{"1104": {"callee_method_names": ["ChemComp.getId"], "method_name": "ChemicalComponentDictionary.getReplacer", "method_implementation": "{\n    return getReplacer(c.getId());\n}", "repo_id": "9", "comment": "/**\n * If ChemComp is replaced by another one, get the newer version otherwise return the same ChemComp again.\n * @param c\n * @return get the component that replaced ChemComp.\n */\n", "repo_name": "biojava-master/", "id": 1104, "method_signature": "ChemComp getReplacer(ChemComp)"}, "1677": {"callee_method_names": ["Pattern.matcher", "Matcher.matches", "Matcher.group", "Matcher.group", "Matcher.group", "Matcher.group", "ResidueNumber.setChainName", "Matcher.group", "Matcher.group", "Matcher.group", "Matcher.group", "ResidueNumber.setChainName", "Pattern.matcher"], "method_name": "ResidueRange.parse", "method_implementation": "{\n    Matcher matcher = RANGE_REGEX.matcher(s);\n    if (matcher.matches()) {\n        ResidueNumber start = null, end = null;\n        String chain = null;\n        try {\n            chain = matcher.group(1);\n            if (matcher.group(2) != null) {\n                // ^ indicates first res (start==null)\n                if (!\"^\".equals(matcher.group(2))) {\n                    start = ResidueNumber.fromString(matcher.group(2));\n                    start.setChainName(chain);\n                }\n            }\n            if (matcher.group(3) == null) {\n                // single-residue range\n                end = start;\n            } else // $ indicates last res (end==null)\n            if (matcher.group(4) != null && !\"$\".equals(matcher.group(4))) {\n                end = ResidueNumber.fromString(matcher.group(4));\n                end.setChainName(chain);\n            }\n            return new ResidueRange(chain, start, end);\n        } catch (IllegalStateException e) {\n            throw new IllegalArgumentException(\"Range \" + s + \" was not valid\", e);\n        }\n    } else if (CHAIN_REGEX.matcher(s).matches()) {\n        return new ResidueRange(s, (ResidueNumber) null, null);\n    }\n    throw new IllegalArgumentException(\"Illegal ResidueRange format:\" + s);\n}", "repo_id": "9", "comment": "/**\n * Parse the residue range from a string. Several formats are accepted:\n * <ul>\n *   <li> chainName.start-end\n *   <li> chainName.residue\n *   <li> chain_start-end (for better filename compatibility)\n * </ul>\n *\n * <p>Residues can be positive or negative and may include insertion codes.\n * See {@link ResidueNumber#fromString(String)}.\n *\n * <p>Examples:\n * <ul>\n * <li><code>A:5-100</code>\n * <li><code>A_5-100</code>\n * <li><code>A_-5</code>\n * <li><code>A:-12I-+12I</code>\n * <li><code>A:^-$</code>\n * </ul>\n *\n * @param s   residue string to parse\n * @return The unique ResidueRange corresponding to {@code s}\n */\n", "repo_name": "biojava-master/", "id": 1677, "method_signature": "ResidueRange parse(String)"}, "1958": {"callee_method_names": ["Matrix4d.setTranslation", "Matrix4d.mul"], "method_name": "C2RotationSolver.combineWithTranslation", "method_implementation": "{\n    rotation.setTranslation(centroid);\n    rotation.mul(rotation, centroidInverse);\n}", "repo_id": "9", "comment": "/**\n * Adds translational component to rotation matrix\n * @param rotation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1958, "method_signature": "void combineWithTranslation(Matrix4d)"}, "2942": {"callee_method_names": ["SequenceReader<C>.getAsList"], "method_name": "AbstractSequence.getAsList", "method_implementation": "{\n    return sequenceStorage.getAsList();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2942, "method_signature": "List<C> getAsList()"}, "3037": {"callee_method_names": ["int.getStart", "ResidueNumber.getStart"], "method_name": "Tools.getMin", "method_implementation": "{\n    return scanLocations(locations, new LocationPredicate() {\n\n        @Override\n        public boolean accept(Location previous, Location current) {\n            int res = current.getStart().compareTo(previous.getStart());\n            return res < 0;\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Scans through a list of locations to find the Location with the\n * lowest start\n */\n", "repo_name": "biojava-master/", "id": 3037, "method_signature": "Location getMin(List)"}, "1921": {"callee_method_ids": [1939, 1941, 1943, 1945, 1947, 1949, 1951, 1955, 1953, 1957], "callee_method_names": ["ArrayList.size", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setMinRmsd", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setMaxRmsd", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setRmsd", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setMinTm", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setMaxTm", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setTm", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setRmsdCenters", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setTmIntra", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setRmsdIntra", "QuatSymmetryScores.setSymDeviation"], "method_name": "HelixLayers.getScores", "method_implementation": "{\n    QuatSymmetryScores scores = new QuatSymmetryScores();\n    double[] values = new double[helices.size()];\n    // minRmsd\n    for (int i = 0; i < helices.size(); i++) {\n        values[i] = helices.get(i).getScores().getMinRmsd();\n    }\n    scores.setMinRmsd(minScores(values));\n    // maxRmsd\n    for (int i = 0; i < helices.size(); i++) {\n        values[i] = helices.get(i).getScores().getMaxRmsd();\n    }\n    scores.setMaxRmsd(maxScores(values));\n    // Rmsd\n    for (int i = 0; i < helices.size(); i++) {\n        values[i] = helices.get(i).getScores().getRmsd();\n    }\n    scores.setRmsd(averageScores(values));\n    // minTm\n    for (int i = 0; i < helices.size(); i++) {\n        values[i] = helices.get(i).getScores().getMinTm();\n    }\n    scores.setMinTm(minScores(values));\n    // maxTm\n    for (int i = 0; i < helices.size(); i++) {\n        values[i] = helices.get(i).getScores().getMaxTm();\n    }\n    scores.setMaxTm(maxScores(values));\n    // Tm\n    for (int i = 0; i < helices.size(); i++) {\n        values[i] = helices.get(i).getScores().getTm();\n    }\n    scores.setTm(averageScores(values));\n    // Rmsd subunit centers\n    for (int i = 0; i < helices.size(); i++) {\n        values[i] = helices.get(i).getScores().getRmsdCenters();\n    }\n    scores.setRmsdCenters(averageScores(values));\n    // TmIntra\n    for (int i = 0; i < helices.size(); i++) {\n        values[i] = helices.get(i).getScores().getTmIntra();\n    }\n    scores.setTmIntra(averageScores(values));\n    // RmsdIntra\n    for (int i = 0; i < helices.size(); i++) {\n        values[i] = helices.get(i).getScores().getRmsdIntra();\n    }\n    scores.setRmsdIntra(averageScores(values));\n    // SymDeviation\n    scores.setSymDeviation(symmetryDeviation);\n    return scores;\n}", "repo_id": "9", "comment": "/**\n * Returns QuatSymmetryScores averaged over all rotations\n * (except the first rotation, which is the unit operation E)\n * @return mean scores average over rotations\n */\n", "repo_name": "biojava-master/", "id": 1921, "method_signature": "QuatSymmetryScores getScores()"}, "1161": {"callee_method_ids": [1359], "callee_method_names": ["Group.getChemComp", "AminoAcidImpl.setAminoType"], "method_name": "PDBFileParser.getNewGroup", "method_implementation": "{\n    Group g = ChemCompGroupFactory.getGroupFromChemCompDictionary(aminoCode3);\n    if (g != null && !g.getChemComp().isEmpty())\n        return g;\n    Group group;\n    if (aminoCode1 == null || StructureTools.UNKNOWN_GROUP_LABEL == aminoCode1) {\n        group = new HetatomImpl();\n    } else if (StructureTools.isNucleotide(aminoCode3)) {\n        // it is a nucleotide\n        NucleotideImpl nu = new NucleotideImpl();\n        group = nu;\n    } else {\n        AminoAcidImpl aa = new AminoAcidImpl();\n        aa.setAminoType(aminoCode1);\n        group = aa;\n    }\n    //\t\tSystem.out.println(\"new resNum type: \"+ resNum.getType() );\n    return group;\n}", "repo_id": "9", "comment": "/**\n * initiate new resNum, either Hetatom, Nucleotide, or AminoAcid\n */\n", "repo_name": "biojava-master/", "id": 1161, "method_signature": "Group getNewGroup(String, Character, String)"}, "737": {"callee_method_names": ["Matrix.print", "Atom.getGroup"], "method_name": "CeCalculatorEnhanced.calc_rmsd", "method_implementation": "{\n    Atom[] cod1 = getAtoms(pro1, strLen, false);\n    Atom[] cod2 = getAtoms(pro2, strLen, true);\n    Matrix4d trans = SuperPositions.superpose(Calc.atomsToPoints(cod1), Calc.atomsToPoints(cod2));\n    Matrix matrix = Matrices.getRotationJAMA(trans);\n    Atom shift = Calc.getTranslationVector(trans);\n    if (debug) {\n        matrix.print(3, 3);\n    }\n    if (storeTransform) {\n        r = matrix;\n        t = shift;\n    }\n    for (Atom a : cod2) Calc.transform(a.getGroup(), trans);\n    //Calc.rotate(a,r);\n    //Calc.shift(a,t);\n    //\t\tif ( show){\n    //\t\t\tStructureAlignmentJmol jmol = new StructureAlignmentJmol();\n    //\n    //\t\t\tjmol.setAtoms(cod1);\n    //\t\t\tjmol.evalString(\"select * ; wireframe off; spacefill off;  backbone on; color chain; select ligand;color cpk; wireframe 40;spacefill 120;  \");\n    //\t\t\tjmol.setTitle(\"calCaRmsd - pdb1\");\n    //\n    //\t\t\tStructureAlignmentJmol jmol2 = new StructureAlignmentJmol();\n    //\t\t\tjmol2.setAtoms(cod2);\n    //\t\t\tjmol2.evalString(\"select * ; wireframe off; spacefill off;  backbone on; color chain; select ligand;color cpk; wireframe 40;spacefill 120;  \");\n    //\t\t\tjmol2.setTitle(\"calCaRmsd - pdb2\");\n    //\t\t}\n    return Calc.rmsd(cod1, cod2);\n}", "repo_id": "9", "comment": "/**\n * superimpose and get rmsd\n *\n * @param pro1\n * @param pro2\n * @param strLen\n * @param storeTransform\n * @param show\n * @return RMSD\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 737, "method_signature": "double calc_rmsd(Atom[], Atom[], int, boolean, boolean)"}, "2737": {"callee_method_names": [], "method_name": "EmblRecord.getAccessionNumber", "method_implementation": "{\n    return accessionNumber;\n}", "repo_id": "9", "comment": "/**\n * The AC (Accession number) line lists the accession numbers associated with\n * the entry.\n *\n * @return List<String>\n */\n", "repo_name": "biojava-master/", "id": 2737, "method_signature": "List<String> getAccessionNumber()"}, "34": {"callee_method_names": [], "method_name": "StockholmFileAnnotation.getNoiseCutoffs", "method_implementation": "{\n    return noiseCutoffs;\n}", "repo_id": "9", "comment": "/**\n * Not always 2.<br>\n *  It may undergo further change.\n *  @return\n */\n", "repo_name": "biojava-master/", "id": 34, "method_signature": "float[] getNoiseCutoffs()"}, "3210": {"callee_method_names": ["BlastTabularParser.setFile", "BlastTabularParser.createObjects", "List<Hsp>.add", "List<Hsp>.add", "List<Hit>.add", "List<Result>.get", "Result.iterator", "Hit.iterator", "BlastTabularParser.setFile", "BlastTabularParser.createObjects", "List<Result>.get", "Result.iterator", "Hit.iterator", "Result.getQueryID", "List<Result>.size"], "method_name": "BlastTabularParserTest.testCreateObjects", "method_implementation": "{\n    System.out.println(\"createObjects\");\n    Result expRes1;\n    Hit expHit1res1;\n    Hsp expHsp1hit1res1;\n    String resource = \"/org/biojava/nbio/core/search/io/blast/small-blastreport.blasttxt\";\n    File file = getFileForResource(resource);\n    BlastTabularParser instance = new BlastTabularParser();\n    instance.setFile(file);\n    List<Result> results = instance.createObjects(1e-10);\n    BlastHsp hsp1Hit1Res1 = new BlastHspBuilder().setHspNum(1).setPercentageIdentity(100.0 / 100).setHspAlignLen(1567).setMismatchCount(0).setHspGaps(0).setHspQueryFrom(1).setHspQueryTo(1567).setHspHitFrom(616309).setHspQueryTo(617875).setHspEvalue(0).setHspBitScore(2894).createBlastHsp();\n    BlastHsp hsp1Hit1Res2 = new BlastHspBuilder().setHspNum(1).setPercentageIdentity(100.0 / 100).setHspAlignLen(1567).setMismatchCount(0).setHspGaps(0).setHspQueryFrom(1).setHspQueryTo(1567).setHspHitFrom(1278699).setHspQueryTo(1277133).setHspEvalue(0).setHspBitScore(2894).createBlastHsp();\n    List<Hsp> hsplist = new ArrayList<Hsp>();\n    hsplist.add(hsp1Hit1Res1);\n    hsplist.add(hsp1Hit1Res2);\n    BlastHit hit1Res1 = new BlastHitBuilder().setHitDef(\"CP000411\").setHsps(hsplist).createBlastHit();\n    List<Hit> hitlist = new ArrayList<Hit>();\n    hitlist.add(hit1Res1);\n    BlastResult res1 = new BlastResultBuilder().setQueryID(\"CP000411_-_16S_rRNA\").setQueryDef(\"CP000411_-_16S_rRNA\").setHits(hitlist).createBlastResult();\n    expRes1 = results.get(0);\n    expHit1res1 = expRes1.iterator().next();\n    expHsp1hit1res1 = expHit1res1.iterator().next();\n    // results test\n    assertEquals(expRes1, res1);\n    // hit test\n    assertEquals(expHit1res1, hit1Res1);\n    // hsp test\n    assertEquals(expHsp1hit1res1, hsp1Hit1Res1);\n    String resource2 = \"/org/biojava/nbio/core/search/io/blast/testBlastTabularReport.txt\";\n    File file2 = getFileForResource(resource2);\n    BlastTabularParser instance2 = new BlastTabularParser();\n    instance2.setFile(file2);\n    List<Result> results2 = instance2.createObjects(1e-10);\n    expRes1 = results2.get(0);\n    expHit1res1 = expRes1.iterator().next();\n    expHsp1hit1res1 = expHit1res1.iterator().next();\n    hsp1Hit1Res1 = new BlastHspBuilder().setPercentageIdentity(100.00 / 100).setHspAlignLen(48).setMismatchCount(0).setHspGaps(0).setHspQueryFrom(1).setHspQueryTo(48).setHspHitFrom(344).setHspHitTo(391).setHspEvalue(4e-19).setHspBitScore(95.6).createBlastHsp();\n    // results test\n    assertEquals(expRes1.getQueryID(), \"1_759_906_F3\");\n    assertEquals(results2.size(), 298);\n    // only one hsp test\n    assertEquals(expHsp1hit1res1, hsp1Hit1Res1);\n}", "repo_id": "9", "comment": "/**\n * Test of createObjects method, of class BlastTabularParser.\n */\n", "repo_name": "biojava-master/", "id": 3210, "method_signature": "void testCreateObjects()"}, "2877": {"callee_method_names": [], "method_name": "ABITrace.isABI", "method_implementation": "{\n    char[] ABI = new char[4];\n    for (int i = 0; i <= 2; i++) {\n        ABI[i] = (char) traceData[i];\n    }\n    if (ABI[0] == 'A' && (ABI[1] == 'B' && ABI[2] == 'I')) {\n        return true;\n    } else {\n        for (int i = 128; i <= 130; i++) {\n            ABI[i - 128] = (char) traceData[i];\n        }\n        if (ABI[0] == 'A' && (ABI[1] == 'B' && ABI[2] == 'I')) {\n            macJunk = 128;\n            return true;\n        } else\n            return false;\n    }\n}", "repo_id": "9", "comment": "/**\n * Test to see if the file is ABI format by checking to see that the first three bytes\n * are \"ABI\". Also handle the special case where 128 bytes were prepended to the file\n * due to binary FTP from an older macintosh system.\n *\n * @return - if format of ABI file is correct\n */\n", "repo_name": "biojava-master/", "id": 2877, "method_signature": "boolean isABI()"}, "3170": {"callee_method_ids": [3077, 3077, 3077, 3077, 3077, 2637, 2686, 2634], "callee_method_names": ["ArrayList.size", "ArrayList.get", "CDSSequence.getCodingSequence", "String.substring", "String.length", "String.substring", "String.length", "ArrayList.size", "ArrayList.get", "CDSSequence.getCodingSequence", "String.substring", "CDSSequence.getCodingSequence", "String.substring", "String.substring", "String.length", "String.substring", "String.length", "ArrayList.size", "ArrayList.get", "CDSSequence.getCodingSequence", "String.substring", "CDSSequence.getCodingSequence", "String.substring", "String.toUpperCase", "Logger.error", "Enumeration<JarEntry>.getMessage", "DNASequence.getRNASequence", "RNASequence.getProteinSequence", "ProteinSequence.setAccession", "CDSSequence.getAccession", "ProteinSequence.setParentDNASequence", "CDSSequence.getLength", "ArrayList<ProteinSequence>.add"], "method_name": "TranscriptSequence.getProteinCDSSequences", "method_implementation": "{\n    ArrayList<ProteinSequence> proteinSequenceList = new ArrayList<ProteinSequence>();\n    for (int i = 0; i < cdsSequenceList.size(); i++) {\n        CDSSequence cdsSequence = cdsSequenceList.get(i);\n        String codingSequence = cdsSequence.getCodingSequence();\n        //          logger.debug(\"CDS {} {} = {}\", getStrand(), cdsSequence.getPhase(), codingSequence);\n        if (this.getStrand() == Strand.NEGATIVE) {\n            if (cdsSequence.phase == 1) {\n                codingSequence = codingSequence.substring(1, codingSequence.length());\n            } else if (cdsSequence.phase == 2) {\n                codingSequence = codingSequence.substring(2, codingSequence.length());\n            }\n            if (i < cdsSequenceList.size() - 1) {\n                CDSSequence nextCDSSequence = cdsSequenceList.get(i + 1);\n                if (nextCDSSequence.phase == 1) {\n                    String nextCodingSequence = nextCDSSequence.getCodingSequence();\n                    codingSequence = codingSequence + nextCodingSequence.substring(0, 1);\n                } else if (nextCDSSequence.phase == 2) {\n                    String nextCodingSequence = nextCDSSequence.getCodingSequence();\n                    codingSequence = codingSequence + nextCodingSequence.substring(0, 2);\n                }\n            }\n        } else {\n            if (cdsSequence.phase == 1) {\n                codingSequence = codingSequence.substring(1, codingSequence.length());\n            } else if (cdsSequence.phase == 2) {\n                codingSequence = codingSequence.substring(2, codingSequence.length());\n            }\n            if (i < cdsSequenceList.size() - 1) {\n                CDSSequence nextCDSSequence = cdsSequenceList.get(i + 1);\n                if (nextCDSSequence.phase == 1) {\n                    String nextCodingSequence = nextCDSSequence.getCodingSequence();\n                    codingSequence = codingSequence + nextCodingSequence.substring(0, 1);\n                } else if (nextCDSSequence.phase == 2) {\n                    String nextCodingSequence = nextCDSSequence.getCodingSequence();\n                    codingSequence = codingSequence + nextCodingSequence.substring(0, 2);\n                }\n            }\n        }\n        //    logger.debug(\"Coding Sequence: {}\", codingSequence);\n        DNASequence dnaCodingSequence = null;\n        try {\n            dnaCodingSequence = new DNASequence(codingSequence.toUpperCase());\n        } catch (CompoundNotFoundException e) {\n            // if I understand this should not happen, please correct if I'm wrong - JD 2014-10-24\n            logger.error(\"Could not create DNA coding sequence, {}. This is most likely a bug.\", e.getMessage());\n        }\n        RNASequence rnaCodingSequence = dnaCodingSequence.getRNASequence(TranscriptionEngine.getDefault());\n        ProteinSequence proteinSequence = rnaCodingSequence.getProteinSequence(TranscriptionEngine.getDefault());\n        proteinSequence.setAccession(new AccessionID(cdsSequence.getAccession().getID()));\n        proteinSequence.setParentDNASequence(cdsSequence, 1, cdsSequence.getLength());\n        proteinSequenceList.add(proteinSequence);\n    }\n    return proteinSequenceList;\n}", "repo_id": "9", "comment": "/**\n * Return a list of protein sequences based on each CDS sequence\n * where the phase shift between two CDS sequences is assigned to the\n * CDS sequence that starts the triplet. This can be used to map\n * a CDS/exon region of a protein sequence back to the DNA sequence\n * If you have a protein sequence and a predicted gene you can take the\n * predict CDS protein sequences and align back to the protein sequence.\n * If you have errors in mapping the predicted protein CDS regions to\n * an the known protein sequence then you can identify possible errors\n * in the prediction\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3170, "method_signature": "ArrayList<ProteinSequence> getProteinCDSSequences()"}, "669": {"callee_method_names": ["MultipleAlignment.size", "MultipleAlignment.getStructureIdentifier", "Map<String, Integer>.containsKey", "Map<String, Integer>.put", "Map<String, Integer>.get", "Map<String, Integer>.get", "Map<String, Integer>.put", "BasicSymmetricalDistanceMatrix.setIdentifier", "Phylogeny.setName"], "method_name": "MultipleAlignmentTools.getStructuralTree", "method_implementation": "{\n    double[][] rmsdMat = MultipleAlignmentTools.getRMSDMatrix(msta).getArray();\n    BasicSymmetricalDistanceMatrix rmsdDist = (BasicSymmetricalDistanceMatrix) DistanceMatrixCalculator.structuralDistance(rmsdMat, 1, 5, 0.4);\n    // Set the identifiers of the matrix\n    Map<String, Integer> alreadySeen = new HashMap<String, Integer>();\n    for (int i = 0; i < msta.size(); i++) {\n        // Make sure the identifiers are unique\n        String id = msta.getStructureIdentifier(i).toString();\n        if (alreadySeen.containsKey(id)) {\n            alreadySeen.put(id, alreadySeen.get(id) + 1);\n            id += \"_\" + alreadySeen.get(id);\n        } else\n            alreadySeen.put(id, 1);\n        rmsdDist.setIdentifier(i, id);\n    }\n    Phylogeny tree = TreeConstructor.distanceTree(rmsdDist, TreeConstructorType.NJ);\n    tree.setName(\"Structural Tree\");\n    return tree;\n}", "repo_id": "9", "comment": "/**\n * Calculate a phylogenetic tree of the MultipleAlignment using RMSD\n * distances and the Neighbor Joining algorithm from forester.\n *\n * @param msta\n *            MultipleAlignment of protein structures\n * @return Phylogeny phylogenetic tree\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 669, "method_signature": "Phylogeny getStructuralTree(MultipleAlignment)"}, "1422": {"callee_method_names": [], "method_name": "UnitCellBoundingBox.getAuBoundingBox", "method_implementation": "{\n    return auBbs[cellIdx];\n}", "repo_id": "9", "comment": "/**\n * Get the AU BoundingBox for the given cell index (cellIdx=0 would be original AU)\n * The AU BoundingBox is the BoundingBox that bounds all chains belonging to the AU\n * @param cellIdx\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1422, "method_signature": "BoundingBox getAuBoundingBox(int)"}, "706": {"callee_method_names": ["Structure.getName", "Structure.getName", "Structure.setName", "Structure.getPDBCode", "Structure.getName", "Structure.getName", "Structure.setName", "File.getName"], "method_name": "AbstractUserArgumentProcessor.fixStructureName", "method_implementation": "{\n    if (s.getName() != null && (!\"\".equals(s.getName())))\n        return s;\n    s.setName(s.getPDBCode());\n    if (s.getName() == null || \"\".equals(s.getName())) {\n        File f = new File(file);\n        s.setName(f.getName());\n    }\n    return s;\n}", "repo_id": "9", "comment": "/**\n * apply a number of rules to fix the name of the structure if it did not get set during loading.\n *\n * @param s\n * @param file\n * @return\n */\n", "repo_name": "biojava-master/", "id": 706, "method_signature": "Structure fixStructureName(Structure, String)"}, "836": {"callee_method_names": ["Map<Integer, List<IndexAndDistance>>.containsKey", "Map<Integer, List<IndexAndDistance>>.put", "Map<Integer, List<IndexAndDistance>>.get", "Map<Integer, List<IndexAndDistance>>.containsKey", "Map<Integer, List<IndexAndDistance>>.put", "Map<Integer, List<IndexAndDistance>>.get", "List<IndexAndDistance>.add", "List<IndexAndDistance>.add", "Map<Integer, List<IndexAndDistance>>.entrySet", "List<IndexAndDistance>.toArray"], "method_name": "AsaCalculator.findNeighborIndicesSpatialHashing", "method_implementation": "{\n    // looking at a typical protein case, number of neighbours are from ~10 to ~50, with an average of ~30\n    int initialCapacity = 60;\n    List<Contact> contactList = calcContacts();\n    Map<Integer, List<IndexAndDistance>> indices = new HashMap<>(atomCoords.length);\n    for (Contact contact : contactList) {\n        // note contacts are stored 1-way only, with j>i\n        int i = contact.getI();\n        int j = contact.getJ();\n        List<IndexAndDistance> iIndices;\n        List<IndexAndDistance> jIndices;\n        if (!indices.containsKey(i)) {\n            iIndices = new ArrayList<>(initialCapacity);\n            indices.put(i, iIndices);\n        } else {\n            iIndices = indices.get(i);\n        }\n        if (!indices.containsKey(j)) {\n            jIndices = new ArrayList<>(initialCapacity);\n            indices.put(j, jIndices);\n        } else {\n            jIndices = indices.get(j);\n        }\n        double radius = radii[i] + probe + probe;\n        double dist = contact.getDistance();\n        if (dist < radius + radii[j]) {\n            iIndices.add(new IndexAndDistance(j, dist));\n            jIndices.add(new IndexAndDistance(i, dist));\n        }\n    }\n    // convert map to array for fast access\n    IndexAndDistance[][] nbsIndices = new IndexAndDistance[atomCoords.length][];\n    for (Map.Entry<Integer, List<IndexAndDistance>> entry : indices.entrySet()) {\n        List<IndexAndDistance> list = entry.getValue();\n        IndexAndDistance[] indexAndDistances = list.toArray(new IndexAndDistance[0]);\n        nbsIndices[entry.getKey()] = indexAndDistances;\n    }\n    // important: some atoms might have no neighbors at all: we need to initialise to empty arrays\n    for (int i = 0; i < nbsIndices.length; i++) {\n        if (nbsIndices[i] == null) {\n            nbsIndices[i] = new IndexAndDistance[0];\n        }\n    }\n    return nbsIndices;\n}", "repo_id": "9", "comment": "/**\n * Returns the 2-dimensional array with neighbor indices for every atom,\n * using spatial hashing to avoid all to all distance calculation.\n * @return 2-dimensional array of size: n_atoms x n_neighbors_per_atom\n */\n", "repo_name": "biojava-master/", "id": 836, "method_signature": "IndexAndDistance[][] findNeighborIndicesSpatialHashing()"}, "10": {"callee_method_names": ["List<S>.size", "List<S>.size", "List<PairwiseSequenceScorer<S, C>>.get", "List<PairwiseSequenceScorer<S, C>>.get"], "method_name": "GuideTree.getScoreMatrix", "method_implementation": "{\n    double[][] matrix = new double[sequences.size()][sequences.size()];\n    for (int i = 0, n = 0; i < matrix.length; i++) {\n        matrix[i][i] = scorers.get(i).getMaxScore();\n        for (int j = i + 1; j < matrix.length; j++) {\n            matrix[i][j] = matrix[j][i] = scorers.get(n++).getScore();\n        }\n    }\n    return matrix;\n}", "repo_id": "9", "comment": "/**\n * Returns the similarity matrix used to construct this guide tree.  The scores have not been normalized.\n *\n * @return the similarity matrix used to construct this guide tree\n */\n", "repo_name": "biojava-master/", "id": 10, "method_signature": "double[][] getScoreMatrix()"}, "1178": {"callee_method_names": ["String.length", "Logger.info", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.length", "String.substring", "String.substring", "Matrix4d.setElement", "Matrix4d.setElement", "Matrix4d.setElement", "Matrix4d.setElement", "List<Matrix4d>.add", "Logger.info", "Element.getMessage"], "method_name": "PDBFileParser.pdb_MTRIXn_Handler", "method_implementation": "{\n    // don't process incomplete records\n    if (line.length() < 55) {\n        logger.info(\"MTRIXn record has fewer than 55 columns: will ignore it\");\n        return;\n    }\n    try {\n        int rowIndex = Integer.parseInt(line.substring(5, 6));\n        double col1Value = Double.parseDouble(line.substring(10, 20));\n        double col2Value = Double.parseDouble(line.substring(20, 30));\n        double col3Value = Double.parseDouble(line.substring(30, 40));\n        double translValue = Double.parseDouble(line.substring(45, 55));\n        int iGiven = 0;\n        if (line.length() >= 60 && !line.substring(59, 60).trim().isEmpty()) {\n            iGiven = Integer.parseInt(line.substring(59, 60));\n        }\n        if (iGiven == 1)\n            return;\n        if (ncsOperators == null) {\n            // we initialise on first pass\n            ncsOperators = new ArrayList<Matrix4d>();\n        }\n        if (currentNcsOp == null) {\n            // initialised to identity\n            currentNcsOp = new Matrix4d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        }\n        currentNcsOp.setElement(rowIndex - 1, 0, col1Value);\n        currentNcsOp.setElement(rowIndex - 1, 1, col2Value);\n        currentNcsOp.setElement(rowIndex - 1, 2, col3Value);\n        currentNcsOp.setElement(rowIndex - 1, 3, translValue);\n        if (rowIndex == 3) {\n            ncsOperators.add(currentNcsOp);\n            // we initialise for next matrix to come\n            // initialised to identity\n            currentNcsOp = new Matrix4d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        }\n    } catch (NumberFormatException e) {\n        logger.info(\"Could not parse a number in MTRIXn record (\" + e.getMessage() + \") from line: >\" + line + \"<\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Handler for MTRIXn records. They specify extra NCS operators (usually in virus entries)\n *\n * See http://www.wwpdb.org/documentation/format33/sect8.html#MTRIXn\n * <pre>\n * COLUMNS        DATA TYPE     FIELD         DEFINITION\n * -------------------------------------------------------------\n *\n *  1 -  6        Record name   \"MTRIXn\"      n=1, 2, or 3\n *  8 - 10        Integer       serial        Serial number.\n * 11 - 20        Real(10.6)    m[n][1]       Mn1\n * 21 - 30        Real(10.6)    m[n][2]       Mn2\n * 31 - 40        Real(10.6)    m[n][3]       Mn3\n * 46 - 55        Real(10.5)    v[n]          Vn\n * 60             Integer       iGiven        1\n *\n * </pre>\n * Note that we ignore operators with iGiven==1\n *\n * @param line\n */\n", "repo_name": "biojava-master/", "id": 1178, "method_signature": "void pdb_MTRIXn_Handler(String)"}, "903": {"callee_method_ids": [874, 875, 874, 875, 832, 874, 875, 874, 875, 876, 874, 873, 874, 883, 885, 885, 883], "callee_method_names": ["List<StructureInterface>.add", "StructureInterface.getMoleculeIds", "StructureInterface.getTransforms", "StructureInterface.getMoleculeIds", "StructureInterface.getTransforms", "Map<String, Atom[]>.put", "StructureInterface.getFirstAtomsForAsa", "Map<String, Atom[]>.put", "StructureInterface.getSecondAtomsForAsa", "Logger.debug", "Map<String, Atom[]>.size", "Map<String, Atom[]>.keySet", "Logger.debug", "Map<String, Atom[]>.get", "Map<String, Atom[]>.get", "AsaCalculator.calculateAsas", "Map<String, double[]>.put", "Logger.debug", "Map<String, Atom[]>.size", "Logger.debug", "List<StructureInterface>.size", "StructureInterface.getMoleculeIds", "StructureInterface.getTransforms", "StructureInterface.getMoleculeIds", "StructureInterface.getTransforms", "Logger.debug", "StructureInterface.getId", "StructureInterface.setAsas", "Map<String, double[]>.get", "Map<String, double[]>.get", "Logger.debug", "List<StructureInterface>.size", "Logger.warn", "StructureInterface.getMoleculeIds", "StructureInterface.setTotalArea", "StructureInterface.getTotalArea", "StructureInterface.getMoleculeIds", "StructureInterface.setFirstGroupAsas", "StructureInterface.getFirstGroupAsas", "StructureInterface.setSecondGroupAsas", "StructureInterface.getSecondGroupAsas", "StructureInterface.setFirstGroupAsas", "StructureInterface.getSecondGroupAsas", "StructureInterface.setSecondGroupAsas", "StructureInterface.getFirstGroupAsas"], "method_name": "StructureInterfaceList.calcAsas", "method_implementation": "{\n    // asa/bsa calculation\n    // NOTE in principle it is more efficient to calculate asas only once per unique chain\n    // BUT! the rolling ball algorithm gives slightly different values for same molecule in different\n    // rotations (due to sampling depending on orientation of axes grid).\n    // Both NACCESS and our own implementation behave like that.\n    // That's why we calculate ASAs for each rotation-unique molecule, otherwise\n    // we get discrepancies (not very big but annoying) which lead to things like negative (small) bsa values\n    Map<String, Atom[]> uniqAsaChains = new TreeMap<>();\n    Map<String, double[]> chainAsas = new TreeMap<>();\n    List<StructureInterface> redundancyReducedList;\n    if (clustersNcs != null) {\n        redundancyReducedList = new ArrayList<>();\n        for (StructureInterfaceCluster ncsCluster : clustersNcs) {\n            // we use the first one in list as the only one for which we calculate ASAs\n            redundancyReducedList.add(ncsCluster.getMembers().get(0));\n        }\n    } else {\n        redundancyReducedList = list;\n    }\n    // first we gather rotation-unique chains (in terms of AU id and transform id)\n    for (StructureInterface interf : redundancyReducedList) {\n        String molecId1 = interf.getMoleculeIds().getFirst() + interf.getTransforms().getFirst().getTransformId();\n        String molecId2 = interf.getMoleculeIds().getSecond() + interf.getTransforms().getSecond().getTransformId();\n        uniqAsaChains.put(molecId1, interf.getFirstAtomsForAsa(cofactorSizeToUse));\n        uniqAsaChains.put(molecId2, interf.getSecondAtomsForAsa(cofactorSizeToUse));\n    }\n    logger.debug(\"Will calculate uncomplexed ASA for {} orientation-unique chains.\", uniqAsaChains.size());\n    long start = System.currentTimeMillis();\n    // we only need to calculate ASA for that subset (any translation of those will have same values)\n    for (String molecId : uniqAsaChains.keySet()) {\n        logger.debug(\"Calculating uncomplexed ASA for molecId {}, with {} atoms\", molecId, uniqAsaChains.get(molecId).length);\n        AsaCalculator asaCalc = new AsaCalculator(uniqAsaChains.get(molecId), AsaCalculator.DEFAULT_PROBE_SIZE, nSpherePoints, nThreads);\n        double[] atomAsas = asaCalc.calculateAsas();\n        chainAsas.put(molecId, atomAsas);\n    }\n    long end = System.currentTimeMillis();\n    logger.debug(\"Calculated uncomplexed ASA for {} orientation-unique chains. Time: {} s\", uniqAsaChains.size(), ((end - start) / 1000.0));\n    logger.debug(\"Will calculate complexed ASA for {} pairwise complexes.\", redundancyReducedList.size());\n    start = System.currentTimeMillis();\n    // now we calculate the ASAs for each of the complexes\n    for (StructureInterface interf : redundancyReducedList) {\n        String molecId1 = interf.getMoleculeIds().getFirst() + interf.getTransforms().getFirst().getTransformId();\n        String molecId2 = interf.getMoleculeIds().getSecond() + interf.getTransforms().getSecond().getTransformId();\n        logger.debug(\"Calculating complexed ASAs for interface {} between molecules {} and {}\", interf.getId(), molecId1, molecId2);\n        interf.setAsas(chainAsas.get(molecId1), chainAsas.get(molecId2), nSpherePoints, nThreads, cofactorSizeToUse);\n    }\n    end = System.currentTimeMillis();\n    logger.debug(\"Calculated complexes ASA for {} pairwise complexes. Time: {} s\", redundancyReducedList.size(), ((end - start) / 1000.0));\n    // now let's populate the interface area value for the NCS-redundant ones from the reference interface (first one in list)\n    if (clustersNcs != null) {\n        if (chainOrigNamesMap == null) {\n            logger.warn(\"No chainOrigNamesMap is set. Considering NCS interfaces in same order as reference. This is likely a bug.\");\n        }\n        for (StructureInterfaceCluster ncsCluster : clustersNcs) {\n            StructureInterface refInterf = ncsCluster.getMembers().get(0);\n            String refMolecId1 = refInterf.getMoleculeIds().getFirst();\n            for (int i = 1; i < ncsCluster.getMembers().size(); i++) {\n                StructureInterface member = ncsCluster.getMembers().get(i);\n                member.setTotalArea(refInterf.getTotalArea());\n                String molecId1 = member.getMoleculeIds().getFirst();\n                if (areMolecIdsSameOrder(refMolecId1, molecId1)) {\n                    // we add the reference interface GroupAsas as the GroupAsas for all other members, like that\n                    // ResidueNumbers won't match in their chain ids, but otherwise all info is there without using a lot of memory\n                    member.setFirstGroupAsas(refInterf.getFirstGroupAsas());\n                    member.setSecondGroupAsas(refInterf.getSecondGroupAsas());\n                } else {\n                    member.setFirstGroupAsas(refInterf.getSecondGroupAsas());\n                    member.setSecondGroupAsas(refInterf.getFirstGroupAsas());\n                }\n            }\n        }\n    }\n    // finally we sort based on the ChainInterface.comparable() (based in interfaceArea)\n    sort();\n}", "repo_id": "9", "comment": "/**\n * Calculates ASAs for all interfaces in list, both for the unbound\n * chains and for the complex of the two chains together.\n * Also sorts the interfaces based on calculated BSA areas (descending)\n * @param nSpherePoints\n * @param nThreads\n * @param cofactorSizeToUse the minimum size of cofactor molecule (non-chain HET atoms) that will be used\n */\n", "repo_name": "biojava-master/", "id": 903, "method_signature": "void calcAsas(int, int, int)"}, "1297": {"callee_method_names": [], "method_name": "StructureSequenceMatcher.removeGaps", "method_implementation": "{\n    if (gapped == null)\n        return null;\n    if (gapped.length < 1)\n        return Arrays.copyOf(gapped, gapped.length);\n    final int nProts = gapped.length;\n    // length of gapped proteins\n    final int protLen = gapped[0].length;\n    // Verify that input is rectangular\n    for (int i = 0; i < nProts; i++) {\n        if (gapped[i].length != protLen) {\n            throw new IllegalArgumentException(String.format(\"Expected a rectangular array, but row 0 has %d elements \" + \"while row %d has %d.\", protLen, i, gapped[i].length));\n        }\n    }\n    // determine where gaps exist in any structures\n    boolean[] isGap = new boolean[protLen];\n    int gaps = 0;\n    for (int j = 0; j < protLen; j++) {\n        for (int i = 0; i < nProts; i++) {\n            if (gapped[i][j] == null) {\n                isGap[j] = true;\n                gaps++;\n                //go to next position\n                break;\n            }\n        }\n    }\n    // Create ungapped array\n    T[][] ungapped = Arrays.copyOf(gapped, nProts);\n    final int ungappedLen = protLen - gaps;\n    for (int i = 0; i < nProts; i++) {\n        ungapped[i] = Arrays.copyOf(gapped[i], ungappedLen);\n        int k = 0;\n        for (int j = 0; j < protLen; j++) {\n            if (!isGap[j]) {\n                //skip gaps\n                assert (gapped[i][j] != null);\n                ungapped[i][k] = gapped[i][j];\n                k++;\n            }\n        }\n        assert (k == ungappedLen);\n    }\n    return ungapped;\n}", "repo_id": "9", "comment": "/**\n * Creates a new list consisting of all columns of gapped where no row\n * contained a null value.\n *\n * Here, \"row\" refers to the first index and \"column\" to the second, eg\n * gapped.get(row).get(column)\n * @param gapped A rectangular matrix containing null to mark gaps\n * @return A new List without columns containing nulls\n */\n", "repo_name": "biojava-master/", "id": 1297, "method_signature": "T[][] removeGaps(T[][])"}, "1925": {"callee_method_names": ["List<Subunit>.size"], "method_name": "QuatSymmetryResults.getSubunitCount", "method_implementation": "{\n    return subunits.size();\n}", "repo_id": "9", "comment": "/**\n * Return the number of Subunits involved in the symmetry.\n *\n * @return the number of Subunits\n */\n", "repo_name": "biojava-master/", "id": 1925, "method_signature": "int getSubunitCount()"}, "3825": {"callee_method_names": ["ArrayList.size"], "method_name": "MetaDataInfo.getNumberDiscreteValues", "method_implementation": "{\n    return discreteValues.size();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3825, "method_signature": "int getNumberDiscreteValues()"}, "1415": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.getNcsOperators", "method_implementation": "{\n    return ncsOperators;\n}", "repo_id": "9", "comment": "/**\n * Get the NCS operators.\n * Some PDB files contain NCS operators necessary to create the full AU.\n * Usually this happens for viral proteins.\n * See http://www.wwpdb.org/documentation/format33/sect8.html#MTRIXn .\n * Note that the \"given\" operators\n * (iGiven field =1 in PDB format, \"given\" string in _struct_ncs_oper.code in mmCIF format)\n * are not stored.\n * @return the operators or null if no operators present\n */\n", "repo_name": "biojava-master/", "id": 1415, "method_signature": "Matrix4d[] getNcsOperators()"}, "3376": {"callee_method_ids": [3339, 3339], "callee_method_names": ["Graphics2D.getClipBounds", "Graphics2D.setColor", "CoordManager.getSeqPos", "CoordManager.getSeqPos", "List<AlignedPosition>.size", "List<AlignedPosition>.size", "CoordManager.getPanelPos", "CoordManager.getPanelPos", "Graphics2D.setColor", "Graphics2D.fill", "Graphics2D.setColor", "Graphics2D.fill", "List<AlignedPosition>.size", "CoordManager.getPanelPos", "List<AlignedPosition>.get", "AlignedPosition.getPos", "Graphics2D.setColor", "Graphics2D.fillRect", "Graphics2D.setColor", "AlignedPosition.getPos", "Graphics2D.setColor", "Graphics2D.fillRect", "Graphics2D.setColor", "Graphics2D.drawString", "Graphics2D.setColor", "Graphics2D.fillRect", "Graphics2D.setColor", "Graphics2D.drawString", "Graphics2D.setColor", "Graphics2D.fillRect", "Graphics2D.setColor", "Graphics2D.drawString", "CoordManager.getPanelPos", "Graphics2D.drawString"], "method_name": "SequenceScalePanel.drawScale", "method_implementation": "{\n    // only draw within the ranges of the Clip\n    Rectangle drawHere = g2D.getClipBounds();\n    g2D.setColor(SCALE_COLOR);\n    int aminosize = Math.round(1 * scale);\n    if (aminosize < 1)\n        aminosize = 1;\n    int startpos = coordManager.getSeqPos(drawHere.x);\n    int endpos = coordManager.getSeqPos(drawHere.x + drawHere.width);\n    if (endpos > apos.size())\n        endpos = apos.size();\n    int l = endpos - startpos + 1;\n    int drawStart = coordManager.getPanelPos(startpos);\n    int drawEnd = coordManager.getPanelPos(l) - DEFAULT_X_START + aminosize;\n    //\t\tSystem.out.println(\"SeqScalePanel drawing scale s:\" + startpos + \" e: \" + endpos +\n    //\t\t\t\t\" ps: \" + drawStart + \" pe:\" + drawEnd  + \" draw.x \" + drawHere.x + \" draw.w \" + drawHere.width +\n    //\t\t\t\t\" scale \" + scale);\n    //\t\tthe frame around the sequence box\n    if (scale < SEQUENCE_SHOW) {\n        g2D.setColor(SEQUENCE_COLOR);\n        //g2D.setColor(Color.blue);\n        Rectangle seqline = new Rectangle(drawStart, y, drawEnd, LINE_HEIGHT);\n        //g2D=  (Graphics2D)g;\n        g2D.fill(seqline);\n        //g2D.setColor(Color.blue);\n        //g2D.draw(seqline);\n    }\n    // the top line for the scale\n    g2D.setColor(SCALE_COLOR);\n    Rectangle baseline = new Rectangle(drawStart, y, drawEnd, 2);\n    g2D.fill(baseline);\n    // draw the vertical ticks\n    int lineH = 11;\n    if (scale <= 3)\n        lineH = 8;\n    for (int gap = startpos; ((gap <= endpos) && (gap < apos.size())); gap++) {\n        int xpos = coordManager.getPanelPos(gap);\n        AlignedPosition m = apos.get(gap);\n        if (m.getPos(position) == -1) {\n            // a gap position\n            g2D.setColor(GAP_COLOR);\n            g2D.fillRect(xpos, y + 2, aminosize + 1, y + lineH);\n            g2D.setColor(GAP_COLOR);\n            continue;\n        }\n        int i = m.getPos(position);\n        if (((i + 1) % 100) == 0) {\n            if (scale > 0.1) {\n                g2D.setColor(TEXT_SCALE_COLOR);\n                g2D.fillRect(xpos, y + 2, aminosize, y + lineH);\n                g2D.setColor(SCALE_COLOR);\n                if (scale < SEQUENCE_SHOW)\n                    g2D.drawString(String.valueOf(i + 1), xpos, y + DEFAULT_Y_STEP);\n            }\n        } else if (((i + 1) % 50) == 0) {\n            if (scale > 1.4) {\n                g2D.setColor(TEXT_SCALE_COLOR);\n                g2D.fillRect(xpos, y + 2, aminosize, y + lineH);\n                g2D.setColor(SCALE_COLOR);\n                if (scale < SEQUENCE_SHOW)\n                    g2D.drawString(String.valueOf(i + 1), xpos, y + DEFAULT_Y_STEP);\n            }\n        } else if (((i + 1) % 10) == 0) {\n            if (scale > 3) {\n                g2D.setColor(TEXT_SCALE_COLOR);\n                g2D.fillRect(xpos, y + 2, aminosize, y + lineH);\n                g2D.setColor(SCALE_COLOR);\n                if (scale < SEQUENCE_SHOW)\n                    g2D.drawString(String.valueOf(i + 1), xpos, y + DEFAULT_Y_STEP);\n            }\n        }\n    }\n    int length = chainLength;\n    if (endpos >= length - 1) {\n        int endPanel = coordManager.getPanelPos(endpos);\n        g2D.drawString(String.valueOf(length), endPanel + 10, y + DEFAULT_Y_STEP);\n    }\n    return y;\n}", "repo_id": "9", "comment": "/**\n * draw the Scale\n *\n * @param g2D\n * @param y the height on which to draw the scale\n * @return the new y position\n */\n", "repo_name": "biojava-master/", "id": 3376, "method_signature": "int drawScale(Graphics2D, int)"}, "3108": {"callee_method_names": [], "method_name": "DBReferenceInfo.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * @return the id\n */\n", "repo_name": "biojava-master/", "id": 3108, "method_signature": "String getId()"}, "1623": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setSequenceIdentityThreshold", "method_implementation": "{\n    this.sequenceIdentityThreshold = sequenceIdentityThreshold;\n}", "repo_id": "9", "comment": "/**\n * Sequence identity threshold to consider for the sequence subunit\n * clustering.\n * <p>\n * Two subunits with sequence identity equal or higher than the threshold\n * will be clustered together.\n *\n * @param sequenceIdentityThreshold\n */\n", "repo_name": "biojava-master/", "id": 1623, "method_signature": "void setSequenceIdentityThreshold(double)"}, "761": {"callee_method_names": [], "method_name": "CeParameters.setSubstitutionMatrix", "method_implementation": "{\n    this.substitutionMatrix = substitutionMatrix;\n}", "repo_id": "9", "comment": "/**\n * Sets the  substitution matrix to be used for influencing the alignment with sequence conservation information.\n * Default: SDM matrix (Prlic et al 2000)\n * @param substitutionMatrix\n */\n", "repo_name": "biojava-master/", "id": 761, "method_signature": "void setSubstitutionMatrix(SubstitutionMatrix)"}, "2717": {"callee_method_names": [], "method_name": "BufferedReaderBytesRead.skip", "method_implementation": "{\n    if (n < 0L) {\n        throw new IllegalArgumentException(\"skip value is negative\");\n    }\n    synchronized (lock) {\n        ensureOpen();\n        long r = n;\n        while (r > 0) {\n            if (nextChar >= nChars) {\n                fill();\n            }\n            if (nextChar >= nChars) /* EOF */\n            {\n                break;\n            }\n            if (skipLF) {\n                skipLF = false;\n                if (cb[nextChar] == '\\n') {\n                    nextChar++;\n                }\n            }\n            long d = (long) nChars - nextChar;\n            if (r <= d) {\n                nextChar += r;\n                r = 0;\n                break;\n            } else {\n                r -= d;\n                nextChar = nChars;\n            }\n        }\n        bytesRead = bytesRead + (n - r);\n        return n - r;\n    }\n}", "repo_id": "9", "comment": "/**\n * Skips characters.\n *\n * @param  n  The number of characters to skip\n *\n * @return    The number of characters actually skipped\n *\n * @exception  IllegalArgumentException  If <code>n</code> is negative.\n * @exception  IOException  If an I/O error occurs\n */\n", "repo_name": "biojava-master/", "id": 2717, "method_signature": "long skip(long)"}, "1655": {"callee_method_names": [], "method_name": "SubunitCluster.setAlpha", "method_implementation": "{\n    this.alpha = alpha;\n}", "repo_id": "9", "comment": "/**\n * A letter that is assigned to this cluster in stoichiometry.\n *\n * @param  alpha\n *          String\n */\n", "repo_name": "biojava-master/", "id": 1655, "method_signature": "void setAlpha(String)"}, "2579": {"callee_method_names": [], "method_name": "SingleLinkageClusterer.getDendrogram", "method_implementation": "{\n    if (dendrogram == null) {\n        clusterIt();\n    }\n    return dendrogram;\n}", "repo_id": "9", "comment": "/**\n * Get the full dendrogram (size n-1) result of the hierarchical clustering\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2579, "method_signature": "LinkedPair[] getDendrogram()"}, "3512": {"callee_method_names": [], "method_name": "StrataInfo.getNearestTime", "method_implementation": "{\n    //the arrays should be sorted by time so this step is probably not needed\n    Double minTime = null;\n    Double maxTime = null;\n    for (Double t : time) {\n        if (minTime == null || t < minTime) {\n            minTime = t;\n        }\n        if (maxTime == null || t > maxTime) {\n            maxTime = t;\n        }\n    }\n    Double timeRange = maxTime - minTime;\n    Double targetTime = minTime + timePercentage * timeRange;\n    Double previousTime = null;\n    for (Double t : time) {\n        if (previousTime == null || t <= targetTime) {\n            previousTime = t;\n        } else {\n            return previousTime;\n        }\n    }\n    return previousTime;\n}", "repo_id": "9", "comment": "/**\n * Need to find the actual time for the nearest time represented as a\n * percentage Would be used to then look up the number at risk at that\n * particular time\n *\n * @param timePercentage\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3512, "method_signature": "Double getNearestTime(double)"}, "455": {"callee_method_names": [], "method_name": "QsAlignResult.setAlignment", "method_implementation": "{\n    this.alignment = alignment;\n}", "repo_id": "9", "comment": "/**\n * The alignment that specifies the residue equivalencies of the equivalent\n * Subunits.\n *\n * @param alignment\n *            a MultipleAlignment object\n */\n", "repo_name": "biojava-master/", "id": 455, "method_signature": "void setAlignment(MultipleAlignment)"}, "1401": {"callee_method_names": [], "method_name": "PdbId.getShortId", "method_implementation": "{\n    if (isInternalShortCompatible(idCode)) {\n        return internalToShortNoCheck(idCode);\n    } else {\n        throw new StructureException(\"ID (\" + getId() + \") is not short format compatible\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Get the PDB Id in the short format. Throws an exception if the conversion is not possible.<br>\n * Use this method only if you know that this PDB ID is shortable.\n * @return the PDB ID in the short format.\n * @throws StructureException if the conversion was not possible.\n */\n", "repo_name": "biojava-master/", "id": 1401, "method_signature": "String getShortId()"}, "1321": {"callee_method_names": [], "method_name": "FileParsingParameters.isAlignSeqRes", "method_implementation": "{\n    return alignSeqRes;\n}", "repo_id": "9", "comment": "/**\n * Flag if the SEQRES amino acids should be aligned with the ATOM amino acids.\n *\n * @return flag if SEQRES - ATOM amino acids alignment is enabled\n */\n", "repo_name": "biojava-master/", "id": 1321, "method_signature": "boolean isAlignSeqRes()"}, "2090": {"callee_method_names": [], "method_name": "SymmetryAxes.getFirstRepeat", "method_implementation": "{\n    return firstRepeat;\n}", "repo_id": "9", "comment": "/**\n * Get the index of the first repeat used by this axis\n * @return the firstRepeat\n */\n", "repo_name": "biojava-master/", "id": 2090, "method_signature": "int getFirstRepeat()"}, "1418": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.setNonStandardSg", "method_implementation": "{\n    this.nonStandardSg = nonStandardSg;\n}", "repo_id": "9", "comment": "/**\n * Set the non-standard space group field\n * @param nonStandardSg\n * @since 4.2.5\n */\n", "repo_name": "biojava-master/", "id": 1418, "method_signature": "void setNonStandardSg(boolean)"}, "2129": {"callee_method_names": ["List<Model>.get"], "method_name": "StructureImpl.size", "method_implementation": "{\n    return models.get(modelnr).size();\n}", "repo_id": "9", "comment": "/**\n * return number of chains  of model.\n */\n", "repo_name": "biojava-master/", "id": 2129, "method_signature": "int size(int)"}, "2051": {"callee_method_names": ["List<Integer>.isEmpty", "List<Integer>.add"], "method_name": "SymmetryTools.getValidFolds", "method_implementation": "{\n    List<Integer> denominators = new ArrayList<Integer>();\n    if (stoichiometry.isEmpty())\n        return denominators;\n    int nChains = Collections.max(stoichiometry);\n    // Remove duplicate stoichiometries\n    Set<Integer> nominators = new TreeSet<Integer>(stoichiometry);\n    // find common denominators\n    for (int d = 1; d <= nChains; d++) {\n        boolean isDivisable = true;\n        for (Integer n : nominators) {\n            if (n % d != 0) {\n                isDivisable = false;\n                break;\n            }\n        }\n        if (isDivisable) {\n            denominators.add(d);\n        }\n    }\n    return denominators;\n}", "repo_id": "9", "comment": "/**\n * Find valid symmetry orders for a given stoichiometry. For instance, an\n * A6B4 protein would give [1,2] because (A6B4)1 and (A3B2)2 are valid\n * decompositions.\n *\n * @param stoichiometry\n *            List giving the number of copies in each Subunit cluster\n * @return The common factors of the stoichiometry\n */\n", "repo_name": "biojava-master/", "id": 2051, "method_signature": "List<Integer> getValidFolds(List)"}, "2762": {"callee_method_ids": [2759, 2755, 2757, 2758, 2761, 2754, 2756, 2760], "callee_method_names": ["EmblReference.setReferenceAuthor", "EmblReference.getReferenceAuthor", "EmblReference.setReferenceComment", "EmblReference.getReferenceComment", "EmblReference.setReferenceCrossReference", "EmblReference.getReferenceCrossReference", "EmblReference.setReferenceGroup", "EmblReference.getReferenceGroup", "EmblReference.setReferenceLocation", "EmblReference.getReferenceLocation", "EmblReference.setReferenceNumber", "EmblReference.getReferenceNumber", "EmblReference.setReferencePosition", "EmblReference.getReferencePosition", "EmblReference.setReferenceTitle", "EmblReference.getReferenceTitle"], "method_name": "EmblReference.copyEmblReference", "method_implementation": "{\n    EmblReference copy = new EmblReference();\n    copy.setReferenceAuthor(emblReference.getReferenceAuthor());\n    copy.setReferenceComment(emblReference.getReferenceComment());\n    copy.setReferenceCrossReference(emblReference.getReferenceCrossReference());\n    copy.setReferenceGroup(emblReference.getReferenceGroup());\n    copy.setReferenceLocation(emblReference.getReferenceLocation());\n    copy.setReferenceNumber(emblReference.getReferenceNumber());\n    copy.setReferencePosition(emblReference.getReferencePosition());\n    copy.setReferenceTitle(emblReference.getReferenceTitle());\n    return copy;\n}", "repo_id": "9", "comment": "/**\n * return copy of EmblReference\n *\n * @param emblReference\n * @return EmblReference\n */\n", "repo_name": "biojava-master/", "id": 2762, "method_signature": "EmblReference copyEmblReference(EmblReference)"}, "1918": {"callee_method_ids": [1876, 1876], "callee_method_names": ["Helix.getAngle", "Helix.getAngle"], "method_name": "HelixLayers.getByLowestAngle", "method_implementation": "{\n    double angle = Double.MAX_VALUE;\n    Helix lowest = null;\n    for (Helix helix : helices) {\n        if (helix.getAngle() < angle) {\n            angle = helix.getAngle();\n            lowest = helix;\n        }\n    }\n    return lowest;\n}", "repo_id": "9", "comment": "/*\n\t * Returns Helix with lowest twist angle\n\t */\n", "repo_name": "biojava-master/", "id": 1918, "method_signature": "Helix getByLowestAngle()"}, "977": {"callee_method_names": [], "method_name": "BioAssemblyInfo.getTransforms", "method_implementation": "{\n    return transforms;\n}", "repo_id": "9", "comment": "/**\n * Return the list of {@link BiologicalAssemblyTransformation}s needed to generate\n * the biological assembly. There is one transformation per internal chain id.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 977, "method_signature": "List<BiologicalAssemblyTransformation> getTransforms()"}, "1442": {"callee_method_ids": [1415, 1415, 1415], "callee_method_names": ["Structure.getCrystallographicInfo", "PDBCrystallographicInfo.getNcsOperators", "PDBCrystallographicInfo.getNcsOperators", "Matrix4d.setIdentity", "PDBCrystallographicInfo.getNcsOperators", "Structure.getChains", "Class.getId", "Class.getName", "Class.clone", "Chain.setId", "Chain.setName", "List<Chain>.add", "Class.getEntityInfo", "Map<String,String>.put", "Map<String,Matrix4d>.put", "Map<String,Matrix4d>.put", "Map<String,String>.put", "List<Chain>.forEach"], "method_name": "CrystalBuilder.expandNcsOps", "method_implementation": "{\n    PDBCrystallographicInfo xtalInfo = structure.getCrystallographicInfo();\n    if (xtalInfo == null)\n        return;\n    if (xtalInfo.getNcsOperators() == null || xtalInfo.getNcsOperators().length == 0)\n        return;\n    List<Chain> chainsToAdd = new ArrayList<>();\n    Matrix4d identity = new Matrix4d();\n    identity.setIdentity();\n    Matrix4d[] ncsOps = xtalInfo.getNcsOperators();\n    for (Chain c : structure.getChains()) {\n        String cOrigId = c.getId();\n        String cOrigName = c.getName();\n        for (int iOperator = 0; iOperator < ncsOps.length; iOperator++) {\n            Matrix4d m = ncsOps[iOperator];\n            Chain clonedChain = (Chain) c.clone();\n            String newChainId = cOrigId + (iOperator + 1) + NCS_CHAINID_SUFFIX_CHAR;\n            String newChainName = cOrigName + (iOperator + 1) + NCS_CHAINID_SUFFIX_CHAR;\n            clonedChain.setId(newChainId);\n            clonedChain.setName(newChainName);\n            setChainIdsInResidueNumbers(clonedChain, newChainName);\n            Calc.transform(clonedChain, m);\n            chainsToAdd.add(clonedChain);\n            c.getEntityInfo().addChain(clonedChain);\n            chainOrigNames.put(newChainName, cOrigName);\n            chainNcsOps.put(newChainName, m);\n        }\n        chainNcsOps.put(cOrigName, identity);\n        chainOrigNames.put(cOrigName, cOrigName);\n    }\n    chainsToAdd.forEach(structure::addChain);\n}", "repo_id": "9", "comment": "/**\n * Apply the NCS operators in the given Structure adding new chains as needed.\n * All chains are (re)assigned ids of the form: original_chain_id+ncs_operator_index+{@value #NCS_CHAINID_SUFFIX_CHAR}.\n * @param structure\n *          the structure to expand\n * @param chainOrigNames\n *          new chain names mapped to the original chain names\n * @param chainNcsOps\n *          new chain names mapped to the ncs operators that was used to generate them\n * @since 5.0.0\n */\n", "repo_name": "biojava-master/", "id": 1442, "method_signature": "void expandNcsOps(Structure, Map, Map)"}, "3143": {"callee_method_names": ["Document.getDocumentElement", "Element.getTextContent", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "UniprotProxySequenceReader.getGeneName", "method_implementation": "{\n    if (uniprotDoc == null) {\n        return \"\";\n    }\n    try {\n        Element uniprotElement = uniprotDoc.getDocumentElement();\n        Element entryElement = XMLHelper.selectSingleElement(uniprotElement, \"entry\");\n        Element geneElement = XMLHelper.selectSingleElement(entryElement, \"gene\");\n        if (geneElement == null) {\n            return \"\";\n        }\n        Element nameElement = XMLHelper.selectSingleElement(geneElement, \"name\");\n        if (nameElement == null) {\n            return \"\";\n        }\n        return nameElement.getTextContent();\n    } catch (XPathExpressionException e) {\n        logger.error(\"Problems while parsing gene name in UniProt XML: {}. Gene name will be blank.\", e.getMessage());\n        return \"\";\n    }\n}", "repo_id": "9", "comment": "/**\n * Get the gene name associated with this sequence.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3143, "method_signature": "String getGeneName()"}, "1091": {"callee_method_names": ["Logger.error"], "method_name": "ChemCompBond.getNumericalBondOrder", "method_implementation": "{\n    switch(valueOrder) {\n        case \"SING\":\n            return 1;\n        case \"DOUB\":\n            return 2;\n        case \"TRIP\":\n            return 3;\n        case \"QUAD\":\n            return 4;\n        default:\n            logger.error(\"Unknown or non-numeric value for value_order: \" + valueOrder);\n            return -1;\n    }\n}", "repo_id": "9", "comment": "/**\n * Converts this ChemCompBond's value_order attribute into an int using the\n * conversion:\n *\n * <pre>\n * \tSING -> 1\n * \tDOUB -> 2\n * \tTRIP -> 3\n * \tQUAD -> 4\n * </pre>\n *\n * Any other values will return -1.\n * <p>\n * (Source:\n * http://mmcif.rcsb.org/dictionaries/mmcif_mdb.dic/Items/_chem_comp_bond.\n * value_order.html)\n *\n * @return the numerical value of this ChemCompBond's bond order, or -1 if\n *         the value is non-numeric or unknown.\n */\n", "repo_name": "biojava-master/", "id": 1091, "method_signature": "int getNumericalBondOrder()"}, "423": {"callee_method_ids": [487], "callee_method_names": ["AFPChain.getBlockNum", "FatCatParameters.getBadRmsd", "AFPChain.getBlock2Afp", "AFPChain.getBlockSize", "AFPChain.getBlockRmsd", "AFPChain.getAfpChainTwiNum", "AFPChain.setBlock2Afp", "AFPChain.setBlockSize", "AFPChain.setBlockNum", "AFPChain.setBlockRmsd", "AFPChain.setAfpChainTwiNum"], "method_name": "AFPPostProcessor.mergeBlock", "method_implementation": "{\n    int blockNum = afpChain.getBlockNum();\n    double badRmsd = params.getBadRmsd();\n    int[] block2Afp = afpChain.getBlock2Afp();\n    int[] blockSize = afpChain.getBlockSize();\n    double[] blockRmsd = afpChain.getBlockRmsd();\n    int afpChainTwiNum = afpChain.getAfpChainTwiNum();\n    //clustering the neighbor blocks if their transformations are similar\n    int i, j, b1, b2, minb1, minb2;\n    double minrmsd;\n    int merge = 0;\n    int blockNumOld = blockNum;\n    double[][] rmsdlist = null;\n    if (blockNum > 1) {\n        rmsdlist = new double[blockNumOld][blockNumOld];\n        for (b1 = 0; b1 < blockNum - 1; b1++) {\n            for (b2 = b1 + 1; b2 < blockNum; b2++) {\n                rmsdlist[b1][b2] = combineRmsd(b1, b2, afpChain, ca1, ca2);\n            }\n        }\n    }\n    minb1 = 0;\n    while (blockNum > 1) {\n        minrmsd = 1000;\n        for (i = 0; i < blockNum - 1; i++) {\n            //only consider neighbor blocks\n            j = i + 1;\n            if (minrmsd > rmsdlist[i][j]) {\n                minrmsd = rmsdlist[i][j];\n                minb1 = i;\n            }\n        }\n        //merge those most similar blocks\n        minb2 = minb1 + 1;\n        //maxrmsd = (blockRmsd[minb1] > blockRmsd[minb2])?blockRmsd[minb1]:blockRmsd[minb2];\n        if (minrmsd < badRmsd) {\n            if (debug)\n                System.out.println(String.format(\"merge block %d (rmsd %.3f) and %d (rmsd %.3f), total rmsd %.3f\\n\", minb1, blockRmsd[minb1], minb2, blockRmsd[minb2], minrmsd));\n            blockSize[minb1] += blockSize[minb2];\n            blockRmsd[minb1] = minrmsd;\n            for (i = minb2; i < blockNum - 1; i++) {\n                block2Afp[i] = block2Afp[i + 1];\n                blockSize[i] = blockSize[i + 1];\n                blockRmsd[i] = blockRmsd[i + 1];\n            }\n            //update block information\n            afpChainTwiNum--;\n            blockNum--;\n            for (b1 = 0; b1 < blockNum - 1; b1++) {\n                for (b2 = b1 + 1; b2 < blockNum; b2++) {\n                    if (b1 == minb1 || b2 == minb1) {\n                        rmsdlist[b1][b2] = combineRmsd(b1, b2, afpChain, ca1, ca2);\n                    } else if (b2 < minb1)\n                        continue;\n                    else if (b1 < minb1) {\n                        rmsdlist[b1][b2] = rmsdlist[b1][b2 + 1];\n                    } else {\n                        rmsdlist[b1][b2] = rmsdlist[b1 + 1][b2 + 1];\n                    }\n                }\n            }\n            //update the rmsdlist\n            merge++;\n        } else //merge two blocks\n        if (minrmsd >= 100)\n            break;\n        else {\n            rmsdlist[minb1][minb2] += 100;\n        }\n        //not merge, modify the rmsdlist so that this combination is not considered in next iteration\n    }\n    if (merge > 0) {\n        if (debug)\n            System.out.println(String.format(\"Merge %d blocks, remaining %d blocks\\n\", merge, blockNum));\n    }\n    if (debug) {\n        System.err.println(\"AFPPostProcessor: mergeBlock end blocknum:\" + blockNum);\n    }\n    afpChain.setBlock2Afp(block2Afp);\n    afpChain.setBlockSize(blockSize);\n    afpChain.setBlockNum(blockNum);\n    afpChain.setBlockRmsd(blockRmsd);\n    afpChain.setAfpChainTwiNum(afpChainTwiNum);\n}", "repo_id": "9", "comment": "/**\n * Merge consecutive blocks with similar transformation\n */\n", "repo_name": "biojava-master/", "id": 423, "method_signature": "void mergeBlock(FatCatParameters, AFPChain, Atom[], Atom[])"}, "2450": {"callee_method_names": ["HashMap.put"], "method_name": "FeatureList.addIndex", "method_implementation": "{\n    featindex.put(index, null);\n}", "repo_id": "9", "comment": "/**\n * Add an attribute that will be used as index for queries\n * @param index an attribute_id\n */\n", "repo_name": "biojava-master/", "id": 2450, "method_signature": "void addIndex(String)"}, "2085": {"callee_method_names": [], "method_name": "SymmetryAxes.getOrder", "method_implementation": "{\n    return order;\n}", "repo_id": "9", "comment": "/**\n * Get the order of this axis (closed symm) or the number of repeats\n * (open symm)\n * @return the order\n */\n", "repo_name": "biojava-master/", "id": 2085, "method_signature": "int getOrder()"}, "1284": {"callee_method_names": [], "method_name": "MmtfSummaryDataBean.setChainIdToIndexMap", "method_implementation": "{\n    this.chainIdToIndexMap = chainIdToIndexMap;\n}", "repo_id": "9", "comment": "/**\n * @param chainIdToIndexMap the map of chain ids (strings asymId) to the index of that chain in the allChains list.\n * This only applies for the first model in the structure.\n */\n", "repo_name": "biojava-master/", "id": 1284, "method_signature": "void setChainIdToIndexMap(Map)"}, "121": {"callee_method_names": ["NeedlemanWunsch<DNASequence, NucleotideCompound>.getPair"], "method_name": "NeedlemanWunschTest.testAnchoredDNAAlignment", "method_implementation": "{\n    DNASequence query = new DNASequence(\"ACGTACCGGTTTT\", DNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"TACGTCCGGTTACGTACGTT\", DNACompoundSet.getDNACompoundSet());\n    NeedlemanWunsch<DNASequence, NucleotideCompound> aligner = new NeedlemanWunsch<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 5, (short) 2), SubstitutionMatrixHelper.getNuc4_4());\n    assertEquals(String.format(\"-ACGTACCGGTT-------TT%nTACGT-CCGGTTACGTACGTT%n\"), aligner.getPair().toString());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 121, "method_signature": "void testAnchoredDNAAlignment()"}, "794": {"callee_method_names": [], "method_name": "CeUserArgumentProcessor.setMaxGapSize", "method_implementation": "{\n    this.maxGapSize = maxGapSize;\n}", "repo_id": "9", "comment": "/**\n * CE specific parameter: set the Max gap size parameter G (during AFP extension). Default: 30\n *\n * @param maxGapSize\n */\n", "repo_name": "biojava-master/", "id": 794, "method_signature": "void setMaxGapSize(int)"}, "2189": {"callee_method_names": ["List<Atom[]>.add", "List<Integer>.add", "List<List<Integer>>.add", "MultipleAlignment.getEnsemble", "Block.setAlignRes", "Matrix4d.setIdentity", "BlockSet.setTransformations"], "method_name": "TestMultipleAlignmentScorer.simpleMSTA", "method_implementation": "{\n    //Generate three identical Atom arrays\n    List<Atom[]> atomArrays = new ArrayList<Atom[]>(52);\n    for (int i = 0; i < 3; i++) atomArrays.add(makeDummyCA(52));\n    //Generate the incorrect alignment (0-1-2,1-2-3,etc)\n    List<List<Integer>> alnRes = new ArrayList<List<Integer>>(3);\n    for (int str = 0; str < 3; str++) {\n        List<Integer> chain = new ArrayList<Integer>(50);\n        for (int res = 0; res < 50; res++) chain.add(res + str);\n        alnRes.add(chain);\n    }\n    //MultipleAlignment generation\n    MultipleAlignment msa = new MultipleAlignmentImpl();\n    msa.getEnsemble().setAtomArrays(atomArrays);\n    BlockSet bs = new BlockSetImpl(msa);\n    Block b = new BlockImpl(bs);\n    b.setAlignRes(alnRes);\n    //We want the identity transfromations to maintain the missalignment\n    Matrix4d ident = new Matrix4d();\n    ident.setIdentity();\n    bs.setTransformations(Arrays.asList(ident, ident, ident));\n    return msa;\n}", "repo_id": "9", "comment": "/**\n * Generates a simple MultipleAlignment: 3 structures with the same\n * Atoms but incorreclty aligned (offset of 1 position) without gaps.\n *\n * @return MultipleAlignment simple MSTA\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2189, "method_signature": "MultipleAlignment simpleMSTA()"}, "3444": {"callee_method_names": ["StructureViewer.clear"], "method_name": "StructureViewerTest.testClear", "method_implementation": "{\n    if (java.awt.GraphicsEnvironment.isHeadless())\n        return;\n    StructureViewer instance = new StructureViewerImpl();\n    instance.clear();\n    // TODO review the generated test code and remove the default call to fail.\n    //fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of clear method, of class StructureViewer.\n */\n", "repo_name": "biojava-master/", "id": 3444, "method_signature": "void testClear()"}, "595": {"callee_method_names": ["Object.getClass"], "method_name": "AlignmentTools.resizeArray", "method_implementation": "{\n    int oldSize = java.lang.reflect.Array.getLength(oldArray);\n    @SuppressWarnings(\"rawtypes\")\n    Class elementType = oldArray.getClass().getComponentType();\n    Object newArray = java.lang.reflect.Array.newInstance(elementType, newSize);\n    int preserveLength = Math.min(oldSize, newSize);\n    if (preserveLength > 0)\n        System.arraycopy(oldArray, 0, newArray, 0, preserveLength);\n    return newArray;\n}", "repo_id": "9", "comment": "/**\n * Reallocates an array with a new size, and copies the contents\n * of the old array to the new array.\n * @param oldArray  the old array, to be reallocated.\n * @param newSize   the new array size.\n * @return          A new array with the same contents.\n */\n", "repo_name": "biojava-master/", "id": 595, "method_signature": "Object resizeArray(Object, int)"}, "3534": {"callee_method_names": [], "method_name": "CoxCoefficient.getZ", "method_implementation": "{\n    return z;\n}", "repo_id": "9", "comment": "/**\n * @return the z\n */\n", "repo_name": "biojava-master/", "id": 3534, "method_signature": "double getZ()"}, "1584": {"callee_method_names": ["SecStrucType.toString"], "method_name": "SecStrucElement.getId", "method_implementation": "{\n    return type.toString() + index + \"\";\n}", "repo_id": "9", "comment": "/**\n * Returns the ID of this element. The ID is the concatenation of the type\n * letter and the numerical element identifier (e.g. H1, S1, ...).\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1584, "method_signature": "String getId()"}, "2856": {"callee_method_names": ["FileInputStream.close"], "method_name": "FastaReaderHelper.readFastaRNASequence", "method_implementation": "{\n    FileInputStream inStream = new FileInputStream(file);\n    LinkedHashMap<String, RNASequence> rnaSequences = readFastaRNASequence(inStream);\n    inStream.close();\n    return rnaSequences;\n}", "repo_id": "9", "comment": "/**\n * @param file\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2856, "method_signature": "LinkedHashMap<String,RNASequence> readFastaRNASequence(File)"}, "1695": {"callee_method_names": [], "method_name": "AtomImpl.getY", "method_implementation": "{\n    return coords.y;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1695, "method_signature": "double getY()"}, "1248": {"callee_method_ids": [977, 959, 957, 957], "callee_method_names": ["BioAssemblyInfo.getTransforms", "BiologicalAssemblyTransformation.getTransformationMatrix", "BiologicalAssemblyTransformation.getChainId", "Map<String,Integer>.containsKey", "Map<String,Integer>.get", "BiologicalAssemblyTransformation.getChainId", "Map<Matrix4d, List<Integer>>.containsKey", "Map<Matrix4d, List<Integer>>.get", "List<Integer>.add", "Map<Matrix4d, List<Integer>>.put", "Map<Matrix4d, List<Integer>>.entrySet", "Map<double[], int[]>.put", "SiftsChainEntry.getKey", "SiftsChainEntry.getValue"], "method_name": "MmtfUtils.getTransformMap", "method_implementation": "{\n    Map<Matrix4d, List<Integer>> matMap = new LinkedHashMap<>();\n    List<BiologicalAssemblyTransformation> transforms = bioassemblyInfo.getTransforms();\n    for (BiologicalAssemblyTransformation transformation : transforms) {\n        Matrix4d transMatrix = transformation.getTransformationMatrix();\n        String transChainId = transformation.getChainId();\n        if (!chainIdToIndexMap.containsKey(transChainId)) {\n            continue;\n        }\n        int chainIndex = chainIdToIndexMap.get(transformation.getChainId());\n        if (matMap.containsKey(transMatrix)) {\n            matMap.get(transMatrix).add(chainIndex);\n        } else {\n            List<Integer> chainIdList = new ArrayList<>();\n            chainIdList.add(chainIndex);\n            matMap.put(transMatrix, chainIdList);\n        }\n    }\n    Map<double[], int[]> outMap = new LinkedHashMap<>();\n    for (Entry<Matrix4d, List<Integer>> entry : matMap.entrySet()) {\n        outMap.put(convertToDoubleArray(entry.getKey()), CodecUtils.convertToIntArray(entry.getValue()));\n    }\n    return outMap;\n}", "repo_id": "9", "comment": "/**\n * Convert a bioassembly information into a map of transform, chainindices it relates to.\n * @param bioassemblyInfo  the bioassembly info object for this structure\n * @param chainIdToIndexMap the map of chain ids to the index that chain corresponds to.\n * @return the bioassembly information (as primitive types).\n */\n", "repo_name": "biojava-master/", "id": 1248, "method_signature": "Map<double[],int[]> getTransformMap(BioAssemblyInfo, Map)"}, "2691": {"callee_method_names": ["Sequence<C>.getCompoundSet", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "AbstractEdit.getEmptySequence", "method_implementation": "{\n    Sequence<C> s = null;\n    try {\n        s = new BasicSequence<C>(\"\", editingSequence.getCompoundSet());\n    } catch (CompoundNotFoundException e) {\n        // should not happen\n        logger.error(\"Could not construct empty sequence. {}. This is most likely a bug.\", e.getMessage());\n    }\n    return s;\n}", "repo_id": "9", "comment": "/**\n * Returns an empty sequence with the given compound set of the editing\n * sequence\n */\n", "repo_name": "biojava-master/", "id": 2691, "method_signature": "Sequence<C> getEmptySequence(Sequence)"}, "1406": {"callee_method_names": ["CrystalCell.getC"], "method_name": "PDBCrystallographicInfo.getC", "method_implementation": "{\n    return (float) cell.getC();\n}", "repo_id": "9", "comment": "/**\n * @return the unit cell parameter c\n */\n", "repo_name": "biojava-master/", "id": 1406, "method_signature": "float getC()"}, "3754": {"callee_method_names": ["HashMap<String, String>.containsKey", "HashMap<String, String>.put", "ArrayList<String>.add"], "method_name": "WorkSheet.getDiscreteRowValues", "method_implementation": "{\n    HashMap<String, String> hashMapValues = new HashMap<String, String>();\n    ArrayList<String> values = new ArrayList<String>();\n    for (String column : getColumns()) {\n        String value = getCell(row, column);\n        if (!hashMapValues.containsKey(value)) {\n            hashMapValues.put(value, value);\n            values.add(value);\n        }\n    }\n    return values;\n}", "repo_id": "9", "comment": "/**\n * Get back a list of unique values in the row\n *\n * @param row\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3754, "method_signature": "ArrayList<String> getDiscreteRowValues(String)"}, "2697": {"callee_method_ids": [2626], "callee_method_names": ["InputStreamProvider.getInputStream", "Iterator<Map.Entry<String, ProteinSequence>>.hasNext", "FastaReader<ProteinSequence, AminoAcidCompound>.process", "FastaReader<ProteinSequence, AminoAcidCompound>.close", "LinkedHashMap.entrySet", "Iterator<Map.Entry<String, ProteinSequence>>.hasNext", "Iterator<Map.Entry<String, ProteinSequence>>.next", "Map.Entry<String, ProteinSequence>.getValue", "FastaReader<ProteinSequence, AminoAcidCompound>.close"], "method_name": "FastaStreamer.stream", "method_implementation": "{\n    InputStreamProvider provider = new InputStreamProvider();\n    InputStream input;\n    try {\n        input = provider.getInputStream(getPath().toFile());\n    } catch (IOException exception) {\n        throw new UncheckedIOException(exception);\n    }\n    FastaReader<ProteinSequence, AminoAcidCompound> reader = new FastaReader<>(input, getHeaderParser(), getSequenceCreator());\n    Spliterator<ProteinSequence> source = new Spliterators.AbstractSpliterator<>(Integer.MAX_VALUE, Spliterator.IMMUTABLE | Spliterator.NONNULL) {\n\n        @Override\n        public boolean tryAdvance(Consumer<? super ProteinSequence> action) {\n            if (closed) {\n                return false;\n            }\n            ProteinSequence protein = next(reader);\n            if (null == protein) {\n                return false;\n            }\n            action.accept(protein);\n            return true;\n        }\n\n        /**\n         * Fetch the next header/protein tuple from the cache.  If the cache is empty, fetch another\n         * batch from the source file\n         *\n         * @param reader\n         * \t\tthe input stream from which the FASTA content is read\n         * @return the protein sequence\n         */\n        private ProteinSequence next(FastaReader<ProteinSequence, AminoAcidCompound> reader) {\n            try {\n                if (!iterator.hasNext()) {\n                    chunk = reader.process(getBatchSize());\n                    if (null == chunk) {\n                        closed = true;\n                        reader.close();\n                        return null;\n                    }\n                    iterator = chunk.entrySet().iterator();\n                }\n                if (iterator.hasNext()) {\n                    Map.Entry<String, ProteinSequence> entry = iterator.next();\n                    return createSequence(entry.getValue());\n                }\n                closed = true;\n                reader.close();\n            } catch (IOException exception) {\n                throw new UncheckedIOException(String.format(\"I/O error reading the FASTA file from '%s'\", getPath()), exception);\n            }\n            return null;\n        }\n    };\n    // Spliterator\n    return StreamSupport.stream(source, false);\n}", "repo_id": "9", "comment": "/**\n * Create a stream of protein sequences from the contents of the path\n * @return the stream\n */\n", "repo_name": "biojava-master/", "id": 2697, "method_signature": "Stream<ProteinSequence> stream()"}, "605": {"callee_method_ids": [490, 489, 487, 487], "callee_method_names": ["AFPChain.getOptLen", "AFPChain.getOptAln", "AFPChain.getBlockNum", "AFPChain.getBlockNum", "Atom[].clone", "AFPChain.getOptLength", "Logger.warn", "AFPChain.getOptLength"], "method_name": "AlignmentTools.fillAlignedAtomArrays", "method_implementation": "{\n    int pos = 0;\n    int[] blockLens = afpChain.getOptLen();\n    int[][][] optAln = afpChain.getOptAln();\n    assert (afpChain.getBlockNum() <= optAln.length);\n    for (int block = 0; block < afpChain.getBlockNum(); block++) {\n        for (int i = 0; i < blockLens[block]; i++) {\n            int pos1 = optAln[block][0][i];\n            int pos2 = optAln[block][1][i];\n            Atom a1 = ca1[pos1];\n            Atom a2 = (Atom) ca2[pos2].clone();\n            ca1aligned[pos] = a1;\n            ca2aligned[pos] = a2;\n            pos++;\n        }\n    }\n    // this can happen when we load an old XML serialization which did not support modern ChemComp representation of modified residues.\n    if (pos != afpChain.getOptLength()) {\n        logger.warn(\"AFPChainScorer getTMScore: Problems reconstructing alignment! nr of loaded atoms is \" + pos + \" but should be \" + afpChain.getOptLength());\n        // we need to resize the array, because we allocated too many atoms earlier on.\n        ca1aligned = (Atom[]) resizeArray(ca1aligned, pos);\n        ca2aligned = (Atom[]) resizeArray(ca2aligned, pos);\n    }\n}", "repo_id": "9", "comment": "/**\n * Fill the aligned Atom arrays with the equivalent residues in the afpChain.\n * @param afpChain\n * @param ca1\n * @param ca2\n * @param ca1aligned\n * @param ca2aligned\n */\n", "repo_name": "biojava-master/", "id": 605, "method_signature": "void fillAlignedAtomArrays(AFPChain, Atom[], Atom[], Atom[], Atom[])"}, "3817": {"callee_method_names": [], "method_name": "ExpressionFigure.setKMFigureInfo", "method_implementation": "{\n    this.kmfi = kmfi;\n    if (kmfi.width != null && kmfi.height != null) {\n        this.setSize(kmfi.width, kmfi.height);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param kmfi\n */\n", "repo_name": "biojava-master/", "id": 3817, "method_signature": "void setKMFigureInfo(KMFigureInfo)"}, "1071": {"callee_method_names": ["Pattern.matcher", "Matcher.matches", "Matcher.group"], "method_name": "URLIdentifier.guessPDBID", "method_implementation": "{\n    Matcher match = PDBID_REGEX.matcher(name);\n    if (match.matches()) {\n        return match.group(1).toUpperCase();\n    }\n    // Give up if doesn't match\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Recognizes PDB IDs that occur at the beginning of name followed by some\n * delimiter.\n * @param name Input filename\n * @return A 4-character id-like string, or null if none is found\n */\n", "repo_name": "biojava-master/", "id": 1071, "method_signature": "String guessPDBID(String)"}, "1080": {"callee_method_names": ["Path.toFile", "Logger.debug", "ChemicalComponentDictionary.getChemComp", "Logger.error", "int.getMessage"], "method_name": "ZipChemCompProvider.getFromZip", "method_implementation": "{\n    ChemComp cc = null;\n    if (!m_zipFile.toFile().exists())\n        return cc;\n    final String filename = \"chemcomp/\" + recordName + \".cif.gz\";\n    // try with resources block to read from the filesystem.\n    // Don't remove the (ClassLoader) cast! It is required for openjdk 11.\n    try (FileSystem fs = FileSystems.newFileSystem(m_zipFile, (ClassLoader) null)) {\n        Path cif = fs.getPath(filename);\n        if (Files.exists(cif)) {\n            s_logger.debug(\"reading {} from {}\", recordName, m_zipFile);\n            final ChemicalComponentDictionary dict = ChemCompConverter.fromPath(cif);\n            cc = dict.getChemComp(recordName);\n        }\n    } catch (IOException e) {\n        s_logger.error(\"Unable to read from zip file : {}\", e.getMessage());\n    }\n    return cc;\n}", "repo_id": "9", "comment": "/**\n * This is synchronized, along with addToFileSystem to prevent simulatenous reading/writing.\n * @param recordName to find in zipfile.\n * @return ChemComp if found or null if missing.\n */\n", "repo_name": "biojava-master/", "id": 1080, "method_signature": "ChemComp getFromZip(String)"}, "2858": {"callee_method_names": ["BufferedInputStream.read", "ByteArrayOutputStream.write", "BufferedInputStream.close", "ByteArrayOutputStream.close", "ByteArrayOutputStream.toByteArray"], "method_name": "ABITrace.ABITraceInit", "method_implementation": "{\n    byte[] bytes = null;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    int b;\n    while ((b = bis.read()) >= 0) {\n        baos.write(b);\n    }\n    bis.close();\n    baos.close();\n    bytes = baos.toByteArray();\n    initData(bytes);\n}", "repo_id": "9", "comment": "/**\n * Helper method for constructors\n *\n * @param bis - BufferedInputStream\n * @throws IOException if there is a problem reading from the BufferedInputStream\n */\n", "repo_name": "biojava-master/", "id": 2858, "method_signature": "void ABITraceInit(BufferedInputStream)"}, "2191": {"callee_method_names": ["Atom[].setName", "Atom[].setCoords", "Group.setPDBName", "Group.setResidueNumber", "Group.addAtom", "Chain.addGroup"], "method_name": "TestMultipleAlignmentScorer.makeDummyCA", "method_implementation": "{\n    Atom[] ca1;\n    Chain chain1 = new ChainImpl();\n    ca1 = new Atom[len];\n    for (int i = 0; i < len; i++) {\n        ca1[i] = new AtomImpl();\n        ca1[i].setName(\"CA\");\n        ca1[i].setCoords(new double[] { i, 0, 0 });\n        Group aa = new AminoAcidImpl();\n        aa.setPDBName(\"GLY\");\n        aa.setResidueNumber(ResidueNumber.fromString(i + \"\"));\n        aa.addAtom(ca1[i]);\n        chain1.addGroup(aa);\n    }\n    return ca1;\n}", "repo_id": "9", "comment": "/**\n * Makes dummy CA atoms at 1A intervals. Only the x coordinate increments\n * by one at each consecutive Atom.\n */\n", "repo_name": "biojava-master/", "id": 2191, "method_signature": "Atom[] makeDummyCA(int)"}, "2231": {"callee_method_names": [], "method_name": "TestMMCIFWriting.test2N3J", "method_implementation": "{\n    // an NMR structure (multimodel) with 2 chains\n    testRoundTrip(\"2N3J\");\n}", "repo_id": "9", "comment": "/**\n * MMCIF write test for an NMR structure with 2 chains\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2231, "method_signature": "void test2N3J()"}, "1992": {"callee_method_names": ["QuatSymmetrySubunits.getSubunitCount", "RotationGroup.getRotation", "RotationGroup.getRotation", "List<Integer>.add", "List<Integer>.get", "List<Integer>.get", "List<List<Integer>>.add"], "method_name": "RotationAxisAligner.calcOrbits", "method_implementation": "{\n    int n = subunits.getSubunitCount();\n    int fold = rotationGroup.getRotation(0).getFold();\n    List<List<Integer>> orbits = new ArrayList<List<Integer>>();\n    boolean[] used = new boolean[n];\n    Arrays.fill(used, false);\n    for (int i = 0; i < n; i++) {\n        if (!used[i]) {\n            // determine the equivalent subunits\n            List<Integer> orbit = new ArrayList<Integer>(fold);\n            for (int j = 0; j < fold; j++) {\n                List<Integer> permutation = rotationGroup.getRotation(j).getPermutation();\n                orbit.add(permutation.get(i));\n                used[permutation.get(i)] = true;\n            }\n            orbits.add(deconvolute(orbit));\n        }\n    }\n    return orbits;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of list of subunit ids that form an \"orbit\", i.e. they\n * are transformed into each other during a rotation around the principal symmetry axis (z-axis)\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1992, "method_signature": "List<List<Integer>> calcOrbits()"}, "585": {"callee_method_names": ["Map<Integer,Integer>.entrySet", "SortedSet<Integer>.add", "SequencePair<ProteinSequence,AminoAcidCompound>.getKey", "SortedSet<Integer>.add", "SequencePair<ProteinSequence,AminoAcidCompound>.getValue", "SequencePair<ProteinSequence,AminoAcidCompound>.getValue", "SortedSet<Integer>.iterator", "SortedSet<Integer>.iterator", "Iterator<Integer>.hasNext", "Map<Integer, Integer>.put", "Iterator<Integer>.next", "Iterator<Integer>.next", "Map<Integer, Integer>.put", "Iterator<Integer>.next", "Iterator<Integer>.next"], "method_name": "AlignmentTools.guessSequentialAlignment", "method_implementation": "{\n    Map<Integer, Integer> identity = new HashMap<Integer, Integer>();\n    SortedSet<Integer> aligned1 = new TreeSet<Integer>();\n    SortedSet<Integer> aligned2 = new TreeSet<Integer>();\n    for (Entry<Integer, Integer> pair : alignment.entrySet()) {\n        aligned1.add(pair.getKey());\n        if (!aligned2.add(pair.getValue()))\n            throw new IllegalArgumentException(\"Alignment is not one-to-one for residue \" + pair.getValue() + \" of the second structure.\");\n    }\n    Iterator<Integer> it1 = aligned1.iterator();\n    Iterator<Integer> it2 = aligned2.iterator();\n    while (it1.hasNext()) {\n        if (inverseAlignment) {\n            // 2->1\n            identity.put(it2.next(), it1.next());\n        } else {\n            // 1->2\n            identity.put(it1.next(), it2.next());\n        }\n    }\n    return identity;\n}", "repo_id": "9", "comment": "/**\n * Takes a potentially non-sequential alignment and guesses a sequential\n * version of it. Residues from each structure are sorted sequentially and\n * then compared directly.\n *\n * <p>The results of this method are consistent with what one might expect\n * from an identity function, and are therefore useful with\n * {@link #getSymmetryOrder(Map, Map identity, int, float)}.\n * <ul>\n *  <li>Perfect self-alignments will have the same pre-image and image,\n *      so will map X->X</li>\n *  <li>Gaps and alignment errors will cause errors in the resulting map,\n *      but only locally. Errors do not propagate through the whole\n *      alignment.</li>\n * </ul>\n *\n * <h4>Example:</h4>\n * A non sequential alignment, represented schematically as\n * <pre>\n * 12456789\n * 78912345</pre>\n * would result in a map\n * <pre>\n * 12456789\n * 12345789</pre>\n * @param alignment The non-sequential input alignment\n * @param inverseAlignment If false, map from structure1 to structure2. If\n *  true, generate the inverse of that map.\n * @return A mapping from sequential residues of one protein to those of the other\n * @throws IllegalArgumentException if the input alignment is not one-to-one.\n */\n", "repo_name": "biojava-master/", "id": 585, "method_signature": "Map<Integer,Integer> guessSequentialAlignment(Map, boolean)"}, "452": {"callee_method_names": [], "method_name": "QsAlignResult.getRelation", "method_implementation": "{\n    return relation;\n}", "repo_id": "9", "comment": "/**\n * The quaternary structure relation {@link QsRelation} between the two\n * groups of Subunits.\n *\n * @return relation\n */\n", "repo_name": "biojava-master/", "id": 452, "method_signature": "QsRelation getRelation()"}, "2890": {"callee_method_names": [], "method_name": "SequenceMixin.createSubSequence", "method_implementation": "{\n    return new SequenceProxyView<C>(sequence, start, end);\n}", "repo_id": "9", "comment": "/**\n * Creates a simple sub sequence view delimited by the given start and end.\n */\n", "repo_name": "biojava-master/", "id": 2890, "method_signature": "SequenceView<C> createSubSequence(Sequence, int, int)"}, "272": {"callee_method_ids": [311, 311, 311, 311], "callee_method_names": ["Component.getPdbccIds", "Component.getPdbccIds", "Component.getPdbccIds", "Component.getPdbccIds"], "method_name": "ModificationLinkage.toString", "method_implementation": "{\n    Component comp1 = getComponent1();\n    Component comp2 = getComponent2();\n    List<String> atom1 = getPDBNameOfPotentialAtomsOnComponent1();\n    List<String> atom2 = getPDBNameOfPotentialAtomsOnComponent2();\n    if (comp1 == null || comp2 == null) {\n        return \"ModificationLinkage: empty\";\n    }\n    if (comp1.getPdbccIds() != null && comp2.getPdbccIds() != null) {\n        return \"ModificationLinkage: \" + comp1.getPdbccIds().toString() + \":\" + atom1 + \"<=>\" + comp2.getPdbccIds() + atom2;\n    } else {\n        return \"ModificationLinkage :\" + atom1 + \"<=>\" + atom2;\n    }\n}", "repo_id": "9", "comment": "/**\n */\n", "repo_name": "biojava-master/", "id": 272, "method_signature": "String toString()"}, "1485": {"callee_method_names": ["Point3d.negate"], "method_name": "CalcPoint.center", "method_implementation": "{\n    Point3d center = centroid(x);\n    center.negate();\n    translate(new Vector3d(center), x);\n}", "repo_id": "9", "comment": "/**\n * Center a cloud of points. This means subtracting the {@lin\n * #centroid(Point3d[])} of the cloud to each point.\n *\n * @param x\n *            array of points. Point objects will be modified\n */\n", "repo_name": "biojava-master/", "id": 1485, "method_signature": "void center(Point3d[])"}, "2838": {"callee_method_names": ["S.setOriginalHeader", "S.setAccession", "S.setAnnotationType", "S.setAnnotationType", "S.setAccession", "S.setDescription", "S.setAccession", "S.setAccession", "S.setAccession", "S.setAccession", "S.setAccession", "String[].startsWith", "String[].split", "String[].split", "S.setAccession", "String[].indexOf", "S.setAccession", "S.setAccession", "S.setAccession", "S.setAccession", "S.setAccession", "S.setAccession", "S.setAccession"], "method_name": "GenericFastaHeaderParser.parseHeader", "method_implementation": "{\n    //uniptrot\n    // tr|Q0TET7|Q0TET7_ECOL5 Putative uncharacterized protein OS=Escherichia coli O6:K15:H31 (strain 536 / UPEC) GN=ECP_2553 PE=4 SV=1\n    sequence.setOriginalHeader(header);\n    String[] data = getHeaderValues(header);\n    if (data.length == 1) {\n        sequence.setAccession(new AccessionID(data[0]));\n    } else if (\"sp\".equalsIgnoreCase(data[0]) || \"tr\".equalsIgnoreCase(data[0])) {\n        if (\"sp\".equalsIgnoreCase(data[0])) {\n            sequence.setAnnotationType(AnnotationType.CURATED);\n        } else {\n            sequence.setAnnotationType(AnnotationType.PREDICTED);\n        }\n        sequence.setAccession(new AccessionID(data[1], DataSource.UNIPROT));\n        if (data.length > 2) {\n            sequence.setDescription(data[2]);\n        }\n    } else if (\"gi\".equalsIgnoreCase(data[0])) {\n        DataSource giSource = DataSource.UNKNOWN;\n        if (data.length >= 3) {\n            if (\"gb\".equalsIgnoreCase(data[2])) {\n                giSource = DataSource.GENBANK;\n            } else if (\"emb\".equalsIgnoreCase(data[2])) {\n                giSource = DataSource.ENA;\n            } else if (\"dbj\".equalsIgnoreCase(data[2])) {\n                giSource = DataSource.DDBJ;\n            }\n            sequence.setAccession(new AccessionID(data[3], giSource));\n        } else {\n            sequence.setAccession(new AccessionID(header, giSource));\n        }\n    } else if (\"pir\".equalsIgnoreCase(data[0])) {\n        sequence.setAccession(new AccessionID(data[2], DataSource.NBRF));\n    } else if (\"prf\".equalsIgnoreCase(data[0])) {\n        sequence.setAccession(new AccessionID(data[2], DataSource.PRF));\n    } else if (\"pdb\".equalsIgnoreCase(data[0])) {\n        sequence.setAccession(new AccessionID(data[1] + \":\" + data[2], DataSource.PDB1));\n    } else if (data[0].startsWith(\"PDB\")) {\n        String[] pdbe = data[0].split(\" \");\n        String[] pdbaccession = pdbe[0].split(\":\");\n        sequence.setAccession(new AccessionID(pdbaccession[1], DataSource.PDBe));\n    } else if (data[0].indexOf(\":\") != -1 && data.length > 1 && \"PDBID\".equals(data[1])) {\n        sequence.setAccession(new AccessionID(data[0], DataSource.PDB2));\n    } else if (\"pat\".equalsIgnoreCase(data[0])) {\n        sequence.setAccession(new AccessionID(data[2], DataSource.PATENTS));\n    } else if (\"bbs\".equalsIgnoreCase(data[0])) {\n        sequence.setAccession(new AccessionID(data[1], DataSource.GENINFO));\n    } else if (\"gnl\".equalsIgnoreCase(data[0])) {\n        sequence.setAccession(new AccessionID(data[2], DataSource.GENERAL));\n    } else if (\"ref\".equalsIgnoreCase(data[0])) {\n        sequence.setAccession(new AccessionID(data[1], DataSource.NCBI));\n    } else if (\"lcl\".equalsIgnoreCase(data[0])) {\n        sequence.setAccession(new AccessionID(data[1], DataSource.LOCAL));\n    } else {\n        // avoid the common problem of picking up all the comments original header in getOriginalHeader\n        sequence.setAccession(new AccessionID(data[0]));\n    }\n}", "repo_id": "9", "comment": "/**\n * Parse the header and set the values in the sequence\n * @param header\n * @param sequence\n */\n", "repo_name": "biojava-master/", "id": 2838, "method_signature": "void parseHeader(String, S)"}, "1231": {"callee_method_names": ["List<Chain>.iterator", "Iterator<Chain>.hasNext", "Iterator<Chain>.next", "Chain.getId", "Chain.getId", "Chain.getName", "Chain.getName", "String.equals", "Logger.info", "Chain.getId", "Chain.getName", "List<Chain>.size"], "method_name": "SeqRes2AtomAligner.getMatchingAtomRes", "method_implementation": "{\n    Iterator<Chain> iter = atomList.iterator();\n    while (iter.hasNext()) {\n        Chain atomChain = iter.next();\n        String atomChainId = null;\n        String seqResChainId = null;\n        if (useChainId) {\n            atomChainId = atomChain.getId();\n            seqResChainId = seqRes.getId();\n        } else {\n            atomChainId = atomChain.getName();\n            seqResChainId = seqRes.getName();\n        }\n        if (atomChainId.equals(seqResChainId)) {\n            return atomChain;\n        }\n    }\n    logger.info(\"Could not match SEQRES chainID asymId:\" + seqRes.getId() + \" authId:\" + seqRes.getName() + \"  to ATOM chains!, size of atom chain: \" + atomList.size());\n    return null;\n}", "repo_id": "9", "comment": "/**\n * @param seqRes\n * @param atomList\n * @param useChainId if true chainId (Chain.getId) is used for matching,\n * if false chainName (Chain.getName) is used\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1231, "method_signature": "Chain getMatchingAtomRes(Chain, List, boolean)"}, "3235": {"callee_method_names": [], "method_name": "GenbankProxySequenceReaderTest.copyTestFiles", "method_implementation": "{\n    Collection<String[]> accessorIds = getExamples();\n    for (String[] arr : accessorIds) {\n        copyTestFileToWorkingDirectory(arr[0] + \".gb\");\n    }\n}", "repo_id": "9", "comment": "/**\n * In {@link GenbankProxySequenceReader} there is a check to see if the requested files are already in the temp\n * directory before attempting to retrieve them from the remote server. so simply copying the test files to the temp\n * directory avoids calling out to the server and hitting a 429 status code from the server which fails the build.\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 3235, "method_signature": "void copyTestFiles()"}, "1661": {"callee_method_ids": [1616, 2053, 1626, 2055, 1630, 2055], "callee_method_names": ["CESymmParameters.setMinCoreLength", "SubunitClustererParameters.getMinimumSequenceLength", "CESymmParameters.setGaps", "ArrayList.get", "CeSymmResult.isSignificant", "CeSymmResult.getMultipleAlignment", "SubunitClustererParameters.getRMSDThreshold", "CeSymmResult.getMultipleAlignment", "CeSymmResult.getNumRepeats", "SubunitClustererParameters.getStructureCoverageThreshold", "Logger.info", "CeSymmResult.getNumRepeats", "CeSymmResult.getMultipleAlignment", "List<List<Integer>>.size", "List<List<Integer>>.add", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.size", "ArrayList.get", "List<List<Integer>>.get", "List<List<Integer>>.size", "List<List<Integer>>.get", "ArrayList.get", "List<List<Integer>>.get", "ArrayList.size", "List<List<Integer>>.size", "ArrayList.size", "List<List<Integer>>.size", "ArrayList.size", "List<List<Integer>>.size", "ArrayList.get", "List<List<Integer>>.get", "ArrayList.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "ArrayList.get", "List<Subunit>.add", "ArrayList.get", "ArrayList.get", "ArrayList.get", "List<List<Integer>>.get", "List<Integer>.add", "ArrayList.get", "List<List<Integer>>.get", "List<List<Integer>>.add", "ArrayList.size", "ArrayList.get", "ArrayList.get"], "method_name": "SubunitCluster.divideInternally", "method_implementation": "{\n    CESymmParameters cesym_params = new CESymmParameters();\n    cesym_params.setMinCoreLength(clusterParams.getMinimumSequenceLength());\n    // We want no gaps between the repeats\n    cesym_params.setGaps(false);\n    // Analyze the internal symmetry of the representative subunit\n    CeSymmResult result = CeSymm.analyze(subunits.get(representative).getRepresentativeAtoms(), cesym_params);\n    if (!result.isSignificant())\n        return false;\n    double rmsd = result.getMultipleAlignment().getScore(MultipleAlignmentScorer.RMSD);\n    if (rmsd > clusterParams.getRMSDThreshold())\n        return false;\n    double coverage = result.getMultipleAlignment().getCoverages().get(0) * result.getNumRepeats();\n    if (coverage < clusterParams.getStructureCoverageThreshold())\n        return false;\n    logger.info(\"SubunitCluster is internally symmetric with {} repeats, \" + \"{} RMSD and {} coverage\", result.getNumRepeats(), rmsd, coverage);\n    // Divide if symmety was significant with RMSD and coverage sufficient\n    List<List<Integer>> alignedRes = result.getMultipleAlignment().getBlock(0).getAlignRes();\n    List<List<Integer>> columns = new ArrayList<>();\n    for (int s = 0; s < alignedRes.size(); s++) columns.add(new ArrayList<>(alignedRes.get(s).size()));\n    // Extract the aligned columns of each repeat in the Subunit\n    for (int col = 0; col < alignedRes.get(0).size(); col++) {\n        // Check that all aligned residues are part of the Cluster\n        boolean missing = false;\n        for (int s = 0; s < alignedRes.size(); s++) {\n            if (!subunitEQR.get(representative).contains(alignedRes.get(s).get(col))) {\n                missing = true;\n                break;\n            }\n        }\n        // Skip the column if any residue was not part of the cluster\n        if (missing)\n            continue;\n        for (int s = 0; s < alignedRes.size(); s++) {\n            columns.get(s).add(subunitEQR.get(representative).indexOf(alignedRes.get(s).get(col)));\n        }\n    }\n    // Divide the Subunits in their repeats\n    List<Subunit> newSubunits = new ArrayList<Subunit>(subunits.size() * columns.size());\n    List<List<Integer>> newSubunitEQR = new ArrayList<List<Integer>>(subunits.size() * columns.size());\n    for (int s = 0; s < subunits.size(); s++) {\n        for (int r = 0; r < columns.size(); r++) {\n            // Calculate start and end residues of the new Subunit\n            int start = subunitEQR.get(s).get(columns.get(r).get(0));\n            int end = subunitEQR.get(s).get(columns.get(r).get(columns.get(r).size() - 1));\n            Atom[] reprAtoms = Arrays.copyOfRange(subunits.get(s).getRepresentativeAtoms(), start, end + 1);\n            newSubunits.add(new Subunit(reprAtoms, subunits.get(s).getName(), subunits.get(s).getIdentifier(), subunits.get(s).getStructure()));\n            // Recalculate equivalent residues\n            List<Integer> eqr = new ArrayList<Integer>();\n            for (int p = 0; p < columns.get(r).size(); p++) {\n                eqr.add(subunitEQR.get(s).get(columns.get(r).get(p)) - start);\n            }\n            newSubunitEQR.add(eqr);\n        }\n    }\n    subunits = newSubunits;\n    subunitEQR = newSubunitEQR;\n    // Update representative\n    for (int s = 0; s < subunits.size(); s++) {\n        if (subunits.get(s).size() > subunits.get(representative).size())\n            representative = s;\n    }\n    method = SubunitClustererMethod.STRUCTURE;\n    pseudoStoichiometric = true;\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Analyze the internal symmetry of the SubunitCluster and divide its\n * {@link Subunit} into the internal repeats (domains) if they are\n * internally symmetric.\n *\n * @param clusterParams {@link SubunitClustererParameters} with fields used as follows:\n * structureCoverageThreshold\n *            the minimum coverage of all repeats in the Subunit\n * rmsdThreshold\n *            the maximum allowed RMSD between the repeats\n * minimumSequenceLength\n *            the minimum length of the repeating units\n * @return true if the cluster was internally symmetric, false otherwise\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 1661, "method_signature": "boolean divideInternally(SubunitClustererParameters)"}, "2626": {"callee_method_names": ["InputStream.close", "File.getName", "String.endsWith", "String.endsWith", "ZipFile.entries", "Enumeration<JarEntry>.hasMoreElements", "Enumeration<JarEntry>.nextElement", "ZipFile.getInputStream", "String.endsWith", "JarFile.entries", "Enumeration<JarEntry>.hasMoreElements", "Enumeration<JarEntry>.nextElement", "JarFile.getInputStream", "String.endsWith"], "method_name": "InputStreamProvider.getInputStream", "method_implementation": "{\n    // use the magic numbers to determine the compression type,\n    // use file extension only as 2nd choice\n    int magic = 0;\n    InputStream test = getInputStreamFromFile(f);\n    magic = getMagicNumber(test);\n    test.close();\n    InputStream inputStream = null;\n    String fileName = f.getName();\n    if (magic == UncompressInputStream.LZW_MAGIC) {\n        // a Z compressed file\n        return openCompressedFile(f);\n    } else if (magic == GZIP_MAGIC) {\n        return openGZIPFile(f);\n    } else if (fileName.endsWith(\".gz\")) {\n        return openGZIPFile(f);\n    } else if (fileName.endsWith(\".zip\")) {\n        ZipFile zipfile = new ZipFile(f);\n        // stream to first entry is returned ...\n        ZipEntry entry;\n        Enumeration<? extends ZipEntry> e = zipfile.entries();\n        if (e.hasMoreElements()) {\n            entry = e.nextElement();\n            inputStream = zipfile.getInputStream(entry);\n        } else {\n            throw new IOException(\"Zip file has no entries\");\n        }\n    } else if (fileName.endsWith(\".jar\")) {\n        JarFile jarFile = new JarFile(f);\n        // stream to first entry is returned\n        JarEntry entry;\n        Enumeration<JarEntry> e = jarFile.entries();\n        if (e.hasMoreElements()) {\n            entry = e.nextElement();\n            inputStream = jarFile.getInputStream(entry);\n        } else {\n            throw new IOException(\"Jar file has no entries\");\n        }\n    } else if (fileName.endsWith(\".Z\")) {\n        // unix compressed\n        return openCompressedFile(f);\n    } else {\n        // no particular extension found, assume that it is an uncompressed file\n        inputStream = getInputStreamFromFile(f);\n    }\n    return inputStream;\n}", "repo_id": "9", "comment": "/**\n * Get an InputStream for the file.\n * The caller is responsible for closing the stream or otherwise\n * a resource leak can occur.\n * @param f a File\n * @return an InputStream for the file\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2626, "method_signature": "InputStream getInputStream(File)"}, "3456": {"callee_method_names": [], "method_name": "NCBIQBlastOutputProperties.getAlignmentOutputFormat", "method_implementation": "{\n    return getOutputOption(ALIGNMENT_VIEW);\n}", "repo_id": "9", "comment": "/**\n * @return alignment output format - a String with the value of key ALIGNMENT_VIEW\n */\n", "repo_name": "biojava-master/", "id": 3456, "method_signature": "String getAlignmentOutputFormat()"}, "3253": {"callee_method_ids": [3302], "callee_method_names": ["JMenu.getAccessibleContext", "JMenuBar.add", "JMenuItem.setMnemonic", "MySaveFileListener.setTextOutput", "JMenuItem.addActionListener", "JMenu.add", "JMenu.addSeparator", "JMenuItem.addActionListener", "JMenu.add", "JMenu.addSeparator", "JMenu.add", "JMenu.add", "JMenu.setMnemonic", "JMenuBar.add", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.getAccessibleContext", "JMenu.setMnemonic", "JMenuBar.add", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.setMnemonic", "JMenu.add", "JMenu.add", "JMenuBar.add", "JMenuBar.add"], "method_name": "MenuCreator.getAlignmentPanelMenu", "method_implementation": "{\n    JMenuBar menu = new JMenuBar();\n    JMenu file = new JMenu(\"File\");\n    file.getAccessibleContext().setAccessibleDescription(\"File Menu\");\n    menu.add(file);\n    ImageIcon saveicon = createImageIcon(\"/icons/filesave.png\");\n    JMenuItem saveF = null;\n    if (saveicon != null)\n        saveF = new JMenuItem(\"Save text display\", saveicon);\n    else\n        saveF = new JMenuItem(\"Save text display\");\n    saveF.setMnemonic(KeyEvent.VK_S);\n    MySaveFileListener listener = new MySaveFileListener(afpChain, msa);\n    listener.setTextOutput(true);\n    saveF.addActionListener(listener);\n    file.add(saveF);\n    file.addSeparator();\n    JMenuItem print = getPrintMenuItem();\n    print.addActionListener(actionListener);\n    file.add(print);\n    file.addSeparator();\n    JMenuItem closeI = MenuCreator.getCloseMenuItem(frame);\n    file.add(closeI);\n    JMenuItem exitI = MenuCreator.getExitMenuItem();\n    file.add(exitI);\n    JMenu edit = new JMenu(\"Edit\");\n    edit.setMnemonic(KeyEvent.VK_E);\n    menu.add(edit);\n    JMenuItem eqrI = MenuCreator.getIcon(actionListener, SELECT_EQR);\n    edit.add(eqrI);\n    JMenuItem eqrcI = MenuCreator.getIcon(actionListener, EQR_COLOR);\n    edit.add(eqrcI);\n    JMenuItem simI = MenuCreator.getIcon(actionListener, SIMILARITY_COLOR);\n    edit.add(simI);\n    JMenuItem fatcatI = MenuCreator.getIcon(actionListener, FATCAT_BLOCK);\n    edit.add(fatcatI);\n    JMenu view = new JMenu(\"View\");\n    view.getAccessibleContext().setAccessibleDescription(\"View Menu\");\n    view.setMnemonic(KeyEvent.VK_V);\n    menu.add(view);\n    JMenuItem textI = MenuCreator.getIcon(actionListener, TEXT_ONLY);\n    view.add(textI);\n    JMenuItem fastaI = MenuCreator.getIcon(actionListener, FASTA_FORMAT);\n    view.add(fastaI);\n    JMenuItem pairsI = MenuCreator.getIcon(actionListener, PAIRS_ONLY);\n    view.add(pairsI);\n    JMenuItem textF = MenuCreator.getIcon(actionListener, FATCAT_TEXT);\n    view.add(textF);\n    JMenu about = new JMenu(\"Help\");\n    about.setMnemonic(KeyEvent.VK_A);\n    JMenuItem helpM = MenuCreator.getHelpMenuItem();\n    about.add(helpM);\n    JMenuItem aboutM = MenuCreator.getAboutMenuItem();\n    about.add(aboutM);\n    menu.add(Box.createGlue());\n    menu.add(about);\n    return menu;\n}", "repo_id": "9", "comment": "/**\n * Create the menu for the Alignment Panel representation of\n * Structural Alignments. The alignment can be in AFPChain format\n * or in the MultipleAlignment format.\n *\n * @param frame\n * @param actionListener\n * @param afpChain\n * @param msa\n * @return a JMenuBar\n */\n", "repo_name": "biojava-master/", "id": 3253, "method_signature": "JMenuBar getAlignmentPanelMenu(JFrame, ActionListener, AFPChain, MultipleAlignment)"}, "793": {"callee_method_names": [], "method_name": "CeUserArgumentProcessor.getMaxGapSize", "method_implementation": "{\n    return maxGapSize;\n}", "repo_id": "9", "comment": "/**\n * CE specific parameter: set the Max gap size parameter G (during AFP extension). Default: 30\n *\n * @return the maximum gap size G parameter.\n */\n", "repo_name": "biojava-master/", "id": 793, "method_signature": "int getMaxGapSize()"}, "2859": {"callee_method_names": [], "method_name": "ABITrace.getSequenceLength", "method_implementation": "{\n    return seqLength;\n}", "repo_id": "9", "comment": "/**\n * Returns the length of the sequence (number of bases) in this trace.\n *\n * @return int seqLength\n */\n", "repo_name": "biojava-master/", "id": 2859, "method_signature": "int getSequenceLength()"}, "2046": {"callee_method_ids": [1633, 1627, 1631], "callee_method_names": ["List<Atom[]>.stream", "SubunitClustererParameters.setClustererMethod", "SubunitClustererParameters.setRMSDThreshold", "SubunitClustererParameters.setStructureCoverageThreshold"], "method_name": "SymmetryTools.getQuaternarySymmetry", "method_implementation": "{\n    // Obtain the subunits of the repeats\n    List<Atom[]> atoms = toRepeatsAlignment(result).getAtomArrays();\n    List<Subunit> subunits = atoms.stream().map(a -> new Subunit(a, null, null, null)).collect(Collectors.toList());\n    // The clustering thresholds are set to 0 so that all always merged\n    SubunitClustererParameters cp = new SubunitClustererParameters();\n    cp.setClustererMethod(SubunitClustererMethod.STRUCTURE);\n    cp.setRMSDThreshold(10.0);\n    cp.setStructureCoverageThreshold(0.0);\n    QuatSymmetryParameters sp = new QuatSymmetryParameters();\n    QuatSymmetryResults gSymmetry = QuatSymmetryDetector.calcGlobalSymmetry(subunits, sp, cp);\n    return gSymmetry;\n}", "repo_id": "9", "comment": "/**\n * Given a symmetry result, it calculates the overall global symmetry,\n * factoring out the alignment and detection steps of\n * {@link QuatSymmetryDetector} algorithm.\n *\n * @param result\n *            symmetry result\n * @return global symmetry results\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2046, "method_signature": "QuatSymmetryResults getQuaternarySymmetry(CeSymmResult)"}, "1933": {"callee_method_names": ["List<List<Integer>>.size", "Set<List<Integer>>.contains", "List<List<Integer>>.add", "ArrayList.add", "Set<List<Integer>>.add"], "method_name": "PermutationGroup.completeGroup", "method_implementation": "{\n    // Copy initial set to allow permutations to grow\n    List<List<Integer>> gens = new ArrayList<List<Integer>>(permutations);\n    // Keep HashSet version of permutations for fast lookup.\n    Set<List<Integer>> known = new HashSet<List<Integer>>(permutations);\n    //breadth-first search through the map of all members\n    List<List<Integer>> currentLevel = new ArrayList<List<Integer>>(permutations);\n    while (currentLevel.size() > 0) {\n        List<List<Integer>> nextLevel = new ArrayList<List<Integer>>();\n        for (List<Integer> p : currentLevel) {\n            for (List<Integer> gen : gens) {\n                List<Integer> y = combine(p, gen);\n                if (!known.contains(y)) {\n                    nextLevel.add(y);\n                    //bypass addPermutation(y) for performance\n                    permutations.add(y);\n                    known.add(y);\n                }\n            }\n        }\n        currentLevel = nextLevel;\n    }\n}", "repo_id": "9", "comment": "/**\n * Starts with an incomplete set of group generators in `permutations` and\n * expands it to include all possible combinations.\n *\n * Ways to complete group:\n * - combinations of permutations pi x pj\n * - combinations with itself p^k\n */\n", "repo_name": "biojava-master/", "id": 1933, "method_signature": "void completeGroup()"}, "2818": {"callee_method_names": ["S.getAccession", "S.getAccession"], "method_name": "IOUtils.getIDFormat", "method_implementation": "{\n    int length = 0;\n    for (S as : sequences) {\n        length = Math.max(length, (as.getAccession() == null) ? 0 : as.getAccession().toString().length());\n    }\n    return (length == 0) ? null : \"%-\" + (length + 1) + \"s\";\n}", "repo_id": "9", "comment": "/**\n * Creates format String for accession IDs\n *\n * @param sequences list of sequences\n * @return format String for accession IDs\n */\n", "repo_name": "biojava-master/", "id": 2818, "method_signature": "String getIDFormat(List)"}, "579": {"callee_method_ids": [492, 489, 490, 487], "callee_method_names": ["AFPChain.getAlnLength", "AFPChain.getOptAln", "AFPChain.getOptLen", "AFPChain.getBlockNum", "Map<Integer, Integer>.containsKey", "Map<Integer, Integer>.get", "Map<Integer, Integer>.put"], "method_name": "AlignmentTools.alignmentAsMap", "method_implementation": "{\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n    if (afpChain.getAlnLength() < 1) {\n        return map;\n    }\n    int[][][] optAln = afpChain.getOptAln();\n    int[] optLen = afpChain.getOptLen();\n    for (int block = 0; block < afpChain.getBlockNum(); block++) {\n        for (int pos = 0; pos < optLen[block]; pos++) {\n            int res1 = optAln[block][0][pos];\n            int res2 = optAln[block][1][pos];\n            if (map.containsKey(res1)) {\n                throw new StructureException(String.format(\"Residue %d aligned to both %d and %d.\", res1, map.get(res1), res2));\n            }\n            map.put(res1, res2);\n        }\n    }\n    return map;\n}", "repo_id": "9", "comment": "/**\n * Creates a Map specifying the alignment as a mapping between residue indices\n * of protein 1 and residue indices of protein 2.\n *\n * <p>For example,<pre>\n * 1234\n * 5678</pre>\n * becomes<pre>\n * 1->5\n * 2->6\n * 3->7\n * 4->8</pre>\n *\n * @param afpChain An alignment\n * @return A mapping from aligned residues of protein 1 to their partners in protein 2.\n * @throws StructureException If afpChain is not one-to-one\n */\n", "repo_name": "biojava-master/", "id": 579, "method_signature": "Map<Integer,Integer> alignmentAsMap(AFPChain)"}, "955": {"callee_method_names": [], "method_name": "BiologicalAssemblyTransformation.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * Returns the identifier for this biological assembly transformation.\n * @return biological assembly transformation identifier\n */\n", "repo_name": "biojava-master/", "id": 955, "method_signature": "String getId()"}, "1329": {"callee_method_names": [], "method_name": "FileParsingParameters.shouldCreateAtomBonds", "method_implementation": "{\n    return createAtomBonds;\n}", "repo_id": "9", "comment": "/**\n * Should we create bonds between atoms when parsing a file?\n *\n * @return true if we should create the bonds, false if not\n */\n", "repo_name": "biojava-master/", "id": 1329, "method_signature": "boolean shouldCreateAtomBonds()"}, "236": {"callee_method_names": [], "method_name": "Builder.setPsimodId", "method_implementation": "{\n    this.psimodId = psimodId;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the PSI-MOD ID.\n * @param psimodId PSI-MOD ID.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 236, "method_signature": "Builder setPsimodId(String)"}, "90": {"callee_method_names": [], "method_name": "AlignerHelper.setScoreVector", "method_implementation": "{\n    Last[][] pointers;\n    ensureScoringMatrixColumn(x, storing, scores);\n    if (x == xb) {\n        pointers = new Last[ye + 1][1];\n    } else {\n        pointers = new Last[ye + 1][1];\n        pointers[0] = new Last[1];\n        for (int y = 1; y < scores[x].length; y++) {\n            pointers[y][0] = setScorePoint(x, y, gep, subs[y], scores);\n            if (scores[x][y][0] <= 0) {\n                scores[x][y][0] = 0;\n                pointers[y][0] = null;\n            } else if (scores[x][y][0] > score) {\n                xyMax[0] = x;\n                xyMax[1] = y;\n                score = scores[x][y][0];\n            }\n        }\n    }\n    return pointers;\n}", "repo_id": "9", "comment": "/**\n * Score local alignment for a given position in the query sequence for a linear gap penalty\n * @param x\n * @param xb\n * @param yb\n * @param ye\n * @param gep\n * @param subs\n * @param storing\n * @param scores\n * @param xyMax\n * @param score\n * @return\n */\n", "repo_name": "biojava-master/", "id": 90, "method_signature": "Last[][] setScoreVector(int, int, int, int, int, int[], boolean, int[][][], int[], int)"}, "304": {"callee_method_names": ["ProteinModification.getCondition", "ModificationCondition.getLinkages", "List<List<Atom[]>>.size", "List<List<Atom[]>>.get", "List<List<Atom[]>>.get", "List<Atom[]>.add", "List<Atom[]>.size", "List<Atom[]>.get", "List<Group>.contains", "Atom[].getGroup", "List<Group>.contains", "Atom[].getGroup", "List<StructureAtomLinkage>.add", "Set<ModifiedCompound>.contains", "List<ModifiedCompound>.add", "Set<ModifiedCompound>.add", "List<List<Atom[]>>.get"], "method_name": "ProteinModificationIdentifier.assembleLinkages", "method_implementation": "{\n    ModificationCondition condition = mod.getCondition();\n    List<ModificationLinkage> modLinks = condition.getLinkages();\n    int nLink = matchedAtomsOfLinkages.size();\n    int[] indices = new int[nLink];\n    Set<ModifiedCompound> identifiedCompounds = new HashSet<ModifiedCompound>();\n    while (indices[0] < matchedAtomsOfLinkages.get(0).size()) {\n        List<Atom[]> atomLinkages = new ArrayList<Atom[]>(nLink);\n        for (int iLink = 0; iLink < nLink; iLink++) {\n            Atom[] atoms = matchedAtomsOfLinkages.get(iLink).get(indices[iLink]);\n            atomLinkages.add(atoms);\n        }\n        if (matchLinkages(modLinks, atomLinkages)) {\n            // matched\n            int n = atomLinkages.size();\n            List<StructureAtomLinkage> linkages = new ArrayList<StructureAtomLinkage>(n);\n            for (int i = 0; i < n; i++) {\n                Atom[] linkage = atomLinkages.get(i);\n                StructureAtomLinkage link = StructureUtil.getStructureAtomLinkage(linkage[0], residues.contains(linkage[0].getGroup()), linkage[1], residues.contains(linkage[1].getGroup()));\n                linkages.add(link);\n            }\n            ModifiedCompound mc = new ModifiedCompoundImpl(mod, linkages);\n            if (!identifiedCompounds.contains(mc)) {\n                ret.add(mc);\n                identifiedCompounds.add(mc);\n            }\n        }\n        // indices++ (e.g. [0,0,1]=>[0,0,2]=>[1,2,0])\n        int i = nLink - 1;\n        while (i >= 0) {\n            if (i == 0 || indices[i] < matchedAtomsOfLinkages.get(i).size() - 1) {\n                indices[i]++;\n                break;\n            } else {\n                indices[i] = 0;\n                i--;\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Assembly the matched linkages\n *\n * @param matchedAtomsOfLinkages\n * @param mod\n * @param ret ModifiedCompound will be stored here\n */\n", "repo_name": "biojava-master/", "id": 304, "method_signature": "void assembleLinkages(List, ProteinModification, List)"}, "2501": {"callee_method_names": ["LinkedHashMap<String, ChromosomeSequence>.values", "File.deleteOnExit", "LinkedHashMap<String, ProteinSequence>.values"], "method_name": "GeneFeatureHelperTest.testGetProteinSequences", "method_implementation": "{\n    LinkedHashMap<String, ChromosomeSequence> chromosomeSequenceList = GeneFeatureHelper.loadFastaAddGeneFeaturesFromGmodGFF3(new File(\"src/test/resources/volvox_all.fna\"), new File(\"src/test/resources/volvox.gff3\"), false);\n    LinkedHashMap<String, ProteinSequence> proteinSequenceList = GeneFeatureHelper.getProteinSequences(chromosomeSequenceList.values());\n    // for(ProteinSequence proteinSequence : proteinSequenceList.values()){\n    // logger.info(\"Output={}\", proteinSequence.getSequenceAsString());\n    // }\n    File tmp = Files.createTempFile(\"volvox_all\", \"faa\").toFile();\n    tmp.deleteOnExit();\n    FastaWriterHelper.writeProteinSequence(tmp, proteinSequenceList.values());\n    FileAssert.assertEquals(\"volvox_all_reference.faa and volvox_all.faa are not equal\", new File(\"src/test/resources/volvox_all_reference.faa\"), tmp);\n}", "repo_id": "9", "comment": "/**\n * Test of getProteinSequences method, of class GeneFeatureHelper. Used gff3 file that was modified from the volvox\n * gff version. Do not have the reference protein that is generated from each CDS record so subject to being\n * incorrect without a validated test case. Could not find anyone providing a gff3 test case with expected protein\n * output.\n */\n", "repo_name": "biojava-master/", "id": 2501, "method_signature": "void testGetProteinSequences()"}, "3648": {"callee_method_names": ["LinkedHashMap.put"], "method_name": "SurvivalInfo.updateContinousVariable", "method_implementation": "{\n    data.put(variable, value);\n}", "repo_id": "9", "comment": "/**\n * @param variable\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 3648, "method_signature": "void updateContinousVariable(String, Double)"}, "3282": {"callee_method_names": ["StringWriter.append", "StringWriter.append", "MultipleAlignment.getBlocks", "ColorBrewer.getColorPalette", "List<Atom[]>.size", "StringWriter.append", "MultipleAlignment.getBlockSets", "Integer.getAlignRes", "List<Atom[]>.get", "StringWriter.append", "StringWriter.append", "StringWriter.toString"], "method_name": "MultipleAlignmentJmol.getMultiBlockJmolString", "method_implementation": "{\n    StringWriter jmol = new StringWriter();\n    jmol.append(DEFAULT_SCRIPT);\n    jmol.append(\"select *; color lightgrey; backbone 0.1; \");\n    int blockNum = multAln.getBlocks().size();\n    Color[] colors = colorPalette.getColorPalette(blockNum);\n    // For every structure color all the blocks with the printBlock method\n    for (int str = 0; str < transformedAtoms.size(); str++) {\n        jmol.append(\"select */\" + (str + 1) + \"; color lightgrey; model \" + (str + 1) + \"; \");\n        int index = 0;\n        for (BlockSet bs : multAln.getBlockSets()) {\n            for (Block b : bs.getBlocks()) {\n                List<List<Integer>> alignRes = b.getAlignRes();\n                printJmolScript4Block(transformedAtoms.get(str), alignRes, colors[index], jmol, str, index, blockNum);\n                index++;\n            }\n        }\n    }\n    jmol.append(\"model 0;  \");\n    jmol.append(LIGAND_DISPLAY_SCRIPT);\n    return jmol.toString();\n}", "repo_id": "9", "comment": "/**\n * Colors every Block of the structures with a different color, following\n * the palette. It colors each Block differently, no matter if it is from\n * the same or different BlockSet.\n */\n", "repo_name": "biojava-master/", "id": 3282, "method_signature": "String getMultiBlockJmolString(MultipleAlignment, List, ColorBrewer, boolean)"}, "300": {"callee_method_names": ["List<ModifiedCompound>.size", "List<ModifiedCompound>.get", "ModifiedCompound.getModification", "TreeSet<Integer>.contains", "List<ModifiedCompound>.get", "ModifiedCompound.getGroups", "ModifiedCompound.getGroups", "List<ModifiedCompound>.get", "ModifiedCompound.getModification", "ModifiedCompound.addAtomLinkages", "ModifiedCompound.getAtomLinkages", "TreeSet<Integer>.add", "TreeSet<Integer>.descendingIterator", "Iterator<Integer>.hasNext", "List<ModifiedCompound>.remove", "Iterator<Integer>.next"], "method_name": "ProteinModificationIdentifier.mergeModComps", "method_implementation": "{\n    TreeSet<Integer> remove = new TreeSet<Integer>();\n    int n = modComps.size();\n    for (int icurr = 1; icurr < n; icurr++) {\n        ModifiedCompound curr = modComps.get(icurr);\n        String id = curr.getModification().getId();\n        if (ProteinModificationRegistry.getById(id).getCategory() != ModificationCategory.UNDEFINED)\n            continue;\n        // find linked compounds that before curr\n        //List<Integer> merging = new ArrayList<Integer>();\n        int ipre = 0;\n        for (; ipre < icurr; ipre++) {\n            if (remove.contains(ipre))\n                continue;\n            ModifiedCompound pre = modComps.get(ipre);\n            if (!Collections.disjoint(pre.getGroups(false), curr.getGroups(false))) {\n                break;\n            }\n        }\n        if (ipre < icurr) {\n            ModifiedCompound mcKeep = modComps.get(ipre);\n            // merge modifications of the same type\n            if (mcKeep.getModification().getId().equals(id)) {\n                // merging the current one to the previous one\n                mcKeep.addAtomLinkages(curr.getAtomLinkages());\n                remove.add(icurr);\n            }\n        }\n    }\n    Iterator<Integer> it = remove.descendingIterator();\n    while (it.hasNext()) {\n        modComps.remove(it.next().intValue());\n    }\n}", "repo_id": "9", "comment": "/**\n * Merge identified modified compounds if linked.\n */\n", "repo_name": "biojava-master/", "id": 300, "method_signature": "void mergeModComps(List)"}, "3751": {"callee_method_names": ["LinkedHashMap.keySet", "ArrayList<String>.add"], "method_name": "WorkSheet.getAllColumns", "method_implementation": "{\n    ArrayList<String> columns = new ArrayList<String>();\n    for (String col : columnLookup.keySet()) {\n        columns.add(col);\n    }\n    return columns;\n}", "repo_id": "9", "comment": "/**\n * Get the list of column names including those that may be hidden\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3751, "method_signature": "ArrayList<String> getAllColumns()"}, "3369": {"callee_method_names": ["Color.getColorSpace", "Color.getComponents", "Color.getComponents", "Color.getColorSpace", "Color.getComponents", "Color.getComponents"], "method_name": "LinearColorInterpolator.interpolate", "method_implementation": "{\n    float[] compA, compB;\n    // Get components\n    // Don't convert colorSpaces unless necessary\n    if (a.getColorSpace().equals(colorSpace)) {\n        compA = a.getComponents(null);\n    } else {\n        compA = a.getComponents(colorSpace, null);\n    }\n    if (b.getColorSpace().equals(colorSpace)) {\n        compB = b.getComponents(null);\n    } else {\n        compB = b.getComponents(colorSpace, null);\n    }\n    float[] compMixed = new float[compA.length];\n    for (int i = 0; i < compA.length; i++) {\n        //Normalizing to [0,1] after the interpolation,\n        // INNER means between a and b\n        // OUTER means between max(a,b) and min(a,b)+1\n        // UPPER means between a and b' s.t. b'>a and b' in {b, b+1}\n        // LOWER means between a and b' s.t. b'<a and b' in {b, b-1}\n        float left, right;\n        left = compA[i];\n        //Alpha uses INNER direction\n        InterpolationDirection dir = i < interpolationDirection.length ? interpolationDirection[i] : InterpolationDirection.INNER;\n        switch(dir) {\n            case INNER:\n                right = compB[i];\n                break;\n            case OUTER:\n                if (compA[i] < compB[i]) {\n                    right = compB[i] - 1;\n                } else {\n                    right = compB[i] + 1;\n                }\n                break;\n            case UPPER:\n                if (compA[i] < compB[i]) {\n                    right = compB[i];\n                } else {\n                    right = compB[i] + 1;\n                }\n                break;\n            case LOWER:\n                if (compA[i] < compB[i]) {\n                    right = compB[i] - 1;\n                } else {\n                    right = compB[i];\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Unkown interpolation Direction \" + interpolationDirection[i]);\n        }\n        //Perform mixing\n        compMixed[i] = mixing * left + (1 - mixing) * right;\n        if (dir != InterpolationDirection.INNER) {\n            //Normalize to [0,1]\n            if (compMixed[i] < 0)\n                compMixed[i] += 1f;\n            if (compMixed[i] > 1)\n                compMixed[i] -= 1f;\n        }\n    }\n    return new Color(colorSpace, compMixed, compMixed[compMixed.length - 1]);\n}", "repo_id": "9", "comment": "/**\n * Interpolates to a color between a and b\n * @param a First color\n * @param b Second color\n * @param mixing Mixing coefficient; the fraction of a in the result.\n * @return The color between a and b\n * @throws IllegalArgumentException if mixing is not between 0 and 1\n * @see org.biojava.nbio.structure.gui.util.color.ColorInterpolator#interpolate(java.awt.Color, java.awt.Color, float)\n */\n", "repo_name": "biojava-master/", "id": 3369, "method_signature": "Color interpolate(Color, Color, float)"}, "2142": {"callee_method_names": ["List<Model>.get", "Class<?>.getId"], "method_name": "StructureImpl.hasNonPolyChain", "method_implementation": "{\n    int modelnr = 0;\n    List<Chain> chains = models.get(modelnr).getNonPolyChains();\n    for (Chain c : chains) {\n        // we check here with equals because we might want to distinguish between upper and lower case chains!\n        if (c.getId().equals(asymId)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2142, "method_signature": "boolean hasNonPolyChain(String)"}, "1195": {"callee_method_names": ["List<List<Chain>>.add", "float.getName", "List<Chain>.add"], "method_name": "PDBFileParser.findChains", "method_implementation": "{\n    List<List<Chain>> models = new ArrayList<>();\n    for (List<Chain> chains : polyModels) {\n        List<Chain> matchingChains = new ArrayList<>();\n        models.add(matchingChains);\n        for (Chain c : chains) {\n            if (c.getName().equals(chainName)) {\n                matchingChains.add(c);\n            }\n        }\n    }\n    return models;\n}", "repo_id": "9", "comment": "/**\n * Gets all chains with given chainName from given models list\n * @param chainName\n * @param polyModels\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1195, "method_signature": "List<List<Chain>> findChains(String, List)"}, "3263": {"callee_method_names": [], "method_name": "AlignmentGui.actionPerformed", "method_implementation": "{\n    // Perform action...\n    abortCalc();\n    dispose();\n    System.exit(0);\n}", "repo_id": "9", "comment": "// This method is called when the button is pressed\n", "repo_name": "biojava-master/", "id": 3263, "method_signature": "void actionPerformed(ActionEvent)"}, "2954": {"callee_method_names": [], "method_name": "SequenceProxyView.setBioEnd", "method_implementation": "{\n    if (sequence == null) {\n        throw new NullPointerException(\"No sequence given before setting the end coordinate; cannot be done\");\n    }\n    // had a bug in the code that allowed this to work. The length of a any exon or cds sequence was always the length of the\n    //parent sequence. Sequence class doesn't have bioStart and bioEnd exposed to do a proper comparison of getting\n    // a subsequence. Januar-20=2011 Scooter\n    //   if (bioEnd > sequence.getLength()) {\n    //       throw new IllegalArgumentException(\"The given end \"\n    //               + bioEnd + \" is greater than sequence length\"\n    //               + sequence.getLength());\n    //   }\n    this.bioEnd = bioEnd;\n}", "repo_id": "9", "comment": "/**\n * @param bioEnd the bioEnd to set\n */\n", "repo_name": "biojava-master/", "id": 2954, "method_signature": "void setBioEnd(Integer)"}, "2323": {"callee_method_names": ["List<Subunit>.size", "List<Subunit>.get", "List<Subunit>.get", "List<Subunit>.get"], "method_name": "TestSubunitExtractor.testHistone", "method_implementation": "{\n    Structure s = StructureIO.getStructure(\"5B2I\");\n    List<Subunit> subunits = SubunitExtractor.extractSubunits(s, 5, 0.75, 20);\n    // We expect all 8 histone subunits to be returned\n    assertEquals(subunits.size(), 8);\n    assertEquals(subunits.get(0).size(), 99);\n    assertEquals(subunits.get(1).size(), 82);\n    assertEquals(subunits.get(2).size(), 106);\n}", "repo_id": "9", "comment": "/**\n * Make sure that only aminoacid chains are extracted: 5B2I.\n */\n", "repo_name": "biojava-master/", "id": 2323, "method_signature": "void testHistone()"}, "1777": {"callee_method_names": [], "method_name": "PDBHeader.setRelDate", "method_implementation": "{\n    this.relDate = relDate;\n}", "repo_id": "9", "comment": "/**\n * The release date of the structure in the PDB.\n *\n * @param relDate the release date\n */\n", "repo_name": "biojava-master/", "id": 1777, "method_signature": "void setRelDate(Date)"}, "2253": {"callee_method_names": ["Date.setTime"], "method_name": "TestMmtfUtils.testGetIsoDateString", "method_implementation": "{\n    Date inputDate = new Date();\n    inputDate.setTime(86500);\n    // One day after\n    assertEquals(\"1970-01-02\", MmtfUtils.dateToIsoString(inputDate));\n}", "repo_id": "9", "comment": "/**\n * Test getting the data as an appropriately formatted string.\n */\n", "repo_name": "biojava-master/", "id": 2253, "method_signature": "void testGetIsoDateString()"}, "3624": {"callee_method_names": [], "method_name": "CoxInfo.getChiSquare", "method_implementation": "{\n    return scoreLogrankTest;\n}", "repo_id": "9", "comment": "/**\n * @return the scoreLogrankTest\n */\n", "repo_name": "biojava-master/", "id": 3624, "method_signature": "double getChiSquare()"}, "3690": {"callee_method_names": ["ArrayList<SurvivalInfo>.get"], "method_name": "SurvivalInfoHelper.getGroupCategories", "method_implementation": "{\n    return survivalInfoList.get(0).getGroupCategories(groupName);\n}", "repo_id": "9", "comment": "/**\n * @param groupName\n * @param survivalInfoList\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3690, "method_signature": "ArrayList<String> getGroupCategories(String, ArrayList)"}, "3600": {"callee_method_ids": [3756, 3740, 3740, 3740, 3740, 3672, 3658, 3660, 3741, 3647, 3741, 3668, 3563], "callee_method_names": ["WorkSheet.getRows", "WorkSheet.getCellDouble", "WorkSheet.getCellDouble", "String.length", "WorkSheet.getCellDouble", "String.length", "WorkSheet.getCellDouble", "SurvivalInfo.setOrder", "SurvivalInfo.setWeight", "SurvivalInfo.setStrata", "int.contains", "WorkSheet.getCell", "SurvivalInfo.addUnknownDataTypeVariable", "String.length", "WorkSheet.getCell", "SurvivalInfo.setClusterValue", "ArrayList<SurvivalInfo>.add", "String.length", "CoxR.process", "double[][].printStackTrace"], "method_name": "CoxHelper.process", "method_implementation": "{\n    try {\n        ArrayList<SurvivalInfo> survivalInfoList = new ArrayList<SurvivalInfo>();\n        int i = 1;\n        for (String row : worksheet.getRows()) {\n            double time = worksheet.getCellDouble(row, timeColumn);\n            double c = worksheet.getCellDouble(row, statusColumn);\n            double weight = 1.0;\n            if (weightColumn != null && weightColumn.length() > 0) {\n                weight = worksheet.getCellDouble(row, weightColumn);\n            }\n            int strata = 0;\n            if (strataColumn != null && strataColumn.length() > 0) {\n                strata = worksheet.getCellDouble(row, strataColumn).intValue();\n            }\n            int censor = (int) c;\n            if (weight <= 0) {\n                //   System.out.println(\"Weight <= 0 Sample=\" + row + \" weight=\" + weight);\n                i++;\n                continue;\n            }\n            SurvivalInfo si = new SurvivalInfo(time, censor);\n            si.setOrder(i);\n            si.setWeight(weight);\n            si.setStrata(strata);\n            for (String column : variables) {\n                if (column.contains(\":\")) {\n                    continue;\n                }\n                String value = worksheet.getCell(row, column);\n                si.addUnknownDataTypeVariable(column, value);\n            }\n            if (clusterColumn != null && clusterColumn.length() > 0) {\n                String v = worksheet.getCell(row, clusterColumn);\n                si.setClusterValue(v);\n            }\n            survivalInfoList.add(si);\n            i++;\n        }\n        boolean cluster = false;\n        boolean robust = false;\n        if (clusterColumn != null && clusterColumn.length() > 0) {\n            cluster = true;\n            robust = true;\n        }\n        //       variables.add(\"TREAT:AGE\");\n        CoxR cox = new CoxR();\n        CoxInfo ci = cox.process(variables, survivalInfoList, useStrata, useWeights, robust, cluster);\n        // System.out.println(ci);\n        //applying Bob Gray's correction for weighted strata wtexamples.docx\n        //           CoxCC.process(ci, survivalInfoList);\n        //           ci.dump();\n        //           ci.calcSummaryValues();\n        return ci;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * @param worksheet\n * @param timeColumn The column representing the event/censor time\n * @param statusColumn The column representing an event=1 and censor=0\n * @param weightColumn For case-cohort data sets may require weighting to reflect the entire cohort\n * @param strataColumn A column representing strata data\n * @param clusterColumn If robost variation calculation is required the cluster column will group samples by the value in this column\n * @param variables The variables to be used in the cox regression analysis. For Interactions using variable1:variable2\n * @param useStrata Boolean to indicate if strata column should be used\n * @param useWeights Boolean to indicate if weight column should be used\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3600, "method_signature": "CoxInfo process(WorkSheet, String, String, String, String, String, ArrayList, boolean, boolean)"}, "946": {"callee_method_names": [], "method_name": "PassthroughIdentifier.loadStructure", "method_implementation": "{\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Passthrough identifiers don't know how to load a structure\n * @return null\n */\n", "repo_name": "biojava-master/", "id": 946, "method_signature": "Structure loadStructure(AtomCache)"}, "1495": {"callee_method_names": ["Point3d[].distanceSquared"], "method_name": "CalcPoint.contacts", "method_implementation": "{\n    int contacts = 0;\n    for (int i = 0; i < x.length; i++) {\n        double minDist = Double.MAX_VALUE;\n        for (int j = 0; j < y.length; j++) {\n            minDist = Math.min(minDist, x[i].distanceSquared(y[j]));\n        }\n        if (minDist < maxDistance * maxDistance) {\n            contacts++;\n        }\n    }\n    return contacts;\n}", "repo_id": "9", "comment": "/*\n\t * Needs documentation!\n\t *\n\t * @param x\n\t *\n\t * @param y\n\t *\n\t * @param maxDistance\n\t *\n\t * @return\n\t */\n", "repo_name": "biojava-master/", "id": 1495, "method_signature": "int contacts(Point3d[], Point3d[], double)"}, "523": {"callee_method_ids": [502, 487, 488, 490, 481, 490], "callee_method_names": ["AFPChain.getAlgorithmName", "AFPChain.setAlgorithmName", "AFPChain.getVersion", "AFPChain.setVersion", "AFPChain.getBlockNum", "AFPChain.getCa1Length", "AFPChain.getCa2Length", "AFPChain.getBlockResList", "AFPChain.getOptLen", "AFPChain.getPdbAln", "AFPChain.getOptLen", "Logger.warn", "String.split", "String.split", "Logger.warn", "AFPChain.setOptLen", "AFPChain.setOptAln", "AFPChain.setBlockResList"], "method_name": "AFPChainXMLParser.rebuildAFPChain", "method_implementation": "{\n    if (afpChain.getAlgorithmName() == null) {\n        afpChain.setAlgorithmName(DEFAULT_ALGORITHM_NAME);\n    }\n    if (afpChain.getVersion() == null) {\n        afpChain.setVersion(\"1.0\");\n    }\n    int blockNum = afpChain.getBlockNum();\n    int ca1Length = afpChain.getCa1Length();\n    int ca2Length = afpChain.getCa2Length();\n    int minLength = Math.min(ca1Length, ca2Length);\n    int[][][] optAln = new int[blockNum][2][minLength];\n    int[][][] blockResList = afpChain.getBlockResList();\n    if (blockResList == null) {\n        blockResList = new int[blockNum][2][minLength];\n    }\n    int[] optLen = afpChain.getOptLen();\n    String[][][] pdbAln = afpChain.getPdbAln();\n    int[] verifiedOptLen = null;\n    if (optLen != null)\n        verifiedOptLen = afpChain.getOptLen().clone();\n    else {\n        logger.warn(\"did not find optimal alignment, building up empty alignment.\");\n        optLen = new int[1];\n        optLen[0] = 0;\n    }\n    for (int blockNr = 0; blockNr < blockNum; blockNr++) {\n        //System.out.println(\"got block \" + blockNr + \" size: \" + optLen[blockNr]);\n        int verifiedEQR = -1;\n        for (int eqrNr = 0; eqrNr < optLen[blockNr]; eqrNr++) {\n            String pdbResnum1 = pdbAln[blockNr][0][eqrNr];\n            String pdbResnum2 = pdbAln[blockNr][1][eqrNr];\n            //System.out.println(blockNr + \" \" + eqrNr + \" got resnum: \" + pdbResnum1 + \" \" + pdbResnum2);\n            String[] spl1 = pdbResnum1.split(\":\");\n            String[] spl2 = pdbResnum2.split(\":\");\n            String chain1 = spl1[0];\n            String pdbres1 = spl1[1];\n            String chain2 = spl2[0];\n            String pdbres2 = spl2[1];\n            int pos1 = getPositionForPDBresunm(pdbres1, chain1, ca1);\n            int pos2 = getPositionForPDBresunm(pdbres2, chain2, ca2);\n            if (pos1 == -1 || pos2 == -1) {\n                // this can happen when parsing old files that contained Calcium atoms...\n                logger.warn(\"pos1: {} (residue {}), pos2: {} (residue {}), should never be -1. Probably parsing an old file.\", pos1, pdbResnum1, pos2, pdbResnum2);\n                verifiedOptLen[blockNr]--;\n                continue;\n            }\n            verifiedEQR++;\n            //System.out.println(blockNr + \" \" + eqrNr + \" \" + pos1 + \" \" + pos2);\n            optAln[blockNr][0][verifiedEQR] = pos1;\n            optAln[blockNr][1][verifiedEQR] = pos2;\n            blockResList[blockNr][0][verifiedEQR] = pos1;\n            blockResList[blockNr][1][verifiedEQR] = pos2;\n        }\n    }\n    afpChain.setOptLen(verifiedOptLen);\n    afpChain.setOptAln(optAln);\n    afpChain.setBlockResList(blockResList);\n    // build up alignment image:\n    AFPAlignmentDisplay.getAlign(afpChain, ca1, ca2);\n}", "repo_id": "9", "comment": "/**\n *  replace the PDB res nums with atom positions:\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n */\n", "repo_name": "biojava-master/", "id": 523, "method_signature": "void rebuildAFPChain(AFPChain, Atom[], Atom[])"}, "2510": {"callee_method_names": ["String.split", "String[].substring", "String[].length", "String.length", "String.length", "String.length", "String.charAt", "AminoAcidCompoundSet.getCompoundForString", "List<AminoAcidCompound>.add", "String.length", "String.charAt", "AminoAcidCompoundSet.getCompoundForString", "List<AminoAcidCompound>.add", "ScaledSubstitutionMatrix.setScale"], "method_name": "AAIndexFileParser.initMatrix", "method_implementation": "{\n    String[] spl = line.split(\" \");\n    // trim off the final , character\n    currentRows = spl[3].substring(0, spl[3].length() - 1);\n    currentCols = spl[6];\n    currentRowPos = -1;\n    int nrRows = currentRows.length();\n    int nrCols = currentCols.length();\n    matrix = new short[nrRows][nrCols];\n    rows = new ArrayList<AminoAcidCompound>();\n    cols = new ArrayList<AminoAcidCompound>();\n    //System.out.println(\">\" + currentRows+\"<\");\n    AminoAcidCompoundSet compoundSet = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    for (int i = 0; i < currentRows.length(); i++) {\n        char c = currentRows.charAt(i);\n        AminoAcidCompound aa = compoundSet.getCompoundForString(String.valueOf(c));\n        rows.add(aa);\n    }\n    for (int i = 0; i < currentCols.length(); i++) {\n        char c = currentRows.charAt(i);\n        AminoAcidCompound aa = compoundSet.getCompoundForString(String.valueOf(c));\n        cols.add(aa);\n    }\n    currentMatrix.setScale(scale);\n}", "repo_id": "9", "comment": "// process a line of type >M rows = ARNDCQEGHILKMFPSTWYV, cols = ARNDCQEGHILKMFPSTWYV<\n", "repo_name": "biojava-master/", "id": 2510, "method_signature": "void initMatrix(String)"}, "1727": {"callee_method_names": [], "method_name": "BasePairParameters.getShear", "method_implementation": "{\n    checkArgument(bp);\n    return pairingParameters[bp][3];\n}", "repo_id": "9", "comment": "/**\n * This method returns the shear in \u00c5 for the given base pair\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in \u00c5)\n */\n", "repo_name": "biojava-master/", "id": 1727, "method_signature": "Double getShear(int)"}, "707": {"callee_method_names": [], "method_name": "OptimalCECPParameters.isTryAllCPs", "method_implementation": "{\n    return tryAllCPs;\n}", "repo_id": "9", "comment": "/**\n * @return Whether we should try all CP sites\n */\n", "repo_name": "biojava-master/", "id": 707, "method_signature": "Boolean isTryAllCPs()"}, "541": {"callee_method_names": ["Atom[].clone", "Atom.setGroup", "Atom[].getGroup", "List<Atom>.add", "List<Atom>.toArray"], "method_name": "AFPTwister.getAtoms", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<Atom>();\n    for (int i = 0; i < length; i++) {\n        int p = positions[i];\n        Atom a;\n        if (clone) {\n            a = (Atom) ca[p].clone();\n            a.setGroup((Group) ca[p].getGroup().clone());\n        } else {\n            a = ca[p];\n        }\n        atoms.add(a);\n    }\n    return atoms.toArray(new Atom[0]);\n}", "repo_id": "9", "comment": "// most likely the clone flag is not needed\n", "repo_name": "biojava-master/", "id": 541, "method_signature": "Atom[] getAtoms(Atom[], int[], int, boolean)"}, "3605": {"callee_method_names": [], "method_name": "CoxInfo.getSurvivalInfoList", "method_implementation": "{\n    return survivalInfoList;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3605, "method_signature": "ArrayList<SurvivalInfo> getSurvivalInfoList()"}, "3718": {"callee_method_names": ["LinkedHashMap.clear"], "method_name": "WorkSheet.setMetaDataColumns", "method_implementation": "{\n    metaDataColumnsHashMap.clear();\n    markMetaDataColumns(metaDataColumns);\n}", "repo_id": "9", "comment": "/**\n * Clears existing meta data columns and sets new ones\n *\n * @param metaDataColumns\n */\n", "repo_name": "biojava-master/", "id": 3718, "method_signature": "void setMetaDataColumns(ArrayList)"}, "1355": {"callee_method_names": [], "method_name": "AminoAcidImpl.getC", "method_implementation": "{\n    return getAtom(\"C\");\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1355, "method_signature": "Atom getC()"}, "3433": {"callee_method_ids": [2102, 2096, 2098, 570], "callee_method_names": ["CeSymmResult.getAxes", "SymmetryAxes.getSymmetryAxes", "SymmetryAxes.getElementaryAxesObjects", "Color.getRotationAxis", "SymmetryAxes.getRepeatsCyclicForm", "List<Atom>.addAll", "List<Atom[]>.get", "RotationAxis.getJmolScript", "List<Atom>.toArray", "List<Atom>.size"], "method_name": "SymmetryDisplay.printSymmetryAxes", "method_implementation": "{\n    int id = 0;\n    String script = \"\";\n    SymmetryAxes axes = symm.getAxes();\n    List<Atom[]> repeats = SymmetryTools.toRepeatsAlignment(symm).getAtomArrays();\n    List<Axis> symmAxes;\n    if (allAxes) {\n        symmAxes = axes.getSymmetryAxes();\n    } else {\n        symmAxes = axes.getElementaryAxesObjects();\n    }\n    for (Axis a : symmAxes) {\n        RotationAxis rot = a.getRotationAxis();\n        List<List<Integer>> cyclicForm = axes.getRepeatsCyclicForm(a);\n        List<Atom> repAtoms = new ArrayList<Atom>();\n        for (List<Integer> cycle : cyclicForm) {\n            for (Integer repeat : cycle) {\n                repAtoms.addAll(Arrays.asList(repeats.get(repeat)));\n            }\n        }\n        script += rot.getJmolScript(repAtoms.toArray(new Atom[repAtoms.size()]), id);\n        id++;\n    }\n    return script;\n}", "repo_id": "9", "comment": "/**\n * Generates a String that displays the symmetry axes of a structure.\n *\n * @param symm\n *            CeSymmResult\n * @param allAxes Indicates whether all axes should be displayed or just\n *  the elemenatary ones\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3433, "method_signature": "String printSymmetryAxes(CeSymmResult, boolean)"}, "2217": {"callee_method_ids": [1330], "callee_method_names": ["FileParsingParameters.setCreateAtomBonds", "String.getBytes", "Structure.getPolyChains", "Chain.getAtomGroups", "Chain.getAtomGroup", "Group.getAtom", "Atom.getBonds", "Block.getAtomA", "Block.getAtomB", "List<Bond>.add", "List<Bond>.size", "Block.getAtomA", "Block.getAtomB", "Atom.getName", "Set<Character>.add", "Atom.getAltLoc", "Set<Character>.size", "Set<Character>.contains", "Set<Character>.contains"], "method_name": "TestAltLocs.testInterResidueBondsBetweenAltlocs", "method_implementation": "{\n    //  from 5MOO\n    String mmcifData = \"data_test\\n\" + \"# \\n\" + \"loop_\\n\" + \"_entity.id \\n\" + \"_entity.type \\n\" + \"_entity.src_method \\n\" + \"_entity.pdbx_description \\n\" + \"_entity.formula_weight \\n\" + \"_entity.pdbx_number_of_molecules \\n\" + \"_entity.pdbx_ec \\n\" + \"_entity.pdbx_mutation \\n\" + \"_entity.pdbx_fragment \\n\" + \"_entity.details \\n\" + \"1 polymer     nat 'Cationic trypsin' 23324.287 1   3.4.21.4 ? ? ? \\n\" + \"# \\n\" + \"loop_\\n\" + \"_entity_poly_seq.entity_id \\n\" + \"_entity_poly_seq.num \\n\" + \"_entity_poly_seq.mon_id \\n\" + \"_entity_poly_seq.hetero \\n\" + \"1 1  ILE n \\n\" + \"1 2  MET n \\n\" + \"# \\n\" + \"loop_\\n\" + \"_struct_asym.id \\n\" + \"_struct_asym.pdbx_blank_PDB_chainid_flag \\n\" + \"_struct_asym.pdbx_modified \\n\" + \"_struct_asym.entity_id \\n\" + \"_struct_asym.details \\n\" + \"A N N 1 ? \\n\" + \"# \\n\" + \"loop_\\n\" + \"_atom_site.group_PDB \\n\" + \"_atom_site.id \\n\" + \"_atom_site.type_symbol \\n\" + \"_atom_site.label_atom_id \\n\" + \"_atom_site.label_alt_id \\n\" + \"_atom_site.label_comp_id \\n\" + \"_atom_site.label_asym_id \\n\" + \"_atom_site.label_entity_id \\n\" + \"_atom_site.label_seq_id \\n\" + \"_atom_site.pdbx_PDB_ins_code \\n\" + \"_atom_site.Cartn_x \\n\" + \"_atom_site.Cartn_y \\n\" + \"_atom_site.Cartn_z \\n\" + \"_atom_site.occupancy \\n\" + \"_atom_site.B_iso_or_equiv \\n\" + \"_atom_site.pdbx_formal_charge \\n\" + \"_atom_site.auth_seq_id \\n\" + \"_atom_site.auth_comp_id \\n\" + \"_atom_site.auth_asym_id \\n\" + \"_atom_site.auth_atom_id \\n\" + \"_atom_site.pdbx_PDB_model_num \\n\" + \"ATOM   1385 N  N    . ILE A 1  1  ? 10.900  -16.328 -10.274 1.00 17.47 ? 103 ILE A N    1 \\n\" + \"ATOM   1386 C  CA   . ILE A 1  1  ? 10.885  -17.487 -9.388  1.00 17.76 ? 103 ILE A CA   1 \\n\" + \"ATOM   1387 C  C    . ILE A 1  1  ? 11.374  -17.058 -8.011  1.00 17.35 ? 103 ILE A C    1 \\n\" + \"ATOM   1388 O  O    . ILE A 1  1  ? 12.265  -16.211 -7.883  1.00 18.51 ? 103 ILE A O    1 \\n\" + \"ATOM   1389 C  CB   . ILE A 1  1  ? 11.721  -18.644 -9.986  1.00 18.19 ? 103 ILE A CB   1 \\n\" + \"ATOM   1390 C  CG1  . ILE A 1  1  ? 11.610  -19.916 -9.144  1.00 19.64 ? 103 ILE A CG1  1 \\n\" + \"ATOM   1391 C  CG2  . ILE A 1  1  ? 13.177  -18.246 -10.209 1.00 19.73 ? 103 ILE A CG2  1 \\n\" + \"ATOM   1392 C  CD1  . ILE A 1  1  ? 12.217  -21.162 -9.820  1.00 22.94 ? 103 ILE A CD1  1 \\n\" + \"ATOM   1393 H  H    A ILE A 1  1  ? 11.598  -15.614 -10.041 1.00 17.71 ? 103 ILE A H    1 \\n\" + \"ATOM   1394 D  D    B ILE A 1  1  ? 11.598  -15.614 -10.041 0.00 17.71 ? 103 ILE A D    1 \\n\" + \"ATOM   1395 H  HA   . ILE A 1  1  ? 9.856   -17.843 -9.277  1.00 17.70 ? 103 ILE A HA   1 \\n\" + \"ATOM   1396 H  HB   . ILE A 1  1  ? 11.300  -18.886 -10.957 1.00 18.93 ? 103 ILE A HB   1 \\n\" + \"ATOM   1397 H  HG12 . ILE A 1  1  ? 12.149  -19.788 -8.209  1.00 20.93 ? 103 ILE A HG12 1 \\n\" + \"ATOM   1398 H  HG13 . ILE A 1  1  ? 10.563  -20.127 -8.939  1.00 20.93 ? 103 ILE A HG13 1 \\n\" + \"ATOM   1399 H  HG21 . ILE A 1  1  ? 13.669  -19.035 -10.776 1.00 20.97 ? 103 ILE A HG21 1 \\n\" + \"ATOM   1400 H  HG22 . ILE A 1  1  ? 13.235  -17.312 -10.767 1.00 20.97 ? 103 ILE A HG22 1 \\n\" + \"ATOM   1401 H  HG23 . ILE A 1  1  ? 13.683  -18.144 -9.251  1.00 20.97 ? 103 ILE A HG23 1 \\n\" + \"ATOM   1402 H  HD11 . ILE A 1  1  ? 13.299  -21.078 -9.905  1.00 24.96 ? 103 ILE A HD11 1 \\n\" + \"ATOM   1403 H  HD12 . ILE A 1  1  ? 11.967  -22.036 -9.223  1.00 24.96 ? 103 ILE A HD12 1 \\n\" + \"ATOM   1404 H  HD13 . ILE A 1  1  ? 11.779  -21.281 -10.808 1.00 24.96 ? 103 ILE A HD13 1 \\n\" + \"ATOM   1405 N  N    A MET A 1  2  ? 10.748  -17.610 -6.975  0.47 16.12 ? 104 MET A N    1 \\n\" + \"ATOM   1406 N  N    B MET A 1  2  ? 10.802  -17.694 -6.986  0.53 17.92 ? 104 MET A N    1 \\n\" + \"ATOM   1407 C  CA   A MET A 1  2  ? 11.189  -17.392 -5.610  0.47 15.78 ? 104 MET A CA   1 \\n\" + \"ATOM   1408 C  CA   B MET A 1  2  ? 11.033  -17.368 -5.587  0.53 18.29 ? 104 MET A CA   1 \\n\" + \"ATOM   1409 C  C    A MET A 1  2  ? 10.952  -18.663 -4.810  0.47 15.91 ? 104 MET A C    1 \\n\" + \"ATOM   1410 C  C    B MET A 1  2  ? 10.882  -18.643 -4.767  0.53 17.40 ? 104 MET A C    1 \\n\" + \"ATOM   1411 O  O    A MET A 1  2  ? 10.120  -19.504 -5.154  0.47 18.21 ? 104 MET A O    1 \\n\" + \"ATOM   1412 O  O    B MET A 1  2  ? 10.018  -19.474 -5.052  0.53 20.02 ? 104 MET A O    1 \\n\" + \"ATOM   1413 C  CB   A MET A 1  2  ? 10.477  -16.204 -4.933  0.47 17.14 ? 104 MET A CB   1 \\n\" + \"ATOM   1414 C  CB   B MET A 1  2  ? 10.001  -16.336 -5.111  0.53 18.92 ? 104 MET A CB   1 \\n\" + \"ATOM   1415 C  CG   A MET A 1  2  ? 9.019   -16.476 -4.619  0.47 20.01 ? 104 MET A CG   1 \\n\" + \"ATOM   1416 C  CG   B MET A 1  2  ? 10.030  -16.038 -3.634  0.53 19.12 ? 104 MET A CG   1 \\n\" + \"ATOM   1417 S  SD   A MET A 1  2  ? 8.207   -15.088 -3.838  0.47 22.06 ? 104 MET A SD   1 \\n\" + \"ATOM   1418 S  SD   B MET A 1  2  ? 8.874   -14.724 -3.205  0.53 20.16 ? 104 MET A SD   1 \\n\" + \"ATOM   1419 C  CE   A MET A 1  2  ? 9.151   -14.973 -2.340  0.47 25.15 ? 104 MET A CE   1 \\n\" + \"ATOM   1420 C  CE   B MET A 1  2  ? 7.269   -15.536 -3.380  0.53 20.38 ? 104 MET A CE   1 \\n\" + \"ATOM   1421 H  H    A MET A 1  2  ? 9.931   -18.207 -7.055  0.47 15.58 ? 104 MET A H    1 \\n\" + \"ATOM   1422 H  H    B MET A 1  2  ? 10.144  -18.461 -7.109  0.53 18.91 ? 104 MET A H    1 \\n\" + \"ATOM   1423 H  HA   A MET A 1  2  ? 12.256  -17.182 -5.644  0.47 15.14 ? 104 MET A HA   1 \\n\" + \"ATOM   1424 H  HA   B MET A 1  2  ? 12.033  -16.953 -5.465  0.53 19.55 ? 104 MET A HA   1 \\n\" + \"ATOM   1425 H  HB2  A MET A 1  2  ? 10.986  -15.920 -4.008  0.47 17.68 ? 104 MET A HB2  1 \\n\" + \"ATOM   1426 H  HB3  A MET A 1  2  ? 10.484  -15.364 -5.622  0.47 17.68 ? 104 MET A HB3  1 \\n\" + \"ATOM   1427 H  HB3  B MET A 1  2  ? 9.001   -16.676 -5.398  0.53 20.49 ? 104 MET A HB3  1 \\n\" + \"ATOM   1428 H  HG2  A MET A 1  2  ? 8.490   -16.704 -5.546  0.47 20.93 ? 104 MET A HG2  1 \\n\" + \"ATOM   1429 H  HG3  A MET A 1  2  ? 8.956   -17.315 -3.927  0.47 20.93 ? 104 MET A HG3  1 \\n\" + \"ATOM   1430 H  HE2  A MET A 1  2  ? 9.861   -14.153 -2.440  0.47 27.31 ? 104 MET A HE2  1 \\n\" + \"ATOM   1431 H  HE2  B MET A 1  2  ? 7.346   -16.554 -2.998  0.53 23.03 ? 104 MET A HE2  1 \\n\" + \"ATOM   1432 H  HE3  B MET A 1  2  ? 6.996   -15.566 -4.437  0.53 23.03 ? 104 MET A HE3  1 \";\n    FileParsingParameters params = new FileParsingParameters();\n    params.setCreateAtomBonds(true);\n    Structure s = CifStructureConverter.fromInputStream(new ByteArrayInputStream(mmcifData.getBytes()), params);\n    Chain c = s.getPolyChains().get(0);\n    assertEquals(2, c.getAtomGroups().size());\n    // inter residue bonds and alt locs\n    // ILE-C (.) must be linked to both MET-N (A and B alt locs)\n    Group g1 = c.getAtomGroup(0);\n    Atom catom = g1.getAtom(\"C\");\n    List<Bond> bonds = new ArrayList<>();\n    for (Bond b : catom.getBonds()) {\n        if (b.getAtomA().getName().equals(\"N\") || b.getAtomB().getName().equals(\"N\")) {\n            bonds.add(b);\n        }\n    }\n    assertEquals(2, bonds.size());\n    Set<Character> seenAltLocs = new HashSet<>();\n    for (Bond b : bonds) {\n        Atom aAtom = b.getAtomA();\n        Atom bAtom = b.getAtomB();\n        Atom nAtom;\n        if (aAtom.getName().equals(\"N\")) {\n            nAtom = aAtom;\n        } else {\n            nAtom = bAtom;\n        }\n        seenAltLocs.add(nAtom.getAltLoc());\n    }\n    // 2 distinct N atoms: alt loc A and B\n    assertEquals(2, seenAltLocs.size());\n    assertTrue(seenAltLocs.contains('A'));\n    assertTrue(seenAltLocs.contains('B'));\n}", "repo_id": "9", "comment": "/**\n * Test that inter-residue bonds between alt locs link atoms with same altloc codes or default alt loc to all alt locs\n * https://github.com/rcsb/mmtf/issues/44\n */\n", "repo_name": "biojava-master/", "id": 2217, "method_signature": "void testInterResidueBondsBetweenAltlocs()"}, "2522": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum40", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum40\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 40 matrix by Henikoff & Henikoff\n * @return Blosum 40 matrix\n */\n", "repo_name": "biojava-master/", "id": 2522, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum40()"}, "1181": {"callee_method_ids": [1317], "callee_method_names": ["FileParsingParameters.isHeaderOnly", "String.substring", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "HashMap<String, Integer>.put", "List<Map<String, Integer>>.add", "Logger.info", "Element.getMessage"], "method_name": "PDBFileParser.pdb_CONECT_Handler", "method_implementation": "{\n    if (atomOverflow) {\n        return;\n    }\n    if (params.isHeaderOnly()) {\n        return;\n    }\n    // this try .. catch is e.g. to catch 1gte which has wrongly formatted lines...\n    try {\n        int atomserial = Integer.parseInt(line.substring(6, 11).trim());\n        Integer bond1 = conect_helper(line, 11, 16);\n        Integer bond2 = conect_helper(line, 16, 21);\n        Integer bond3 = conect_helper(line, 21, 26);\n        Integer bond4 = conect_helper(line, 26, 31);\n        Integer hyd1 = conect_helper(line, 31, 36);\n        Integer hyd2 = conect_helper(line, 36, 41);\n        Integer salt1 = conect_helper(line, 41, 46);\n        Integer hyd3 = conect_helper(line, 46, 51);\n        Integer hyd4 = conect_helper(line, 51, 56);\n        Integer salt2 = conect_helper(line, 56, 61);\n        //System.out.println(atomserial+ \" \"+ bond1 +\" \"+bond2+ \" \" +bond3+\" \"+bond4+\" \"+\n        //\t\t   hyd1+\" \"+hyd2 +\" \"+salt1+\" \"+hyd3+\" \"+hyd4+\" \"+salt2);\n        HashMap<String, Integer> cons = new HashMap<String, Integer>();\n        cons.put(\"atomserial\", atomserial);\n        if (bond1 != null)\n            cons.put(\"bond1\", bond1);\n        if (bond2 != null)\n            cons.put(\"bond2\", bond2);\n        if (bond3 != null)\n            cons.put(\"bond3\", bond3);\n        if (bond4 != null)\n            cons.put(\"bond4\", bond4);\n        if (hyd1 != null)\n            cons.put(\"hydrogen1\", hyd1);\n        if (hyd2 != null)\n            cons.put(\"hydrogen2\", hyd2);\n        if (salt1 != null)\n            cons.put(\"salt1\", salt1);\n        if (hyd3 != null)\n            cons.put(\"hydrogen3\", hyd3);\n        if (hyd4 != null)\n            cons.put(\"hydrogen4\", hyd4);\n        if (salt2 != null)\n            cons.put(\"salt2\", salt2);\n        connects.add(cons);\n    } catch (NumberFormatException e) {\n        logger.info(\"could not parse CONECT line correctly (\" + e.getMessage() + \"), at line : \" + line);\n        return;\n    }\n}", "repo_id": "9", "comment": "/**\n *  Handler for CONECT Record Format\n * \t<pre>\n * \t COLUMNS         DATA TYPE        FIELD           DEFINITION\n * \t ---------------------------------------------------------------------------------\n * \t 1 -  6         Record name      \"CONECT\"\n * \t 7 - 11         Integer          serial          Atom serial number\n * \t 12 - 16         Integer          serial          Serial number of bonded atom\n * \t 17 - 21         Integer          serial          Serial number of bonded atom\n * \t 22 - 26         Integer          serial          Serial number of bonded atom\n * \t 27 - 31         Integer          serial          Serial number of bonded atom\n * \t 32 - 36         Integer          serial          Serial number of hydrogen bonded\n * \t atom\n * \t 37 - 41         Integer          serial          Serial number of hydrogen bonded\n * \t atom\n * \t 42 - 46         Integer          serial          Serial number of salt bridged\n * \t atom\n * \t 47 - 51         Integer          serial          Serial number of hydrogen bonded\n * \t atom\n * \t 52 - 56         Integer          serial          Serial number of hydrogen bonded\n * \t atom\n * \t 57 - 61         Integer          serial          Serial number of salt bridged\n * \t atom\n * \t </pre>\n */\n", "repo_name": "biojava-master/", "id": 1181, "method_signature": "void pdb_CONECT_Handler(String)"}, "817": {"callee_method_names": [], "method_name": "AlternativeAlignment.getIdx1", "method_implementation": "{\n    return idx1;\n}", "repo_id": "9", "comment": "/**\n * the positions of the structure equivalent positions in atom set 1\n *\n * @return the array of the positions\n */\n", "repo_name": "biojava-master/", "id": 817, "method_signature": "int[] getIdx1()"}, "951": {"callee_method_names": ["String.trim", "String.replaceAll"], "method_name": "OperatorResolver.parseOperatorExpressionString", "method_implementation": "{\n    String expression = operatorExpression.trim();\n    // remove single quotes, i.e. '(1-49)' in 1CGM\n    expression = expression.replaceAll(\"'\", \"\");\n    if (BioAssemblyTools.isUnaryExpression(expression)) {\n        unaryOperators = BioAssemblyTools.parseUnaryOperatorExpression(expression);\n    } else {\n        binaryOperators = BioAssemblyTools.parseBinaryOperatorExpression(expression);\n    }\n    //System.out.println(\"OperatorResolver: unary: \" + unaryOperators + \" | binary: \" + binaryOperators);\n}", "repo_id": "9", "comment": "/**\n * Parses the operator expression and save the operators as a list\n * of unary or binary operators (i.e. matrix multiplication, see below).\n * Operation expressions are given in a compact notation and specify\n * matrices from the operations list.\n * An operation expression can be a comma-separated list 1, 5, 9,\n * a dash-delimited range 1-60 or a matrix multiplication involving two\n * or more lists or ranges. For instance, (X0)(1-20) specifies the\n * portion of the X174 procapsid crystal asymmetric unit belonging to\n * the first independent virus particle and corresponds\n * to the 20 transformations [X0][1], [X0][2], ... , [X0][20].\n * See C. Lawson, Acta Cryst., D64, 874-882, 2008.\n *\n * @param operatorExpression the operator expression to be parsed\n */\n", "repo_name": "biojava-master/", "id": 951, "method_signature": "void parseOperatorExpressionString(String)"}, "3349": {"callee_method_names": ["NavigableMap<Double, Color>.get", "NavigableMap<Double, Color>.get", "NavigableMap<Double, Color>.clear", "NavigableMap<Double, Color>.put", "NavigableMap<Double, Color>.put"], "method_name": "GradientMapper.clear", "method_implementation": "{\n    Color neg = mapping.get(Double.NEGATIVE_INFINITY);\n    Color pos = mapping.get(Double.POSITIVE_INFINITY);\n    mapping.clear();\n    mapping.put(Double.NEGATIVE_INFINITY, neg);\n    mapping.put(Double.POSITIVE_INFINITY, pos);\n}", "repo_id": "9", "comment": "/**\n * Clears all finite endpoints\n *\n * @see java.util.Map#clear()\n */\n", "repo_name": "biojava-master/", "id": 3349, "method_signature": "void clear()"}, "1433": {"callee_method_names": [], "method_name": "CrystalTransform.formatCoef", "method_implementation": "{\n    // rounding tolerance\n    double tol = 1e-6;\n    // zero case\n    if (Math.abs(coef) < tol) {\n        return \"0\";\n    }\n    // integer case\n    long num = Math.round(coef);\n    if (Math.abs(num - coef) < tol) {\n        return Long.toString(num);\n    }\n    // Other small cases\n    for (int denom = 2; denom < 12; denom++) {\n        num = Math.round(coef * denom);\n        if (num - coef * denom < tol) {\n            return String.format(\"%d/%d\", num, denom);\n        }\n    }\n    // Give up and use floating point;\n    return String.format(Locale.US, \"%.3f\", coef);\n}", "repo_id": "9", "comment": "/**\n * helper function to format simple fractions into rationals\n * @param coef\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1433, "method_signature": "String formatCoef(double)"}, "766": {"callee_method_names": [], "method_name": "StartupParameters.isPrintCE", "method_implementation": "{\n    return printCE;\n}", "repo_id": "9", "comment": "/**\n * Display the output string in CE style\n *\n * @return flag\n */\n", "repo_name": "biojava-master/", "id": 766, "method_signature": "boolean isPrintCE()"}, "2153": {"callee_method_names": [], "method_name": "StructureImpl.setSSBonds", "method_implementation": "{\n    this.ssbonds = ssbonds;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2153, "method_signature": "void setSSBonds(List)"}, "3476": {"callee_method_names": ["Map<?,?>.keySet", "StringBuilder.append", "BlastOutputParameterEnum.toString", "StringBuilder.append", "StringBuilder.append", "Map<?,?>.get", "Map<?,?>.get", "StringBuilder.append", "StringBuilder.substring"], "method_name": "MapToStringTransformer.transform", "method_implementation": "{\n    StringBuilder sb = new StringBuilder();\n    for (Object key : map.keySet()) {\n        sb.append(getSeparatorSequence());\n        String keyString = key != null ? key.toString() : getNullValue();\n        sb.append(keyString);\n        sb.append(getMappingSequence());\n        String valueString = map.get(key) != null ? map.get(key).toString() : getNullValue();\n        sb.append(valueString);\n    }\n    return sb.substring(1);\n}", "repo_id": "9", "comment": "/**\n * Transforms {@code Map} to {@code String}, representing every entry as\n * {@code key} {@code mappingSequence} {@code value} , joined by\n * {@code separatorSequence}\n * <p>\n * Calls {@code toString()} for keys and values, replacing {@code null} with\n * the value of {@code nullValue} property\n * <p>\n * For example, if we have a map with two entries: {@code (\"key1\", \"1\")} and\n * {@code (\"key2\", \"2\")} this method would return {@code \"key1=1&key2=2\"} if\n * {@code mappingSequence} is \"=\" and separator sequence is \"&\";\n *\n * @param map map of arguments\n * @return String resulting string\n */\n", "repo_name": "biojava-master/", "id": 3476, "method_signature": "String transform(Map)"}, "3291": {"callee_method_names": [], "method_name": "MultipleAlignmentCoordManager.getSeqPos", "method_implementation": "{\n    int x = p.x - DEFAULT_X_SPACE - DEFAULT_LEGEND_SIZE;\n    int y = p.y - DEFAULT_Y_SPACE;\n    y -= (DEFAULT_LINE_SEPARATION * aligSeq) - DEFAULT_CHAR_SIZE;\n    int lineNr = y / DEFAULT_Y_STEP;\n    int linePos = x / DEFAULT_CHAR_SIZE;\n    return lineNr * DEFAULT_LINE_LENGTH + linePos;\n}", "repo_id": "9", "comment": "/**\n * Convert from an X position in the JPanel to the position\n * in the sequence alignment.\n *\n * @param aligSeq sequence number\n * @param p point on panel\n * @return the sequence position for a point on the Panel\n */\n", "repo_name": "biojava-master/", "id": 3291, "method_signature": "int getSeqPos(int, Point)"}, "1916": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.isOnTheFly", "method_implementation": "{\n    return onTheFly;\n}", "repo_id": "9", "comment": "/**\n * On-the-fly Jmol bioassembly generation.\n *\n * @return true if Jmol on the fly bioassembly generation is used\n */\n", "repo_name": "biojava-master/", "id": 1916, "method_signature": "boolean isOnTheFly()"}, "2812": {"callee_method_names": [], "method_name": "IOUtils.getList", "method_implementation": "{\n    return getList(openFile(file));\n}", "repo_id": "9", "comment": "/**\n * Delegates to {@link #getList(InputStream)} by wrapping the File\n * in a valid stream. No encoding is mentioned so if you need anything\n * more advanced then use the other version of this method. Since this\n * uses {@link #openFile(File)} this code can support GZipped and plain\n * files.\n *\n * @param file File which is a text file\n * @return List of Strings representing the lines of the files\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2812, "method_signature": "List<String> getList(File)"}, "1065": {"callee_method_names": ["Set<String>.add", "ResidueRange.getChainName"], "method_name": "CathDomain.getChains", "method_implementation": "{\n    Set<String> chains = new HashSet<String>();\n    List<ResidueRange> rrs = toCanonical().getResidueRanges();\n    for (ResidueRange rr : rrs) chains.add(rr.getChainName());\n    return chains;\n}", "repo_id": "9", "comment": "/**\n * Returns the chains this domain is defined over; contains more than 1 element only if this domains is a multi-chain domain.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 1065, "method_signature": "Set<String> getChains()"}, "1199": {"callee_method_names": ["List<List<Chain>>.add", "List<List<Chain>>.add", "List<List<Chain>>.add", "char[].isWaterOnly", "List<Chain>.add", "char[].isPureNonPolymer", "List<Chain>.add", "List<Chain>.add", "List<List<Chain>>.size", "List<List<Chain>>.get", "List<List<Chain>>.get", "List<List<Chain>>.add", "List<Chain>.addAll", "List<List<Chain>>.get", "List<Chain>.addAll", "List<List<Chain>>.get", "ArrayList.isEmpty", "HashMap.get", "ChemComp.getMolId", "ChemComp.addChain", "Chain.setEntityInfo", "List<Chain>.isEmpty", "Logger.warn", "ChemComp.getMolId", "Logger.info", "List<List<Chain>>.size", "List<Chain>.addAll", "List<List<Chain>>.get", "List<Chain>.addAll", "List<List<Chain>>.get", "List<Chain>.addAll", "List<List<Chain>>.get", "Structure.addModel"], "method_name": "PDBFileParser.assignChainsAndEntities", "method_implementation": "{\n    List<List<Chain>> polyModels = new ArrayList<>();\n    List<List<Chain>> nonPolyModels = new ArrayList<>();\n    List<List<Chain>> waterModels = new ArrayList<>();\n    for (List<Chain> model : allModels) {\n        List<Chain> polyChains = new ArrayList<>();\n        List<Chain> nonPolyChains = new ArrayList<>();\n        List<Chain> waterChains = new ArrayList<>();\n        polyModels.add(polyChains);\n        nonPolyModels.add(nonPolyChains);\n        waterModels.add(waterChains);\n        for (Chain c : model) {\n            // we only have entities for polymeric chains, all others are ignored for assigning entities\n            if (c.isWaterOnly()) {\n                waterChains.add(c);\n            } else if (c.isPureNonPolymer()) {\n                nonPolyChains.add(c);\n            } else {\n                polyChains.add(c);\n            }\n        }\n    }\n    List<List<Chain>> splitNonPolyModels = new ArrayList<>();\n    for (int i = 0; i < nonPolyModels.size(); i++) {\n        List<Chain> nonPolyModel = nonPolyModels.get(i);\n        List<Chain> waterModel = waterModels.get(i);\n        List<Chain> splitNonPolys = new ArrayList<>();\n        splitNonPolyModels.add(splitNonPolys);\n        for (Chain nonPoly : nonPolyModel) {\n            List<List<Chain>> splits = splitNonPolyChain(nonPoly);\n            splitNonPolys.addAll(splits.get(0));\n            waterModel.addAll(splits.get(1));\n        }\n    }\n    // now we have all chains as in mmcif, let's assign ids following the mmcif rules\n    assignAsymIds(polyModels, splitNonPolyModels, waterModels);\n    if (!entities.isEmpty()) {\n        // if the file contained COMPOUND records then we can assign entities to the poly chains\n        for (EntityInfo comp : entities) {\n            List<String> chainIds = compoundMolIds2chainIds.get(comp.getMolId());\n            if (chainIds == null)\n                continue;\n            for (String chainId : chainIds) {\n                List<List<Chain>> models = findChains(chainId, polyModels);\n                for (List<Chain> matchingChains : models) {\n                    for (Chain chain : matchingChains) {\n                        comp.addChain(chain);\n                        chain.setEntityInfo(comp);\n                    }\n                    if (matchingChains.isEmpty()) {\n                        // usually if this happens something is wrong with the PDB header\n                        // e.g. 2brd - there is no Chain A, although it is specified in the header\n                        // Some bona-fide cases exist, e.g. 2ja5, chain N is described in SEQRES\n                        // but the authors didn't observe in the density so it's completely missing\n                        // from the ATOM lines\n                        logger.warn(\"Could not find polymeric chain {} to link to entity {}. The chain will be missing in the entity.\", chainId, comp.getMolId());\n                    }\n                }\n            }\n        }\n    } else {\n        logger.info(\"Entity information (COMPOUND record) not found in file. Will assign entities heuristically\");\n        // if no entity information was present in file we then go and find the entities heuristically with EntityFinder\n        entities = EntityFinder.findPolyEntities(polyModels);\n    }\n    // now we assign entities to the nonpoly and water chains\n    EntityFinder.createPurelyNonPolyEntities(splitNonPolyModels, waterModels, entities);\n    // in some rare cases purely non-polymer or purely water chain are present in pdb files\n    // see https://github.com/biojava/biojava/pull/394\n    // these case should be covered by the above\n    // now that we have entities in chains we add the chains to the structure\n    for (int i = 0; i < allModels.size(); i++) {\n        List<Chain> model = new ArrayList<>();\n        model.addAll(polyModels.get(i));\n        model.addAll(splitNonPolyModels.get(i));\n        model.addAll(waterModels.get(i));\n        structure.addModel(model);\n    }\n}", "repo_id": "9", "comment": "/**\n * Here we assign chains following the mmCIF data model:\n * one chain per polymer, one chain per non-polymer group and\n * several water chains.\n * <p>\n * Subsequently we assign entities for them: either from those read from\n * COMPOUND records or from those found heuristically through {@link EntityFinder}\n */\n", "repo_name": "biojava-master/", "id": 1199, "method_signature": "void assignChainsAndEntities()"}, "514": {"callee_method_names": ["AFPChain.getAlgorithmName"], "method_name": "AfpChainWriter.toWebSiteDisplay", "method_implementation": "{\n    boolean printLegend = true;\n    boolean longHeader = true;\n    boolean showHTML = true;\n    if (afpChain.getAlgorithmName().equalsIgnoreCase(FatCatFlexible.algorithmName)) {\n        String msg = toFatCatCore(afpChain, ca1, ca2, printLegend, longHeader, showHTML, showAlignmentBlock);\n        return msg;\n    }\n    boolean showSeq = true;\n    AFPAlignmentDisplay.getAlign(afpChain, ca1, ca2, showSeq);\n    //      String msg= toFatCatCore(afpChain,ca1,ca2, printLegend,longHeader);\n    //\n    String msg = toPrettyAlignment(afpChain, ca1, ca2, showHTML, showAlignmentBlock);\n    msg = msg + newline + \"     <span class=\\\"m\\\">|</span> ... Structurally equivalent and identical residues \" + newline + \"     <span class=\\\"sm\\\">:</span> ... Structurally equivalent and similar residues \" + newline + \"     <span class=\\\"qg\\\">.</span> ... Structurally equivalent, but not similar residues. \" + newline;\n    msg += newline;\n    msg += \"     To calculate the coordinates of chain 2 aligned on chain 1 apply the following transformation: \";\n    msg += newline;\n    msg += newline;\n    msg += toRotMat(afpChain);\n    return msg;\n}", "repo_id": "9", "comment": "/**\n * Prints the afpChain as a nicely formatted alignment, including alignment\n * statistics, the aligned sequences themselves, and information about the\n * superposition.\n * @param afpChain\n * @param ca1\n * @param ca2\n *\n * @return a String representation as it is used on the RCSB PDB web site for display.\n */\n", "repo_name": "biojava-master/", "id": 514, "method_signature": "String toWebSiteDisplay(AFPChain, Atom[], Atom[], boolean)"}, "2019": {"callee_method_names": [], "method_name": "Prism.setCirumscribedRadius", "method_implementation": "{\n    this.circumscribedRadius = cirumscribedRadius;\n}", "repo_id": "9", "comment": "/**\n * Set the radius of a circumscribed sphere, that goes\n * through all vertices\n * @param cirumscribedRadius the cirumscribedRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2019, "method_signature": "void setCirumscribedRadius(double)"}, "3726": {"callee_method_names": ["String.length"], "method_name": "WorkSheet.hideEmptyColumns", "method_implementation": "{\n    ArrayList<String> rows = this.getDataRows();\n    ArrayList<String> columns = this.getDataColumns();\n    for (String column : columns) {\n        boolean emptyColumn = true;\n        for (String row : rows) {\n            String value = this.getCell(row, column).trim();\n            if (value.length() > 0) {\n                emptyColumn = false;\n                break;\n            }\n        }\n        if (emptyColumn) {\n            hideColumn(column, true);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3726, "method_signature": "void hideEmptyColumns()"}, "841": {"callee_method_names": [], "method_name": "GroupAsa.getAsaC", "method_implementation": "{\n    return asaC;\n}", "repo_id": "9", "comment": "/**\n * Returns the ASA of the residue in the complexed state\n * @return\n */\n", "repo_name": "biojava-master/", "id": 841, "method_signature": "double getAsaC()"}, "2583": {"callee_method_names": ["Map<Integer, Set<Integer>>.keySet", "Map<Integer, Set<Integer>>.get", "Set<Integer>.contains", "LinkedPair[].getFirst", "Set<Integer>.contains", "LinkedPair[].getSecond", "Set<Integer>.add", "LinkedPair[].getFirst", "Set<Integer>.add", "LinkedPair[].getSecond", "Map<Integer, Set<Integer>>.put", "Map<Integer, Set<Integer>>.get", "LinkedPair[].getSecond", "Map<Integer, Set<Integer>>.get", "LinkedPair[].getFirst", "Map<Integer, Set<Integer>>.get", "Map<Integer, Set<Integer>>.get", "Set<Integer>.size", "Set<Integer>.size", "Logger.debug", "Set<Integer>.add", "Map<Integer, Set<Integer>>.remove", "Logger.debug", "Set<Integer>.add", "Map<Integer, Set<Integer>>.remove", "Logger.debug", "Logger.debug", "Map<Integer, Set<Integer>>.keySet", "Map<Integer, Set<Integer>>.put", "Map<Integer, Set<Integer>>.get", "Map<Integer, Set<Integer>>.values", "StructureInterfaceCluster.contains", "Set<Integer>.add", "Map<Integer, Set<Integer>>.put", "Logger.debug"], "method_name": "SingleLinkageClusterer.getClusters", "method_implementation": "{\n    if (dendrogram == null) {\n        clusterIt();\n    }\n    Map<Integer, Set<Integer>> clusters = new TreeMap<Integer, Set<Integer>>();\n    int clusterId = 1;\n    for (int i = 0; i < numItems - 1; i++) {\n        if (isWithinCutoff(i, cutoff)) {\n            //int containingClusterId = getContainingCluster(clusters, dendrogram[i]);\n            int firstClusterId = -1;\n            int secondClusterId = -1;\n            for (int cId : clusters.keySet()) {\n                Set<Integer> members = clusters.get(cId);\n                if (members.contains(dendrogram[i].getFirst())) {\n                    firstClusterId = cId;\n                }\n                if (members.contains(dendrogram[i].getSecond())) {\n                    secondClusterId = cId;\n                }\n            }\n            if (firstClusterId == -1 && secondClusterId == -1) {\n                // neither member is in a cluster yet, let's assign a new cluster and put them both in\n                Set<Integer> members = new TreeSet<Integer>();\n                members.add(dendrogram[i].getFirst());\n                members.add(dendrogram[i].getSecond());\n                clusters.put(clusterId, members);\n                clusterId++;\n            } else if (firstClusterId != -1 && secondClusterId == -1) {\n                // first member was in firstClusterId already, we add second\n                clusters.get(firstClusterId).add(dendrogram[i].getSecond());\n            } else if (secondClusterId != -1 && firstClusterId == -1) {\n                // second member was in secondClusterId already, we add first\n                clusters.get(secondClusterId).add(dendrogram[i].getFirst());\n            } else {\n                // both were in different clusters already\n                // we need to join them: necessarily one must be of size 1 and the other of size>=1\n                Set<Integer> firstCluster = clusters.get(firstClusterId);\n                Set<Integer> secondCluster = clusters.get(secondClusterId);\n                if (firstCluster.size() < secondCluster.size()) {\n                    logger.debug(\"Joining cluster \" + firstClusterId + \" to cluster \" + secondClusterId);\n                    // we join first onto second\n                    for (int member : firstCluster) {\n                        secondCluster.add(member);\n                    }\n                    clusters.remove(firstClusterId);\n                } else {\n                    logger.debug(\"Joining cluster \" + secondClusterId + \" to cluster \" + firstClusterId);\n                    // we join second onto first\n                    for (int member : secondCluster) {\n                        firstCluster.add(member);\n                    }\n                    clusters.remove(secondClusterId);\n                }\n            }\n            logger.debug(\"Within cutoff:     {}\", dendrogram[i]);\n        } else {\n            logger.debug(\"Not within cutoff: {}\", dendrogram[i]);\n        }\n    }\n    // reassigning cluster numbers by creating a new map (there can be gaps in the numbering if cluster-joining happened)\n    Map<Integer, Set<Integer>> finalClusters = new TreeMap<Integer, Set<Integer>>();\n    int newClusterId = 1;\n    for (int oldClusterId : clusters.keySet()) {\n        finalClusters.put(newClusterId, clusters.get(oldClusterId));\n        newClusterId++;\n    }\n    // anything not clustered is assigned to a singleton cluster (cluster with one member)\n    for (int i = 0; i < numItems; i++) {\n        boolean isAlreadyClustered = false;\n        for (Set<Integer> cluster : finalClusters.values()) {\n            if (cluster.contains(i)) {\n                isAlreadyClustered = true;\n                break;\n            }\n        }\n        if (!isAlreadyClustered) {\n            Set<Integer> members = new TreeSet<Integer>();\n            members.add(i);\n            finalClusters.put(newClusterId, members);\n            newClusterId++;\n        }\n    }\n    logger.debug(\"Clusters: \\n{}\", clustersToString(finalClusters));\n    return finalClusters;\n}", "repo_id": "9", "comment": "/**\n * Get the clusters by cutting the dendrogram at given cutoff\n * @param cutoff\n * @return Map from cluster numbers to indices of the cluster members\n */\n", "repo_name": "biojava-master/", "id": 2583, "method_signature": "Map<Integer,Set<Integer>> getClusters(double)"}, "1464": {"callee_method_names": [], "method_name": "CrystalCell.getCellIndices", "method_implementation": "{\n    Point3d p = new Point3d(pt);\n    this.transfToCrystal(p);\n    int x = (int) Math.floor(p.x);\n    int y = (int) Math.floor(p.y);\n    int z = (int) Math.floor(p.z);\n    return new Point3i(x, y, z);\n}", "repo_id": "9", "comment": "/**\n * Get the index of a unit cell to which the query point belongs.\n *\n * <p>For instance, all points in the unit cell at the origin will return (0,0,0);\n * Points in the unit cell one unit further along the `a` axis will return (1,0,0),\n * etc.\n * @param pt Input point (in orthonormal coordinates)\n * @return A new point with the three indices of the cell containing pt\n */\n", "repo_name": "biojava-master/", "id": 1464, "method_signature": "Point3i getCellIndices(Tuple3d)"}, "3840": {"callee_method_names": ["String.toCharArray", "Set<Character>.contains"], "method_name": "Utils.doesSequenceContainInvalidChar", "method_implementation": "{\n    for (char c : sequence.toCharArray()) {\n        if (!cSet.contains(c))\n            return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Checks if given sequence contains invalid characters. Returns true if invalid characters are found, else return false.\n * Note that any characters are deemed as valid only if it is found in cSet.\n *\n * @param sequence\n * \t\tprotein sequence to be check.\n * @param cSet\n * \t\tthe set of characters that are deemed valid.\n * @return\n * \t\ttrue if invalid characters are found, else return false.\n */\n", "repo_name": "biojava-master/", "id": 3840, "method_signature": "boolean doesSequenceContainInvalidChar(String, Set)"}, "3855": {"callee_method_names": ["HashMap.put", "HashMap.put", "HashMap.put"], "method_name": "Constraints.initExtinctionCoefficient", "method_implementation": "{\n    aa2ExtinctionCoefficient.put(Y, 1490.0);\n    aa2ExtinctionCoefficient.put(W, 5500.0);\n    aa2ExtinctionCoefficient.put(C, 125.0);\n}", "repo_id": "9", "comment": "/**\n * Does the initialization of extinction coefficient based on\n * http://au.expasy.org/tools/protparam-doc.html\n */\n", "repo_name": "biojava-master/", "id": 3855, "method_signature": "void initExtinctionCoefficient()"}, "788": {"callee_method_ids": [491], "callee_method_names": ["List<List<List<Integer>>>.size", "List<List<List<Integer>>>.size", "List<List<List<Integer>>>.size", "List<List<List<Integer>>>.get", "List<List<List<Integer>>>.get", "List<List<List<Integer>>>.get", "List<List<List<Integer>>>.get", "List<List<List<Integer>>>.get", "List<List<List<Integer>>>.get", "AFPChain.setBlockNum", "AFPChain.setOptAln", "AFPChain.setOptLen", "AFPChain.setOptLength"], "method_name": "OptimalCECPMain.assignOptAln", "method_implementation": "{\n    int[][][] optAln = new int[blocks.size()][][];\n    int[] optLen = new int[blocks.size()];\n    int optLength = 0;\n    int numBlocks = blocks.size();\n    for (int block = 0; block < numBlocks; block++) {\n        // block should be 2xN rectangular\n        assert (blocks.get(block).size() == 2);\n        assert (blocks.get(block).get(0).size() == blocks.get(block).get(1).size());\n        optLen[block] = blocks.get(block).get(0).size();\n        optLength += optLen[block];\n        optAln[block] = new int[][] { new int[optLen[block]], new int[optLen[block]] };\n        for (int pos = 0; pos < optLen[block]; pos++) {\n            optAln[block][0][pos] = blocks.get(block).get(0).get(pos);\n            optAln[block][1][pos] = blocks.get(block).get(1).get(pos);\n        }\n    }\n    afpChain.setBlockNum(numBlocks);\n    afpChain.setOptAln(optAln);\n    afpChain.setOptLen(optLen);\n    afpChain.setOptLength(optLength);\n    // TODO I don't know what these do. Should they be set?\n    //afpChain.setBlockSize(blockSize);\n    //afpChain.setBlockResList(blockResList);\n    //afpChain.setChainLen(chainLen);\n}", "repo_id": "9", "comment": "/**\n * Sometimes it's convenient to store an alignment using java collections,\n * where <tt>blocks.get(blockNum).get(0).get(pos)</tt> specifies the aligned\n * residue at position <i>pos</i> of block <i>blockNum</i> of the first\n * protein.\n *\n * This method takes such a collection and stores it into the afpChain's\n * {@link AFPChain#setOptAln(int[][][]) optAln}, setting the associated\n * length variables as well.\n *\n * @param afpChain\n * @param blocks\n */\n", "repo_name": "biojava-master/", "id": 788, "method_signature": "void assignOptAln(AFPChain, List)"}, "2739": {"callee_method_names": [], "method_name": "EmblRecord.getOrGanelle", "method_implementation": "{\n    return orGanelle;\n}", "repo_id": "9", "comment": "/**\n * The OG (OrGanelle) linetype indicates the sub-cellular location of non-nuclear\n * sequences.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2739, "method_signature": "String getOrGanelle()"}, "1882": {"callee_method_names": [], "method_name": "HelixSolver.getAngle", "method_implementation": "{\n    return getAxisAngle(transformation).angle;\n}", "repo_id": "9", "comment": "/**\n * Returns the pitch angle of the helix\n *\n * @param transformation\n *            helix transformation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1882, "method_signature": "double getAngle(Matrix4d)"}, "2518": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getIdentity", "method_implementation": "{\n    return getAminoAcidMatrix(\"identity\");\n}", "repo_id": "9", "comment": "/**\n * Gets identity matrix where matches score 1 and mismatches score -10000\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2518, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getIdentity()"}, "2535": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getNuc4_2", "method_implementation": "{\n    return getNucleotideMatrix(\"nuc-4_2\");\n}", "repo_id": "9", "comment": "/**\n * Returns Nuc 4.2 matrix by Lowe\n * Only the first nucleotide sequence to align can contain ambiguous nucleotides\n * @return Nuc 4.2 matrix\n */\n", "repo_name": "biojava-master/", "id": 2535, "method_signature": "SubstitutionMatrix<NucleotideCompound> getNuc4_2()"}, "2807": {"callee_method_names": ["Closeable.close", "Logger.warn"], "method_name": "IOUtils.close", "method_implementation": "{\n    try {\n        if (c != null) {\n            c.close();\n        }\n    } catch (IOException e) {\n        logger.warn(\"Cannot close down the given Closeable object\", e);\n    }\n}", "repo_id": "9", "comment": "/**\n * Closes any Object which implements the interface {@link Closeable} and\n * sending any error to the logger but not forcing any explicit catching of\n * stream errors.\n *\n * @param c The stream to close\n */\n", "repo_name": "biojava-master/", "id": 2807, "method_signature": "void close(Closeable)"}, "967": {"callee_method_names": [], "method_name": "BioAssemblyTools.getBiologicalMoleculeMaximumExtend", "method_implementation": "{\n    double[][] bounds = getBiologicalMoleculeBounds(structure, transformations);\n    double xMax = Math.abs(bounds[0][0] - bounds[1][0]);\n    double yMax = Math.abs(bounds[0][1] - bounds[1][1]);\n    double zMax = Math.abs(bounds[0][2] - bounds[1][2]);\n    return Math.max(xMax, Math.max(yMax, zMax));\n}", "repo_id": "9", "comment": "/**\n * Returns the maximum extend of the biological molecule in the x, y, or z direction.\n * @param structure\n * @return maximum extend\n */\n", "repo_name": "biojava-master/", "id": 967, "method_signature": "double getBiologicalMoleculeMaximumExtend(Structure, List)"}, "883": {"callee_method_names": [], "method_name": "StructureInterface.getFirstGroupAsas", "method_implementation": "{\n    return groupAsas1;\n}", "repo_id": "9", "comment": "/**\n * Gets a map of ResidueNumbers to GroupAsas for all groups of first chain.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 883, "method_signature": "Map<ResidueNumber,GroupAsa> getFirstGroupAsas()"}, "1269": {"callee_method_names": ["Group.getAtoms", "List<Atom>.size", "List<Atom>.get", "Atom.getAltLoc", "Group.getAltLocGroup", "Group.addAltLoc", "Chain.getAtomGroups", "Group.getAtoms", "Group.clone", "Group.setAtoms", "Group.getAltLocs", "Group.addAltLoc"], "method_name": "MmtfStructureReader.getCorrectAltLocGroup", "method_implementation": "{\n    // see if we know this altLoc already;\n    List<Atom> atoms = group.getAtoms();\n    if (atoms.size() > 0) {\n        Atom a1 = atoms.get(0);\n        // we are just adding atoms to the current group\n        // probably there is a second group following later...\n        if (a1.getAltLoc().equals(altLoc)) {\n            return group;\n        }\n    }\n    // Get the altLocGroup\n    Group altLocgroup = group.getAltLocGroup(altLoc);\n    if (altLocgroup != null) {\n        return altLocgroup;\n    }\n    // If the group already exists (microheterogenity).\n    Group oldGroup = getGroupWithSameResNumButDiffPDBName();\n    if (oldGroup != null) {\n        Group altLocG = group;\n        group = oldGroup;\n        group.addAltLoc(altLocG);\n        chain.getAtomGroups().remove(altLocG);\n        return altLocG;\n    }\n    // no matching altLoc group found.\n    // build it up.\n    if (group.getAtoms().size() == 0) {\n        return group;\n    }\n    Group altLocG = (Group) group.clone();\n    // drop atoms from cloned group...\n    // https://redmine.open-bio.org/issues/3307\n    altLocG.setAtoms(new ArrayList<Atom>());\n    altLocG.getAltLocs().clear();\n    group.addAltLoc(altLocG);\n    return altLocG;\n}", "repo_id": "9", "comment": "/**\n * Generates Alternate location groups.\n *\n * @param altLoc the alt loc\n * @return the correct alt loc group\n */\n", "repo_name": "biojava-master/", "id": 1269, "method_signature": "Group getCorrectAltLocGroup(Character)"}, "2313": {"callee_method_names": ["Matrix4d.set"], "method_name": "TestUnitQuaternions.testRelativeOrientation", "method_implementation": "{\n    // Get points from a structure.\n    Structure pdb = StructureIO.getStructure(\"4hhb.A\");\n    Point3d[] cloud = Calc.atomsToPoints(StructureTools.getRepresentativeAtomArray(pdb));\n    Point3d[] cloud2 = CalcPoint.clonePoint3dArray(cloud);\n    // Test orientation angle equal to 0 at this point\n    double angle = UnitQuaternions.orientationAngle(cloud, cloud2, false);\n    assertEquals(angle, 0, 0.001);\n    // Apply a 30 degree rotation to cloud\n    AxisAngle4d axis = new AxisAngle4d(new Vector3d(1, 1, 1), Math.PI / 6);\n    Matrix4d transform = new Matrix4d();\n    transform.set(axis);\n    CalcPoint.transform(transform, cloud);\n    angle = UnitQuaternions.orientationAngle(cloud, cloud2, false);\n    angle = Math.min(Math.abs(2 * Math.PI - angle), angle);\n    // Test that angle was recovered\n    assertEquals(angle, Math.PI / 6, 0.001);\n}", "repo_id": "9", "comment": "/**\n * Test {@link UnitQuaternions#relativeOrientation(Point3d[], Point3d[])} on\n * a real structure. Test recovering of the angle applied.\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2313, "method_signature": "void testRelativeOrientation()"}, "875": {"callee_method_names": [], "method_name": "StructureInterface.getTransforms", "method_implementation": "{\n    return transforms;\n}", "repo_id": "9", "comment": "/**\n * Return the 2 crystal transform operations performed on each of the\n * molecules of this interface.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 875, "method_signature": "Pair<CrystalTransform> getTransforms()"}, "397": {"callee_method_names": [], "method_name": "Calc.getTMScore", "method_implementation": "{\n    if (atomSet1.length != atomSet2.length) {\n        throw new StructureException(\"The two atom sets are not of same length!\");\n    }\n    if (atomSet1.length > len1) {\n        throw new StructureException(\"len1 must be greater or equal to the alignment length!\");\n    }\n    if (atomSet2.length > len2) {\n        throw new StructureException(\"len2 must be greater or equal to the alignment length!\");\n    }\n    int Lnorm;\n    if (normalizeMin) {\n        Lnorm = Math.min(len1, len2);\n    } else {\n        Lnorm = Math.max(len1, len2);\n    }\n    int Laln = atomSet1.length;\n    double d0 = 1.24 * Math.cbrt(Lnorm - 15.) - 1.8;\n    double d0sq = d0 * d0;\n    double sum = 0;\n    for (int i = 0; i < Laln; i++) {\n        double d = Calc.getDistance(atomSet1[i], atomSet2[i]);\n        sum += 1. / (1 + d * d / d0sq);\n    }\n    return sum / Lnorm;\n}", "repo_id": "9", "comment": "/**\n * Calculate the TM-Score for the superposition.\n *\n * Atom sets must be pre-rotated.\n *\n * <p>\n * Citation:<br/>\n * <i>Zhang Y and Skolnick J (2004). \"Scoring function for automated\n * assessment of protein structure template quality\". Proteins 57: 702 -\n * 710.</i>\n *\n * @param atomSet1\n *            atom array 1\n * @param atomSet2\n *            atom array 2\n * @param len1\n *            The full length of the protein supplying atomSet1\n * @param len2\n *            The full length of the protein supplying atomSet2\n * @param normalizeMin\n *            Whether to normalize by the <strong>minimum</strong>-length structure,\n *            that is, {@code min\\{len1,len2\\}}. If false, normalized by the {@code max\\{len1,len2\\}}).\n *\n * @return The TM-Score\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 397, "method_signature": "double getTMScore(Atom[], Atom[], int, int, boolean)"}, "1867": {"callee_method_names": [], "method_name": "Rotation.getAxisAngle", "method_implementation": "{\n    return axisAngle;\n}", "repo_id": "9", "comment": "/**\n * @return the axisAngle\n */\n", "repo_name": "biojava-master/", "id": 1867, "method_signature": "AxisAngle4d getAxisAngle()"}, "553": {"callee_method_names": ["StrucAligParameters.getUsedAtomNames"], "method_name": "StructurePairAligner.getAlignmentAtoms", "method_implementation": "{\n    String[] atomNames = params.getUsedAtomNames();\n    return StructureTools.getAtomArray(s, atomNames);\n}", "repo_id": "9", "comment": "/**\n * Returns the atoms that are being used for the alignment. (E.g. Calpha\n * only, etc.)\n *\n * @param s\n * @return an array of Atoms objects\n */\n", "repo_name": "biojava-master/", "id": 553, "method_signature": "Atom[] getAlignmentAtoms(Structure)"}, "873": {"callee_method_names": [], "method_name": "StructureInterface.getTotalArea", "method_implementation": "{\n    return totalArea;\n}", "repo_id": "9", "comment": "/**\n * Returns the total area buried upon formation of this interface,\n * defined as: 1/2[ (ASA1u-ASA1c) + (ASA2u-ASA2u) ] , with:\n *  <p>ASAxu = ASA of first/second unbound chain</p>\n *  <p>ASAxc = ASA of first/second complexed chain</p>\n * In the area calculation HETATOM groups not part of the main protein/nucleotide chain\n * are not included.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 873, "method_signature": "double getTotalArea()"}, "337": {"callee_method_names": ["String.length", "String.length", "String.length", "String.substring", "String.equals", "String.equals", "String.equals", "StringTokenizer.hasMoreTokens", "StringTokenizer.nextToken", "Synonym.setScope", "Synonym.setCategory", "Synonym.setName", "String.length"], "method_name": "OboFileParser.parseSynonym", "method_implementation": "{\n    //logger.info(\"PARSE SYNONYM \" + key +  \" \" + value);\n    int startIndex = findUnescaped(value, '\"', 0, value.length());\n    if (startIndex == -1)\n        throw new IOException(\"Expected \\\"\" + line + \" \" + linenum);\n    SOPair p = unescape(value, '\"', startIndex + 1, value.length(), true);\n    int defIndex = findUnescaped(value, '[', p.index, value.length());\n    if (defIndex == -1) {\n        throw new IOException(\"Badly formatted synonym. \" + \"No dbxref list found.\" + line + \" \" + linenum);\n    }\n    String leftovers = value.substring(p.index + 1, defIndex).trim();\n    StringTokenizer tokenizer = new StringTokenizer(leftovers, \" \\t\");\n    int scope = Synonym.RELATED_SYNONYM;\n    if (key.equals(OboFileHandler.EXACT_SYNONYM))\n        scope = Synonym.EXACT_SYNONYM;\n    else if (key.equals(OboFileHandler.BROAD_SYNONYM))\n        scope = Synonym.BROAD_SYNONYM;\n    else if (key.equals(OboFileHandler.NARROW_SYNONYM))\n        scope = Synonym.NARROW_SYNONYM;\n    String catID = null;\n    for (int i = 0; tokenizer.hasMoreTokens(); i++) {\n        String token = tokenizer.nextToken();\n        //logger.info(\"TOKEN:\" +token);\n        if (i == 0) {\n            if (\"RELATED\".equals(token))\n                scope = Synonym.RELATED_SYNONYM;\n            else if (\"UNSPECIFIED\".equals(token))\n                scope = Synonym.RELATED_SYNONYM;\n            else if (\"EXACT\".equals(token))\n                scope = Synonym.EXACT_SYNONYM;\n            else if (\"BROAD\".equals(token))\n                scope = Synonym.BROAD_SYNONYM;\n            else if (\"NARROW\".equals(token))\n                scope = Synonym.NARROW_SYNONYM;\n            else\n                throw new IOException(\"Found unexpected scope \" + \"identifier \" + token + line);\n        } else if (i == 1) {\n            catID = token;\n        } else\n            throw new IOException(\"Expected dbxref list,\" + \" instead found \" + token + line);\n    }\n    Synonym synonym = new Synonym();\n    synonym.setScope(scope);\n    synonym.setCategory(catID);\n    synonym.setName(p.str);\n    //logger.info(\"SYNONYM: \" + p.str +\" \" + synonym.getCategory() + \" \" + synonym.getScope());\n    Map<String, Object>[] refs = getDbxrefList(value, defIndex + 1, value.length());\n    // set the refs in the synonym\n    for (Map<String, Object> ref : refs) {\n        @SuppressWarnings(\"unused\")\n        String xref = (String) ref.get(\"xref\");\n        @SuppressWarnings(\"unused\")\n        String desc = (String) ref.get(\"desc\");\n        //logger.info(xref + \" \" + desc);\n        @SuppressWarnings(\"unused\")\n        NestedValue nv = (NestedValue) ref.get(\"nv\");\n        //TODO: add implementation for this...\n    }\n    return synonym;\n}", "repo_id": "9", "comment": "/**\n * parse the Synonym String from the Term.\n * value can be:\n * <pre>\"ca_bind\" RELATED [uniprot:curation]</pre>\n * @param value\n * @return the synonym text\n */\n", "repo_name": "biojava-master/", "id": 337, "method_signature": "Synonym parseSynonym(String, String)"}, "1937": {"callee_method_ids": [1868, 1867, 1867, 1862, 1861], "callee_method_names": ["ArrayList.get", "ArrayList.get", "Rotation.setAxisAngle", "Rotation.getAxisAngle", "Rotation.getAxisAngle", "Rotation.setFold", "Rotation.getFold"], "method_name": "RotationGroup.setEAxis", "method_implementation": "{\n    Rotation e = rotations.get(0);\n    Rotation h = rotations.get(principalAxisIndex);\n    e.setAxisAngle(new AxisAngle4d(h.getAxisAngle()));\n    e.getAxisAngle().angle = 0.0;\n    e.setFold(h.getFold());\n}", "repo_id": "9", "comment": "/**\n * Add E operation to the highest order rotation axis. By definition\n * E belongs to the highest order axis.\n */\n", "repo_name": "biojava-master/", "id": 1937, "method_signature": "void setEAxis()"}, "3350": {"callee_method_names": ["NavigableMap<Double, Color>.containsKey"], "method_name": "GradientMapper.containsKey", "method_implementation": "{\n    return mapping.containsKey(position);\n}", "repo_id": "9", "comment": "/**\n * @param position\n * @return\n * @see java.util.Map#containsKey(java.lang.Object)\n */\n", "repo_name": "biojava-master/", "id": 3350, "method_signature": "boolean containsKey(Object)"}, "2906": {"callee_method_names": [], "method_name": "AbstractSequence.getAnnotationType", "method_implementation": "{\n    return annotationType;\n}", "repo_id": "9", "comment": "/**\n * @return the annotation\n */\n", "repo_name": "biojava-master/", "id": 2906, "method_signature": "AnnotationType getAnnotationType()"}, "3321": {"callee_method_names": ["ActionEvent.getSource", "JComboBox.getSelectedItem", "Map<String, ContinuousColorMapper>.get"], "method_name": "ScaleableMatrixPanel.actionPerformed", "method_implementation": "{\n    // == coloring\n    JComboBox cb = (JComboBox) e.getSource();\n    String gradientName = (String) cb.getSelectedItem();\n    ContinuousColorMapper gradient = gradients.get(gradientName);\n    assert (gradient != null);\n    this.setCellColor(gradient);\n    this.repaint();\n}", "repo_id": "9", "comment": "/**\n * @param e\n * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)\n */\n", "repo_name": "biojava-master/", "id": 3321, "method_signature": "void actionPerformed(ActionEvent)"}, "2758": {"callee_method_names": [], "method_name": "EmblReference.getReferenceGroup", "method_implementation": "{\n    return referenceGroup;\n}", "repo_id": "9", "comment": "/**\n * The RG (Reference Group) lines list the working groups/consortia that\n * produced the record.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2758, "method_signature": "String getReferenceGroup()"}, "1220": {"callee_method_names": [], "method_name": "ChemCompConverter.fromInputStream", "method_implementation": "{\n    return fromCifFile(CifIO.readFromInputStream(inputStream));\n}", "repo_id": "9", "comment": "/**\n * Convert InputStream to chem comp dictionary.\n * @param inputStream the InputStream of information - can be gzipped or binary or text data\n * @return the target\n * @throws IOException thrown when reading fails\n * @see CifStructureConverter#fromInputStream(InputStream, FileParsingParameters)\n */\n", "repo_name": "biojava-master/", "id": 1220, "method_signature": "ChemicalComponentDictionary fromInputStream(InputStream)"}, "2336": {"callee_method_names": [], "method_name": "TestSymmetryTools.testValidFolds", "method_implementation": "{\n    List<Integer> stoich;\n    List<Integer> folds;\n    List<Integer> expected;\n    stoich = Arrays.asList(6, 4);\n    expected = Arrays.asList(1, 2);\n    folds = SymmetryTools.getValidFolds(stoich);\n    assertEquals(\"Wrong folds for \" + stoich, expected, folds);\n    stoich = Arrays.asList(6, 6);\n    expected = Arrays.asList(1, 2, 3, 6);\n    folds = SymmetryTools.getValidFolds(stoich);\n    assertEquals(\"Wrong folds for \" + stoich, expected, folds);\n    stoich = Arrays.asList(6, 3);\n    expected = Arrays.asList(1, 3);\n    folds = SymmetryTools.getValidFolds(stoich);\n    assertEquals(\"Wrong folds for \" + stoich, expected, folds);\n    stoich = Arrays.asList(6, 5);\n    expected = Arrays.asList(1);\n    folds = SymmetryTools.getValidFolds(stoich);\n    assertEquals(\"Wrong folds for \" + stoich, expected, folds);\n}", "repo_id": "9", "comment": "/**\n * Test {@link SymmetryTools#getValidFolds(List)}.\n */\n", "repo_name": "biojava-master/", "id": 2336, "method_signature": "void testValidFolds()"}, "819": {"callee_method_names": [], "method_name": "AlternativeAlignment.apairs_from_seed", "method_implementation": "{\n    aligpath = new IndexPair[l];\n    idx1 = new int[l];\n    idx2 = new int[l];\n    for (int x = 0; x < l; x++) {\n        idx1[x] = i + x;\n        idx2[x] = j + x;\n        aligpath[x] = new IndexPair((short) (i + x), (short) (j + x));\n    }\n}", "repo_id": "9", "comment": "/**\n * Set apairs according to a seed position.\n *\n * @param l\n * @param i\n * @param j\n */\n", "repo_name": "biojava-master/", "id": 819, "method_signature": "void apairs_from_seed(int, int, int)"}, "2670": {"callee_method_names": ["S.getLength", "S.getLength", "S.getAccession", "S.getLength", "ArrayList.add"], "method_name": "MultipleSequenceAlignment.addAlignedSequence", "method_implementation": "{\n    if (length == null) {\n        length = sequence.getLength();\n    }\n    if (sequence.getLength() != length) {\n        throw new IllegalArgumentException(sequence.getAccession() + \" length = \" + sequence.getLength() + \" not equal to MSA length = \" + length);\n    }\n    sequences.add(sequence);\n}", "repo_id": "9", "comment": "/**\n * A sequence that has been aligned to other sequences will have inserts.\n * @param sequence\n */\n", "repo_name": "biojava-master/", "id": 2670, "method_signature": "void addAlignedSequence(S)"}, "2781": {"callee_method_names": ["List<String>.size", "List<List<String>>.get", "List<String>.get", "List<String>.get", "CompoundSet<AminoAcidCompound>.getCompoundForString", "List<String>.get", "ArrayList.add"], "method_name": "IUPACTable.getCodons", "method_implementation": "{\n    if (this.codons.isEmpty()) {\n        List<String> aminoAcidStrings = aminoAcids();\n        List<String> startCodonStrings = startCodons();\n        List<List<String>> codonStrings = codonStrings();\n        for (int i = 0; i < aminoAcidStrings.size(); i++) {\n            List<String> codonString = codonStrings.get(i);\n            NucleotideCompound one = getCompound(codonString, 0, nucelotides);\n            NucleotideCompound two = getCompound(codonString, 1, nucelotides);\n            NucleotideCompound three = getCompound(codonString, 2, nucelotides);\n            boolean start = (\"M\".equals(startCodonStrings.get(i)));\n            boolean stop = (\"*\".equals(aminoAcidStrings.get(i)));\n            AminoAcidCompound aminoAcid = aminoAcids.getCompoundForString(aminoAcidStrings.get(i));\n            codons.add(new Codon(new CaseInsensitiveTriplet(one, two, three), aminoAcid, start, stop));\n        }\n    }\n    return codons;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of codons where the source and target compounds\n * are the same as those given by the parameters.\n *\n * @param nucleotides The nucleotide set to use when building BioJava\n * representations of codons\n * @param aminoAcids The target amino acid compounds objects\n */\n", "repo_name": "biojava-master/", "id": 2781, "method_signature": "List<Codon> getCodons(CompoundSet, CompoundSet)"}, "838": {"callee_method_names": ["Atom.getElement", "Atom.getElement", "Atom.getElement", "Atom.getElement", "Atom.getElement", "Atom.getElement", "Logger.info", "Atom.getName", "NucleotideImpl.getPDBName", "Atom.getElement"], "method_name": "AsaCalculator.getRadiusForNucl", "method_implementation": "{\n    if (atom.getElement().equals(Element.H))\n        return Element.H.getVDWRadius();\n    if (atom.getElement().equals(Element.D))\n        return Element.D.getVDWRadius();\n    if (atom.getElement() == Element.C)\n        return NUC_CARBON_VDW;\n    if (atom.getElement() == Element.N)\n        return NUC_NITROGEN_VDW;\n    if (atom.getElement() == Element.P)\n        return PHOSPHOROUS_VDW;\n    if (atom.getElement() == Element.O)\n        return OXIGEN_VDW;\n    logger.info(\"Unexpected atom \" + atom.getName() + \" for nucleotide \" + nuc.getPDBName() + \", assigning its standard vdw radius\");\n    return atom.getElement().getVDWRadius();\n}", "repo_id": "9", "comment": "/**\n * Gets the radius for given nucleotide atom\n * @param atom\n * @return\n */\n", "repo_name": "biojava-master/", "id": 838, "method_signature": "double getRadiusForNucl(NucleotideImpl, Atom)"}, "209": {"callee_method_ids": [204], "callee_method_names": ["FastaSequence.getSequence"], "method_name": "SequenceUtil.isNucleotideSequence", "method_implementation": "{\n    return SequenceUtil.isNonAmbNucleotideSequence(s.getSequence());\n}", "repo_id": "9", "comment": "/**\n * @return true is the sequence contains only letters a,c, t, g, u\n */\n", "repo_name": "biojava-master/", "id": 209, "method_signature": "boolean isNucleotideSequence(FastaSequence)"}, "2874": {"callee_method_names": [], "method_name": "ABITrace.setIndex", "method_implementation": "{\n    int DataCounter, PBASCounter, PLOCCounter, PCONCounter, NumRecords, indexBase;\n    byte[] RecNameArray = new byte[4];\n    String RecName;\n    DataCounter = 0;\n    PBASCounter = 0;\n    PLOCCounter = 0;\n    PCONCounter = 0;\n    indexBase = getIntAt(absIndexBase + macJunk);\n    NumRecords = getIntAt(absIndexBase - 8 + macJunk);\n    for (int record = 0; record <= NumRecords - 1; record++) {\n        getSubArray(RecNameArray, (indexBase + (record * 28)));\n        RecName = new String(RecNameArray);\n        if (\"FWO_\".equals(RecName))\n            FWO = indexBase + (record * 28) + 20;\n        if (\"DATA\".equals(RecName)) {\n            ++DataCounter;\n            if (DataCounter == 9)\n                DATA9 = indexBase + (record * 28) + 20;\n            if (DataCounter == 10)\n                DATA10 = indexBase + (record * 28) + 20;\n            if (DataCounter == 11)\n                DATA11 = indexBase + (record * 28) + 20;\n            if (DataCounter == 12)\n                DATA12 = indexBase + (record * 28) + 20;\n        }\n        if (\"PBAS\".equals(RecName)) {\n            ++PBASCounter;\n            if (PBASCounter == 2)\n                PBAS2 = indexBase + (record * 28) + 20;\n        }\n        if (\"PLOC\".equals(RecName)) {\n            ++PLOCCounter;\n            if (PLOCCounter == 2)\n                PLOC = indexBase + (record * 28) + 20;\n        }\n        if (\"PCON\".equals(RecName)) {\n            ++PCONCounter;\n            if (PCONCounter == 2)\n                PCON = indexBase + (record * 28) + 20;\n        }\n    }\n    //next record\n    traceLength = getIntAt(DATA12 - 8);\n    seqLength = getIntAt(PBAS2 - 4);\n    PLOC = getIntAt(PLOC) + macJunk;\n    DATA9 = getIntAt(DATA9) + macJunk;\n    DATA10 = getIntAt(DATA10) + macJunk;\n    DATA11 = getIntAt(DATA11) + macJunk;\n    DATA12 = getIntAt(DATA12) + macJunk;\n    PBAS2 = getIntAt(PBAS2) + macJunk;\n    PCON = getIntAt(PCON) + macJunk;\n}", "repo_id": "9", "comment": "/**\n * Sets up all of the initial pointers to the important records in TraceData.\n */\n", "repo_name": "biojava-master/", "id": 2874, "method_signature": "void setIndex()"}, "1501": {"callee_method_names": ["SuperPositionQuat.setCentered", "SuperPositionQuat.getRmsd"], "method_name": "SuperPositions.getRmsdAtOrigin", "method_implementation": "{\n    superposer.setCentered(true);\n    return superposer.getRmsd(fixed, moved);\n}", "repo_id": "9", "comment": "/**\n * Use the {@link SuperPosition#getRmsd(Point3d[], Point3d[])} method of the\n * default static SuperPosition algorithm contained in this Class, assuming\n * that the point arrays are centered at the origin.\n */\n", "repo_name": "biojava-master/", "id": 1501, "method_signature": "double getRmsdAtOrigin(Point3d[], Point3d[])"}, "924": {"callee_method_names": ["Point3d[].distance", "Point3d[].distance"], "method_name": "GridCell.hasContactToAtom", "method_implementation": "{\n    for (int i : iIndices) {\n        double distance = iAtoms[i].distance(query);\n        if (distance < cutoff)\n            return true;\n    }\n    if (jAtoms != null) {\n        for (int i : jIndices) {\n            double distance = jAtoms[i].distance(query);\n            if (distance < cutoff)\n                return true;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Tests whether any atom in this cell has a contact with the specified query atom\n * @param iAtoms the first set of atoms to which the iIndices correspond\n * @param jAtoms the second set of atoms to which the jIndices correspond, or null\n * @param query test point\n * @param cutoff\n * @return\n */\n", "repo_name": "biojava-master/", "id": 924, "method_signature": "boolean hasContactToAtom(Point3d[], Point3d[], Point3d, double)"}, "862": {"callee_method_names": ["TreeMap<Key, Value>.lastKey"], "method_name": "SymbolTable.max", "method_implementation": "{\n    return st.lastKey();\n}", "repo_id": "9", "comment": "/**\n * Return the largest key in the table.\n */\n", "repo_name": "biojava-master/", "id": 862, "method_signature": "Key max()"}, "232": {"callee_method_names": [], "method_name": "Builder.setPdbccId", "method_implementation": "{\n    this.pdbccId = pdbccId;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the Protein Data Bank Chemical Component ID.\n * @param pdbccId Protein Data Bank Chemical Component ID.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 232, "method_signature": "Builder setPdbccId(String)"}, "2350": {"callee_method_ids": [2353, 2354, 2353], "callee_method_names": ["FastqParserLineProcessor.getState", "ParseListener.complete", "FastqParserLineProcessor.setState", "FastqParserLineProcessor.getState"], "method_name": "FastqParser.parse", "method_implementation": "{\n    if (readable == null) {\n        throw new IllegalArgumentException(\"readable must not be null\");\n    }\n    FastqParserLineProcessor lineProcessor = new FastqParserLineProcessor(listener);\n    CharStreams.readLines(readable, lineProcessor);\n    if (lineProcessor.getState() == State.COMPLETE) {\n        listener.complete();\n        lineProcessor.setState(State.DESCRIPTION);\n    }\n    if (lineProcessor.getState() != State.DESCRIPTION) {\n        // at line \" + lineNumber);\n        throw new IOException(\"truncated sequence\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Parse the specified readable.\n *\n * @param readable readable, must not be null\n * @param listener low-level event based parser callback, must not be null\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "biojava-master/", "id": 2350, "method_signature": "void parse(Readable, ParseListener)"}, "3678": {"callee_method_names": [], "method_name": "CoxMart.main", "method_implementation": "{\n    // TODO code application logic here\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3678, "method_signature": "void main(String[])"}, "3375": {"callee_method_names": ["Graphics2D.setRenderingHint", "Graphics2D.setRenderingHint", "Graphics2D.setFont"], "method_name": "SequenceScalePanel.setPaintDefaults", "method_implementation": "{\n    g2D.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n    g2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    g2D.setFont(seqFont);\n}", "repo_id": "9", "comment": "/**\n * set some default rendering hints, like text antialiasing on\n *\n * @param g2D the graphics object to set the defaults on\n */\n", "repo_name": "biojava-master/", "id": 3375, "method_signature": "void setPaintDefaults(Graphics2D)"}, "2752": {"callee_method_names": [], "method_name": "EmblRecord.getSequenceHeader", "method_implementation": "{\n    return sequenceHeader;\n}", "repo_id": "9", "comment": "/**\n * The SQ (SeQuence header) line marks the beginning of the sequence data and\n * Gives a summary of its content.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2752, "method_signature": "String getSequenceHeader()"}, "637": {"callee_method_names": [], "method_name": "AtomCache.getFetchBehavior", "method_implementation": "{\n    return fetchBehavior;\n}", "repo_id": "9", "comment": "/**\n * Get the behavior for fetching files from the server\n * @return\n */\n", "repo_name": "biojava-master/", "id": 637, "method_signature": "FetchBehavior getFetchBehavior()"}, "2219": {"callee_method_names": [], "method_name": "TestMMcifOrganismParsing.test1a4w", "method_implementation": "{\n    String pdbId = \"1a4w\";\n    checkPDB(pdbId, \"9606\");\n}", "repo_id": "9", "comment": "// removed this test, since entity 3 of 1a4w has no organism tax_id\n", "repo_name": "biojava-master/", "id": 2219, "method_signature": "void test1a4w()"}, "422": {"callee_method_ids": [487, 484], "callee_method_names": ["AFPChain.getBlockNum", "AFPChain.getAfpSet", "AFPChain.getAfpChainList", "AFPChain.getBlock2Afp", "AFPChain.getBlockSize", "AFPChain.getBlockRmsd", "FatCatParameters.getFragLen", "List<AFP>.get", "List<AFP>.get", "AFPChain.setBlock2Afp", "AFPChain.setBlockSize", "AFPChain.setAfpChainList", "AFPChain.setBlockNum", "AFPChain.setBlockRmsd"], "method_name": "AFPPostProcessor.deleteBlock", "method_implementation": "{\n    int blockNum = afpChain.getBlockNum();\n    List<AFP> afpSet = afpChain.getAfpSet();\n    int[] afpChainList = afpChain.getAfpChainList();\n    int[] block2Afp = afpChain.getBlock2Afp();\n    int[] blockSize = afpChain.getBlockSize();\n    double[] blockRmsd = afpChain.getBlockRmsd();\n    int fragLen = params.getFragLen();\n    //remove those blocks (both in terminals and in the middle) with only a AFP\n    //but still keep those small blocks spaning large regions\n    if (blockNum <= 1)\n        return;\n    int blockNumOld = blockNum;\n    int i, j, b1, b2, e1, e2, len;\n    e1 = e2 = 0;\n    for (i = 0; i < blockNum; i++) {\n        b1 = e1;\n        b2 = e2;\n        if (i < blockNum - 1) {\n            e1 = afpSet.get(afpChainList[block2Afp[i + 1]]).getP1();\n            e2 = afpSet.get(afpChainList[block2Afp[i + 1]]).getP2();\n        } else {\n            e1 = ca1.length;\n            e2 = ca2.length;\n        }\n        if (blockSize[i] > 1)\n            continue;\n        len = (e1 - b1) < (e2 - b2) ? (e1 - b1) : (e2 - b2);\n        //if(i == blockNum - 1) blockNum --;\n        if (len < 2 * fragLen) {\n            for (j = i; j < blockNum - 1; j++) {\n                blockRmsd[j] = blockRmsd[j + 1];\n                blockSize[j] = blockSize[j + 1];\n                block2Afp[j] = block2Afp[j + 1];\n            }\n            blockNum--;\n            i--;\n        }\n        //delete a block\n    }\n    if (blockNumOld > blockNum)\n        if (debug)\n            System.out.println(String.format(\"Delete %d small blocks\\n\", blockNumOld - blockNum));\n    if (debug)\n        System.err.println(\"deleteBlock: end blockNum:\" + blockNum);\n    afpChain.setBlock2Afp(block2Afp);\n    afpChain.setBlockSize(blockSize);\n    afpChain.setAfpChainList(afpChainList);\n    afpChain.setBlockNum(blockNum);\n    afpChain.setBlockRmsd(blockRmsd);\n}", "repo_id": "9", "comment": "/**\n *  remove the artifical small rigid-body superimpose in the middle\n * \t clust the similar superimpositions (caused by the small flexible\n * \t region, which is detected as a seperate rigid superimposing region by adding\n * \t two twists before and after it(artifically!)\n * \t one possible solution: allowing long enough loops in the chaining process,\n * \t which however increase the calculation complexity\n */\n", "repo_name": "biojava-master/", "id": 422, "method_signature": "void deleteBlock(FatCatParameters, AFPChain, Atom[], Atom[])"}, "3788": {"callee_method_names": [], "method_name": "KaplanMeierFigure.setKMFigureInfo", "method_implementation": "{\n    this.kmfi = kmfi;\n    if (kmfi.width != null && kmfi.height != null) {\n        this.setSize(kmfi.width, kmfi.height);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param kmfi\n */\n", "repo_name": "biojava-master/", "id": 3788, "method_signature": "void setKMFigureInfo(KMFigureInfo)"}, "2920": {"callee_method_names": [], "method_name": "AbstractSequence.setSequenceScore", "method_implementation": "{\n    this.sequenceScore = sequenceScore;\n}", "repo_id": "9", "comment": "/**\n * @param sequenceScore the sequenceScore to set\n */\n", "repo_name": "biojava-master/", "id": 2920, "method_signature": "void setSequenceScore(Double)"}, "3339": {"callee_method_names": [], "method_name": "CoordManager.getSeqPos", "method_implementation": "{\n    int seqPos = Math.round((panelPos - SequenceScalePanel.DEFAULT_X_START) / scale);\n    if (seqPos < 0)\n        seqPos = 0;\n    //int length = chainLength;\n    //if ( seqPos >= length)\n    //   seqPos = length-1;\n    return seqPos;\n}", "repo_id": "9", "comment": "/**\n * start counting at 0...\n *\n * @param panelPos\n * @return the sequence position\n */\n", "repo_name": "biojava-master/", "id": 3339, "method_signature": "int getSeqPos(int)"}, "3050": {"callee_method_names": [], "method_name": "LocationHelper.completeCircularPasses", "method_implementation": "{\n    int count = 0;\n    while (index > seqLength) {\n        count++;\n        index -= seqLength;\n    }\n    return count - 1;\n}", "repo_id": "9", "comment": "/**\n * Works in a similar way to modulateCircularLocation but returns\n * the number of complete passes over a Sequence length a circular\n * location makes i.e. if we have a sequence of length 10 and the\n * location 3..52 we make 4 complete passes through the genome to\n * go from position 3 to position 52.\n */\n", "repo_name": "biojava-master/", "id": 3050, "method_signature": "int completeCircularPasses(int, int)"}, "1796": {"callee_method_names": ["String.hashCode", "String.hashCode", "String.hashCode", "String.hashCode", "Integer.hashCode", "Integer.hashCode", "String.hashCode", "Long.hashCode", "Set<String>.hashCode", "Boolean.hashCode", "PdbId.hashCode", "String.hashCode", "Integer.hashCode", "String.hashCode", "Long.hashCode", "Integer.hashCode", "String.hashCode"], "method_name": "EcodDomain.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((architectureName == null) ? 0 : architectureName.hashCode());\n    result = prime * result + ((chainId == null) ? 0 : chainId.hashCode());\n    result = prime * result + ((domainId == null) ? 0 : domainId.hashCode());\n    result = prime * result + ((fGroupName == null) ? 0 : fGroupName.hashCode());\n    result = prime * result + ((fGroup == null) ? 0 : fGroup.hashCode());\n    result = prime * result + ((hGroup == null) ? 0 : hGroup.hashCode());\n    result = prime * result + ((hGroupName == null) ? 0 : hGroupName.hashCode());\n    result = prime * result + ((assemblyId == null) ? 0 : assemblyId.hashCode());\n    result = prime * result + ((ligands == null) ? 0 : ligands.hashCode());\n    result = prime * result + ((manual == null) ? 0 : manual.hashCode());\n    result = prime * result + ((pdbId == null) ? 0 : pdbId.hashCode());\n    result = prime * result + ((range == null) ? 0 : range.hashCode());\n    result = prime * result + ((tGroup == null) ? 0 : tGroup.hashCode());\n    result = prime * result + ((tGroupName == null) ? 0 : tGroupName.hashCode());\n    result = prime * result + ((uid == null) ? 0 : uid.hashCode());\n    result = prime * result + ((xGroup == null) ? 0 : xGroup.hashCode());\n    result = prime * result + ((xGroupName == null) ? 0 : xGroupName.hashCode());\n    return result;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#hashCode()\n\t */\n", "repo_name": "biojava-master/", "id": 1796, "method_signature": "int hashCode()"}, "1236": {"callee_method_names": ["List<Group>.setSeqResGroups", "List<Group>.getAtomGroups", "List<Group>.setAtomGroups", "List<Chain>.add", "Structure.setChains", "Structure.nrModels", "Structure.getModel", "List<Chain>.isEmpty", "Chain.setSeqResGroups", "List<Group>.getAtomGroups", "Logger.warn", "List<Group>.getId"], "method_name": "SeqRes2AtomAligner.storeUnAlignedSeqRes", "method_implementation": "{\n    if (headerOnly) {\n        List<Chain> atomChains = new ArrayList<>();\n        for (Chain seqRes : seqResChains) {\n            // In header-only mode skip ATOM records.\n            // Here we store chains with SEQRES instead of AtomGroups.\n            seqRes.setSeqResGroups(seqRes.getAtomGroups());\n            // clear out the atom groups.\n            seqRes.setAtomGroups(new ArrayList<>());\n            atomChains.add(seqRes);\n        }\n        structure.setChains(0, atomChains);\n    } else {\n        for (int i = 0; i < structure.nrModels(); i++) {\n            List<Chain> atomChains = structure.getModel(i);\n            if (seqResChains.isEmpty()) {\n                // in files without SEQRES, seqResChains object is empty: we replace by atomChains resulting below in a trivial alignment and a copy of atom groups to seqres groups\n                seqResChains = atomChains;\n            }\n            for (Chain seqRes : seqResChains) {\n                // Otherwise, we find a chain with AtomGroups\n                // and set this as SEQRES groups.\n                // TODO no idea if new parameter useChainId should be false or true here, used true as a guess - JD 2016-05-09\n                Chain atomRes = SeqRes2AtomAligner.getMatchingAtomRes(seqRes, atomChains, true);\n                if (atomRes != null)\n                    atomRes.setSeqResGroups(seqRes.getAtomGroups());\n                else\n                    logger.warn(\"Could not find atom records for chain \" + seqRes.getId());\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Storing unaligned SEQRES groups in a Structure.\n * @param structure\n * @param seqResChains\n */\n", "repo_name": "biojava-master/", "id": 1236, "method_signature": "void storeUnAlignedSeqRes(Structure, List, boolean)"}, "1679": {"callee_method_names": ["AtomPositionMap.getNavMap", "SiftsChainEntry.getKey", "SiftsChainEntry.getKey"], "method_name": "ResidueRange.getResidue", "method_implementation": "{\n    if (map == null)\n        throw new NullPointerException(\"The AtomPositionMap must be non-null\");\n    int i = 0;\n    for (Map.Entry<ResidueNumber, Integer> entry : map.getNavMap().entrySet()) {\n        if (i == positionInRange)\n            return entry.getKey();\n        if (contains(entry.getKey(), map)) {\n            i++;\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Returns the ResidueNumber that is at position {@code positionInRange} in\n * <em>this</em> ResidueRange.\n * @return The ResidueNumber, or false if it does not exist or is not within this ResidueRange\n */\n", "repo_name": "biojava-master/", "id": 1679, "method_signature": "ResidueNumber getResidue(int, AtomPositionMap)"}, "730": {"callee_method_names": ["CeParameters.getScoringStrategy", "Atom.getGroup", "Group.hasAtom", "Group.getAtom", "Atom.getGroup", "Group.hasAtom", "Group.getAtom", "CeParameters.getScoringStrategy", "CeParameters.getScoringStrategy", "CeParameters.getScoringStrategy", "CeParameters.getScoringStrategy"], "method_name": "CeCalculatorEnhanced.getDistanceWithSidechain", "method_implementation": "{\n    if (params.getScoringStrategy() == CeParameters.ScoringStrategy.CA_SCORING) {\n        return Calc.getDistance(ca1, ca2);\n    }\n    double dist;\n    Group g1 = ca1.getGroup();\n    Atom cb1 = null;\n    if (g1.hasAtom(StructureTools.CB_ATOM_NAME)) {\n        cb1 = g1.getAtom(StructureTools.CB_ATOM_NAME);\n    }\n    //\n    Group g2 = ca2.getGroup();\n    Atom cb2 = null;\n    if (g2.hasAtom(StructureTools.CB_ATOM_NAME)) {\n        cb2 = g2.getAtom(StructureTools.CB_ATOM_NAME);\n    }\n    if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SIDE_CHAIN_SCORING) {\n        // here we are using side chain orientation for scoring...\n        // score type 1    consider side chain distances\n        if (cb1 != null && cb2 != null) {\n            // CB distance\n            dist = Calc.getDistance(cb1, cb2);\n            //dist = dist / 2.;\n        } else {\n            dist = Calc.getDistance(ca1, ca2);\n        }\n        return dist;\n    } else if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SIDE_CHAIN_ANGLE_SCORING) {\n        // score type 2 add angle info\n        if (cb1 != null && cb2 != null) {\n            // If the CA were overlaid, what is the distance between the CB?\n            // Recall c^2 = a^2 + b^2 -2ab*cos(theta), so this is a function of angle\n            Atom c1 = Calc.subtract(cb1, ca1);\n            Atom c2 = Calc.subtract(cb2, ca2);\n            Atom newA = Calc.subtract(c2, c1);\n            dist = Calc.amount(newA);\n        } else {\n            //dist += Calc.getDistance(ca1,ca2);\n            dist = 0;\n        }\n        return dist;\n    } else if (params.getScoringStrategy() == CeParameters.ScoringStrategy.CA_AND_SIDE_CHAIN_ANGLE_SCORING) {\n        // score type 3\n        // CA distance + cos(angle)\n        dist = 0;\n        if (cb1 != null && cb2 != null) {\n            Atom cacb1 = Calc.subtract(cb1, ca1);\n            Atom cacb2 = Calc.subtract(cb2, ca2);\n            Atom newA = Calc.subtract(cacb2, cacb1);\n            //System.out.format(\"CACB 1: %s\\nCACB 2: %s\\ndiff: %s\\nd: %f\\n\",cacb1.toString(),cacb2.toString(),newA.toString(),Calc.amount(newA));\n            dist += Calc.amount(newA);\n        }\n        dist += Calc.getDistance(ca1, ca2);\n        return dist;\n    } else if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SEQUENCE_CONSERVATION) {\n        if (cb1 != null && cb2 != null) {\n            // CB distance\n            dist = Calc.getDistance(cb1, cb2);\n            //dist = dist / 2.;\n        } else {\n            dist = Calc.getDistance(ca1, ca2);\n        }\n        return dist;\n    } else {\n        // unsupported scoring scheme\n        return Calc.getDistance(ca1, ca2);\n    }\n}", "repo_id": "9", "comment": "/**\n * Evaluates the distance between two atoms\n * Several scoring functions are implemented and can be changed by calling\n * {@link CeParameters#setScoringStrategy(Integer) setScoringStrategy()}\n * on {@link CeParameters parameter} object this CECalculator was created with.\n * <p>\n * Scoring Strategies:<dl>\n * <dt>DEFAULT_SCORING_STRATEGY</dt>\n * <dd>Strategy of the original CE publication; CA-CA distance</dd>\n *\n * <dt>SIDE_CHAIN_SCORING</dt>\n * <dd>CB-CB distance. This performs better for sheets and helices than CA.</dd>\n *\n * <dt>SIDE_CHAIN_ANGLE_SCORING</dt>\n * <dd>Use the dot product (eg the cosine) of the two CA-CB vectors.</dd>\n *\n * <dt>CA_AND_SIDE_CHAIN_ANGLE_SCORING</dt>\n * <dd>Equivalent to DEFAULT_SCORING_STRATEGY + SIDE_CHAIN_ANGLE_SCORING</dd>\n * </dl>\n *\n *  <dt>SEQUENCE_CONSERVATION</dt>\n * <dd>A mix between the DEFAULT_SCORING_STRATEGY and a scoring function that favors the alignment of sequence conserved positions in the alignment</dd>\n * </dl>\n *\n * @param ca1 The CA of the first residue\n * @param ca2 The CA of the second residue\n * @return The distance between the two fragments, according to the selected\n * scoring strategy. Lower distances are better alignments.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 730, "method_signature": "double getDistanceWithSidechain(Atom, Atom)"}, "763": {"callee_method_names": [], "method_name": "CeParameters.setOptimizeAlignment", "method_implementation": "{\n    this.optimizeAlignment = optimizeAlignment;\n}", "repo_id": "9", "comment": "/**\n * Whether the CE algorithm should extend the best found trace with dynamic programming,\n * while keeping RMSD at about the same level. This is useful for edge cases with remote homology,\n * but can be slow for large structures.\n *\n * @param optimizeAlignment\n */\n", "repo_name": "biojava-master/", "id": 763, "method_signature": "void setOptimizeAlignment(boolean)"}, "1983": {"callee_method_names": ["RotationGroup.getPointGroup"], "method_name": "RotationAxisAligner.getSymmetry", "method_implementation": "{\n    run();\n    return rotationGroup.getPointGroup();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getTransformation()\n\t */\n", "repo_name": "biojava-master/", "id": 1983, "method_signature": "String getSymmetry()"}, "1789": {"callee_method_names": [], "method_name": "PDBHeader.setKeywords", "method_implementation": "{\n    this.keywords = keywords;\n}", "repo_id": "9", "comment": "/**\n * Sets the KEYWODS record of the structure.\n * @param keywords The keywords in a <code>List&lt;String&gt; to set.</code>\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 1789, "method_signature": "void setKeywords(List)"}, "1872": {"callee_method_names": [], "method_name": "Helix.getPermutation", "method_implementation": "{\n    return permutation;\n}", "repo_id": "9", "comment": "/**\n * @return the permutation\n */\n", "repo_name": "biojava-master/", "id": 1872, "method_signature": "List<Integer> getPermutation()"}, "3472": {"callee_method_names": [], "method_name": "NCBIQBlastService.setTool", "method_implementation": "{\n    this.tool = tool;\n}", "repo_id": "9", "comment": "/**\n * Set the tool identifier for QBlast. Defaults to {@value #DEFAULT_TOOL}\n *\n * @param tool the new identifier\n */\n", "repo_name": "biojava-master/", "id": 3472, "method_signature": "void setTool(String)"}, "1328": {"callee_method_names": [], "method_name": "FileParsingParameters.isParseBioAssembly", "method_implementation": "{\n    return parseBioAssembly;\n}", "repo_id": "9", "comment": "/**\n * Should the biological assembly info (REMARK 350) be parsed from the PDB file?\n *\n * @return boolean flag yes/no\n */\n", "repo_name": "biojava-master/", "id": 1328, "method_signature": "boolean isParseBioAssembly()"}, "26": {"callee_method_names": [], "method_name": "StockholmStructure.addGSAccessionNumber", "method_implementation": "{\n    getSequenceAnnotation(seqName).setAccessionNumber(text);\n}", "repo_id": "9", "comment": "/**\n * @param seqName\n * @param text\n */\n", "repo_name": "biojava-master/", "id": 26, "method_signature": "void addGSAccessionNumber(String, String)"}, "1089": {"callee_method_names": ["AtomicBoolean.get", "Logger.error", "int.getMessage", "ChemicalComponentDictionary.getChemComp"], "method_name": "AllChemCompProvider.getChemComp", "method_implementation": "{\n    while (loading.get()) {\n        // another thread is still initializing the definitions\n        try {\n            // wait half a second\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            logger.error(\"Interrepted thread while waiting: {}\", e.getMessage());\n            //e.printStackTrace();\n        }\n    }\n    return dict.getChemComp(recordName);\n}", "repo_id": "9", "comment": "/**\n *  {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1089, "method_signature": "ChemComp getChemComp(String)"}, "5": {"callee_method_names": [], "method_name": "SimpleGapPenalty.setOpenPenalty", "method_implementation": "{\n    this.gop = -Math.abs(gop);\n    setType();\n}", "repo_id": "9", "comment": "/**\n * @param gop Should be nonnegative\n */\n", "repo_name": "biojava-master/", "id": 5, "method_signature": "void setOpenPenalty(int)"}, "2648": {"callee_method_names": [], "method_name": "TranscriptionEngine.getDefault", "method_implementation": "{\n    return IOD.INSTANCE;\n}", "repo_id": "9", "comment": "/**\n * Default instance to use when Transcribing from DNA -&gt; RNA -&gt;\n * Protein. If you require anything that is not a default setting then look\n * at @ TranscriptionEngine.Builder} for customisation options.\n */\n", "repo_name": "biojava-master/", "id": 2648, "method_signature": "TranscriptionEngine getDefault()"}, "2837": {"callee_method_names": ["String.startsWith", "String.length", "String.charAt", "ArrayList<String>.add", "StringBuffer.toString", "StringBuffer.setLength", "String.length", "StringBuffer.append", "String.charAt", "ArrayList<String>.add", "StringBuffer.toString", "StringBuffer.append", "String.charAt", "ArrayList<String>.size", "ArrayList<String>.toArray", "String.split"], "method_name": "GenericFastaHeaderParser.getHeaderValues", "method_implementation": "{\n    String[] data = new String[0];\n    ArrayList<String> values = new ArrayList<String>();\n    StringBuffer sb = new StringBuffer();\n    //commented out 1/11/2012 to resolve an issue where headers do contain a length= at the end that are not recognized\n    //if(header.indexOf(\"length=\") != -1){\n    //    data = new String[1];\n    //    int index = header.indexOf(\"length=\");\n    //    data[0] = header.substring(0, index).trim();\n    //        logger.debug(\"accession=\" + data[0]);\n    //    return data;\n    //} else\n    if (!header.startsWith(\"PDB:\")) {\n        for (int i = 0; i < header.length(); i++) {\n            if (header.charAt(i) == '|') {\n                values.add(sb.toString());\n                //faster than  = new StringBuffer();\n                sb.setLength(0);\n            } else if (i == header.length() - 1) {\n                sb.append(header.charAt(i));\n                values.add(sb.toString());\n            } else {\n                sb.append(header.charAt(i));\n            }\n            data = new String[values.size()];\n            values.toArray(data);\n        }\n    } else {\n        data = header.split(\" \");\n    }\n    return data;\n}", "repo_id": "9", "comment": "/**\n * Parse out the components where some have a | and others do not\n * @param header\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2837, "method_signature": "String[] getHeaderValues(String)"}, "1935": {"callee_method_ids": [1939, 1941, 1943, 1945, 1947, 1949, 1951, 1955, 1953, 1957], "callee_method_names": ["ArrayList.size", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setMinRmsd", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setMaxRmsd", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setRmsd", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setMinTm", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setMaxTm", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setTm", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setRmsdCenters", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setTmIntra", "ArrayList.size", "ArrayList.get", "QuatSymmetryScores.setRmsdIntra", "QuatSymmetryScores.setSymDeviation"], "method_name": "RotationGroup.getScores", "method_implementation": "{\n    QuatSymmetryScores scores = new QuatSymmetryScores();\n    int n = rotations.size() - 1;\n    if (n > 0) {\n        double[] values = new double[n];\n        // minRmsd\n        for (int i = 1; i < rotations.size(); i++) {\n            values[i - 1] = rotations.get(i).getScores().getMinRmsd();\n        }\n        scores.setMinRmsd(minScores(values));\n        // maxRmsd\n        for (int i = 1; i < rotations.size(); i++) {\n            values[i - 1] = rotations.get(i).getScores().getMaxRmsd();\n        }\n        scores.setMaxRmsd(maxScores(values));\n        // Rmsd\n        for (int i = 1; i < rotations.size(); i++) {\n            values[i - 1] = rotations.get(i).getScores().getRmsd();\n        }\n        scores.setRmsd(averageScores(values));\n        // minTm\n        for (int i = 1; i < rotations.size(); i++) {\n            values[i - 1] = rotations.get(i).getScores().getMinTm();\n        }\n        scores.setMinTm(minScores(values));\n        // maxTm\n        for (int i = 1; i < rotations.size(); i++) {\n            values[i - 1] = rotations.get(i).getScores().getMaxTm();\n        }\n        scores.setMaxTm(maxScores(values));\n        // Tm\n        for (int i = 1; i < rotations.size(); i++) {\n            values[i - 1] = rotations.get(i).getScores().getTm();\n        }\n        scores.setTm(averageScores(values));\n        // Rmsd subunit centers\n        for (int i = 1; i < rotations.size(); i++) {\n            values[i - 1] = rotations.get(i).getScores().getRmsdCenters();\n        }\n        scores.setRmsdCenters(averageScores(values));\n        // TmIntra\n        for (int i = 1; i < rotations.size(); i++) {\n            values[i - 1] = rotations.get(i).getScores().getTmIntra();\n        }\n        scores.setTmIntra(averageScores(values));\n        // RmsdIntra\n        for (int i = 1; i < rotations.size(); i++) {\n            values[i - 1] = rotations.get(i).getScores().getRmsdIntra();\n        }\n        scores.setRmsdIntra(averageScores(values));\n        // SymDeviation\n        scores.setSymDeviation(symmetryDeviation);\n    }\n    return scores;\n}", "repo_id": "9", "comment": "/**\n * Returns QuatSymmetryScores averaged over all rotations\n * (except the first rotation, which is the unit operation E)\n * @return mean scores average over rotations\n */\n", "repo_name": "biojava-master/", "id": 1935, "method_signature": "QuatSymmetryScores getScores()"}, "2672": {"callee_method_names": [], "method_name": "MultipleSequenceAlignment.getAlignedSequences", "method_implementation": "{\n    return Collections.unmodifiableList(sequences);\n}", "repo_id": "9", "comment": "/**\n * Get the list of sequences\n * @return list of sequences\n */\n", "repo_name": "biojava-master/", "id": 2672, "method_signature": "List<S> getAlignedSequences()"}, "3221": {"callee_method_names": ["GenbankReader<DNASequence, NucleotideCompound>.process", "LinkedHashMap<String, DNASequence>.values", "DNASequence.getFeaturesByType", "FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>.getQualifiers", "FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>.getQualifiers"], "method_name": "GenbankReaderTest.testGithub843", "method_implementation": "{\n    CheckableInputStream inStream = new CheckableInputStream(this.getClass().getResourceAsStream(\"/NC_018080.gb\"));\n    assertNotNull(inStream);\n    GenbankReader<DNASequence, NucleotideCompound> genbankDNA = new GenbankReader<>(inStream, new GenericGenbankHeaderParser<>(), new DNASequenceCreator(DNACompoundSet.getDNACompoundSet()));\n    LinkedHashMap<String, DNASequence> dnaSequences = genbankDNA.process();\n    assertNotNull(dnaSequences);\n    DNASequence dna = new ArrayList<>(dnaSequences.values()).get(0);\n    assertNotNull(dna);\n    FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> tRNAFeature = dna.getFeaturesByType(\"tRNA\").get(0);\n    String anticodon = tRNAFeature.getQualifiers().get(\"anticodon\").get(0).getValue();\n    assertEquals(\"(pos:complement(1123552..1123554),aa:Leu,seq:caa)\", anticodon);\n    String transl_except = tRNAFeature.getQualifiers().get(\"transl_except\").get(0).getValue();\n    assertEquals(\"(pos:complement(1123552..1123554),aa:Leu)\", transl_except);\n}", "repo_id": "9", "comment": "/**\n * Biojava fails to parse anticodon and transl_except feature qualifiers when they line wrap.\n * https://github.com/biojava/biojava/issues/843\n */\n", "repo_name": "biojava-master/", "id": 3221, "method_signature": "void testGithub843()"}, "2830": {"callee_method_names": [], "method_name": "GenericGenbankHeaderParser.reset", "method_implementation": "{\n    this.version = 0;\n    this.versionSeen = false;\n    this.accession = null;\n    this.description = null;\n    this.identifier = null;\n    this.name = null;\n    this.comments.clear();\n}", "repo_id": "9", "comment": "/**\n * Sets the sequence info back to default values, ie. in order to start\n * constructing a new sequence from scratch.\n */\n", "repo_name": "biojava-master/", "id": 2830, "method_signature": "void reset()"}, "1532": {"callee_method_names": [], "method_name": "JournalArticle.getRefn", "method_implementation": "{\n    return refn;\n}", "repo_id": "9", "comment": "/**\n * Get the value of REFN field.\n * For example: ISSN 0969-2126\n *\n * @return the value of ref\n */\n", "repo_name": "biojava-master/", "id": 1532, "method_signature": "String getRefn()"}, "3550": {"callee_method_names": [], "method_name": "CoxCoefficient.setMean", "method_implementation": "{\n    this.mean = mean;\n}", "repo_id": "9", "comment": "/**\n * @param mean the mean to set\n */\n", "repo_name": "biojava-master/", "id": 3550, "method_signature": "void setMean(double)"}, "2957": {"callee_method_names": [], "method_name": "AbstractNucleotideCompoundSet.isComplementable", "method_implementation": "{\n    return true;\n}", "repo_id": "9", "comment": "/**\n * NucleotideCompounds can always complement\n */\n", "repo_name": "biojava-master/", "id": 2957, "method_signature": "boolean isComplementable()"}, "2021": {"callee_method_names": [], "method_name": "Prism.setInscribedRadius", "method_implementation": "{\n    double side = getSideLengthFromInscribedRadius(radius, n);\n    this.circumscribedRadius = getCircumscribedRadiusFromSideLength(side, n);\n}", "repo_id": "9", "comment": "/**\n * Sets the radius of an inscribed sphere, that is tangent to each\n * of the icosahedron's faces\n * @param inscribedRadius the inscribedRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2021, "method_signature": "void setInscribedRadius(double)"}, "845": {"callee_method_names": ["Group.getType", "HashMap<Character, Double>.get"], "method_name": "GroupAsa.getRelativeAsaC", "method_implementation": "{\n    if (!g.getType().equals(GroupType.AMINOACID))\n        throw new IllegalArgumentException(\"Can not calculate relative ASA for non amino-acid\");\n    char aa = ((AminoAcid) g).getAminoType();\n    return (asaC / tripeptAsa.get(aa));\n}", "repo_id": "9", "comment": "/**\n * Returns the relative (complexed) ASA, i.e. the ASA of the residue\n * with respect to its ASA in an extended tri-peptide conformation (GLY-x-GLY)\n * @return\n */\n", "repo_name": "biojava-master/", "id": 845, "method_signature": "double getRelativeAsaC()"}, "2437": {"callee_method_ids": [2431], "callee_method_names": ["FeatureI.group", "FeatureList.add"], "method_name": "FeatureList.selectByGroup", "method_implementation": "{\n    FeatureList list = new FeatureList();\n    for (FeatureI f : this) {\n        if (f.group().equals(groupid)) {\n            list.add(f);\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Create a list of all features that have the specified group id, as defined by\n * the group() method of the features.\n *\n * @param groupid The group to match.\n * @return A list of features having the specified group id.\n */\n", "repo_name": "biojava-master/", "id": 2437, "method_signature": "FeatureList selectByGroup(String)"}, "905": {"callee_method_names": [], "method_name": "StructureInterfaceList.getClustersNcs", "method_implementation": "{\n    return clustersNcs;\n}", "repo_id": "9", "comment": "/**\n * Get the interface clusters for this StructureInterfaceList grouped by NCS-equivalence.\n * This means that for any two interfaces in the same cluster:\n * 1. The chains forming the first interface are NCS-copies of the chains forming the second interface, in any order.\n * 2. Relative orientation of the chains is preserved, i.e. the contacts are identical.\n * @return list of {@link StructureInterfaceCluster} objects.\n * @since 5.0.0\n */\n", "repo_name": "biojava-master/", "id": 905, "method_signature": "List<StructureInterfaceCluster> getClustersNcs()"}, "2503": {"callee_method_names": [], "method_name": "TestLocation.L", "method_implementation": "{\n    return new Location(s, e);\n}", "repo_id": "9", "comment": "//shorthand for testing\n", "repo_name": "biojava-master/", "id": 2503, "method_signature": "Location L(int, int)"}, "1229": {"callee_method_names": ["String.indexOf", "String.substring", "String.split", "ArrayList.addAll"], "method_name": "PDBBioAssemblyParser.addToCurrentChainList", "method_implementation": "{\n    int index = line.indexOf(\":\");\n    String chainList = line.substring(index + 1).trim();\n    // split by spaces or commas\n    String[] chainIds = chainList.split(\"[ ,]+\");\n    currentChainIDs.addAll(Arrays.asList(chainIds));\n}", "repo_id": "9", "comment": "/**\n * Parses list of chain ids (A, B, C, etc.)\n */\n", "repo_name": "biojava-master/", "id": 1229, "method_signature": "void addToCurrentChainList(String)"}, "1883": {"callee_method_names": ["AxisAngle4d.set"], "method_name": "HelixSolver.getAxisAngle", "method_implementation": "{\n    AxisAngle4d axis = new AxisAngle4d();\n    axis.set(transformation);\n    return axis;\n}", "repo_id": "9", "comment": "/**\n * Returns the AxisAngle of the helix transformation\n *\n * @param transformation\n *            helix transformation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1883, "method_signature": "AxisAngle4d getAxisAngle(Matrix4d)"}, "3807": {"callee_method_names": ["Graphics2D.setColor", "Graphics2D.getFont", "Font.getFontName", "Font.getSize", "Graphics2D.setFont", "FontMetrics.getHeight", "ArrayList<String>.size", "FontMetrics.stringWidth", "ArrayList<String>.get", "Font.getFontName", "Graphics2D.setFont", "Graphics2D.drawString", "ArrayList<String>.get", "FontMetrics.stringWidth", "ArrayList<String>.get", "DecimalFormat.format", "Graphics2D.drawString", "FontMetrics.stringWidth", "Graphics2D.drawLine", "DecimalFormat.format", "Graphics2D.drawString", "FontMetrics.stringWidth", "Graphics2D.drawLine", "DecimalFormat.format", "Graphics2D.drawString", "FontMetrics.stringWidth", "Graphics2D.drawLine", "AffineTransform.rotate", "Font.deriveFont", "Graphics2D.setFont", "FontMetrics.stringWidth", "Graphics2D.drawString", "Graphics2D.setFont", "ArrayList.clear", "ArrayList.clear", "KMFigureInfo.isEmpty", "ArrayList.add", "ArrayList.add", "ArrayList.add", "ArrayList.add", "KMFigureInfo.get", "KMFigureInfo.get", "KMFigureInfo.size", "ArrayList.add", "ArrayList.add", "ArrayList.size", "ArrayList.get", "ArrayList.get", "DecimalFormat.format", "ArrayList.size", "Graphics2D.drawString", "FontMetrics.stringWidth", "FontMetrics.getHeight", "Graphics2D.drawString", "FontMetrics.stringWidth", "FontMetrics.getHeight", "Graphics2D.drawLine", "Graphics2D.setStroke", "Graphics2D.drawLine", "Graphics2D.drawLine", "Graphics2D.drawString", "FontMetrics.stringWidth", "FontMetrics.getHeight"], "method_name": "KaplanMeierFigure.drawLegend", "method_implementation": "{\n    Graphics2D g2 = (Graphics2D) g;\n    setRenderingHints(g2);\n    g2.setColor(Color.BLACK);\n    Font font = g2.getFont();\n    Font f = new Font(font.getFontName(), Font.BOLD, font.getSize());\n    g2.setFont(f);\n    fm = getFontMetrics(f);\n    int fontHeight = fm.getHeight();\n    for (int i = 0; i < title.size(); i++) {\n        if (fm.stringWidth(title.get(i)) > .8 * this.getWidth()) {\n            f = new Font(font.getFontName(), Font.BOLD, 10);\n            g2.setFont(f);\n            fm = getFontMetrics(f);\n        }\n        g2.drawString(title.get(i), (getSize().width - fm.stringWidth(title.get(i))) / 2, ((i + 1) * fontHeight));\n        // g2.setFont(font);\n    }\n    // draw the maxPercentage and minPercentage values\n    String label = df.format(minPercentage);\n    g2.drawString(label, left - 5 - (fm.stringWidth(label)), bottom + titleHeight / 6);\n    g2.drawLine(left - 5, bottom, left, bottom);\n    double d = minPercentage + kmfi.yaxisPercentIncrement;\n    //double graphHeight = top - bottom;\n    while (d < maxPercentage) {\n        int yvalue = bottom - (int) (d * (bottom - top));\n        label = df.format(d * 100);\n        //\n        g2.drawString(label, left - 5 - (fm.stringWidth(label)), yvalue + titleHeight / 6);\n        g2.drawLine(left - 5, yvalue, left, yvalue);\n        d = d + kmfi.yaxisPercentIncrement;\n    }\n    label = df.format(maxPercentage * 100);\n    g2.drawString(label, left - 5 - (fm.stringWidth(label)), top + (titleHeight) / 6);\n    g2.drawLine(left - 5, top, left, top);\n    // Create a rotation transformation for the font.\n    AffineTransform fontAT = new AffineTransform();\n    // Derive a new font using a rotatation transform\n    fontAT.rotate(270 * java.lang.Math.PI / 180);\n    Font theDerivedFont = f.deriveFont(fontAT);\n    // set the derived font in the Graphics2D context\n    g2.setFont(theDerivedFont);\n    // Render a string using the derived font\n    int yaxisHeight = fm.stringWidth(kmfi.yAxisLegend);\n    g2.drawString(kmfi.yAxisLegend, yaxisLabel, (bottom - (int) (.5 * (bottom - top))) + yaxisHeight / 2);\n    // put the original font back\n    g2.setFont(f);\n    double timeDistance = maxTime - minTime;\n    double timeIncrement = timeDistance * kmfi.xaxisPercentIncrement;\n    double timeInt = (int) Math.floor(timeIncrement);\n    if (timeInt < 1.0) {\n        timeInt = 1.0;\n    }\n    adjustedPercentIncrement = timeInt / timeDistance;\n    //kmfi.xaxisPercentIncrement;\n    d = adjustedPercentIncrement;\n    xAxisTimeValues.clear();\n    xAxisTimeCoordinates.clear();\n    //if we don't have time values then use percentage to set time. Not perfect but allows different tics\n    if (kmfi.xAxisLabels.isEmpty()) {\n        xAxisTimeValues.add(minTime);\n        xAxisTimeCoordinates.add(left);\n        while (d <= 1.0) {\n            //\n            double xaxisTime = ((minTime * kmfi.timeScale) + d * ((maxTime - minTime) * kmfi.timeScale));\n            xAxisTimeValues.add(xaxisTime);\n            Integer coordinate = left + (int) (d * (right - left));\n            xAxisTimeCoordinates.add(coordinate);\n            //       System.out.println(d + \" \" + left + \" \" + right + \" \" + coordinate + \" \" + minTime + \" \" + maxTime);\n            //kmfi.xaxisPercentIncrement;\n            d = d + adjustedPercentIncrement;\n        }\n    } else {\n        minTime = kmfi.xAxisLabels.get(0);\n        maxTime = kmfi.xAxisLabels.get(kmfi.xAxisLabels.size() - 1);\n        for (Double xaxisTime : kmfi.xAxisLabels) {\n            xAxisTimeValues.add(xaxisTime);\n            d = (xaxisTime - minTime) / (maxTime - minTime);\n            Integer coordinate = left + (int) (d * (right - left));\n            xAxisTimeCoordinates.add(coordinate);\n        }\n    }\n    for (int i = 0; i < xAxisTimeValues.size(); i++) {\n        Double xaxisTime = xAxisTimeValues.get(i);\n        Integer xCoordinate = xAxisTimeCoordinates.get(i);\n        label = df.format(xaxisTime);\n        if (i == xAxisTimeValues.size() - 1) {\n            g2.drawString(label, xCoordinate - (fm.stringWidth(label)), bottom + fm.getHeight() + 5);\n        } else {\n            g2.drawString(label, xCoordinate - (fm.stringWidth(label) / 2), bottom + fm.getHeight() + 5);\n        }\n        g2.drawLine(xCoordinate, bottom, xCoordinate, bottom + 5);\n    }\n    // draw the vertical and horizontal lines\n    g2.setStroke(kmfi.axisStroke);\n    g2.drawLine(left, top, left, bottom);\n    g2.drawLine(left, bottom, right, bottom);\n    // draw xAxis legend\n    g2.drawString(kmfi.xAxisLegend, getSize().width / 2 - (fm.stringWidth(kmfi.xAxisLegend) / 2), bottom + 2 * fm.getHeight() + 10);\n}", "repo_id": "9", "comment": "/**\n * Setup the axis, labels etc\n *\n * @param g\n */\n", "repo_name": "biojava-master/", "id": 3807, "method_signature": "void drawLegend(Graphics)"}, "893": {"callee_method_names": ["Logger.debug"], "method_name": "StructureInterface.isIsologous", "method_implementation": "{\n    double scoreInverse = this.getContactOverlapScore(this, true);\n    logger.debug(\"Interface {} contact overlap score with itself inverted: {}\", getId(), scoreInverse);\n    return (scoreInverse > SELF_SCORE_FOR_ISOLOGOUS);\n}", "repo_id": "9", "comment": "/**\n * Tell whether the interface is isologous, i.e. it is formed\n * by the same patches of same entity on both sides.\n *\n * @return true if isologous, false if heterologous\n */\n", "repo_name": "biojava-master/", "id": 893, "method_signature": "boolean isIsologous()"}, "64": {"callee_method_names": [], "method_name": "AbstractMatrixAligner.setGapPenalty", "method_implementation": "{\n    this.gapPenalty = gapPenalty;\n    reset();\n}", "repo_id": "9", "comment": "/**\n * Sets the gap penalties.\n *\n * @param gapPenalty the gap penalties used during alignment\n */\n", "repo_name": "biojava-master/", "id": 64, "method_signature": "void setGapPenalty(GapPenalty)"}, "1604": {"callee_method_names": ["Logger.debug", "SecStrucState.getType", "SecStrucState.getTurn", "SecStrucState.getTurn"], "method_name": "SecStrucCalc.checkSetHelix", "method_implementation": "{\n    int idx = n - 3;\n    logger.debug(\"Set helix {} {} {}\", type, n, idx);\n    for (int i = 1; i < groups.length - n; i++) {\n        SecStrucState state = getSecStrucState(i);\n        SecStrucState previousState = getSecStrucState(i - 1);\n        //Check that no other helix was assgined to this range\n        if (state.getType().compareTo(type) < 0)\n            continue;\n        if (getSecStrucState(i + 1).getType().compareTo(type) < 0)\n            continue;\n        char turn = state.getTurn()[idx];\n        char pturn = previousState.getTurn()[idx];\n        //Two consecutive n-turns present to define a n-helix\n        if ((turn == '>' || turn == 'X') && (pturn == '>' || pturn == 'X')) {\n            //Mark following n residues as turn\n            for (int k = 0; k < n; k++) {\n                setSecStrucType(i + k, type);\n            }\n            if (!DSSP_HELICES) {\n                setSecStrucType(i - 1, type);\n                setSecStrucType(i + n, type);\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * A minimal helix is defined by two consecutive n-turns.\n * For example, a 4-helix, of minimal length 4 from residues\n * i to (i+3), requires turns (of type 4) at residues (i-1) and i.\n * <p>\n * Note that the orignal DSSP implementation does not assign\n * helix type to residue (i-1) and residue (i+n+1), although\n * they contain a helix turn. As they state in the original paper,\n * \"the helices are one residue shorter than they would be according\n * to rule 6.3 of IUPAC-IUB\".\n *\n * @param n\n * @param type\n */\n", "repo_name": "biojava-master/", "id": 1604, "method_signature": "void checkSetHelix(int, SecStrucType)"}, "1439": {"callee_method_ids": [1423, 1422, 1422, 1424, 1421, 1421, 906], "callee_method_names": ["UnitCellBoundingBox.setBbs", "Logger.isDebugEnabled", "Logger.debug", "Logger.debug", "Logger.debug", "Structure.getPolyChains", "UnitCellBoundingBox.getTranslatedBbs", "UnitCellBoundingBox.getAuBoundingBox", "UnitCellBoundingBox.getAuBoundingBox", "CrystalTransform.translate", "CrystalTransform.isEquivalent", "Logger.debug", "CrystalTransform.toString", "UnitCellBoundingBox.getChainBoundingBox", "UnitCellBoundingBox.getChainBoundingBox", "StringBuilder.append", "List<Chain>.get", "List<Chain>.get", "Chain.clone", "StructureInterfaceList.addNcsEquivalent", "StructureInterfaceList.add", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Logger.debug", "StringBuilder.toString", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "StructureInterfaceList.size"], "method_name": "CrystalBuilder.calcInterfacesCrystal", "method_implementation": "{\n    // initialising debugging vars\n    long start = -1;\n    long end = -1;\n    int trialCount = 0;\n    int skippedRedundant = 0;\n    int skippedAUsNoOverlap = 0;\n    int skippedChainsNoOverlap = 0;\n    int skippedSelfEquivalent = 0;\n    // The bounding boxes of all AUs of the unit cell\n    UnitCellBoundingBox bbGrid = new UnitCellBoundingBox(numOperatorsSg, numPolyChainsAu);\n    ;\n    // we calculate all the bounds of each of the asym units, those will then be reused and translated\n    bbGrid.setBbs(structure, ops, INCLUDE_HETATOMS);\n    // if not crystallographic there's no search to do in other cells, only chains within \"AU\" will be checked\n    if (!searchBeyondAU)\n        numCells = 0;\n    boolean verbose = logger.isDebugEnabled();\n    if (verbose) {\n        trialCount = 0;\n        start = System.currentTimeMillis();\n        int neighbors = (2 * numCells + 1) * (2 * numCells + 1) * (2 * numCells + 1) - 1;\n        int auTrials = (numPolyChainsAu * (numPolyChainsAu - 1)) / 2;\n        int trials = numPolyChainsAu * numOperatorsSg * numPolyChainsAu * neighbors;\n        logger.debug(\"Chain clash trials within original AU: {}\", auTrials);\n        logger.debug(\"Chain clash trials between the original AU and the neighbouring \" + neighbors + \" whole unit cells (\" + numCells + \" neighbours)\" + \"(2x\" + numPolyChainsAu + \"chains x \" + numOperatorsSg + \"AUs x \" + neighbors + \"cells) : \" + trials);\n        logger.debug(\"Total trials: {}\", (auTrials + trials));\n    }\n    List<Chain> polyChains = structure.getPolyChains();\n    for (int a = -numCells; a <= numCells; a++) {\n        for (int b = -numCells; b <= numCells; b++) {\n            for (int c = -numCells; c <= numCells; c++) {\n                Point3i trans = new Point3i(a, b, c);\n                Vector3d transOrth = new Vector3d(a, b, c);\n                if (a != 0 || b != 0 || c != 0) {\n                    // we avoid doing the transformation for 0,0,0 (in case it's not crystallographic)\n                    this.crystallographicInfo.getCrystalCell().transfToOrthonormal(transOrth);\n                }\n                UnitCellBoundingBox bbGridTrans = bbGrid.getTranslatedBbs(transOrth);\n                for (int n = 0; n < numOperatorsSg; n++) {\n                    // short-cut strategies\n                    // 1) we skip first of all if the bounding boxes of the AUs don't overlap\n                    if (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(n), cutoff)) {\n                        skippedAUsNoOverlap++;\n                        continue;\n                    }\n                    // 2) we check if we didn't already see its equivalent symmetry operator partner\n                    CrystalTransform tt = new CrystalTransform(this.crystallographicInfo.getSpaceGroup(), n);\n                    tt.translate(trans);\n                    if (isRedundantTransform(tt)) {\n                        skippedRedundant++;\n                        continue;\n                    }\n                    addVisitedTransform(tt);\n                    boolean selfEquivalent = false;\n                    // 3) an operator can be \"self redundant\" if it is the inverse of itself (involutory, e.g. all pure 2-folds with no translation)\n                    if (tt.isEquivalent(tt)) {\n                        logger.debug(\"Transform {} is equivalent to itself, will skip half of i-chains to j-chains comparisons\", tt.toString());\n                        // in this case we can't skip the operator, but we can skip half of the matrix comparisons e.g. j>i\n                        // we set a flag and do that within the loop below\n                        selfEquivalent = true;\n                    }\n                    StringBuilder builder = null;\n                    if (verbose)\n                        builder = new StringBuilder(String.valueOf(tt)).append(\" \");\n                    // Now that we know that boxes overlap and operator is not redundant, we have to go to the details\n                    int contactsFound = 0;\n                    for (int j = 0; j < numPolyChainsAu; j++) {\n                        for (int i = 0; i < numPolyChainsAu; i++) {\n                            // we only have to compare the original asymmetric unit to every full cell around\n                            if (selfEquivalent && (j > i)) {\n                                // in case of self equivalency of the operator we can safely skip half of the matrix\n                                skippedSelfEquivalent++;\n                                continue;\n                            }\n                            // special case of original AU, we don't compare a chain to itself\n                            if (n == 0 && a == 0 && b == 0 && c == 0 && i == j)\n                                continue;\n                            // before calculating the AtomContactSet we check for overlap, then we save putting atoms into the grid\n                            if (!bbGrid.getChainBoundingBox(0, i).overlaps(bbGridTrans.getChainBoundingBox(n, j), cutoff)) {\n                                skippedChainsNoOverlap++;\n                                if (verbose) {\n                                    builder.append(\".\");\n                                }\n                                continue;\n                            }\n                            trialCount++;\n                            // finally we've gone through all short-cuts and the 2 chains seem to be close enough:\n                            // we do the calculation of contacts\n                            Chain chaini = polyChains.get(i);\n                            Chain chainj = polyChains.get(j);\n                            if (n != 0 || a != 0 || b != 0 || c != 0) {\n                                Matrix4d mJCryst = new Matrix4d(ops[n]);\n                                translate(mJCryst, transOrth);\n                                chainj = (Chain) chainj.clone();\n                                Calc.transform(chainj, mJCryst);\n                            }\n                            StructureInterface interf = calcContacts(chaini, chainj, cutoff, tt, builder);\n                            if (interf == null) {\n                                continue;\n                            }\n                            contactsFound++;\n                            if (this.hasNcsOps()) {\n                                StructureInterface interfNcsRef = findNcsRef(interf);\n                                set.addNcsEquivalent(interf, interfNcsRef);\n                            } else {\n                                set.add(interf);\n                            }\n                        }\n                    }\n                    if (verbose) {\n                        if (a == 0 && b == 0 && c == 0 && n == 0)\n                            builder.append(\" \" + contactsFound + \"(\" + (numPolyChainsAu * (numPolyChainsAu - 1)) / 2 + \")\");\n                        else if (selfEquivalent)\n                            builder.append(\" \" + contactsFound + \"(\" + (numPolyChainsAu * (numPolyChainsAu + 1)) / 2 + \")\");\n                        else\n                            builder.append(\" \" + contactsFound + \"(\" + numPolyChainsAu * numPolyChainsAu + \")\");\n                        logger.debug(builder.toString());\n                    }\n                }\n            }\n        }\n    }\n    end = System.currentTimeMillis();\n    logger.debug(\"\\n{} chain-chain clash trials done. Time {}{}s\", trialCount, (end - start), 1000);\n    logger.debug(\"  skipped (not overlapping AUs)       : {}\", skippedAUsNoOverlap);\n    logger.debug(\"  skipped (not overlapping chains)    : {}\", skippedChainsNoOverlap);\n    logger.debug(\"  skipped (sym redundant op pairs)    : {}\", skippedRedundant);\n    logger.debug(\"  skipped (sym redundant self op)     : {}\", skippedSelfEquivalent);\n    logger.debug(\"Found {} interfaces.\", set.size());\n}", "repo_id": "9", "comment": "/**\n * Calculate interfaces between original asymmetric unit and neighboring\n * whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0\n * @param set\n * @param cutoff\n */\n", "repo_name": "biojava-master/", "id": 1439, "method_signature": "void calcInterfacesCrystal(StructureInterfaceList, double)"}, "248": {"callee_method_names": ["Set<ProteinModification>.remove", "Map<String, ProteinModification>.remove", "ProteinModification.getId", "Map<String, Set<ProteinModification>>.get", "ProteinModification.getResidId", "Set<ProteinModification>.remove", "Map<String, Set<ProteinModification>>.get", "ProteinModification.getPsimodId", "Set<ProteinModification>.remove", "Map<String, Set<ProteinModification>>.get", "ProteinModification.getPdbccId", "Set<ProteinModification>.remove", "ProteinModification.getKeywords", "Map<String, Set<ProteinModification>>.get", "Set<ProteinModification>.remove", "ProteinModification.getCondition", "ModificationCondition.getComponents", "Map<Component, Set<ProteinModification>>.get", "Set<ProteinModification>.remove", "Map<ModificationCategory, Set<ProteinModification>>.get", "ProteinModification.getCategory", "Map<ModificationOccurrenceType, Set<ProteinModification>>.get", "ProteinModification.getOccurrenceType"], "method_name": "ProteinModificationRegistry.unregister", "method_implementation": "{\n    if (modification == null)\n        throw new IllegalArgumentException(\"modification == null!\");\n    registry.remove(modification);\n    byId.remove(modification.getId());\n    Set<ProteinModification> mods;\n    mods = byResidId.get(modification.getResidId());\n    if (mods != null)\n        mods.remove(modification);\n    mods = byPsimodId.get(modification.getPsimodId());\n    if (mods != null)\n        mods.remove(modification);\n    mods = byPdbccId.get(modification.getPdbccId());\n    if (mods != null)\n        mods.remove(modification);\n    for (String keyword : modification.getKeywords()) {\n        mods = byKeyword.get(keyword);\n        if (mods != null)\n            mods.remove(modification);\n    }\n    ModificationCondition condition = modification.getCondition();\n    List<Component> comps = condition.getComponents();\n    for (Component comp : comps) {\n        mods = byComponent.get(comp);\n        if (mods != null)\n            mods.remove(modification);\n    }\n    byCategory.get(modification.getCategory()).remove(modification);\n    byOccurrenceType.get(modification.getOccurrenceType()).remove(modification);\n}", "repo_id": "9", "comment": "/**\n * Remove a modification from registry.\n * @param mod\n */\n", "repo_name": "biojava-master/", "id": 248, "method_signature": "void unregister(ProteinModification)"}, "3819": {"callee_method_ids": [3515, 3515], "callee_method_names": ["ArrayList<SurvivalInfo>.size", "StrataInfo.getOriginalMetaData", "DescriptiveStatistics.addValue", "StrataInfo.getTime", "StrataInfo.getTime", "DescriptiveStatistics.getMean", "DescriptiveStatistics.getMin", "DescriptiveStatistics.getMax"], "method_name": "ExpressionFigure.setSurvivalInfo", "method_implementation": "{\n    this.siList = new ArrayList<SurvivalInfo>();\n    this.title = title;\n    this.variable = variable;\n    minX = 0.0;\n    maxX = (double) _siList.size();\n    minY = 0.0;\n    maxY = null;\n    DescriptiveStatistics ds = new DescriptiveStatistics();\n    for (SurvivalInfo si : _siList) {\n        this.siList.add(si);\n        String v = si.getOriginalMetaData(variable);\n        Double value = Double.parseDouble(v);\n        ds.addValue(value);\n        if (maxTime == null || maxTime < si.getTime()) {\n            maxTime = si.getTime();\n        }\n    }\n    SurvivalInfoValueComparator sivc = new SurvivalInfoValueComparator(variable);\n    Collections.sort(this.siList, sivc);\n    mean = ds.getMean();\n    minY = ds.getMin();\n    maxY = ds.getMax();\n    minY = (double) Math.floor(minY);\n    maxY = (double) Math.ceil(maxY);\n    this.repaint();\n}", "repo_id": "9", "comment": "/**\n * @param title\n * @param _siList\n * @param variable\n */\n", "repo_name": "biojava-master/", "id": 3819, "method_signature": "void setSurvivalInfo(ArrayList, ArrayList, String)"}, "3081": {"callee_method_names": [], "method_name": "AbstractFeature.getType", "method_implementation": "{\n    return type;\n}", "repo_id": "9", "comment": "/**\n * The feature type\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3081, "method_signature": "String getType()"}, "3046": {"callee_method_names": ["int.getStart", "ResidueNumber.getStart"], "method_name": "LocationHelper.getMin", "method_implementation": "{\n    return scanLocations(locations, new LocationPredicate() {\n\n        @Override\n        public boolean accept(Location previous, Location current) {\n            int res = current.getStart().compareTo(previous.getStart());\n            return res < 0;\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Scans through a list of locations to find the Location with the\n * lowest start\n */\n", "repo_name": "biojava-master/", "id": 3046, "method_signature": "Location getMin(List)"}, "1562": {"callee_method_names": ["Set<String>.add", "ResidueRange.getChainName"], "method_name": "ScopDomain.getChains", "method_implementation": "{\n    Set<String> chains = new HashSet<String>();\n    List<ResidueRange> rrs = ResidueRange.parseMultiple(getRanges());\n    for (ResidueRange rr : rrs) chains.add(rr.getChainName());\n    return chains;\n}", "repo_id": "9", "comment": "/**\n * Returns the chains this domain is defined over; contains more than 1 element only if this domains is a multi-chain domain.\n */\n", "repo_name": "biojava-master/", "id": 1562, "method_signature": "Set<String> getChains()"}, "3206": {"callee_method_names": ["BlastXMLParser.setDatabaseReferences"], "method_name": "BlastXMLParserTest.testSetDatabaseReferences", "method_implementation": "{\n    System.out.println(\"setDatabaseReferences\");\n    List<org.biojava.nbio.core.sequence.template.Sequence> sequences = null;\n    BlastXMLParser instance = new BlastXMLParser();\n    instance.setDatabaseReferences(sequences);\n    // TODO review the generated test code and remove the default call to fail.\n    fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of setDatabaseReferences method, of class BlastXMLParser.\n */\n", "repo_name": "biojava-master/", "id": 3206, "method_signature": "void testSetDatabaseReferences()"}, "57": {"callee_method_names": [], "method_name": "AbstractProfileProfileAligner.setQuery", "method_implementation": "{\n    this.query = query;\n    queryFuture = null;\n    reset();\n}", "repo_id": "9", "comment": "/**\n * Sets the query {@link Profile}.\n *\n * @param query the first {@link Profile} of the pair to align\n */\n", "repo_name": "biojava-master/", "id": 57, "method_signature": "void setQuery(Profile)"}, "3627": {"callee_method_names": [], "method_name": "CoxInfo.getRscore", "method_implementation": "{\n    return rscore;\n}", "repo_id": "9", "comment": "/**\n * @return the rscore\n */\n", "repo_name": "biojava-master/", "id": 3627, "method_signature": "Double getRscore()"}, "2048": {"callee_method_ids": [2105, 2100, 2097, 2094, 2100], "callee_method_names": ["MultipleAlignment.getBlocks", "List<List<Integer>>.get", "SymmetryAxes.getNumLevels", "SymmetryAxes.getFirstRepeats", "SymmetryAxes.getRepeatTransform", "SymmetryAxes.getRepeatRelation", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "MultipleAlignment.getAtomArrays", "MultipleAlignment.getAtomArrays", "List<Atom>.add", "List<Atom>.add", "List<Atom>.toArray", "List<Atom>.size", "List<Atom>.toArray", "List<Atom>.size", "SymmetryAxes.updateAxis", "MultipleAlignment.size", "List<Matrix4d>.add", "SymmetryAxes.getRepeatTransform", "MultipleAlignment.getBlockSet", "MultipleSuperimposer.superimpose"], "method_name": "SymmetryTools.updateSymmetryTransformation", "method_implementation": "{\n    List<List<Integer>> block = msa.getBlocks().get(0).getAlignRes();\n    int length = block.get(0).size();\n    if (axes != null) {\n        for (int level = 0; level < axes.getNumLevels(); level++) {\n            // Calculate the aligned atom arrays to superimpose\n            List<Atom> list1 = new ArrayList<Atom>();\n            List<Atom> list2 = new ArrayList<Atom>();\n            for (int firstRepeat : axes.getFirstRepeats(level)) {\n                Matrix4d transform = axes.getRepeatTransform(firstRepeat);\n                List<List<Integer>> relation = axes.getRepeatRelation(level, firstRepeat);\n                for (int index = 0; index < relation.get(0).size(); index++) {\n                    int p1 = relation.get(0).get(index);\n                    int p2 = relation.get(1).get(index);\n                    for (int k = 0; k < length; k++) {\n                        Integer pos1 = block.get(p1).get(k);\n                        Integer pos2 = block.get(p2).get(k);\n                        if (pos1 != null && pos2 != null) {\n                            Atom a = (Atom) msa.getAtomArrays().get(p1)[pos1].clone();\n                            Atom b = (Atom) msa.getAtomArrays().get(p2)[pos2].clone();\n                            Calc.transform(a, transform);\n                            Calc.transform(b, transform);\n                            list1.add(a);\n                            list2.add(b);\n                        }\n                    }\n                }\n            }\n            Atom[] arr1 = list1.toArray(new Atom[list1.size()]);\n            Atom[] arr2 = list2.toArray(new Atom[list2.size()]);\n            // Calculate the new transformation information\n            if (arr1.length > 0 && arr2.length > 0) {\n                Matrix4d axis = SuperPositions.superpose(Calc.atomsToPoints(arr1), Calc.atomsToPoints(arr2));\n                axes.updateAxis(level, axis);\n            }\n            // Get the transformations from the SymmetryAxes\n            List<Matrix4d> transformations = new ArrayList<Matrix4d>();\n            for (int su = 0; su < msa.size(); su++) {\n                transformations.add(axes.getRepeatTransform(su));\n            }\n            msa.getBlockSet(0).setTransformations(transformations);\n        }\n    } else {\n        MultipleSuperimposer imposer = new CoreSuperimposer();\n        imposer.superimpose(msa);\n    }\n    updateSymmetryScores(msa);\n}", "repo_id": "9", "comment": "/**\n * Calculates the set of symmetry operation Matrices (transformations) of\n * the new alignment, based on the symmetry relations in the SymmetryAxes\n * object. It sets the transformations to the input MultipleAlignment and\n * SymmetryAxes objects. If the SymmetryAxes object is null, the\n * superposition of the repeats is done without symmetry constraints.\n * <p>\n * This method also sets the scores (RMSD and TM-score) after the new\n * superposition has been updated.\n *\n * @param axes\n *            SymmetryAxes object. It will be modified.\n * @param msa\n *            MultipleAlignment. It will be modified.\n */\n", "repo_name": "biojava-master/", "id": 2048, "method_signature": "void updateSymmetryTransformation(SymmetryAxes, MultipleAlignment)"}, "657": {"callee_method_names": ["List<Integer>.get", "MultipleAlignment.getBlocks", "String.length", "String.length", "String.getAlignRes", "MultipleAlignment.getAtomArrays"], "method_name": "MultipleAlignmentTools.getAtomForSequencePosition", "method_implementation": "{\n    int seqPos = mapSeqToStruct.get(sequencePos);\n    // Check if the position selected is an aligned position\n    if (seqPos == -1)\n        return null;\n    else {\n        Atom a = null;\n        // Calculate the corresponding structure position\n        int sum = 0;\n        for (Block b : msa.getBlocks()) {\n            if (sum + b.length() <= seqPos) {\n                sum += b.length();\n                continue;\n            } else {\n                for (Integer p : b.getAlignRes().get(str)) {\n                    if (sum == seqPos) {\n                        if (p != null) {\n                            a = msa.getAtomArrays().get(str)[p];\n                        }\n                        break;\n                    }\n                    sum++;\n                }\n                break;\n            }\n        }\n        return a;\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the Atom of the specified structure that is aligned in the\n * sequence alignment position specified.\n *\n * @param multAln\n *            the MultipleAlignment object from where the sequence alignment\n *            has been generated\n * @param mapSeqToStruct\n *            the mapping between sequence and structure generated with the\n *            sequence alignment\n * @param str\n *            the structure index of the alignment (row)\n * @param sequencePos\n *            the sequence alignment position (column)\n * @return Atom the atom in that position or null if there is a gap\n */\n", "repo_name": "biojava-master/", "id": 657, "method_signature": "Atom getAtomForSequencePosition(MultipleAlignment, List, int, int)"}, "3466": {"callee_method_ids": [3476, 3447, 3447, 3447], "callee_method_names": ["RemotePairwiseAlignmentProperties.getAlignmentOptions", "Map<String, String>.put", "RemotePairwiseAlignmentProperties.getAlignmentOption", "String.isEmpty", "Map<String, String>.containsKey", "Map<String, String>.containsKey", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "MapToStringTransformer.transform", "URL.openConnection", "URLConnection.getOutputStream", "OutputStreamWriter.write", "OutputStreamWriter.flush", "URLConnection.getInputStream", "BufferedReader.readLine", "String.contains", "String.contains", "String.contains", "String.split", "BlastJob.setId", "String[].trim", "String.contains", "String.split", "BlastJob.setStartTimestamp", "BlastJob.setExpectedExecutionTime", "String[].trim", "HashMap.put", "BlastJob.getId", "String.split", "String[].split", "String[].trim", "BlastJob.getId", "BlastJob.getId", "MouseEvent.getMessage"], "method_name": "NCBIQBlastService.sendAlignmentRequest", "method_implementation": "{\n    Map<String, String> params = new HashMap<String, String>();\n    for (String key : alignmentProperties.getAlignmentOptions()) {\n        params.put(key, alignmentProperties.getAlignmentOption(key));\n    }\n    if (query == null || query.isEmpty()) {\n        throw new IllegalArgumentException(\"Impossible to execute QBlast request. The sequence has not been set.\");\n    }\n    if (!params.containsKey(PROGRAM.name())) {\n        throw new IllegalArgumentException(\"Impossible to execute QBlast request. Parameter PROGRAM has not been set.\");\n    }\n    if (!params.containsKey(DATABASE.name())) {\n        throw new IllegalArgumentException(\"Impossible to execute QBlast request. Parameter DATABASE has not been set.\");\n    }\n    params.put(CMD.name(), \"Put\");\n    params.put(QUERY.name(), query);\n    params.put(TOOL.name(), getTool());\n    params.put(EMAIL.name(), getEmail());\n    String putCmd = MAP_TO_STRING_TRANSFORMER.transform(params);\n    OutputStreamWriter writer = null;\n    BufferedReader reader = null;\n    try {\n        URLConnection serviceConnection = setQBlastServiceProperties(serviceUrl.openConnection());\n        writer = new OutputStreamWriter(serviceConnection.getOutputStream());\n        writer.write(putCmd);\n        writer.flush();\n        // Get the response\n        reader = new BufferedReader(new InputStreamReader(serviceConnection.getInputStream()));\n        // find request id and time of execution\n        BlastJob job = new BlastJob();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (!line.contains(\"class=\\\"error\\\"\") && !line.contains(\"Message ID#\")) {\n                // if there is no error, capture RID and RTOE\n                if (line.contains(\"RID = \")) {\n                    String[] arr = line.split(\"=\");\n                    job.setId(arr[1].trim());\n                } else if (line.contains(\"RTOE = \")) {\n                    String[] arr = line.split(\"=\");\n                    job.setStartTimestamp(System.currentTimeMillis());\n                    job.setExpectedExecutionTime(Long.parseLong(arr[1].trim()) * 1000);\n                }\n                jobs.put(job.getId(), job);\n            } else {\n                // handle QBlast error message\n                // Capture everything to the left of this HTML statement...\n                String[] tmp = line.split(\"</p></li></ul>\");\n                // Only the error message is on the right side of this...\n                String[] moreTmp = tmp[0].split(\"<p class=\\\"error\\\">\");\n                throw new Exception(\"NCBI QBlast refused this request because: \" + moreTmp[1].trim());\n            }\n        }\n        if (job != null && job.getId() != null) {\n            return job.getId();\n        } else {\n            throw new Exception(\"Unable to retrieve request ID\");\n        }\n    } catch (IOException e) {\n        throw new IOException(\"An error occured submiting sequence to BLAST server. Cause: \" + e.getMessage(), e);\n    } finally {\n        IOUtils.close(reader);\n        IOUtils.close(writer);\n    }\n}", "repo_id": "9", "comment": "/**\n * Sends the Blast request via the Put command of the CGI-BIN interface. Uses all of the parameters specified in\n * {@code alignmentProperties} (parameters PROGRAM and DATABASE are required).\n *\n * @param query : a {@code String} representing a sequence or Genbank ID\n * @param alignmentProperties : a {@code RemotePairwiseAlignmentProperties} object representing alignment properties\n * @return the request id for this sequence, necessary to fetch results after completion\n * @throws Exception if unable to connect to the NCBI QBlast service or if no sequence or required parameters\n *             PROGRAM and DATABASE are not set\n */\n", "repo_name": "biojava-master/", "id": 3466, "method_signature": "String sendAlignmentRequest(String, RemotePairwiseAlignmentProperties)"}, "2180": {"callee_method_ids": [628, 633], "callee_method_names": ["AtomCache.getStructure", "List<ResidueRangeAndLength>.get", "AtomCache.getStructureForDomain", "Structure.getPolyChains", "Structure.getPolyChainByPDB", "Chain.getAtomGroups", "Structure.getNonPolyChainsByPDB", "Chain.getAtomGroups", "List<Group>.size"], "method_name": "AtomCacheTest.testGetStructureForDomain3", "method_implementation": "{\n    String ranges = \"E:\";\n    Structure whole = cache.getStructure(\"1I3O\");\n    AtomPositionMap map = new AtomPositionMap(StructureTools.getAllAtomArray(whole), AtomPositionMap.ANYTHING_MATCHER);\n    List<ResidueRangeAndLength> rrs = ResidueRangeAndLength.parseMultiple(ranges, map);\n    int expectedLengthE = rrs.get(0).getLength();\n    Structure structure = cache.getStructureForDomain(\"d1i3oe_\");\n    assertEquals(1, structure.getPolyChains().size());\n    Chain e = structure.getPolyChainByPDB(\"E\");\n    // since biojava 5.0 we have no ligand molecules in the polymer chains, we have to subtract the 2 zinc molecules\n    assertEquals(expectedLengthE - 2, e.getAtomGroups().size());\n    Chain eligands = structure.getNonPolyChainsByPDB(\"E\").get(0);\n    List<Group> ligandsE = StructureTools.filterLigands(eligands.getAtomGroups());\n    assertEquals(1, ligandsE.size());\n}", "repo_id": "9", "comment": "/**\n * Tests {@link AtomCache#getStructureForDomain(String)} on a single-chain domain with two zinc ligands that occurs after the TER.\n */\n", "repo_name": "biojava-master/", "id": 2180, "method_signature": "void testGetStructureForDomain3()"}, "1505": {"callee_method_names": ["Matrix4d.set"], "method_name": "SuperPositionQCP.weightedSuperpose", "method_implementation": "{\n    set(moved, fixed, weight);\n    getRotationMatrix();\n    if (!centered) {\n        calcTransformation();\n    } else {\n        transformation.set(rotmat);\n    }\n    return transformation;\n}", "repo_id": "9", "comment": "/**\n * Weighted superposition.\n *\n * @param fixed\n * @param moved\n * @param weight\n *            array of weigths for each equivalent point position\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1505, "method_signature": "Matrix4d weightedSuperpose(Point3d[], Point3d[], double[])"}, "3236": {"callee_method_names": ["String.endsWith", "String.endsWith", "String.contains", "File.delete"], "method_name": "GenbankProxySequenceReaderTest.copyTestFileToWorkingDirectory", "method_implementation": "{\n    String destRoot = System.getProperty(\"java.io.tmpdir\");\n    //if the directory does not end with a slash or backslash then add one\n    if (!(destRoot.endsWith(\"/\") || destRoot.endsWith(\"\\\\\"))) {\n        destRoot += destRoot.contains(\"/\") ? \"/\" : \"\\\\\";\n    }\n    String dest = destRoot + filename;\n    String src = \"org/biojava/nbio/core/sequence/loader/\" + filename;\n    //Remove any pre-existing files\n    File d = new File(dest);\n    d.delete();\n    try (FileOutputStream destination = new FileOutputStream(d);\n        InputStream is = this.getClass().getClassLoader().getResourceAsStream(src);\n        ReadableByteChannel source = Channels.newChannel(is)) {\n        destination.getChannel().transferFrom(source, 0, Long.MAX_VALUE);\n    }\n}", "repo_id": "9", "comment": "/**\n * Convenience method for {@link GenbankProxySequenceReaderTest#copyTestFiles()}\n * @param filename name of the file to copy from the resource folder\n * @throws IOException when something goes wrong with copying the files.\n */\n", "repo_name": "biojava-master/", "id": 3236, "method_signature": "void copyTestFileToWorkingDirectory(String)"}, "2559": {"callee_method_names": ["ReferenceQueue.poll", "HashMap.remove"], "method_name": "SoftHashMap.clearGCCollected", "method_implementation": "{\n    SoftValue<K, V> sv;\n    while ((sv = (SoftValue<K, V>) queue.poll()) != null) {\n        // we can access private data!\n        map.remove(sv.key);\n    }\n}", "repo_id": "9", "comment": "/**\n * Here we go through the ReferenceQueue and remove garbage collected\n * SoftValue objects from the HashMap by looking them up using the\n * SoftValue.key data member.\n */\n", "repo_name": "biojava-master/", "id": 2559, "method_signature": "void clearGCCollected()"}, "2190": {"callee_method_names": ["List<Atom[]>.add", "List<List<Integer>>.add", "List<List<Integer>>.add", "List<List<Integer>>.add", "MultipleAlignment.getEnsemble", "Block.setAlignRes", "Matrix4d.setIdentity", "BlockSet.setTransformations"], "method_name": "TestMultipleAlignmentScorer.gappedMSTA", "method_implementation": "{\n    //Generate three identical Atom arrays\n    List<Atom[]> atomArrays = new ArrayList<Atom[]>(30);\n    for (int i = 0; i < 3; i++) atomArrays.add(makeDummyCA(30));\n    //Generate alignment with nulls and some missalignments\n    List<List<Integer>> alnRes = new ArrayList<List<Integer>>(3);\n    List<Integer> chain1 = Arrays.asList(1, 2, 3, 5, 8, 10, 12, 15, 17, 19, 22, null, 24, 27);\n    List<Integer> chain2 = Arrays.asList(1, null, 3, 6, 9, 11, 12, 15, null, 18, 22, 24, 26, 28);\n    List<Integer> chain3 = Arrays.asList(1, 2, 4, 7, 9, 10, null, 15, null, 17, 22, 24, 26, 28);\n    alnRes.add(chain1);\n    alnRes.add(chain2);\n    alnRes.add(chain3);\n    //MultipleAlignment generation\n    MultipleAlignment msa = new MultipleAlignmentImpl();\n    msa.getEnsemble().setAtomArrays(atomArrays);\n    BlockSet bs = new BlockSetImpl(msa);\n    Block b = new BlockImpl(bs);\n    b.setAlignRes(alnRes);\n    //We want the identity transfromations to mantain the missalignments\n    Matrix4d ident = new Matrix4d();\n    ident.setIdentity();\n    bs.setTransformations(Arrays.asList(ident, ident, ident));\n    return msa;\n}", "repo_id": "9", "comment": "/**\n * Generates a simple MultipleAlignment: 3 structures with the\n * same Atoms but incorreclty aligned with gaps.\n *\n * @return MultipleAlignment gapped MSTA\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2190, "method_signature": "MultipleAlignment gappedMSTA()"}, "2933": {"callee_method_names": [], "method_name": "AbstractSequence.setFeaturesKeyWord", "method_implementation": "{\n    this.featuresKeyWord = featuresKeyWord;\n}", "repo_id": "9", "comment": "/**\n * @param featuresKeyWord the featuresKeyWord to set\n */\n", "repo_name": "biojava-master/", "id": 2933, "method_signature": "void setFeaturesKeyWord(FeaturesKeyWordInterface)"}, "1981": {"callee_method_names": ["Vector3d.dot", "Vector3d.dot", "Vector3d.dot", "Vector3d.negate"], "method_name": "HelixAxisAligner.getReferenceAxisCylic", "method_implementation": "{\n    // get principal axis vector that is perpendicular to the principal\n    // rotation vector\n    Vector3d vmin = null;\n    double dotMin = 1.0;\n    for (Vector3d v : principalAxesOfInertia) {\n        if (Math.abs(principalRotationVector.dot(v)) < dotMin) {\n            dotMin = Math.abs(principalRotationVector.dot(v));\n            vmin = new Vector3d(v);\n        }\n    }\n    if (principalRotationVector.dot(vmin) < 0) {\n        vmin.negate();\n    }\n    return vmin;\n}", "repo_id": "9", "comment": "/**\n * Returns the default reference vector for the alignment of Cn structures\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1981, "method_signature": "Vector3d getReferenceAxisCylic()"}, "620": {"callee_method_names": [], "method_name": "AtomCache.getRepresentativeAtoms", "method_implementation": "{\n    return getRepresentativeAtoms(new StructureName(name));\n}", "repo_id": "9", "comment": "/**\n * Returns the representative atoms for the provided name.\n * See {@link #getStructure(String)} for supported naming conventions.\n *\n * @param name\n * @return an array of Atoms.\n * @throws IOException\n * @throws StructureException\n * @see\n */\n", "repo_name": "biojava-master/", "id": 620, "method_signature": "Atom[] getRepresentativeAtoms(String)"}, "562": {"callee_method_names": ["Atom.getX", "Atom.getY", "Atom.getZ"], "method_name": "RotationAxis.getRotationMatrix", "method_implementation": "{\n    if (rotationAxis == null) {\n        // special case for pure translational axes\n        return Matrix.identity(3, 3);\n    }\n    double x = rotationAxis.getX();\n    double y = rotationAxis.getY();\n    double z = rotationAxis.getZ();\n    double cos = Math.cos(theta);\n    double sin = Math.sin(theta);\n    double com = 1 - cos;\n    return new Matrix(new double[][] { { com * x * x + cos, com * x * y + sin * z, com * x * z + -sin * y }, { com * x * y - sin * z, com * y * y + cos, com * y * z + sin * x }, { com * x * z + sin * y, com * y * z - sin * x, com * z * z + cos } });\n}", "repo_id": "9", "comment": "/**\n * Get the rotation matrix corresponding to a rotation about this axis\n * @param theta The amount to rotate\n * @return A 3x3 rotation matrix\n */\n", "repo_name": "biojava-master/", "id": 562, "method_signature": "Matrix getRotationMatrix(double)"}, "2751": {"callee_method_names": [], "method_name": "EmblRecord.getConstructedSequence", "method_implementation": "{\n    return constructedSequence;\n}", "repo_id": "9", "comment": "/**\n * Con(structed) sequences in the CON data classes represent complete\n * chromosomes, genomes and other long sequences constructed from segment entries.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2751, "method_signature": "String getConstructedSequence()"}, "2014": {"callee_method_names": ["AxisAngle4d.set", "List<Quat4d>.get"], "method_name": "SphereSampler.getAxisAngle", "method_implementation": "{\n    axisAngle.set(orientations.get(index));\n}", "repo_id": "9", "comment": "/**\n * @param index Index between 0 and {@link #getSphereCount()}-1\n * @param axisAngle (Output) modified to contain the index-th sampled orientation\n */\n", "repo_name": "biojava-master/", "id": 2014, "method_signature": "void getAxisAngle(int, AxisAngle4d)"}, "2227": {"callee_method_ids": [1322], "callee_method_names": ["FileParsingParameters.setAlignSeqRes", "Structure.isCrystallographic", "Structure.getChains", "Structure.getEntityInfos", "Structure.getEntityInfos", "Structure.getPolyChains"], "method_name": "TestNonDepositedFiles.testPhenixCifFile", "method_implementation": "{\n    InputStream inStream = new GZIPInputStream(this.getClass().getResourceAsStream(\"/org/biojava/nbio/structure/io/4lup_phenix_output.cif.gz\"));\n    FileParsingParameters fileParsingParams = new FileParsingParameters();\n    fileParsingParams.setAlignSeqRes(true);\n    Structure s = CifStructureConverter.fromInputStream(inStream, fileParsingParams);\n    assertNotNull(s);\n    assertTrue(s.isCrystallographic());\n    // all ligands are into their own chains, so we have 2 proteins, 2 nucleotide chains, 1 ligand chain and 1 purely water chain\n    assertEquals(6, s.getChains().size());\n    // 4 entities: 1 protein, 1 nucleotide, 1 water, 1 ligand (EDO)\n    assertEquals(4, s.getEntityInfos().size());\n    int[] counts = countEntityTypes(s.getEntityInfos());\n    assertEquals(2, counts[0]);\n    assertEquals(1, counts[1]);\n    assertEquals(1, counts[2]);\n    // we should have seqres groups (testing getSeqResSequence() is equivalent)\n    assertFalse(s.getPolyChains().get(0).getSeqResSequence().isEmpty());\n}", "repo_id": "9", "comment": "/**\n * A test for reading a phenix-produced (ver 1.9_1692) mmCIF file.\n * This is the file submitted to the PDB for deposition of entry 4lup\n * See github issue #234\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2227, "method_signature": "void testPhenixCifFile()"}, "473": {"callee_method_ids": [465, 1400], "callee_method_names": ["StructureName.getPdbId", "PdbId.getId"], "method_name": "PdbPair.getPDBCode2", "method_implementation": "{\n    PdbId pdbId = name2.getPdbId();\n    return pdbId == null ? null : pdbId.getId();\n}", "repo_id": "9", "comment": "/**\n * @deprecated use {@link #getPDBCode2()} instead\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 473, "method_signature": "String getPDBCode2()"}, "68": {"callee_method_names": ["GapPenalty.getType", "List<Subproblem>.size", "ArrayList.size", "List<Subproblem>.size", "List<Subproblem>.get", "Subproblem.getQueryStartIndex", "Subproblem.getQueryEndIndex", "GapPenalty.getExtensionPenalty", "GapPenalty.getOpenPenalty", "GapPenalty.getExtensionPenalty", "GapPenalty.getExtensionPenalty", "GapPenalty.getOpenPenalty", "GapPenalty.getExtensionPenalty"], "method_name": "AbstractMatrixAligner.align", "method_implementation": "{\n    if (!isReady()) {\n        return;\n    }\n    long timeStart = System.nanoTime();\n    int[] dim = getScoreMatrixDimensions();\n    if (storingScoreMatrix) {\n        scores = new int[dim[0]][dim[1]][dim[2]];\n    } else {\n        scores = new int[dim[0]][][];\n        scores[0] = new int[dim[1]][dim[2]];\n        scores[1] = new int[dim[1]][dim[2]];\n    }\n    boolean linear = (gapPenalty.getType() == GapPenalty.Type.LINEAR);\n    Last[][][] traceback = new Last[dim[0]][][];\n    List<Step> sx = new ArrayList<Step>(), sy = new ArrayList<Step>();\n    if (!local) {\n        xyMax = new int[] { dim[0] - 1, dim[1] - 1 };\n        xyStart = new int[] { 0, 0 };\n        score = 0;\n        List<Subproblem> problems = Subproblem.getSubproblems(anchors, xyMax[0], xyMax[1]);\n        assert problems.size() == anchors.size() + 1;\n        for (int i = 0; i < problems.size(); i++) {\n            Subproblem subproblem = problems.get(i);\n            for (int x = subproblem.getQueryStartIndex(); x <= subproblem.getQueryEndIndex(); x++) {\n                traceback[x] = linear ? setScoreVector(x, subproblem, gapPenalty.getExtensionPenalty(), getSubstitutionScoreVector(x, subproblem), storingScoreMatrix, scores) : setScoreVector(x, subproblem, gapPenalty.getOpenPenalty(), gapPenalty.getExtensionPenalty(), getSubstitutionScoreVector(x, subproblem), storingScoreMatrix, scores);\n            }\n        }\n        setSteps(traceback, scores, sx, sy);\n        score = Integer.MIN_VALUE;\n        int[] finalScore = scores[xyMax[0]][xyMax[1]];\n        for (int z = 0; z < finalScore.length; z++) {\n            score = Math.max(score, finalScore[z]);\n        }\n    } else {\n        for (int x = 0; x < dim[0]; x++) {\n            traceback[x] = linear ? setScoreVector(x, gapPenalty.getExtensionPenalty(), getSubstitutionScoreVector(x), storingScoreMatrix, scores, xyMax, score) : setScoreVector(x, gapPenalty.getOpenPenalty(), gapPenalty.getExtensionPenalty(), getSubstitutionScoreVector(x), storingScoreMatrix, scores, xyMax, score);\n            if (xyMax[0] == x) {\n                score = scores[x][xyMax[1]][0];\n            }\n        }\n        xyStart = local ? setSteps(traceback, xyMax, sx, sy) : setSteps(traceback, scores, sx, sy);\n    }\n    setProfile(sx, sy);\n    if (!storingScoreMatrix) {\n        scores = null;\n    }\n    time = System.nanoTime() - timeStart;\n}", "repo_id": "9", "comment": "/**\n * Performs alignment\n */\n", "repo_name": "biojava-master/", "id": 68, "method_signature": "void align()"}, "3853": {"callee_method_names": ["HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put"], "method_name": "Constraints.initPKaInnovagen", "method_implementation": "{\n    /*\n\t\t * A.Lehninger, Principles of Biochemistry, 4th Edition (2005), Chapter 3, page78, Table 3-1.\n\t\t */\n    //(NH2-)\t9.69\t(-COOH)\t2.34\n    aa2CTerminalPka.put(G, 2.34);\n    aa2CTerminalPka.put(A, 2.34);\n    aa2CTerminalPka.put(P, 1.99);\n    aa2CTerminalPka.put(V, 2.32);\n    aa2CTerminalPka.put(L, 2.36);\n    aa2CTerminalPka.put(I, 2.36);\n    aa2CTerminalPka.put(M, 2.28);\n    aa2CTerminalPka.put(F, 1.83);\n    aa2CTerminalPka.put(Y, 2.20);\n    aa2CTerminalPka.put(W, 2.38);\n    aa2CTerminalPka.put(S, 2.21);\n    aa2CTerminalPka.put(T, 2.11);\n    aa2CTerminalPka.put(C, 1.96);\n    aa2CTerminalPka.put(N, 2.02);\n    aa2CTerminalPka.put(Q, 2.17);\n    aa2CTerminalPka.put(K, 2.18);\n    aa2CTerminalPka.put(H, 1.82);\n    aa2CTerminalPka.put(R, 2.17);\n    aa2CTerminalPka.put(D, 1.88);\n    aa2CTerminalPka.put(E, 2.19);\n    aa2NTerminalPka.put(G, 9.60);\n    aa2NTerminalPka.put(A, 9.69);\n    aa2NTerminalPka.put(P, 10.96);\n    aa2NTerminalPka.put(V, 9.62);\n    aa2NTerminalPka.put(L, 9.60);\n    aa2NTerminalPka.put(I, 9.68);\n    aa2NTerminalPka.put(M, 9.21);\n    aa2NTerminalPka.put(F, 9.13);\n    aa2NTerminalPka.put(Y, 9.11);\n    aa2NTerminalPka.put(W, 9.39);\n    aa2NTerminalPka.put(S, 9.15);\n    aa2NTerminalPka.put(T, 9.62);\n    aa2NTerminalPka.put(C, 10.28);\n    aa2NTerminalPka.put(N, 8.80);\n    aa2NTerminalPka.put(Q, 9.13);\n    aa2NTerminalPka.put(K, 8.95);\n    aa2NTerminalPka.put(H, 9.17);\n    aa2NTerminalPka.put(R, 9.04);\n    aa2NTerminalPka.put(D, 9.60);\n    aa2NTerminalPka.put(E, 9.67);\n    //\t\tK, Lys\t10.53\n    aa2PKa.put(K, 10.53);\n    //\t\tD, Asp\t3.65\n    aa2PKa.put(D, 3.65);\n    //\t\tR, Arg\t12.48\n    aa2PKa.put(R, 12.48);\n    //\t\tE, Glu\t4.25\n    aa2PKa.put(E, 4.25);\n    //\t\tH, His\t6.00\n    aa2PKa.put(H, 6.00);\n    //\t\tC, Cys\t8.18\n    aa2PKa.put(C, 8.18);\n    //\t\tY, Tyr\t10.07\n    aa2PKa.put(Y, 10.07);\n}", "repo_id": "9", "comment": "/**\n * Does the initialization of PKa based on\n * http://www.innovagen.se/custom-peptide-synthesis/peptide-property-calculator/peptide-property-calculator-notes.asp#NetCharge\n */\n", "repo_name": "biojava-master/", "id": 3853, "method_signature": "void initPKaInnovagen()"}, "231": {"callee_method_names": [], "method_name": "ProteinModificationImpl.build", "method_implementation": "{\n    return new ProteinModificationImpl(this);\n}", "repo_id": "9", "comment": "/**\n * @return build ProteinModification.\n */\n", "repo_name": "biojava-master/", "id": 231, "method_signature": "ProteinModificationImpl build()"}, "2266": {"callee_method_names": ["ClassLoader.getResource", "Structure.getPDBCode", "Structure.getChains"], "method_name": "TestMmtfStructureWriter.testRead", "method_implementation": "{\n    ClassLoader classLoader = getClass().getClassLoader();\n    Structure structure = MmtfActions.readFromFile(new File(classLoader.getResource(\"org/biojava/nbio/structure/io/mmtf/4CUP.mmtf\").getPath()).toPath());\n    assertEquals(structure.getPDBCode(), \"4CUP\");\n    assertEquals(structure.getChains().size(), 6);\n}", "repo_id": "9", "comment": "/**\n * Test that Biojava can read a file from the file system.\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2266, "method_signature": "void testRead()"}, "3310": {"callee_method_names": ["Logger.warn"], "method_name": "BrowserOpener.showDocument", "method_implementation": "{\n    try {\n        URL url = new URL(urlstring);\n        return showDocument(url);\n    } catch (MalformedURLException e) {\n        logger.warn(\"malformed URL {}\", urlstring, e);\n        return false;\n    }\n}", "repo_id": "9", "comment": "/**\n * open a URL in the browser that was used to launch SPICE\n *\n * @param urlstring string represntation of URL to be opened\n * @return true if this was successfull\n */\n", "repo_name": "biojava-master/", "id": 3310, "method_signature": "boolean showDocument(String)"}, "3332": {"callee_method_names": ["SequenceScalePanel.setScale", "SequenceScalePanel.setScale", "SequenceScalePanel.repaint", "SequenceScalePanel.repaint"], "method_name": "SequenceDisplay.calcScale", "method_implementation": "{\n    float s = getScaleForZoom(zoomFactor);\n    scale = s;\n    //logger.info(\"calc scale zoom:\"+zoomFactor+ \" s: \" + s);\n    panel1.setScale(s);\n    panel2.setScale(s);\n    panel1.repaint();\n    panel2.repaint();\n    //return scale;\n}", "repo_id": "9", "comment": "/**\n * a value of 100 means that the whole sequence should be displayed in the current visible window\n * a factor of 1 means that one amino acid shoud be drawn as big as possible\n *\n * @param zoomFactor - a value between 1 and 100\n */\n", "repo_name": "biojava-master/", "id": 3332, "method_signature": "void calcScale(int)"}, "1662": {"callee_method_names": ["ArrayList.size"], "method_name": "SubunitCluster.size", "method_implementation": "{\n    return subunits.size();\n}", "repo_id": "9", "comment": "/**\n * @return the number of Subunits in the cluster\n */\n", "repo_name": "biojava-master/", "id": 1662, "method_signature": "int size()"}, "834": {"callee_method_names": [], "method_name": "AsaCalculator.generateSpherePoints", "method_implementation": "{\n    Vector3d[] points = new Vector3d[nSpherePoints];\n    double inc = Math.PI * (3.0 - Math.sqrt(5.0));\n    double offset = 2.0 / nSpherePoints;\n    for (int k = 0; k < nSpherePoints; k++) {\n        double y = k * offset - 1.0 + (offset / 2.0);\n        double r = Math.sqrt(1.0 - y * y);\n        double phi = k * inc;\n        points[k] = new Vector3d(Math.cos(phi) * r, y, Math.sin(phi) * r);\n    }\n    return points;\n}", "repo_id": "9", "comment": "/**\n * Returns list of 3d coordinates of points on a unit sphere using the\n * Golden Section Spiral algorithm.\n * @param nSpherePoints the number of points to be used in generating the spherical dot-density\n * @return the array of points as Vector3d objects\n */\n", "repo_name": "biojava-master/", "id": 834, "method_signature": "Vector3d[] generateSpherePoints(int)"}, "3587": {"callee_method_names": [], "method_name": "Matrix.multiply", "method_implementation": "{\n    int m = A.length;\n    int n = A[0].length;\n    if (x.length != m) {\n        throw new RuntimeException(\"Illegal matrix dimensions.\");\n    }\n    double[] y = new double[n];\n    for (int j = 0; j < n; j++) {\n        for (int i = 0; i < m; i++) {\n            y[j] += (A[i][j] * x[i]);\n        }\n    }\n    return y;\n}", "repo_id": "9", "comment": "/**\n * @param x\n * @param A\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3587, "method_signature": "double[] multiply(double[], double[][])"}, "1446": {"callee_method_names": ["SpaceGroupMapRoot.getMapProperty"], "method_name": "SymoplibParser.parseSpaceGroupsXML", "method_implementation": "{\n    String xml = convertStreamToString(spaceGroupIS);\n    SpaceGroupMapRoot spaceGroups = SpaceGroupMapRoot.fromXML(xml);\n    return spaceGroups.getMapProperty();\n}", "repo_id": "9", "comment": "/**\n * Load all SpaceGroup information from the file spacegroups.xml\n *\n * @return a map providing information for all spacegroups\n */\n", "repo_name": "biojava-master/", "id": 1446, "method_signature": "TreeMap<Integer,SpaceGroup> parseSpaceGroupsXML(InputStream)"}, "871": {"callee_method_names": [], "method_name": "StructureInterfaceCluster.getAverageScore", "method_implementation": "{\n    return averageScore;\n}", "repo_id": "9", "comment": "/**\n * Returns the average similarity score between all pairs of members in the cluster\n * @return\n */\n", "repo_name": "biojava-master/", "id": 871, "method_signature": "double getAverageScore()"}, "2918": {"callee_method_names": [], "method_name": "AbstractSequence.setNotesList", "method_implementation": "{\n    this.notesList = notesList;\n}", "repo_id": "9", "comment": "/**\n * @param notesList the notesList to set\n */\n", "repo_name": "biojava-master/", "id": 2918, "method_signature": "void setNotesList(ArrayList)"}, "1342": {"callee_method_names": ["Set<String>.add"], "method_name": "EntityInfo.getChainIds", "method_implementation": "{\n    Set<String> uniqChainIds = new TreeSet<>();\n    for (int i = 0; i < getChains().size(); i++) {\n        uniqChainIds.add(getChains().get(i).getId());\n    }\n    return new ArrayList<>(uniqChainIds);\n}", "repo_id": "9", "comment": "/**\n * Return the list of member chain ids (asym ids) that are described by this EntityInfo,\n * only unique chain IDs are contained in the list.\n * Note that in the case of multimodel structures this will return just the unique\n * chain identifiers whilst {@link #getChains()} will return a corresponding chain\n * per model.\n * @return the list of unique ChainIDs that are described by this EnityInfo\n * @see #setChains(List)\n * @see #getChains()\n */\n", "repo_name": "biojava-master/", "id": 1342, "method_signature": "List<String> getChainIds()"}, "1301": {"callee_method_names": ["Logger.error"], "method_name": "EntityFinder.getProteinSequence", "method_implementation": "{\n    try {\n        ProteinSequence s = new ProteinSequence(str);\n        return s;\n    } catch (CompoundNotFoundException e) {\n        logger.error(\"Unexpected error when creating ProteinSequence\", e);\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Returns the ProteinSequence or null if one can't be created\n * @param str\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1301, "method_signature": "ProteinSequence getProteinSequence(String)"}, "3492": {"callee_method_names": ["String.split"], "method_name": "NCBIQBlastAlignmentProperties.getBlastGapExtension", "method_implementation": "{\n    String gapCosts = getAlignmentOption(GAPCOSTS);\n    try {\n        String gapExtension = gapCosts.split(\"\\\\+\")[1];\n        return Integer.parseInt(gapExtension);\n    } catch (Exception e) {\n        return -1;\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the value for the gap extension parameter (second half of GAPCOSTS parameter)\n *\n * @return an integer for the value for gap extension used by this search, -1 if not set or not a number\n */\n", "repo_name": "biojava-master/", "id": 3492, "method_signature": "int getBlastGapExtension()"}, "3039": {"callee_method_names": ["LocationPredicate.accept"], "method_name": "Tools.scanLocations", "method_implementation": "{\n    Location location = null;\n    for (Location l : locations) {\n        if (location == null) {\n            location = l;\n        } else {\n            if (predicate.accept(location, l)) {\n                location = l;\n            }\n        }\n    }\n    return location;\n}", "repo_id": "9", "comment": "/**\n * Used for scanning through a list of locations; assumes the\n * locations given will have at least one value otherwise\n * we will get a null pointer\n */\n", "repo_name": "biojava-master/", "id": 3039, "method_signature": "Location scanLocations(List, LocationPredicate)"}, "2511": {"callee_method_names": ["ScaledSubstitutionMatrix.setMatrix", "ScaledSubstitutionMatrix.setMax", "ScaledSubstitutionMatrix.setMin", "ScaledSubstitutionMatrix.setCols", "ScaledSubstitutionMatrix.setRows", "ScaledSubstitutionMatrix.setScale", "Map<String, SubstitutionMatrix<AminoAcidCompound>>.put", "ScaledSubstitutionMatrix.getName"], "method_name": "AAIndexFileParser.finalizeMatrix", "method_implementation": "{\n    currentMatrix.setMatrix(matrix);\n    currentMatrix.setMax(max);\n    currentMatrix.setMin(min);\n    currentMatrix.setCols(cols);\n    currentMatrix.setRows(rows);\n    currentMatrix.setScale(scale);\n    matrices.put(currentMatrix.getName(), currentMatrix);\n    return currentMatrix;\n}", "repo_id": "9", "comment": "//\n", "repo_name": "biojava-master/", "id": 2511, "method_signature": "SubstitutionMatrix<AminoAcidCompound> finalizeMatrix()"}, "1489": {"callee_method_names": [], "method_name": "CalcPoint.clonePoint3dArray", "method_implementation": "{\n    Point3d[] clone = new Point3d[x.length];\n    for (int i = 0; i < x.length; i++) {\n        clone[i] = new Point3d(x[i]);\n    }\n    return clone;\n}", "repo_id": "9", "comment": "/**\n * Clone an array of points.\n *\n * @param x\n *            original array of points. Point objects will not be modified\n * @return new array of points, identical clone of x\n */\n", "repo_name": "biojava-master/", "id": 1489, "method_signature": "Point3d[] clonePoint3dArray(Point3d[])"}, "1421": {"callee_method_names": [], "method_name": "UnitCellBoundingBox.getChainBoundingBox", "method_implementation": "{\n    return chainBbs[cellIdx][chainIdx];\n}", "repo_id": "9", "comment": "/**\n * Get the chain BoundingBox for the given cell index (cellIdx=0 would be original AU)\n * and chain index\n * @param cellIdx\n * @param chainIdx\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1421, "method_signature": "BoundingBox getChainBoundingBox(int, int)"}, "2199": {"callee_method_names": [], "method_name": "PDBStatusTest.testGetStatus", "method_implementation": "{\n    Assert.assertEquals(Status.REMOVED, PDBStatus.getStatus(\"1HHB\"));\n    Assert.assertEquals(Status.CURRENT, PDBStatus.getStatus(\"3HHB\"));\n    Assert.assertEquals(Status.CURRENT, PDBStatus.getStatus(\"4HHB\"));\n}", "repo_id": "9", "comment": "/**\n *  Test {@link PDBStatus#getStatus(String)}.\n *\n *  <p>Uses the following PDBs:<br/>\n *  <pre>1HHB    OBSOLETE\treplacedBy=4HHB\n * 4HHB    CURRENT\treplaces=1HHB\n * 3HHB    CURRENT\treplaces=1HHB\n * </pre>\n */\n", "repo_name": "biojava-master/", "id": 2199, "method_signature": "void testGetStatus()"}, "672": {"callee_method_names": ["MultipleAlignment.size", "StringWriter.append", "StringWriter.append", "MultipleAlignment.getEnsemble", "StringWriter.append", "MultipleAlignment.size", "StringWriter.append", "StringWriter.append", "MultipleAlignment.getBlocks", "String.length", "MultipleAlignment.size", "String.getAlignRes", "StringWriter.append", "StringWriter.append", "StringWriter.append", "StringWriter.append", "StringWriter.append", "StringWriter.append", "MultipleAlignment.getAtomArrays", "StringWriter.append", "Atom.getGroup", "StringWriter.append", "StringWriter.append", "Atom.getGroup", "StringWriter.append", "StringWriter.append", "Atom.getGroup", "StringWriter.append", "StringWriter.append", "StringWriter.toString"], "method_name": "MultipleAlignmentWriter.toAlignedResidues", "method_implementation": "{\n    StringWriter residueGroup = new StringWriter();\n    // Write structure names & PDB codes\n    for (int str = 0; str < multAln.size(); str++) {\n        residueGroup.append(\"#Struct\" + (str + 1) + \":\\t\");\n        residueGroup.append(multAln.getEnsemble().getStructureIdentifiers().get(str).getIdentifier());\n        residueGroup.append(\"\\n\");\n    }\n    // Whrite header for columns\n    for (int str = 0; str < multAln.size(); str++) residueGroup.append(\"#Num\" + (str + 1) + \"\\tChain\" + (str + 1) + \"\\tAA\" + (str + 1) + \"\\t\");\n    residueGroup.append(\"\\n\");\n    // Write optimally aligned pairs\n    for (Block b : multAln.getBlocks()) {\n        for (int res = 0; res < b.length(); res++) {\n            for (int str = 0; str < multAln.size(); str++) {\n                Integer residue = b.getAlignRes().get(str).get(res);\n                if (residue == null) {\n                    residueGroup.append(\"-\");\n                    residueGroup.append('\\t');\n                    residueGroup.append(\"-\");\n                    residueGroup.append('\\t');\n                    residueGroup.append(\"-\");\n                    residueGroup.append('\\t');\n                } else {\n                    Atom atom = multAln.getAtomArrays().get(str)[residue];\n                    residueGroup.append(atom.getGroup().getResidueNumber().toString());\n                    residueGroup.append('\\t');\n                    residueGroup.append(atom.getGroup().getChain().// ABradley - I'm assuming Auth Id's here 04/05/16\n                    getName());\n                    residueGroup.append('\\t');\n                    residueGroup.append(atom.getGroup().getPDBName());\n                    residueGroup.append('\\t');\n                }\n            }\n            residueGroup.append('\\n');\n        }\n    }\n    return residueGroup.toString();\n}", "repo_id": "9", "comment": "/**\n * Converts the alignment to its simplest form: a list of groups of aligned\n * residues. Format is one line per residue group, tab delimited:\n * <ul>\n * <li>PDB number (includes insertion code)\n * <li>Chain\n * <li>Amino Acid (three letter code)</li>\n * </ul>\n * Example: <code>52\tA\tALA\t102\tA\tVAL\t154\tA\tTHR</code>\n * <p>\n * Note that this format loses information about blocks.\n *\n * @param multAln\n *            MultipleAlignment object\n * @return a String representation of the aligned residues.\n */\n", "repo_name": "biojava-master/", "id": 672, "method_signature": "String toAlignedResidues(MultipleAlignment)"}, "32": {"callee_method_names": ["Set<DatabaseReference>.add"], "method_name": "StockholmFileAnnotation.addDBReference", "method_implementation": "{\n    if (this.dbReferences == null) {\n        this.dbReferences = new HashSet<DatabaseReference>();\n    }\n    dbReferences.add(new DatabaseReference(dbReferenceRepresentingString));\n}", "repo_id": "9", "comment": "/**\n * @param dbReference the string without the initial annotation identifier ( #=GS DR )\n */\n", "repo_name": "biojava-master/", "id": 32, "method_signature": "void addDBReference(String)"}, "428": {"callee_method_ids": [484], "callee_method_names": ["AFPChain.getAfpSet", "AFPChain.setAfpIndex", "AFPChain.setAfpAftIndex", "AFPChain.setAfpBefIndex", "AFPChain.getAfpIndex", "AFPChain.getAfpAftIndex", "AFPChain.getAfpBefIndex", "List<AFP>.size", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get"], "method_name": "AFPCalculator.sortAfps", "method_implementation": "{\n    List<AFP> afpSet = afpChain.getAfpSet();\n    if (debug)\n        System.err.println(\"entering sortAfps\");\n    int pro1Len = ca1.length;\n    int pro2Len = ca2.length;\n    //the index of (i,j) pair in AFP list, otherwise -1\n    afpChain.setAfpIndex(new int[pro1Len][pro2Len]);\n    //the index of AFP (i,j*) nearest to (i,j), j*<j. if a AFP exits for (i,j), it equals to afpIndex\n    afpChain.setAfpAftIndex(new int[pro1Len][pro2Len]);\n    //the index of AFP (i,j*) nearest to (i,j), j*>j. if a AFP exits for (i,j), it equals to afpIndex\n    afpChain.setAfpBefIndex(new int[pro1Len][pro2Len]);\n    int[][] afpIndex = afpChain.getAfpIndex();\n    int[][] afpAftIndex = afpChain.getAfpAftIndex();\n    int[][] afpBefIndex = afpChain.getAfpBefIndex();\n    for (int i = 0; i < pro1Len; i++) {\n        for (int j = 0; j < pro2Len; j++) {\n            afpIndex[i][j] = afpAftIndex[i][j] = afpBefIndex[i][j] = -1;\n        }\n    }\n    //index the AFP for easy extraction of compatible AFPs\n    int afpNum = afpSet.size();\n    int b0 = 0;\n    for (int a = 0; a < afpNum; a++) {\n        if (a == afpNum - 1 || afpSet.get(a).getP1() != afpSet.get(a + 1).getP1()) {\n            int i = afpSet.get(a).getP1();\n            for (int b = b0; b <= a; b++) {\n                int j = afpSet.get(b).getP2();\n                afpIndex[i][j] = b;\n                afpBefIndex[i][j] = b;\n                afpAftIndex[i][j] = b;\n                if (afpSet.get(b).getP1() != i) {\n                    System.err.println(String.format(\"Warning: wrong afp index %d %d\\n\", i, afpSet.get(b).getP1()));\n                    return;\n                }\n            }\n            for (int k = 1; k < pro2Len; k++) {\n                if (afpBefIndex[i][k] == -1) {\n                    afpBefIndex[i][k] = afpBefIndex[i][k - 1];\n                }\n            }\n            for (int k = pro2Len - 2; k >= 0; k--) {\n                if (afpAftIndex[i][k] == -1) {\n                    afpAftIndex[i][k] = afpAftIndex[i][k + 1];\n                }\n            }\n            b0 = a + 1;\n        }\n    }\n    if (debug)\n        System.err.println(\"done sortAfps\");\n}", "repo_id": "9", "comment": "//------------------------------------------------------------------\n", "repo_name": "biojava-master/", "id": 428, "method_signature": "void sortAfps(AFPChain, Atom[], Atom[])"}, "894": {"callee_method_names": ["Logger.warn", "Atom[].getGroup", "Atom[].getGroup"], "method_name": "StructureInterface.getParentChains", "method_implementation": "{\n    Atom[] firstMol = this.molecules.getFirst();\n    Atom[] secondMol = this.molecules.getSecond();\n    if (firstMol.length == 0 || secondMol.length == 0) {\n        logger.warn(\"No atoms found in first or second molecule, can't get parent Chains\");\n        return null;\n    }\n    return new Pair<>(firstMol[0].getGroup().getChain(), secondMol[0].getGroup().getChain());\n}", "repo_id": "9", "comment": "/**\n * Finds the parent chains by looking up the references of first atom of each side of this interface\n * @return\n */\n", "repo_name": "biojava-master/", "id": 894, "method_signature": "Pair<Chain> getParentChains()"}, "2526": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum60", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum60\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 60 matrix by Henikoff & Henikoff\n * @return Blosum 60 matrix\n */\n", "repo_name": "biojava-master/", "id": 2526, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum60()"}, "1278": {"callee_method_names": [], "method_name": "MmtfSummaryDataBean.setAllChains", "method_implementation": "{\n    this.allChains = allChains;\n}", "repo_id": "9", "comment": "/**\n * @param allChains the list of chains (in all models) in the structure\n */\n", "repo_name": "biojava-master/", "id": 1278, "method_signature": "void setAllChains(List)"}, "384": {"callee_method_names": [], "method_name": "Calc.centerAtoms", "method_implementation": "{\n    Atom shiftVector = getCenterVector(atomSet, centroid);\n    Atom[] newAtoms = new AtomImpl[atomSet.length];\n    for (int i = 0; i < atomSet.length; i++) {\n        Atom a = atomSet[i];\n        Atom n = add(a, shiftVector);\n        newAtoms[i] = n;\n    }\n    return newAtoms;\n}", "repo_id": "9", "comment": "/**\n * Center the atoms at the Centroid, if the centroid is already know.\n *\n * @param atomSet\n *            a set of Atoms\n * @return an Atom representing the Centroid of the set of atoms\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 384, "method_signature": "Atom[] centerAtoms(Atom[], Atom)"}, "581": {"callee_method_names": ["Map<S,T>.keySet", "List<S>.size", "List<S>.get", "Map<S,T>.get", "Map<T,S>.get", "List<S>.set", "Map<S,T>.size", "List<S>.size", "List<S>.get", "List<S>.get", "Map<S,T>.get", "Map<S, T>.put"], "method_name": "AlignmentTools.applyAlignment", "method_implementation": "{\n    // This implementation simply applies the map k times.\n    // If k were large, it would be more efficient to do this recursively,\n    // (eg f^4 = (f^2)^2) but k will usually be small.\n    if (k < 0)\n        throw new IllegalArgumentException(\"k must be positive\");\n    if (k == 1) {\n        return new HashMap<S, T>(alignmentMap);\n    }\n    // Convert to lists to establish a fixed order\n    // currently unmodified\n    List<S> preimage = new ArrayList<S>(alignmentMap.keySet());\n    List<S> image = new ArrayList<S>(preimage);\n    for (int n = 1; n < k; n++) {\n        // apply alignment\n        for (int i = 0; i < image.size(); i++) {\n            S pre = image.get(i);\n            T intermediate = (pre == null ? null : alignmentMap.get(pre));\n            S post = (intermediate == null ? null : identity.get(intermediate));\n            image.set(i, post);\n        }\n    }\n    Map<S, T> imageMap = new HashMap<S, T>(alignmentMap.size());\n    //TODO handle nulls consistently.\n    // assure that all the residues in the domain are valid keys\n    /*\n\t\tfor(int i=0;i<preimage.size();i++) {\n\t\t\tS pre = preimage.get(i);\n\t\t\tT intermediate = (pre==null?null: alignmentMap.get(pre));\n\t\t\tS post = (intermediate==null?null: identity.get(intermediate));\n\t\t\timageMap.put(post, null);\n\t\t}\n\t\t */\n    // now populate with actual values\n    for (int i = 0; i < preimage.size(); i++) {\n        S pre = preimage.get(i);\n        // image is currently f^k-1(x), so take the final step\n        S preK1 = image.get(i);\n        T postK = (preK1 == null ? null : alignmentMap.get(preK1));\n        imageMap.put(pre, postK);\n    }\n    return imageMap;\n}", "repo_id": "9", "comment": "/**\n * Applies an alignment k times. Eg if alignmentMap defines function f(x),\n * this returns a function f^k(x)=f(f(...f(x)...)).\n *\n * To allow for functions with different domains and codomains, the identity\n * function allows converting back in a reasonable way. For instance, if\n * alignmentMap represented an alignment between two proteins with different\n * numbering schemes, the identity function could calculate the offset\n * between residue numbers, eg I(x) = x-offset.\n *\n * When an identity function is provided, the returned function calculates\n * f^k(x) = f(I( f(I( ... f(x) ... )) )).\n *\n * @param <S>\n * @param <T>\n * @param alignmentMap The input function, as a map (see {@link AlignmentTools#alignmentAsMap(AFPChain)})\n * @param identity An identity-like function providing the isomorphism between\n *  the codomain of alignmentMap (of type <T>) and the domain (type <S>).\n * @param k The number of times to apply the alignment\n * @return A new alignment. If the input function is not automorphic\n *  (one-to-one), then some inputs may map to null, indicating that the\n *  function is undefined for that input.\n */\n", "repo_name": "biojava-master/", "id": 581, "method_signature": "Map<S,T> applyAlignment(Map, Map, int)"}, "2651": {"callee_method_names": [], "method_name": "TranscriptionEngine.build", "method_implementation": "{\n    return new TranscriptionEngine(getTable(), getRnaAminoAcidTranslator(), getDnaRnaTranslator(), getProteinCreator(), getRnaCreator(), getDnaCompounds(), getRnaCompounds(), getAminoAcidCompounds());\n}", "repo_id": "9", "comment": "/**\n * The method to finish any calls to the builder with which returns a\n * transcription engine. The engine is designed to provide everything\n * required for transcription to those classes which will do the\n * transcription.\n */\n", "repo_name": "biojava-master/", "id": 2651, "method_signature": "TranscriptionEngine build()"}, "52": {"callee_method_names": ["List<PairwiseSequenceAligner<S,C>>.size", "List<Future<SequencePair<S, C>>>.add"], "method_name": "Alignments.runPairwiseAligners", "method_implementation": "{\n    int n = 1, all = aligners.size();\n    List<Future<SequencePair<S, C>>> futures = new ArrayList<Future<SequencePair<S, C>>>();\n    for (PairwiseSequenceAligner<S, C> aligner : aligners) {\n        futures.add(ConcurrencyTools.submit(new CallablePairwiseSequenceAligner<S, C>(aligner), String.format(\"Aligning pair %d of %d\", n++, all)));\n    }\n    return getListFromFutures(futures);\n}", "repo_id": "9", "comment": "/**\n * Factory method to run a list of alignments concurrently.  This method runs the alignments in parallel by\n * submitting all of the alignment tasks to the shared thread pool of the {@link ConcurrencyTools} utility.\n *\n * @param <S> each {@link Sequence} of an alignment pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param aligners list of alignments to run\n * @return list of {@link SequencePair} results from running alignments\n */\n", "repo_name": "biojava-master/", "id": 52, "method_signature": "List<SequencePair<S,C>> runPairwiseAligners(List)"}, "2368": {"callee_method_ids": [2373, 2372, 2372], "callee_method_names": ["Fastq.getVariant", "Fastq.getQuality", "Fastq.getQuality", "StringBuilder.append", "FastqVariant.quality", "FastqVariant.qualityScore", "StringBuilder.toString"], "method_name": "FastqTools.convertQualities", "method_implementation": "{\n    if (fastq == null) {\n        throw new IllegalArgumentException(\"fastq must not be null\");\n    }\n    if (variant == null) {\n        throw new IllegalArgumentException(\"variant must not be null\");\n    }\n    if (fastq.getVariant().equals(variant)) {\n        return fastq.getQuality();\n    }\n    int size = fastq.getQuality().length();\n    double[] errorProbabilities = errorProbabilities(fastq, new double[size]);\n    StringBuilder sb = new StringBuilder(size);\n    for (int i = 0; i < size; i++) {\n        sb.append(variant.quality(variant.qualityScore(errorProbabilities[i])));\n    }\n    return sb.toString();\n}", "repo_id": "9", "comment": "/**\n * Convert the qualities in the specified FASTQ formatted sequence to the\n * specified FASTQ sequence format variant.\n *\n * @since 4.2\n * @param fastq FASTQ formatted sequence, must not be null\n * @param variant FASTQ sequence format variant, must not be null\n * @return the qualities in the specified FASTQ formatted sequence converted to the\n *    specified FASTQ sequence format variant\n */\n", "repo_name": "biojava-master/", "id": 2368, "method_signature": "String convertQualities(Fastq, FastqVariant)"}, "3122": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getInverse", "method_implementation": "{\n    return SequenceMixin.inverse(this);\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3122, "method_signature": "SequenceView<C> getInverse()"}, "353": {"callee_method_names": [], "method_name": "Calc.torsionAngle", "method_implementation": "{\n    Atom ab = subtract(a, b);\n    Atom cb = subtract(c, b);\n    Atom bc = subtract(b, c);\n    Atom dc = subtract(d, c);\n    Atom abc = vectorProduct(ab, cb);\n    Atom bcd = vectorProduct(bc, dc);\n    double angl = angle(abc, bcd);\n    /* calc the sign: */\n    Atom vecprod = vectorProduct(abc, bcd);\n    double val = scalarProduct(cb, vecprod);\n    if (val < 0.0)\n        angl = -angl;\n    return angl;\n}", "repo_id": "9", "comment": "/**\n * Calculate the torsion angle, i.e. the angle between the normal vectors of\n * the two plains a-b-c and b-c-d. See\n * http://en.wikipedia.org/wiki/Dihedral_angle\n *\n * @param a\n *            an Atom object\n * @param b\n *            an Atom object\n * @param c\n *            an Atom object\n * @param d\n *            an Atom object\n * @return the torsion angle in degrees, in range +-[0,180]. If either first\n *         3 or last 3 atoms are colinear then torsion angle is not defined\n *         and NaN is returned\n */\n", "repo_name": "biojava-master/", "id": 353, "method_signature": "double torsionAngle(Atom, Atom, Atom, Atom)"}, "465": {"callee_method_names": [], "method_name": "StructureName.getPdbId", "method_implementation": "{\n    if (pdbId == null) {\n        pdbId = toCanonical().getPdbId();\n    }\n    return pdbId;\n}", "repo_id": "9", "comment": "/**\n * Get the PDB ID for this name, if any.\n *\n * Equivalent to {@link SubstructureIdentifier#getPdbId()\n * toCanonical().getPdbId()}\n * @return The upper-case PDB Name, or null if not applicable\n * @throws StructureException Wraps errors which occur when converting to canonical form\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 465, "method_signature": "PdbId getPdbId()"}, "1996": {"callee_method_names": ["RotationGroup.getPointGroup", "QuatSymmetrySubunits.getOriginalCenters", "Vector3d.sub", "QuatSymmetrySubunits.getCentroid", "Vector3d.normalize", "Vector3d.dot", "Vector3d.dot", "Vector3d.dot", "Vector3d.negate"], "method_name": "RotationAxisAligner.getReferenceAxisCylic", "method_implementation": "{\n    if (\"C2\".equals(rotationGroup.getPointGroup())) {\n        Vector3d vr = new Vector3d(subunits.getOriginalCenters().get(0));\n        vr.sub(subunits.getCentroid());\n        vr.normalize();\n        return vr;\n    }\n    // get principal axis vector that is perpendicular to the principal\n    // rotation vector\n    Vector3d vmin = null;\n    double dotMin = 1.0;\n    for (Vector3d v : principalAxesOfInertia) {\n        if (Math.abs(principalRotationVector.dot(v)) < dotMin) {\n            dotMin = Math.abs(principalRotationVector.dot(v));\n            vmin = new Vector3d(v);\n        }\n    }\n    if (principalRotationVector.dot(vmin) < 0) {\n        vmin.negate();\n    }\n    return vmin;\n}", "repo_id": "9", "comment": "/**\n * Returns the default reference vector for the alignment of Cn structures\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1996, "method_signature": "Vector3d getReferenceAxisCylic()"}, "2210": {"callee_method_names": ["Structure.getChain", "Group.getAltLocs", "Group.getAtom", "Group.getAtom", "Atom.getX", "Atom.getY", "Atom.getZ", "Atom.getX", "Atom.getY", "Atom.getZ", "Structure.getChain", "Group.getAltLocs", "Group.getAtom", "Group.getAtom", "Atom.getX", "Atom.getY", "Atom.getZ", "Atom.getX", "Atom.getY", "Atom.getZ"], "method_name": "TestCalc.testStructureTransform", "method_implementation": "{\n    Structure s = createDummyStructure();\n    // shift of 1 in x axis\n    Matrix4d m = new Matrix4d(1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    Calc.transform(s, m);\n    // testing 1st chain\n    Group thegroup = s.getChain(\"A\").getAtomGroup(0);\n    Group thealtlocgroup = thegroup.getAltLocs().get(0);\n    Atom atom1 = thegroup.getAtom(\"CA\");\n    Atom atom2 = thealtlocgroup.getAtom(\"CA\");\n    // x should be shitfted by 1\n    assertEquals(2, atom1.getX(), 0.00001);\n    assertEquals(1, atom1.getY(), 0.00001);\n    assertEquals(1, atom1.getZ(), 0.00001);\n    // x should be shitfted by 1\n    assertEquals(3, atom2.getX(), 0.00001);\n    assertEquals(2, atom2.getY(), 0.00001);\n    assertEquals(2, atom2.getZ(), 0.00001);\n    // testing 2nd chain\n    thegroup = s.getChain(\"B\").getAtomGroup(0);\n    thealtlocgroup = thegroup.getAltLocs().get(0);\n    atom1 = thegroup.getAtom(\"CA\");\n    atom2 = thealtlocgroup.getAtom(\"CA\");\n    // x should be shitfted by 1\n    assertEquals(4, atom1.getX(), 0.00001);\n    assertEquals(3, atom1.getY(), 0.00001);\n    assertEquals(3, atom1.getZ(), 0.00001);\n    // x should be shitfted by 1\n    assertEquals(5, atom2.getX(), 0.00001);\n    assertEquals(4, atom2.getY(), 0.00001);\n    assertEquals(4, atom2.getZ(), 0.00001);\n}", "repo_id": "9", "comment": "/**\n * Issue https://github.com/biojava/biojava/issues/715\n */\n", "repo_name": "biojava-master/", "id": 2210, "method_signature": "void testStructureTransform()"}, "2125": {"callee_method_names": ["Class<?>.setStructure", "Model.setChains", "List<Model>.add"], "method_name": "StructureImpl.addModel", "method_implementation": "{\n    for (Chain c : modelChains) {\n        c.setStructure(this);\n    }\n    Model model = new Model();\n    model.setChains(modelChains);\n    models.add(model);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2125, "method_signature": "void addModel(List)"}, "3813": {"callee_method_names": ["Properties.load", "Properties.containsKey", "Properties.getProperty", "Properties.containsKey", "Properties.getProperty", "Properties.containsKey", "Properties.getProperty", "String.startsWith", "String.startsWith", "String.startsWith", "String.substring", "String.length", "String.endsWith", "String.endsWith", "String.endsWith", "String.substring", "String.length", "ArrayList.clear", "String.split", "double.trim", "ArrayList.add", "Properties.containsKey", "Properties.getProperty", "Properties.containsKey", "Properties.getProperty"], "method_name": "KMFigureInfo.init", "method_implementation": "{\n    Properties properties = new Properties();\n    properties.load(new FileInputStream(propertyFileName));\n    if (properties.containsKey(\"legendUpperPercentX\")) {\n        legendUpperPercentX = Double.parseDouble(properties.getProperty(\"legendUpperPercentX\"));\n    }\n    if (properties.containsKey(\"legendUpperPercentY\")) {\n        legendUpperPercentY = Double.parseDouble(properties.getProperty(\"legendUpperPercentY\"));\n    }\n    if (properties.containsKey(\"xAxisLabels\")) {\n        String values = properties.getProperty(\"xAxisLabels\").trim();\n        if (values.startsWith(\"[\") || values.startsWith(\"(\") || values.startsWith(\"{\")) {\n            values = values.substring(1, values.length()).trim();\n        }\n        if (values.endsWith(\"]\") || values.endsWith(\")\") || values.endsWith(\"}\")) {\n            values = values.substring(0, values.length() - 1).trim();\n        }\n        xAxisLabels.clear();\n        String[] data = values.split(\",\");\n        for (String d : data) {\n            try {\n                Double v = Double.parseDouble(d.trim());\n                xAxisLabels.add(v);\n            } catch (Exception e) {\n            }\n        }\n    }\n    if (properties.containsKey(\"xAxisLegend\")) {\n        xAxisLegend = properties.getProperty(\"xAxisLegend\");\n    }\n    if (properties.containsKey(\"yAxisLegend\")) {\n        yAxisLegend = properties.getProperty(\"yAxisLegend\");\n    }\n}", "repo_id": "9", "comment": "/**\n * @param propertyFileName\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3813, "method_signature": "void init(String)"}, "2411": {"callee_method_names": [], "method_name": "Location.distance", "method_implementation": "{\n    if (isSameStrand(other)) {\n        if (overlaps(other)) {\n            return -1;\n        } else {\n            return (mEnd <= other.mStart) ? (other.mStart - mEnd) : (mStart - other.mEnd);\n        }\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n *    Return distance between this location and the other location.\n *\n * \tDistance is defined only if both locations are on same strand.\n *\n *  @param other The location to compare.\n *  @return The integer distance. Returns -1 if they overlap; 0 if directly adjacent.\n *  @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2411, "method_signature": "int distance(Location)"}, "1042": {"callee_method_names": ["Group.getAtoms", "Set<String>.contains", "Atom.getName", "List<Atom>.add"], "method_name": "StructureTools.addNucleotideAndAminoAtoms", "method_implementation": "{\n    for (Atom a : g.getAtoms()) {\n        if (atomNames.contains(a.getName())) {\n            atoms.add(a);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * This method will be used to add the Nucleotide and Amino atoms to the backbone Atom arrays based on the pre-defined Atom names.\n * @param atoms\n * @param g\n * @param atomNames\n */\n", "repo_name": "biojava-master/", "id": 1042, "method_signature": "void addNucleotideAndAminoAtoms(List, Group, Set)"}, "1068": {"callee_method_names": ["HashMap.get", "CathInstallation.setCathVersion"], "method_name": "CathFactory.getCathDatabase", "method_implementation": "{\n    if (version == null)\n        version = DEFAULT_VERSION;\n    CathDatabase cath = versions.get(version);\n    if (cath == null) {\n        CathInstallation newCath = new CathInstallation();\n        newCath.setCathVersion(version);\n        cath = newCath;\n    }\n    return cath;\n}", "repo_id": "9", "comment": "/**\n * Returns a CATH database of the specified version.\n * @param version For example, \"3.5.0\"\n */\n", "repo_name": "biojava-master/", "id": 1068, "method_signature": "CathDatabase getCathDatabase(String)"}, "275": {"callee_method_names": ["Group.getResidueNumber", "Group.getPDBName"], "method_name": "StructureUtil.getStructureGroup", "method_implementation": "{\n    ResidueNumber resNum = group.getResidueNumber();\n    return new StructureGroup(resNum, group.getPDBName(), isAminoAcid);\n}", "repo_id": "9", "comment": "/**\n * @param group a {@link Group} in structure.\n * @param isAminoAcid true if it is an amino acid.\n * @return the {@link StructureGroup} of the group.\n */\n", "repo_name": "biojava-master/", "id": 275, "method_signature": "StructureGroup getStructureGroup(Group, boolean)"}, "1778": {"callee_method_names": [], "method_name": "PDBHeader.getDescription", "method_implementation": "{\n    return description;\n}", "repo_id": "9", "comment": "/**\n * @deprecated will be removed later. Use {@link #getKeywords()} if you use\n *  <code>description</code> to keep the keywords.\n *  @return\n */\n", "repo_name": "biojava-master/", "id": 1778, "method_signature": "String getDescription()"}, "60": {"callee_method_names": [], "method_name": "AbstractMatrixAligner.getGapPenalty", "method_implementation": "{\n    return gapPenalty;\n}", "repo_id": "9", "comment": "/**\n * Returns the gap penalties.\n *\n * @return the gap penalties used during alignment\n */\n", "repo_name": "biojava-master/", "id": 60, "method_signature": "GapPenalty getGapPenalty()"}, "1585": {"callee_method_names": [], "method_name": "SecStrucElement.getRange", "method_implementation": "{\n    return range;\n}", "repo_id": "9", "comment": "/**\n * Returns the residue range of this SSE.\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1585, "method_signature": "ResidueRangeAndLength getRange()"}, "3452": {"callee_method_names": ["HashMap.keySet", "Set<String>.add"], "method_name": "NCBIQBlastOutputProperties.getOutputOptions", "method_implementation": "{\n    Set<String> result = new HashSet<String>();\n    for (BlastOutputParameterEnum parameter : param.keySet()) {\n        result.add(parameter.name());\n    }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * Gets output parameters, which are currently set\n */\n", "repo_name": "biojava-master/", "id": 3452, "method_signature": "Set<String> getOutputOptions()"}, "2709": {"callee_method_names": [], "method_name": "BufferedReaderBytesRead.getBytesRead", "method_implementation": "{\n    return bytesRead;\n}", "repo_id": "9", "comment": "/**\n * Keep track of bytesread via ReadLine to account for CR-LF in the stream. Does not keep track of position if\n * use methods other than ReadLine.\n * //TODO should override other methods and throw exception or keep track of bytes read\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2709, "method_signature": "long getBytesRead()"}, "2024": {"callee_method_names": [], "method_name": "Prism.getSideLengthFromInscribedRadius", "method_implementation": "{\n    if (n == 2) {\n        return radius;\n    }\n    return radius * 2 * Math.tan(Math.PI / n);\n}", "repo_id": "9", "comment": "// http://www.mathopenref.com/polygonincircle.html\n", "repo_name": "biojava-master/", "id": 2024, "method_signature": "double getSideLengthFromInscribedRadius(double, int)"}, "1025": {"callee_method_names": [], "method_name": "StructureTools.addGroupsToStructure", "method_implementation": "{\n    Chain chainGuess = null;\n    for (Group g : groups) {\n        chainGuess = addGroupToStructure(s, g, model, chainGuess, clone);\n    }\n}", "repo_id": "9", "comment": "/**\n * Add a list of groups to a new structure. Chains will be automatically\n * created in the new structure as needed.\n * @param s structure to receive the group\n * @param groups groups to add\n * @param model model number\n * @param clone Indicates whether the input groups should be cloned before\n *  being added to the new chain\n */\n", "repo_name": "biojava-master/", "id": 1025, "method_signature": "void addGroupsToStructure(Structure, Collection, int, boolean)"}, "3152": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.getIndexOf", "method_implementation": "{\n    return this.parsedCompounds.indexOf(compound) + 1;\n}", "repo_id": "9", "comment": "/**\n * @param compound\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3152, "method_signature": "int getIndexOf(C)"}, "852": {"callee_method_ids": [846, 847], "callee_method_names": ["SparseVector.put", "SparseVector.get"], "method_name": "SparseVector.scale", "method_implementation": "{\n    SparseVector a = this;\n    SparseVector c = new SparseVector(N);\n    for (int i : a.symbolTable) c.put(i, alpha * a.get(i));\n    return c;\n}", "repo_id": "9", "comment": "/**\n * Calculates  alpha * a\n *\n * @param alpha\n * @return\n */\n", "repo_name": "biojava-master/", "id": 852, "method_signature": "SparseVector scale(double)"}, "848": {"callee_method_names": ["SymbolTable<Integer, Double>.size"], "method_name": "SparseVector.nnz", "method_implementation": "{\n    return symbolTable.size();\n}", "repo_id": "9", "comment": "// return the number of nonzero entries\n", "repo_name": "biojava-master/", "id": 848, "method_signature": "int nnz()"}, "1512": {"callee_method_names": [], "method_name": "UnitQuaternions.orientationMetric", "method_implementation": "{\n    return Math.acos(Math.abs(dotProduct(q1, q2)));\n}", "repo_id": "9", "comment": "/**\n * The orientation metric is obtained by comparing two unit quaternion\n * orientations.\n * <p>\n * The two quaternions are compared using the formula: d(q1,q2) =\n * arccos(|q1*q2|). The range of the metric is [0, Pi/2], where 0 means the\n * same orientation and Pi/2 means the opposite orientation.\n * <p>\n * The formula is taken from: Huynh, D. Q. (2009). Metrics for 3D rotations:\n * comparison and analysis. Journal of Mathematical Imaging and Vision,\n * 35(2), 155\u2013164. http://doi.org/10.1007/s10851-009-0161-2\n *\n * @param q1\n *            quaternion as Quat4d object\n * @param q2\n *            quaternion as Quat4d object\n * @return the quaternion orientation metric\n */\n", "repo_name": "biojava-master/", "id": 1512, "method_signature": "double orientationMetric(Quat4d, Quat4d)"}, "3559": {"callee_method_names": [], "method_name": "CoxVariables.getGeneSet", "method_implementation": "{\n    return geneSet;\n}", "repo_id": "9", "comment": "/**\n * @return the geneSet\n */\n", "repo_name": "biojava-master/", "id": 3559, "method_signature": "String getGeneSet()"}, "3698": {"callee_method_names": [], "method_name": "HeaderInfo.getIndex", "method_implementation": "{\n    return index;\n}", "repo_id": "9", "comment": "/**\n * @return the index\n */\n", "repo_name": "biojava-master/", "id": 3698, "method_signature": "Integer getIndex()"}, "2425": {"callee_method_names": [], "method_name": "Location.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + mEnd;\n    result = prime * result + mStart;\n    return result;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#hashCode()\n\t */\n", "repo_name": "biojava-master/", "id": 2425, "method_signature": "int hashCode()"}, "1352": {"callee_method_names": [], "method_name": "EntityInfo.setType", "method_implementation": "{\n    this.type = type;\n}", "repo_id": "9", "comment": "/**\n * Set the type of entity this EntityInfo describes.\n * Options are polymer, non-polymer or water.\n * @param type a string describing the type of entity. (polymer, non-polymer or water).\n */\n", "repo_name": "biojava-master/", "id": 1352, "method_signature": "void setType(EntityType)"}, "1177": {"callee_method_ids": [1479, 1411, 1418, 1413, 1418], "callee_method_names": ["String.length", "Logger.warn", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "Logger.info", "Element.getMessage", "String.length", "String.substring", "String.substring", "String.length", "CrystalCell.setA", "CrystalCell.setB", "CrystalCell.setC", "CrystalCell.setAlpha", "CrystalCell.setBeta", "CrystalCell.setGamma", "CrystalCell.isCellReasonable", "Logger.debug", "PDBCrystallographicInfo.setCrystalCell", "Logger.warn", "PDBCrystallographicInfo.setNonStandardSg", "PDBCrystallographicInfo.setSpaceGroup", "PDBCrystallographicInfo.setNonStandardSg"], "method_name": "PDBFileParser.pdb_CRYST1_Handler", "method_implementation": "{\n    // for badly formatted files (e.g. phenix-produced ones), there's no z and the min length is 58 (e.g. for SG 'P 1')\n    if (line.length() < 58) {\n        logger.warn(\"CRYST1 record has fewer than 58 columns: will ignore it\");\n        return;\n    }\n    float a;\n    float b;\n    float c;\n    float alpha;\n    float beta;\n    float gamma;\n    String spaceGroup = \"\";\n    try {\n        a = Float.parseFloat(line.substring(6, 15).trim());\n        b = Float.parseFloat(line.substring(15, 24).trim());\n        c = Float.parseFloat(line.substring(24, 33).trim());\n        alpha = Float.parseFloat(line.substring(33, 40).trim());\n        beta = Float.parseFloat(line.substring(40, 47).trim());\n        gamma = Float.parseFloat(line.substring(47, 54).trim());\n    } catch (NumberFormatException e) {\n        logger.info(\"could not parse CRYST1 record (\" + e.getMessage() + \") from line and ignoring it \" + line);\n        return;\n    }\n    if (line.length() >= 66) {\n        // for well formatted files\n        spaceGroup = line.substring(55, 66).trim();\n    } else {\n        // for not-so-well formatted files, e.g. phenix-produced ones: they lack a Z value\n        spaceGroup = line.substring(55, line.length()).trim();\n    }\n    CrystalCell xtalCell = new CrystalCell();\n    xtalCell.setA(a);\n    xtalCell.setB(b);\n    xtalCell.setC(c);\n    xtalCell.setAlpha(alpha);\n    xtalCell.setBeta(beta);\n    xtalCell.setGamma(gamma);\n    if (!xtalCell.isCellReasonable()) {\n        // If the entry describes a structure determined by a technique other than X-ray crystallography,\n        // CRYST1 contains a = b = c = 1.0, alpha = beta = gamma = 90 degrees, space group = P 1, and Z =1.\n        // if so we don't add the crystal cell and it remains null\n        logger.debug(\"The crystal cell read from file does not have reasonable dimensions (at least one dimension is below {}), discarding it.\", CrystalCell.MIN_VALID_CELL_SIZE);\n    } else {\n        crystallographicInfo.setCrystalCell(xtalCell);\n    }\n    SpaceGroup sg = SymoplibParser.getSpaceGroup(spaceGroup);\n    if (sg == null) {\n        logger.warn(\"Space group '\" + spaceGroup + \"' not recognised as a standard space group\");\n        crystallographicInfo.setNonStandardSg(true);\n    } else {\n        crystallographicInfo.setSpaceGroup(sg);\n        crystallographicInfo.setNonStandardSg(false);\n    }\n}", "repo_id": "9", "comment": "/**\n * Handler for\n * CRYST1 Record Format\n * The CRYST1 record presents the unit cell parameters, space group, and Z value.\n * If the entry describes a structure determined by a technique other than X-ray crystallography,\n * CRYST1 contains a = b = c = 1.0, alpha = beta = gamma = 90 degrees, space group = P 1, and Z =1.\n * <pre>\n * COLUMNS DATA TYPE    FIELD          DEFINITION\n * -------------------------------------------------------------\n *  1 - 6  Record name  \"CRYST1\"\n *  7 - 15 Real(9.3)    a              a (Angstroms).\n * 16 - 24 Real(9.3)    b              b (Angstroms).\n * 25 - 33 Real(9.3)    c              c (Angstroms).\n * 34 - 40 Real(7.2)    alpha          alpha (degrees).\n * 41 - 47 Real(7.2)    beta           beta (degrees).\n * 48 - 54 Real(7.2)    gamma          gamma (degrees).\n * 56 - 66 LString      sGroup         Space group.\n * 67 - 70 Integer      z              Z value.\n * </pre>\n */\n", "repo_name": "biojava-master/", "id": 1177, "method_signature": "void pdb_CRYST1_Handler(String)"}, "3030": {"callee_method_names": ["int.getEnd", "ResidueNumber.getEnd"], "method_name": "Location.getMax", "method_implementation": "{\n    return scanLocations(locations, new LocationPredicate() {\n\n        @Override\n        public boolean accept(Location previous, Location current) {\n            int res = current.getEnd().compareTo(previous.getEnd());\n            return res > 0;\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Scans through a list of locations to find the Location with the\n * highest end\n */\n", "repo_name": "biojava-master/", "id": 3030, "method_signature": "Location getMax(List)"}, "3288": {"callee_method_ids": [477], "callee_method_names": ["AFPChain.getNrEQR", "List<Atom>.add", "List<Atom>.toArray", "List<Atom>.size"], "method_name": "DisplayAFP.createArtificalStructure", "method_implementation": "{\n    if (afpChain.getNrEQR() < 1) {\n        return AlignmentTools.getAlignedStructure(ca1, ca2);\n    }\n    Group[] twistedGroups = AlignmentTools.prepareGroupsForDisplay(afpChain, ca1, ca2);\n    List<Atom> twistedAs = new ArrayList<Atom>();\n    for (Group g : twistedGroups) {\n        if (g == null)\n            continue;\n        if (g.size() < 1)\n            continue;\n        Atom a = g.getAtom(0);\n        twistedAs.add(a);\n    }\n    Atom[] twistedAtoms = twistedAs.toArray(new Atom[twistedAs.size()]);\n    List<Group> hetatms = StructureTools.getUnalignedGroups(ca1);\n    List<Group> hetatms2 = StructureTools.getUnalignedGroups(ca2);\n    Atom[] arr1 = DisplayAFP.getAtomArray(ca1, hetatms);\n    Atom[] arr2 = DisplayAFP.getAtomArray(twistedAtoms, hetatms2);\n    Structure artificial = AlignmentTools.getAlignedStructure(arr1, arr2);\n    return artificial;\n}", "repo_id": "9", "comment": "/**\n * Create a \"fake\" Structure objects that contains the two sets of atoms aligned on top of each other.\n *\n * @param afpChain the container of the alignment\n * @param ca1 atoms for protein 1\n * @param ca2 atoms for protein 2\n * @return a protein structure with 2 models.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3288, "method_signature": "Structure createArtificalStructure(AFPChain, Atom[], Atom[])"}, "3722": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "WorkSheet.isMetaDataRow", "method_implementation": "{\n    if (metaDataRowsHashMap.get(row) == null) {\n        return false;\n    } else {\n        return true;\n    }\n}", "repo_id": "9", "comment": "/**\n * @param row\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3722, "method_signature": "boolean isMetaDataRow(String)"}, "609": {"callee_method_names": [], "method_name": "IdentityMap.entrySet", "method_implementation": "{\n    return Collections.emptySet();\n}", "repo_id": "9", "comment": "/**\n * Always returns the empty set\n */\n", "repo_name": "biojava-master/", "id": 609, "method_signature": "Set<java.util.Map.Entry<K,K>> entrySet()"}, "1142": {"callee_method_names": ["String.trim", "Logger.debug", "String.startsWith", "String.startsWith", "String.startsWith", "Logger.warn", "Logger.info"], "method_name": "LocalPDBDirectory.getServerName", "method_implementation": "{\n    String name = System.getProperty(PDB_FILE_SERVER_PROPERTY);\n    if (name == null || name.trim().isEmpty()) {\n        name = DEFAULT_PDB_FILE_SERVER;\n        logger.debug(\"Using default PDB file server {}\", name);\n    } else {\n        if (!name.startsWith(\"http://\") && !name.startsWith(\"ftp://\") && !name.startsWith(\"https://\")) {\n            logger.warn(\"Server name {} read from system property {} does not have a leading protocol string. Adding http:// to it\", name, PDB_FILE_SERVER_PROPERTY);\n            name = \"http://\" + name;\n        }\n        logger.info(\"Using PDB file server {} read from system property {}\", name, PDB_FILE_SERVER_PROPERTY);\n    }\n    return name;\n}", "repo_id": "9", "comment": "/**\n * Return the String with the PDB server name, including the leading protocol\n * String (http:// or ftp://).\n * The server name will be by default the value {@value #DEFAULT_PDB_FILE_SERVER} or the one\n * read from system property {@value #PDB_FILE_SERVER_PROPERTY}\n *\n * @return the server name including the leading protocol string\n */\n", "repo_name": "biojava-master/", "id": 1142, "method_signature": "String getServerName()"}, "3767": {"callee_method_names": ["File.getParentFile", "File.isDirectory", "File.mkdirs", "BufferedOutputStream.close", "FileOutputStream.close"], "method_name": "WorkSheet.saveTXT", "method_implementation": "{\n    File f = new File(fileName);\n    File parentFile = f.getParentFile();\n    if (!parentFile.isDirectory()) {\n        parentFile.mkdirs();\n    }\n    FileOutputStream file = new FileOutputStream(fileName);\n    BufferedOutputStream bs = new BufferedOutputStream(file);\n    save(bs, '\\t', false);\n    bs.close();\n    file.close();\n}", "repo_id": "9", "comment": "/**\n * @param fileName\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3767, "method_signature": "void saveTXT(String)"}, "1706": {"callee_method_names": ["Atom.getBonds", "Atom.setBonds", "HBond.getOther", "Atom.addBond", "Atom.addBond"], "method_name": "BondImpl.addSelfToAtoms", "method_implementation": "{\n    List<Bond> bonds = atomA.getBonds();\n    if (bonds == null) {\n        bonds = new ArrayList<Bond>(AtomImpl.BONDS_INITIAL_CAPACITY);\n        atomA.setBonds(bonds);\n    }\n    boolean exists = false;\n    for (Bond bond : bonds) {\n        // TODO is it equals() what we want here, or is it == ? - JD 2016-03-02\n        if (bond.getOther(atomA).equals(atomB)) {\n            exists = true;\n            break;\n        }\n    }\n    if (!exists) {\n        atomA.addBond(this);\n        atomB.addBond(this);\n    }\n}", "repo_id": "9", "comment": "// TODO first check if those bonds haven't been made already\n", "repo_name": "biojava-master/", "id": 1706, "method_signature": "void addSelfToAtoms()"}, "142": {"callee_method_ids": [449, 452, 451], "callee_method_names": ["QsAlignResult.length", "QsAlignResult.getRelation", "QsAlignResult.getRmsd"], "method_name": "TestQsAlignExamples.testPartialIncomplete", "method_implementation": "{\n    Structure s1 = StructureIO.getStructure(\"1bcc\");\n    Structure s2 = StructureIO.getStructure(\"1kb9\");\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n    QsAlignParameters alignParams = new QsAlignParameters();\n    QsAlignResult result = QsAlign.align(s1, s2, clusterParams, alignParams);\n    assertEquals(result.length(), 8);\n    assertEquals(result.getRelation(), QsRelation.PARTIAL_INCOMPLETE);\n    assertTrue(result.getRmsd() < 10.0);\n}", "repo_id": "9", "comment": "/**\n * Cytochrome bc1 complexes (1BCC, 1KB9) have some equivalent Chains and\n * some unmatched.\n */\n", "repo_name": "biojava-master/", "id": 142, "method_signature": "void testPartialIncomplete()"}, "497": {"callee_method_names": [], "method_name": "AFPChain.getTotalRmsdOpt", "method_implementation": "{\n    return totalRmsdOpt;\n}", "repo_id": "9", "comment": "/**\n * The RMSD of the final alignment. Use this to print overal alignment RMSD.\n *\n * @return total RMSD of the optimal alignment.\n */\n", "repo_name": "biojava-master/", "id": 497, "method_signature": "double getTotalRmsdOpt()"}, "2946": {"callee_method_names": [], "method_name": "AbstractSequence.getLength", "method_implementation": "{\n    return getSequenceStorage().getLength();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2946, "method_signature": "int getLength()"}, "3463": {"callee_method_names": ["URL.openConnection", "URLConnection.getOutputStream", "OutputStreamWriter.write", "OutputStreamWriter.flush", "URLConnection.getInputStream", "BufferedReader.readLine", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString", "MouseEvent.getMessage"], "method_name": "NCBIQBlastService.getRemoteBlastInfo", "method_implementation": "{\n    OutputStreamWriter writer = null;\n    BufferedReader reader = null;\n    try {\n        URLConnection serviceConnection = setQBlastServiceProperties(serviceUrl.openConnection());\n        writer = new OutputStreamWriter(serviceConnection.getOutputStream());\n        writer.write(\"CMD=Info\");\n        writer.flush();\n        reader = new BufferedReader(new InputStreamReader(serviceConnection.getInputStream()));\n        StringBuilder sb = new StringBuilder();\n        String line;\n        while ((line = reader.readLine()) != null) {\n            sb.append(line);\n            sb.append(System.getProperty(\"line.separator\"));\n        }\n        return sb.toString();\n    } catch (IOException e) {\n        throw new Exception(\"Impossible to get info from QBlast service at this time. Cause: \" + e.getMessage(), e);\n    } finally {\n        IOUtils.close(reader);\n        IOUtils.close(writer);\n    }\n}", "repo_id": "9", "comment": "/**\n * A simple method to check the availability of the QBlast service. Sends {@code Info} command to QBlast\n *\n * @return QBlast info output concatenated to String\n * @throws Exception if unable to connect to the NCBI QBlast service\n */\n", "repo_name": "biojava-master/", "id": 3463, "method_signature": "String getRemoteBlastInfo()"}, "3622": {"callee_method_names": ["String.length"], "method_name": "CoxInfo.fmtpl", "method_implementation": "{\n    int length = d.length();\n    int extra = pad - length;\n    if (extra < 0) {\n        extra = 0;\n    }\n    String v = d;\n    for (int i = 0; i < extra; i++) {\n        v = \" \" + v;\n    }\n    return v;\n}", "repo_id": "9", "comment": "/**\n * Pad left a string with spaces\n *\n * @param d\n * @param pad\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3622, "method_signature": "String fmtpl(String, int)"}, "2092": {"callee_method_names": ["List<Axis>.add", "List<Axis>.size"], "method_name": "SymmetryAxes.addAxis", "method_implementation": "{\n    axes.add(new Axis(axis, order, type, axes.size(), 0));\n}", "repo_id": "9", "comment": "/**\n * Adds a new axis of symmetry to the bottom level of the tree\n *\n * @param axis the new axis of symmetry found\n * @param order number of parts that this axis divides the structure in\n * @param type indicates whether the axis has OPEN or CLOSED symmetry\n */\n", "repo_name": "biojava-master/", "id": 2092, "method_signature": "void addAxis(Matrix4d, int, SymmetryType)"}, "2880": {"callee_method_names": ["Sequence<NucleotideCompound>.getCompoundSet", "CompoundSet<NucleotideCompound>.getCompoundForString", "CompoundSet<NucleotideCompound>.getCompoundForString", "CompoundSet<NucleotideCompound>.getCompoundForString", "CompoundSet<NucleotideCompound>.getCompoundForString"], "method_name": "SequenceMixin.countAT", "method_implementation": "{\n    CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n    NucleotideCompound A = cs.getCompoundForString(\"A\");\n    NucleotideCompound T = cs.getCompoundForString(\"T\");\n    NucleotideCompound a = cs.getCompoundForString(\"a\");\n    NucleotideCompound t = cs.getCompoundForString(\"t\");\n    return countCompounds(sequence, A, T, a, t);\n}", "repo_id": "9", "comment": "/**\n * Returns the count of AT in the given sequence\n *\n * @param sequence The {@link NucleotideCompound} {@link Sequence} to perform\n * the AT analysis on\n * @return The number of AT compounds in the sequence\n */\n", "repo_name": "biojava-master/", "id": 2880, "method_signature": "int countAT(Sequence)"}, "3553": {"callee_method_names": ["String.hashCode"], "method_name": "CoxVariables.getUniqueID", "method_implementation": "{\n    String link = geneSet + \"_\" + cohortName;\n    return link.hashCode();\n}", "repo_id": "9", "comment": "/**\n * Need a unique id from String\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3553, "method_signature": "int getUniqueID()"}, "1484": {"callee_method_names": ["ArrayList.size", "ArrayList.get"], "method_name": "MomentsOfInertia.getElipsisRadii", "method_implementation": "{\n    if (modified) {\n        diagonalizeTensor();\n        modified = false;\n    }\n    double m = 0;\n    for (int i = 0, n = points.size(); i < n; i++) {\n        m += masses.get(i);\n    }\n    double[] r = new double[3];\n    for (int i = 0; i < 3; i++) {\n        r[i] = Math.sqrt(principalMomentsOfInertia[i] / m);\n    }\n    return r;\n}", "repo_id": "9", "comment": "/**\n * The effective value of this distance for a certain body is known as its\n * radius of / gyration with respect to the given axis. The radius of\n * gyration corresponding to Ijj / is defined as /\n * http://www.eng.auburn.edu/~marghitu/MECH2110/C_4.pdf / radius of gyration\n * k(j) = sqrt(I(j)/m)\n */\n", "repo_name": "biojava-master/", "id": 1484, "method_signature": "double[] getElipsisRadii()"}, "1333": {"callee_method_names": ["Object.getClass", "Character.equals", "Integer.equals"], "method_name": "ResidueNumber.equalsPositional", "method_implementation": "{\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    ResidueNumber other = (ResidueNumber) obj;\n    if (insCode == null) {\n        if (other.insCode != null)\n            return false;\n    } else if (!insCode.equals(other.insCode))\n        return false;\n    if (seqNum == null) {\n        if (other.seqNum != null)\n            return false;\n    } else if (!seqNum.equals(other.seqNum))\n        return false;\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Check if the seqNum and insertion code are equivalent,\n * ignoring the chain\n * @param obj\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1333, "method_signature": "boolean equalsPositional(Object)"}, "3528": {"callee_method_names": [], "method_name": "StrataInfo.setStdlow", "method_implementation": "{\n    this.stdlow = stdlow;\n}", "repo_id": "9", "comment": "/**\n * @param stdlow the stdlow to set\n */\n", "repo_name": "biojava-master/", "id": 3528, "method_signature": "void setStdlow(ArrayList)"}, "2258": {"callee_method_names": [], "method_name": "TestMmtfUtils.testGetSecStructTypeFromDsspIndex", "method_implementation": "{\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(0).name, \"pi Helix\");\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(1).name, \"Bend\");\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(2).name, \"alpha Helix\");\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(3).name, \"Extended\");\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(4).name, \"3-10 Helix\");\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(5).name, \"Bridge\");\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(6).name, \"Turn\");\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(7).name, \"Coil\");\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(-1), null);\n    assertEquals(MmtfUtils.getSecStructTypeFromDsspIndex(10), null);\n}", "repo_id": "9", "comment": "/**\n * Test that setting the secondary structure types behaves as expected.\n */\n", "repo_name": "biojava-master/", "id": 2258, "method_signature": "void testGetSecStructTypeFromDsspIndex()"}, "3514": {"callee_method_names": ["DecimalFormat.format", "String.length"], "method_name": "StrataInfo.f", "method_implementation": "{\n    String v = df.format(d);\n    int l = 10 - v.length();\n    for (int i = 0; i < l; i++) {\n        v = v + \" \";\n    }\n    return v;\n}", "repo_id": "9", "comment": "/**\n * @param d\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3514, "method_signature": "String f(Double)"}, "2136": {"callee_method_names": ["List<Model>.get"], "method_name": "StructureImpl.getModel", "method_implementation": "{\n    return models.get(modelnr).getChains();\n}", "repo_id": "9", "comment": "/**\n * Retrieve all Chains belonging to a model .\n *\n * @param modelnr  an int\n * @return a List object\n */\n", "repo_name": "biojava-master/", "id": 2136, "method_signature": "List<Chain> getModel(int)"}, "1326": {"callee_method_names": [], "method_name": "FileParsingParameters.getAtomCaThreshold", "method_implementation": "{\n    return atomCaThreshold;\n}", "repo_id": "9", "comment": "/**\n * The maximum number of atoms that will be parsed before the parser switches to a CA-only\n * representation of the PDB file. If this limit is exceeded also the SEQRES groups will be\n * ignored.\n *\n * @return atomCaThreshold.\n */\n", "repo_name": "biojava-master/", "id": 1326, "method_signature": "int getAtomCaThreshold()"}, "93": {"callee_method_names": [], "method_name": "AlignerHelper.setSteps", "method_implementation": "{\n    return setSteps(traceback, true, xyMax, Last.SUBSTITUTION, sx, sy);\n}", "repo_id": "9", "comment": "/**\n * Find local alignment path through traceback matrix\n * @param traceback\n * @param xyMax\n * @param sx\n * @param sy\n * @return\n */\n", "repo_name": "biojava-master/", "id": 93, "method_signature": "int[] setSteps(Last[][][], int[], List, List)"}, "505": {"callee_method_names": [], "method_name": "AFPChain.getDistanceMatrix", "method_implementation": "{\n    return distanceMatrix;\n}", "repo_id": "9", "comment": "/**\n * A matrix with <i>ca1length</i> rows and <i>ca2length</i> columns.\n * For CE this is the distance matrix, but the exact interpretation is left\n * up to the alignment algorithm.\n *\n * <p>Note:\n * A {@link org.biojava.nbio.structure.gui.JMatrixPanel}, which is used in\n * the structure-gui package to display distance matrices, will display the\n * transpose of this matrix. Be sure to take that into account when debugging\n * visually.\n *\n * @return A matrix with dimensions ca1length x ca2length, or null\n */\n", "repo_name": "biojava-master/", "id": 505, "method_signature": "Matrix getDistanceMatrix()"}, "2182": {"callee_method_ids": [639, 634, 641, 628], "callee_method_names": ["Logger.info", "Path.toString", "Path.toString", "Path.toString", "AtomCache.setPath", "Path.toString", "AtomCache.setCachePath", "Path.toString", "AtomCache.setFiletype", "Path.toString", "Path.resolve", "Path.getParent", "Path.resolve", "Path.getParent", "URL.getPath", "File.toPath", "AtomCache.getStructure", "Structure.getChain", "Group.getPDBName", "Group.getChemComp", "ChemComp.getAtoms", "ChemComp.getType"], "method_name": "AtomCacheTest.testEmptyChemComp", "method_implementation": "{\n    Path tmpCache = Paths.get(System.getProperty(\"java.io.tmpdir\"), \"BIOJAVA_TEST_CACHE\");\n    logger.info(\"Testing AtomCache at {}\", tmpCache.toString());\n    System.setProperty(UserConfiguration.PDB_DIR, tmpCache.toString());\n    System.setProperty(UserConfiguration.PDB_CACHE_DIR, tmpCache.toString());\n    FileDownloadUtils.deleteDirectory(tmpCache);\n    Files.createDirectory(tmpCache);\n    try {\n        cache.setPath(tmpCache.toString());\n        cache.setCachePath(tmpCache.toString());\n        cache.setFiletype(StructureFiletype.CIF);\n        ChemCompGroupFactory.setChemCompProvider(new DownloadChemCompProvider(tmpCache.toString()));\n        // Create an empty chemcomp\n        Path chemCompCif = tmpCache.resolve(Paths.get(\"chemcomp\", \"ATP.cif.gz\"));\n        Files.createDirectories(chemCompCif.getParent());\n        Files.createFile(chemCompCif);\n        assertTrue(Files.exists(chemCompCif));\n        assertEquals(0, Files.size(chemCompCif));\n        // Copy stub file into place\n        Path testCif = tmpCache.resolve(Paths.get(\"data\", \"structures\", \"divided\", \"mmCIF\", \"ab\", \"1abc.cif.gz\"));\n        Files.createDirectories(testCif.getParent());\n        URL resource = AtomCacheTest.class.getResource(\"/atp.cif.gz\");\n        File src = new File(resource.getPath());\n        Files.copy(src.toPath(), testCif, StandardCopyOption.REPLACE_EXISTING);\n        // Load structure\n        Structure s = cache.getStructure(\"1ABC\");\n        // Should have re-downloaded the file\n        assertTrue(Files.size(chemCompCif) > LocalPDBDirectory.MIN_PDB_FILE_SIZE);\n        // Structure should have valid ChemComp now\n        assertNotNull(s);\n        Group g = s.getChain(\"A\").getAtomGroup(0);\n        assertTrue(g.getPDBName().equals(\"ATP\"));\n        // should be unknown\n        ChemComp chem = g.getChemComp();\n        assertNotNull(chem);\n        assertTrue(chem.getAtoms().size() > 0);\n        assertEquals(\"NON-POLYMER\", chem.getType());\n    } finally {\n        FileDownloadUtils.deleteDirectory(tmpCache);\n    }\n}", "repo_id": "9", "comment": "/**\n * Test for #703 - Chemical component cache poisoning\n *\n * Handle empty CIF files\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2182, "method_signature": "void testEmptyChemComp()"}, "340": {"callee_method_names": ["ScopDatabase.getDomainsForPDB", "ScopDatabase.getScopNode", "List<ScopDomain>.get", "ScopNode.getSunid", "ScopDatabase.getScopDescriptionBySunid", "ScopNode.getSunid", "ScopDatabase.getScopNode", "ScopNode.getParentSunid"], "method_name": "DemoSCOP.traverseHierarchy", "method_implementation": "{\n    String pdbId = \"4HHB\";\n    // download SCOP if required and load into memory\n    ScopDatabase scop = ScopFactory.getSCOP();\n    List<ScopDomain> domains = scop.getDomainsForPDB(pdbId);\n    // show the hierachy for the first domain:\n    ScopNode node = scop.getScopNode(domains.get(0).getSunid());\n    while (node != null) {\n        System.out.println(\"This node: sunid:\" + node.getSunid());\n        System.out.println(scop.getScopDescriptionBySunid(node.getSunid()));\n        node = scop.getScopNode(node.getParentSunid());\n    }\n}", "repo_id": "9", "comment": "/**\n * Traverse throught the SCOP hierarchy\n */\n", "repo_name": "biojava-master/", "id": 340, "method_signature": "void traverseHierarchy()"}, "1356": {"callee_method_names": [], "method_name": "AminoAcidImpl.getO", "method_implementation": "{\n    return getAtom(\"O\");\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1356, "method_signature": "Atom getO()"}, "1305": {"callee_method_names": ["ProteinSequence.getSequenceAsString", "ProteinSequence.getSequenceAsString", "ProteinSequence.getLength", "ProteinSequence.getSequenceAsString", "Logger.error", "Element.getMessage", "ProteinSequence.getUserCollection", "ProteinSequence.getUserCollection"], "method_name": "FastaAFPChainConverter.cpFastaToAfpChain", "method_implementation": "{\n    if (structure == null) {\n        throw new IllegalArgumentException(\"The structure is null\");\n    }\n    if (first == null) {\n        throw new IllegalArgumentException(\"The sequence is null\");\n    }\n    // we need to find the ungapped CP site\n    int gappedCpShift = 0;\n    int ungappedCpShift = 0;\n    while (ungappedCpShift < Math.abs(cpSite)) {\n        char c;\n        try {\n            if (cpSite <= 0) {\n                c = second.getSequenceAsString().charAt(gappedCpShift);\n            } else {\n                c = second.getSequenceAsString().charAt(first.getLength() - 1 - gappedCpShift);\n            }\n        } catch (StringIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\"CP site of \" + cpSite + \" is wrong\");\n        }\n        if (c != '-') {\n            ungappedCpShift++;\n        }\n        gappedCpShift++;\n    }\n    Atom[] ca1 = StructureTools.getRepresentativeAtomArray(structure);\n    // can't use cloneCAArray because it doesn't set parent group.chain.structure\n    Atom[] ca2 = StructureTools.getRepresentativeAtomArray(structure);\n    ProteinSequence antipermuted = null;\n    try {\n        antipermuted = new ProteinSequence(SequenceTools.permuteCyclic(second.getSequenceAsString(), gappedCpShift));\n    } catch (CompoundNotFoundException e) {\n        // this can't happen, the original sequence comes from a ProteinSequence\n        logger.error(\"Unexpected error while creating protein sequence: {}. This is most likely a bug.\", e.getMessage());\n    }\n    ResidueNumber[] residues = StructureSequenceMatcher.matchSequenceToStructure(first, structure);\n    ResidueNumber[] antipermutedResidues = StructureSequenceMatcher.matchSequenceToStructure(antipermuted, structure);\n    ResidueNumber[] nonpermutedResidues = new ResidueNumber[antipermutedResidues.length];\n    SequenceTools.permuteCyclic(antipermutedResidues, nonpermutedResidues, -gappedCpShift);\n    // nullify ResidueNumbers that have a lowercase sequence character\n    if (first.getUserCollection() != null) {\n        CasePreservingProteinSequenceCreator.setLowercaseToNull(first, residues);\n    }\n    if (second.getUserCollection() != null) {\n        CasePreservingProteinSequenceCreator.setLowercaseToNull(second, nonpermutedResidues);\n    }\n    //\t\tfor (int i = 0; i < residues.length; i++) {\n    //\t\t\tif (residues[i] == null) {\n    //\t\t\t\tSystem.out.print(\"=\");\n    //\t\t\t} else {\n    //\t\t\t\tSystem.out.print(sequence.getSequenceAsString().charAt(i));\n    //\t\t\t}\n    //\t\t}\n    //\t\tSystem.out.println();\n    //\t\tfor (int i = 0; i < residues.length; i++) {\n    //\t\t\tif (nonpermutedResidues[i] == null) {\n    //\t\t\t\tSystem.out.print(\"=\");\n    //\t\t\t} else {\n    //\t\t\t\tSystem.out.print(second.getSequenceAsString().charAt(i));\n    //\t\t\t}\n    //\t\t}\n    //\t\tSystem.out.println();\n    return buildAlignment(ca1, ca2, residues, nonpermutedResidues);\n}", "repo_id": "9", "comment": "/**\n * Takes a structure and sequence corresponding to an alignment between a structure or sequence and itself (or even a structure with a sequence), where the result has a circular permutation site\n * {@link cpSite} residues to the right.\n *\n * @param first The unpermuted sequence\n * @param second The sequence permuted by cpSite\n * @param cpSite\n *            The number of residues from the beginning of the sequence at which the circular permutation site occurs; can be positive or negative; values greater than the length of the sequence\n *            are acceptable\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 1305, "method_signature": "AFPChain cpFastaToAfpChain(ProteinSequence, ProteinSequence, Structure, int)"}, "3232": {"callee_method_names": ["String.length", "TranscriptSequence.setAccession"], "method_name": "SequenceTestUtils.transcriptFromSequence", "method_implementation": "{\n    GeneSequence gene = fromSequence(chromosomeSequence, 1, chromosomeSequence.length(), strand);\n    TranscriptSequence ts = new TranscriptSequence(gene, new AccessionID(\"Transcript\"), bioStart, bioEnd);\n    ts.setAccession(new AccessionID(\"Transcript1\"));\n    return ts;\n}", "repo_id": "9", "comment": "/**\n * Creates a transcript from coordinates on the supplied chromosome sequence.\n * The GeneSequence is set to same length as Chromosomal sequence for simplicity.\n *\n * @param chromosomeSequence\n * @param bioStart\n * @param bioEnd\n * @param strand\n * @return\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 3232, "method_signature": "TranscriptSequence transcriptFromSequence(String, int, int, Strand)"}, "1634": {"callee_method_names": [], "method_name": "SubunitClustererParameters.isInternalSymmetry", "method_implementation": "{\n    return internalSymmetry;\n}", "repo_id": "9", "comment": "/**\n * The internal symmetry option divides each {@link Subunit} of each\n * {@link SubunitCluster} into its internally symmetric repeats.\n * <p>\n * The {@link SubunitClustererMethod#STRUCTURE} must be chosen to consider\n * internal symmetry, otherwise this parameter will be ignored.\n *\n * @return true if internal symmetry is considered, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 1634, "method_signature": "boolean isInternalSymmetry()"}, "2271": {"callee_method_ids": [641, 1318], "callee_method_names": ["AtomCache.setFiletype", "FileParsingParameters.setHeaderOnly", "AtomCache.setFileParsingParams", "Structure.getChain", "Chain.getAtoms", "Block.toPDB"], "method_name": "TestWriteLargeCoordinatePDB.TestWrite5D9Q", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.PDB);\n    FileParsingParameters params = new FileParsingParameters();\n    params.setHeaderOnly(false);\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    // Example structure with large coordinates in PDB file.\n    Structure sPDB = StructureIO.getStructure(\"5D9Q\");\n    // If 48 column for a ATOM/HETATM has a comma, fail.\n    for (Group g : sPDB.getChain(\"K\").getAtomGroups()) {\n        for (Atom a : g.getAtoms()) {\n            if (a.toPDB().contains(\",\")) {\n                fail(\"Comma present in ATOM/HETATM record.\");\n            }\n        }\n    }\n    //try (PrintWriter p = new PrintWriter(new FileWriter(new File(\"/tmp/test.pdb\")))) {\n    //\tp.print(sPDB.toPDB());\n    //}\n}", "repo_id": "9", "comment": "// See FileConvert.d3 formatter.\n", "repo_name": "biojava-master/", "id": 2271, "method_signature": "void TestWrite5D9Q()"}, "2565": {"callee_method_names": [], "method_name": "CRC64Checksum.update", "method_implementation": "{\n    if (b == null) {\n        throw new IllegalArgumentException(\"byte array cannot be null\");\n    }\n    if (offset < 0 || length < 0 || offset > b.length - length) {\n        throw new IllegalArgumentException(\"Offset and length must be non-negative\" + \" and their sum cannot be greater than length of byte array\");\n    }\n    for (int i = offset; i < length + offset; ++i) update(b[i]);\n}", "repo_id": "9", "comment": "/**\n * Updates the CRC-64 checksum with the specified array of bytes.\n * <br/>\n * Note that BioJava before version 6.0 implemented this method incorrectly,\n * using {@code length} as an index.\n *\n * @throws IllegalArgumentException\n *         if {@code offset} is negative, or {@code length} is negative, or\n *         {@code offset+length} is negative or greater than the length of\n *         the array {@code b}.\n */\n", "repo_name": "biojava-master/", "id": 2565, "method_signature": "void update(byte[], int, int)"}, "168": {"callee_method_names": ["ScopDatabase.getByCategory", "ScopDatabase.getScopVersion", "List<ScopDescription>.size", "List<ScopDescription>.isEmpty", "ScopDatabase.getByCategory", "List<ScopDescription>.isEmpty", "ScopDatabase.getScopVersion", "List<ScopDescription>.size"], "method_name": "ScopDatabaseTest.testCategories", "method_implementation": "{\n    List<ScopDescription> superfams = scop.getByCategory(ScopCategory.Superfamily);\n    assertNotNull(tag, superfams);\n    if (scop.getScopVersion().compareToIgnoreCase(ScopFactory.VERSION_1_75) == 0) {\n        assertEquals(tag, 2223, superfams.size());\n    } else {\n        // defaults for other versions\n        assertFalse(tag, superfams.isEmpty());\n    }\n    List<ScopDescription> folds = scop.getByCategory(ScopCategory.Fold);\n    assertNotNull(tag, folds);\n    assertFalse(tag, folds.isEmpty());\n    if (scop.getScopVersion().compareToIgnoreCase(ScopFactory.VERSION_1_75) == 0) {\n        assertEquals(tag, 1393, folds.size());\n    }\n}", "repo_id": "9", "comment": "/**\n * Get various categories\n */\n", "repo_name": "biojava-master/", "id": 168, "method_signature": "void testCategories()"}, "3111": {"callee_method_names": [], "method_name": "QuantityFeature.getQuantities", "method_implementation": "{\n    return quantities;\n}", "repo_id": "9", "comment": "/**\n * @return the quantities\n */\n", "repo_name": "biojava-master/", "id": 3111, "method_signature": "List<Number> getQuantities()"}, "2657": {"callee_method_names": [], "method_name": "TranscriptionEngine.getDnaCompounds", "method_implementation": "{\n    if (dnaCompounds != null) {\n        return dnaCompounds;\n    }\n    return AmbiguityDNACompoundSet.getDNACompoundSet();\n}", "repo_id": "9", "comment": "// ------ INTERNAL BUILDERS with defaults if exists\n", "repo_name": "biojava-master/", "id": 2657, "method_signature": "CompoundSet<NucleotideCompound> getDnaCompounds()"}, "1926": {"callee_method_names": [], "method_name": "QuatSymmetryResults.getRotationGroup", "method_implementation": "{\n    return rotationGroup;\n}", "repo_id": "9", "comment": "/**\n * @return rotation group (point group) information representing rotational\n *         quaternary symmetry.\n */\n", "repo_name": "biojava-master/", "id": 1926, "method_signature": "RotationGroup getRotationGroup()"}, "3673": {"callee_method_names": [], "method_name": "SurvivalInfo.getTime", "method_implementation": "{\n    return time;\n}", "repo_id": "9", "comment": "/**\n * @return the time\n */\n", "repo_name": "biojava-master/", "id": 3673, "method_signature": "double getTime()"}, "1208": {"callee_method_names": ["CifStructureConsumer.prepare", "CifFile.as", "CifStructureConsumer.consumeAuditAuthor", "MmCifBlock.getAuditAuthor", "CifStructureConsumer.consumeAtomSite", "MmCifBlock.getAtomSite", "CifStructureConsumer.consumeAtomSites", "MmCifBlock.getAtomSites", "CifStructureConsumer.consumeCell", "MmCifBlock.getCell", "CifStructureConsumer.consumeChemComp", "MmCifBlock.getChemComp", "CifStructureConsumer.consumeChemCompBond", "MmCifBlock.getChemCompBond", "CifStructureConsumer.consumeDatabasePDBRemark", "MmCifBlock.getDatabasePDBRemark", "CifStructureConsumer.consumeDatabasePDBRev", "MmCifBlock.getDatabasePDBRev", "CifStructureConsumer.consumeDatabasePDBRevRecord", "MmCifBlock.getDatabasePDBRevRecord", "CifStructureConsumer.consumeEm3dReconstruction", "MmCifBlock.getEm3dReconstruction", "CifStructureConsumer.consumeEntity", "MmCifBlock.getEntity", "CifStructureConsumer.consumeEntityPoly", "MmCifBlock.getEntityPoly", "CifStructureConsumer.consumeEntitySrcGen", "MmCifBlock.getEntitySrcGen", "CifStructureConsumer.consumeEntitySrcNat", "MmCifBlock.getEntitySrcNat", "CifStructureConsumer.consumeEntitySrcSyn", "MmCifBlock.getPdbxEntitySrcSyn", "CifStructureConsumer.consumeEntityPolySeq", "MmCifBlock.getEntityPolySeq", "CifStructureConsumer.consumeExptl", "MmCifBlock.getExptl", "CifStructureConsumer.consumePdbxAuditRevisionHistory", "MmCifBlock.getPdbxAuditRevisionHistory", "CifStructureConsumer.consumePdbxChemCompIdentifier", "MmCifBlock.getPdbxChemCompIdentifier", "CifStructureConsumer.consumePdbxDatabaseStatus", "MmCifBlock.getPdbxDatabaseStatus", "CifStructureConsumer.consumePdbxEntityBranchDescriptor", "MmCifBlock.getPdbxEntityBranchDescriptor", "CifStructureConsumer.consumePdbxMolecule", "MmCifBlock.getPdbxMolecule", "CifStructureConsumer.consumePdbxMoleculeFeatures", "MmCifBlock.getPdbxMoleculeFeatures", "CifStructureConsumer.consumePdbxNonpolyScheme", "MmCifBlock.getPdbxNonpolyScheme", "CifStructureConsumer.consumePdbxReferenceEntityLink", "MmCifBlock.getPdbxReferenceEntityLink", "CifStructureConsumer.consumePdbxReferenceEntityList", "MmCifBlock.getPdbxReferenceEntityList", "CifStructureConsumer.consumePdbxReferenceEntityPolyLink", "MmCifBlock.getPdbxReferenceEntityPolyLink", "CifStructureConsumer.consumePdbxStructAssembly", "MmCifBlock.getPdbxStructAssembly", "CifStructureConsumer.consumePdbxStructAssemblyGen", "MmCifBlock.getPdbxStructAssemblyGen", "CifStructureConsumer.consumePdbxStructModResidue", "MmCifBlock.getPdbxStructModResidue", "CifStructureConsumer.consumePdbxStructOperList", "MmCifBlock.getPdbxStructOperList", "CifStructureConsumer.consumeRefine", "MmCifBlock.getRefine", "CifStructureConsumer.consumeStruct", "MmCifBlock.getStruct", "CifStructureConsumer.consumeStructAsym", "MmCifBlock.getStructAsym", "CifStructureConsumer.consumeStructConf", "MmCifBlock.getStructConf", "CifStructureConsumer.consumeStructConn", "MmCifBlock.getStructConn", "CifStructureConsumer.consumeStructConnType", "MmCifBlock.getStructConnType", "CifStructureConsumer.consumeStructKeywords", "MmCifBlock.getStructKeywords", "CifStructureConsumer.consumeStructNcsOper", "MmCifBlock.getStructNcsOper", "CifStructureConsumer.consumeStructRef", "MmCifBlock.getStructRef", "CifStructureConsumer.consumeStructRefSeq", "MmCifBlock.getStructRefSeq", "CifStructureConsumer.consumeStructRefSeqDif", "MmCifBlock.getStructRefSeqDif", "CifStructureConsumer.consumeStructSheetRange", "MmCifBlock.getStructSheetRange", "CifStructureConsumer.consumeStructSite", "MmCifBlock.getStructSite", "CifStructureConsumer.consumeStructSiteGen", "MmCifBlock.getStructSiteGen", "CifStructureConsumer.consumeSymmetry", "MmCifBlock.getSymmetry", "CifStructureConsumer.finish", "CifStructureConsumer.getContainer"], "method_name": "CifStructureConverter.fromCifFile", "method_implementation": "{\n    // initialize consumer\n    CifStructureConsumer consumer = new CifStructureConsumerImpl(parameters);\n    // init structure\n    consumer.prepare();\n    // feed individual categories to consumer\n    MmCifBlock cifBlock = cifFile.as(StandardSchemata.MMCIF).getFirstBlock();\n    consumer.consumeAuditAuthor(cifBlock.getAuditAuthor());\n    consumer.consumeAtomSite(cifBlock.getAtomSite());\n    consumer.consumeAtomSites(cifBlock.getAtomSites());\n    consumer.consumeCell(cifBlock.getCell());\n    consumer.consumeChemComp(cifBlock.getChemComp());\n    consumer.consumeChemCompBond(cifBlock.getChemCompBond());\n    consumer.consumeDatabasePDBRemark(cifBlock.getDatabasePDBRemark());\n    consumer.consumeDatabasePDBRev(cifBlock.getDatabasePDBRev());\n    consumer.consumeDatabasePDBRevRecord(cifBlock.getDatabasePDBRevRecord());\n    consumer.consumeEm3dReconstruction(cifBlock.getEm3dReconstruction());\n    consumer.consumeEntity(cifBlock.getEntity());\n    consumer.consumeEntityPoly(cifBlock.getEntityPoly());\n    consumer.consumeEntitySrcGen(cifBlock.getEntitySrcGen());\n    consumer.consumeEntitySrcNat(cifBlock.getEntitySrcNat());\n    consumer.consumeEntitySrcSyn(cifBlock.getPdbxEntitySrcSyn());\n    consumer.consumeEntityPolySeq(cifBlock.getEntityPolySeq());\n    consumer.consumeExptl(cifBlock.getExptl());\n    consumer.consumePdbxAuditRevisionHistory(cifBlock.getPdbxAuditRevisionHistory());\n    consumer.consumePdbxChemCompIdentifier(cifBlock.getPdbxChemCompIdentifier());\n    consumer.consumePdbxDatabaseStatus(cifBlock.getPdbxDatabaseStatus());\n    consumer.consumePdbxEntityBranchDescriptor(cifBlock.getPdbxEntityBranchDescriptor());\n    consumer.consumePdbxMolecule(cifBlock.getPdbxMolecule());\n    consumer.consumePdbxMoleculeFeatures(cifBlock.getPdbxMoleculeFeatures());\n    consumer.consumePdbxNonpolyScheme(cifBlock.getPdbxNonpolyScheme());\n    consumer.consumePdbxReferenceEntityLink(cifBlock.getPdbxReferenceEntityLink());\n    consumer.consumePdbxReferenceEntityList(cifBlock.getPdbxReferenceEntityList());\n    consumer.consumePdbxReferenceEntityPolyLink(cifBlock.getPdbxReferenceEntityPolyLink());\n    consumer.consumePdbxStructAssembly(cifBlock.getPdbxStructAssembly());\n    consumer.consumePdbxStructAssemblyGen(cifBlock.getPdbxStructAssemblyGen());\n    consumer.consumePdbxStructModResidue(cifBlock.getPdbxStructModResidue());\n    consumer.consumePdbxStructOperList(cifBlock.getPdbxStructOperList());\n    consumer.consumeRefine(cifBlock.getRefine());\n    consumer.consumeStruct(cifBlock.getStruct());\n    consumer.consumeStructAsym(cifBlock.getStructAsym());\n    consumer.consumeStructConf(cifBlock.getStructConf());\n    consumer.consumeStructConn(cifBlock.getStructConn());\n    consumer.consumeStructConnType(cifBlock.getStructConnType());\n    consumer.consumeStructKeywords(cifBlock.getStructKeywords());\n    consumer.consumeStructNcsOper(cifBlock.getStructNcsOper());\n    consumer.consumeStructRef(cifBlock.getStructRef());\n    consumer.consumeStructRefSeq(cifBlock.getStructRefSeq());\n    consumer.consumeStructRefSeqDif(cifBlock.getStructRefSeqDif());\n    consumer.consumeStructSheetRange(cifBlock.getStructSheetRange());\n    consumer.consumeStructSite(cifBlock.getStructSite());\n    consumer.consumeStructSiteGen(cifBlock.getStructSiteGen());\n    consumer.consumeSymmetry(cifBlock.getSymmetry());\n    // prepare structure to be retrieved\n    consumer.finish();\n    return consumer.getContainer();\n}", "repo_id": "9", "comment": "/**\n * Convert CifFile to Structure.\n * @param cifFile the source\n * @param parameters parameters for parsing\n * @return the target\n */\n", "repo_name": "biojava-master/", "id": 1208, "method_signature": "Structure fromCifFile(CifFile, FileParsingParameters)"}, "3393": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.hideAxes", "method_implementation": "{\n    return \"draw axes* off;\";\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#hideAxes()\n\t */\n", "repo_name": "biojava-master/", "id": 3393, "method_signature": "String hideAxes()"}, "2550": {"callee_method_names": ["Object.getClass"], "method_name": "Hit.equals", "method_implementation": "{\n    if (obj == null) {\n        return false;\n    }\n    if (getClass() != obj.getClass()) {\n        return false;\n    }\n    final Hit other = (Hit) obj;\n    if (this.hitLen != other.hitLen) {\n        return false;\n    }\n    if (this.hsps != other.hsps && (this.hsps == null || !this.hsps.equals(other.hsps))) {\n        return false;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Implements conceptual comparisons of search results.\n * Fields unrelated to search are deliberately not considered.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2550, "method_signature": "boolean equals(Object)"}, "827": {"callee_method_names": ["Structure.clone", "Matrix.print", "Structure.setPdbId", "Structure.setName", "Structure.addModel", "Structure.getChains", "Structure.addModel", "Structure.getChains"], "method_name": "AlternativeAlignment.getAlignedStructure", "method_implementation": "{\n    // do not change the original coords ..\n    Structure s3 = s2.clone();\n    currentRotMatrix.print(3, 3);\n    Calc.rotate(s3, currentRotMatrix);\n    Calc.shift(s3, currentTranMatrix);\n    Structure newpdb = new StructureImpl();\n    newpdb.setPdbId(null);\n    newpdb.setName(\"Aligned with BioJava\");\n    newpdb.addModel(s1.getChains(0));\n    newpdb.addModel(s3.getChains(0));\n    return newpdb;\n}", "repo_id": "9", "comment": "/**\n * create an artifical Structure object that contains the two\n * structures superimposed onto each other. Each structure is in a separate model.\n * Model 1 is structure 1 and Model 2 is structure 2.\n *\n * @param s1 the first structure. its coordinates will not be changed\n * @param s2 the second structure, it will be cloned and the cloned coordinates will be rotated according to the alignment results.\n * @return composite structure containing the 2 aligned structures as a models 1 and 2\n */\n", "repo_name": "biojava-master/", "id": 827, "method_signature": "Structure getAlignedStructure(Structure, Structure)"}, "3342": {"callee_method_names": ["Color.getRed", "Color.getGreen", "Color.getBlue", "Color.getAlpha"], "method_name": "ColorUtils.lighter", "method_implementation": "{\n    int red = (int) Math.round(color.getRed() * (1.0 + fraction));\n    int green = (int) Math.round(color.getGreen() * (1.0 + fraction));\n    int blue = (int) Math.round(color.getBlue() * (1.0 + fraction));\n    if (red < 0)\n        red = 0;\n    else if (red > 255)\n        red = 255;\n    if (green < 0)\n        green = 0;\n    else if (green > 255)\n        green = 255;\n    if (blue < 0)\n        blue = 0;\n    else if (blue > 255)\n        blue = 255;\n    int alpha = color.getAlpha();\n    return new Color(red, green, blue, alpha);\n}", "repo_id": "9", "comment": "/**\n * Make a color lighter. (RGB color scheme)\n *\n * @param color     Color to make lighter.\n * @param fraction  Darkness fraction.\n * @return          Lighter color.\n */\n", "repo_name": "biojava-master/", "id": 3342, "method_signature": "Color lighter(Color, double)"}, "2553": {"callee_method_names": [], "method_name": "BlastTabularParser.setQueryReferences", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported for this parser.\");\n}", "repo_id": "9", "comment": "/**\n * Intended for use with run module.\n * Although possible, does not make a lot of sense to have it with limited\n * information such those in tabular report\n * @param sequences\n */\n", "repo_name": "biojava-master/", "id": 2553, "method_signature": "void setQueryReferences(List)"}, "703": {"callee_method_names": ["BlockSet.getCoreLength"], "method_name": "MultipleAlignmentImpl.updateCoreLength", "method_implementation": "{\n    if (getBlockSets().size() == 0) {\n        throw new IndexOutOfBoundsException(\"Empty MultipleAlignment: blockSets size == 0.\");\n    } else // Otherwise try to calculate it from the BlockSet information\n    {\n        coreLength = 0;\n        for (BlockSet blockSet : blockSets) coreLength += blockSet.getCoreLength();\n    }\n}", "repo_id": "9", "comment": "/**\n * Force recalculation of the core length (ungapped columns) based on the\n * BlockSet core lengths.\n */\n", "repo_name": "biojava-master/", "id": 703, "method_signature": "void updateCoreLength()"}, "2564": {"callee_method_names": ["SoftHashMap.clear"], "method_name": "FlatFileCache.clear", "method_implementation": "{\n    cache.clear();\n}", "repo_id": "9", "comment": "/**\n * Removes all elements from the cache\n */\n", "repo_name": "biojava-master/", "id": 2564, "method_signature": "void clear()"}, "3074": {"callee_method_names": ["String.length", "String.charAt", "CompoundSet<NucleotideCompound>.getCompoundForString", "StringBuilder.append", "NucleotideCompound.getComplement", "StringBuilder.toString", "String.toUpperCase", "DNASequence.setAccession", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "GeneSequence.getSequence5PrimeTo3Prime", "method_implementation": "{\n    String sequence = getSequenceAsString(this.getBioBegin(), this.getBioEnd(), this.getStrand());\n    if (getStrand() == Strand.NEGATIVE) {\n        //need to take complement of sequence because it is negative and we are returning the gene sequence from the opposite strand\n        StringBuilder b = new StringBuilder(getLength());\n        CompoundSet<NucleotideCompound> compoundSet = this.getCompoundSet();\n        for (int i = 0; i < sequence.length(); i++) {\n            String nucleotide = String.valueOf(sequence.charAt(i));\n            NucleotideCompound nucleotideCompound = compoundSet.getCompoundForString(nucleotide);\n            b.append(nucleotideCompound.getComplement().getShortName());\n        }\n        sequence = b.toString();\n    }\n    DNASequence dnaSequence = null;\n    try {\n        dnaSequence = new DNASequence(sequence.toUpperCase());\n        dnaSequence.setAccession(new AccessionID(this.getAccession().getID()));\n    } catch (CompoundNotFoundException e) {\n        // this should not happen, the sequence is DNA originally, if it does, there's a bug somewhere\n        logger.error(\"Could not create new DNA sequence in getSequence5PrimeTo3Prime(). Error: {}\", e.getMessage());\n    }\n    return dnaSequence;\n}", "repo_id": "9", "comment": "/**\n * Try to give method clarity where you want a DNASequence coding in the 5' to 3' direction\n * Returns the DNASequence representative of the 5' and 3' reading based on strand\n * @return dna sequence or null if sequence could not be generated.\n */\n", "repo_name": "biojava-master/", "id": 3074, "method_signature": "DNASequence getSequence5PrimeTo3Prime()"}, "2312": {"callee_method_names": ["Matrix4d.rotX", "Matrix4d.rotY", "Matrix4d.rotZ"], "method_name": "TestUnitQuaternions.testOrientationMetricIncrement", "method_implementation": "{\n    // The rotation increment will be Pi/10, Pi/15 and Pi/12 degrees in X,Y\n    // and Z\n    Matrix4d transform = new Matrix4d();\n    transform.rotX(Math.PI / 10);\n    transform.rotY(Math.PI / 12);\n    transform.rotZ(Math.PI / 15);\n    // Get points from a structure.\n    Structure pdb = StructureIO.getStructure(\"4hhb.A\");\n    Point3d[] cloud = Calc.atomsToPoints(StructureTools.getRepresentativeAtomArray(pdb));\n    Point3d[] cloud2 = CalcPoint.clonePoint3dArray(cloud);\n    // Center the clouds at the origin\n    CalcPoint.center(cloud);\n    CalcPoint.center(cloud2);\n    // Their orientation is equal at this stage\n    double m0 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertEquals(m0, 0.0, 0.001);\n    // Assert it keeps incrementing every time transform is applied\n    CalcPoint.transform(transform, cloud2);\n    double m1 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertTrue(m1 > m0);\n    CalcPoint.transform(transform, cloud2);\n    double m2 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertTrue(m2 > m1);\n    CalcPoint.transform(transform, cloud2);\n    double m3 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertTrue(m3 > m2);\n    CalcPoint.transform(transform, cloud2);\n    double m4 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertTrue(m4 > m3);\n    CalcPoint.transform(transform, cloud2);\n    double m5 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertTrue(m5 > m4);\n    CalcPoint.transform(transform, cloud2);\n    double m6 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertTrue(m6 > m5);\n    CalcPoint.transform(transform, cloud2);\n    double m7 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertTrue(m7 > m6);\n    CalcPoint.transform(transform, cloud2);\n    double m8 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertTrue(m8 > m7);\n    CalcPoint.transform(transform, cloud2);\n    double m9 = UnitQuaternions.orientationMetric(cloud, cloud2);\n    assertTrue(m9 > m8);\n}", "repo_id": "9", "comment": "/**\n * Test {@link UnitQuaternions#orientationMetric(Point3d[], Point3d[])} on a\n * real structure, which will be deviating a little bit every time.\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2312, "method_signature": "void testOrientationMetricIncrement()"}, "1013": {"callee_method_names": [], "method_name": "NucleotideImpl.getP", "method_implementation": "{\n    return getAtom(\"P\");\n}", "repo_id": "9", "comment": "/**\n * Returns the P atom if present, otherwise null\n * @return P atom or null\n */\n", "repo_name": "biojava-master/", "id": 1013, "method_signature": "Atom getP()"}, "1939": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setMinRmsd", "method_implementation": "{\n    this.minRmsd = minRmsd;\n}", "repo_id": "9", "comment": "/**\n * @param minRmsd the minRmsd to set\n */\n", "repo_name": "biojava-master/", "id": 1939, "method_signature": "void setMinRmsd(double)"}, "1975": {"callee_method_names": ["Vector3d.dot", "Vector3d.cross", "Vector3d.normalize", "AxisAngle4d.set", "Vector3d.angle", "Matrix4d.set", "Matrix4d.setElement", "Matrix4d.setIdentity", "Matrix4d.set", "Matrix4d.transform", "Matrix4d.transform", "Vector3d.dot", "Vector3d.cross", "Vector3d.normalize", "AxisAngle4d.set", "Vector3d.angle", "Matrix4d.set", "Matrix4d.setElement", "Matrix4d.setIdentity", "Matrix4d.set", "Matrix4d.transform", "Matrix4d.transform", "Matrix4d.mul", "Logger.warn"], "method_name": "HelixAxisAligner.alignAxes", "method_implementation": "{\n    Matrix4d m1 = new Matrix4d();\n    AxisAngle4d a = new AxisAngle4d();\n    Vector3d axis = new Vector3d();\n    // calculate rotation matrix to rotate refPoints[0] into coordPoints[0]\n    Vector3d v1 = new Vector3d(axisVectors[0]);\n    Vector3d v2 = new Vector3d(referenceVectors[0]);\n    double dot = v1.dot(v2);\n    if (Math.abs(dot) < 0.999) {\n        axis.cross(v1, v2);\n        axis.normalize();\n        a.set(axis, v1.angle(v2));\n        m1.set(a);\n        // make sure matrix element m33 is 1.0. It's 0 on Linux.\n        m1.setElement(3, 3, 1.0);\n    } else if (dot > 0) {\n        // parallel axis, nothing to do -> identity matrix\n        m1.setIdentity();\n    } else if (dot < 0) {\n        // anti-parallel axis, flip around x-axis\n        m1.set(flipX());\n    }\n    // apply transformation matrix to all refPoints\n    m1.transform(axisVectors[0]);\n    m1.transform(axisVectors[1]);\n    // calculate rotation matrix to rotate refPoints[1] into coordPoints[1]\n    v1 = new Vector3d(axisVectors[1]);\n    v2 = new Vector3d(referenceVectors[1]);\n    Matrix4d m2 = new Matrix4d();\n    dot = v1.dot(v2);\n    if (Math.abs(dot) < 0.999) {\n        axis.cross(v1, v2);\n        axis.normalize();\n        a.set(axis, v1.angle(v2));\n        m2.set(a);\n        // make sure matrix element m33 is 1.0. It's 0 on Linux.\n        m2.setElement(3, 3, 1.0);\n    } else if (dot > 0) {\n        // parallel axis, nothing to do -> identity matrix\n        m2.setIdentity();\n    } else if (dot < 0) {\n        // anti-parallel axis, flip around z-axis\n        m2.set(flipZ());\n    }\n    // apply transformation matrix to all refPoints\n    m2.transform(axisVectors[0]);\n    m2.transform(axisVectors[1]);\n    // combine the two rotation matrices\n    m2.mul(m1);\n    // the RMSD should be close to zero\n    Point3d[] axes = new Point3d[2];\n    axes[0] = new Point3d(axisVectors[0]);\n    axes[1] = new Point3d(axisVectors[1]);\n    Point3d[] ref = new Point3d[2];\n    ref[0] = new Point3d(referenceVectors[0]);\n    ref[1] = new Point3d(referenceVectors[1]);\n    if (CalcPoint.rmsd(axes, ref) > 0.1) {\n        logger.warn(\"AxisTransformation: axes alignment is off. RMSD: \" + CalcPoint.rmsd(axes, ref));\n    }\n    return m2;\n}", "repo_id": "9", "comment": "/**\n * Returns a transformation matrix that rotates refPoints to match\n * coordPoints\n * @param refPoints the points to be aligned\n * @param referenceVectors\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1975, "method_signature": "Matrix4d alignAxes(Vector3d[], Vector3d[])"}, "2233": {"callee_method_names": ["SimpleDateFormat.parse", "Structure.getPDBHeader", "SimpleDateFormat.parse", "Structure.getPDBHeader", "SimpleDateFormat.parse", "Structure.getPDBHeader"], "method_name": "CifFileConsumerImplTest.testDatesV4", "method_implementation": "{\n    InputStream inputStream = getClass().getResourceAsStream(\"/org/biojava/nbio/structure/io/mmcif/1stp_v4.cif\");\n    Objects.requireNonNull(inputStream, \"could not acquire test resource /org/biojava/nbio/structure/io/mmcif/1stp_v4.cif\");\n    Structure s = new CifFileReader().getStructure(inputStream);\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.US);\n    Date modDate = dateFormat.parse(\"2011-07-13\");\n    assertEquals(modDate, s.getPDBHeader().getModDate());\n    Date releaseDate = dateFormat.parse(\"1992-10-15\");\n    assertEquals(releaseDate, s.getPDBHeader().getRelDate());\n    Date depositionDate = dateFormat.parse(\"1992-03-12\");\n    assertEquals(depositionDate, s.getPDBHeader().getDepDate());\n}", "repo_id": "9", "comment": "/**\n * Test parsing dates from MMCIF file version 4.\n */\n", "repo_name": "biojava-master/", "id": 2233, "method_signature": "void testDatesV4()"}, "2628": {"callee_method_names": ["HashMap.containsKey", "ArrayList.add"], "method_name": "PrettyXMLWriter.declareNamespace", "method_implementation": "{\n    if (!namespacePrefixes.containsKey(nsURI)) {\n        if (isOpeningTag) {\n            String prefix = allocPrefix(nsURI);\n            attribute(\"xmlns:\" + prefix, nsURI);\n        } else {\n            namespacesDeclared.add(nsURI);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Declare a namespace for current and following elements\n * 'prefixHint' is ignored entirely in this implementation\n */\n", "repo_name": "biojava-master/", "id": 2628, "method_signature": "void declareNamespace(String, String)"}, "3752": {"callee_method_ids": [3700], "callee_method_names": ["LinkedHashMap.keySet", "LinkedHashMap.get", "HeaderInfo.isHide", "ArrayList<String>.add"], "method_name": "WorkSheet.getColumns", "method_implementation": "{\n    ArrayList<String> columns = new ArrayList<String>();\n    for (String col : columnLookup.keySet()) {\n        HeaderInfo hi = columnLookup.get(col);\n        if (!hi.isHide()) {\n            columns.add(col);\n        }\n    }\n    return columns;\n}", "repo_id": "9", "comment": "/**\n * Get the list of column names. Does not include hidden columns\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3752, "method_signature": "ArrayList<String> getColumns()"}, "1375": {"callee_method_names": [], "method_name": "DBRef.setChainName", "method_implementation": "{\n    this.chainName = chainName;\n}", "repo_id": "9", "comment": "/**\n * The name of the corresponding chain.\n *\n * @param chainName the name of the corresponding chain\n * @see #getChainName()\n */\n", "repo_name": "biojava-master/", "id": 1375, "method_signature": "void setChainName(String)"}, "24": {"callee_method_names": ["Set<DatabaseReference>.add"], "method_name": "StockholmSequenceAnnotation.addDBReference", "method_implementation": "{\n    if (this.dbReferences == null) {\n        this.dbReferences = new HashSet<DatabaseReference>();\n    }\n    dbReferences.add(new DatabaseReference(dbReferenceRepresentingString));\n}", "repo_id": "9", "comment": "/**\n * @param dbReference the string without the initial annotation identifier ( #=GS DR )\n */\n", "repo_name": "biojava-master/", "id": 24, "method_signature": "void addDBReference(String)"}, "3650": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "SurvivalInfo.getContinuousVariable", "method_implementation": "{\n    return data.get(variable);\n}", "repo_id": "9", "comment": "/**\n * @param variable\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3650, "method_signature": "Double getContinuousVariable(String)"}, "102": {"callee_method_names": [], "method_name": "Comparison.isGap", "method_implementation": "{\n    return (c == '-' || c == '.' || c == ' ') ? true : false;\n}", "repo_id": "9", "comment": "/**\n * Method that determines if a character means a gap in the alignment.\n *\n * @param c\n *            gap character is one of the symbols in {' ','-','.'}\n *\n * @return true if it is a gap, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 102, "method_signature": "boolean isGap(char)"}, "2864": {"callee_method_names": [], "method_name": "ABITrace.getTrace", "method_implementation": "{\n    if (\"A\".equals(base)) {\n        return A;\n    } else if (\"C\".equals(base)) {\n        return C;\n    } else if (\"G\".equals(base)) {\n        return G;\n    } else if (\"T\".equals(base)) {\n        return T;\n    } else {\n        throw new CompoundNotFoundException(\"Don't know base: \" + base);\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns one of the four traces - all of the y-coordinate values,\n * each of which correspond to a single x-coordinate relative to the\n * position in the array, so that if element 4 in the array is 972, then\n * x is 4 and y is 972 for that point.\n *\n * @param base - the DNA String to retrieve the trace values for\n * @return an array of ints giving the entire trace for that base\n * @throws CompoundNotFoundException if the base is not valid\n */\n", "repo_name": "biojava-master/", "id": 2864, "method_signature": "int[] getTrace(String)"}, "1980": {"callee_method_names": ["Logger.warn"], "method_name": "HelixAxisAligner.calcReferenceVector", "method_implementation": "{\n    referenceVector = getReferenceAxisCylic();\n    if (referenceVector == null) {\n        logger.warn(\"no reference vector found. Using y-axis.\");\n        referenceVector = new Vector3d(Y_AXIS);\n    }\n    // make sure reference vector is perpendicular principal roation vector\n    referenceVector = orthogonalize(principalRotationVector, referenceVector);\n}", "repo_id": "9", "comment": "/**\n * Returns a vector perpendicular to the principal rotation vector\n * for the alignment of structures in the xy-plane\n * @return reference vector\n */\n", "repo_name": "biojava-master/", "id": 1980, "method_signature": "void calcReferenceVector()"}, "2162": {"callee_method_names": [], "method_name": "StructureImpl.getPDBCode", "method_implementation": "{\n    if (pdbId == null)\n        return null;\n    return this.pdbId.getId();\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n * @deprecated use {@link #getPdbId()} to get a {@link PdbId} object or getPdbId().getId() to get a {@link String}\n */\n", "repo_name": "biojava-master/", "id": 2162, "method_signature": "String getPDBCode()"}, "33": {"callee_method_names": [], "method_name": "StockholmFileAnnotation.getGatheringThreshs", "method_implementation": "{\n    return gatheringThreshs;\n}", "repo_id": "9", "comment": "/**\n * Not always 2.<br>\n *  It may undergo further change.\n *  @return\n */\n", "repo_name": "biojava-master/", "id": 33, "method_signature": "float[] getGatheringThreshs()"}, "3734": {"callee_method_names": ["ArrayList<String>.size", "ArrayList<String>.size", "ArrayList<String>.get", "LinkedHashMap.put", "ArrayList<String>.get"], "method_name": "WorkSheet.addRows", "method_implementation": "{\n    CompactCharSequence dv = new CompactCharSequence(defaultValue);\n    int oldlength = data.length;\n    int numColumns = 0;\n    if (data.length > 0 && data[0] != null) {\n        numColumns = data[0].length;\n    }\n    data = (CompactCharSequence[][]) resizeArray(data, data.length + rows.size());\n    for (int r = 0; r < rows.size(); r++) {\n        data[oldlength + r] = new CompactCharSequence[numColumns];\n        for (int c = 0; c < numColumns; c++) {\n            data[oldlength + r][c] = dv;\n        }\n        data[oldlength + r][0] = new CompactCharSequence(rows.get(r));\n        rowLookup.put(rows.get(r), new HeaderInfo(r + oldlength));\n    }\n}", "repo_id": "9", "comment": "/**\n * Add rows to the worksheet and fill in default value\n *\n * @param rows\n * @param defaultValue\n */\n", "repo_name": "biojava-master/", "id": 3734, "method_signature": "void addRows(ArrayList, String)"}, "1402": {"callee_method_names": ["String.toUpperCase", "String.toUpperCase"], "method_name": "PdbId.toExtendedId", "method_implementation": "{\n    if (isValidShortPdbId(shortId)) {\n        return PDB_0000 + shortId.toUpperCase();\n    } else if (isValidExtendedPdbId(shortId)) {\n        return shortId.toUpperCase();\n    } else {\n        throw new StructureException(\"Unknown format [\" + shortId + \"]\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Converts <code>shortId</code> to the PDB ID extended format.\n * If <code>shortId</code> is a valid short PDB ID, it would be converted to an extended ID,\n * if <code>shortId</code> is a valid extended PDB ID, it would be returned in UPPER CASE,\n * a {@link StructureException} is thrown otherwise.\n * @param shortId the PDB ID to convert to extended format\n * @return the ID in the extended UPPER CASE format.\n * @throws StructureException if the conversion was not possible.\n */\n", "repo_name": "biojava-master/", "id": 1402, "method_signature": "String toExtendedId(String)"}, "2165": {"callee_method_names": [], "method_name": "StructureImpl.setPdbId", "method_implementation": "{\n    this.pdbId = pdbId;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 2165, "method_signature": "void setPdbId(PdbId)"}, "3313": {"callee_method_names": ["Graphics.setColor", "FragmentPair.getPos1", "FragmentPair.getPos2", "Graphics.drawRect"], "method_name": "JMatrixPanel.drawBoxes", "method_implementation": "{\n    if (fragmentPairs == null)\n        return;\n    g.setColor(Color.yellow);\n    for (int i = 0; i < fragmentPairs.length; i++) {\n        FragmentPair fp = fragmentPairs[i];\n        int xp = fp.getPos1();\n        int yp = fp.getPos2();\n        int width = Math.round(scale);\n        g.drawRect(Math.round(xp * scale), Math.round(yp * scale), width, width);\n    }\n}", "repo_id": "9", "comment": "/**\n * draw high scoring fragments that are used for the initial alignment seed\n * selection\n *\n * @param g\n */\n", "repo_name": "biojava-master/", "id": 3313, "method_signature": "void drawBoxes(Graphics)"}, "1818": {"callee_method_ids": [1822, 1823], "callee_method_names": ["ReadWriteLock.writeLock", "Logger.trace", "EcodParser.getDomains", "EcodParser.getVersion", "Logger.trace", "ReadWriteLock.writeLock"], "method_name": "EcodInstallation.parseDomains", "method_implementation": "{\n    domainsFileLock.writeLock().lock();\n    logger.trace(\"LOCK writelock\");\n    try {\n        EcodParser parser = new EcodParser(getDomainFile());\n        allDomains = parser.getDomains();\n        parsedVersion = parser.getVersion();\n    } finally {\n        logger.trace(\"UNLOCK writelock\");\n        domainsFileLock.writeLock().unlock();\n    }\n}", "repo_id": "9", "comment": "/**\n * Parses the domains from the local file\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1818, "method_signature": "void parseDomains()"}, "1478": {"callee_method_names": ["Matrix3d.getElement", "Matrix4d.getElement", "Matrix4d.getElement"], "method_name": "CrystalCell.checkScaleMatrix", "method_implementation": "{\n    Matrix3d mtranspose = getMTranspose();\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (!deltaComp(mtranspose.getElement(i, j), scaleMatrix.getElement(i, j))) {\n                //System.out.println(\"Our value   (\"+i+\",\"+j+\"): \"+getM().getElement(i,j));\n                //System.out.println(\"Their value (\"+i+\",\"+j+\"): \"+scaleMatrix.getElement(i,j));\n                return false;\n            }\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        if (!deltaComp(scaleMatrix.getElement(i, 3), 0)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Given a scale matrix parsed from a PDB entry (SCALE1,2,3 records),\n * compares it to our calculated Mtranspose matrix to see if they coincide and\n * returns true if they do.\n * If they don't that means that the PDB entry is not in the standard\n * orthogonalisation (NCODE=1 in ccp4).\n * In 2011's remediation only 148 PDB entries were found not to be in\n * a non-standard orthogonalisation. See:\n * http://www.wwpdb.org/documentation/2011remediation_overview-061711.pdf\n * For normal cases the scale matrix is diagonal without a translation component.\n * Additionally the translation component of the SCALE matrix is also checked to\n * make sure it is (0,0,0), if not false is return\n * @param scaleMatrix\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1478, "method_signature": "boolean checkScaleMatrix(Matrix4d)"}, "189": {"callee_method_names": ["List<QuatSymmetryResults>.get", "List<QuatSymmetryResults>.get"], "method_name": "TestQuatSymmetryDetectorExamples.testHelicalLocal", "method_implementation": "{\n    Structure pdb = StructureIO.getStructure(\"BIO:5JLF:1\");\n    SubunitClustererParameters cp = new SubunitClustererParameters();\n    QuatSymmetryParameters symmParams = new QuatSymmetryParameters();\n    List<QuatSymmetryResults> results = QuatSymmetryDetector.calcLocalSymmetries(pdb, symmParams, cp);\n    // H symmetry A5 stoichiometry\n    assertEquals(\"H\", results.get(0).getSymmetry());\n    assertEquals(\"A5\", results.get(0).getStoichiometry().toString());\n}", "repo_id": "9", "comment": "/**\n * A structure with local helical symmetry: 5JLF\n *\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 189, "method_signature": "void testHelicalLocal()"}, "1931": {"callee_method_names": [], "method_name": "QuatSymmetryResults.isLocal", "method_implementation": "{\n    return local;\n}", "repo_id": "9", "comment": "/**\n * A local result means that only a subset of the original Subunits was used\n * for symmetry determination.\n *\n * @return true if local result, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 1931, "method_signature": "boolean isLocal()"}, "2750": {"callee_method_names": [], "method_name": "EmblRecord.getAssemblyInformation", "method_implementation": "{\n    return assemblyInformation;\n}", "repo_id": "9", "comment": "/**\n * The AS (Assembly Information) lines provide information on the composition of\n * a TPA or TSA sequence.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2750, "method_signature": "String getAssemblyInformation()"}, "2073": {"callee_method_ids": [1588, 2057, 2075, 2054], "callee_method_names": ["CESymmParameters.getSSEThreshold", "Atom[].getGroup", "Logger.info", "SecStrucCalc.calculate", "CeSymmIterative.execute", "CeSymmResult.isRefined", "CESymmParameters.getOptimization", "CeSymmResult.getSymmLevels", "SymmOptimizer.optimize", "CeSymmResult.setMultipleAlignment", "Logger.info", "MultipleAlignmentEnsemble.getMessage", "CeSymmResult.getMultipleAlignment", "CeSymmResult.getRepeatsID"], "method_name": "CeSymm.analyze", "method_implementation": "{\n    if (atoms.length < 1)\n        throw new IllegalArgumentException(\"Empty Atom array given.\");\n    // If the SSE information is needed, we calculate it if the user did not\n    if (params.getSSEThreshold() > 0) {\n        Structure s = atoms[0].getGroup().getChain().getStructure();\n        if (SecStrucTools.getSecStrucInfo(s).isEmpty()) {\n            logger.info(\"Calculating Secondary Structure...\");\n            SecStrucCalc ssp = new SecStrucCalc();\n            ssp.calculate(s, true);\n        }\n    }\n    CeSymmIterative iter = new CeSymmIterative(params);\n    CeSymmResult result = iter.execute(atoms);\n    if (result.isRefined()) {\n        // Optimize the global alignment freely once more (final step)\n        if (params.getOptimization() && result.getSymmLevels() > 1) {\n            try {\n                SymmOptimizer optimizer = new SymmOptimizer(result);\n                MultipleAlignment optimized = optimizer.optimize();\n                // Set the optimized MultipleAlignment and the axes\n                result.setMultipleAlignment(optimized);\n            } catch (RefinerFailedException e) {\n                logger.info(\"Final optimization failed:\" + e.getMessage());\n            }\n        }\n        result.getMultipleAlignment().getEnsemble().setStructureIdentifiers(result.getRepeatsID());\n    }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * Analyze the symmetries of the input Atom array using the provided\n * parameters.\n *\n * @param atoms\n *            representative Atom array of the Structure\n * @param param\n *            CeSymmParameters bean\n * @return CeSymmResult\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2073, "method_signature": "CeSymmResult analyze(Atom[], CESymmParameters)"}, "1754": {"callee_method_names": [], "method_name": "MismatchedBasePairParameters.getMaxShear", "method_implementation": "{\n    return maxShear;\n}", "repo_id": "9", "comment": "/**\n * This method returns the maximum shear between bases used as criteria for the characterization of two bases as being paired.\n * @return the maximum shear (in \u00c5) allowed.\n */\n", "repo_name": "biojava-master/", "id": 1754, "method_signature": "double getMaxShear()"}, "3687": {"callee_method_names": ["SurvivalInfo.keySet", "LinkedHashMap<String, LinkedHashMap<String, Double>>.get", "LinkedHashMap<String, LinkedHashMap<String, Double>>.put", "LinkedHashMap<String, Double>.put", "SurvivalInfo.get", "LinkedHashMap<String, LinkedHashMap<String, Double>>.keySet", "LinkedHashMap<String, LinkedHashMap<String, Double>>.get", "LinkedHashMap<String, Double>.keySet", "ArrayList<String>.size", "LinkedHashMap<String, Double>.keySet", "ArrayList<String>.indexOf", "LinkedHashMap<String, Double>.put", "LinkedHashMap<String, Double>.keySet", "ArrayList<String>.indexOf", "LinkedHashMap<String, Double>.put", "LinkedHashMap<String, Double>.keySet", "LinkedHashMap<String, Double>.put", "SurvivalInfo.keySet", "LinkedHashMap<String, LinkedHashMap<String, Double>>.get", "SurvivalInfo.get", "LinkedHashMap<String, Double>.get", "SurvivalInfo.put", "SurvivalInfo.clear"], "method_name": "SurvivalInfoHelper.categorizeData", "method_implementation": "{\n    //Go through and get all variable value pairs\n    LinkedHashMap<String, LinkedHashMap<String, Double>> valueMap = new LinkedHashMap<String, LinkedHashMap<String, Double>>();\n    for (SurvivalInfo si : DataT) {\n        for (String key : si.unknownDataType.keySet()) {\n            LinkedHashMap<String, Double> map = valueMap.get(key);\n            if (map == null) {\n                map = new LinkedHashMap<String, Double>();\n                valueMap.put(key, map);\n            }\n            map.put(si.unknownDataType.get(key), null);\n        }\n    }\n    for (String variable : valueMap.keySet()) {\n        LinkedHashMap<String, Double> values = valueMap.get(variable);\n        if (isCategorical(values)) {\n            ArrayList<String> categories = new ArrayList<String>(values.keySet());\n            //go ahead and put in alphabetical order\n            Collections.sort(categories);\n            if (categories.size() == 2) {\n                for (String value : values.keySet()) {\n                    int index = categories.indexOf(value);\n                    values.put(value, index + 0.0);\n                }\n            } else {\n                for (String value : values.keySet()) {\n                    int index = categories.indexOf(value);\n                    values.put(value, index + 1.0);\n                }\n            }\n        } else {\n            for (String value : values.keySet()) {\n                Double d = Double.parseDouble(value);\n                values.put(value, d);\n            }\n        }\n    }\n    for (SurvivalInfo si : DataT) {\n        for (String key : si.unknownDataType.keySet()) {\n            LinkedHashMap<String, Double> map = valueMap.get(key);\n            String value = si.unknownDataType.get(key);\n            Double d = map.get(value);\n            si.data.put(key, d);\n        }\n    }\n    for (SurvivalInfo si : DataT) {\n        si.unknownDataType.clear();\n    }\n}", "repo_id": "9", "comment": "/**\n * Take a collection of categorical data and convert it to numeric to be used in cox calculations\n * @param DataT\n */\n", "repo_name": "biojava-master/", "id": 3687, "method_signature": "void categorizeData(ArrayList)"}, "721": {"callee_method_names": ["Atom[].getGroup", "Group.getAtom", "Atom[].getName", "List<Atom>.add", "List<Atom>.toArray", "List<Atom>.size"], "method_name": "CECalculator.getAtoms", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<Atom>();\n    for (int i = 0; i < length; i++) {\n        Atom a;\n        if (clone) {\n            Group g = (Group) ca[i].getGroup().clone();\n            a = g.getAtom(ca[i].getName());\n        } else {\n            a = ca[i];\n        }\n        atoms.add(a);\n    }\n    return atoms.toArray(new Atom[atoms.size()]);\n}", "repo_id": "9", "comment": "/**\n * Copies the first length atoms from the input array\n * @param ca The array to copy\n * @param length the number of atoms to copy\n * @param clone If true, preform a deep copy, cloning the underlying Groups\n * @return An array with the first length items of ca, possibly cloning the Atoms.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 721, "method_signature": "Atom[] getAtoms(Atom[], int, boolean)"}, "1993": {"callee_method_ids": [1867], "callee_method_names": ["RotationGroup.getRotation", "Rotation.getAxisAngle"], "method_name": "RotationAxisAligner.calcPrincipalRotationVector", "method_implementation": "{\n    // the rotation around the principal axis is the first rotation\n    Rotation rotation = rotationGroup.getRotation(0);\n    AxisAngle4d axisAngle = rotation.getAxisAngle();\n    principalRotationVector = new Vector3d(axisAngle.x, axisAngle.y, axisAngle.z);\n}", "repo_id": "9", "comment": "/**\n * Returns a vector along the principal rotation axis for the\n * alignment of structures along the z-axis\n * @return principal rotation vector\n */\n", "repo_name": "biojava-master/", "id": 1993, "method_signature": "void calcPrincipalRotationVector()"}, "1088": {"callee_method_names": ["Logger.debug"], "method_name": "AllChemCompProvider.loadAllChemComps", "method_implementation": "{\n    String fileName = getLocalFileName();\n    logger.debug(\"Loading {}\", fileName);\n    dict = ChemCompConverter.fromPath(Paths.get(fileName));\n}", "repo_id": "9", "comment": "/**\n * Load all {@link ChemComp} definitions into memory.\n */\n", "repo_name": "biojava-master/", "id": 1088, "method_signature": "void loadAllChemComps()"}, "2070": {"callee_method_ids": [2069, 2070], "callee_method_names": ["ResidueGroup.order", "ResidueGroup.get", "ResidueGroup.isCompatible", "ResidueGroup.get", "List<Integer>.get", "List<Integer>.get", "ResidueGroup.get"], "method_name": "ResidueGroup.isCompatible", "method_implementation": "{\n    // Same order needed is necessary\n    if (this.order() != other.order())\n        return false;\n    // Use the method of the smallest ResidueGroup\n    if (this.residues.get(0) > other.residues.get(0))\n        return other.isCompatible(this);\n    // Check for intercalation of residues\n    for (int i = 0; i < order() - 1; i++) {\n        if (other.residues.get(i) > residues.get(i + 1))\n            return false;\n        if (residues.get(i) > other.residues.get(i + 1))\n            return false;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Determine if two Residuegroups (maximally connected components of the\n * alignment Graph) are compatible, based in the following criterion:\n *\n * <pre>\n * Two maximally connected components of the self-alignment Graph are\n * compatible if they can be combined in a consistent multiple alignment\n * of repeats, i.e.there exists one residue in c1 between each sorted\n * pair of residues in c2.\n * </pre>\n *\n * Compatibility is an intransitive relation, which means that for three\n * ResidueGroups {A,B,C}, if A is compatible with B and B is compatible with\n * C, then A is not necessarily compatible with C.\n *\n * @param c2\n *            second maximally connected component\n * @return true if compatible, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 2070, "method_signature": "boolean isCompatible(ResidueGroup)"}, "2282": {"callee_method_names": ["Group.getChemComp", "StringBuilder.append", "ChemComp.getOneLetterCode", "StringBuilder.toString"], "method_name": "TestHeaderOnly.getSequenceString", "method_implementation": "{\n    StringBuilder sb = new StringBuilder();\n    for (Group g : seqres) {\n        ChemComp c = g.getChemComp();\n        sb.append(c.getOneLetterCode());\n    }\n    return sb.toString();\n}", "repo_id": "9", "comment": "/**\n * @param seqres : a list of Group(s)\n * @return a String representing these Groups\n */\n", "repo_name": "biojava-master/", "id": 2282, "method_signature": "String getSequenceString(List)"}, "741": {"callee_method_names": [], "method_name": "CeCalculatorEnhanced.zGaps", "method_implementation": "{\n    if (nTrace < 2)\n        return (0.0);\n    double scoreAv_, scoreSd_;\n    if (winSize == 8) {\n        if (nTrace < 21) {\n            scoreAv_ = gapsAv8[nTrace - 1];\n            scoreSd_ = gapsSd8[nTrace - 1];\n        } else {\n            scoreAv_ = 14.949173 * nTrace - 14.581193;\n            scoreSd_ = 2.045067 * nTrace + 13.191095;\n        }\n        if (nGaps > scoreAv_)\n            return (0.0);\n        return ((scoreAv_ - nGaps) / scoreSd_);\n    }\n    if (winSize == 6) {\n        if (nTrace < 21) {\n            scoreAv_ = gapsAv6[nTrace - 1];\n            scoreSd_ = gapsSd6[nTrace - 1];\n        } else {\n            scoreAv_ = 13.574490 * nTrace - 13.977223;\n            scoreSd_ = 1.719977 * nTrace + 19.615014;\n        }\n        if (nGaps > scoreAv_)\n            return (0.0);\n        return ((scoreAv_ - nGaps) / scoreSd_);\n    }\n    return (0.0);\n}", "repo_id": "9", "comment": "///////////////////////////////////////////////////////////////////////////\n", "repo_name": "biojava-master/", "id": 741, "method_signature": "double zGaps(int, int, int)"}, "292": {"callee_method_names": [], "method_name": "ProteinModificationIdentifier.getUnidentifiableModifiedResidues", "method_implementation": "{\n    if (!recordUnidentifiableModifiedCompounds) {\n        throw new UnsupportedOperationException(\"Recording unidentified atom linkages\" + \"is not supported. Please setRecordUnidentifiableCompounds(true) first.\");\n    }\n    if (identifiedModifiedCompounds == null) {\n        throw new IllegalStateException(\"No result available. Please call parse() first.\");\n    }\n    return unidentifiableModifiedResidues;\n}", "repo_id": "9", "comment": "/**\n * @return a set of modified residues that were not covered by\n *  the identified ModifiedCompounds from the last parse\n *  result.\n *  @see StructureGroup\n *  @see #setRecordUnidentifiableCompounds\n *  @see #getIdentifiedModifiedCompound\n */\n", "repo_name": "biojava-master/", "id": 292, "method_signature": "Set<StructureGroup> getUnidentifiableModifiedResidues()"}, "1324": {"callee_method_names": [], "method_name": "FileParsingParameters.getMaxAtoms", "method_implementation": "{\n    return maxAtoms;\n}", "repo_id": "9", "comment": "/**\n * The maximum numbers of atoms to load in a protein structure (prevents memory overflows)\n *\n * @return maximum nr of atoms to load, default Integer.MAX_VALUE;\n */\n", "repo_name": "biojava-master/", "id": 1324, "method_signature": "int getMaxAtoms()"}, "1606": {"callee_method_ids": [400, 404], "callee_method_names": ["GroupIterator.hasNext", "GroupIterator.next", "Group.hasAminoAtoms", "Group.getProperty", "List<SecStrucInfo>.add"], "method_name": "SecStrucTools.getSecStrucInfo", "method_implementation": "{\n    List<SecStrucInfo> listSSI = new ArrayList<>();\n    GroupIterator iter = new GroupIterator(s);\n    while (iter.hasNext()) {\n        Group g = iter.next();\n        if (g.hasAminoAtoms()) {\n            Object p = g.getProperty(Group.SEC_STRUC);\n            if (!(p == null)) {\n                SecStrucInfo ss = (SecStrucInfo) p;\n                listSSI.add(ss);\n            }\n        }\n    }\n    return listSSI;\n}", "repo_id": "9", "comment": "/**\n * Obtain the List of secondary structure information (SecStrucInfo) of a\n * Structure.\n *\n * @param s\n *            Structure with SS assignments\n * @return List of SecStrucInfo objects\n */\n", "repo_name": "biojava-master/", "id": 1606, "method_signature": "List<SecStrucInfo> getSecStrucInfo(Structure)"}, "2378": {"callee_method_ids": [2385, 2380], "callee_method_names": ["TwoBitParser.close", "TwoBitParser.getSequenceNames", "String[].equalsIgnoreCase", "TwoBitParser.setCurrentSequence"], "method_name": "TwoBitFacade.setChromosome", "method_implementation": "{\n    if (twoBitParser == null) {\n    }\n    twoBitParser.close();\n    String[] names = twoBitParser.getSequenceNames();\n    for (int i = 0; i < names.length; i++) {\n        if (names[i].equalsIgnoreCase(chr)) {\n            twoBitParser.setCurrentSequence(names[i]);\n            break;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Sets a chromosome for TwoBitParser.\n *\n * @param chr The chromosome name (e.g. chr21)\n */\n", "repo_name": "biojava-master/", "id": 2378, "method_signature": "void setChromosome(String)"}, "2560": {"callee_method_names": ["Logger.debug", "HashMap.put"], "method_name": "SoftHashMap.put", "method_implementation": "{\n    clearGCCollected();\n    logger.debug(\"Putting {} on cache. size: {}\", key, size());\n    map.put(key, new SoftValue<K, V>(value, key, queue));\n    return value;\n}", "repo_id": "9", "comment": "/**\n * Here we put the key, value pair into the HashMap using a SoftValue\n * object.\n */\n", "repo_name": "biojava-master/", "id": 2560, "method_signature": "V put(K, V)"}, "2871": {"callee_method_names": [], "method_name": "ABITrace.setSeq", "method_implementation": "{\n    char[] tempseq = new char[seqLength];\n    for (int x = 0; x <= seqLength - 1; ++x) {\n        tempseq[x] = (char) traceData[PBAS2 + x];\n    }\n    sequence = String.valueOf(tempseq);\n}", "repo_id": "9", "comment": "/**\n * Fetch the sequence from the trace data.\n */\n", "repo_name": "biojava-master/", "id": 2871, "method_signature": "void setSeq()"}, "2207": {"callee_method_ids": [1334], "callee_method_names": ["ResidueNumber.toString"], "method_name": "ResidueNumberTest.testToString", "method_implementation": "{\n    //        System.out.println(\"toString\");\n    ResidueNumber instance = new ResidueNumber(\"A\", 42, ' ');\n    String expResult = \"42\";\n    String result = instance.toString();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of toString method, of class ResidueNumber.\n */\n", "repo_name": "biojava-master/", "id": 2207, "method_signature": "void testToString()"}, "3191": {"callee_method_names": [], "method_name": "TestFASTAReader.testProcessAllWithBlankLines", "method_implementation": "{\n    testProcessAll(\"org/biojava/nbio/core/fasta/P02768_blank_lines.fasta\");\n}", "repo_id": "9", "comment": "/**\n * Same as {@link #testProcessAll()} but input files contains blank lines\n *\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3191, "method_signature": "void testProcessAllWithBlankLines()"}, "1251": {"callee_method_names": ["Group.getAtoms", "List<Atom>.add", "Set<Atom>.add", "Group.getAltLocs", "Set<Atom>.contains", "List<Atom>.add"], "method_name": "MmtfUtils.getAtomsForGroup", "method_implementation": "{\n    Set<Atom> uniqueAtoms = new HashSet<Atom>();\n    List<Atom> theseAtoms = new ArrayList<Atom>();\n    for (Atom a : inputGroup.getAtoms()) {\n        theseAtoms.add(a);\n        uniqueAtoms.add(a);\n    }\n    List<Group> altLocs = inputGroup.getAltLocs();\n    for (Group thisG : altLocs) {\n        for (Atom a : thisG.getAtoms()) {\n            if (uniqueAtoms.contains(a)) {\n                continue;\n            }\n            theseAtoms.add(a);\n        }\n    }\n    return theseAtoms;\n}", "repo_id": "9", "comment": "/**\n * Get a list of atoms for a group. Only add each atom once.\n * @param inputGroup the Biojava Group to consider\n * @return the atoms for the input Biojava Group\n */\n", "repo_name": "biojava-master/", "id": 1251, "method_signature": "List<Atom> getAtomsForGroup(Group)"}, "2791": {"callee_method_names": [], "method_name": "FileProxyProteinSequenceCreator.getSequence", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported yet.\");\n}", "repo_id": "9", "comment": "/**\n * Not sure of use case and currently not supported\n * @param list\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2791, "method_signature": "AbstractSequence<AminoAcidCompound> getSequence(List)"}, "692": {"callee_method_names": ["List<Atom[]>.size", "List<AFPChain>.get", "List<AFPChain>.get", "List<List<Integer>>.add", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<AFPChain>.get", "List<AFPChain>.get", "List<AFPChain>.get", "List<AFPChain>.get", "List<AFPChain>.get", "List<AFPChain>.get", "List<List<Integer>>.get", "SortedSet<Integer>.add", "MultipleAlignment.getEnsemble", "SortedSet<Integer>.contains", "BlockSet.getBlocks", "BlockSet.getBlocks", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "BlockSet.getBlocks", "BlockSet.getBlocks", "Block.getAlignRes", "List<List<Integer>>.add", "Block.setAlignRes", "Block.getAlignRes", "List<List<Integer>>.get", "Logger.info", "MultipleAlignment.getBlocks"], "method_name": "MultipleMcMain.combineReferenceAlignments", "method_implementation": "{\n    int size = atomArrays.size();\n    //the number of residues of the reference structure\n    int length = 0;\n    if (ref == 0)\n        length = afpList.get(1).getCa1Length();\n    else\n        length = afpList.get(0).getCa2Length();\n    SortedSet<Integer> flexibleBoundaries = new TreeSet<Integer>();\n    //Stores the equivalencies of all the structures as a double List\n    List<List<Integer>> equivalencies = new ArrayList<List<Integer>>();\n    for (int str = 0; str < size; str++) {\n        equivalencies.add(new ArrayList<Integer>());\n        for (int res = 0; res < length; res++) {\n            if (//identity\n            str == ref)\n                //identity\n                equivalencies.get(str).add(res);\n            else\n                equivalencies.get(str).add(null);\n        }\n    }\n    //Now we parse the AFPChains adding the residue equivalencies\n    for (int str = 0; str < size; str++) {\n        //avoid self-comparison\n        if (str == ref)\n            continue;\n        for (int bk = 0; bk < afpList.get(str).getBlockNum(); bk++) {\n            for (int i = 0; i < afpList.get(str).getOptLen()[bk]; i++) {\n                //reference index\n                int res1 = 0;\n                int res2 = 0;\n                //The low index is always in the first chain (0)\n                if (str > ref) {\n                    res1 = afpList.get(str).getOptAln()[bk][0][i];\n                    res2 = afpList.get(str).getOptAln()[bk][1][i];\n                } else if (str < ref) {\n                    res1 = afpList.get(str).getOptAln()[bk][1][i];\n                    res2 = afpList.get(str).getOptAln()[bk][0][i];\n                }\n                equivalencies.get(str).set(res1, res2);\n                //Add the flexible boundaries if flexible\n                if (flexible && i == 0)\n                    flexibleBoundaries.add(res1);\n            }\n        }\n    }\n    //We have translated the equivalencies, we create the MultipleAlignment\n    MultipleAlignment seed = new MultipleAlignmentImpl();\n    seed.getEnsemble().setAtomArrays(atomArrays);\n    BlockSet blockSet = new BlockSetImpl(seed);\n    new BlockImpl(blockSet);\n    //Store last positions in the block different than null to detect CP\n    int[] lastResidues = new int[size];\n    Arrays.fill(lastResidues, -1);\n    //We loop through all the equivalencies checking for CP\n    for (int pos = 0; pos < length; pos++) {\n        //Start a new BlockSet if the position means a boundary\n        if (flexibleBoundaries.contains(pos) && blockSet.getBlocks().get(blockSet.getBlocks().size() - 1).getAlignRes() != null) {\n            blockSet = new BlockSetImpl(seed);\n            new BlockImpl(blockSet);\n        }\n        boolean cp = false;\n        for (int str = 0; str < size; str++) {\n            if (equivalencies.get(str).get(pos) == null) {\n                //there is a gap, ignore position\n                continue;\n            } else if (equivalencies.get(str).get(pos) < lastResidues[str]) {\n                //current residue is lower than the last\n                cp = true;\n                break;\n            } else\n                lastResidues[str] = equivalencies.get(str).get(pos);\n        }\n        if (cp) {\n            //if there is a CP create a new Block\n            new BlockImpl(blockSet);\n            Arrays.fill(lastResidues, -1);\n        }\n        //Now add the equivalent residues into the Block AlignRes variable\n        for (int str = 0; str < size; str++) {\n            Block lastB = blockSet.getBlocks().get(blockSet.getBlocks().size() - 1);\n            if (lastB.getAlignRes() == null) {\n                //Initialize the aligned residues list\n                List<List<Integer>> alnRes = new ArrayList<List<Integer>>(size);\n                for (int k = 0; k < size; k++) {\n                    alnRes.add(new ArrayList<Integer>());\n                }\n                lastB.setAlignRes(alnRes);\n            }\n            lastB.getAlignRes().get(str).add(equivalencies.get(str).get(pos));\n        }\n    }\n    logger.info(\"Seed alignment has \" + seed.getBlocks() + \" Blocks.\");\n    return seed;\n}", "repo_id": "9", "comment": "/**\n * This method takes a list of pairwise alignments to the reference\n * structure and calculates a MultipleAlignment resulting from combining\n * their residue equivalencies.\n * <p>\n * It uses the blocks in AFPChain as {@link Block}s in the\n * MultipleAlignment, so considers non-topological\n * alignments, if the alignment is rigid. If the alignment is flexible,\n * it considers the blocks as {@link BlockSets}.\n *\n * @param afpList the list of pairwise alignments to the reference\n * @param atomArrays List of Atoms of the structures\n * @param ref index of the reference structure\n * @param flexible uses BlockSets if true, uses Blocks otherwise\n * @return MultipleAlignment seed alignment\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 692, "method_signature": "MultipleAlignment combineReferenceAlignments(List, List, int, boolean)"}, "1074": {"callee_method_names": [], "method_name": "ZipChemCompProvider.setRemoveCif", "method_implementation": "{\n    m_removeCif = doRemove;\n}", "repo_id": "9", "comment": "/**\n * Remove downloaded .cif.gz after adding to zip archive?\n * Default is true.\n * @param doRemove\n */\n", "repo_name": "biojava-master/", "id": 1074, "method_signature": "void setRemoveCif(boolean)"}, "3112": {"callee_method_names": [], "method_name": "QuantityFeature.setQuantities", "method_implementation": "{\n    this.quantities = quantities;\n}", "repo_id": "9", "comment": "/**\n * @param quantities the quantities to set\n */\n", "repo_name": "biojava-master/", "id": 3112, "method_signature": "void setQuantities(List)"}, "2508": {"callee_method_names": ["BufferedReader.readLine", "String.startsWith", "String.startsWith", "String.startsWith", "ScaledSubstitutionMatrix.setDescription", "String.substring", "String.startsWith", "String.startsWith", "BufferedReader.readLine"], "method_name": "AAIndexFileParser.parse", "method_implementation": "{\n    currentMatrix = null;\n    currentRows = \"\";\n    currentCols = \"\";\n    max = Short.MIN_VALUE;\n    min = Short.MAX_VALUE;\n    inMatrix = false;\n    BufferedReader buf = new BufferedReader(new InputStreamReader(inputStream));\n    String line = null;\n    line = buf.readLine();\n    while (line != null) {\n        if (line.startsWith(\"//\")) {\n            finalizeMatrix();\n            inMatrix = false;\n        } else if (line.startsWith(\"H \")) {\n            // a new matrix!\n            newMatrix(line);\n        } else if (line.startsWith(\"D \")) {\n            currentMatrix.setDescription(line.substring(2));\n        } else if (line.startsWith(\"M \")) {\n            initMatrix(line);\n            inMatrix = true;\n        } else if (line.startsWith(\"  \")) {\n            if (inMatrix)\n                processScores(line);\n        }\n        line = buf.readLine();\n    }\n}", "repo_id": "9", "comment": "/**\n * Parse an inputStream that points to an AAINDEX database file\n *\n * @param inputStream\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2508, "method_signature": "void parse(InputStream)"}, "1900": {"callee_method_ids": [1933], "callee_method_names": ["PermutationGroup.addPermutation", "String.getPermutation", "PermutationGroup.addPermutation", "String.getPermutation", "HashMap.get", "String.getPermutation", "PermutationGroup.completeGroup", "PermutationGroup.getOrder", "RotationGroup.getOrder", "PermutationGroup.getOrder", "HashMap.containsKey", "HashMap.get", "HashMap.containsKey", "HashMap.get", "HashMap.containsKey", "List<Rotation>.add"], "method_name": "RotationSolver.completeRotationGroup", "method_implementation": "{\n    PermutationGroup g = new PermutationGroup();\n    for (Rotation s : rotations) {\n        g.addPermutation(s.getPermutation());\n    }\n    for (Rotation s : additionalRots) {\n        g.addPermutation(s.getPermutation());\n        // inputs should not have been added already\n        assert evaluatedPermutations.get(s.getPermutation()) == null;\n    }\n    g.completeGroup();\n    // the group is complete, nothing to do\n    if (g.getOrder() == rotations.getOrder() + additionalRots.length) {\n        for (Rotation s : additionalRots) {\n            addRotation(s);\n        }\n        return true;\n    }\n    // try to complete the group\n    List<Rotation> newRots = new ArrayList<>(g.getOrder());\n    // First, quick check for whether they're allowed\n    for (List<Integer> permutation : g) {\n        if (evaluatedPermutations.containsKey(permutation)) {\n            Rotation rot = evaluatedPermutations.get(permutation);\n            if (rot == null) {\n                return false;\n            }\n        } else {\n            if (!isAllowedPermutation(permutation)) {\n                return false;\n            }\n        }\n    }\n    // Slower check including the superpositions\n    for (List<Integer> permutation : g) {\n        Rotation rot;\n        if (evaluatedPermutations.containsKey(permutation)) {\n            rot = evaluatedPermutations.get(permutation);\n        } else {\n            rot = isValidPermutation(permutation);\n        }\n        if (rot == null) {\n            // if any induced rotation is invalid, abort\n            return false;\n        }\n        if (!evaluatedPermutations.containsKey(permutation)) {\n            //novel\n            newRots.add(rot);\n        }\n    }\n    // Add rotations\n    for (Rotation rot : newRots) {\n        addRotation(rot);\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Combine current rotations to make all possible permutations.\n * If these are all valid, add them to the rotations\n * @param additionalRots Additional rotations we are considering adding to this.rotations\n * @return whether the rotations were valid and added\n */\n", "repo_name": "biojava-master/", "id": 1900, "method_signature": "boolean completeRotationGroup(Rotation[])"}, "3753": {"callee_method_names": ["HashMap<String, String>.containsKey", "HashMap<String, String>.put", "ArrayList<String>.add"], "method_name": "WorkSheet.getDiscreteColumnValues", "method_implementation": "{\n    HashMap<String, String> hashMapValues = new HashMap<String, String>();\n    ArrayList<String> values = new ArrayList<String>();\n    ArrayList<String> rows = getDataRows();\n    for (String row : rows) {\n        String value = getCell(row, column);\n        if (!hashMapValues.containsKey(value)) {\n            hashMapValues.put(value, value);\n            values.add(value);\n        }\n    }\n    return values;\n}", "repo_id": "9", "comment": "/**\n * Get back a list of unique values in the column\n *\n * @param column\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3753, "method_signature": "ArrayList<String> getDiscreteColumnValues(String)"}, "1506": {"callee_method_names": ["Logger.debug", "Point3d.negate", "Logger.debug", "Point3d.negate"], "method_name": "SuperPositionQCP.calcRmsd", "method_implementation": "{\n    if (centered) {\n        innerProduct(y, x);\n    } else {\n        // translate to origin\n        xref = CalcPoint.clonePoint3dArray(x);\n        xtrans = CalcPoint.centroid(xref);\n        logger.debug(\"x centroid: {}\", xtrans);\n        xtrans.negate();\n        CalcPoint.translate(new Vector3d(xtrans), xref);\n        yref = CalcPoint.clonePoint3dArray(y);\n        ytrans = CalcPoint.centroid(yref);\n        logger.debug(\"y centroid: {}\", ytrans);\n        ytrans.negate();\n        CalcPoint.translate(new Vector3d(ytrans), yref);\n        innerProduct(yref, xref);\n    }\n    calcRmsd(wsum);\n}", "repo_id": "9", "comment": "/**\n * Calculates the RMSD value for superposition of y onto x. This requires\n * the coordinates to be precentered.\n *\n * @param x\n *            3d points of reference coordinate set\n * @param y\n *            3d points of coordinate set for superposition\n */\n", "repo_name": "biojava-master/", "id": 1506, "method_signature": "void calcRmsd(Point3d[], Point3d[])"}, "628": {"callee_method_names": ["StructureIdentifier.loadStructure", "StructureIdentifier.reduce", "Structure.setStructureIdentifier"], "method_name": "AtomCache.getStructure", "method_implementation": "{\n    Structure s = strucId.loadStructure(this);\n    Structure r = strucId.reduce(s);\n    r.setStructureIdentifier(strucId);\n    return r;\n}", "repo_id": "9", "comment": "/**\n * Get the structure corresponding to the given {@link StructureIdentifier}.\n * Equivalent to calling {@link StructureIdentifier#loadStructure(AtomCache)}\n * followed by {@link StructureIdentifier#reduce(Structure)}.\n *\n * <p>Note that this method should not be used in StructureIdentifier\n * implementations to avoid circular calls.\n * @param strucId\n * @return\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 628, "method_signature": "Structure getStructure(StructureIdentifier)"}, "589": {"callee_method_ids": [491, 487, 487], "callee_method_names": ["AFPChain.setName1", "Atom[].getGroup", "Atom[].getGroup", "AFPChain.setName2", "Atom[].getGroup", "AFPChain.setBlockNum", "AFPChain.setCa1Length", "AFPChain.setCa2Length", "AFPChain.setOptLength", "AFPChain.setOptLen", "AFPChain.getBlockNum", "AFPChain.setBlockRotationMatrix", "AFPChain.getBlockNum", "AFPChain.setBlockShiftVector", "ResidueNumber[].getChainName", "ResidueNumber[].getChainName", "AFPChain.setPdbAln"], "method_name": "AlignmentTools.createAFPChain", "method_implementation": "{\n    //input validation\n    int alnLen = aligned1.length;\n    if (alnLen != aligned2.length) {\n        throw new IllegalArgumentException(\"Alignment lengths are not equal\");\n    }\n    AFPChain a = new AFPChain(AFPChain.UNKNOWN_ALGORITHM);\n    try {\n        a.setName1(ca1[0].getGroup().getChain().getStructure().getName());\n        if (ca2[0].getGroup().getChain().getStructure() != null) {\n            // common case for cloned ca2\n            a.setName2(ca2[0].getGroup().getChain().getStructure().getName());\n        }\n    } catch (Exception e) {\n        // One of the structures wasn't fully created. Ignore\n    }\n    a.setBlockNum(1);\n    a.setCa1Length(ca1.length);\n    a.setCa2Length(ca2.length);\n    a.setOptLength(alnLen);\n    a.setOptLen(new int[] { alnLen });\n    Matrix[] ms = new Matrix[a.getBlockNum()];\n    a.setBlockRotationMatrix(ms);\n    Atom[] blockShiftVector = new Atom[a.getBlockNum()];\n    a.setBlockShiftVector(blockShiftVector);\n    String[][][] pdbAln = new String[1][2][alnLen];\n    for (int i = 0; i < alnLen; i++) {\n        pdbAln[0][0][i] = aligned1[i].getChainName() + \":\" + aligned1[i];\n        pdbAln[0][1][i] = aligned2[i].getChainName() + \":\" + aligned2[i];\n    }\n    a.setPdbAln(pdbAln);\n    // convert pdbAln to optAln, and fill in some other basic parameters\n    AFPChainXMLParser.rebuildAFPChain(a, ca1, ca2);\n    return a;\n    // Currently a single block. Split into several blocks by sequence if needed\n    //\t\treturn AlignmentTools.splitBlocksByTopology(a,ca1,ca2);\n}", "repo_id": "9", "comment": "/**\n * Fundamentally, an alignment is just a list of aligned residues in each\n * protein. This method converts two lists of ResidueNumbers into an\n * AFPChain.\n *\n * <p>Parameters are filled with defaults (often null) or sometimes\n * calculated.\n *\n * <p>For a way to modify the alignment of an existing AFPChain, see\n * {@link AlignmentTools#replaceOptAln(AFPChain, Atom[], Atom[], Map)}\n * @param ca1 CA atoms of the first protein\n * @param ca2 CA atoms of the second protein\n * @param aligned1 A list of aligned residues from the first protein\n * @param aligned2 A list of aligned residues from the second protein.\n *  Must be the same length as aligned1.\n * @return An AFPChain representing the alignment. Many properties may be\n *  null or another default.\n * @throws StructureException if an error occured during superposition\n * @throws IllegalArgumentException if aligned1 and aligned2 have different\n *  lengths\n * @see AlignmentTools#replaceOptAln(AFPChain, Atom[], Atom[], Map)\n */\n", "repo_name": "biojava-master/", "id": 589, "method_signature": "AFPChain createAFPChain(Atom[], Atom[], ResidueNumber[], ResidueNumber[])"}, "2357": {"callee_method_ids": [2371, 2370], "callee_method_names": ["Fastq.getSequence", "DNASequence.setOriginalHeader", "Fastq.getDescription"], "method_name": "FastqTools.createDNASequence", "method_implementation": "{\n    if (fastq == null) {\n        throw new IllegalArgumentException(\"fastq must not be null\");\n    }\n    DNASequence sequence = new DNASequence(fastq.getSequence());\n    sequence.setOriginalHeader(fastq.getDescription());\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Create and return a new {@link DNASequence} from the specified FASTQ formatted sequence.\n *\n * @param fastq FASTQ formatted sequence, must not be null\n * @return a new {@link DNASequence} from the specified FASTQ formatted sequence\n * @throws CompoundNotFoundException if DNA sequence in fastq contains unrecognised compounds\n */\n", "repo_name": "biojava-master/", "id": 2357, "method_signature": "DNASequence createDNASequence(Fastq)"}, "3482": {"callee_method_names": ["HashMap.remove"], "method_name": "NCBIQBlastAlignmentProperties.removeAlignmentOption", "method_implementation": "{\n    param.remove(key);\n}", "repo_id": "9", "comment": "/**\n * Removes given parameter\n */\n", "repo_name": "biojava-master/", "id": 3482, "method_signature": "void removeAlignmentOption(BlastAlignmentParameterEnum)"}, "2558": {"callee_method_names": ["HashMap<String, ResultFactory>.put", "File.getAbsolutePath", "String.lastIndexOf", "String.substring", "HashMap<String, ResultFactory>.get", "HashMap<String, ResultFactory>.get"], "method_name": "SearchIO.guessFactory", "method_implementation": "{\n    if (extensionFactoryAssociation == null) {\n        extensionFactoryAssociation = new HashMap<String, ResultFactory>();\n        ServiceLoader<ResultFactory> impl = ServiceLoader.load(ResultFactory.class);\n        for (ResultFactory loadedImpl : impl) {\n            List<String> fileExtensions = loadedImpl.getFileExtensions();\n            for (String ext : fileExtensions) extensionFactoryAssociation.put(ext, loadedImpl);\n        }\n    }\n    String filename = f.getAbsolutePath();\n    int extensionPos = filename.lastIndexOf(\".\");\n    String extension = filename.substring(extensionPos + 1);\n    if (extensionFactoryAssociation.get(extension) == null)\n        throw new UnsupportedOperationException(NOT_SUPPORTED_FILE_EXCEPTION + \"\\nExtension:\" + extension);\n    return extensionFactoryAssociation.get(extension);\n}", "repo_id": "9", "comment": "/**\n * Guess factory class to be used using file extension.\n * It can be used both for read and for in write.\n * To be ResultFactory classes automatically available to this subsystem\n * they must be listed in the file org.biojava.nbio.core.search.io.ResultFactory\n * located in src/main/resources\n *\n * @param f: file. Its last extension (text after last dot) will be compared\n * to default extensions of known ResultFactory implementing classes\n * @return the guessed factory\n */\n", "repo_name": "biojava-master/", "id": 2558, "method_signature": "ResultFactory guessFactory(File)"}, "457": {"callee_method_names": ["Map<Integer,Integer>.size", "Map<Integer,Integer>.keySet", "List<Subunit>.add", "List<Subunit>.get", "Map<Integer,Integer>.get"], "method_name": "QsAlignResult.getAlignedSubunits2", "method_implementation": "{\n    List<Subunit> aligned = new ArrayList<>(subunitMap.size());\n    for (Integer key : subunitMap.keySet()) aligned.add(subunits2.get(subunitMap.get(key)));\n    return aligned;\n}", "repo_id": "9", "comment": "/**\n * Return the aligned subunits of the second Subunit group, in the alignment\n * order.\n *\n * @return a List of Subunits in the alignment order\n */\n", "repo_name": "biojava-master/", "id": 457, "method_signature": "List<Subunit> getAlignedSubunits2()"}, "2716": {"callee_method_names": ["String.length"], "method_name": "BufferedReaderBytesRead.readLine", "method_implementation": "{\n    String line = readLine(false);\n    if (line != null) {\n        bytesRead = bytesRead + line.length();\n    }\n    return line;\n}", "repo_id": "9", "comment": "/**\n * Reads a line of text.  A line is considered to be terminated by any one\n * of a line feed ('\\n'), a carriage return ('\\r'), or a carriage return\n * followed immediately by a linefeed.\n *\n * @return     A String containing the contents of the line, not including\n *             any line-termination characters, or null if the end of the\n *             stream has been reached\n *\n * @exception  IOException  If an I/O error occurs\n */\n", "repo_name": "biojava-master/", "id": 2716, "method_signature": "String readLine()"}, "3671": {"callee_method_names": [], "method_name": "SurvivalInfo.getOrder", "method_implementation": "{\n    return order;\n}", "repo_id": "9", "comment": "/**\n * @return the order\n */\n", "repo_name": "biojava-master/", "id": 3671, "method_signature": "int getOrder()"}, "1224": {"callee_method_names": ["Chain.setId", "Chain.getId", "Chain.setName", "Chain.getName", "Chain.setEntityInfo", "Chain.getEntityInfo", "Chain.getAtomGroups", "Group.getAtoms", "float.getName", "float.getElement", "AminoAcid.setPDBName", "Group.getPDBName", "AminoAcid.setResidueNumber", "Group.getResidueNumber", "AminoAcid.addAtom", "Chain.addGroup"], "method_name": "CAConverter.getRepresentativeAtomsOnly", "method_implementation": "{\n    Chain newChain = new ChainImpl();\n    newChain.setId(chain.getId());\n    newChain.setName(chain.getName());\n    newChain.setEntityInfo(chain.getEntityInfo());\n    List<Group> groups = chain.getAtomGroups();\n    grouploop: for (Group g : groups) {\n        List<Atom> atoms = g.getAtoms();\n        if (!(g instanceof AminoAcid))\n            continue;\n        for (Atom a : atoms) {\n            if (a.getName().equals(StructureTools.CA_ATOM_NAME) && a.getElement() == Element.C) {\n                // we got a CA atom in this group!\n                AminoAcid n = new AminoAcidImpl();\n                n.setPDBName(g.getPDBName());\n                n.setResidueNumber(g.getResidueNumber());\n                n.addAtom(a);\n                newChain.addGroup(n);\n                continue grouploop;\n            }\n        }\n    }\n    return newChain;\n}", "repo_id": "9", "comment": "/**\n * Convert a Chain to a new Chain containing C-alpha atoms only.\n *\n * @param chain to convert\n * @return a new chain containing Amino acids with C-alpha only.\n * @since Biojava 4.1.0\n */\n", "repo_name": "biojava-master/", "id": 1224, "method_signature": "Chain getRepresentativeAtomsOnly(Chain)"}, "3729": {"callee_method_names": ["LinkedHashMap.keySet", "HashMap<String,String>.get"], "method_name": "WorkSheet.replaceColumnValues", "method_implementation": "{\n    for (String row : rowLookup.keySet()) {\n        String oldValue = this.getCell(row, column);\n        String newValue = values.get(oldValue);\n        this.addCell(row, column, newValue);\n    }\n}", "repo_id": "9", "comment": "/**\n * Change values in a column where 0 = something and 1 = something different\n *\n * @param column\n * @param values\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3729, "method_signature": "void replaceColumnValues(String, HashMap)"}, "3148": {"callee_method_names": ["BufferedReader.skip", "SequenceParserInterface.getSequence"], "method_name": "SequenceFileProxyLoader.init", "method_implementation": "{\n    try (BufferedReader br = new BufferedReader(new FileReader(file))) {\n        br.skip(sequenceStartIndex);\n        String sequence = sequenceParser.getSequence(br, sequenceLength);\n        setContents(sequence);\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n *  Load the sequence\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3148, "method_signature": "boolean init()"}, "466": {"callee_method_names": [], "method_name": "StructureName.getChainId", "method_implementation": "{\n    return chainName;\n}", "repo_id": "9", "comment": "/**\n * Gets the chain ID, for structures where it is unique and well-defined.\n * May return '.' for multi-chain ranges, '_' for wildcard chains, or\n * null if the information is unavailable.\n *\n * <p>This method should only be used casually. For precise chainIds, it\n * is better to use {@link #toCanonical()} and iterate through the\n * residue ranges.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 466, "method_signature": "String getChainId()"}, "1683": {"callee_method_names": ["List<? extends ResidueRange>.size", "List<? extends ResidueRange>.size", "List<? extends ResidueRange>.get"], "method_name": "ResidueRange.multiIterator", "method_implementation": "{\n    ResidueRange[] ranges = new ResidueRange[rrs.size()];\n    for (int i = 0; i < rrs.size(); i++) {\n        ranges[i] = rrs.get(i);\n    }\n    return multiIterator(map, ranges);\n}", "repo_id": "9", "comment": "/**\n * Returns a new Iterator over every {@link ResidueNumber} in the list of ResidueRanges.\n * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n */\n", "repo_name": "biojava-master/", "id": 1683, "method_signature": "Iterator<ResidueNumber> multiIterator(AtomPositionMap, List)"}, "2546": {"callee_method_names": [], "method_name": "Hsp.getHspHseq", "method_implementation": "{\n    return hspHseq;\n}", "repo_id": "9", "comment": "/**\n * HSP aligned hit sequence string\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2546, "method_signature": "String getHspHseq()"}, "1371": {"callee_method_names": ["Class.getMethods", "Map<String, String>.getName", "String.substring", "Map<String, String>.invoke", "StringBuilder.append", "String.substring", "String.length", "StringBuilder.append", "Logger.error", "StringBuilder.toString"], "method_name": "DBRef.toString", "method_implementation": "{\n    StringBuilder buf = new StringBuilder();\n    try {\n        @SuppressWarnings(\"rawtypes\")\n        Class c = Class.forName(DBRef.class.getName());\n        Method[] methods = c.getMethods();\n        for (Method m : methods) {\n            String name = m.getName();\n            if (\"get\".equals(name.substring(0, 3))) {\n                if (\"getClass\".equals(name)) {\n                    continue;\n                }\n                Object o = m.invoke(this);\n                if (o != null) {\n                    buf.append(name.substring(3, name.length()));\n                    buf.append(\": \").append(o).append(\" \");\n                }\n            }\n        }\n    } catch (Exception e) {\n        logger.error(\"Exception: \", e);\n    }\n    return buf.toString();\n}", "repo_id": "9", "comment": "/**\n * String representation of a DBRef.\n * @return a String\n */\n", "repo_name": "biojava-master/", "id": 1371, "method_signature": "String toString()"}, "2540": {"callee_method_names": ["HashMap.containsKey", "HashMap.put", "HashMap.get"], "method_name": "SubstitutionMatrixHelper.getNucleotideMatrix", "method_implementation": "{\n    if (!nucleotideMatrices.containsKey(file)) {\n        nucleotideMatrices.put(file, new SimpleSubstitutionMatrix<NucleotideCompound>(AmbiguityDNACompoundSet.getDNACompoundSet(), getReader(file), file));\n    }\n    return nucleotideMatrices.get(file);\n}", "repo_id": "9", "comment": "// reads in a nucleotide substitution matrix, if necessary\n", "repo_name": "biojava-master/", "id": 2540, "method_signature": "SubstitutionMatrix<NucleotideCompound> getNucleotideMatrix(String)"}, "3005": {"callee_method_names": ["String.charAt"], "method_name": "BitArrayWorker.populate", "method_implementation": "{\n    for (int index = 0; index < getLength(); index++) {\n        setCompoundAt(sequence.charAt(index), index + 1);\n    }\n}", "repo_id": "9", "comment": "/**\n * Loops through the chars in a String and passes them onto\n * {@link #setCompoundAt(char, int)}\n */\n", "repo_name": "biojava-master/", "id": 3005, "method_signature": "void populate(String)"}, "2483": {"callee_method_names": ["List<Integer>.size", "List<Integer>.get", "List<Integer>.get"], "method_name": "ChromosomeMappingTools.getCDSLengthReverse", "method_implementation": "{\n    int codingLength = 0;\n    if (cdsEnd < cdsStart) {\n        int tmp = cdsEnd;\n        cdsEnd = cdsStart;\n        cdsStart = tmp;\n    }\n    cdsStart = cdsStart + base;\n    // map reverse\n    for (int i = exonStarts.size() - 1; i >= 0; i--) {\n        int end = exonStarts.get(i);\n        int start = exonEnds.get(i);\n        if (end < start) {\n            int tmp = end;\n            end = start;\n            start = tmp;\n        }\n        start = start + base;\n        if ((start < cdsStart && end < cdsStart) || (start > cdsEnd && end > cdsEnd))\n            continue;\n        if (start < cdsStart)\n            start = cdsStart;\n        if (end > cdsEnd)\n            end = cdsEnd;\n        codingLength += (end - start + 1);\n    }\n    return codingLength - 3;\n}", "repo_id": "9", "comment": "/**\n * Get the length of the coding sequence\n *\n * @param exonStarts\n * @param exonEnds\n * @param cdsStart\n * @param cdsEnd\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2483, "method_signature": "int getCDSLengthReverse(List, List, int, int)"}, "2353": {"callee_method_names": [], "method_name": "FastqParserLineProcessor.getState", "method_implementation": "{\n    return state;\n}", "repo_id": "9", "comment": "/**\n * Return the parser state.\n *\n * @return the parser state\n */\n", "repo_name": "biojava-master/", "id": 2353, "method_signature": "State getState()"}, "2081": {"callee_method_names": ["Matrix.get", "Matrix.get", "Random.nextDouble", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.add"], "method_name": "SymmOptimizer.shrinkBlock", "method_implementation": "{\n    // Let shrink moves only if the repeat is larger enough\n    if (repeatCore <= Lmin)\n        return false;\n    // Select column by maximum distance\n    updateMultipleAlignment();\n    Matrix residueDistances = MultipleAlignmentTools.getAverageResidueDistances(msa);\n    double maxDist = Double.MIN_VALUE;\n    double[] colDistances = new double[length];\n    int res = 0;\n    for (int col = 0; col < length; col++) {\n        int normalize = 0;\n        for (int s = 0; s < order; s++) {\n            if (residueDistances.get(s, col) != -1) {\n                colDistances[col] += residueDistances.get(s, col);\n                normalize++;\n            }\n        }\n        colDistances[col] /= normalize;\n        if (colDistances[col] > maxDist) {\n            // geometric distribution\n            if (rnd.nextDouble() > 0.5) {\n                maxDist = colDistances[col];\n                res = col;\n            }\n        }\n    }\n    for (int su = 0; su < order; su++) {\n        Integer residue = block.get(su).get(res);\n        block.get(su).remove(res);\n        if (residue != null)\n            freePool.add(residue);\n        Collections.sort(freePool);\n    }\n    length--;\n    checkGaps();\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Deletes an alignment column at a randomly selected position.\n *\n * @throws StructureException\n * @throws RefinerFailedException\n */\n", "repo_name": "biojava-master/", "id": 2081, "method_signature": "boolean shrinkBlock()"}, "1834": {"callee_method_ids": [628], "callee_method_names": ["AtomCache.getStructure"], "method_name": "StructureIO.getStructure", "method_implementation": "{\n    checkInitAtomCache();\n    // delegate this functionality to AtomCache...\n    return cache.getStructure(name);\n}", "repo_id": "9", "comment": "/**\n *  Loads a structure based on a name. Supported naming conventions are:\n *\n *   <pre>\n * \t\tFormal specification for how to specify the <i>name</i>:\n *\n * \t\tname     := pdbID\n * \t\t\t\t\t   | pdbID '.' chainID\n * \t\t\t\t\t   | pdbID '.' range\n * \t\t\t\t\t   | scopID\n * \t\t\t\t\t   | biol\n * \t\t\t\t\t   | pdp\n * \t\trange         := '('? range (',' range)? ')'?\n * \t\t\t\t\t   | chainID\n * \t\t\t\t\t   | chainID '_' resNum '-' resNum\n * \t\tpdbID         := [1-9][a-zA-Z0-9]{3}\n * \t\t\t\t\t   | PDB_[a-zA-Z0-9]{8}\n * \t\tchainID       := [a-zA-Z0-9]\n * \t\tscopID        := 'd' pdbID [a-z_][0-9_]\n * \t\tbiol\t\t  := 'BIO:' pdbID [:]? [0-9]+\n * \t\tresNum        := [-+]?[0-9]+[A-Za-z]?\n *\n * \t\tExample structures:\n * \t\t1TIM                #whole structure - asym unit (short format)\n * \t\t4HHB.C              #single chain\n * \t\t4GCR.A_1-83         #one domain, by residue number\n * \t\t3AA0.A,B            #two chains treated as one structure\n * \t\tPDB_00001TIM        #whole structure - asym unit (extended format)\n * \t\tPDB_00004HHB.C      #single chain\n * \t\tPDB_00004GCR.A_1-83 #one domain, by residue number\n * \t\tPDB_00003AA0.A,B    #two chains treated as one structure\n * \t\td2bq6a1     #scop domain\n * \t\tBIO:1fah   #biological assembly nr 1 for 1fah\n * \t\tBIO:1fah:0 #asym unit for 1fah\n * \t\tBIO:1fah:1 #biological assembly nr 1 for 1fah\n * \t\tBIO:1fah:2 #biological assembly nr 2 for 1fah\n *\n *  </pre>\n *\n *  With the additional set of rules:\n *\n *   <ul>\n *   <li>If only a PDB code is provided, the whole structure will be return including ligands, but the first model only (for NMR).\n * \t<li>Chain IDs are case sensitive, PDB ids are not. To specify a particular chain write as: 4hhb.A or 4HHB.A </li>\n *   <li>To specify a SCOP domain write a scopId e.g. d2bq6a1. Some flexibility can be allowed in SCOP domain names, see {@link #setStrictSCOP(boolean)}</li>\n *   <li>URLs are accepted as well</li>\n *   </ul>\n *\n *  @param name\n *  @return a Structure object, or null if name appears improperly formated (eg too short, etc)\n *  @throws IOException The PDB file cannot be cached due to IO errors\n *  @throws StructureException The name appeared valid but did not correspond to a structure.\n *  \tAlso thrown by some submethods upon errors, eg for poorly formatted subranges.\n */\n", "repo_name": "biojava-master/", "id": 1834, "method_signature": "Structure getStructure(String)"}, "392": {"callee_method_names": ["Atom.setCoords"], "method_name": "Calc.getTranslationVector", "method_implementation": "{\n    Atom transl = new AtomImpl();\n    double[] coords = { transform.m03, transform.m13, transform.m23 };\n    transl.setCoords(coords);\n    return transl;\n}", "repo_id": "9", "comment": "/**\n * Extract the translational vector as an Atom of a transformation matrix.\n *\n * @param transform\n *            Matrix4d\n * @return Atom shift vector\n */\n", "repo_name": "biojava-master/", "id": 392, "method_signature": "Atom getTranslationVector(Matrix4d)"}, "874": {"callee_method_names": [], "method_name": "StructureInterface.getMoleculeIds", "method_implementation": "{\n    return moleculeIds;\n}", "repo_id": "9", "comment": "/**\n * Return the pair of identifiers identifying each of the 2 molecules of this interface\n * in the asymmetry unit (usually the chain identifier if this interface is between 2 chains)\n * @return\n */\n", "repo_name": "biojava-master/", "id": 874, "method_signature": "Pair<String> getMoleculeIds()"}, "1279": {"callee_method_names": [], "method_name": "MmtfSummaryDataBean.getAllAtoms", "method_implementation": "{\n    return allAtoms;\n}", "repo_id": "9", "comment": "/**\n * @return the list of atoms (in all models) in the structure\n */\n", "repo_name": "biojava-master/", "id": 1279, "method_signature": "List<Atom> getAllAtoms()"}, "1526": {"callee_method_names": [], "method_name": "JournalArticle.setDoi", "method_implementation": "{\n    this.doi = doi;\n}", "repo_id": "9", "comment": "/**\n * Set the value of doi\n *\n * @param doi new value of doi\n */\n", "repo_name": "biojava-master/", "id": 1526, "method_signature": "void setDoi(String)"}, "378": {"callee_method_names": ["Atom.getX", "Atom.getY", "Atom.getZ", "Atom.setX", "Atom.setY", "Atom.setZ"], "method_name": "Calc.scaleEquals", "method_implementation": "{\n    double x = a.getX();\n    double y = a.getY();\n    double z = a.getZ();\n    x *= s;\n    y *= s;\n    z *= s;\n    //Atom b = new AtomImpl();\n    a.setX(x);\n    a.setY(y);\n    a.setZ(z);\n    return a;\n}", "repo_id": "9", "comment": "/**\n * Multiply elements of a by s (in place)\n *\n * @param a\n * @param s\n * @return the modified a\n */\n", "repo_name": "biojava-master/", "id": 378, "method_signature": "Atom scaleEquals(Atom, double)"}, "1615": {"callee_method_ids": [929, 940], "callee_method_names": ["Grid.addAtoms", "Structure.getNonPolyChains", "Chain.getAtomGroups", "Group.isWater", "Group.isPolymeric", "Grid.hasAnyContact", "Group.getAtoms", "Structure.findGroup", "Group.getChainId", "Group.getResidueNumber", "Logger.info", "Group.getPDBName", "Group.getResidueNumber"], "method_name": "SubstructureIdentifier.copyLigandsByProximity", "method_implementation": "{\n    // Geometric hashing of the reduced structure\n    Grid grid = new Grid(cutoff);\n    Atom[] nonwaters = StructureTools.getAllNonHAtomArray(reduced, true, toModel);\n    if (nonwaters.length < 1)\n        return;\n    grid.addAtoms(nonwaters);\n    //potential ligand chains\n    full.getNonPolyChains(fromModel).stream().flatMap(// potential ligand groups\n    (chain) -> chain.getAtomGroups().stream()).filter(// ignore waters\n    (g) -> !g.isWater()).filter(// already shouldn't be polymeric, but filter anyways\n    (g) -> !g.isPolymeric()).filter(// must contact reduced\n    (g) -> grid.hasAnyContact(Calc.atomsToPoints(g.getAtoms()))).// Keeps ligands from the same chain together if possible\n    sequential().// reduction updates the chain guess\n    reduce(// reduction updates the chain guess\n    (Chain) null, (guess, g) -> {\n        boolean wasAdded;\n        try {\n            // Check that it's not in reduced already\n            wasAdded = reduced.findGroup(g.getChainId(), g.getResidueNumber().toString(), toModel) != null;\n        } catch (StructureException e) {\n            // not found\n            wasAdded = false;\n        }\n        if (!wasAdded) {\n            // Add the ligand to reduced\n            // note this is not idempotent, but it is synchronized on reduced\n            logger.info(\"Adding ligand group {} {} by proximity\", g.getPDBName(), g.getResidueNumber().toPDB());\n            return StructureTools.addGroupToStructure(reduced, g, toModel, guess, false);\n        }\n        return guess;\n    }, // update to the new guess\n    (oldGuess, newGuess) -> newGuess);\n}", "repo_id": "9", "comment": "/**\n * Supplements the reduced structure with ligands from the full structure based on\n * a distance cutoff. Ligand groups are moved (destructively) from full to reduced\n * if they fall within the cutoff of any atom in the reduced structure.\n * @param full Structure containing all ligands\n * @param reduced Structure with a subset of the polymer groups from full\n * @param cutoff Distance cutoff (\u00c5)\n * @param fromModel source model in full\n * @param toModel destination model in reduced\n * @see StructureTools#getLigandsByProximity(java.util.Collection, Atom[], double)\n */\n", "repo_name": "biojava-master/", "id": 1615, "method_signature": "void copyLigandsByProximity(Structure, Structure, double, int, int)"}, "2372": {"callee_method_names": [], "method_name": "Fastq.getQuality", "method_implementation": "{\n    return quality;\n}", "repo_id": "9", "comment": "/**\n * Return the quality scores for this FASTQ formatted sequence.\n * The quality scores will not be null.\n *\n * @return the quality scores for this FASTQ formatted sequence\n */\n", "repo_name": "biojava-master/", "id": 2372, "method_signature": "String getQuality()"}, "1971": {"callee_method_names": [], "method_name": "HelixAxisAligner.getSubunits", "method_implementation": "{\n    return subunits;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getSubunits()\n\t */\n", "repo_name": "biojava-master/", "id": 1971, "method_signature": "QuatSymmetrySubunits getSubunits()"}, "2218": {"callee_method_ids": [1351, 1351], "callee_method_names": ["Structure.getEntityInfos", "EntityInfo.getType", "List<EntityInfo>.add", "List<EntityInfo>.size", "Structure.getPolyChainByPDB", "Structure.getPolyChainByPDB", "Structure.getPolyChainByPDB", "Chain.getGroupByPDB", "Chain.getEntityInfo", "Chain.getGroupByPDB", "Chain.getEntityInfo", "Chain.getGroupByPDB", "Chain.getEntityInfo", "Structure.getEntityInfos", "EntityInfo.getType", "List<EntityInfo>.add", "List<EntityInfo>.size", "Structure.getPolyChainByPDB", "Structure.getPolyChainByPDB", "Structure.getPolyChainByPDB", "Chain.getGroupByPDB", "Chain.getEntityInfo", "Chain.getGroupByPDB", "Chain.getEntityInfo", "Chain.getGroupByPDB", "Chain.getEntityInfo"], "method_name": "TestEntityResIndexMapping.test3ddoRawNoSeqres", "method_implementation": "{\n    // 3ddo has 6 chains in 1 entity, all of them with different residue numbering (chain A is 1000+, chain B 2000+ ...)\n    Structure s = getStructure(\"3ddo_raw_noseqres.pdb.gz\", true);\n    List<EntityInfo> polyEntities = new ArrayList<>();\n    for (EntityInfo entityInfo : s.getEntityInfos()) {\n        if (entityInfo.getType() == EntityType.POLYMER) {\n            polyEntities.add(entityInfo);\n        }\n    }\n    assertEquals(1, polyEntities.size());\n    Chain chainA = s.getPolyChainByPDB(\"A\");\n    Chain chainB = s.getPolyChainByPDB(\"B\");\n    Chain chainC = s.getPolyChainByPDB(\"C\");\n    // the last 3 residues of each chain are all the same: they should map to the same index\n    for (int resNum = 251; resNum <= 253; resNum++) {\n        Group groupInChainA = chainA.getGroupByPDB(new ResidueNumber(\"A\", resNum + 1000, null));\n        int indexInChainA = chainA.getEntityInfo().getAlignedResIndex(groupInChainA, chainA);\n        Group groupInChainB = chainB.getGroupByPDB(new ResidueNumber(\"B\", resNum + 2000, null));\n        int indexInChainB = chainB.getEntityInfo().getAlignedResIndex(groupInChainB, chainB);\n        Group groupInChainC = chainC.getGroupByPDB(new ResidueNumber(\"C\", resNum + 3000, null));\n        int indexInChainC = chainC.getEntityInfo().getAlignedResIndex(groupInChainC, chainC);\n        assertNotEquals(-1, indexInChainA);\n        assertNotEquals(-1, indexInChainB);\n        assertNotEquals(-1, indexInChainC);\n        assertEquals(indexInChainA, indexInChainB);\n        assertEquals(indexInChainA, indexInChainC);\n    }\n    // this should work either with or without setAlignSeqRes, since the mapping happens in EntityFinder\n    s = getStructure(\"3ddo_raw_noseqres.pdb.gz\", false);\n    polyEntities = new ArrayList<>();\n    for (EntityInfo entityInfo : s.getEntityInfos()) {\n        if (entityInfo.getType() == EntityType.POLYMER) {\n            polyEntities.add(entityInfo);\n        }\n    }\n    assertEquals(1, polyEntities.size());\n    chainA = s.getPolyChainByPDB(\"A\");\n    chainB = s.getPolyChainByPDB(\"B\");\n    chainC = s.getPolyChainByPDB(\"C\");\n    // the last 3 residues of each chain are all the same: they should map to the same index\n    for (int resNum = 251; resNum <= 253; resNum++) {\n        Group groupInChainA = chainA.getGroupByPDB(new ResidueNumber(\"A\", resNum + 1000, null));\n        int indexInChainA = chainA.getEntityInfo().getAlignedResIndex(groupInChainA, chainA);\n        Group groupInChainB = chainB.getGroupByPDB(new ResidueNumber(\"B\", resNum + 2000, null));\n        int indexInChainB = chainB.getEntityInfo().getAlignedResIndex(groupInChainB, chainB);\n        Group groupInChainC = chainC.getGroupByPDB(new ResidueNumber(\"C\", resNum + 3000, null));\n        int indexInChainC = chainC.getEntityInfo().getAlignedResIndex(groupInChainC, chainC);\n        assertNotEquals(-1, indexInChainA);\n        assertNotEquals(-1, indexInChainB);\n        assertNotEquals(-1, indexInChainC);\n        assertEquals(indexInChainA, indexInChainB);\n        assertEquals(indexInChainA, indexInChainC);\n    }\n}", "repo_id": "9", "comment": "// see https://github.com/eppic-team/eppic/issues/39\n", "repo_name": "biojava-master/", "id": 2218, "method_signature": "void test3ddoRawNoSeqres()"}, "2235": {"callee_method_names": ["Structure.isCrystallographic", "Structure.getChains", "Structure.getEntityInfos", "Structure.getEntityInfos"], "method_name": "CifFileConsumerImplTest.testPhenixCifFile", "method_implementation": "{\n    InputStream inputStream = new GZIPInputStream(getClass().getResourceAsStream(\"/org/biojava/nbio/structure/io/4lup_phenix_output.cif.gz\"));\n    Structure structure = new CifFileReader().getStructure(inputStream);\n    assertNotNull(structure);\n    assertTrue(structure.isCrystallographic());\n    // all ligands are into their own chains, so we have 2 proteins, 2 nucleotide chains, 1 ligand chain and 1 purely water chain\n    assertEquals(6, structure.getChains().size());\n    // 4 entities: 1 protein, 1 nucleotide, 1 water, 1 ligand (EDO)\n    assertEquals(4, structure.getEntityInfos().size());\n    int[] counts = countEntityTypes(structure.getEntityInfos());\n    assertEquals(2, counts[0]);\n    assertEquals(1, counts[1]);\n    assertEquals(1, counts[2]);\n}", "repo_id": "9", "comment": "/**\n * A test for reading a phenix-produced (ver 1.9_1692) mmCIF file. This is the file submitted to the PDB for\n * deposition of entry 4lup - See github issue #234\n * @throws IOException propagated\n */\n", "repo_name": "biojava-master/", "id": 2235, "method_signature": "void testPhenixCifFile()"}, "67": {"callee_method_names": [], "method_name": "AbstractMatrixAligner.getComputationTime", "method_implementation": "{\n    if (profile == null) {\n        align();\n    }\n    return time;\n}", "repo_id": "9", "comment": "// methods for Aligner\n", "repo_name": "biojava-master/", "id": 67, "method_signature": "long getComputationTime()"}, "3478": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.setAlignementOption", "method_implementation": "{\n    setAlignmentOption(BlastAlignmentParameterEnum.valueOf(key), val);\n}", "repo_id": "9", "comment": "/**\n * This method forwards to {@link #setAlignmentOption(BlastAlignmentParameterEnum, String)}. Consider using it\n * instead.\n */\n", "repo_name": "biojava-master/", "id": 3478, "method_signature": "void setAlignementOption(String, String)"}, "3238": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "DemoStructureFromFasta.buildJmolSelection", "method_implementation": "{\n    StringBuilder cmd = new StringBuilder(\"select \");\n    for (ResidueNumber res : residues) {\n        if (res != null) {\n            cmd.append(String.format(\"%d^%s:%s.CA or \", res.getSeqNum(), res.getInsCode() == null ? \" \" : res.getInsCode(), res.getChainName()));\n        }\n    }\n    //easier than removing the railing 'or'\n    cmd.append(\"none;\");\n    return cmd.toString();\n}", "repo_id": "9", "comment": "/**\n * Converts an array of ResidueNumbers into a jMol selection.\n *\n * <p>For example, \"select 11^ :A.CA or 12^ :A.CA;\" would select the\n * CA atoms of residues 11-12 on chain A.\n * @param residues Residues to include in the selection. Nulls are ignored.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3238, "method_signature": "String buildJmolSelection(ResidueNumber[])"}, "1897": {"callee_method_names": [], "method_name": "Stoichiometry.setAlphabet", "method_implementation": "{\n    this.alphabet = alphabet;\n    doResetAlphas();\n}", "repo_id": "9", "comment": "/**\n * Change alphabet used for string representation of a stoichiometry.\n * This action invalidates alphas already assigned to the clusters.\n * @param alphabet\n *          a sequence of characters used in this stoichiometry to construct human-readable representation.\n */\n", "repo_name": "biojava-master/", "id": 1897, "method_signature": "void setAlphabet(String)"}, "2247": {"callee_method_names": ["Structure.nrModels", "Structure.getModel", "Chain.getAtomGroups", "List<Atom>.add"], "method_name": "TestMmtfUtils.getAllAtoms", "method_implementation": "{\n    // Get all the atoms\n    List<Atom> theseAtoms = new ArrayList<Atom>();\n    for (int i = 0; i < bioJavaStruct.nrModels(); i++) {\n        List<Chain> chains = bioJavaStruct.getModel(i);\n        for (Chain c : chains) {\n            for (Group g : c.getAtomGroups()) {\n                for (Atom a : MmtfUtils.getAtomsForGroup(g)) {\n                    theseAtoms.add(a);\n                }\n            }\n        }\n    }\n    return theseAtoms;\n}", "repo_id": "9", "comment": "/**\n * Function to get all the atoms in the strucutre as a list.\n * @param bioJavaStruct the biojava structure\n * @return a list of all the unique atoms in the structure\n */\n", "repo_name": "biojava-master/", "id": 2247, "method_signature": "List<Atom> getAllAtoms(Structure)"}, "3326": {"callee_method_names": [], "method_name": "WrapLayout.addRow", "method_implementation": "{\n    dim.width = Math.max(dim.width, rowWidth);\n    if (dim.height > 0) {\n        dim.height += getVgap();\n    }\n    dim.height += rowHeight;\n}", "repo_id": "9", "comment": "/*\n\t *  A new row has been completed. Use the dimensions of this row\n\t *  to update the preferred size for the container.\n\t *\n\t *  @param dim update the width and height when appropriate\n\t *  @param rowWidth the width of the row to add\n\t *  @param rowHeight the height of the row to add\n\t */\n", "repo_name": "biojava-master/", "id": 3326, "method_signature": "void addRow(Dimension, int, int)"}, "1138": {"callee_method_names": ["URL.openConnection", "Logger.debug", "URL.toString", "Logger.warn", "URL.toString", "Logger.warn", "URL.toString"], "method_name": "LocalPDBDirectory.getLastModifiedTime", "method_implementation": "{\n    // see http://stackoverflow.com/questions/2416872/how-do-you-obtain-modified-date-from-a-remote-file-java\n    Date date = null;\n    try {\n        String lastModified = url.openConnection().getHeaderField(\"Last-Modified\");\n        logger.debug(\"Last modified date of server file ({}) is {}\", url.toString(), lastModified);\n        if (lastModified != null) {\n            try {\n                date = new SimpleDateFormat(\"E, d MMM yyyy HH:mm:ss Z\", Locale.ENGLISH).parse(lastModified);\n            } catch (ParseException e) {\n                logger.warn(\"Could not parse last modified time from string '{}', no last modified time available for file {}\", lastModified, url.toString());\n                // this will return null\n            }\n        }\n    } catch (IOException e) {\n        logger.warn(\"Problems while retrieving last modified time for file {}\", url.toString());\n    }\n    return date;\n}", "repo_id": "9", "comment": "/**\n * Get the last modified time of the file in given url by retrieveing the \"Last-Modified\" header.\n * Note that this only works for http URLs\n * @param url\n * @return the last modified date or null if it couldn't be retrieved (in that case a warning will be logged)\n */\n", "repo_name": "biojava-master/", "id": 1138, "method_signature": "Date getLastModifiedTime(URL)"}, "1678": {"callee_method_names": ["String.trim", "String.startsWith", "String.substring", "String.endsWith", "String.substring", "String.length", "String.split", "List<ResidueRange>.add"], "method_name": "ResidueRange.parseMultiple", "method_implementation": "{\n    s = s.trim();\n    // trim parentheses, for backwards compatibility\n    if (s.startsWith(\"(\"))\n        s = s.substring(1);\n    if (s.endsWith(\")\")) {\n        s = s.substring(0, s.length() - 1);\n    }\n    String[] parts = s.split(\",\");\n    List<ResidueRange> list = new ArrayList<ResidueRange>(parts.length);\n    for (String part : parts) {\n        list.add(parse(part));\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * @param s\n *            A string of the form chain_start-end,chain_start-end, ... For example:\n *            <code>A.5-100,R_110-190,Z_200-250</code>.\n * @return The unique ResidueRange corresponding to {@code s}.\n * @see #parse(String)\n */\n", "repo_name": "biojava-master/", "id": 1678, "method_signature": "List<ResidueRange> parseMultiple(String)"}, "1373": {"callee_method_names": [], "method_name": "DBRef.setIdCode", "method_implementation": "{\n    this.idCode = idCode;\n}", "repo_id": "9", "comment": "/**\n * Set the idCode for this entry.\n *\n * @param idCode the idCode for this entry\n * @see #getIdCode()\n */\n", "repo_name": "biojava-master/", "id": 1373, "method_signature": "void setIdCode(String)"}, "3031": {"callee_method_names": ["LocationPredicate.accept"], "method_name": "Location.scanLocations", "method_implementation": "{\n    Location location = null;\n    for (Location l : locations) {\n        if (location == null) {\n            location = l;\n        } else {\n            if (predicate.accept(location, l)) {\n                location = l;\n            }\n        }\n    }\n    return location;\n}", "repo_id": "9", "comment": "/**\n * Used for scanning through a list of locations; assumes the\n * locations given will have at least one value otherwise\n * we will get a null pointer\n */\n", "repo_name": "biojava-master/", "id": 3031, "method_signature": "Location scanLocations(List, LocationPredicate)"}, "3815": {"callee_method_names": [], "method_name": "CensorStatus.getPercentage", "method_implementation": "{\n    return percentage;\n}", "repo_id": "9", "comment": "/**\n * @return the percentage\n */\n", "repo_name": "biojava-master/", "id": 3815, "method_signature": "Double getPercentage()"}, "1652": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setUseEntityIdForSeqIdentityDetermination", "method_implementation": "{\n    this.useEntityIdForSeqIdentityDetermination = useEntityIdForSeqIdentityDetermination;\n}", "repo_id": "9", "comment": "/**\n * Whether to use the entity id of subunits to infer that sequences are identical.\n * Only applies if the {@link SubunitClustererMethod} is a sequence based one.\n * Note this requires {@link org.biojava.nbio.structure.io.FileParsingParameters#setAlignSeqRes(boolean)} to be\n * set to true.\n * @param useEntityIdForSeqIdentityDetermination the flag to be set\n * @since 5.4.0\n */\n", "repo_name": "biojava-master/", "id": 1652, "method_signature": "void setUseEntityIdForSeqIdentityDetermination(boolean)"}, "437": {"callee_method_ids": [484, 497], "callee_method_names": ["AFPChain.getAfpSet", "List<AFP>.size", "AFPChain.getAfpChainLen", "AFPChain.setShortAlign", "SigEva.calSigAll", "AFPChain.setProbability", "SigEva.calNS", "AFPChain.setNormAlignScore", "AFPChain.setTMScore", "AFPChain.getAlignScore", "AFPChain.getOptLength", "AFPChain.getTotalRmsdOpt"], "method_name": "FatCatAligner.chainAfp", "method_implementation": "{\n    // we don;t want to rotate input atoms, do we?\n    Atom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n    List<AFP> afpSet = afpChain.getAfpSet();\n    if (debug)\n        System.out.println(\"entering chainAfp\");\n    int afpNum = afpSet.size();\n    if (afpNum < 1)\n        return new Group[0];\n    long bgtime = System.currentTimeMillis();\n    if (debug) {\n        System.out.println(String.format(\"total AFP %d\\n\", afpNum));\n    }\n    //run AFP chaining\n    AFPChainer.doChainAfp(params, afpChain, ca1, ca2);\n    int afpChainLen = afpChain.getAfpChainLen();\n    if (afpChainLen < 1) {\n        afpChain.setShortAlign(true);\n        return new Group[0];\n    }\n    //very short alignment\n    long chaintime = System.currentTimeMillis();\n    if (debug) {\n        System.out.println(\"Afp chaining: time \" + (chaintime - bgtime));\n    }\n    // do post processing\n    AFPPostProcessor.postProcess(params, afpChain, ca1, ca2);\n    // Optimize the final alignment\n    AFPOptimizer.optimizeAln(params, afpChain, ca1, ca2);\n    AFPOptimizer.blockInfo(afpChain);\n    AFPOptimizer.updateScore(params, afpChain);\n    AFPAlignmentDisplay.getAlign(afpChain, ca1, ca2);\n    Group[] twistedPDB = AFPTwister.twistPDB(afpChain, ca1, ca2clone);\n    SigEva sig = new SigEva();\n    double probability = sig.calSigAll(params, afpChain);\n    afpChain.setProbability(probability);\n    double normAlignScore = sig.calNS(params, afpChain);\n    afpChain.setNormAlignScore(normAlignScore);\n    double tmScore = AFPChainScorer.getTMScore(afpChain, ca1, ca2, false);\n    afpChain.setTMScore(tmScore);\n    /*\n\n\t\tSIGEVA  sig;\n\t\tprobability = sig.calSigAll(maxTra, sparse, pro1Len, pro2Len, alignScore, totalRmsdOpt, optLength, blockNum - 1);\n\t\tnormAlignScore = sig.calNS(pro1Len, pro2Len, alignScore, totalRmsdOpt, optLength, blockNum - 1);\n\n\t\t */\n    //if(maxTra == 0)       probability = sig.calSigRigid(pro1Len, pro2Len, alignScore, totalRmsdOpt, optLength);\n    //else  probability = sig.calSigFlexi(pro1Len, pro2Len, alignScore, totalRmsdOpt, optLength, blockNum - 1);\n    if (debug) {\n        long nowtime = System.currentTimeMillis();\n        long diff = nowtime - chaintime;\n        System.out.println(\"Alignment optimization: time \" + diff);\n        System.out.println(\"score:      \" + afpChain.getAlignScore());\n        System.out.println(\"opt length: \" + afpChain.getOptLength());\n        System.out.println(\"opt rmsd:   \" + afpChain.getTotalRmsdOpt());\n    }\n    return twistedPDB;\n}", "repo_id": "9", "comment": "/**\n * run AFP chaining allowing up to maxTra flexible regions.\n * Input is original coordinates.\n */\n", "repo_name": "biojava-master/", "id": 437, "method_signature": "Group[] chainAfp(FatCatParameters, AFPChain, Atom[], Atom[])"}, "2204": {"callee_method_names": ["ResidueNumber.getSeqNum"], "method_name": "ResidueNumberTest.testGetSetResidueNumber", "method_implementation": "{\n    //        System.out.println(\"getSeqNum\");\n    ResidueNumber instance = new ResidueNumber(\"A\", 42, ' ');\n    Integer expResult = 42;\n    Integer result = instance.getSeqNum();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of getSeqNum method, of class ResidueNumber.\n */\n", "repo_name": "biojava-master/", "id": 2204, "method_signature": "void testGetSetResidueNumber()"}, "2416": {"callee_method_names": [], "method_name": "Location.startsBefore", "method_implementation": "{\n    if (isSameStrand(other)) {\n        return mStart < other.mStart;\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Check if this location starts before other location starts.\n * The locations may overlap.\n *\n * @param other The location to compare.\n * @return True if this starts before other.\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2416, "method_signature": "boolean startsBefore(Location)"}, "1705": {"callee_method_names": ["Map<String, AminoAcid>.get"], "method_name": "StandardAminoAcid.getAminoAcid", "method_implementation": "{\n    return aminoAcids.get(name);\n}", "repo_id": "9", "comment": "/**\n * get a standard amino acid.\n *\n * @param name the 3- or 1-letter representation of the amino acid.\n * @return the amino acids, or null if the name can not be matched\n */\n", "repo_name": "biojava-master/", "id": 1705, "method_signature": "AminoAcid getAminoAcid(String)"}, "733": {"callee_method_names": ["Atom[].getGroup", "Atom[].getName", "Group.getAtom"], "method_name": "CeCalculatorEnhanced.setStrBuf", "method_implementation": "{\n    // TODO Auto-generated method stub\n    //TODO\n    Group parent = ca[j].getGroup();\n    int pos = 0;\n    String atomName = ca[j].getName();\n    Atom a = null;\n    a = parent.getAtom(atomName);\n    if (a != null) {\n        strBuf[i] = a;\n    } else {\n        // probably a GLY and no CB was found...\n        //e.printStackTrace();\n    }\n    strBuf[i + pos] = a;\n    pos++;\n}", "repo_id": "9", "comment": "/**\n * set the Atoms for a particular residue position.\n * Requires that atom.getParent returns the correct group!\n * take care during cloning of atoms. Best to use StructureTools.cloneCaAtoms();\n *\n * @param strBuf\n * @param i\n * @param ca\n * @param j\n */\n", "repo_name": "biojava-master/", "id": 733, "method_signature": "void setStrBuf(Atom[], int, Atom[], int)"}, "3795": {"callee_method_ids": [3784], "callee_method_names": ["LinkedHashMap<String,ArrayList<CensorStatus>>.keySet", "LinkedHashMap<String,ArrayList<CensorStatus>>.get", "Double.floatValue", "SurvFitKM.process"], "method_name": "KaplanMeierFigure.setSurvivalData", "method_implementation": "{\n    this.title = title;\n    this.survivalData = survivalData;\n    Double mTime = null;\n    ArrayList<String> labels = new ArrayList<String>(survivalData.keySet());\n    Collections.sort(labels);\n    for (String legend : labels) {\n        ArrayList<CensorStatus> censorStatusList = survivalData.get(legend);\n        for (CensorStatus cs : censorStatusList) {\n            if (mTime == null || cs.time > mTime) {\n                mTime = cs.time;\n            }\n        }\n    }\n    int evenCheck = Math.round(mTime.floatValue());\n    if (evenCheck % 2 == 1) {\n        evenCheck = evenCheck + 1;\n    }\n    this.maxTime = evenCheck;\n    if (userSetMaxTime != null && userSetMaxTime > maxTime) {\n        this.maxTime = userSetMaxTime;\n    }\n    //calculate percentages\n    SurvFitKM survFitKM = new SurvFitKM();\n    sfi = survFitKM.process(survivalData, useWeighted);\n    this.repaint();\n}", "repo_id": "9", "comment": "/**\n * @param title\n * @param survivalData\n * @param userSetMaxTime\n * @param useWeighted\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3795, "method_signature": "void setSurvivalData(ArrayList, LinkedHashMap, Double, Boolean)"}, "73": {"callee_method_names": [], "method_name": "AnchoredPairwiseSequenceAligner.setAnchors", "method_implementation": "{\n    super.anchors = new ArrayList<Anchor>();\n    if (anchors != null) {\n        for (int i = 0; i < anchors.length; i++) {\n            if (anchors[i] >= 0) {\n                addAnchor(i, anchors[i]);\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Sets the starting list of anchors before running the alignment routine.\n *\n * @param anchors list of points that are tied to the given indices in the target\n */\n", "repo_name": "biojava-master/", "id": 73, "method_signature": "void setAnchors(int[])"}, "901": {"callee_method_names": ["List<StructureInterface>.get"], "method_name": "StructureInterfaceList.get", "method_implementation": "{\n    return list.get(id - 1);\n}", "repo_id": "9", "comment": "/**\n * Gets the interface corresponding to given id.\n * The ids go from 1 to n\n * If {@link #sort()} was called then the order is descendent by area.\n * @param id\n * @return\n */\n", "repo_name": "biojava-master/", "id": 901, "method_signature": "StructureInterface get(int)"}, "3132": {"callee_method_names": ["ArrayList<String>.add", "Element.getTextContent", "Element.getTextContent", "String.trim", "ArrayList<String>.add"], "method_name": "UniprotProxySequenceReader.getProteinAliasesFromElement", "method_implementation": "{\n    Element fullNameElement = XMLHelper.selectSingleElement(element, \"fullName\");\n    aliasList.add(fullNameElement.getTextContent());\n    Element shortNameElement = XMLHelper.selectSingleElement(element, \"shortName\");\n    if (null != shortNameElement) {\n        String shortName = shortNameElement.getTextContent();\n        if (null != shortName && !shortName.trim().isEmpty()) {\n            aliasList.add(shortName);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @param aliasList\n * @param element\n * @throws XPathExpressionException\n */\n", "repo_name": "biojava-master/", "id": 3132, "method_signature": "void getProteinAliasesFromElement(ArrayList, Element)"}, "2952": {"callee_method_names": [], "method_name": "SequenceProxyView.setBioStart", "method_implementation": "{\n    if (bioStart < 1) {\n        throw new IllegalArgumentException(\"The given start \" + bioStart + \" is less than 1; cannot index less than 1\");\n    }\n    this.bioStart = bioStart;\n}", "repo_id": "9", "comment": "/**\n * @param bioStart the bioStart to set\n */\n", "repo_name": "biojava-master/", "id": 2952, "method_signature": "void setBioStart(Integer)"}, "434": {"callee_method_names": [], "method_name": "FatCatParameters.isOptimizeAlignment", "method_implementation": "{\n    return optimizeAlignment;\n}", "repo_id": "9", "comment": "/**\n * Whether the alignment algorithm should try its best to optimize the alignment,\n * or we are happy with a quick and dirty result.\n * NB: Not implemented in jFatCat\n *\n * @return optimizeAlignment\n */\n", "repo_name": "biojava-master/", "id": 434, "method_signature": "boolean isOptimizeAlignment()"}, "408": {"callee_method_names": [], "method_name": "FCAlignHelper.del", "method_implementation": "{\n    //if(last < 0)    last = sapp[-1] -= (k);\n    //else            last = *sapp++ = -(k);\n    if (last < 0)\n        last = sapp[sappPos - 1] -= (k);\n    else\n        last = sapp[(sappPos++)] = -(k);\n}", "repo_id": "9", "comment": "//-----------------------------------------------------------------------------\n", "repo_name": "biojava-master/", "id": 408, "method_signature": "void del(int)"}, "426": {"callee_method_names": [], "method_name": "AFPCalculator.getEnd2EndDistance", "method_implementation": "{\n    double min = 99;\n    double dist1 = Calc.getDistance(ca1[p1b], ca1[p1e]);\n    double dist2 = Calc.getDistance(ca2[p2b], ca2[p2e]);\n    min = dist1 - dist2;\n    return Math.abs(min);\n}", "repo_id": "9", "comment": "/**\n * filter 1 for AFP extration: the distance of end-to-end\n * @param p1b\n * @param p1e\n * @param p2b\n * @param p2e\n * @return\n */\n", "repo_name": "biojava-master/", "id": 426, "method_signature": "double getEnd2EndDistance(Atom[], Atom[], int, int, int, int)"}, "2216": {"callee_method_ids": [1330], "callee_method_names": ["FileParsingParameters.setCreateAtomBonds", "String.getBytes", "Structure.getPolyChains", "Chain.getAtomGroups", "Chain.getAtomGroup", "Group.getAltLocs", "Group.getAtoms", "Block.getBonds", "Block.getAtomA", "Block.getAtomB", "Block.getAtomA", "Block.getAtomB", "Block.getAtomA", "Block.getAtomB", "Block.getAtomA", "Block.getAtomB"], "method_name": "TestAltLocs.testIntraResidueBondsBetweenAltlocs", "method_implementation": "{\n    // from 5MOO\n    String mmcifData = \"data_test\\n\" + \"loop_\\n\" + \"_atom_site.group_PDB \\n\" + \"_atom_site.id \\n\" + \"_atom_site.type_symbol \\n\" + \"_atom_site.label_atom_id \\n\" + \"_atom_site.label_alt_id \\n\" + \"_atom_site.label_comp_id \\n\" + \"_atom_site.label_asym_id \\n\" + \"_atom_site.label_entity_id \\n\" + \"_atom_site.label_seq_id \\n\" + \"_atom_site.pdbx_PDB_ins_code \\n\" + \"_atom_site.Cartn_x \\n\" + \"_atom_site.Cartn_y \\n\" + \"_atom_site.Cartn_z \\n\" + \"_atom_site.occupancy \\n\" + \"_atom_site.B_iso_or_equiv \\n\" + \"_atom_site.pdbx_formal_charge \\n\" + \"_atom_site.auth_seq_id \\n\" + \"_atom_site.auth_comp_id \\n\" + \"_atom_site.auth_asym_id \\n\" + \"_atom_site.auth_atom_id \\n\" + \"_atom_site.pdbx_PDB_model_num \\n\" + \"ATOM   1405 N  N    A MET A 1 86  ? 10.748  -17.610 -6.975  0.47 16.12 ? 104 MET A N    1 \\n\" + \"ATOM   1406 N  N    B MET A 1 86  ? 10.802  -17.694 -6.986  0.53 17.92 ? 104 MET A N    1 \\n\" + \"ATOM   1407 C  CA   A MET A 1 86  ? 11.189  -17.392 -5.610  0.47 15.78 ? 104 MET A CA   1 \\n\" + \"ATOM   1408 C  CA   B MET A 1 86  ? 11.033  -17.368 -5.587  0.53 18.29 ? 104 MET A CA   1 \\n\" + \"ATOM   1409 C  C    A MET A 1 86  ? 10.952  -18.663 -4.810  0.47 15.91 ? 104 MET A C    1 \\n\" + \"ATOM   1410 C  C    B MET A 1 86  ? 10.882  -18.643 -4.767  0.53 17.40 ? 104 MET A C    1 \\n\" + \"ATOM   1411 O  O    A MET A 1 86  ? 10.120  -19.504 -5.154  0.47 18.21 ? 104 MET A O    1 \\n\" + \"ATOM   1412 O  O    B MET A 1 86  ? 10.018  -19.474 -5.052  0.53 20.02 ? 104 MET A O    1 \\n\" + \"ATOM   1413 C  CB   A MET A 1 86  ? 10.477  -16.204 -4.933  0.47 17.14 ? 104 MET A CB   1 \\n\" + \"ATOM   1414 C  CB   B MET A 1 86  ? 10.001  -16.336 -5.111  0.53 18.92 ? 104 MET A CB   1 \\n\" + \"ATOM   1415 C  CG   A MET A 1 86  ? 9.019   -16.476 -4.619  0.47 20.01 ? 104 MET A CG   1 \\n\" + \"ATOM   1416 C  CG   B MET A 1 86  ? 10.030  -16.038 -3.634  0.53 19.12 ? 104 MET A CG   1 \\n\" + \"ATOM   1417 S  SD   A MET A 1 86  ? 8.207   -15.088 -3.838  0.47 22.06 ? 104 MET A SD   1 \\n\" + \"ATOM   1418 S  SD   B MET A 1 86  ? 8.874   -14.724 -3.205  0.53 20.16 ? 104 MET A SD   1 \\n\" + \"ATOM   1419 C  CE   A MET A 1 86  ? 9.151   -14.973 -2.340  0.47 25.15 ? 104 MET A CE   1 \\n\" + \"ATOM   1420 C  CE   B MET A 1 86  ? 7.269   -15.536 -3.380  0.53 20.38 ? 104 MET A CE   1 \\n\" + \"ATOM   1421 H  H    A MET A 1 86  ? 9.931   -18.207 -7.055  0.47 15.58 ? 104 MET A H    1 \\n\" + \"ATOM   1422 H  H    B MET A 1 86  ? 10.144  -18.461 -7.109  0.53 18.91 ? 104 MET A H    1 \\n\" + \"ATOM   1423 H  HA   A MET A 1 86  ? 12.256  -17.182 -5.644  0.47 15.14 ? 104 MET A HA   1 \\n\" + \"ATOM   1424 H  HA   B MET A 1 86  ? 12.033  -16.953 -5.465  0.53 19.55 ? 104 MET A HA   1 \\n\" + \"ATOM   1425 H  HB2  A MET A 1 86  ? 10.986  -15.920 -4.008  0.47 17.68 ? 104 MET A HB2  1 \\n\" + \"ATOM   1426 H  HB3  A MET A 1 86  ? 10.484  -15.364 -5.622  0.47 17.68 ? 104 MET A HB3  1 \\n\" + \"ATOM   1427 H  HB3  B MET A 1 86  ? 9.001   -16.676 -5.398  0.53 20.49 ? 104 MET A HB3  1 \\n\" + \"ATOM   1428 H  HG2  A MET A 1 86  ? 8.490   -16.704 -5.546  0.47 20.93 ? 104 MET A HG2  1 \\n\" + \"ATOM   1429 H  HG3  A MET A 1 86  ? 8.956   -17.315 -3.927  0.47 20.93 ? 104 MET A HG3  1 \\n\" + \"ATOM   1430 H  HE2  A MET A 1 86  ? 9.861   -14.153 -2.440  0.47 27.31 ? 104 MET A HE2  1 \\n\" + \"ATOM   1431 H  HE2  B MET A 1 86  ? 7.346   -16.554 -2.998  0.53 23.03 ? 104 MET A HE2  1 \\n\" + \"ATOM   1432 H  HE3  B MET A 1 86  ? 6.996   -15.566 -4.437  0.53 23.03 ? 104 MET A HE3  1 \";\n    FileParsingParameters params = new FileParsingParameters();\n    params.setCreateAtomBonds(true);\n    Structure s = CifStructureConverter.fromInputStream(new ByteArrayInputStream(mmcifData.getBytes()), params);\n    Chain c = s.getPolyChains().get(0);\n    assertEquals(1, c.getAtomGroups().size());\n    Group g = c.getAtomGroup(0);\n    assertEquals(1, g.getAltLocs().size());\n    boolean foundCEHE3bond = false;\n    for (Atom a : g.getAtoms()) {\n        for (Bond b : a.getBonds()) {\n            //\t\t\t\tif (b.getAtomA().getAltLoc() != b.getAtomB().getAltLoc()) {\n            //\t\t\t\t\tSystem.out.println(\n            //\t\t\t\t\t\t\tb.getAtomA().toString() + \": '\" + b.getAtomA().getAltLoc() + \"' --- \" +\n            //\t\t\t\t\t\t\tb.getAtomB().toString() + \": '\" + b.getAtomB().getAltLoc() + \"'\");\n            //\t\t\t\t}\n            // no bonds between atoms with different alt locs\n            assertEquals(b.getAtomA().toString() + \" --- \" + b.getAtomB().toString(), b.getAtomA().getAltLoc(), b.getAtomB().getAltLoc());\n            // a bond should exist between CE and HE3 but only for altloc=B\n            if ((b.getAtomA().getName().equals(\"CE\") && b.getAtomB().getName().equals(\"HE3\")) || (b.getAtomA().getName().equals(\"HE3\") && b.getAtomB().getName().equals(\"CE\"))) {\n                foundCEHE3bond = true;\n            }\n        }\n    }\n    // there should be a bond between CE and HE3 but only for altloc=B\n    assertTrue(foundCEHE3bond);\n}", "repo_id": "9", "comment": "/**\n * Test that intra-residue bonds between alt locs link atoms with same altloc codes\n * https://github.com/rcsb/mmtf/issues/44\n */\n", "repo_name": "biojava-master/", "id": 2216, "method_signature": "void testIntraResidueBondsBetweenAltlocs()"}, "1603": {"callee_method_names": ["Atom.setName"], "method_name": "SecStrucCalc.calc_H", "method_implementation": "{\n    Atom nc = Calc.subtract(N, C);\n    Atom nca = Calc.subtract(N, CA);\n    Atom u_nc = Calc.unitVector(nc);\n    Atom u_nca = Calc.unitVector(nca);\n    Atom added = Calc.add(u_nc, u_nca);\n    Atom U = Calc.unitVector(added);\n    // according to Creighton distance N-H is 1.03 +/- 0.02A\n    Atom H = Calc.add(N, U);\n    H.setName(\"H\");\n    // this atom does not have a pdbserial number ...\n    return H;\n}", "repo_id": "9", "comment": "/**\n * Use unit vectors NC and NCalpha Add them. Calc unit vector and\n * substract it from N.\n * C coordinates are from amino acid i-1\n * N, CA atoms from amino acid i\n *\n * @link http://openbioinformatics.blogspot.com/\n * \t\t2009/08/how-to-calculate-h-atoms-for-nitrogens.html\n */\n", "repo_name": "biojava-master/", "id": 1603, "method_signature": "Atom calc_H(Atom, Atom, Atom)"}, "2105": {"callee_method_names": ["List<Axis>.get", "List<Integer>.add"], "method_name": "SymmetryAxes.getFirstRepeats", "method_implementation": "{\n    List<Integer> firstRepeats = new ArrayList<Integer>();\n    //size of the level\n    int m = getNumRepeats(level + 1);\n    //degree of this level\n    int d = axes.get(level).getOrder();\n    // number of repeats included in each axis\n    int n = m * d;\n    for (int firstRepeat = 0; firstRepeat < getNumRepeats(); firstRepeat += n) firstRepeats.add(firstRepeat);\n    return firstRepeats;\n}", "repo_id": "9", "comment": "/**\n * Get the first repeat index of each axis of a specified level.\n * @param level level of the tree to cut at\n * @return List of first Repeats of each index, sorted in ascending order\n */\n", "repo_name": "biojava-master/", "id": 2105, "method_signature": "List<Integer> getFirstRepeats(int)"}, "1982": {"callee_method_ids": [1929], "callee_method_names": ["QuatSymmetryResults.getSymmetry"], "method_name": "AxisAligner.getInstance", "method_implementation": "{\n    String symmetry = results.getSymmetry();\n    if (\"H\".equals(symmetry)) {\n        return new HelixAxisAligner(results);\n    } else {\n        return new RotationAxisAligner(results);\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns an instance of AxisAligner for differnt type of QuatSymmetryResults (factory method)\n * @param results symmetry results\n * @return instance of AxisAligner\n */\n", "repo_name": "biojava-master/", "id": 1982, "method_signature": "AxisAligner getInstance(QuatSymmetryResults)"}, "665": {"callee_method_names": ["List<Atom[]>.size", "List<Atom[]>.get", "Structure.addModel"], "method_name": "MultipleAlignmentTools.getAlignedStructure", "method_implementation": "{\n    Structure s = new StructureImpl();\n    for (int i = 0; i < atomArrays.size(); i++) {\n        List<Chain> model = AlignmentTools.getAlignedModel(atomArrays.get(i));\n        s.addModel(model);\n    }\n    return s;\n}", "repo_id": "9", "comment": "/**\n * Get an artificial Structure containing a different model for every\n * input structure, so that the alignment result can be viewed in Jmol.\n * The Atoms have to be rotated beforehand.\n *\n * @param atomArrays an array of Atoms for every aligned structure\n * @return a structure object containing a set of models,\n * \t\t\tone for each input array of Atoms.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 665, "method_signature": "Structure getAlignedStructure(List)"}, "3618": {"callee_method_names": ["DecimalFormat.format", "DecimalFormat.format", "String.length"], "method_name": "CoxInfo.fmt", "method_implementation": "{\n    if (d == null)\n        return \"\";\n    if (Double.isNaN(d))\n        return \"\";\n    String value = \"\";\n    DecimalFormat dfe = new DecimalFormat(\"0.00E0\");\n    String dpad = \"0.\";\n    double p = 1.0;\n    for (int i = 0; i < (precision); i++) {\n        dpad = dpad + \"0\";\n        p = p / 10.0;\n    }\n    DecimalFormat df = new DecimalFormat(dpad);\n    if (Math.abs(d) >= p) {\n        value = df.format(d);\n    } else {\n        value = dfe.format(d);\n    }\n    int length = value.length();\n    int extra = pad - length;\n    if (extra > 0) {\n        for (int i = 0; i < extra; i++) {\n            value = \" \" + value;\n        }\n    }\n    return value;\n}", "repo_id": "9", "comment": "/**\n * @param d\n * @param precision\n * @param pad\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3618, "method_signature": "String fmt(Double, int, int)"}, "171": {"callee_method_names": ["AminoAcid.size", "AminoAcid.size"], "method_name": "StructureTest.testStandardAmino", "method_implementation": "{\n    AminoAcid arg = StandardAminoAcid.getAminoAcid(\"ARG\");\n    assertTrue(arg.size() == 11);\n    AminoAcid gly = StandardAminoAcid.getAminoAcid(\"G\");\n    assertTrue(gly.size() == 4);\n}", "repo_id": "9", "comment": "/**\n * Tests that standard amino acids are working properly\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 171, "method_signature": "void testStandardAmino()"}, "2907": {"callee_method_names": [], "method_name": "AbstractSequence.setAnnotationType", "method_implementation": "{\n    this.annotationType = annotationType;\n}", "repo_id": "9", "comment": "/**\n * @param annotationType the annotation to set\n */\n", "repo_name": "biojava-master/", "id": 2907, "method_signature": "void setAnnotationType(AnnotationType)"}, "1534": {"callee_method_names": [], "method_name": "JournalArticle.getTitle", "method_implementation": "{\n    return title;\n}", "repo_id": "9", "comment": "/**\n * Get the value of title\n *\n * @return the value of title\n */\n", "repo_name": "biojava-master/", "id": 1534, "method_signature": "String getTitle()"}, "1968": {"callee_method_names": ["Matrix4d.setTranslation"], "method_name": "HelixAxisAligner.getGeometicCenterTransformation", "method_implementation": "{\n    run();\n    Matrix4d geometricCentered = new Matrix4d(reverseTransformationMatrix);\n    geometricCentered.setTranslation(new Vector3d(getGeometricCenter()));\n    return geometricCentered;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getGeometicCenterTransformation()\n\t */\n", "repo_name": "biojava-master/", "id": 1968, "method_signature": "Matrix4d getGeometicCenterTransformation()"}, "108": {"callee_method_names": [], "method_name": "DistanceMatrixCalculator.kimuraDistance", "method_implementation": "{\n    Msa fMsa = ForesterWrapper.convert(msa);\n    DistanceMatrix DM = PairwiseDistanceCalculator.calcPoissonDistances(fMsa);\n    return DM;\n}", "repo_id": "9", "comment": "/**\n * The Kimura evolutionary distance (d) is a correction of the fractional\n * dissimilarity (D) specially needed for large evolutionary distances. It\n * is given by:\n *\n * <pre>\n * d = -log(1 - D - 0.2 * D<sup>2</sup>)\n * </pre>\n *\n * The equation is derived by fitting the relationship between the\n * evolutionary distance (d) and the fractional dissimilarity (D) according\n * to the PAM model of evolution (it is an empirical approximation for the\n * method {@link #pamDistance(MultipleSequenceAlignment}). The gapped\n * positons in the alignment are ignored in the calculation. This method is\n * a wrapper to the forester implementation of the calculation:\n * {@link PairwiseDistanceCalculator#calcKimuraDistances(Msa)}.\n *\n * @param msa\n *            MultipleSequenceAlignment\n * @return DistanceMatrix\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 108, "method_signature": "DistanceMatrix kimuraDistance(MultipleSequenceAlignment)"}, "2656": {"callee_method_names": [], "method_name": "TranscriptionEngine.decorateRna", "method_implementation": "{\n    this.decorateRna = decorateRna;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Performs an optimisation where RNASequences are not translated into\n * their own objects but are views onto the base DNA sequence.\n */\n", "repo_name": "biojava-master/", "id": 2656, "method_signature": "Builder decorateRna(boolean)"}, "1014": {"callee_method_names": ["NucleotideImpl.setPDBFlag", "NucleotideImpl.setResidueNumber", "NucleotideImpl.setPDBName", "NucleotideImpl.addAltLoc", "NucleotideImpl.setChemComp"], "method_name": "NucleotideImpl.clone", "method_implementation": "{\n    NucleotideImpl n = new NucleotideImpl();\n    n.setPDBFlag(has3D());\n    n.setResidueNumber(getResidueNumber());\n    n.setPDBName(getPDBName());\n    //clone atoms and bonds.\n    cloneAtomsAndBonds(n);\n    // copying the alt loc groups if present, otherwise they stay null\n    if (getAltLocs() != null && !getAltLocs().isEmpty()) {\n        for (Group altLocGroup : this.getAltLocs()) {\n            Group nAltLocGroup = (Group) altLocGroup.clone();\n            n.addAltLoc(nAltLocGroup);\n        }\n    }\n    if (chemComp != null)\n        n.setChemComp(chemComp);\n    return n;\n}", "repo_id": "9", "comment": "// that's due to issue https://github.com/biojava/biojava/issues/631 - JD 2017-01-21\n", "repo_name": "biojava-master/", "id": 1014, "method_signature": "Object clone()"}, "199": {"callee_method_names": ["List<FastaSequence>.stream"], "method_name": "Jronn.getDisorderScores", "method_implementation": "{\n    Map<FastaSequence, float[]> results = new TreeMap<FastaSequence, float[]>();\n    results = sequences.stream().collect(Collectors.toMap(fastaSequence -> fastaSequence, fastaSequence -> predictSerial(fastaSequence)));\n    return results;\n}", "repo_id": "9", "comment": "/**\n * Calculates the probability of disorder scores for each residue in the sequence for\n * many sequences in the input.\n *\n * @param sequences the list of the FastaSequence objects\n * @return the Map with key->FastaSequence, value->probability of disorder for each residue\n * @see #getDisorder(FastaSequence)\n */\n", "repo_name": "biojava-master/", "id": 199, "method_signature": "Map<FastaSequence,float[]> getDisorderScores(List)"}, "1553": {"callee_method_names": [], "method_name": "ScopInstallation.getScopVersion", "method_implementation": "{\n    return scopVersion;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopVersion()\n\t */\n", "repo_name": "biojava-master/", "id": 1553, "method_signature": "String getScopVersion()"}, "2623": {"callee_method_names": ["Collection<String>.stream"], "method_name": "StringManipulationHelper.join", "method_implementation": "{\n    if (s == null)\n        return \"\";\n    return s.stream().collect(Collectors.joining(delimiter));\n}", "repo_id": "9", "comment": "/**\n * Joins Strings together with a delimiter to a single\n * @param s An {@link Iterable} of Strings\n * @param delimiter\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2623, "method_signature": "String join(Collection, String)"}, "2548": {"callee_method_names": ["Object.getClass"], "method_name": "Result.equals", "method_implementation": "{\n    if (obj == null) {\n        return false;\n    }\n    if (getClass() != obj.getClass()) {\n        return false;\n    }\n    final Result other = (Result) obj;\n    if ((this.queryID == null) ? (other.queryID != null) : !this.queryID.equals(other.queryID)) {\n        return false;\n    }\n    if ((this.queryDef == null) ? (other.queryDef != null) : !this.queryDef.equals(other.queryDef)) {\n        return false;\n    }\n    if (this.hits != other.hits && (this.hits == null || !this.hits.equals(other.hits))) {\n        return false;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Experimental.\n * Wants to return an hashcode designed to allow conceptual comparisons of search results.\n * Wants to implement conceptual comparisons of search results.\n * Fields unrelated to search are deliberately not considered.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2548, "method_signature": "boolean equals(Object)"}, "430": {"callee_method_names": [], "method_name": "FatCatParameters.setRmsdCut", "method_implementation": "{\n    this.rmsdCut = rmsdCut;\n}", "repo_id": "9", "comment": "/**\n * The cutoff to be used during AFP detection\n *\n * @param rmsdCut\n */\n", "repo_name": "biojava-master/", "id": 430, "method_signature": "void setRmsdCut(Double)"}, "2827": {"callee_method_names": ["String.length", "String.length", "List<Object>.add", "String.charAt"], "method_name": "CasePreservingProteinSequenceCreator.getStringCase", "method_implementation": "{\n    List<Object> types = new ArrayList<Object>(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        types.add(Character.isUpperCase(str.charAt(i)));\n    }\n    return types;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of Booleans of the same length as the input, specifying\n * whether each character was uppercase or not.\n * @param str A string. Should not contain unicode supplemental characters.\n * @return a list of Booleans of the same length as the input, specifying\n * whether each character was uppercase or not.\n * This list contains only Booleans.\n */\n", "repo_name": "biojava-master/", "id": 2827, "method_signature": "List<Object> getStringCase(String)"}, "2769": {"callee_method_ids": [2709, 2716], "callee_method_names": ["String.trim", "String.length", "String.startsWith", "StringBuilder.length", "SequenceCreatorInterface<C>.getSequence", "StringBuilder.toString", "SequenceHeaderParserInterface<S, C>.parseHeader", "LinkedHashMap<String, S>.put", "S.getAccession", "Logger.warn", "Enumeration<JarEntry>.getMessage", "StringBuilder.setLength", "String.substring", "String.startsWith", "StringBuilder.length", "StringBuilder.append", "BufferedReaderBytesRead.getBytesRead", "BufferedReaderBytesRead.readLine", "StringBuilder.length", "String.length", "Logger.warn", "Logger.warn", "StringBuilder.length", "SequenceCreatorInterface<C>.getSequence", "StringBuilder.toString", "SequenceHeaderParserInterface<S, C>.parseHeader", "LinkedHashMap<String, S>.put", "S.getAccession", "Logger.warn", "Enumeration<JarEntry>.getMessage", "LinkedHashMap<String, S>.isEmpty"], "method_name": "FastaReader.process", "method_implementation": "{\n    String line = \"\";\n    if (this.line != null && this.line.length() > 0) {\n        line = this.line;\n    }\n    String header = \"\";\n    if (this.header != null && this.header.length() > 0) {\n        header = this.header;\n    }\n    StringBuilder sb = new StringBuilder();\n    int processedSequences = 0;\n    boolean keepGoing = true;\n    LinkedHashMap<String, S> sequences = new LinkedHashMap<String, S>();\n    do {\n        // nice to have but probably not needed\n        line = line.trim();\n        if (line.length() != 0) {\n            if (line.startsWith(\">\")) {\n                //start of new fasta record\n                if (sb.length() > 0) {\n                    //i.e. if there is already a sequence before\n                    //logger.info(\"Sequence index=\" + sequenceIndex);\n                    try {\n                        @SuppressWarnings(\"unchecked\")\n                        S sequence = (S) sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n                        headerParser.parseHeader(header, sequence);\n                        sequences.put(sequence.getAccession().getID(), sequence);\n                        processedSequences++;\n                    } catch (CompoundNotFoundException e) {\n                        logger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\", header, e.getMessage());\n                    }\n                    //this is faster than allocating new buffers, better memory utilization (same buffer)\n                    sb.setLength(0);\n                }\n                header = line.substring(1);\n            } else if (line.startsWith(\";\")) {\n            } else {\n                //mark the start of the sequence with the fileIndex before the line was read\n                if (sb.length() == 0) {\n                    sequenceIndex = fileIndex;\n                }\n                sb.append(line);\n            }\n        }\n        fileIndex = br.getBytesRead();\n        line = br.readLine();\n        if (line == null) {\n            //i.e. EOF\n            if (sb.length() == 0 && header.length() != 0) {\n                logger.warn(\"Can't parse sequence {}. Got sequence of length 0!\", sequenceIndex);\n                logger.warn(\"header: {}\", header);\n                header = null;\n            } else if (sb.length() > 0) {\n                //logger.info(\"Sequence index=\" + sequenceIndex + \" \" + fileIndex );\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    S sequence = (S) sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n                    headerParser.parseHeader(header, sequence);\n                    sequences.put(sequence.getAccession().getID(), sequence);\n                    processedSequences++;\n                    header = null;\n                } catch (CompoundNotFoundException e) {\n                    logger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\", header, e.getMessage());\n                }\n            }\n            keepGoing = false;\n        }\n        if (max > -1 && processedSequences >= max) {\n            keepGoing = false;\n        }\n    } while (keepGoing);\n    this.line = line;\n    this.header = header;\n    return max > -1 && sequences.isEmpty() ? null : sequences;\n}", "repo_id": "9", "comment": "/**\n * This method tries to parse maximum <code>max</code> records from\n * the open File or InputStream, and leaves the underlying resource open.<br>\n * Subsequent calls to the same method continue parsing the rest of the file.<br>\n * This is particularly useful when dealing with very big data files,\n * (e.g. NCBI nr database), which can't fit into memory and will take long\n * time before the first result is available.<br>\n * <b>N.B.</b>\n * <ul>\n * <li>This method can't be called after calling its NO-ARGUMENT twin.</li>\n * <li>remember to close the underlying resource when you are done.</li>\n * </ul>\n * @see #process()\n * @author Amr ALHOSSARY\n * @since 3.0.6\n * @param max maximum number of records to return, <code>-1</code> for infinity.\n * @return {@link HashMap} containing maximum <code>max</code> parsed fasta records\n * present, starting current fileIndex onwards.\n * @throws IOException if an error occurs reading the input file\n */\n", "repo_name": "biojava-master/", "id": 2769, "method_signature": "LinkedHashMap<String,S> process(int)"}, "486": {"callee_method_names": [], "method_name": "AFPChain.setChainRmsd", "method_implementation": "{\n    this.chainRmsd = chainRmsd;\n}", "repo_id": "9", "comment": "/**\n * The RMSD of the chain of AFPs. Set during AFPCHainer.traceBack();\n *\n * @param chainRmsd\n */\n", "repo_name": "biojava-master/", "id": 486, "method_signature": "void setChainRmsd(double)"}, "3506": {"callee_method_names": [], "method_name": "ChiSq.chiSq", "method_implementation": "{\n    double p = Math.exp(-0.5 * x);\n    if ((n % 2) == 1) {\n        p = p * Math.sqrt(2 * x / Math.PI);\n    }\n    double k = n;\n    while (k >= 2) {\n        p = p * x / k;\n        k = k - 2;\n    }\n    double t = p;\n    double a = n;\n    while (t > 0.000001 * p) {\n        a = a + 2;\n        t = t * x / a;\n        p = p + t;\n    }\n    return 1 - p;\n}", "repo_id": "9", "comment": "/**\n * @param x\n * @param n\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3506, "method_signature": "double chiSq(double, int)"}, "38": {"callee_method_names": [], "method_name": "Alignments.getPairwiseAlignment", "method_implementation": "{\n    return getPairwiseAligner(query, target, type, gapPenalty, subMatrix).getPair();\n}", "repo_id": "9", "comment": "/**\n * Factory method which computes a sequence alignment for the given {@link Sequence} pair.\n *\n * @param <S> each {@link Sequence} of the pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param query the first {@link Sequence}s to align\n * @param target the second {@link Sequence}s to align\n * @param type chosen type from list of pairwise sequence alignment routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return sequence alignment pair\n */\n", "repo_name": "biojava-master/", "id": 38, "method_signature": "SequencePair<S,C> getPairwiseAlignment(S, S, PairwiseSequenceAlignerType, GapPenalty, SubstitutionMatrix)"}, "58": {"callee_method_names": [], "method_name": "AbstractProfileProfileAligner.setTarget", "method_implementation": "{\n    this.target = target;\n    targetFuture = null;\n    reset();\n}", "repo_id": "9", "comment": "/**\n * Sets the target {@link Profile}.\n *\n * @param target the second {@link Profile} of the pair to align\n */\n", "repo_name": "biojava-master/", "id": 58, "method_signature": "void setTarget(Profile)"}, "2093": {"callee_method_names": ["List<Axis>.get"], "method_name": "SymmetryAxes.getAxisCounts", "method_implementation": "{\n    int[] counts = new int[getNumLevels()];\n    for (int i = counts.length - 1; i >= 0; i--) {\n        int d = axes.get(i).getOrder();\n        counts[i] = repeat % d;\n        repeat /= d;\n    }\n    assert repeat == 0 : \"Invalid repeat index\";\n    return counts;\n}", "repo_id": "9", "comment": "/**\n * Return a list giving the number of times each axis must be applied\n * to generate the given repeat.\n * <P>\n * For instance, for a D3 case <tt>getAxisCounts(4)</tt> would return [2,0],\n * indicating that repeat 4 is generated by two applications of the 3-fold\n * axis followed by 0 applications of the two-fold axis.\n *\n * @param repeat Index of the desired repeat\n * @return array of the same length as axes giving the number of times\n *  to apply each axis.\n */\n", "repo_name": "biojava-master/", "id": 2093, "method_signature": "int[] getAxisCounts(int)"}, "2023": {"callee_method_names": ["Matrix3d.rotZ", "Matrix3d.transform", "Point3d[].add"], "method_name": "Prism.getPolygonVertices", "method_implementation": "{\n    Point3d[] polygon = new Point3d[n];\n    Matrix3d m = new Matrix3d();\n    for (int i = 0; i < n; i++) {\n        polygon[i] = new Point3d(0, radius, 0);\n        m.rotZ(i * 2 * Math.PI / n);\n        m.transform(polygon[i]);\n        polygon[i].add(center);\n    }\n    return polygon;\n}", "repo_id": "9", "comment": "/**\n * Returns the vertices of an n-fold polygon of given radius and center\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2023, "method_signature": "Point3d[] getPolygonVertices(int, double, Point3d)"}, "3087": {"callee_method_names": [], "method_name": "AbstractFeature.setChildrenFeatures", "method_implementation": "{\n    childrenFeatures = features;\n}", "repo_id": "9", "comment": "/**\n * Set the children features\n * @param features\n */\n", "repo_name": "biojava-master/", "id": 3087, "method_signature": "void setChildrenFeatures(List)"}, "3816": {"callee_method_names": [], "method_name": "CensorStatus.setPercentage", "method_implementation": "{\n    this.percentage = percentage;\n}", "repo_id": "9", "comment": "/**\n * @param percentage the percentage to set\n */\n", "repo_name": "biojava-master/", "id": 3816, "method_signature": "void setPercentage(Double)"}, "2018": {"callee_method_names": [], "method_name": "Prism.getCirumscribedRadius", "method_implementation": "{\n    return circumscribedRadius;\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a circumscribed sphere, that goes\n * through all vertices\n * @return the cirumscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2018, "method_signature": "double getCirumscribedRadius()"}, "1271": {"callee_method_names": [], "method_name": "MmtfStructureReader.getGroupTypIndicator", "method_implementation": "{\n    if (PolymerType.PROTEIN_ONLY.contains(polymerType)) {\n        return 1;\n    }\n    if (PolymerType.POLYNUCLEOTIDE_ONLY.contains(polymerType)) {\n        return 2;\n    }\n    return 0;\n}", "repo_id": "9", "comment": "/**\n * Get the type of group (0,1 or 2) depending on whether it is an amino aicd (1), nucleic acid (2) or ligand (0)\n * @param polymerType\n * @return The type of group. (0,1 or 2) depending on whether it is an amino aicd (1), nucleic acid (2) or ligand (0)\n */\n", "repo_name": "biojava-master/", "id": 1271, "method_signature": "int getGroupTypIndicator(PolymerType)"}, "504": {"callee_method_names": [], "method_name": "AFPChain.setSequentialAlignment", "method_implementation": "{\n    this.sequentialAlignment = sequentialAlignment;\n}", "repo_id": "9", "comment": "/**\n * Set whether this alignment has the normal topology, ie the residues\n * aligned in each block increase sequentially over the original protein.\n *\n * This will be false if a circular permutation was detected.\n */\n", "repo_name": "biojava-master/", "id": 504, "method_signature": "void setSequentialAlignment(boolean)"}, "3517": {"callee_method_names": [], "method_name": "StrataInfo.getStderr", "method_implementation": "{\n    return stderr;\n}", "repo_id": "9", "comment": "/**\n * @return the stderr\n */\n", "repo_name": "biojava-master/", "id": 3517, "method_signature": "ArrayList<Double> getStderr()"}, "2495": {"callee_method_names": ["File.getName", "FileWriter.write", "LinkedHashMap<String, DNASequence>.values", "DNASequence.getAccession", "DNASequence.getBioEnd", "DNASequence.getAccession", "FileWriter.write", "FileWriter.close"], "method_name": "GeneFeatureHelper.outputFastaSequenceLengthGFF3", "method_implementation": "{\n    LinkedHashMap<String, DNASequence> dnaSequenceList = FastaReaderHelper.readFastaDNASequence(fastaSequenceFile);\n    String fileName = fastaSequenceFile.getName();\n    FileWriter fw = new FileWriter(gffFile);\n    String newLine = System.getProperty(\"line.separator\");\n    fw.write(\"##gff-version 3\" + newLine);\n    for (DNASequence dnaSequence : dnaSequenceList.values()) {\n        String gff3line = dnaSequence.getAccession().getID() + \"\\t\" + fileName + \"\\t\" + \"contig\" + \"\\t\" + \"1\" + \"\\t\" + dnaSequence.getBioEnd() + \"\\t.\\t.\\t.\\tName=\" + dnaSequence.getAccession().getID() + newLine;\n        fw.write(gff3line);\n    }\n    fw.close();\n}", "repo_id": "9", "comment": "/**\n * Output a gff3 feature file that will give the length of each scaffold/chromosome in the fasta file.\n * Used for gbrowse so it knows length.\n * @param fastaSequenceFile\n * @param gffFile\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2495, "method_signature": "void outputFastaSequenceLengthGFF3(File, File)"}, "772": {"callee_method_names": [], "method_name": "StartupParameters.setOutputPDB", "method_implementation": "{\n    this.printPDB = printPDB;\n}", "repo_id": "9", "comment": "/**\n * When writing the results to a file, don;t write as XML but write aligned PDB file\n *\n * @param printPDB flag to print aligned PDB\n */\n", "repo_name": "biojava-master/", "id": 772, "method_signature": "void setOutputPDB(boolean)"}, "3175": {"callee_method_names": ["StartCodonSequence.setAccession"], "method_name": "TranscriptSequence.addStartCodonSequence", "method_implementation": "{\n    this.startCodonSequence = new StartCodonSequence(this, begin, end);\n    startCodonSequence.setAccession(accession);\n}", "repo_id": "9", "comment": "/**\n * Sets the start codon sequence at given begin /  end location. Note that calling this method multiple times\n * will replace any existing value.\n * @param accession\n * @param begin\n * @param end\n */\n", "repo_name": "biojava-master/", "id": 3175, "method_signature": "void addStartCodonSequence(AccessionID, int, int)"}, "3124": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getSubSequence", "method_implementation": "{\n    return new SequenceProxyView<C>(UniprotProxySequenceReader.this, bioBegin, bioEnd);\n}", "repo_id": "9", "comment": "/**\n * @param bioBegin\n * @param bioEnd\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3124, "method_signature": "SequenceView<C> getSubSequence(Integer, Integer)"}, "1121": {"callee_method_ids": [625, 2626], "callee_method_names": ["AtomCache.getCachePath", "String.toLowerCase", "String.substring", "File.exists", "Logger.info", "File.toString", "File.mkdir", "File.exists", "Logger.info", "File.toString", "File.mkdir", "Logger.debug", "File.getAbsolutePath", "File.exists", "Logger.debug", "Logger.debug", "InputStreamProvider.getInputStream", "SiftsXMLParser.parseXmlFile", "SiftsXMLParser.getEntities"], "method_name": "SiftsMappingProvider.getSiftsMapping", "method_implementation": "{\n    // grab files from here:\n    AtomCache cache = new AtomCache();\n    String path = cache.getCachePath();\n    pdbId = pdbId.toLowerCase();\n    String dirHash = pdbId.substring(1, 3);\n    File siftsDir = new File(path, \"SIFTS\");\n    if (!siftsDir.exists()) {\n        logger.info(\"Creating directory {}\", siftsDir.toString());\n        siftsDir.mkdir();\n    }\n    File hashDir = new File(siftsDir, dirHash);\n    if (!hashDir.exists()) {\n        logger.info(\"Creating directory {}\", hashDir.toString());\n        hashDir.mkdir();\n    }\n    File dest = new File(hashDir, pdbId + \".sifts.xml.gz\");\n    logger.debug(\"testing SIFTS file {}\", dest.getAbsolutePath());\n    if (!dest.exists()) {\n        String u = String.format(fileLoc, pdbId);\n        URL url = new URL(u);\n        logger.debug(\"Downloading SIFTS file {} validation metadata.\", url);\n        FileDownloadUtils.createValidationFiles(url, dest, null, FileDownloadUtils.Hash.UNKNOWN);\n        logger.debug(\"Downloading SIFTS file {} to {}\", url, dest);\n        FileDownloadUtils.downloadFile(url, dest);\n    }\n    if (!FileDownloadUtils.validateFile(dest))\n        throw new IOException(\"Downloaded file invalid: \" + dest);\n    InputStreamProvider prov = new InputStreamProvider();\n    InputStream is = prov.getInputStream(dest);\n    SiftsXMLParser parser = new SiftsXMLParser();\n    parser.parseXmlFile(is);\n    //System.out.println(parser.getEntities());\n    return parser.getEntities();\n}", "repo_id": "9", "comment": "/**\n * Return the SIFTS mappings by getting the info from individual SIFTS xml files at URL {@value EBI_SIFTS_FILE_LOCATION}\n * @param pdbId the pdb identifier\n * @return\n * @throws IOException if problems downloading or parsing the file\n */\n", "repo_name": "biojava-master/", "id": 1121, "method_signature": "List<SiftsEntity> getSiftsMapping(String)"}, "2568": {"callee_method_names": ["File.getName", "String.indexOf", "String.substring"], "method_name": "FileDownloadUtils.getFilePrefix", "method_implementation": "{\n    String fileName = f.getName();\n    int mid = fileName.indexOf(\".\");\n    if (mid < 0) {\n        return fileName;\n    }\n    return fileName.substring(0, mid);\n}", "repo_id": "9", "comment": "/**\n * Gets the file name up to and excluding the first\n * '.' character. If there is no extension, the full filename\n * is returned.\n * @param f A file\n * @return A possibly empty but non-null String.\n */\n", "repo_name": "biojava-master/", "id": 2568, "method_signature": "String getFilePrefix(File)"}, "950": {"callee_method_names": [], "method_name": "OrderedPair.setElement2", "method_implementation": "{\n    this.element2 = element2;\n}", "repo_id": "9", "comment": "/**\n * Sets the second element of an ordered pair.\n *\n * @param element2 the second element of an ordered pair\n */\n", "repo_name": "biojava-master/", "id": 950, "method_signature": "void setElement2(T)"}, "518": {"callee_method_names": ["ArrayList.listIterator", "ListIterator<StructureAlignment>.hasNext", "ListIterator<StructureAlignment>.next", "StructureAlignment.getAlgorithmName", "ListIterator<StructureAlignment>.remove"], "method_name": "StructureAlignmentFactory.removeAlgorithm", "method_implementation": "{\n    ListIterator<StructureAlignment> algIt = algorithms.listIterator();\n    while (algIt.hasNext()) {\n        StructureAlignment alg = algIt.next();\n        if (alg.getAlgorithmName().equalsIgnoreCase(name)) {\n            algIt.remove();\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Removes the specified algorithm from the list of options\n * @param name the name of the algorithm to remove\n * @return true if the specified algorithm was found and removed\n */\n", "repo_name": "biojava-master/", "id": 518, "method_signature": "boolean removeAlgorithm(String)"}, "2919": {"callee_method_names": [], "method_name": "AbstractSequence.getSequenceScore", "method_implementation": "{\n    return sequenceScore;\n}", "repo_id": "9", "comment": "/**\n * Provide place holder for a metric that indicate a score associated with the sequence\n * @return the sequenceScore\n */\n", "repo_name": "biojava-master/", "id": 2919, "method_signature": "Double getSequenceScore()"}, "3858": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getMolecularWeight"], "method_name": "PeptideProperties.getMolecularWeight", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getMolecularWeight(pSequence, aminoAcidCompositionFile);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the molecular weight of sequence. The sequence argument must be a protein sequence consisting of only non-ambiguous characters.\n * This method will sum the molecular weight of each amino acid in the\n * sequence. Molecular weights are based on the input files. These input files must be XML using the defined schema.\n * Note that it assumes that ElementMass.xml file can be found in default location.\n *\n * @param sequence\n * \ta protein sequence consisting of non-ambiguous characters only\n * \txml file that details the mass of each elements and isotopes\n * @param aminoAcidCompositionFile\n * \txml file that details the composition of amino acids\n * @return the total molecular weight of sequence + weight of water molecule\n * @throws JAXBException\n * \tthrown if unable to properly parse either elementMassFile or aminoAcidCompositionFile\n * @throws FileNotFoundException\n * \tthrown if either elementMassFile or aminoAcidCompositionFile are not found\n */\n", "repo_name": "biojava-master/", "id": 3858, "method_signature": "double getMolecularWeight(String, File)"}, "635": {"callee_method_names": [], "method_name": "AtomCache.setObsoleteBehavior", "method_implementation": "{\n    obsoleteBehavior = behavior;\n}", "repo_id": "9", "comment": "/**\n * <b>[Optional]</b> This method changes the behavior when obsolete entries\n * are requested. Current behaviors are:\n * <ul>\n * <li>{@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}\n *   Throw a {@link StructureException} (the default)\n * <li>{@link ObsoleteBehavior#FETCH_OBSOLETE FETCH_OBSOLETE}\n *   Load the requested ID from the PDB's obsolete repository\n * <li>{@link ObsoleteBehavior#FETCH_CURRENT FETCH_CURRENT}\n *   Load the most recent version of the requested structure\n *\n * <p>This setting may be silently ignored by implementations which do not have\n * access to the server to determine whether an entry is obsolete, such as\n * if {@link #isAutoFetch()} is false. Note that an obsolete entry may still be\n * returned even this is FETCH_CURRENT if the entry is found locally.\n *\n * @param fetchFileEvenIfObsolete Whether to fetch obsolete records\n * @see #setFetchCurrent(boolean)\n * @since 4.0.0\n */\n", "repo_name": "biojava-master/", "id": 635, "method_signature": "void setObsoleteBehavior(ObsoleteBehavior)"}, "638": {"callee_method_names": [], "method_name": "AtomCache.setFetchBehavior", "method_implementation": "{\n    this.fetchBehavior = fetchBehavior;\n}", "repo_id": "9", "comment": "/**\n * Set the behavior for fetching files from the server\n * @param fetchBehavior\n */\n", "repo_name": "biojava-master/", "id": 638, "method_signature": "void setFetchBehavior(FetchBehavior)"}, "3862": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getAbsorbance"], "method_name": "PeptideProperties.getAbsorbance", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getAbsorbance(pSequence, assumeCysReduced);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to returns the absorbance (optical density) of sequence. The sequence argument\n * must be a protein sequence consisting of only non-ambiguous characters.\n * The computation of absorbance (optical density) follows the\n * documentation in <a href=\"http://web.expasy.org/protparam/protparam-doc.html\">here</a>.\n *\n * @param sequence\n * \ta protein sequence consisting of non-ambiguous characters only\n * @param assumeCysReduced\n * \ttrue if Cys are assumed to be reduced and false if Cys are assumed to form cystines\n * @return the absorbance (optical density) of sequence\n */\n", "repo_name": "biojava-master/", "id": 3862, "method_signature": "double getAbsorbance(String, boolean)"}, "2585": {"callee_method_names": ["DocumentBuilderFactory.newDocumentBuilder", "DocumentBuilder.newDocument"], "method_name": "XMLHelper.getNewDocument", "method_implementation": "{\n    //Create instance of DocumentBuilderFactory\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    //Get the DocumentBuilder\n    DocumentBuilder docBuilder = factory.newDocumentBuilder();\n    //Create blank DOM Document\n    Document doc = docBuilder.newDocument();\n    return doc;\n}", "repo_id": "9", "comment": "/**\n * Create a new, empty {@code}org.w3c.dom.Document{@code}\n * @return a new {@code}org.w3c.dom.Document{@code}\n * @throws ParserConfigurationException\n */\n", "repo_name": "biojava-master/", "id": 2585, "method_signature": "Document getNewDocument()"}, "3217": {"callee_method_names": ["TranscriptSequence.equals"], "method_name": "AfterValidConstruction.equalsDoesntDependOnStrand", "method_implementation": "{\n    assertTrue(transcriptSeq.equals(transcriptNegativeSeq));\n}", "repo_id": "9", "comment": "// whether it's -ve or +ve doesn't affect equals?\n", "repo_name": "biojava-master/", "id": 3217, "method_signature": "void equalsDoesntDependOnStrand()"}, "2228": {"callee_method_ids": [1322, 1190], "callee_method_names": ["FileParsingParameters.setAlignSeqRes", "PDBFileParser.setFileParsingParameters", "PDBFileParser.parsePDBFile", "Structure.getEntityInfos", "Structure.getEntityById", "Structure.getEntityById", "Structure.getEntityById", "Structure.getPolyChains", "Structure.getEntityById", "Structure.getPolyChains", "Structure.getEntityById", "Structure.getPolyChains", "Structure.getEntityById", "Structure.getPolyChains", "Structure.getEntityById", "Structure.getPolyChains", "Structure.getEntityById", "Structure.getPolyChains", "Structure.getEntityById", "Structure.getPolyChains", "Structure.getPolyChains"], "method_name": "TestNonDepositedFiles.testIssue931", "method_implementation": "{\n    InputStream inStream = new GZIPInputStream(this.getClass().getResourceAsStream(\"/org/biojava/nbio/structure/io/3zyb_truncated.pdb.gz\"));\n    PDBFileParser pdbpars = new PDBFileParser();\n    FileParsingParameters params = new FileParsingParameters();\n    params.setAlignSeqRes(true);\n    pdbpars.setFileParsingParameters(params);\n    Structure s = pdbpars.parsePDBFile(inStream);\n    assertEquals(2, s.getEntityInfos().size());\n    assertEquals(4, s.getEntityById(1).getChains().size());\n    assertEquals(3, s.getEntityById(2).getChains().size());\n    assertSame(s.getEntityById(1), s.getPolyChains().get(0).getEntityInfo());\n    assertSame(s.getEntityById(1), s.getPolyChains().get(1).getEntityInfo());\n    assertSame(s.getEntityById(1), s.getPolyChains().get(2).getEntityInfo());\n    assertSame(s.getEntityById(1), s.getPolyChains().get(3).getEntityInfo());\n    assertSame(s.getEntityById(2), s.getPolyChains().get(4).getEntityInfo());\n    assertSame(s.getEntityById(2), s.getPolyChains().get(5).getEntityInfo());\n    assertSame(s.getEntityById(2), s.getPolyChains().get(6).getEntityInfo());\n    // we should have seqres groups (testing getSeqResSequence() is equivalent)\n    assertFalse(s.getPolyChains().get(0).getSeqResSequence().isEmpty());\n}", "repo_id": "9", "comment": "/**\n * Making sure we find the right number of entities and that chains are assigned to entities correctly.\n * See https://github.com/biojava/biojava/issues/931\n */\n", "repo_name": "biojava-master/", "id": 2228, "method_signature": "void testIssue931()"}, "1461": {"callee_method_names": ["Matrix3d.determinant"], "method_name": "SpaceGroup.getRotAxisType", "method_implementation": "{\n    int axisType = 0;\n    Matrix3d rot = new Matrix3d(m.m00, m.m01, m.m02, m.m10, m.m11, m.m12, m.m20, m.m21, m.m22);\n    double determinant = rot.determinant();\n    if (!deltaComp(determinant, 1.0, DELTA) && !deltaComp(determinant, -1.0, DELTA)) {\n        throw new IllegalArgumentException(\"Given matrix does not seem to be a rotation matrix.\");\n    }\n    int trace = (int) (rot.m00 + rot.m11 + rot.m22);\n    if (determinant > 0) {\n        switch(trace) {\n            case 3:\n                axisType = 1;\n                break;\n            case -1:\n                axisType = 2;\n                break;\n            case 0:\n                axisType = 3;\n                break;\n            case 1:\n                axisType = 4;\n                break;\n            case 2:\n                axisType = 6;\n                break;\n            default:\n                throw new RuntimeException(\"Trace of transform does not correspond to one of the expected types. This is most likely a bug\");\n        }\n    } else {\n        switch(trace) {\n            case -3:\n                axisType = -1;\n                break;\n            case 1:\n                axisType = -2;\n                break;\n            case 0:\n                axisType = -3;\n                break;\n            case -1:\n                axisType = -4;\n                break;\n            case -2:\n                axisType = -6;\n                break;\n            default:\n                throw new RuntimeException(\"Trace of transform does not correspond to one of the expected types. This is most likely a bug\");\n        }\n    }\n    return axisType;\n}", "repo_id": "9", "comment": "/**\n * Given a transformation matrix containing a rotation returns the type of rotation:\n * 1 for identity, 2 for 2-fold rotation, 3 for 3-fold rotation, 4 for 4-fold rotation,\n * 6 for 6-fold rotation,\n * -1 for inversions, -2 for mirror planes, -3 for 3-fold improper rotation,\n * -4 for 4-fold improper rotation and -6 for 6-fold improper rotation\n * @param m\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1461, "method_signature": "int getRotAxisType(Matrix4d)"}, "279": {"callee_method_names": [], "method_name": "StructureUtil.findNearestAtomLinkage", "method_implementation": "{\n    List<Atom[]> linkages = findAtomLinkages(group1, group2, potentialNamesOfAtomOnGroup1, potentialNamesOfAtomOnGroup2, ignoreNCLinkage, bondLengthTolerance);\n    Atom[] ret = null;\n    double minDistance = Double.POSITIVE_INFINITY;\n    for (Atom[] linkage : linkages) {\n        double distance;\n        distance = Calc.getDistance(linkage[0], linkage[1]);\n        if (distance < minDistance) {\n            minDistance = distance;\n            ret = linkage;\n        }\n    }\n    return ret;\n}", "repo_id": "9", "comment": "/**\n * Find a linkage between two groups within tolerance of bond length,\n * from potential atoms.\n * @param group1 the first {@link Group}.\n * @param group2 the second {@link Group}.\n * @param potentialNamesOfAtomOnGroup1 potential names of the atom on the first group.\n * \t\t  If null, search all atoms on the first group.\n * @param potentialNamesOfAtomOnGroup2 potential names of the atom on the second group.\n * \t\t  If null, search all atoms on the second group.\n * @param ignoreNCLinkage true to ignore all N-C linkages\n * @param bondLengthTolerance bond length error tolerance.\n * @return an array of two Atoms that form bond between each other\n *  if found; null, otherwise.\n */\n", "repo_name": "biojava-master/", "id": 279, "method_signature": "Atom[] findNearestAtomLinkage(Group, Group, List, List, boolean, double)"}, "1451": {"callee_method_names": [], "method_name": "SpaceGroup.getShortSymbol", "method_implementation": "{\n    return shortSymbol;\n}", "repo_id": "9", "comment": "/**\n * Gets the international short name (as used in PDB),\n * e.g. \"P 21 21 21\" or \"C 1 c 1\"\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1451, "method_signature": "String getShortSymbol()"}, "2472": {"callee_method_ids": [2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2422, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2402, 2424, 2404, 2466, 2469, 2424], "callee_method_names": ["Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Location.opposite", "Logger.info", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.window", "Logger.info", "Location.toString", "Logger.info", "Location.iterator", "LocIterator.hasNext", "LocIterator.next", "Logger.info", "Location.toString", "Logger.info"], "method_name": "LocIterator.main", "method_implementation": "{\n    Location r = new Location(10, 21);\n    logger.info(\"10 to 21, 1 by 1\");\n    for (Location t : r.window(1, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by 3\");\n    for (Location t : r.window(3, 3)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by 1\");\n    for (Location t : r.window(3, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 11 by 1\");\n    for (Location t : r.window(11, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 12 by 1\");\n    for (Location t : r.window(12, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 1 by -1\");\n    for (Location t : r.window(1, -1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by -3\");\n    for (Location t : r.window(3, -3)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by -1\");\n    for (Location t : r.window(3, -1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 1 by 1\");\n    for (Location t : r.window(1, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by 3\");\n    for (Location t : r.window(3, 3)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by 1\");\n    for (Location t : r.window(3, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 11 by 1\");\n    for (Location t : r.window(11, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 12 by 1\");\n    for (Location t : r.window(12, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 1 by -1\");\n    for (Location t : r.window(1, -1)) {\n        logger.info(t.toString());\n    }\n    //reverse strand\n    r = r.opposite();\n    logger.info(\"reverse strand\");\n    logger.info(\"10 to 21, 1 by 1\");\n    for (Location t : r.window(1, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by 3\");\n    for (Location t : r.window(3, 3)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by 1\");\n    for (Location t : r.window(3, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 11 by 1\");\n    for (Location t : r.window(11, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 12 by 1\");\n    for (Location t : r.window(12, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 1 by -1\");\n    for (Location t : r.window(1, -1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by -3\");\n    for (Location t : r.window(3, -3)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by -1\");\n    for (Location t : r.window(3, -1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 1 by 1\");\n    for (Location t : r.window(1, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by 3\");\n    for (Location t : r.window(3, 3)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 3 by 1\");\n    for (Location t : r.window(3, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 11 by 1\");\n    for (Location t : r.window(11, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 12 by 1\");\n    for (Location t : r.window(12, 1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 1 by -1\");\n    for (Location t : r.window(1, -1)) {\n        logger.info(t.toString());\n    }\n    logger.info(\"10 to 21, 1 by 1 (+2)\");\n    LocIterator i = r.iterator();\n    int chunk = 1;\n    while (i.hasNext(1, chunk)) {\n        Location t = i.next(1, chunk);\n        logger.info(t.toString());\n        chunk += 2;\n    }\n    //FIXME test remainder()\n    logger.info(\"JavaGene.LocIterator Passed.\");\n}", "repo_id": "9", "comment": "/**\n * @deprecated\n */\n", "repo_name": "biojava-master/", "id": 2472, "method_signature": "void main(String[])"}, "1764": {"callee_method_names": ["Class<?>.getMethods", "int.getName", "String.substring", "int.invoke", "int.invoke", "Logger.warn", "Logger.warn", "Object.equals", "Logger.warn", "Logger.error", "Logger.error", "Logger.error"], "method_name": "PDBHeader.equals", "method_implementation": "{\n    try {\n        Class<?> c = Class.forName(PDBHeader.class.getName());\n        Method[] methods = c.getMethods();\n        for (Method m : methods) {\n            String name = m.getName();\n            if (\"get\".equals(name.substring(0, 3))) {\n                if (\"getClass\".equals(name)) {\n                    continue;\n                }\n                Object a = m.invoke(this);\n                Object b = m.invoke(other);\n                if (a == null) {\n                    if (b == null) {\n                        continue;\n                    } else {\n                        logger.warn(name + \" a is null, where other is \" + b);\n                        return false;\n                    }\n                }\n                if (b == null) {\n                    logger.warn(name + \" other is null, where a is \" + a);\n                    return false;\n                }\n                if (!(a.equals(b))) {\n                    logger.warn(\"mismatch with \" + name + \" >\" + a + \"< >\" + b + \"<\");\n                    return false;\n                }\n            }\n        }\n    } catch (ClassNotFoundException e) {\n        logger.error(\"Exception caught while comparing PDBHeader objects \", e);\n        return false;\n    } catch (InvocationTargetException e) {\n        logger.error(\"Exception caught while comparing PDBHeader objects \", e);\n        return false;\n    } catch (IllegalAccessException e) {\n        logger.error(\"Exception caught while comparing PDBHeader objects \", e);\n        return false;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Compare two PDBHeader objects\n *\n * @param other a PDBHeader object to compare this one to.\n * @return true if they are equal or false if they are not.\n */\n", "repo_name": "biojava-master/", "id": 1764, "method_signature": "boolean equals(PDBHeader)"}, "947": {"callee_method_names": [], "method_name": "OrderedPair.getElement1", "method_implementation": "{\n    return element1;\n}", "repo_id": "9", "comment": "/**\n * @return element1 the first element of an ordered pair\n */\n", "repo_name": "biojava-master/", "id": 947, "method_signature": "T getElement1()"}, "2234": {"callee_method_names": ["SimpleDateFormat.parse", "Structure.getPDBHeader", "SimpleDateFormat.parse", "Structure.getPDBHeader", "SimpleDateFormat.parse", "Structure.getPDBHeader"], "method_name": "CifFileConsumerImplTest.testDatesV5", "method_implementation": "{\n    InputStream inputStream = getClass().getResourceAsStream(\"/org/biojava/nbio/structure/io/mmcif/1stp_v5.cif\");\n    Objects.requireNonNull(inputStream, \"could not acquire test resource /org/biojava/nbio/structure/io/mmcif/1stp_v5.cif\");\n    Structure s = new CifFileReader().getStructure(inputStream);\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.US);\n    Date modDate = dateFormat.parse(\"2011-07-13\");\n    assertEquals(modDate, s.getPDBHeader().getModDate());\n    Date releaseDate = dateFormat.parse(\"1992-10-15\");\n    assertEquals(releaseDate, s.getPDBHeader().getRelDate());\n    Date depositionDate = dateFormat.parse(\"1992-03-12\");\n    assertEquals(depositionDate, s.getPDBHeader().getDepDate());\n}", "repo_id": "9", "comment": "/**\n * Test parsing dates from MMCIF file version 5.\n */\n", "repo_name": "biojava-master/", "id": 2234, "method_signature": "void testDatesV5()"}, "1468": {"callee_method_names": ["Matrix4d.transform", "Matrix4d.set", "Matrix4d.mul", "Matrix4d.transform"], "method_name": "CrystalCell.transfToOriginCellCrystal", "method_implementation": "{\n    Matrix4d[] transformed = new Matrix4d[ops.length];\n    for (int j = 0; j < ops.length; j++) {\n        Matrix4d op = ops[j];\n        // transform the reference point\n        Point3d xXtal = new Point3d(reference);\n        op.transform(xXtal);\n        // Calculate unit cell of transformed reference\n        int x = (int) Math.floor(xXtal.x);\n        int y = (int) Math.floor(xXtal.y);\n        int z = (int) Math.floor(xXtal.z);\n        Matrix4d translation = new Matrix4d();\n        translation.set(new Vector3d(-x, -y, -z));\n        // Compose op with an additional translation operator\n        translation.mul(op);\n        Point3d ref2 = new Point3d(reference);\n        translation.transform(ref2);\n        transformed[j] = translation;\n    }\n    return transformed;\n}", "repo_id": "9", "comment": "/**\n * @param ops Set of operations in crystal coordinates\n * @param reference Reference point, which should be in the unit cell after\n *  each operation (also in crystal coordinates)\n * @return A set of crystal operators with equivalent rotation to the\n *  inputs, but with translation such that the reference point would fall\n *  within the unit cell\n */\n", "repo_name": "biojava-master/", "id": 1468, "method_signature": "Matrix4d[] transfToOriginCellCrystal(Matrix4d[], Tuple3d)"}, "286": {"callee_method_names": [], "method_name": "ProteinModificationIdentifier.setRecordUnidentifiableCompounds", "method_implementation": "{\n    this.recordUnidentifiableModifiedCompounds = recordUnidentifiableModifiedCompounds;\n}", "repo_id": "9", "comment": "/**\n * @param recordUnidentifiableModifiedCompounds true if choosing to record unidentifiable\n *  atoms; false, otherwise.\n * @see #getRecordUnidentifiableCompounds\n * @see #getUnidentifiableModifiedResidues\n * @see #getUnidentifiableAtomLinkages\n */\n", "repo_name": "biojava-master/", "id": 286, "method_signature": "void setRecordUnidentifiableCompounds(boolean)"}, "184": {"callee_method_ids": [1633, 1929], "callee_method_names": ["SubunitClustererParameters.setClustererMethod", "QuatSymmetryResults.getSymmetry", "QuatSymmetryResults.getStoichiometry", "QuatSymmetryResults.isPseudoStoichiometric"], "method_name": "TestQuatSymmetryDetectorExamples.testDihedral", "method_implementation": "{\n    Structure pdb = StructureIO.getStructure(\"BIO:2vml:1\");\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n    clusterParams.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n    QuatSymmetryParameters symmParams = new QuatSymmetryParameters();\n    QuatSymmetryResults symmetry = QuatSymmetryDetector.calcGlobalSymmetry(pdb, symmParams, clusterParams);\n    // D3 symmetry non pseudosymmetric\n    assertEquals(\"D3\", symmetry.getSymmetry());\n    assertEquals(\"A6B6\", symmetry.getStoichiometry().toString());\n    assertFalse(symmetry.isPseudoStoichiometric());\n}", "repo_id": "9", "comment": "/**\n * Test a dihedral symmetry: 2VML\n */\n", "repo_name": "biojava-master/", "id": 184, "method_signature": "void testDihedral()"}, "2112": {"callee_method_names": [], "method_name": "Axis.getFirstRepeat", "method_implementation": "{\n    return firstRepeat;\n}", "repo_id": "9", "comment": "/**\n * Get the index of the first repeat used by this axis\n * @return the firstRepeat\n */\n", "repo_name": "biojava-master/", "id": 2112, "method_signature": "int getFirstRepeat()"}, "444": {"callee_method_names": ["Pair<Atom[]>.getFirst", "Pair<Atom[]>.getSecond"], "method_name": "QsAlign.getTransformForClusterSubunitMap", "method_implementation": "{\n    Pair<Atom[]> pair = getAlignedAtomsForClusterSubunitMap(clusters, clusterSubunitMap);\n    return SuperPositions.superpose(Calc.atomsToPoints(pair.getFirst()), Calc.atomsToPoints(pair.getSecond()));\n}", "repo_id": "9", "comment": "/**\n * Returns the transformation matrix corresponding to the alignment of\n * subunit matchings.\n * <p>\n * Utility method to cumulative calculate the alignment transformation.\n *\n * @param clusters\n *            List of SubunitClusters\n * @param clusterSubunitMap\n *            map from cluster id to subunit matching\n * @return transformation matrix\n */\n", "repo_name": "biojava-master/", "id": 444, "method_signature": "Matrix4d getTransformForClusterSubunitMap(List, Map)"}, "3158": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.getSubSequence", "method_implementation": "{\n    return new SequenceProxyView<C>(SequenceFileProxyLoader.this, bioBegin, bioEnd);\n}", "repo_id": "9", "comment": "/**\n * @param bioBegin\n * @param bioEnd\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3158, "method_signature": "SequenceView<C> getSubSequence(Integer, Integer)"}, "3025": {"callee_method_names": ["Sequence<C>.getCompoundSet", "CompoundSet<C>.getAllCompounds", "Compound.getClass"], "method_name": "AbstractLocation.canComplement", "method_implementation": "{\n    CompoundSet<C> compoundSet = sequence.getCompoundSet();\n    Compound c = compoundSet.getAllCompounds().iterator().next();\n    return ComplementCompound.class.isAssignableFrom(c.getClass());\n}", "repo_id": "9", "comment": "/**\n * Uses the Sequence's CompoundSet to decide if a compound can\n * be assgined to ComplementCompound meaning it can complement\n */\n", "repo_name": "biojava-master/", "id": 3025, "method_signature": "boolean canComplement(Sequence)"}, "2079": {"callee_method_names": ["Random.nextInt", "Random.nextInt", "Random.nextInt", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.contains", "List<List<Integer>>.get", "List<Integer>.remove", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.contains", "List<List<Integer>>.get", "List<Integer>.remove", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "Random.nextInt", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.contains", "List<List<Integer>>.get", "List<Integer>.remove", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.add", "List<Integer>.contains", "List<List<Integer>>.get", "List<Integer>.remove", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.contains", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.remove", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.add"], "method_name": "SymmOptimizer.shiftRow", "method_implementation": "{\n    // Select the repeat\n    int su = rnd.nextInt(order);\n    // Select between moving right (0) or left (1)\n    int rl = rnd.nextInt(2);\n    // Residue as a pivot\n    int res = rnd.nextInt(length);\n    // When the pivot residue is null try to add a residue from the freePool\n    if (block.get(su).get(res) == null) {\n        int right = res;\n        int left = res;\n        // Find the boundary to the right abd left\n        while (block.get(su).get(right) == null && right < length - 1) {\n            right++;\n        }\n        while (block.get(su).get(left) == null && left > 0) {\n            left--;\n        }\n        // If they both are null the whole block is null\n        if (block.get(su).get(left) == null && block.get(su).get(right) == null) {\n            return false;\n        } else if (block.get(su).get(left) == null) {\n            // Choose the sequentially previous residue of the known one\n            Integer residue = block.get(su).get(right) - 1;\n            if (freePool.contains(residue)) {\n                block.get(su).set(res, residue);\n                freePool.remove(residue);\n            } else\n                return false;\n        } else if (block.get(su).get(right) == null) {\n            // Choose the sequentially next residue of the known one\n            Integer residue = block.get(su).get(left) + 1;\n            if (freePool.contains(residue)) {\n                block.get(su).set(res, residue);\n                freePool.remove(residue);\n            } else\n                return false;\n        } else {\n            // If boundaries are consecutive swap null and position (R or L)\n            if (block.get(su).get(right) == block.get(su).get(left) + 1) {\n                switch(rl) {\n                    case // to the right\n                    0:\n                        block.get(su).set(right - 1, block.get(su).get(right));\n                        block.get(su).set(right, null);\n                        break;\n                    case // to the left\n                    1:\n                        block.get(su).set(left + 1, block.get(su).get(left));\n                        block.get(su).set(left, null);\n                        break;\n                }\n            } else {\n                // Choose randomly a residue in between left and right to\n                // add\n                Integer residue = rnd.nextInt(block.get(su).get(right) - block.get(su).get(left) - 1) + block.get(su).get(left) + 1;\n                if (freePool.contains(residue)) {\n                    block.get(su).set(res, residue);\n                    freePool.remove(residue);\n                }\n            }\n        }\n        return true;\n    }\n    // When the residue is different than null\n    switch(rl) {\n        case // Move to the right\n        0:\n            int leftBoundary = res - 1;\n            int leftPrevRes = res;\n            while (true) {\n                if (leftBoundary < 0)\n                    break;\n                else {\n                    if (block.get(su).get(leftBoundary) == null) {\n                        // gap\n                        break;\n                    } else if (block.get(su).get(leftPrevRes) > block.get(su).get(leftBoundary) + 1) {\n                        // discontinuity\n                        break;\n                    }\n                }\n                leftPrevRes = leftBoundary;\n                leftBoundary--;\n            }\n            leftBoundary++;\n            int rightBoundary = res + 1;\n            int rightPrevRes = res;\n            while (true) {\n                if (rightBoundary == length)\n                    break;\n                else {\n                    if (block.get(su).get(rightBoundary) == null) {\n                        // gap\n                        break;\n                    } else if (block.get(su).get(rightPrevRes) + 1 < block.get(su).get(rightBoundary)) {\n                        // discontinuity\n                        break;\n                    }\n                }\n                rightPrevRes = rightBoundary;\n                rightBoundary++;\n            }\n            rightBoundary--;\n            // Residues at the boundary\n            Integer residueR0 = block.get(su).get(rightBoundary);\n            Integer residueL0 = block.get(su).get(leftBoundary);\n            // Remove residue at the right of the block and add to the freePool\n            block.get(su).remove(rightBoundary);\n            if (residueR0 != null) {\n                freePool.add(residueR0);\n                Collections.sort(freePool);\n            }\n            // Add the residue at the left of the block\n            // cannot be null, throw exception if it is\n            residueL0 -= 1;\n            if (freePool.contains(residueL0)) {\n                block.get(su).add(leftBoundary, residueL0);\n                freePool.remove(residueL0);\n            } else {\n                block.get(su).add(leftBoundary, null);\n            }\n            break;\n        case // Move to the left\n        1:\n            int leftBoundary1 = res - 1;\n            int leftPrevRes1 = res;\n            while (true) {\n                if (leftBoundary1 < 0)\n                    break;\n                else {\n                    if (block.get(su).get(leftBoundary1) == null) {\n                        // gap\n                        break;\n                    } else if (block.get(su).get(leftPrevRes1) > block.get(su).get(leftBoundary1) + 1) {\n                        // discontinuity\n                        break;\n                    }\n                }\n                leftPrevRes1 = leftBoundary1;\n                leftBoundary1--;\n            }\n            leftBoundary1++;\n            int rightBoundary1 = res + 1;\n            int rightPrevRes1 = res;\n            while (true) {\n                if (rightBoundary1 == length)\n                    break;\n                else {\n                    if (block.get(su).get(rightBoundary1) == null) {\n                        // gap\n                        break;\n                    } else if (block.get(su).get(rightPrevRes1) + 1 < block.get(su).get(rightBoundary1)) {\n                        // discontinuity\n                        break;\n                    }\n                }\n                rightPrevRes1 = rightBoundary1;\n                rightBoundary1++;\n            }\n            rightBoundary1--;\n            // Residues at the boundary\n            Integer residueR1 = block.get(su).get(rightBoundary1);\n            Integer residueL1 = block.get(su).get(leftBoundary1);\n            // Add the residue at the right of the block\n            // cannot be null\n            residueR1 += 1;\n            if (freePool.contains(residueR1)) {\n                if (rightBoundary1 == length - 1)\n                    block.get(su).add(residueR1);\n                else\n                    block.get(su).add(rightBoundary1 + 1, residueR1);\n                freePool.remove(residueR1);\n            } else {\n                block.get(su).add(rightBoundary1 + 1, null);\n            }\n            // Remove the residue at the left of the block\n            block.get(su).remove(leftBoundary1);\n            freePool.add(residueL1);\n            Collections.sort(freePool);\n            break;\n    }\n    checkGaps();\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Move all the block residues of one repeat one position to the left or\n * right and move the corresponding boundary residues from the freePool to\n * the block, and viceversa.\n * <p>\n * The boundaries are determined by any irregularity (either a gap or a\n * discontinuity in the alignment.\n */\n", "repo_name": "biojava-master/", "id": 2079, "method_signature": "boolean shiftRow()"}, "1973": {"callee_method_ids": [1919], "callee_method_names": ["Vector3d.sub", "Vector3d.sub", "Vector3d.add", "Vector3d.add", "Vector3d.normalize", "Vector3d.length", "HelixLayers.getByLargestContacts", "Vector3d.scale", "Vector3d.add"], "method_name": "HelixAxisAligner.getMidPoint", "method_implementation": "{\n    Vector3d v1 = new Vector3d();\n    v1.sub(p1, p2);\n    Vector3d v2 = new Vector3d();\n    v2.sub(p3, p2);\n    Vector3d v3 = new Vector3d();\n    v3.add(v1);\n    v3.add(v2);\n    v3.normalize();\n    // calculat the total distance between to subunits\n    double dTotal = v1.length();\n    // calculate the rise along the y-axis. The helix axis is aligned with y-axis,\n    // therfore, the rise between subunits is the y-distance\n    double rise = p2.y - p1.y;\n    // use phythagorean theoremm to calculate chord length between two subunit centers\n    double chord = Math.sqrt(dTotal * dTotal - rise * rise);\n    //\t\tSystem.out.println(\"Chord d: \" + dTotal + \" rise: \" + rise + \"chord: \" + chord);\n    double angle = helixLayers.getByLargestContacts().getAxisAngle().angle;\n    // using the axis angle and the chord length, we can calculate the radius of the helix\n    // http://en.wikipedia.org/wiki/Chord_%28geometry%29\n    // can this go to zero?\n    double radius = chord / Math.sin(angle / 2) / 2;\n    //\t\tSystem.out.println(\"Radius: \" + radius);\n    // project the radius onto the vector that points toward the helix axis\n    v3.scale(radius);\n    v3.add(p2);\n    //\t\tSystem.out.println(\"Angle: \" + Math.toDegrees(helixLayers.getByLowestAngle().getAxisAngle().angle));\n    Point3d cor = new Point3d(v3);\n    return cor;\n}", "repo_id": "9", "comment": "/**\n * Return a midpoint of a helix, calculated from three positions\n * of three adjacent subunit centers.\n * @param p1 center of first subunit\n * @param p2 center of second subunit\n * @param p3 center of third subunit\n * @return midpoint of helix\n */\n", "repo_name": "biojava-master/", "id": 1973, "method_signature": "Point3d getMidPoint(Point3d, Point3d, Point3d)"}, "3412": {"callee_method_ids": [1960], "callee_method_names": ["HelixAxisAligner.getTransformation"], "method_name": "JmolSymmetryScriptGeneratorH.getTransformation", "method_implementation": "{\n    return helixAxisAligner.getTransformation();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#getTransformation()\n\t */\n", "repo_name": "biojava-master/", "id": 3412, "method_signature": "Matrix4d getTransformation()"}, "1531": {"callee_method_names": [], "method_name": "JournalArticle.setRef", "method_implementation": "{\n    this.ref = ref;\n}", "repo_id": "9", "comment": "/**\n * Set the value of the ref.\n *\n * @param ref new value of ref\n */\n", "repo_name": "biojava-master/", "id": 1531, "method_signature": "void setRef(String)"}, "416": {"callee_method_ids": [484, 431], "callee_method_names": ["AFPChain.getAfpSet", "AFPChain.getDisTable1", "AFPChain.getDisTable2", "FatCatParameters.getFragLen", "FatCatParameters.getAfpDisCut", "FatCatParameters.getDisCut", "FatCatParameters.getFragLenSq", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "Matrix.get", "Matrix.get"], "method_name": "AFPChainer.calAfpDis", "method_implementation": "{\n    List<AFP> afpSet = afpChain.getAfpSet();\n    Matrix disTable1 = afpChain.getDisTable1();\n    Matrix disTable2 = afpChain.getDisTable2();\n    int fragLen = params.getFragLen();\n    double afpDisCut = params.getAfpDisCut();\n    double disCut = params.getDisCut();\n    double fragLenSq = params.getFragLenSq();\n    int i, j, ai, bi, aj, bj;\n    double d;\n    double rms = 0;\n    for (i = 0; i < fragLen; i++) {\n        ai = afpSet.get(afp1).getP1() + i;\n        bi = afpSet.get(afp1).getP2() + i;\n        for (j = 0; j < fragLen; j++) {\n            aj = afpSet.get(afp2).getP1() + j;\n            bj = afpSet.get(afp2).getP2() + j;\n            d = disTable1.get(aj, ai) - disTable2.get(bj, bi);\n            rms += d * d;\n            if (rms > afpDisCut) {\n                return (disCut);\n            }\n        }\n    }\n    return (Math.sqrt(rms / fragLenSq));\n}", "repo_id": "9", "comment": "/**\n * \t//return the root mean square of the distance matrix between the residues\n * \t//from the segments that form the given AFP list\n * \t//this value can be a measurement (2) for the connectivity of the AFPs\n * \t//and its calculation is quicker than the measurement (1), rmsd\n * \t//currently only deal with AFP pair\n * //\n * //           |-d1--|\n * //          |--d2---|\n * //         |---d3----|\n * \t//-----------------------------------------------------------------------\n * \t//this module is optimized\n *\n *  @param afp1\n *  @param afp2\n *  @return\n */\n", "repo_name": "biojava-master/", "id": 416, "method_signature": "double calAfpDis(int, int, FatCatParameters, AFPChain)"}, "2241": {"callee_method_names": ["Structure.getPolyChains", "Structure.getPolyChains", "Structure.getNonPolyChains", "Structure.getNonPolyChains", "Structure.getWaterChains", "Structure.getWaterChains"], "method_name": "TestMmtfRoundTrip.checkDiffChains", "method_implementation": "{\n    assertEquals(structOne.getPolyChains(i).size(), structTwo.getPolyChains(i).size());\n    assertEquals(structOne.getNonPolyChains(i).size(), structTwo.getNonPolyChains(i).size());\n    assertEquals(structOne.getWaterChains(i).size(), structTwo.getWaterChains(i).size());\n}", "repo_id": "9", "comment": "/**\n * Check both structures have the same number of poly, non-poly and water chains\n * @param structOne the first structure\n * @param structTwo the second structure\n * @param i the model index\n */\n", "repo_name": "biojava-master/", "id": 2241, "method_signature": "void checkDiffChains(Structure, Structure, int)"}, "1349": {"callee_method_names": [], "method_name": "EntityInfo.addChain", "method_implementation": "{\n    this.chains.add(chain);\n}", "repo_id": "9", "comment": "/**\n * Add new Chain to this EntityInfo\n * @param chain\n */\n", "repo_name": "biojava-master/", "id": 1349, "method_signature": "void addChain(Chain)"}, "969": {"callee_method_names": ["List<T>.size", "List<T>.size", "List<OrderedPair<T>>.add"], "method_name": "CartesianProduct.getOrderedPairs", "method_implementation": "{\n    List<OrderedPair<T>> pairs = new ArrayList<OrderedPair<T>>(list1.size() * list2.size());\n    for (T element1 : list1) {\n        for (T element2 : list2) {\n            pairs.add(new OrderedPair<T>(element1, element2));\n        }\n    }\n    return pairs;\n}", "repo_id": "9", "comment": "/**\n * Generates the list of ordered pair between two sets.\n *\n * @return the list of ordered pairs\n */\n", "repo_name": "biojava-master/", "id": 969, "method_signature": "List<OrderedPair<T>> getOrderedPairs()"}, "2724": {"callee_method_names": [], "method_name": "FileProxyRNASequenceCreator.getSequence", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported yet.\");\n}", "repo_id": "9", "comment": "/**\n * Not sure of use case and currently not supported\n * @param list\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2724, "method_signature": "AbstractSequence<NucleotideCompound> getSequence(List)"}, "2588": {"callee_method_names": ["TransformerFactory.newTransformer", "Transformer.transform"], "method_name": "XMLHelper.outputToStream", "method_implementation": "{\n    // Use a Transformer for output\n    TransformerFactory tFactory = TransformerFactory.newInstance();\n    Transformer transformer = tFactory.newTransformer();\n    //    transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n    DOMSource source = new DOMSource(document);\n    StreamResult result = new StreamResult(outputStream);\n    transformer.transform(source, result);\n}", "repo_id": "9", "comment": "/**\n * Given an {@code}org.w3c.dom.Document{@code}, writes it to the given {@code}outputStream{@code}\n * @param document\n * @param outputStream\n * @throws TransformerException\n */\n", "repo_name": "biojava-master/", "id": 2588, "method_signature": "void outputToStream(Document, OutputStream)"}, "2549": {"callee_method_names": [], "method_name": "Result.getQuerySequence", "method_implementation": "{\n    return querySequence;\n}", "repo_id": "9", "comment": "/**\n * returns the reference to the original and whole sequence used to query the database.\n * Available only if the ResultFactory implements setQueryReferences and\n * it was used before the parsing with SearchIO\n * @return Sequence object\n */\n", "repo_name": "biojava-master/", "id": 2549, "method_signature": "Sequence getQuerySequence()"}, "372": {"callee_method_ids": [1831, 1832], "callee_method_names": ["AtomIterator.hasNext", "AtomIterator.next", "Logger.debug", "Logger.error", "Atom.clone", "Atom.getX", "Atom.getY", "Atom.getZ", "Matrix.plus", "Matrix.get", "Matrix.get", "Matrix.get", "Atom.setCoords", "Logger.debug", "Logger.error", "Atom.clone"], "method_name": "Calc.plus", "method_implementation": "{\n    AtomIterator iter = new AtomIterator(s);\n    Atom oldAtom = null;\n    Atom rotOldAtom = null;\n    while (iter.hasNext()) {\n        Atom atom = null;\n        atom = iter.next();\n        try {\n            if (oldAtom != null) {\n                logger.debug(\"before {}\", getDistance(oldAtom, atom));\n            }\n        } catch (Exception e) {\n            logger.error(\"Exception: \", e);\n        }\n        oldAtom = (Atom) atom.clone();\n        double x = atom.getX();\n        double y = atom.getY();\n        double z = atom.getZ();\n        double[][] ad = new double[][] { { x, y, z } };\n        Matrix am = new Matrix(ad);\n        Matrix na = am.plus(matrix);\n        double[] coords = new double[3];\n        coords[0] = na.get(0, 0);\n        coords[1] = na.get(0, 1);\n        coords[2] = na.get(0, 2);\n        atom.setCoords(coords);\n        try {\n            if (rotOldAtom != null) {\n                logger.debug(\"after {}\", getDistance(rotOldAtom, atom));\n            }\n        } catch (Exception e) {\n            logger.error(\"Exception: \", e);\n        }\n        rotOldAtom = (Atom) atom.clone();\n    }\n}", "repo_id": "9", "comment": "/**\n * calculate structure + Matrix coodinates ...\n *\n * @param s\n *            the structure to operate on\n * @param matrix\n *            a Matrix object\n */\n", "repo_name": "biojava-master/", "id": 372, "method_signature": "void plus(Structure, Matrix)"}, "1266": {"callee_method_names": ["Atom.setPDBserial", "Atom.setName", "String.trim", "Atom.setElement", "Atom.setAltLoc", "Atom.setAltLoc", "Atom.setX", "Atom.setY", "Atom.setZ", "Atom.setOccupancy", "Atom.setTempFactor", "Atom.setCharge", "Group.addAtom", "Group.setChain", "Group.addAtom", "Group.hasAtom", "Atom.getName", "Group.getPDBName", "Atom.getGroup", "Group.addAtom", "List<Atom>.add"], "method_name": "MmtfStructureReader.setAtomInfo", "method_implementation": "{\n    Atom atom = new AtomImpl();\n    Group altGroup = null;\n    atom.setPDBserial(serialNumber);\n    atom.setName(atomName.trim());\n    atom.setElement(Element.valueOfIgnoreCase(element));\n    if (alternativeLocationId == MmtfStructure.UNAVAILABLE_CHAR_VALUE) {\n        alternativeLocationId = ' ';\n    }\n    if (alternativeLocationId != ' ') {\n        // Get the altGroup\n        altGroup = getCorrectAltLocGroup(alternativeLocationId);\n        atom.setAltLoc(alternativeLocationId);\n    } else {\n        atom.setAltLoc(Character.valueOf(' '));\n    }\n    atom.setX(x);\n    atom.setY(y);\n    atom.setZ(z);\n    atom.setOccupancy(occupancy);\n    atom.setTempFactor(temperatureFactor);\n    atom.setCharge((short) charge);\n    if (altGroup == null) {\n        group.addAtom(atom);\n    } else {\n        altGroup.setChain(chain);\n        altGroup.addAtom(atom);\n    }\n    // IF the main group doesn't have this atom\n    if (!group.hasAtom(atom.getName())) {\n        // If it's not a microheterogenity case\n        if (group.getPDBName().equals(atom.getGroup().getPDBName())) {\n            // And it's not a deuterated case.  'nanoheterogenity'\n            if (!StructureTools.hasNonDeuteratedEquiv(atom, group)) {\n                group.addAtom(atom);\n            }\n        }\n    }\n    atomsInGroup.add(atom);\n    allAtoms[atomCounter] = atom;\n    atomCounter++;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface#\n\t * setAtomInfo(java.lang.String, int, char, float, float,\n\t * float, float, float, java.lang.String, int)\n\t */\n", "repo_name": "biojava-master/", "id": 1266, "method_signature": "void setAtomInfo(String, int, char, float, float, float, float, float, String, int)"}, "1470": {"callee_method_names": [], "method_name": "CrystalCell.transfToOrthonormal", "method_implementation": "{\n    // see Giacovazzo section 2.E, eq. 2.E.1\n    getMTransposeInv().transform(v);\n}", "repo_id": "9", "comment": "/**\n * Transforms the given crystal basis coordinates into orthonormal coordinates.\n * e.g. transfToOrthonormal(new Point3d(1,1,1)) returns the orthonormal coordinates of the\n * vertex of the unit cell.\n * See Giacovazzo section 2.E, eq. 2.E.1 (or any linear algebra manual)\n * @param v\n */\n", "repo_name": "biojava-master/", "id": 1470, "method_signature": "void transfToOrthonormal(Tuple3d)"}, "2671": {"callee_method_names": ["ArrayList.remove"], "method_name": "MultipleSequenceAlignment.removeAlignedSequence", "method_implementation": "{\n    return sequences.remove(sequence);\n}", "repo_id": "9", "comment": "/**\n * Remove a sequence\n * @param sequence\n * @return flag\n */\n", "repo_name": "biojava-master/", "id": 2671, "method_signature": "boolean removeAlignedSequence(S)"}, "3317": {"callee_method_names": [], "method_name": "BiojavaJmol.jmolInClassPath", "method_implementation": "{\n    try {\n        Class.forName(viewer);\n    } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n        return false;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * returns true if Jmol can be found in the classpath, otherwise false.\n *\n * @return true/false depending if Jmol can be found\n */\n", "repo_name": "biojava-master/", "id": 3317, "method_signature": "boolean jmolInClassPath()"}, "2360": {"callee_method_names": ["DNASequence.addFeature", "DNASequence.getLength", "DNASequence.addFeature", "DNASequence.getLength"], "method_name": "FastqTools.createDNASequenceWithQualityScoresAndErrorProbabilities", "method_implementation": "{\n    DNASequence sequence = createDNASequence(fastq);\n    sequence.addFeature(1, sequence.getLength(), createQualityScores(fastq));\n    sequence.addFeature(1, sequence.getLength(), createErrorProbabilities(fastq));\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Create and return a new {@link DNASequence} with quality scores and error probabilities from the\n * specified FASTQ formatted sequence.  The quality scores are stored in a {@link QualityFeature}\n * with a type <code>\"qualityScores\"</code> the same length as the sequence and the error\n * probabilities are stored in a {@link QuantityFeature} with a type <code>\"errorProbabilities\"</code>\n * the same length as the sequence.\n *\n * @param fastq FASTQ formatted sequence, must not be null\n * @return a new {@link DNASequence} with quality scores and error probabilities from the specified\n *    FASTQ formatted sequence\n * @throws CompoundNotFoundException if DNA sequence in fastq contains unrecognised compounds\n */\n", "repo_name": "biojava-master/", "id": 2360, "method_signature": "DNASequence createDNASequenceWithQualityScoresAndErrorProbabilities(Fastq)"}, "2462": {"callee_method_ids": [2431], "callee_method_names": ["Logger.info", "BufferedReader.readLine", "BufferedReader.readLine", "String.trim", "String.length", "String.charAt", "FeatureList.add"], "method_name": "GeneIDGFF2Reader.read", "method_implementation": "{\n    logger.info(\"Reading: {}\", filename);\n    FeatureList features = new FeatureList();\n    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {\n        String s;\n        for (s = br.readLine(); null != s; s = br.readLine()) {\n            s = s.trim();\n            if (s.length() > 0) {\n                if (s.charAt(0) == '#') {\n                    //ignore comment lines\n                } else {\n                    FeatureI f = parseLine(s);\n                    if (f != null) {\n                        features.add(f);\n                    }\n                }\n            }\n        }\n    }\n    return features;\n}", "repo_id": "9", "comment": "/**\n * Read a file into a FeatureList. Each line of the file becomes one Feature object.\n *\n * @param filename The path to the GFF file.\n * @return A FeatureList.\n * @throws IOException Something went wrong -- check exception detail message.\n */\n", "repo_name": "biojava-master/", "id": 2462, "method_signature": "FeatureList read(String)"}, "1353": {"callee_method_names": [], "method_name": "AminoAcidImpl.getN", "method_implementation": "{\n    return getAtom(\"N\");\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1353, "method_signature": "Atom getN()"}, "2082": {"callee_method_names": [], "method_name": "SymmOptimizer.probabilityFunction", "method_implementation": "{\n    double prob = (C + AS) / (C * Math.sqrt(m));\n    // Normalization factor\n    double norm = (1 - (m * 1.0) / maxIter);\n    return Math.min(Math.max(prob * norm, 0.0), 1.0);\n}", "repo_id": "9", "comment": "/**\n * Calculates the probability of accepting a bad move given the iteration\n * step and the score change.\n * <p>\n * Function: p=(C-AS)/(C*sqrt(step)) Added a normalization factor so that\n * the probability approaches 0 when the maxIter is reached.\n */\n", "repo_name": "biojava-master/", "id": 2082, "method_signature": "double probabilityFunction(double, int, int)"}, "346": {"callee_method_names": ["Atom.setX", "Atom.getX", "Atom.getX", "Atom.setY", "Atom.getY", "Atom.getY", "Atom.setZ", "Atom.getZ", "Atom.getZ"], "method_name": "Calc.add", "method_implementation": "{\n    Atom c = new AtomImpl();\n    c.setX(a.getX() + b.getX());\n    c.setY(a.getY() + b.getY());\n    c.setZ(a.getZ() + b.getZ());\n    return c;\n}", "repo_id": "9", "comment": "/**\n * add two atoms ( a + b).\n *\n * @param a\n *            an Atom object\n * @param b\n *            an Atom object\n * @return an Atom object\n */\n", "repo_name": "biojava-master/", "id": 346, "method_signature": "Atom add(Atom, Atom)"}, "246": {"callee_method_names": ["Map<ModificationCategory, Set<ProteinModification>>.put", "Map<ModificationOccurrenceType, Set<ProteinModification>>.put"], "method_name": "ProteinModificationRegistry.lazyInit", "method_implementation": "{\n    if (registry == null) {\n        registry = new HashSet<ProteinModification>();\n        byId = new HashMap<String, ProteinModification>();\n        byResidId = new HashMap<String, Set<ProteinModification>>();\n        byPsimodId = new HashMap<String, Set<ProteinModification>>();\n        byPdbccId = new HashMap<String, Set<ProteinModification>>();\n        byKeyword = new HashMap<String, Set<ProteinModification>>();\n        byComponent = new HashMap<Component, Set<ProteinModification>>();\n        byCategory = new EnumMap<ModificationCategory, Set<ProteinModification>>(ModificationCategory.class);\n        for (ModificationCategory cat : ModificationCategory.values()) {\n            byCategory.put(cat, new HashSet<ProteinModification>());\n        }\n        byOccurrenceType = new EnumMap<ModificationOccurrenceType, Set<ProteinModification>>(ModificationOccurrenceType.class);\n        for (ModificationOccurrenceType occ : ModificationOccurrenceType.values()) {\n            byOccurrenceType.put(occ, new HashSet<ProteinModification>());\n        }\n        registerCommonProteinModifications(inStream);\n    }\n}", "repo_id": "9", "comment": "/**\n * Lazy Initialization the static variables and register common modifications.\n */\n", "repo_name": "biojava-master/", "id": 246, "method_signature": "void lazyInit(InputStream)"}, "2396": {"callee_method_names": [], "method_name": "Location.minus", "method_implementation": "{\n    if (isNegative()) {\n        return this;\n    } else {\n        return opposite();\n    }\n}", "repo_id": "9", "comment": "/**\n * Return location that is in same position on negative strand. If location is already\n * on negative strand, just return the location unchanged.\n *\n * @return Location on negative strand.\n */\n", "repo_name": "biojava-master/", "id": 2396, "method_signature": "Location minus()"}, "718": {"callee_method_ids": [760], "callee_method_names": ["CeParameters.getSubstitutionMatrix", "ScaledSubstitutionMatrix.getScale", "Matrix.getRowDimension", "Matrix.getColumnDimension", "Matrix.get", "AminoAcidCompoundSet.getCompoundForString", "Atom.getGroup", "AminoAcidCompoundSet.getCompoundForString", "Atom.getGroup", "SubstitutionMatrix<AminoAcidCompound>.getValue", "CeParameters.getSeqWeight", "Matrix.set", "Matrix.getArray"], "method_name": "CECalculator.updateMatrixWithSequenceConservation", "method_implementation": "{\n    Matrix origM = new Matrix(max);\n    SubstitutionMatrix<AminoAcidCompound> substMatrix = params.getSubstitutionMatrix();\n    int internalScale = 1;\n    if (substMatrix instanceof ScaledSubstitutionMatrix) {\n        ScaledSubstitutionMatrix scaledMatrix = (ScaledSubstitutionMatrix) substMatrix;\n        internalScale = scaledMatrix.getScale();\n    }\n    AminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    for (int i = 0; i < origM.getRowDimension(); i++) {\n        for (int j = 0; j < origM.getColumnDimension(); j++) {\n            double val = origM.get(i, j);\n            Atom a1 = ca1[i];\n            Atom a2 = ca2[j];\n            AminoAcidCompound ac1 = set.getCompoundForString(a1.getGroup().getChemComp().getOneLetterCode());\n            AminoAcidCompound ac2 = set.getCompoundForString(a2.getGroup().getChemComp().getOneLetterCode());\n            if (ac1 == null || ac2 == null)\n                continue;\n            short aaScore = substMatrix.getValue(ac1, ac2);\n            double weightedScore = (aaScore / internalScale) * params.getSeqWeight();\n            val += weightedScore;\n            origM.set(i, j, val);\n        }\n    }\n    max = origM.getArray();\n    //SymmetryTools.showMatrix((Matrix)origM.clone(), \"in optimizer \"  + loopCount  );\n    //SymmetryTools.showMatrix(origM, \"iteration  matrix \" + loopCount + \" after\");\n    return max;\n}", "repo_id": "9", "comment": "/**\n * Modifies an alignment matrix by favoring the alignment of similar and identical amino acids and penalizing the alignment of unrelated ones.\n *\n * @param max alignment matrix\n * @param ca1 Atoms for protein 1\n * @param ca2 Atoms for Protein 2\n * @param params alignment parameters\n * @return modified alignment matrix\n */\n", "repo_name": "biojava-master/", "id": 718, "method_signature": "double[][] updateMatrixWithSequenceConservation(double[][], Atom[], Atom[], CeParameters)"}, "658": {"callee_method_names": ["List<Integer>.get", "MultipleAlignment.getBlocks", "String.length", "String.length"], "method_name": "MultipleAlignmentTools.getBlockForSequencePosition", "method_implementation": "{\n    int seqPos = mapSeqToStruct.get(sequencePos);\n    // Check if the position selected is an aligned position\n    if (seqPos == -1)\n        return -1;\n    else {\n        // Calculate the corresponding block (by iterating all Blocks)\n        int sum = 0;\n        int block = 0;\n        for (Block b : multAln.getBlocks()) {\n            if (sum + b.length() <= seqPos) {\n                sum += b.length();\n                block++;\n                continue;\n            } else\n                break;\n        }\n        return block;\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the block number of a specified position in the sequence\n * alignment, given the mapping from structure to function.\n *\n * @param multAln\n *            the MultipleAlignment object from where the sequence alignment\n *            has been generated.\n * @param mapSeqToStruct\n *            the mapping between sequence and structure generated with the\n *            sequence alignment\n * @param sequencePos\n *            the position in the sequence alignment (column)\n * @return int the block index, or -1 if the position is not aligned\n */\n", "repo_name": "biojava-master/", "id": 658, "method_signature": "int getBlockForSequencePosition(MultipleAlignment, List, int)"}, "1431": {"callee_method_ids": [1456], "callee_method_names": ["SpaceGroup.getAxisFoldType"], "method_name": "CrystalTransform.getTransformType", "method_implementation": "{\n    // if no SG, that means a non-crystallographic entry (e.g. NMR). We return AU as type\n    if (sg == null)\n        return TransformType.AU;\n    int foldType = sg.getAxisFoldType(this.transformId);\n    boolean isScrewOrGlide = false;\n    Vector3d translScrewComponent = getTranslScrewComponent();\n    if (Math.abs(translScrewComponent.x - 0.0) > SpaceGroup.DELTA || Math.abs(translScrewComponent.y - 0.0) > SpaceGroup.DELTA || Math.abs(translScrewComponent.z - 0.0) > SpaceGroup.DELTA) {\n        isScrewOrGlide = true;\n    }\n    if (foldType > 1) {\n        if (isScrewOrGlide) {\n            switch(foldType) {\n                case 2:\n                    return TransformType.TWOFOLDSCREW;\n                case 3:\n                    return TransformType.THREEFOLDSCREW;\n                case 4:\n                    return TransformType.FOURFOLDSCREW;\n                case 6:\n                    return TransformType.SIXFOLDSCREW;\n                default:\n                    throw new NullPointerException(\"This transformation did not fall into any of the known types! This is most likely a bug.\");\n            }\n        } else {\n            switch(foldType) {\n                case 2:\n                    return TransformType.TWOFOLD;\n                case 3:\n                    return TransformType.THREEFOLD;\n                case 4:\n                    return TransformType.FOURFOLD;\n                case 6:\n                    return TransformType.SIXFOLD;\n                default:\n                    throw new NullPointerException(\"This transformation did not fall into any of the known types! This is most likely a bug.\");\n            }\n        }\n    } else if (foldType < 0) {\n        switch(foldType) {\n            case -1:\n                return TransformType.ONEBAR;\n            case -2:\n                if (isScrewOrGlide) {\n                    return TransformType.GLIDE;\n                }\n                return TransformType.TWOBAR;\n            case -3:\n                return TransformType.THREEBAR;\n            case -4:\n                return TransformType.FOURBAR;\n            case -6:\n                return TransformType.SIXBAR;\n            default:\n                throw new NullPointerException(\"This transformation did not fall into any of the known types! This is most likely a bug.\");\n        }\n    } else {\n        if (isIdentity()) {\n            return TransformType.AU;\n        }\n        if (isPureCrystalTranslation()) {\n            return TransformType.XTALTRANSL;\n        }\n        if (isFractionalTranslation()) {\n            return TransformType.CELLTRANSL;\n        }\n        throw new NullPointerException(\"This transformation did not fall into any of the known types! This is most likely a bug.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the TransformType of this transformation: AU, crystal translation, fractional translation\n * , 2 3 4 6-fold rotations, 2 3 4 6-fold screw rotations, -1 -3 -2 -4 -6 inversions/rotoinversions.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1431, "method_signature": "TransformType getTransformType()"}, "174": {"callee_method_names": [], "method_name": "StringManipulationTestsHelper.assertEqualsXml", "method_implementation": "{\n    Assert.assertTrue(StringManipulationHelper.equalsToXml(expectedXml, actualXml));\n}", "repo_id": "9", "comment": "/**\n * Asserts that two XML-representing strings are equal, by recursively\n * comparing each node's set of properties & children nodes. This method\n * should be used when two XMLs are considered identical when all nodes are\n * identical regardless to their order\n *\n * @param expectedXml\n * @param actualXml\n */\n", "repo_name": "biojava-master/", "id": 174, "method_signature": "void assertEqualsXml(String, String)"}, "1762": {"callee_method_names": [], "method_name": "PDBHeader.toPDB", "method_implementation": "{\n    //          1         2         3         4         5         6         7\n    //01234567890123456789012345678901234567890123456789012345678901234567890123456789\n    //HEADER    COMPLEX (SERINE PROTEASE/INHIBITORS)    06-FEB-98   1A4W\n    //TITLE     CRYSTAL STRUCTURES OF THROMBIN WITH THIAZOLE-CONTAINING\n    //TITLE    2 INHIBITORS: PROBES OF THE S1' BINDING SITE\n    printHeader(buf);\n    printTitle(buf);\n    printExpdata(buf);\n    printAuthors(buf);\n    printResolution(buf);\n}", "repo_id": "9", "comment": "/**\n * Appends a PDB representation of the PDB header to the provided StringBuffer\n *\n * @param buf\n */\n", "repo_name": "biojava-master/", "id": 1762, "method_signature": "void toPDB(StringBuffer)"}, "2586": {"callee_method_names": [], "method_name": "XMLHelper.loadXML", "method_implementation": "{\n    InputStream is = openFile(new File(fileName));\n    Document doc = inputStreamToDocument(new BufferedInputStream(is));\n    close(is);\n    return doc;\n}", "repo_id": "9", "comment": "/**\n * Given a path to an XML file, parses into an {@code}org.w3c.dom.Document{@code}\n * @param fileName path to a readable XML file\n * @return\n * @throws SAXException\n * @throws IOException\n * @throws ParserConfigurationException\n */\n", "repo_name": "biojava-master/", "id": 2586, "method_signature": "Document loadXML(String)"}, "1878": {"callee_method_names": [], "method_name": "Helix.getFold", "method_implementation": "{\n    return fold;\n}", "repo_id": "9", "comment": "/**\n * @return the fold\n */\n", "repo_name": "biojava-master/", "id": 1878, "method_signature": "int getFold()"}, "2071": {"callee_method_names": ["List<List<Integer>>.get", "List<Integer>.get"], "method_name": "ResidueGroup.combineWith", "method_implementation": "{\n    for (int i = 0; i < order(); i++) alignRes.get(i).add(residues.get(i));\n}", "repo_id": "9", "comment": "/**\n * Combine the ResidueGroup with the alignment block.\n *\n * @param alignRes\n *            the alignment block, will be modified.\n */\n", "repo_name": "biojava-master/", "id": 2071, "method_signature": "void combineWith(List)"}, "1486": {"callee_method_names": ["Point3d.add", "Point3d.scale"], "method_name": "CalcPoint.centroid", "method_implementation": "{\n    Point3d center = new Point3d();\n    for (Point3d p : x) {\n        center.add(p);\n    }\n    center.scale(1.0 / x.length);\n    return center;\n}", "repo_id": "9", "comment": "/**\n * Calculate the centroid of the point cloud.\n *\n * @param x\n *            array of points. Point objects will not be modified\n * @return centroid as Point3d\n */\n", "repo_name": "biojava-master/", "id": 1486, "method_signature": "Point3d centroid(Point3d[])"}, "547": {"callee_method_names": [], "method_name": "StructurePairAligner.getParams", "method_implementation": "{\n    return params;\n}", "repo_id": "9", "comment": "/**\n * get the parameters.\n *\n * @return the Parameters.\n */\n", "repo_name": "biojava-master/", "id": 547, "method_signature": "StrucAligParameters getParams()"}, "2128": {"callee_method_ids": [1351, 1370], "callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Chain.getAtomGroups", "Chain.getAtomGroups", "Chain.getAtomGroups", "StringBuilder.append", "Chain.getId", "Chain.getName", "Chain.getEntityInfo", "Chain.getEntityInfo", "EntityInfo.getDescription", "StringBuilder.append", "EntityInfo.getType", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Chain.getSeqResLength", "StringBuilder.append", "Chain.getAtomLength", "StringBuilder.append", "List<Group>.size", "StringBuilder.append", "List<Group>.size", "StringBuilder.append", "List<Group>.size", "StringBuilder.append", "List<DBRef>.size", "StringBuilder.append", "DBRef.toPDB", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "StructureImpl.toString", "method_implementation": "{\n    String newline = System.getProperty(\"line.separator\");\n    StringBuilder str = new StringBuilder();\n    str.append(\"structure \");\n    str.append(name);\n    str.append(\" \");\n    str.append(pdbId);\n    str.append(\" \");\n    if (nrModels() > 1) {\n        str.append(\" models: \");\n        str.append(nrModels());\n        str.append(newline);\n    }\n    str.append(pdbHeader);\n    str.append(newline);\n    for (int i = 0; i < nrModels(); i++) {\n        if (nrModels() > 1) {\n            str.append(\" model[\");\n            str.append(i);\n            str.append(\"]:\");\n            str.append(newline);\n        }\n        str.append(\" chains:\");\n        str.append(newline);\n        for (int j = 0; j < size(i); j++) {\n            Chain cha = getChainByIndex(i, j);\n            List<Group> agr = cha.getAtomGroups(GroupType.AMINOACID);\n            List<Group> hgr = cha.getAtomGroups(GroupType.HETATM);\n            List<Group> ngr = cha.getAtomGroups(GroupType.NUCLEOTIDE);\n            str.append(\"chain \").append(j).append(\": asymId:\").append(cha.getId()).append(\" authId:\").append(cha.getName()).append(\" \");\n            if (cha.getEntityInfo() != null) {\n                EntityInfo comp = cha.getEntityInfo();\n                String molName = comp.getDescription();\n                if (molName != null) {\n                    str.append(molName);\n                }\n                String type = comp.getType().toString();\n                str.append(\" (\").append(type).append(\")\");\n            }\n            str.append(newline);\n            str.append(\" length SEQRES: \").append(cha.getSeqResLength());\n            str.append(\" length ATOM: \").append(cha.getAtomLength());\n            str.append(\" aminos: \").append(agr.size());\n            str.append(\" hetatms: \").append(hgr.size());\n            str.append(\" nucleotides: \").append(ngr.size()).append(newline);\n        }\n    }\n    str.append(\"DBRefs: \").append(dbrefs.size()).append(newline);\n    for (DBRef dbref : dbrefs) {\n        str.append(dbref.toPDB()).append(newline);\n    }\n    str.append(\"Molecules: \").append(newline);\n    for (EntityInfo mol : entityInfos) {\n        str.append(mol).append(newline);\n    }\n    return str.toString();\n}", "repo_id": "9", "comment": "/**\n * String representation.\n */\n", "repo_name": "biojava-master/", "id": 2128, "method_signature": "String toString()"}, "3500": {"callee_method_names": ["String.replaceAll"], "method_name": "NCBIQBlastAlignmentProperties.setBlastAdvancedOptions", "method_implementation": "{\n    // Escaping white spaces with + char to comply with QBlast specifications\n    setAlignmentOption(OTHER_ADVANCED, advancedOptions.replaceAll(\" \", \"+\"));\n}", "repo_id": "9", "comment": "/**\n * This method is to be used if a request is to use non-default values at submission. Useful for the following\n * blastall parameters:\n * <ul>\n * <li>-r: integer to reward for match. Default = 1</li>\n * <li>-q: negative integer for penalty to allow mismatch. Default = -3</li>\n * <li>-y: dropoff for blast extensions in bits, using default if not specified. Default = 20 for blastn, 7 for all\n * others (except megablast for which it is not applicable).</li>\n * <li>-X: X dropoff value for gapped alignment, in bits. Default = 30 for blastn/megablast, 15 for all others.</li>\n * <li>-Z: final X dropoff value for gapped alignement, in bits. Default = 50 for blastn, 25 for all others (except\n * megablast for which it is not applicable)</li>\n * <li>-P: equals 0 for multiple hits 1-pass, 1 for single hit 1-pass. Does not apply to blastn ou megablast.</li>\n * <li>-A: multiple hits window size. Default = 0 (for single hit algorithm)</li>\n * <li>-I: number of database sequences to save hits for. Default = 500</li>\n * <li>-Y: effective length of the search space. Default = 0 (0 represents using the whole space)</li>\n * <li>-z: a real specifying the effective length of the database to use. Default = 0 (0 represents the real size)</li>\n * <li>-c: an integer representing pseudocount constant for PSI-BLAST. Default = 7</li>\n * <li>-F: any filtering directive</li>\n * </ul>\n * <p>\n * WARNING!! This method is still very much in flux and might not work as expected...\n * </p>\n * <p>\n * You have to be aware that at no moment is there any error checking on the use of these parameters by this class.\n * </p>\n *\n * @param advancedOptions : a String with any number of optional parameters with an associated value.\n */\n", "repo_name": "biojava-master/", "id": 3500, "method_signature": "void setBlastAdvancedOptions(String)"}, "954": {"callee_method_names": [], "method_name": "BiologicalAssemblyTransformation.setId", "method_implementation": "{\n    this.id = id;\n}", "repo_id": "9", "comment": "/**\n * Sets the identifier for this biological assembly transformation. This is usually\n * the model number used in the biological assembly files.\n * @param id\n */\n", "repo_name": "biojava-master/", "id": 954, "method_signature": "void setId(String)"}, "2259": {"callee_method_ids": [1279, 1283, 1277, 1281], "callee_method_names": ["Chain.setId", "Map<String, Integer>.put", "List<Chain>.add", "Chain.addGroup", "List<Atom>.add", "List<Atom>.add", "Structure.addChain", "Group.addAtom", "Group.addAtom", "MmtfSummaryDataBean.getAllAtoms", "MmtfSummaryDataBean.getChainIdToIndexMap", "MmtfSummaryDataBean.getAllChains", "MmtfSummaryDataBean.getNumBonds"], "method_name": "TestMmtfUtils.testGetStructureInfo", "method_implementation": "{\n    Structure structure = new StructureImpl();\n    Chain chain = new ChainImpl();\n    chain.setId(\"A\");\n    Map<String, Integer> testMap = new HashMap<>();\n    testMap.put(\"A\", 0);\n    List<Chain> chainList = new ArrayList<>();\n    chainList.add(chain);\n    Group group = new AminoAcidImpl();\n    chain.addGroup(group);\n    Atom atomOne = new AtomImpl();\n    Atom atomTwo = new AtomImpl();\n    List<Atom> atomList = new ArrayList<>();\n    atomList.add(atomOne);\n    atomList.add(atomTwo);\n    new BondImpl(atomOne, atomTwo, 1);\n    structure.addChain(chain);\n    group.addAtom(atomOne);\n    group.addAtom(atomTwo);\n    // Get the structure\n    MmtfSummaryDataBean mmtfSummaryDataBean = MmtfUtils.getStructureInfo(structure);\n    assertEquals(mmtfSummaryDataBean.getAllAtoms(), atomList);\n    assertEquals(testMap, mmtfSummaryDataBean.getChainIdToIndexMap());\n    assertEquals(chainList, mmtfSummaryDataBean.getAllChains());\n    assertEquals(1, mmtfSummaryDataBean.getNumBonds());\n}", "repo_id": "9", "comment": "/**\n * Test that getting the structure data info works.\n */\n", "repo_name": "biojava-master/", "id": 2259, "method_signature": "void testGetStructureInfo()"}, "1507": {"callee_method_names": ["Matrix4d.set", "Matrix4d.setIdentity", "Matrix4d.setTranslation", "Matrix4d.mul", "Point3d.negate", "Matrix4d.setIdentity", "Matrix4d.setTranslation", "Matrix4d.mul"], "method_name": "SuperPositionQCP.calcTransformation", "method_implementation": "{\n    // transformation.set(rotmat,new Vector3d(0,0,0), 1);\n    transformation.set(rotmat);\n    // long t2 = System.nanoTime();\n    // System.out.println(\"create transformation: \" + (t2-t1));\n    // System.out.println(\"m3d -> m4d\");\n    // System.out.println(transformation);\n    // combine with x -> origin translation\n    Matrix4d trans = new Matrix4d();\n    trans.setIdentity();\n    trans.setTranslation(new Vector3d(xtrans));\n    transformation.mul(transformation, trans);\n    // System.out.println(\"setting xtrans\");\n    // System.out.println(transformation);\n    // combine with origin -> y translation\n    ytrans.negate();\n    Matrix4d transInverse = new Matrix4d();\n    transInverse.setIdentity();\n    transInverse.setTranslation(new Vector3d(ytrans));\n    transformation.mul(transInverse, transformation);\n    // System.out.println(\"setting ytrans\");\n    // System.out.println(transformation);\n}", "repo_id": "9", "comment": "/**\n * Superposition coords2 onto coords1 -- in other words, coords2 is rotated,\n * coords1 is held fixed\n */\n", "repo_name": "biojava-master/", "id": 1507, "method_signature": "void calcTransformation()"}, "424": {"callee_method_names": ["AFPChain.getAfpChainList", "AFPChain.getBlock2Afp", "AFPChain.getBlockSize", "AFPChain.setBlock2Afp", "AFPChain.setBlockSize", "AFPChain.setAfpChainList"], "method_name": "AFPPostProcessor.combineRmsd", "method_implementation": "{\n    int i;\n    int afpn = 0;\n    int[] afpChainList = afpChain.getAfpChainList();\n    int[] block2Afp = afpChain.getBlock2Afp();\n    int[] blockSize = afpChain.getBlockSize();\n    int[] list = new int[blockSize[b1] + blockSize[b2]];\n    for (i = block2Afp[b1]; i < block2Afp[b1] + blockSize[b1]; i++) {\n        list[afpn++] = afpChainList[i];\n    }\n    for (i = block2Afp[b2]; i < block2Afp[b2] + blockSize[b2]; i++) {\n        list[afpn++] = afpChainList[i];\n    }\n    double rmsd = AFPChainer.calAfpRmsd(afpn, list, 0, afpChain, ca1, ca2);\n    afpChain.setBlock2Afp(block2Afp);\n    afpChain.setBlockSize(blockSize);\n    afpChain.setAfpChainList(afpChainList);\n    return rmsd;\n}", "repo_id": "9", "comment": "/**\n * \treturn the rmsd of two blocks\n */\n", "repo_name": "biojava-master/", "id": 424, "method_signature": "double combineRmsd(int, int, AFPChain, Atom[], Atom[])"}, "2327": {"callee_method_ids": [1322], "callee_method_names": ["FileParsingParameters.setAlignSeqRes", "AtomCache.setFileParsingParams", "Structure.clone"], "method_name": "TestCloning.test3piuCloning", "method_implementation": "{\n    final AtomCache cache = new AtomCache();\n    final FileParsingParameters params = new FileParsingParameters();\n    params.setAlignSeqRes(true);\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    final Structure s = StructureIO.getStructure(\"3piu\");\n    final Structure c = s.clone();\n    compareCloned(s, c);\n}", "repo_id": "9", "comment": "/**\n * A Structure with alt locs, we make sure they are being cloned too\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2327, "method_signature": "void test3piuCloning()"}, "1965": {"callee_method_names": [], "method_name": "HelixAxisAligner.getPrincipalAxesOfInertia", "method_implementation": "{\n    run();\n    return principalAxesOfInertia;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getPrincipalAxesOfInertia()\n\t */\n", "repo_name": "biojava-master/", "id": 1965, "method_signature": "Vector3d[] getPrincipalAxesOfInertia()"}, "1403": {"callee_method_names": ["String.substring", "String.toUpperCase"], "method_name": "PdbId.toShortId", "method_implementation": "{\n    if (isShortCompatible(extendedId)) {\n        return extendedId.substring(8).toUpperCase();\n    } else if (isValidShortPdbId(extendedId)) {\n        return extendedId.toUpperCase();\n    } else {\n        throw new StructureException(\"Conversion not possible of ID [\" + extendedId + \"]\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Converts <code>extendedId</code> to the PDB ID short format.\n * If <code>extendedId</code> is a valid extended PDB ID, it would be converted to a short ID,\n * if <code>extendedId</code> is a valid short PDB ID, it would be returned in UPPER CASE,\n * a {@link StructureException} is thrown otherwise.\n * @param extendedId the PDB ID to convert to short format\n * @return the ID in the short UPPER CASE format.\n * @throws StructureException if the conversion was not possible.\n */\n", "repo_name": "biojava-master/", "id": 1403, "method_signature": "String toShortId(String)"}, "75": {"callee_method_names": [], "method_name": "GuanUberbacher.setDefaultCutsPerSection", "method_implementation": "{\n    defaultCutsPerSection = Math.max(1, defaultCutsPerSection);\n}", "repo_id": "9", "comment": "/**\n * Sets the default number of cuts added to each section during each pass.\n * @param defaultCutsPerSection the default number of cuts added to each section during each pass\n */\n", "repo_name": "biojava-master/", "id": 75, "method_signature": "void setDefaultCutsPerSection(int)"}, "1548": {"callee_method_names": ["Map<String, List<ScopDomain>>.get", "String.toLowerCase", "double[].clone", "List<ScopDomain>.add"], "method_name": "ScopInstallation.getDomainsForPDB", "method_implementation": "{\n    try {\n        ensureClaInstalled();\n    } catch (IOException e) {\n        throw new ScopIOException(e);\n    }\n    List<ScopDomain> doms = domainMap.get(pdbId.toLowerCase());\n    List<ScopDomain> retdoms = new ArrayList<ScopDomain>();\n    if (doms == null)\n        return retdoms;\n    for (ScopDomain d : doms) {\n        try {\n            ScopDomain n = (ScopDomain) d.clone();\n            retdoms.add(n);\n        } catch (CloneNotSupportedException e) {\n            throw new RuntimeException(ScopDomain.class + \" subclass does not support clone()\", e);\n        }\n    }\n    return retdoms;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getDomainsForPDB(java.lang.String)\n\t */\n", "repo_name": "biojava-master/", "id": 1548, "method_signature": "List<ScopDomain> getDomainsForPDB(String)"}, "3083": {"callee_method_names": [], "method_name": "AbstractFeature.setSource", "method_implementation": "{\n    this.source = source;\n}", "repo_id": "9", "comment": "/**\n * Set the feature source\n * @param source\n */\n", "repo_name": "biojava-master/", "id": 3083, "method_signature": "void setSource(String)"}, "3731": {"callee_method_names": ["ArrayList<String>.add"], "method_name": "WorkSheet.addColumn", "method_implementation": "{\n    ArrayList<String> columns = new ArrayList<String>();\n    columns.add(column);\n    addColumns(columns, defaultValue);\n}", "repo_id": "9", "comment": "/**\n * @param column\n * @param defaultValue\n */\n", "repo_name": "biojava-master/", "id": 3731, "method_signature": "void addColumn(String, String)"}, "1710": {"callee_method_names": [], "method_name": "BondImpl.getBondOrder", "method_implementation": "{\n    return bondOrder;\n}", "repo_id": "9", "comment": "/**\n * Gets the bond order of this bond. A return value of '1' corresponds to a\n * single bond, '2' to a double bond, etc.\n *\n * @return this bond's bond order\n */\n", "repo_name": "biojava-master/", "id": 1710, "method_signature": "int getBondOrder()"}, "2793": {"callee_method_names": [], "method_name": "GenbankWriter.setLineLength", "method_implementation": "{\n    this.lineLength = lineLength;\n}", "repo_id": "9", "comment": "/**\n * @param lineLength\n *            the lineLength to set\n */\n", "repo_name": "biojava-master/", "id": 2793, "method_signature": "void setLineLength(int)"}, "1932": {"callee_method_names": [], "method_name": "QuatSymmetryResults.setLocal", "method_implementation": "{\n    this.local = local;\n}", "repo_id": "9", "comment": "/**\n * A local result means that only a subset of the original Subunits was used\n * for symmetry determination.\n *\n * @param local\n *            true if local result, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 1932, "method_signature": "void setLocal(boolean)"}, "2299": {"callee_method_names": [], "method_name": "TestBond.testDeuterated", "method_implementation": "{\n    // The terminal Hydrogen D3 - is missing (from the CCD)\n    assertEquals(2, countAtomsWithoutBonds(\"1GKT\"));\n    assertEquals(2, countAtomsWithoutBonds(\"1IO5\"));\n    // All H/D2,H/D3 errors\n    assertEquals(13, countAtomsWithoutBonds(\"5E5J\"));\n}", "repo_id": "9", "comment": "/**\n * Test that all the atoms in deuterated structures are bonded.\n * @throws IOException an error getting the required file\n * @throws StructureException an error parsing the required file\n */\n", "repo_name": "biojava-master/", "id": 2299, "method_signature": "void testDeuterated()"}, "1386": {"callee_method_names": [], "method_name": "DBRef.getIdbnsBegin", "method_implementation": "{\n    return idbnsBegin;\n}", "repo_id": "9", "comment": "/**\n *  Insertion code of initial residue of the segment, if PDB is the\n * \treference.\n *  @return idbnsBegin isnertion code\n *  @see #setIdbnsBegin(char)\n */\n", "repo_name": "biojava-master/", "id": 1386, "method_signature": "char getIdbnsBegin()"}, "323": {"callee_method_ids": [298, 290], "callee_method_names": ["ProteinModificationIdentifier.identify", "ProteinModificationIdentifier.getIdentifiedModifiedCompound"], "method_name": "ProteinModificationParserTest.identifyAllModfications", "method_implementation": "{\n    ProteinModificationIdentifier parser = new ProteinModificationIdentifier();\n    parser.identify(struc);\n    Set<ModifiedCompound> mcs = parser.getIdentifiedModifiedCompound();\n    return mcs;\n}", "repo_id": "9", "comment": "/**\n * Note: if you change this unit test, also change the cook book:\n * http://www.biojava.org/wiki/BioJava:CookBook3:ProtMod\n */\n", "repo_name": "biojava-master/", "id": 323, "method_signature": "Set<ModifiedCompound> identifyAllModfications(Structure)"}, "2930": {"callee_method_names": [], "method_name": "AbstractSequence.getComments", "method_implementation": "{\n    return comments;\n}", "repo_id": "9", "comment": "/**\n * @return comments\n */\n", "repo_name": "biojava-master/", "id": 2930, "method_signature": "List<String> getComments()"}, "645": {"callee_method_names": ["Logger.error", "int[].getMessage", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug"], "method_name": "AtomCache.getStructureForPdbId", "method_implementation": "{\n    if (pdbId == null)\n        return null;\n    while (checkLoading(pdbId)) {\n        // waiting for loading to be finished...\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            logger.error(e.getMessage());\n        }\n    }\n    switch(filetype) {\n        case CIF:\n            logger.debug(\"loading from mmcif\");\n            return loadStructureFromCifByPdbId(pdbId);\n        case BCIF:\n            logger.debug(\"loading from bcif\");\n            return loadStructureFromBcifByPdbId(pdbId);\n        case MMTF:\n            logger.debug(\"loading from mmtf\");\n            return loadStructureFromMmtfByPdbId(pdbId);\n        case PDB:\n        default:\n            logger.debug(\"loading from pdb\");\n            return loadStructureFromPdbByPdbId(pdbId);\n    }\n}", "repo_id": "9", "comment": "/**\n * Loads a structure directly by PDB ID\n * @param pdbId\n * @return\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 645, "method_signature": "Structure getStructureForPdbId(PdbId)"}, "1144": {"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append"], "method_name": "SSBondImpl.toPDB", "method_implementation": "{\n    /*12 - 14        LString(3)      \"CYS\"        Residue name.\n\t\t16             Character       chainID1     Chain identifier.\n\t\t18 - 21        Integer         seqNum1      Residue sequence number.\n\t\t22             AChar           icode1       Insertion code.\n\t\t26 - 28        LString(3)      \"CYS\"        Residue name.\n\t\t30             Character       chainID2     Chain identifier.\n\t\t32 - 35        Integer         seqNum2      Residue sequence number.\n\t\t36             AChar           icode2       Insertion code.\n\t\t60 - 65        SymOP           sym1         Symmetry oper for 1st resid\n\t\t67 - 72        SymOP           sym2         Symmetry oper for 2nd resid\n\t\t*/\n    //01234567890123456789012345678901234567890123456789012345678901234567890123456789\n    //SSBOND   1 CYS      5    CYS     55                                     5PTI  67\n    //SSBOND   2 CYS     14    CYS     38\n    //SSBOND   3 CYS     30    CYS     51\n    buf.append(\"SSBOND \");\n    buf.append(String.format(\"%3d\", serNum));\n    buf.append(String.format(\" CYS %s %4s%1s  \", chainID1, resnum1, insCode1));\n    buf.append(String.format(\" CYS %s %4s%1s  \", chainID2, resnum2, insCode2));\n}", "repo_id": "9", "comment": "/**\n * Append the PDB representation of this SSBOND to the provided StringBuffer\n *\n * @param buf a StringBuffer to print the PDB representation to\n */\n", "repo_name": "biojava-master/", "id": 1144, "method_signature": "void toPDB(StringBuffer)"}, "3047": {"callee_method_names": ["int.getEnd", "ResidueNumber.getEnd"], "method_name": "LocationHelper.getMax", "method_implementation": "{\n    return scanLocations(locations, new LocationPredicate() {\n\n        @Override\n        public boolean accept(Location previous, Location current) {\n            int res = current.getEnd().compareTo(previous.getEnd());\n            return res > 0;\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Scans through a list of locations to find the Location with the\n * highest end\n */\n", "repo_name": "biojava-master/", "id": 3047, "method_signature": "Location getMax(List)"}, "2457": {"callee_method_names": [], "method_name": "Feature.attributes", "method_implementation": "{\n    return mAttributes;\n}", "repo_id": "9", "comment": "/**\n * Get the string of key/value attributes. (GFF field 9). The format and\n * meaning of this field varies from flavor to flavor of GFF/GTF. This method\n * simply returns the whole string. Other methods in this class make assumptions\n * about its format and provide additional utility.\n *\n * @return The attribute string.\n */\n", "repo_name": "biojava-master/", "id": 2457, "method_signature": "String attributes()"}, "1378": {"callee_method_names": [], "method_name": "DBRef.getDbAccession", "method_implementation": "{\n    return dbAccession;\n}", "repo_id": "9", "comment": "/**\n * Sequence database accession code.\n * @return the dbAccession\n * @see #setDbAccession(String)\n */\n", "repo_name": "biojava-master/", "id": 1378, "method_signature": "String getDbAccession()"}, "1580": {"callee_method_names": [], "method_name": "DSSPParser.parseString", "method_implementation": "{\n    Reader read = new StringReader(dsspOut);\n    BufferedReader reader = new BufferedReader(read);\n    return generalParse(reader, structure, assign);\n}", "repo_id": "9", "comment": "/**\n * Parse a DSSP format String and return the secondary structure\n * annotation as a List of {@link SecStrucState} objects.\n *\n * @param dsspOut String with the DSSP output to parse\n * @param structure Structure object associated to the dssp\n * @param assign assigns the SS to the structure if true\n * @return a List of SS annotation objects\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1580, "method_signature": "List<SecStrucState> parseString(String, Structure, boolean)"}, "2608": {"callee_method_names": [], "method_name": "ConcurrencyTools.setThreadPoolCPUsAvailable", "method_implementation": "{\n    setThreadPoolSize(Math.max(1, Runtime.getRuntime().availableProcessors() - cpus));\n}", "repo_id": "9", "comment": "/**\n * Sets thread pool to reserve a given number of processor cores for foreground or other use.\n *\n * @param cpus number of processor cores to reserve\n */\n", "repo_name": "biojava-master/", "id": 2608, "method_signature": "void setThreadPoolCPUsAvailable(int)"}, "143": {"callee_method_ids": [497, 497], "callee_method_names": ["SmithWaterman3DParameters.setMaxRmsd", "SmithWaterman3Daligner.align", "AFPChain.getTotalRmsdOpt", "AFPChain.getOptLength", "SmithWaterman3DParameters.setMaxRmsd", "SmithWaterman3Daligner.align", "AFPChain.getTotalRmsdOpt", "AFPChain.getOptLength", "SmithWaterman3DParameters.setMaxRmsd", "SmithWaterman3DParameters.setMinLen", "SmithWaterman3Daligner.align", "AFPChain.getOptLength"], "method_name": "TestSmithWaterman3Daligner.testMaxRMSD", "method_implementation": "{\n    Structure s1 = StructureTools.getStructure(\"1A3N.A\");\n    Structure s2 = StructureTools.getStructure(\"1A3N.B\");\n    Atom[] ca1 = StructureTools.getRepresentativeAtomArray(s1);\n    Atom[] ca2 = StructureTools.getRepresentativeAtomArray(s2);\n    SmithWaterman3Daligner aligner = new SmithWaterman3Daligner();\n    SmithWaterman3DParameters params = new SmithWaterman3DParameters();\n    // Use no restriction on the RMSD\n    params.setMaxRmsd(99.0);\n    AFPChain afpChain = aligner.align(ca1, ca2, params);\n    assertEquals(\"RMSD is wrong\", 1.39, afpChain.getTotalRmsdOpt(), 0.005);\n    assertEquals(\"Length is wrong\", 137, afpChain.getOptLength());\n    // Restrict it to 1A RMSD (18 columns have to be dropped)\n    params.setMaxRmsd(1.0);\n    afpChain = aligner.align(ca1, ca2, params);\n    assertTrue(\"RMSD is above the threshold\", afpChain.getTotalRmsdOpt() < 1.0);\n    assertEquals(\"Length is wrong\", 119, afpChain.getOptLength());\n    // Restrict it to 0A RMSD (the minimum length is relevant )\n    params.setMaxRmsd(0.0);\n    params.setMinLen(30);\n    afpChain = aligner.align(ca1, ca2, params);\n    assertEquals(\"Length shoild be the minimum possible\", 30, afpChain.getOptLength());\n}", "repo_id": "9", "comment": "/**\n * Test the changes in the alignment by the max RMSD parameter. Use the\n * chain A and B of hemoglobin, because they have very similar sequences,\n * but some columns of the alignment have to be removed for a better\n * superposition (lower RMSD).\n */\n", "repo_name": "biojava-master/", "id": 143, "method_signature": "void testMaxRMSD()"}, "3142": {"callee_method_names": ["File.exists", "File.mkdirs"], "method_name": "UniprotProxySequenceReader.setUniprotDirectoryCache", "method_implementation": "{\n    File f = new File(aUniprotDirectoryCache);\n    if (!f.exists()) {\n        f.mkdirs();\n    }\n    uniprotDirectoryCache = aUniprotDirectoryCache;\n}", "repo_id": "9", "comment": "/**\n * @param aUniprotDirectoryCache the uniprotDirectoryCache to set\n */\n", "repo_name": "biojava-master/", "id": 3142, "method_signature": "void setUniprotDirectoryCache(String)"}, "3147": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.setCompoundSet", "method_implementation": "{\n    this.compoundSet = compoundSet;\n}", "repo_id": "9", "comment": "/**\n * @param compoundSet\n */\n", "repo_name": "biojava-master/", "id": 3147, "method_signature": "void setCompoundSet(CompoundSet)"}, "2370": {"callee_method_names": [], "method_name": "Fastq.getDescription", "method_implementation": "{\n    return description;\n}", "repo_id": "9", "comment": "/**\n * Return the description of this FASTQ formatted sequence.\n * The description will not be null.\n *\n * @return the description of this FASTQ formatted sequence\n */\n", "repo_name": "biojava-master/", "id": 2370, "method_signature": "String getDescription()"}, "30": {"callee_method_names": [], "method_name": "StockholmStructure.getBioSequences", "method_implementation": "{\n    return getBioSequences(ignoreCase, null);\n}", "repo_id": "9", "comment": "/**\n * Because some database files have incorrectly small letters (e.g. Pfam23 structure PF00389.22 sequence\n * TKRA_BACSU/6-322), this function is used to ignore the small letters case.\n *\n * @param ignoreCase\n * @return\n * @see #getBioSequences()\n * @see #getBioSequences(boolean, String)\n */\n", "repo_name": "biojava-master/", "id": 30, "method_signature": "List<AbstractSequence<? extends AbstractCompound>> getBioSequences(boolean)"}, "1619": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setAbsoluteMinimumSequenceLength", "method_implementation": "{\n    this.absoluteMinimumSequenceLength = absoluteMinimumSequenceLength;\n}", "repo_id": "9", "comment": "/**\n * If the shortest subunit sequence length is higher or equal the\n * minimumSequenceLengthFraction times the median subunit sequence length,\n * then the minimumSequenceLength is set to shortest subunit sequence\n * length, but not shorter than the absoluteMinimumSequenceLength.\n * <p>\n * This adaptive feature allows the consideration of structures mainly\n * constructed by very short chains, such as collagen (1A3I)\n *\n * @param absoluteMinimumSequenceLength\n */\n", "repo_name": "biojava-master/", "id": 1619, "method_signature": "void setAbsoluteMinimumSequenceLength(int)"}, "539": {"callee_method_ids": [487, 490, 489, 498], "callee_method_names": ["AFPChain.getBlockNum", "AFPChain.getFocusRes1", "AFPChain.getFocusRes2", "AFPChain.getCa1Length", "AFPChain.setFocusRes1", "AFPChain.getCa2Length", "AFPChain.setFocusRes2", "AFPChain.getOptLen", "AFPChain.getOptAln", "Logger.debug", "Logger.debug", "AFPChain.getOptLength", "Logger.warn", "Logger.debug", "AFPChain.setTotalLenOpt", "AFPChain.setTotalRmsdOpt"], "method_name": "AFPTwister.twistOptimized", "method_implementation": "{\n    Atom[] optTwistPdb = new Atom[ca2.length];\n    int gPos = -1;\n    for (Atom a : ca2) {\n        gPos++;\n        optTwistPdb[gPos] = a;\n    }\n    int blockNum = afpChain.getBlockNum();\n    int b2 = 0;\n    int e2 = 0;\n    int focusResn = 0;\n    int[] focusRes1 = afpChain.getFocusRes1();\n    int[] focusRes2 = afpChain.getFocusRes2();\n    if (focusRes1 == null) {\n        focusRes1 = new int[afpChain.getCa1Length()];\n        afpChain.setFocusRes1(focusRes1);\n    }\n    if (focusRes2 == null) {\n        focusRes2 = new int[afpChain.getCa2Length()];\n        afpChain.setFocusRes2(focusRes2);\n    }\n    int[] optLen = afpChain.getOptLen();\n    int[][][] optAln = afpChain.getOptAln();\n    for (int bk = 0; bk < blockNum; bk++) {\n        // THIS IS TRANSFORMING THE ORIGINAL ca2 COORDINATES, NO CLONING...\n        // copies the atoms over to iniTwistPdb later on in modifyCod\n        transformOrigPDB(optLen[bk], optAln[bk][0], optAln[bk][1], ca1, ca2, afpChain, bk);\n        // transform pro2 according to comparison of pro1 and pro2 at give\n        // residues\n        if (bk > 0) {\n            b2 = e2;\n        }\n        if (bk < blockNum - 1) {\n            // bend at the middle of two consecutive\n            // blocks\n            e2 = optAln[bk][1][optLen[bk] - 1];\n            e2 = (optAln[bk + 1][1][0] - e2) / 2 + e2;\n        } else {\n            e2 = ca2.length;\n        }\n        cloneAtomRange(optTwistPdb, ca2, b2, e2);\n        for (int i = 0; i < optLen[bk]; i++) {\n            focusRes1[focusResn] = optAln[bk][0][i];\n            focusRes2[focusResn] = optAln[bk][1][i];\n            focusResn++;\n        }\n    }\n    int totalLenOpt = focusResn;\n    logger.debug(\"calrmsdopt for {} residues\", focusResn);\n    double totalRmsdOpt = calCaRmsd(ca1, optTwistPdb, focusResn, focusRes1, focusRes2);\n    logger.debug(\"got opt RMSD: {}\", totalRmsdOpt);\n    int optLength = afpChain.getOptLength();\n    if (totalLenOpt != optLength) {\n        logger.warn(\"Final alignment length is different {} {}\", totalLenOpt, optLength);\n    }\n    logger.debug(\"final alignment length {}, rmsd {}\", focusResn, totalRmsdOpt);\n    afpChain.setTotalLenOpt(totalLenOpt);\n    afpChain.setTotalRmsdOpt(totalRmsdOpt);\n    return StructureTools.cloneGroups(optTwistPdb);\n}", "repo_id": "9", "comment": "/**\n * superimposing according to the optimized alignment\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @return Group array twisted.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 539, "method_signature": "Group[] twistOptimized(AFPChain, Atom[], Atom[])"}, "1658": {"callee_method_ids": [1673, 1673, 1675, 1675], "callee_method_names": ["SubunitCluster.get", "Subunit.getName", "Subunit.getName", "Subunit.getStructure", "Subunit.getStructure", "Logger.info", "Structure.getChain", "Structure.getChain", "Logger.info", "Chain.getEntityInfo", "Chain.getEntityInfo", "Logger.info", "Chain.getEntityInfo", "Chain.getEntityInfo"], "method_name": "SubunitCluster.isIdenticalByEntityIdTo", "method_implementation": "{\n    Subunit thisSub = this.subunits.get(this.representative);\n    Subunit otherSub = other.subunits.get(other.representative);\n    String thisName = thisSub.getName();\n    String otherName = otherSub.getName();\n    Structure thisStruct = thisSub.getStructure();\n    Structure otherStruct = otherSub.getStructure();\n    if (thisStruct == null || otherStruct == null) {\n        logger.info(\"SubunitClusters {}-{} have no referenced structures. Ignoring identity check by entity id\", thisName, otherName);\n        return false;\n    }\n    if (thisStruct != otherStruct) {\n        // different object references: will not cluster even if entity id is same\n        return false;\n    }\n    Chain thisChain = thisStruct.getChain(thisName);\n    Chain otherChain = otherStruct.getChain(otherName);\n    if (thisChain == null || otherChain == null) {\n        logger.info(\"Can't determine entity ids of SubunitClusters {}-{}. Ignoring identity check by entity id\", thisName, otherName);\n        return false;\n    }\n    if (thisChain.getEntityInfo() == null || otherChain.getEntityInfo() == null) {\n        logger.info(\"Can't determine entity ids of SubunitClusters {}-{}. Ignoring identity check by entity id\", thisName, otherName);\n        return false;\n    }\n    int thisEntityId = thisChain.getEntityInfo().getMolId();\n    int otherEntityId = otherChain.getEntityInfo().getMolId();\n    return thisEntityId == otherEntityId;\n}", "repo_id": "9", "comment": "/**\n * Tells whether the other SubunitCluster contains exactly the same Subunit.\n * This is checked by equality of their entity identifiers if they are present.\n *\n * @param other\n *            SubunitCluster\n * @return true if the SubunitClusters are identical, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 1658, "method_signature": "boolean isIdenticalByEntityIdTo(SubunitCluster)"}, "3298": {"callee_method_names": ["Point.setLocation"], "method_name": "AFPChainCoordManager.getPanelPos", "method_implementation": "{\n    Point p = new Point();\n    // get line\n    // we do integer division since we ignore remainders\n    int lineNr = i / DEFAULT_LINE_LENGTH;\n    // but we want to have the reminder for the line position.\n    int linePos = i % DEFAULT_LINE_LENGTH;\n    int x = linePos * DEFAULT_CHAR_SIZE + DEFAULT_X_SPACE + DEFAULT_LEGEND_SIZE;\n    int y = lineNr * DEFAULT_Y_STEP + DEFAULT_Y_SPACE;\n    y += DEFAULT_LINE_SEPARATION * aligSeq;\n    p.setLocation(x, y);\n    return p;\n}", "repo_id": "9", "comment": "/**\n * get the position of the sequence position on the Panel\n *\n * @param aligSeq  0 or 1 for which of the two sequences to ask for.\n * @param i sequence position\n * @return the point on a panel for a sequence position\n */\n", "repo_name": "biojava-master/", "id": 3298, "method_signature": "Point getPanelPos(int, int)"}, "626": {"callee_method_names": [], "method_name": "AtomCache.getPath", "method_implementation": "{\n    return path;\n}", "repo_id": "9", "comment": "/**\n * Get the path that is used to cache PDB files.\n *\n * @return path to a directory\n */\n", "repo_name": "biojava-master/", "id": 626, "method_signature": "String getPath()"}, "3755": {"callee_method_names": ["LinkedHashMap.keySet", "ArrayList<String>.add"], "method_name": "WorkSheet.getAllRows", "method_implementation": "{\n    ArrayList<String> rows = new ArrayList<String>();\n    for (String row : rowLookup.keySet()) {\n        rows.add(row);\n    }\n    return rows;\n}", "repo_id": "9", "comment": "/**\n * Get all rows including those that may be hidden\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3755, "method_signature": "ArrayList<String> getAllRows()"}, "3088": {"callee_method_names": [], "method_name": "AbstractFeature.getDescription", "method_implementation": "{\n    return description;\n}", "repo_id": "9", "comment": "/**\n * @return the description\n */\n", "repo_name": "biojava-master/", "id": 3088, "method_signature": "String getDescription()"}, "2778": {"callee_method_names": ["List<String>.size", "List<List<String>>.get", "List<String>.get", "List<String>.get", "CompoundSet<AminoAcidCompound>.getCompoundForString", "List<String>.get", "ArrayList.add"], "method_name": "IUPACParser.getCodons", "method_implementation": "{\n    if (this.codons.isEmpty()) {\n        List<String> aminoAcidStrings = aminoAcids();\n        List<String> startCodonStrings = startCodons();\n        List<List<String>> codonStrings = codonStrings();\n        for (int i = 0; i < aminoAcidStrings.size(); i++) {\n            List<String> codonString = codonStrings.get(i);\n            NucleotideCompound one = getCompound(codonString, 0, nucelotides);\n            NucleotideCompound two = getCompound(codonString, 1, nucelotides);\n            NucleotideCompound three = getCompound(codonString, 2, nucelotides);\n            boolean start = (\"M\".equals(startCodonStrings.get(i)));\n            boolean stop = (\"*\".equals(aminoAcidStrings.get(i)));\n            AminoAcidCompound aminoAcid = aminoAcids.getCompoundForString(aminoAcidStrings.get(i));\n            codons.add(new Codon(new CaseInsensitiveTriplet(one, two, three), aminoAcid, start, stop));\n        }\n    }\n    return codons;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of codons where the source and target compounds\n * are the same as those given by the parameters.\n *\n * @param nucleotides The nucleotide set to use when building BioJava\n * representations of codons\n * @param aminoAcids The target amino acid compounds objects\n */\n", "repo_name": "biojava-master/", "id": 2778, "method_signature": "List<Codon> getCodons(CompoundSet, CompoundSet)"}, "1588": {"callee_method_names": ["Structure.nrModels", "SpaceGroup.getProperty", "List<SecStrucState>.add", "SpaceGroup.getOriginal"], "method_name": "SecStrucCalc.calculate", "method_implementation": "{\n    List<SecStrucState> secstruc = new ArrayList<SecStrucState>();\n    for (int i = 0; i < s.nrModels(); i++) {\n        // Reinitialise the global vars\n        ladders = new ArrayList<Ladder>();\n        bridges = new ArrayList<BetaBridge>();\n        groups = initGroupArray(s, i);\n        // Initialise the contact set for this structure\n        initContactSet();\n        if (groups.length < 5) {\n            // not enough groups to do anything\n            throw new StructureException(\"Not enough backbone groups in the\" + \" Structure to calculate the secondary structure (\" + groups.length + \" given, minimum 5)\");\n        }\n        calculateHAtoms();\n        calculateHBonds();\n        calculateDihedralAngles();\n        calculateTurns();\n        buildHelices();\n        detectBends();\n        detectStrands();\n        for (SecStrucGroup sg : groups) {\n            SecStrucState ss = (SecStrucState) sg.getProperty(Group.SEC_STRUC);\n            // Add to return list and assign to original if flag is true\n            secstruc.add(ss);\n            if (assign)\n                sg.getOriginal().setProperty(Group.SEC_STRUC, ss);\n        }\n    }\n    return secstruc;\n}", "repo_id": "9", "comment": "/**\n * Predicts the secondary structure of this Structure object,\n * using a DSSP implementation.\n *\n * @param s Structure to predict the SS\n * @param assign sets the SS information to the Groups of s\n * @return a List of SS annotation objects\n */\n", "repo_name": "biojava-master/", "id": 1588, "method_signature": "List<SecStrucState> calculate(Structure, boolean)"}, "3011": {"callee_method_names": [], "method_name": "BitArrayWorker.getCompoundsToIndexLookup", "method_implementation": "{\n    if (compoundsToIndexLookup == null) {\n        compoundsToIndexLookup = generateCompoundsToIndex();\n    }\n    return compoundsToIndexLookup;\n}", "repo_id": "9", "comment": "/**\n * Returns a map which converts from compound to an integer representation\n */\n", "repo_name": "biojava-master/", "id": 3011, "method_signature": "Map<C,Integer> getCompoundsToIndexLookup()"}, "498": {"callee_method_names": [], "method_name": "AFPChain.setTotalRmsdOpt", "method_implementation": "{\n    this.totalRmsdOpt = totalRmsdOpt;\n}", "repo_id": "9", "comment": "/**\n * The RMSD of the final alignment. Use this to print overal alignment RMSD.\n *\n * @param totalRmsdOpt : total RMSD of the optimal alignment\n */\n", "repo_name": "biojava-master/", "id": 498, "method_signature": "void setTotalRmsdOpt(double)"}, "1206": {"callee_method_names": [], "method_name": "CifStructureConverter.fromInputStream", "method_implementation": "{\n    return fromCifFile(CifIO.readFromInputStream(inputStream), parameters);\n}", "repo_id": "9", "comment": "/**\n * Convert InputStream to Structure.\n * @param inputStream the InputStream of information - can be gzipped or binary or text data\n * @param parameters parameters for parsing\n * @return the target\n * @throws IOException thrown when reading fails\n */\n", "repo_name": "biojava-master/", "id": 1206, "method_signature": "Structure fromInputStream(InputStream, FileParsingParameters)"}, "792": {"callee_method_names": ["Class<?>.newInstance", "Class<?>.getMethod", "Method.invoke"], "method_name": "GuiWrapper.showStructure", "method_implementation": "{\n    Class<?> structureAlignmentJmol = Class.forName(strucAligJmol);\n    Object strucAligJ = structureAlignmentJmol.newInstance();\n    Method setS = structureAlignmentJmol.getMethod(\"setStructure\", new Class[] { Structure.class });\n    setS.invoke(strucAligJ, structure);\n}", "repo_id": "9", "comment": "/**\n * Shows a structure in Jmol\n * @since 3.0.5\n */\n", "repo_name": "biojava-master/", "id": 792, "method_signature": "void showStructure(Structure)"}, "2469": {"callee_method_ids": [2408, 2408, 2407], "callee_method_names": ["Location.suffix", "Location.suffix", "Location.prefix", "int.toString"], "method_name": "LocIterator.next", "method_implementation": "{\n    if (windowSize <= 0) {\n        throw new IllegalArgumentException(\"Window size must be positive.\");\n    }\n    if (increment == 0) {\n        throw new IllegalArgumentException(\"Increment must be non-zero.\");\n    }\n    Location r;\n    try {\n        if (increment > 0) {\n            r = mBounds.suffix(mPosition).prefix(windowSize);\n        } else {\n            if (mPosition == 0) {\n                r = mBounds.suffix(-windowSize);\n            } else {\n                r = mBounds.prefix(mPosition).suffix(-windowSize);\n            }\n        }\n        mPosition += increment;\n    } catch (Exception e) {\n        throw new IndexOutOfBoundsException(e.toString());\n    }\n    return r;\n}", "repo_id": "9", "comment": "/**\n * Get next window of specified size, then increment position by specified amount.\n *\n * @return Location of next window.\n * @param windowSize Size of window to get.\n * @param increment Amount by which to shift position. If increment is positive, the position is shifted\n * toward the end of the bounding location; if increment is negative, the position is shifted toward\n * the beginning of the bounding location.\n * @throws IndexOutOfBoundsException The next window was not within the bounding location.\n * @throws IllegalArgumentException The increment was zero, or windowSize was not positive.\n */\n", "repo_name": "biojava-master/", "id": 2469, "method_signature": "Location next(int, int)"}, "2143": {"callee_method_names": ["Class<?>.getName"], "method_name": "StructureImpl.hasPdbChain", "method_implementation": "{\n    int modelnr = 0;\n    List<Chain> chains = getChains(modelnr);\n    for (Chain c : chains) {\n        // we check here with equals because we might want to distinguish between upper and lower case chains!\n        if (c.getName().equals(authId)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2143, "method_signature": "boolean hasPdbChain(String)"}, "1477": {"callee_method_names": ["Matrix4d.getRotationScale", "Matrix3d.determinant"], "method_name": "CrystalCell.checkScaleMatrixConsistency", "method_implementation": "{\n    double vol = getVolume();\n    Matrix3d m = new Matrix3d();\n    scaleMatrix.getRotationScale(m);\n    // note we need to have a relaxed tolerance here as the PDB scale matrix is given with not such high precision\n    // plus we don't want to have false positives, so we stay conservative\n    double tolerance = vol / 100.0;\n    if ((Math.abs(vol - 1.0 / m.determinant()) > tolerance)) {\n        //System.err.println(\"Warning! SCALE matrix from PDB does not match 1/determinat == cell volume: \"+\n        //\t\tString.format(\"vol=%6.3f  1/det=%6.3f\",vol,1.0/m.determinant()));\n        return false;\n    }\n    // this would be to check our own matrix, must always match!\n    //if (!deltaComp(vol,1.0/getMTranspose().determinant())) {\n    //\tSystem.err.println(\"Our calculated SCALE matrix does not match 1/det=cell volume\");\n    //}\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Given a scale matrix parsed from the PDB entry (SCALE1,2,3 records),\n * checks that the matrix is a consistent scale matrix by comparing the\n * cell volume to the inverse of the scale matrix determinant (tolerance of 1/100).\n * If they don't match false is returned.\n * See the PDB documentation for the SCALE record.\n * See also last equation of section 2.5 of \"Fundamentals of Crystallography\" C. Giacovazzo\n * @param scaleMatrix\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1477, "method_signature": "boolean checkScaleMatrixConsistency(Matrix4d)"}, "3109": {"callee_method_names": [], "method_name": "DBReferenceInfo.setId", "method_implementation": "{\n    this.id = id;\n}", "repo_id": "9", "comment": "/**\n * @param id the id to set\n */\n", "repo_name": "biojava-master/", "id": 3109, "method_signature": "void setId(String)"}, "3537": {"callee_method_names": [], "method_name": "CoxCoefficient.getHazardRatioHiCI", "method_implementation": "{\n    return hazardRatioHiCI;\n}", "repo_id": "9", "comment": "/**\n * @return the hazardRatioHiCI\n */\n", "repo_name": "biojava-master/", "id": 3537, "method_signature": "double getHazardRatioHiCI()"}, "760": {"callee_method_names": [], "method_name": "CeParameters.getSubstitutionMatrix", "method_implementation": "{\n    if (substitutionMatrix == null) {\n        substitutionMatrix = SubstitutionMatrixHelper.getMatrixFromAAINDEX(DEFAULT_SUBSTITUTION_MATRIX);\n    }\n    return substitutionMatrix;\n}", "repo_id": "9", "comment": "/**\n * Sets the  substitution matrix to be used for influencing the alignment with sequence conservation information.\n * Default: SDM matrix (Prlic et al 2000)\n * @return substitutionMatrix\n */\n", "repo_name": "biojava-master/", "id": 760, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getSubstitutionMatrix()"}, "2792": {"callee_method_names": [], "method_name": "GenbankWriter.getLineLength", "method_implementation": "{\n    return lineLength;\n}", "repo_id": "9", "comment": "/**\n * @return the lineLength\n */\n", "repo_name": "biojava-master/", "id": 2792, "method_signature": "int getLineLength()"}, "2089": {"callee_method_names": [], "method_name": "SymmetryAxes.setLevel", "method_implementation": "{\n    if (level < 0)\n        throw new IndexOutOfBoundsException(\"Level must be positive\");\n    this.level = level;\n}", "repo_id": "9", "comment": "/**\n * @param level The level of this axis within it's parent hierarchy. Must be positive\n */\n", "repo_name": "biojava-master/", "id": 2089, "method_signature": "void setLevel(int)"}, "2828": {"callee_method_names": ["ProteinSequence.getUserCollection", "Collection<Object>.size"], "method_name": "CasePreservingProteinSequenceCreator.setLowercaseToNull", "method_implementation": "{\n    // should have been set by seq creator\n    Collection<Object> userCollection = seq.getUserCollection();\n    if (userCollection == null)\n        throw new IllegalArgumentException(\"Sequence doesn't contain valid case info\");\n    if (userCollection.size() != out.length)\n        throw new IllegalArgumentException(\"Sequence length doesn't math output array length\");\n    int pos = 0;\n    for (Object isAligned : userCollection) {\n        assert (isAligned instanceof Boolean);\n        if (!(Boolean) isAligned) {\n            out[pos] = null;\n        }\n        pos++;\n    }\n}", "repo_id": "9", "comment": "/**\n * Takes a {@link ProteinSequence} which was created by a\n * {@link CasePreservingProteinSequenceCreator}. Uses the case info\n * stored in the user collection to modify the output array.\n *\n * <p>Sets elements of the output array which correspond to lowercase letters\n * to null.\n *\n * @param seq Input sequence with case stored as the user collection\n * @param out\n */\n", "repo_name": "biojava-master/", "id": 2828, "method_signature": "void setLowercaseToNull(ProteinSequence, Object[])"}, "155": {"callee_method_ids": [641], "callee_method_names": ["AtomCache.setFiletype", "List<Structure>.size", "List<Structure>.size", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get"], "method_name": "TestBioassemblies.test4TTX", "method_implementation": "{\n    AtomCache prevAtomCache = StructureIO.getAtomCache();\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    StructureIO.setAtomCache(cache);\n    List<Structure> multiModelBioAssemblies = StructureIO.getBiologicalAssemblies(\"4TTX\", true);\n    List<Structure> flattenedBioAssemblies = StructureIO.getBiologicalAssemblies(\"4TTX\", false);\n    // 3 bioassemblies in this case\n    assertEquals(3, multiModelBioAssemblies.size());\n    assertEquals(3, flattenedBioAssemblies.size());\n    // checking that we have 1 model only\n    assertEquals(1, multiModelBioAssemblies.get(0).nrModels());\n    assertEquals(1, flattenedBioAssemblies.get(0).nrModels());\n    // the 3 bioassemblies are dimers\n    assertEquals(2, multiModelBioAssemblies.get(0).getPolyChains().size());\n    assertEquals(2, flattenedBioAssemblies.get(0).getPolyChains().size());\n    assertEquals(2, multiModelBioAssemblies.get(1).getPolyChains().size());\n    assertEquals(2, flattenedBioAssemblies.get(1).getPolyChains().size());\n    assertEquals(2, multiModelBioAssemblies.get(2).getPolyChains().size());\n    assertEquals(2, flattenedBioAssemblies.get(2).getPolyChains().size());\n    // all 3 flattened bioassemblies have operator id 1 in their new chain ids\n    assertEquals(\"1\", flattenedBioAssemblies.get(0).getPolyChains().get(0).getId().split(\"_\")[1]);\n    assertEquals(\"1\", flattenedBioAssemblies.get(1).getPolyChains().get(0).getId().split(\"_\")[1]);\n    assertEquals(\"1\", flattenedBioAssemblies.get(2).getPolyChains().get(0).getId().split(\"_\")[1]);\n    StructureIO.setAtomCache(prevAtomCache);\n}", "repo_id": "9", "comment": "/**\n * A test for an entry with a biounit that is a subset of the AU\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 155, "method_signature": "void test4TTX()"}, "1954": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getTmIntra", "method_implementation": "{\n    return tmIntra;\n}", "repo_id": "9", "comment": "/**\n * @return the tmIntra\n */\n", "repo_name": "biojava-master/", "id": 1954, "method_signature": "double getTmIntra()"}, "412": {"callee_method_ids": [484, 432], "callee_method_names": ["AFPChain.getAfpSet", "AFPChain.setConn", "AFPChain.setDVar", "List<AFP>.size", "AFPChain.getTwi", "AFPChain.setTwi", "AFPChain.setConn", "AFPChain.setDVar", "FatCatParameters.getMaxGap", "FatCatParameters.getFragLen", "FatCatParameters.getMaxTra", "AFPChain.setDisTable1", "AFPChain.setDisTable2", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "AFPChain.getConn", "List<AFP>.get", "AFPChain.setAlignScore", "AFPChain.setAlignScoreUpdate", "AFPChain.setAfpChainTwiNum"], "method_name": "AFPChainer.doChainAfp", "method_implementation": "{\n    List<AFP> afpSet = afpChain.getAfpSet();\n    afpChain.setConn(0d);\n    afpChain.setDVar(0d);\n    int afpNum = afpSet.size();\n    if (afpNum <= 0)\n        return;\n    int[] twi = afpChain.getTwi();\n    if (twi == null) {\n        twi = new int[afpNum];\n        afpChain.setTwi(twi);\n    }\n    //transformation, calculated at DoChainAfp, be used in List extraction\n    //forward: calculate the score matrix\n    boolean isConnected = false;\n    int i, j, j0, n;\n    double stmp;\n    afpChain.setConn(0d);\n    afpChain.setDVar(0d);\n    //the score ending at an AFP\n    double[] sco = new double[afpNum];\n    //the previous AFP\n    int[] pre = new int[afpNum];\n    double maxsco = 0;\n    int maxafp = 0;\n    int[] list = new int[afpNum];\n    int maxGap = params.getMaxGap();\n    int fragLen = params.getFragLen();\n    int maxTra = params.getMaxTra();\n    Matrix disTable1 = getDisTable(maxGap + 2 * fragLen + 1, ca1);\n    Matrix disTable2 = getDisTable(maxGap + 2 * fragLen + 1, ca2);\n    afpChain.setDisTable1(disTable1);\n    afpChain.setDisTable2(disTable2);\n    for (i = 0; i < afpNum; i++) {\n        //start from itself\n        sco[i] = afpSet.get(i).getScore();\n        pre[i] = -1;\n        twi[i] = 0;\n        if (afpSet.get(i).getP1() < fragLen || afpSet.get(i).getP2() < fragLen)\n            n = 0;\n        else\n            //get a compatible list\n            n = getCompatibleAfps(i, list, params, afpChain);\n        //printf(\"afp %d, compatible %d\\n\", i, n);\n        for (j0 = 0; j0 < n; j0++) {\n            j = list[j0];\n            //note: j, i\n            isConnected = afpPairConn(j, i, params, afpChain);\n            Double conn = afpChain.getConn();\n            int t = 0;\n            if (isConnected)\n                t = 1;\n            if (twi[j] + t > maxTra)\n                continue;\n            //two many transformation are disfavored\n            stmp = sco[j] + afpSet.get(i).getScore() + conn;\n            if (stmp > sco[i]) {\n                //considered all previous compatible AFPs\n                sco[i] = stmp;\n                twi[i] = twi[j] + t;\n                pre[i] = j;\n            }\n        }\n        if (maxsco < sco[i]) {\n            maxsco = sco[i];\n            maxafp = i;\n        }\n    }\n    int currafp = maxafp;\n    if (debug)\n        System.out.printf(\"maximum score %f, %d%n%n\", maxsco, twi[currafp]);\n    //trace-back from maxafp (maxsco)\n    afpChain.setAlignScore(maxsco);\n    afpChain.setAlignScoreUpdate(maxsco);\n    afpChain.setAfpChainTwiNum(0);\n    traceBack(pre, currafp, twi[currafp], params, afpChain, ca1, ca2);\n}", "repo_id": "9", "comment": "/**\n * \t// Key function: chain (assembly) the AFPs\n * \t// a AFP (k) is defined as (i, j, k), with i and j are staring points\n * \t// AFP extension (eg. AFP(k-1) -> AFP(k) ) requiring\n * \t// AFP(k-1) < AFP(k)(refer AFP.h definition),\n * \t// ie i(k-1) < i(k) and j(k-1) < j(k)\n * \t// in the figure, only (2) AFP can extend to AFP(k)\n * \t// Key features: a coordination transformation is allowed in the AFP extension\n * \t//                      gap penalties are also considered\n * \t//\n * \t//                                   protein1\n * \t//                 ---------------------------\n * \t//                 |        \\                |\n * \t//                 |         \\(1)            |\n * \t//                 |     \\    \\              |\n * \t//                 |      \\(2) \\             |\n * \t//              p  |       \\                 |\n * \t//              r  |   \\                     |\n * \t//              o  |    \\(3)  \\(i,j, k)      |\n * \t//              t  |     \\     \\             |\n * \t//              e  |            \\            |\n * \t//              i  |                         |\n * \t//              n  |                         |\n * \t//              2  ---------------------------\n * \t//                  schematic of AFP chaining\n */\n", "repo_name": "biojava-master/", "id": 412, "method_signature": "void doChainAfp(FatCatParameters, AFPChain, Atom[], Atom[])"}, "688": {"callee_method_ids": [620], "callee_method_names": ["AtomCache.getRepresentativeAtoms", "List<Atom[]>.add"], "method_name": "MultipleAlignmentEnsembleImpl.updateAtomArrays", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    atomArrays = new ArrayList<Atom[]>();\n    for (StructureIdentifier name : getStructureIdentifiers()) {\n        Atom[] array = cache.getRepresentativeAtoms(name);\n        atomArrays.add(array);\n    }\n}", "repo_id": "9", "comment": "/**\n * Force the atom arrays to regenerate based on\n * {@link #getStructureIdentifiers()}.\n *\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 688, "method_signature": "void updateAtomArrays()"}, "1273": {"callee_method_names": [], "method_name": "MmtfActions.writeToFile", "method_implementation": "{\n    // Set up this writer\n    AdapterToStructureData writerToEncoder = new AdapterToStructureData();\n    // Get the writer - this is what people implement\n    new MmtfStructureWriter(structure, writerToEncoder);\n    // Now write this data to file\n    WriterUtils.writeDataToFile(writerToEncoder, path);\n}", "repo_id": "9", "comment": "/**\n * Write a Structure object to a file.\n * @param structure the Structure to write\n * @param path the file to write\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1273, "method_signature": "void writeToFile(Structure, Path)"}, "2141": {"callee_method_names": ["Class<?>.getId"], "method_name": "StructureImpl.hasChain", "method_implementation": "{\n    int modelnr = 0;\n    List<Chain> chains = getChains(modelnr);\n    for (Chain c : chains) {\n        // we check here with equals because we might want to distinguish between upper and lower case chains!\n        if (c.getId().equals(authId)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2141, "method_signature": "boolean hasChain(String)"}, "3835": {"callee_method_names": [], "method_name": "AminoAcidCompositionTable.getMolecularWeight", "method_implementation": "{\n    if (this.aaSymbol2MolecularWeight == null) {\n        throw new NullPointerException(\"Please call AminoAcidCompositionTable.computeMolecularWeight(ElementTable) before this method\");\n    }\n    Double d = this.aaSymbol2MolecularWeight.get(aaSymbol);\n    if (d == null)\n        return 0;\n    else\n        return d;\n}", "repo_id": "9", "comment": "/**\n * @param aaSymbol\n * \tStandard symbol of Amino Acid\n * @return the molecular weight given its symbol\n * @throws NullPointerException\n * \tthrown if AminoAcidCompositionTable.computeMolecularWeight(ElementTable) is not called before this method\n */\n", "repo_name": "biojava-master/", "id": 3835, "method_signature": "double getMolecularWeight(Character)"}, "3101": {"callee_method_names": [], "method_name": "QualityFeature.setQualities", "method_implementation": "{\n    this.qualities = qualities;\n}", "repo_id": "9", "comment": "/**\n * @param qualities the qualities to set\n */\n", "repo_name": "biojava-master/", "id": 3101, "method_signature": "void setQualities(List)"}, "2147": {"callee_method_ids": [1346], "callee_method_names": ["EntityInfo.getMolId"], "method_name": "StructureImpl.getEntityById", "method_implementation": "{\n    for (EntityInfo mol : this.entityInfos) {\n        if (mol.getMolId() == entityId) {\n            return mol;\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2147, "method_signature": "EntityInfo getEntityById(int)"}, "266": {"callee_method_names": ["List<Component>.get"], "method_name": "ModificationLinkage.getComponent1", "method_implementation": "{\n    return components.get(indexOfComponent1);\n}", "repo_id": "9", "comment": "/**\n * @return the first component.\n */\n", "repo_name": "biojava-master/", "id": 266, "method_signature": "Component getComponent1()"}, "2822": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "IOUtils.getPDBLegend", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    s.append(\"</pre></div>\");\n    s.append(\"          <div class=\\\"subText\\\">\");\n    s.append(\"          <b>Legend:</b>\");\n    s.append(\"          <span class=\\\"m\\\">Green</span> - identical residues |\");\n    s.append(\"          <span class=\\\"sm\\\">Pink</span> - similar residues | \");\n    s.append(\"          <span class=\\\"qg\\\">Blue</span> - sequence mismatch |\");\n    s.append(\"          <span class=\\\"dm\\\">Brown</span> - insertion/deletion |\");\n    s.append(\"      </div>\");\n    s.append(String.format(\"%n\"));\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * Creates formatted String for displaying conservation legend in PDB output\n *\n * @return legend String\n */\n", "repo_name": "biojava-master/", "id": 2822, "method_signature": "String getPDBLegend()"}, "2330": {"callee_method_ids": [638, 635, 641, 628, 641, 628], "callee_method_names": ["AtomCache.setFetchBehavior", "AtomCache.setObsoleteBehavior", "AtomCache.setFiletype", "AtomCache.getStructure", "Structure.getPdbId", "AtomCache.setFiletype", "AtomCache.getStructure", "Structure.getPdbId"], "method_name": "TestAtomCache.testFetchCurrent1HHB", "method_implementation": "{\n    cache.setFetchBehavior(FetchBehavior.FETCH_FILES);\n    cache.setObsoleteBehavior(ObsoleteBehavior.FETCH_CURRENT);\n    cache.setFiletype(StructureFiletype.PDB);\n    Structure s = cache.getStructure(\"1HHB\");\n    assertEquals(\"Failed to get the current ID for 1HHB.\", \"4HHB\", s.getPdbId().getId());\n    cache.setFiletype(StructureFiletype.CIF);\n    s = cache.getStructure(\"1HHB\");\n    assertEquals(\"Failed to get the current ID for 1HHB.\", \"4HHB\", s.getPdbId().getId());\n}", "repo_id": "9", "comment": "// 1HHB is obsolete with a replacement\n", "repo_name": "biojava-master/", "id": 2330, "method_signature": "void testFetchCurrent1HHB()"}, "1298": {"callee_method_names": [], "method_name": "EntityFinder.findPolyEntities", "method_implementation": "{\n    TreeMap<String, EntityInfo> chainIds2entities = findEntitiesFromAlignment(polyModels);\n    return findUniqueEntities(chainIds2entities);\n}", "repo_id": "9", "comment": "/**\n * Utility method that employs some heuristics to find the {@link EntityInfo}s\n * for the polymeric chains given in constructor.\n * To be used in case the information is missing in PDB/mmCIF file\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1298, "method_signature": "List<EntityInfo> findPolyEntities(List)"}, "1450": {"callee_method_names": [], "method_name": "SpaceGroup.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * Gets the standard numeric identifier for the space group.\n * See for example http://en.wikipedia.org/wiki/Space_group\n * or the IUCr crystallographic tables\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1450, "method_signature": "int getId()"}, "3078": {"callee_method_names": ["Set<AminoAcidCompound>.add", "HashMap.get", "Set<AminoAcidCompound>.add", "HashMap.get", "Set<AminoAcidCompound>.add", "HashMap.get", "HashMap.put", "Set<AminoAcidCompound>.add", "Set<AminoAcidCompound>.add", "HashMap.put", "Set<AminoAcidCompound>.add", "Set<AminoAcidCompound>.add", "HashMap.put"], "method_name": "AminoAcidCompoundSet.addAmbiguousEquivalents", "method_implementation": "{\n    Set<AminoAcidCompound> equivalents;\n    AminoAcidCompound cOne, cTwo, cEither;\n    equivalents = new HashSet<AminoAcidCompound>();\n    equivalents.add(cOne = aminoAcidCompoundCache.get(one));\n    equivalents.add(cTwo = aminoAcidCompoundCache.get(two));\n    equivalents.add(cEither = aminoAcidCompoundCache.get(either));\n    equivalentsCache.put(cEither, equivalents);\n    equivalents = new HashSet<AminoAcidCompound>();\n    equivalents.add(cOne);\n    equivalents.add(cEither);\n    equivalentsCache.put(cOne, equivalents);\n    equivalents = new HashSet<AminoAcidCompound>();\n    equivalents.add(cTwo);\n    equivalents.add(cEither);\n    equivalentsCache.put(cTwo, equivalents);\n}", "repo_id": "9", "comment": "// helper method to initialize the equivalent sets for 2 amino acid compounds and their ambiguity compound\n", "repo_name": "biojava-master/", "id": 3078, "method_signature": "void addAmbiguousEquivalents(String, String, String)"}, "2949": {"callee_method_names": [], "method_name": "AbstractSequence.countCompounds", "method_implementation": "{\n    return SequenceMixin.countCompounds(this, compounds);\n}", "repo_id": "9", "comment": "/**\n * @param compounds\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2949, "method_signature": "int countCompounds(C[])"}, "1543": {"callee_method_ids": [1556], "callee_method_names": ["Map<Integer, ScopDescription>.keySet", "Map<Integer, ScopDescription>.get", "ScopDescription.getClassificationId", "List<ScopDescription>.add"], "method_name": "ScopInstallation.filterByClassificationId", "method_implementation": "{\n    try {\n        ensureDesInstalled();\n    } catch (IOException e) {\n        throw new ScopIOException(e);\n    }\n    List<ScopDescription> matches = new ArrayList<ScopDescription>();\n    for (Integer i : sunidMap.keySet()) {\n        ScopDescription sc = sunidMap.get(i);\n        if (sc.getClassificationId().startsWith(query)) {\n            matches.add(sc);\n        }\n    }\n    return matches;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#filterByClassificationId(java.lang.String)\n\t */\n", "repo_name": "biojava-master/", "id": 1543, "method_signature": "List<ScopDescription> filterByClassificationId(String)"}, "2334": {"callee_method_names": ["UserConfiguration.getPdbFilePath", "UserConfiguration.getCacheFilePath"], "method_name": "GlobalsHelper.setPdbPath", "method_implementation": "{\n    pushState();\n    if (path == null || cachePath == null) {\n        UserConfiguration config = new UserConfiguration();\n        if (path == null) {\n            path = config.getPdbFilePath();\n        }\n        if (cachePath == null) {\n            cachePath = config.getCacheFilePath();\n        }\n    }\n    System.setProperty(UserConfiguration.PDB_DIR, path);\n    System.setProperty(UserConfiguration.PDB_CACHE_DIR, path);\n    AtomCache cache = new AtomCache(path);\n    StructureIO.setAtomCache(cache);\n    // Note side effect setting the path for all DownloadChemCompProvider due to static state\n    ChemCompProvider provider = new DownloadChemCompProvider(path);\n    ChemCompGroupFactory.setChemCompProvider(provider);\n}", "repo_id": "9", "comment": "/**\n * Sets a new PDB_PATH and PDB_CACHE_PATH consistently.\n *\n * Previous values can be restored with {@link #restoreState()}.\n * @param path\n */\n", "repo_name": "biojava-master/", "id": 2334, "method_signature": "void setPdbPath(String, String)"}, "3029": {"callee_method_names": ["int.getStart", "ResidueNumber.getStart"], "method_name": "Location.getMin", "method_implementation": "{\n    return scanLocations(locations, new LocationPredicate() {\n\n        @Override\n        public boolean accept(Location previous, Location current) {\n            int res = current.getStart().compareTo(previous.getStart());\n            return res < 0;\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Scans through a list of locations to find the Location with the\n * lowest start\n */\n", "repo_name": "biojava-master/", "id": 3029, "method_signature": "Location getMin(List)"}, "3818": {"callee_method_names": [], "method_name": "ExpressionFigure.setFigureLineInfo", "method_implementation": "{\n    this.lineInfoList = lineInfoList;\n    this.repaint();\n}", "repo_id": "9", "comment": "/**\n * @param lineInfoList\n */\n", "repo_name": "biojava-master/", "id": 3818, "method_signature": "void setFigureLineInfo(ArrayList)"}, "716": {"callee_method_names": [], "method_name": "CECalculator.getRMSDForBestTrace", "method_implementation": "{\n    int is = 0;\n    for (int jt = 0; jt < bestTracesN[ir]; jt++) {\n        for (int i = 0; i < winSize; i++) {\n            setStrBuf(strBuf1, is + i, ca1, bestTraces1[ir][jt] + i);\n            setStrBuf(strBuf2, is + i, ca2, bestTraces2[ir][jt] + i);\n        }\n        is += winSize;\n    }\n    //sup_str(strBuf1, strBuf2, bestTracesN[ir]*winSize, d_);\n    double rmsdNew = calc_rmsd(strBuf1, strBuf2, bestTracesN[ir] * winSize, true);\n    return rmsdNew;\n}", "repo_id": "9", "comment": "// TODO:  consider all requested Atoms?\n", "repo_name": "biojava-master/", "id": 716, "method_signature": "double getRMSDForBestTrace(int, Atom[], Atom[], int[], int[][], int[], int, Atom[], Atom[])"}, "247": {"callee_method_names": ["ProteinModification.getId", "Map<String, ProteinModification>.containsKey", "Set<ProteinModification>.add", "Map<String, ProteinModification>.put", "ProteinModification.getCategory", "Map<ModificationCategory, Set<ProteinModification>>.get", "ProteinModification.getOccurrenceType", "Map<ModificationOccurrenceType, Set<ProteinModification>>.get", "ProteinModification.getCondition", "ModificationCondition.getComponents", "Map<Component, Set<ProteinModification>>.get", "Map<Component, Set<ProteinModification>>.put", "Set<ProteinModification>.add", "ProteinModification.getPdbccId", "Map<String, Set<ProteinModification>>.get", "Map<String, Set<ProteinModification>>.put", "Set<ProteinModification>.add", "ProteinModification.getResidId", "Map<String, Set<ProteinModification>>.get", "Map<String, Set<ProteinModification>>.put", "Set<ProteinModification>.add", "ProteinModification.getPsimodId", "Map<String, Set<ProteinModification>>.get", "Map<String, Set<ProteinModification>>.put", "Set<ProteinModification>.add", "ProteinModification.getKeywords", "Map<String, Set<ProteinModification>>.get", "Map<String, Set<ProteinModification>>.put", "Set<ProteinModification>.add"], "method_name": "ProteinModificationRegistry.register", "method_implementation": "{\n    if (modification == null)\n        throw new IllegalArgumentException(\"modification == null!\");\n    lazyInit();\n    String id = modification.getId();\n    if (byId.containsKey(id)) {\n        throw new IllegalArgumentException(id + \" has already been registered.\");\n    }\n    registry.add(modification);\n    byId.put(id, modification);\n    ModificationCategory cat = modification.getCategory();\n    byCategory.get(cat).add(modification);\n    ModificationOccurrenceType occType = modification.getOccurrenceType();\n    byOccurrenceType.get(occType).add(modification);\n    ModificationCondition condition = modification.getCondition();\n    List<Component> comps = condition.getComponents();\n    for (Component comp : comps) {\n        Set<ProteinModification> mods = byComponent.get(comp);\n        if (mods == null) {\n            mods = new HashSet<ProteinModification>();\n            byComponent.put(comp, mods);\n        }\n        mods.add(modification);\n    }\n    String pdbccId = modification.getPdbccId();\n    if (pdbccId != null) {\n        Set<ProteinModification> mods = byPdbccId.get(pdbccId);\n        if (mods == null) {\n            mods = new HashSet<ProteinModification>();\n            byPdbccId.put(pdbccId, mods);\n        }\n        mods.add(modification);\n    }\n    String residId = modification.getResidId();\n    if (residId != null) {\n        Set<ProteinModification> mods = byResidId.get(residId);\n        if (mods == null) {\n            mods = new HashSet<ProteinModification>();\n            byResidId.put(residId, mods);\n        }\n        mods.add(modification);\n    }\n    String psimodId = modification.getPsimodId();\n    if (psimodId != null) {\n        Set<ProteinModification> mods = byPsimodId.get(psimodId);\n        if (mods == null) {\n            mods = new HashSet<ProteinModification>();\n            byPsimodId.put(psimodId, mods);\n        }\n        mods.add(modification);\n    }\n    for (String keyword : modification.getKeywords()) {\n        Set<ProteinModification> mods = byKeyword.get(keyword);\n        if (mods == null) {\n            mods = new HashSet<ProteinModification>();\n            byKeyword.put(keyword, mods);\n        }\n        mods.add(modification);\n    }\n}", "repo_id": "9", "comment": "/**\n * Register a new ProteinModification.\n */\n", "repo_name": "biojava-master/", "id": 247, "method_signature": "void register(ProteinModification)"}, "3775": {"callee_method_names": [], "method_name": "WorkSheet.getRowLookup", "method_implementation": "{\n    return rowLookup;\n}", "repo_id": "9", "comment": "/**\n * @return the rowLookup\n */\n", "repo_name": "biojava-master/", "id": 3775, "method_signature": "LinkedHashMap<String,HeaderInfo> getRowLookup()"}, "3677": {"callee_method_ids": [3673, 3675, 3659, 3657, 3661], "callee_method_names": ["ArrayList<SurvivalInfo>.size", "ArrayList<SurvivalInfo>.size", "ArrayList<SurvivalInfo>.get", "SurvivalInfo.getTime", "SurvivalInfo.getStatus", "SurvivalInfo.getStrata", "SurvivalInfo.getWeight", "SurvivalInfo.getScore"], "method_name": "CoxMart.process", "method_implementation": "{\n    int i, j;\n    int lastone;\n    int n = survivalInfoList.size();\n    double deaths, denom = 0, e_denom = 0;\n    double hazard;\n    double temp, wtsum;\n    double downwt;\n    double[] time = new double[n];\n    double[] status = new double[n];\n    double[] strata = new double[n];\n    double[] wt = new double[n];\n    double[] score = new double[n];\n    double[] expect = new double[survivalInfoList.size()];\n    for (int p = 0; p < n; p++) {\n        SurvivalInfo si = survivalInfoList.get(p);\n        time[p] = si.getTime();\n        status[p] = si.getStatus();\n        if (useStrata) {\n            strata[p] = si.getStrata();\n        } else {\n            strata[p] = 0;\n        }\n        wt[p] = si.getWeight();\n        score[p] = si.getScore();\n    }\n    strata[n - 1] = 1;\n    /*failsafe */\n    /* Pass 1-- store the risk denominator in 'expect' */\n    for (i = n - 1; i >= 0; i--) {\n        // Error because of no bounds checking in C it is an error on the get i - 1\n        //   SurvivalInfo si = survivalInfoList.get(i);\n        if (strata[i] == 1) {\n            //strata[i]\n            denom = 0;\n        }\n        //score[i]*wt[i];\n        denom += score[i] * wt[i];\n        if (//strata[i-1]==1 ||  time[i-1]!=time[i]\n        i == 0 || strata[i - 1] == 1 || time[i - 1] != time[i]) {\n            //   si.setResidual(denom);\n            expect[i] = denom;\n        } else {\n            //   si.setResidual(0); //expect[i] =0;\n            expect[i] = 0;\n        }\n    }\n    /* Pass 2-- now do the work */\n    deaths = 0;\n    wtsum = 0;\n    e_denom = 0;\n    hazard = 0;\n    lastone = 0;\n    for (i = 0; i < n; i++) {\n        //         SurvivalInfo si = survivalInfoList.get(i);\n        //         SurvivalInfo sip1 = null;\n        //         if (i + 1 < n) {\n        //             sip1 = survivalInfoList.get(i + 1);\n        //         }\n        //         if (si.getResidual() != 0) {\n        //             denom = si.getResidual();\n        //         }\n        if (expect[i] != 0)\n            denom = expect[i];\n        //         si.setResidual(status[i]);//expect[i] = status[i];\n        expect[i] = status[i];\n        //status[i];\n        deaths += status[i];\n        // status[i]*wt[i];\n        wtsum += status[i] * wt[i];\n        //score[i]*status[i] *wt[i];\n        e_denom += score[i] * status[i] * wt[i];\n        if (strata[i] == 1 || time[i + 1] != time[i]) {\n            //strata[i]==1 ||  time[i+1]!=time[i]\n            /*last subject of a set of tied times */\n            if (deaths < 2 || method == CoxMethod.Breslow) {\n                //*method==0\n                hazard += wtsum / denom;\n                for (j = lastone; j <= i; j++) {\n                    //     SurvivalInfo sj = survivalInfoList.get(j);\n                    //     double res =  sj.getResidual() - score[j] * hazard;\n                    expect[j] -= score[j] * hazard;\n                    //     sj.setResidual(res); //expect[j] -= score[j]*hazard;\n                }\n            } else {\n                temp = hazard;\n                wtsum /= deaths;\n                for (j = 0; j < deaths; j++) {\n                    downwt = j / deaths;\n                    hazard += wtsum / (denom - e_denom * downwt);\n                    temp += wtsum * (1 - downwt) / (denom - e_denom * downwt);\n                }\n                for (j = lastone; j <= i; j++) {\n                    //   SurvivalInfo sj = survivalInfoList.get(j);\n                    if (status[j] == 0) {\n                        //this appears to be an error for = - versus -=\n                        //   double res = -score[j] * hazard;\n                        expect[j] = -score[j] * hazard;\n                        //   sj.setResidual(res);//expect[j] = -score[j]*hazard; This appears to be an error of -score vs -=\n                    } else {\n                        // double res = sj.getResidual() - score[j] * temp;\n                        expect[j] -= score[j] * temp;\n                        //expect[j] -=  score[j]* temp;\n                    }\n                }\n            }\n            lastone = i + 1;\n            deaths = 0;\n            wtsum = 0;\n            e_denom = 0;\n        }\n        if (strata[i] == 1) {\n            hazard = 0;\n        }\n    }\n    for (j = lastone; j < n; j++) {\n        expect[j] -= score[j] * hazard;\n    }\n    return expect;\n}", "repo_id": "9", "comment": "/**\n * @param method\n * @param survivalInfoList\n * @param useStrata\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3677, "method_signature": "double[] process(CoxMethod, ArrayList, boolean)"}, "710": {"callee_method_names": [], "method_name": "OptimalCECPParameters.setCPPoint", "method_implementation": "{\n    this.cpPoint = cpPoint;\n}", "repo_id": "9", "comment": "/**\n * @param cpPoint the cpPoint to set\n */\n", "repo_name": "biojava-master/", "id": 710, "method_signature": "void setCPPoint(Integer)"}, "1793": {"callee_method_names": [], "method_name": "EcodDomain.getSeqIdRange", "method_implementation": "{\n    return seqIdRange;\n}", "repo_id": "9", "comment": "/**\n * Get the range of this domain, in 1-based residue indices (mmCif's\n * _pdbx_poly_seq_scheme.seq_id)\n *\n * Note that {@link #getRange()} is used when constructing the domain.\n * @return The chain and residue range, e.g. \"A:1-100\"\n */\n", "repo_name": "biojava-master/", "id": 1793, "method_signature": "String getSeqIdRange()"}, "892": {"callee_method_names": ["Pair<EntityInfo>.getFirst", "Pair<EntityInfo>.getFirst", "Pair<EntityInfo>.getSecond", "Pair<EntityInfo>.getSecond", "Pair<EntityInfo>.getFirst", "Pair<EntityInfo>.getSecond", "Pair<EntityInfo>.getSecond", "Pair<EntityInfo>.getFirst"], "method_name": "StructureInterface.checkMolIdMatch", "method_implementation": "{\n    boolean firstMatch = thisCompounds.getFirst().getMolId() == otherCompounds.getFirst().getMolId() && thisCompounds.getSecond().getMolId() == otherCompounds.getSecond().getMolId();\n    boolean secondMatch = thisCompounds.getFirst().getMolId() == otherCompounds.getSecond().getMolId() && thisCompounds.getSecond().getMolId() == otherCompounds.getFirst().getMolId();\n    return firstMatch || secondMatch;\n}", "repo_id": "9", "comment": "/**\n * This method check if two compounds have same MolIds or not.\n * @param thisCompounds\n * @param otherCompounds\n * @return\n */\n", "repo_name": "biojava-master/", "id": 892, "method_signature": "boolean checkMolIdMatch(Pair, Pair)"}, "3077": {"callee_method_names": ["String.length", "String.charAt", "CompoundSet<NucleotideCompound>.getCompoundForString", "StringBuilder.append", "NucleotideCompound.getComplement", "StringBuilder.toString"], "method_name": "CDSSequence.getCodingSequence", "method_implementation": "{\n    String sequence = this.getSequenceAsString(getBioBegin(), getBioEnd(), getStrand());\n    if (getStrand() == Strand.NEGATIVE) {\n        //need to take complement of sequence because it is negative and we are returning a coding sequence\n        StringBuilder b = new StringBuilder(getLength());\n        CompoundSet<NucleotideCompound> compoundSet = this.getCompoundSet();\n        for (int i = 0; i < sequence.length(); i++) {\n            String nucleotide = String.valueOf(sequence.charAt(i));\n            NucleotideCompound nucleotideCompound = compoundSet.getCompoundForString(nucleotide);\n            b.append(nucleotideCompound.getComplement().getShortName());\n        }\n        sequence = b.toString();\n    }\n    //  sequence = sequence.substring(phase);\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * A CDS sequence if negative stranded needs to be reverse complement\n * to represent the actual coding sequence. When getting a ProteinSequence\n * from a TranscriptSequence this method is callled for each CDSSequence\n * {@link http://www.sequenceontology.org/gff3.shtml}\n * {@link http://biowiki.org/~yam/bioe131/GFF.ppt}\n * @return coding sequence\n */\n", "repo_name": "biojava-master/", "id": 3077, "method_signature": "String getCodingSequence()"}, "1733": {"callee_method_names": [], "method_name": "BasePairParameters.getShift", "method_implementation": "{\n    if (bp < 0 || bp >= getStepParameters().length)\n        throw new IllegalArgumentException(\"Base pair number is out of range.\");\n    return stepParameters[bp][3];\n}", "repo_id": "9", "comment": "/**\n * Return the shift for the given base pair, relative to the one before it.\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in \u00c5)\n */\n", "repo_name": "biojava-master/", "id": 1733, "method_signature": "Double getShift(int)"}, "1175": {"callee_method_ids": [1328, 1225], "callee_method_names": ["String.length", "String.startsWith", "String.startsWith", "FileParsingParameters.isParseBioAssembly", "PDBBioAssemblyParser.pdb_REMARK_350_Handler", "String.startsWith", "String.startsWith", "Pattern.matcher", "Matcher.matches", "Matcher.group", "Logger.info", "Matcher.group", "Pattern.matcher", "Matcher.matches", "Matcher.group", "Logger.info", "Matcher.group", "String.startsWith", "String.startsWith"], "method_name": "PDBFileParser.pdb_REMARK_Handler", "method_implementation": "{\n    if (line == null || line.length() < 11)\n        return;\n    if (line.startsWith(\"REMARK 800\")) {\n        pdb_REMARK_800_Handler(line);\n    } else if (line.startsWith(\"REMARK 350\")) {\n        if (params.isParseBioAssembly()) {\n            if (bioAssemblyParser == null) {\n                bioAssemblyParser = new PDBBioAssemblyParser();\n            }\n            bioAssemblyParser.pdb_REMARK_350_Handler(line);\n        }\n    } else if (line.startsWith(\"REMARK   2\")) {\n        //REMARK   2 RESOLUTION.\n        Pattern pR = Pattern.compile(\"^REMARK   2 RESOLUTION.\\\\s+(\\\\d+\\\\.\\\\d+)\\\\s+ANGSTROMS\\\\..*\");\n        handleResolutionLine(line, pR);\n        // REMARK 3 (for R free)\n        // note: if more than 1 value present (occurring in hybrid experimental technique entries, e.g. 3ins, 4n9m)\n        // then last one encountered will be taken\n    } else if (line.startsWith(\"REMARK   3   FREE R VALUE\")) {\n        // Rfree annotation is not very consistent in PDB format, it varies depending on the software\n        // Here we follow this strategy:\n        // a) take the '(NO CUTOFF)' value if the only one available (shelx software, e.g. 1x7q)\n        // b) don't take it if also a line without '(NO CUTOFF)' is present (CNX software, e.g. 3lak)\n        Pattern pR = Pattern.compile(\"^REMARK   3   FREE R VALUE\\\\s+(?:\\\\(NO CUTOFF\\\\))?\\\\s+:\\\\s+(\\\\d?\\\\.\\\\d+).*\");\n        Matcher mR = pR.matcher(line);\n        if (mR.matches()) {\n            try {\n                rfreeNoCutoffLine = Float.parseFloat(mR.group(1));\n            } catch (NumberFormatException e) {\n                logger.info(\"Rfree value \" + mR.group(1) + \" does not look like a number, will ignore it\");\n            }\n        }\n        pR = Pattern.compile(\"^REMARK   3   FREE R VALUE\\\\s+:\\\\s+(\\\\d?\\\\.\\\\d+).*\");\n        mR = pR.matcher(line);\n        if (mR.matches()) {\n            try {\n                rfreeStandardLine = Float.parseFloat(mR.group(1));\n            } catch (NumberFormatException e) {\n                logger.info(\"Rfree value '{}' does not look like a number, will ignore it\", mR.group(1));\n            }\n        }\n        // REMARK 3 RESOLUTION (contains more info than REMARK 2, for instance multiple resolutions in hybrid experimental technique entries)\n        // note: if more than 1 value present (occurring in hybrid experimental technique entries, e.g. 3ins, 4n9m)\n        // then last one encountered will be taken\n    } else if (line.startsWith(\"REMARK   3   RESOLUTION RANGE HIGH\")) {\n        Pattern pR = Pattern.compile(\"^REMARK   3   RESOLUTION RANGE HIGH \\\\(ANGSTROMS\\\\) :\\\\s+(\\\\d+\\\\.\\\\d+).*\");\n        handleResolutionLine(line, pR);\n    } else if (line.startsWith(\"REMARK   3   EFFECTIVE RESOLUTION\")) {\n        Pattern pR = Pattern.compile(\"^REMARK   3   EFFECTIVE RESOLUTION \\\\(ANGSTROMS\\\\)\\\\s+:\\\\s+(\\\\d+\\\\.\\\\d+).*\");\n        handleResolutionLine(line, pR);\n    }\n}", "repo_id": "9", "comment": "/**\n * Handler for REMARK lines\n */\n", "repo_name": "biojava-master/", "id": 1175, "method_signature": "void pdb_REMARK_Handler(String)"}, "2514": {"callee_method_names": ["List<C>.indexOf", "List<C>.size", "C.equalsIgnoreCase", "List<C>.get"], "method_name": "SimpleSubstitutionMatrix.getIndexOfCompound", "method_implementation": "{\n    int index = list.indexOf(compound);\n    if (index == -1) {\n        for (int i = 0; i < list.size(); i++) {\n            if (compound.equalsIgnoreCase(list.get(i))) {\n                index = i;\n                break;\n            }\n        }\n    }\n    return index;\n}", "repo_id": "9", "comment": "/**\n * Returns the index of the first occurrence of the specified element in the list.\n * If the list does not contain the given compound, the index of the first occurrence\n * of the element according to case-insensitive equality.\n * If no such elements exist, -1 is returned.\n * @param list list of compounds to search\n * @param compound compound to search for\n * @return Returns the index of the first match to the specified element in this list, or -1 if there is no such index.\n */\n", "repo_name": "biojava-master/", "id": 2514, "method_signature": "int getIndexOfCompound(List, C)"}, "2179": {"callee_method_ids": [628, 633], "callee_method_names": ["AtomCache.getStructure", "List<ResidueRangeAndLength>.get", "List<ResidueRangeAndLength>.get", "AtomCache.getStructureForDomain", "Structure.getPolyChains", "Structure.getPolyChainByPDB", "Structure.getPolyChainByPDB", "Chain.getAtomGroups", "Chain.getAtomGroups", "Chain.getAtomGroups", "List<Group>.size", "Chain.getAtomGroups", "List<Group>.size"], "method_name": "AtomCacheTest.testGetStructureForDomain2", "method_implementation": "{\n    String ranges = \"A:,B:\";\n    Structure whole = cache.getStructure(\"1I3O\");\n    AtomPositionMap map = new AtomPositionMap(StructureTools.getAllAtomArray(whole), AtomPositionMap.ANYTHING_MATCHER);\n    List<ResidueRangeAndLength> rrs = ResidueRangeAndLength.parseMultiple(ranges, map);\n    int expectedLengthA = rrs.get(0).getLength();\n    int expectedLengthB = rrs.get(1).getLength();\n    Structure structure = cache.getStructureForDomain(\"d1i3o.1\");\n    assertEquals(2, structure.getPolyChains().size());\n    Chain a = structure.getPolyChainByPDB(\"A\");\n    Chain b = structure.getPolyChainByPDB(\"B\");\n    // since biojava 5.0 we have no ligand or water molecules in the polymer chains, we have to subtract the 3 water molecules\n    assertEquals(expectedLengthA - 3, a.getAtomGroups().size());\n    // since biojava 5.0 we have no ligand or water molecules in the polymer chains, we have to subtract the 4 water molecules\n    assertEquals(expectedLengthB - 4, b.getAtomGroups().size());\n    List<Group> ligandsA = StructureTools.filterLigands(b.getAtomGroups());\n    assertEquals(0, ligandsA.size());\n    List<Group> ligandsB = StructureTools.filterLigands(b.getAtomGroups());\n    assertEquals(0, ligandsB.size());\n}", "repo_id": "9", "comment": "/**\n * Tests {@link AtomCache#getStructureForDomain(String)} on a multi-chain domain with two zinc ligands that occurs after the TER. The ligands are in chains E and F, so they should not be included in the domain.\n */\n", "repo_name": "biojava-master/", "id": 2179, "method_signature": "void testGetStructureForDomain2()"}, "1186": {"callee_method_ids": [1317], "callee_method_names": ["FileParsingParameters.isHeaderOnly", "String.length", "Logger.info", "String.length", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "List<LinkRecord>.add"], "method_name": "PDBFileParser.pdb_LINK_Handler", "method_implementation": "{\n    if (params.isHeaderOnly())\n        return;\n    // Check for the minimal set of fields.\n    if (line.length() < 56) {\n        logger.info(\"LINK line has length under 56. Ignoring it.\");\n        return;\n    }\n    int len = line.length();\n    String name1 = line.substring(12, 16).trim();\n    String altLoc1 = line.substring(16, 17).trim();\n    String resName1 = line.substring(17, 20).trim();\n    String chainID1 = line.substring(21, 22).trim();\n    String resSeq1 = line.substring(22, 26).trim();\n    String iCode1 = line.substring(26, 27).trim();\n    String name2 = line.substring(42, 46).trim();\n    String altLoc2 = line.substring(46, 47).trim();\n    String resName2 = line.substring(47, 50).trim();\n    String chainID2 = line.substring(51, 52).trim();\n    String resSeq2 = line.substring(52, 56).trim();\n    // Might get trimmed if blank.\n    String iCode2 = null;\n    if (len > 56)\n        iCode2 = line.substring(56, 57).trim();\n    String sym1 = null;\n    if (len > 64)\n        sym1 = line.substring(59, 65).trim();\n    String sym2 = null;\n    if (len > 71)\n        sym2 = line.substring(66, 72).trim();\n    linkRecords.add(new LinkRecord(name1, altLoc1, resName1, chainID1, resSeq1, iCode1, name2, altLoc2, resName2, chainID2, resSeq2, iCode2, sym1, sym2));\n}", "repo_id": "9", "comment": "/**\n * Takes care of LINK records. These take the format of:\n *\n * <pre>\n * COLUMNS        DATA TYPE       FIELD       DEFINITION\n * --------------------------------------------------------------------------------\n *  1 -  6        Record name     \"LINK  \"\n * 13 - 16        Atom            name1       Atom name.\n * 17             Character       altLoc1     Alternate location indicator.\n * 18 - 20        Residue name    resName1    Residue name.\n * 22             Character       chainID1    Chain identifier.\n * 23 - 26        Integer         resSeq1     Residue sequence number.\n * 27             AChar           iCode1      Insertion code.\n * 43 - 46        Atom            name2       Atom name.\n * 47             Character       altLoc2     Alternate location indicator.\n * 48 - 50        Residue name    resName2    Residue name.\n * 52             Character       chainID2    Chain identifier.\n * 53 - 56        Integer         resSeq2     Residue sequence number.\n * 57             AChar           iCode2      Insertion code.\n * 60 - 65        SymOP           sym1        Symmetry operator for 1st atom.\n * 67 - 72        SymOP           sym2        Symmetry operator for 2nd atom.\n * </pre>\n *\n * (From http://www.wwpdb.org/documentation/format32/sect6.html#LINK)\n *\n * @param line the LINK record line to parse.\n */\n", "repo_name": "biojava-master/", "id": 1186, "method_signature": "void pdb_LINK_Handler(String)"}, "1575": {"callee_method_names": [], "method_name": "Site.getEvCode", "method_implementation": "{\n    return evCode;\n}", "repo_id": "9", "comment": "/**\n * gets the REMARK 800 EVIDENCE CODE for the site.\n * @return evidence code\n */\n", "repo_name": "biojava-master/", "id": 1575, "method_signature": "String getEvCode()"}, "1222": {"callee_method_names": ["Structure.nrModels", "Structure.getChains", "Chain.getAtomGroups", "Group.getPDBName", "ChemComp.getAtoms", "Group.getAtom", "Atom.setCharge", "Group.getAltLocs", "Character.getAtom", "Atom.setCharge"], "method_name": "ChargeAdder.addCharges", "method_implementation": "{\n    // Loop through the models\n    for (int i = 0; i < structure.nrModels(); i++) {\n        for (Chain c : structure.getChains(i)) {\n            for (Group g : c.getAtomGroups()) {\n                ChemComp thisChemComp = ChemCompGroupFactory.getChemComp(g.getPDBName());\n                List<ChemCompAtom> chemAtoms = thisChemComp.getAtoms();\n                for (ChemCompAtom chemCompAtom : chemAtoms) {\n                    Atom atom = g.getAtom(chemCompAtom.getAtomId());\n                    short shortCharge = (short) chemCompAtom.getCharge();\n                    if (atom != null) {\n                        atom.setCharge(shortCharge);\n                    }\n                    // Now do the same for alt locs\n                    for (Group altLoc : g.getAltLocs()) {\n                        Atom altAtom = altLoc.getAtom(chemCompAtom.getAtomId());\n                        if (altAtom != null) {\n                            altAtom.setCharge(shortCharge);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Function to add the charges to a given structure.\n */\n", "repo_name": "biojava-master/", "id": 1222, "method_signature": "void addCharges(Structure)"}, "641": {"callee_method_names": [], "method_name": "AtomCache.setFiletype", "method_implementation": "{\n    this.filetype = filetype;\n}", "repo_id": "9", "comment": "/**\n * Set the file type that will be parsed.\n * @param filetype a StructureFiletype\n */\n", "repo_name": "biojava-master/", "id": 641, "method_signature": "void setFiletype(StructureFiletype)"}, "2466": {"callee_method_names": [], "method_name": "LocIterator.hasNext", "method_implementation": "{\n    return hasNext(mWindowSize, mIncrement);\n}", "repo_id": "9", "comment": "/**\n * Check if next window of default size is available.\n *\n * @return True if window of default size is available. The default size\n * is the size specified in the LocIterator constructor.\n */\n", "repo_name": "biojava-master/", "id": 2466, "method_signature": "boolean hasNext()"}, "222": {"callee_method_names": [], "method_name": "ProteinModificationImpl.setPdbccName", "method_implementation": "{\n    this.pdbccName = pdbccName;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the Protein Data Bank Chemical Component name.\n * @param pdbccName Protein Data Bank Chemical Component name.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 222, "method_signature": "Builder setPdbccName(String)"}, "3254": {"callee_method_ids": [3302], "callee_method_names": ["JMenu.getAccessibleContext", "JMenuBar.add", "JMenuItem.setMnemonic", "MySaveFileListener.setTextOutput", "JMenuItem.addActionListener", "JMenu.add", "JMenu.addSeparator", "JMenuItem.addActionListener", "JMenu.add", "JMenu.addSeparator", "JMenu.add", "JMenu.add", "JMenu.getAccessibleContext", "JMenu.setMnemonic", "JMenuBar.add", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.setMnemonic", "JMenu.add", "JMenu.add", "JMenuBar.add", "JMenuBar.add"], "method_name": "MenuCreator.getAlignmentTextMenu", "method_implementation": "{\n    JMenuBar menu = new JMenuBar();\n    JMenu file = new JMenu(\"File\");\n    file.getAccessibleContext().setAccessibleDescription(\"File Menu\");\n    menu.add(file);\n    ImageIcon saveicon = createImageIcon(\"/icons/filesave.png\");\n    JMenuItem saveF = null;\n    if (saveicon != null)\n        saveF = new JMenuItem(\"Save text display\", saveicon);\n    else\n        saveF = new JMenuItem(\"Save text display\");\n    saveF.setMnemonic(KeyEvent.VK_S);\n    MySaveFileListener listener = new MySaveFileListener(afpChain, msa);\n    listener.setTextOutput(true);\n    saveF.addActionListener(listener);\n    file.add(saveF);\n    file.addSeparator();\n    JMenuItem print = getPrintMenuItem();\n    print.addActionListener(actionListener);\n    file.add(print);\n    file.addSeparator();\n    JMenuItem closeI = MenuCreator.getCloseMenuItem(frame);\n    file.add(closeI);\n    JMenuItem exitI = MenuCreator.getExitMenuItem();\n    file.add(exitI);\n    JMenu view = new JMenu(\"View\");\n    view.getAccessibleContext().setAccessibleDescription(\"View Menu\");\n    view.setMnemonic(KeyEvent.VK_V);\n    menu.add(view);\n    JMenuItem textI = MenuCreator.getIcon(actionListener, TEXT_ONLY);\n    view.add(textI);\n    JMenuItem fastaI = MenuCreator.getIcon(actionListener, FASTA_FORMAT);\n    view.add(fastaI);\n    JMenuItem pairsI = MenuCreator.getIcon(actionListener, PAIRS_ONLY);\n    view.add(pairsI);\n    JMenuItem textF = MenuCreator.getIcon(actionListener, FATCAT_TEXT);\n    view.add(textF);\n    JMenu about = new JMenu(\"Help\");\n    about.setMnemonic(KeyEvent.VK_A);\n    JMenuItem helpM = MenuCreator.getHelpMenuItem();\n    about.add(helpM);\n    JMenuItem aboutM = MenuCreator.getAboutMenuItem();\n    about.add(aboutM);\n    menu.add(Box.createGlue());\n    menu.add(about);\n    return menu;\n}", "repo_id": "9", "comment": "/**\n * Create the menu for the Text representations of Structural Alignments.\n * @param frame\n * @param actionListener\n * @param afpChain\n * @param msa\n * @return a JMenuBar\n */\n", "repo_name": "biojava-master/", "id": 3254, "method_signature": "JMenuBar getAlignmentTextMenu(JFrame, ActionListener, AFPChain, MultipleAlignment)"}, "3418": {"callee_method_ids": [1971, 1885, 1884, 1972], "callee_method_names": ["HelixAxisAligner.getSubunits", "QuatSymmetrySubunits.getModelNumbers", "QuatSymmetrySubunits.getChainIds", "HelixAxisAligner.getOrbits", "List<List<Integer>>.size", "List<List<Integer>>.size", "List<List<Integer>>.get", "Map<Color4f, List<String>>.get", "Map<Color4f, List<String>>.put", "List<String>.add"], "method_name": "JmolSymmetryScriptGeneratorH.colorBySubunit", "method_implementation": "{\n    QuatSymmetrySubunits subunits = helixAxisAligner.getSubunits();\n    List<Integer> modelNumbers = subunits.getModelNumbers();\n    List<String> chainIds = subunits.getChainIds();\n    List<List<Integer>> orbits = helixAxisAligner.getOrbits();\n    Color[] col = ColorBrewer.Spectral.getColorPalette(orbits.size());\n    Color4f[] colors = ColorConverter.convertColor4f(col);\n    int half = colors.length / 2;\n    for (int i = 0; i < half; i++) {\n        if (i % 2 != 0) {\n            Color4f temp = colors[i];\n            colors[i] = colors[half + i];\n            colors[half + i] = temp;\n        }\n    }\n    Map<Color4f, List<String>> colorMap = new HashMap<Color4f, List<String>>();\n    for (int i = 0; i < orbits.size(); i++) {\n        for (Integer j : orbits.get(i)) {\n            Color4f c = colors[i];\n            List<String> ids = colorMap.get(c);\n            if (ids == null) {\n                ids = new ArrayList<String>();\n                colorMap.put(c, ids);\n            }\n            String id = getChainSpecification(modelNumbers, chainIds, j);\n            ids.add(id);\n        }\n    }\n    String coloring = defaultColoring + getJmolColorScript(colorMap);\n    return coloring;\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script that colors the subunits of a structure by different colors\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3418, "method_signature": "String colorBySubunit()"}, "3821": {"callee_method_names": ["String.startsWith", "BufferedImage.createGraphics"], "method_name": "ExpressionFigure.savePNG", "method_implementation": "{\n    if (fileName.startsWith(\"null\")) {\n        return;\n    }\n    this.fileName = fileName;\n    BufferedImage image = new BufferedImage(this.getWidth(), this.getHeight(), BufferedImage.TYPE_INT_RGB);\n    Graphics2D graphics2D = image.createGraphics();\n    this.paint(graphics2D);\n    try {\n        ImageIO.write(image, \"png\", new File(fileName));\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * @param fileName\n */\n", "repo_name": "biojava-master/", "id": 3821, "method_signature": "void savePNG(String)"}, "2461": {"callee_method_ids": [2399, 2400], "callee_method_names": ["Location.start", "Location.end"], "method_name": "Feature.toString", "method_implementation": "{\n    String s = mSeqname + '\\t';\n    s += mSource + '\\t';\n    s += mType + '\\t';\n    s += mLocation.start() + \"\\t\";\n    s += mLocation.end() + \"\\t\";\n    s += Double.toString(mScore) + \"\\t\";\n    if (mFrame == -1) {\n        s += \".\\t\";\n    } else {\n        s += mFrame + \"\\t\";\n    }\n    s += mAttributes;\n    return s;\n}", "repo_id": "9", "comment": "/**\n */\n", "repo_name": "biojava-master/", "id": 2461, "method_signature": "String toString()"}, "1387": {"callee_method_names": [], "method_name": "DBRef.setIdbnsBegin", "method_implementation": "{\n    this.idbnsBegin = idbnsBegin;\n}", "repo_id": "9", "comment": "/**\n *  Insertion code of initial residue of the segment, if PDB is the\n * \treference.\n *  @param idbnsBegin insertion code\n *  @see #getIdbnsBegin()\n */\n", "repo_name": "biojava-master/", "id": 1387, "method_signature": "void setIdbnsBegin(char)"}, "3546": {"callee_method_names": [], "method_name": "CoxCoefficient.setHazardRatio", "method_implementation": "{\n    this.hazardRatio = hazardRatio;\n}", "repo_id": "9", "comment": "/**\n * @param hazardRatio the hazardRatio to set\n */\n", "repo_name": "biojava-master/", "id": 3546, "method_signature": "void setHazardRatio(double)"}, "1": {"callee_method_names": [], "method_name": "SimpleGapPenalty.setDefaultOpenPenalty", "method_implementation": "{\n    dgop = gop;\n}", "repo_id": "9", "comment": "/**\n * Sets the default gap open penalty.\n *\n * @param gop the default gap open penalty\n */\n", "repo_name": "biojava-master/", "id": 1, "method_signature": "void setDefaultOpenPenalty(int)"}, "540": {"callee_method_ids": [487, 487], "callee_method_names": ["Logger.debug", "Logger.debug", "AFPChain.getBlockRotationMatrix", "AFPChain.getBlockNum", "AFPChain.getBlockShiftVector", "AFPChain.getBlockNum", "AFPChain.setBlockRotationMatrix", "AFPChain.setBlockShiftVector", "Atom.getGroup"], "method_name": "AFPTwister.transformOrigPDB", "method_implementation": "{\n    logger.debug(\"transforming original coordinates {} len1: {} res1: {} len2: {} res2: {}\", n, ca1.length, res1.length, ca2.length, res2.length);\n    Atom[] cod1 = getAtoms(ca1, res1, n, false);\n    Atom[] cod2 = getAtoms(ca2, res2, n, false);\n    // double *cod1 = pro1->Cod4Res(n, res1);\n    // double *cod2 = pro2->Cod4Res(n, res2);\n    Matrix4d transform = SuperPositions.superpose(Calc.atomsToPoints(cod1), Calc.atomsToPoints(cod2));\n    Matrix r = Matrices.getRotationJAMA(transform);\n    Atom t = Calc.getTranslationVector(transform);\n    logger.debug(\"transPdb: transforming orig coordinates with matrix: {}\", r);\n    if (afpChain != null) {\n        Matrix[] ms = afpChain.getBlockRotationMatrix();\n        if (ms == null)\n            ms = new Matrix[afpChain.getBlockNum()];\n        ms[blockNr] = r;\n        Atom[] shifts = afpChain.getBlockShiftVector();\n        if (shifts == null)\n            shifts = new Atom[afpChain.getBlockNum()];\n        shifts[blockNr] = t;\n        afpChain.setBlockRotationMatrix(ms);\n        afpChain.setBlockShiftVector(shifts);\n    }\n    for (Atom a : ca2) Calc.transform(a.getGroup(), transform);\n}", "repo_id": "9", "comment": "// orig name: transPdb\n", "repo_name": "biojava-master/", "id": 540, "method_signature": "void transformOrigPDB(int, int[], int[], Atom[], Atom[], AFPChain, int)"}, "114": {"callee_method_names": ["DistanceMatrix.getSize", "Phylogeny.getExternalNodes", "HashMap<String, PhylogenyNode>.put", "DistanceMatrix.getIdentifier", "HashMap<String, PhylogenyNode>.get", "DistanceMatrix.getIdentifier", "HashMap<String, PhylogenyNode>.get", "DistanceMatrix.getValue", "Logger.info", "Logger.warn", "Set<PhylogenyNode>.clear", "Logger.info", "Logger.info", "Logger.info"], "method_name": "DistanceTreeEvaluator.evaluate", "method_implementation": "{\n    int numSequences = matrix.getSize();\n    List<PhylogenyNode> externalNodes = tree.getExternalNodes();\n    HashMap<String, PhylogenyNode> externalNodesHashMap = new HashMap<String, PhylogenyNode>();\n    Set<PhylogenyNode> path = new HashSet<PhylogenyNode>();\n    for (PhylogenyNode node : externalNodes) {\n        externalNodesHashMap.put(node.getName(), node);\n    }\n    int count = 0;\n    double averageMatrixDistance = 0.0;\n    double averageTreeDistance = 0.0;\n    double averageTreeErrorDistance = 0.0;\n    for (int row = 0; row < numSequences - 1; row++) {\n        String nodeName1 = matrix.getIdentifier(row);\n        PhylogenyNode node1 = externalNodesHashMap.get(nodeName1);\n        markPathToRoot(node1, path);\n        for (int col = row + 1; col < numSequences; col++) {\n            count++;\n            String nodeName2 = matrix.getIdentifier(col);\n            PhylogenyNode node2 = externalNodesHashMap.get(nodeName2);\n            double distance = matrix.getValue(col, row);\n            averageMatrixDistance = averageMatrixDistance + distance;\n            PhylogenyNode commonParent = findCommonParent(node2, path);\n            if (commonParent != null) {\n                double treeDistance = getNodeDistance(commonParent, node1) + getNodeDistance(commonParent, node2);\n                averageTreeDistance += treeDistance;\n                averageTreeErrorDistance += (distance - treeDistance) * (distance - treeDistance);\n                logger.info(\"{} {} Distance: {}Tree: {} difference: {}\", nodeName1, nodeName2, distance, treeDistance, Math.abs(distance - treeDistance));\n            } else {\n                logger.warn(\"Unable to find common parent with {} {}\", node1, node2);\n            }\n        }\n        path.clear();\n    }\n    averageMatrixDistance /= count;\n    averageTreeDistance /= count;\n    averageTreeErrorDistance /= count;\n    logger.info(\"Average matrix distance: {}\", averageMatrixDistance);\n    logger.info(\"Average tree distance: {}\", averageTreeDistance);\n    logger.info(\"Average LS error: {}\", averageTreeErrorDistance);\n    return Math.sqrt(averageTreeErrorDistance) / averageMatrixDistance;\n}", "repo_id": "9", "comment": "/**\n * Evaluate the goodness of fit of a given tree to the original distance\n * matrix. The returned value is the coefficient of variation, i.e. the\n * square root of the LS error normalized by the mean.\n * <p>\n * This measure can also give an estimate of the quality of the distance\n * matrix, because a bad fit may mean that the distance is non-additive.\n *\n * @param tree\n *            Phylogenetic Distance Tree to evaluate\n * @param matrix\n *            Distance Matrix with the original distances\n * @return the square root of the average tree LS error normalized by the\n *         average tree distance (coefficient of variation, CV).\n */\n", "repo_name": "biojava-master/", "id": 114, "method_signature": "double evaluate(Phylogeny, DistanceMatrix)"}, "2364": {"callee_method_ids": [2372, 2373, 2372], "callee_method_names": ["Fastq.getQuality", "Fastq.getVariant", "Fastq.getQuality", "FastqVariant.qualityScore"], "method_name": "FastqTools.qualityScores", "method_implementation": "{\n    if (fastq == null) {\n        throw new IllegalArgumentException(\"fastq must not be null\");\n    }\n    if (qualityScores == null) {\n        throw new IllegalArgumentException(\"qualityScores must not be null\");\n    }\n    int size = fastq.getQuality().length();\n    if (qualityScores.length != size) {\n        throw new IllegalArgumentException(\"qualityScores must be the same length as the FASTQ formatted sequence quality\");\n    }\n    FastqVariant variant = fastq.getVariant();\n    for (int i = 0; i < size; i++) {\n        char c = fastq.getQuality().charAt(i);\n        qualityScores[i] = variant.qualityScore(c);\n    }\n    return qualityScores;\n}", "repo_id": "9", "comment": "/**\n * Copy the quality scores from the specified FASTQ formatted sequence into the specified int array.\n *\n * @param fastq FASTQ formatted sequence, must not be null\n * @param qualityScores int array of quality scores, must not be null and must be the same\n *    length as the FASTQ formatted sequence quality\n * @return the specified int array of quality scores\n */\n", "repo_name": "biojava-master/", "id": 2364, "method_signature": "int[] qualityScores(Fastq, int[])"}, "797": {"callee_method_names": [], "method_name": "CeStartupParams.getMaxGapSize", "method_implementation": "{\n    return maxGapSize;\n}", "repo_id": "9", "comment": "/**\n * CE specific parameter: set the Max gap size parameter G (during AFP extension). Default: 30\n *\n * @return the maximum gap size G parameter.\n */\n", "repo_name": "biojava-master/", "id": 797, "method_signature": "int getMaxGapSize()"}, "2746": {"callee_method_names": [], "method_name": "EmblRecord.getOrganismSpecies", "method_implementation": "{\n    return organismSpecies;\n}", "repo_id": "9", "comment": "/**\n * The OS (Organism Species) line specifies the preferred scientific name of\n * the organism which was the source of the stored sequence. In most\n * cases this is done by giving the Latin genus and species designations,\n * followed (in parentheses) by the preferred common name in English where known.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2746, "method_signature": "String getOrganismSpecies()"}, "1062": {"callee_method_names": ["Structure.nrModels", "Structure.getPolyChains", "Chain.getAtomGroups", "Group.getAtoms", "Group.isAminoAcid", "List<Atom>.removeIf", "Atom.getName", "Group.isNucleotide", "List<Atom>.removeIf", "Atom.getName"], "method_name": "StructureTools.reduceToRepresentativeAtoms", "method_implementation": "{\n    for (int modelIdx = 0; modelIdx < structure.nrModels(); modelIdx++) {\n        for (Chain c : structure.getPolyChains(modelIdx)) {\n            for (Group g : c.getAtomGroups()) {\n                List<Atom> atoms = g.getAtoms();\n                if (g.isAminoAcid()) {\n                    atoms.removeIf(a -> !a.getName().equals(CA_ATOM_NAME));\n                } else if (g.isNucleotide()) {\n                    atoms.removeIf(a -> !a.getName().equals(NUCLEOTIDE_REPRESENTATIVE));\n                }\n                // else we keep all other atoms. We are concerned only about aminoacids and nucleotides that make up the bulk of the structures\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Remove all atoms but the representative atoms (C alphas or phosphates) from the given structure.\n * @param structure the structure\n * @since 5.4.0\n */\n", "repo_name": "biojava-master/", "id": 1062, "method_signature": "void reduceToRepresentativeAtoms(Structure)"}, "3181": {"callee_method_names": ["GeneSequence.setAccession", "LinkedHashMap.put", "AccessionID.toString"], "method_name": "ChromosomeSequence.addGene", "method_implementation": "{\n    GeneSequence geneSequence = new GeneSequence(this, bioBegin, bioEnd, strand);\n    geneSequence.setAccession(accession);\n    geneSequenceHashMap.put(accession.toString(), geneSequence);\n    return geneSequence;\n}", "repo_id": "9", "comment": "/**\n * Add a gene to the chromosome sequence using bioIndexing starts at 1 instead of 0. The\n * GeneSequence that is returned will have a reference to parent chromosome sequence\n * which actually contains the sequence data. Strand is important for positive and negative\n * direction where negative strand means we need reverse complement. If negative strand then\n * bioBegin will be greater than bioEnd\n * @param accession\n * @param bioBegin\n * @param bioEnd\n * @param strand\n * @return A GeneSequence\n */\n", "repo_name": "biojava-master/", "id": 3181, "method_signature": "GeneSequence addGene(AccessionID, int, int, Strand)"}, "1928": {"callee_method_names": [], "method_name": "QuatSymmetryResults.getMethod", "method_implementation": "{\n    return method;\n}", "repo_id": "9", "comment": "/**\n * @return the method used for symmetry perception.\n */\n", "repo_name": "biojava-master/", "id": 1928, "method_signature": "SymmetryPerceptionMethod getMethod()"}, "3301": {"callee_method_names": [], "method_name": "StructureAlignmentDisplay.display", "method_implementation": "{\n    if (ca1.length < 1 || ca2.length < 1) {\n        throw new StructureException(\"length of atoms arrays is too short! \" + ca1.length + \",\" + ca2.length);\n    }\n    Group[] twistedGroups = AlignmentTools.prepareGroupsForDisplay(afpChain, ca1, ca2);\n    List<Group> hetatms = StructureTools.getUnalignedGroups(ca1);\n    List<Group> hetatms2 = StructureTools.getUnalignedGroups(ca2);\n    return DisplayAFP.display(afpChain, twistedGroups, ca1, ca2, hetatms, hetatms2);\n}", "repo_id": "9", "comment": "/**\n * Display an AFPChain alignment\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @return a StructureAlignmentJmol instance\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3301, "method_signature": "StructureAlignmentJmol display(AFPChain, Atom[], Atom[])"}, "3745": {"callee_method_names": ["LinkedHashMap<String,String>.keySet", "LinkedHashMap<String,String>.get"], "method_name": "WorkSheet.changeColumnsHeaders", "method_implementation": "{\n    for (String oldColumn : newColumnValues.keySet()) {\n        String newColumn = newColumnValues.get(oldColumn);\n        changeColumnHeader(oldColumn, newColumn);\n    }\n}", "repo_id": "9", "comment": "/**\n * Change the columns in the HashMap Key to the name of the value\n *\n * @param newColumnValues\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3745, "method_signature": "void changeColumnsHeaders(LinkedHashMap)"}, "3738": {"callee_method_names": ["LinkedHashMap.get", "LinkedHashMap.keySet", "String.equalsIgnoreCase"], "method_name": "WorkSheet.isValidColumn", "method_implementation": "{\n    HeaderInfo colIndex = columnLookup.get(col);\n    if (colIndex == null) {\n        for (String coltable : columnLookup.keySet()) {\n            if (col.equalsIgnoreCase(coltable)) {\n                return true;\n            }\n        }\n        return false;\n    } else {\n        return true;\n    }\n}", "repo_id": "9", "comment": "/**\n * @param col\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3738, "method_signature": "boolean isValidColumn(String)"}, "2726": {"callee_method_names": [], "method_name": "FastaGeneWriter.getLineLength", "method_implementation": "{\n    return lineLength;\n}", "repo_id": "9", "comment": "/**\n * @return the lineLength\n */\n", "repo_name": "biojava-master/", "id": 2726, "method_signature": "int getLineLength()"}, "2220": {"callee_method_ids": [641], "callee_method_names": ["AtomCache.setFiletype", "Structure.nrModels", "Structure.getPolyChains", "Structure.getPolyChainByPDB", "Structure.getPolyChainByPDB"], "method_name": "TestHardBioUnits.test4A1Immcif", "method_implementation": "{\n    String pdbId = \"4A1I\";\n    int biolAssemblyNr = 2;\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    StructureIO.setAtomCache(cache);\n    Structure bioAssembly = StructureIO.getBiologicalAssembly(pdbId, biolAssemblyNr);\n    if (bioAssembly == null) {\n        System.err.println(\"Could not generate the biological assembly \" + pdbId + \" nr \" + biolAssemblyNr);\n    }\n    /*\n\t\t * loop_\n\t\t\t\t_pdbx_struct_assembly_gen.assembly_id\n\t\t\t\t_pdbx_struct_assembly_gen.oper_expression\n\t\t\t\t_pdbx_struct_assembly_gen.asym_id_list\n\t\t\t\t1 1 A,I,J,K,L,M,N,UA,H,PA,QA,RA,SA,TA,BB\n\t\t\t\t2 1 G,KA,LA,MA,NA,OA,AB\n\t\t\t\t2 2 B,O,P,Q,R,VA\n\t\t\t\t3 1 B,O,P,Q,R,VA\n\t\t\t\t3 3 G,KA,LA,MA,NA,OA,AB\n\t\t\t\t4 1 C,S,T,U,V,W,WA,F,FA,GA,HA,IA,JA,ZA\n\t\t\t\t5 1 D,X,Y,Z,XA,E,AA,BA,CA,DA,EA,YA\n\t\t */\n    //System.out.println(bioAssembly.toPDB());\n    assertEquals(1, bioAssembly.nrModels());\n    assertEquals(2, bioAssembly.getPolyChains().size());\n    // this tests checks that the operator ids are exactly those read from mmcif, it doesn't necessarily work in mmtf where there are no ids\n    Chain g = bioAssembly.getPolyChainByPDB(\"G_1\");\n    Chain b = bioAssembly.getPolyChainByPDB(\"B_2\");\n    assertNotNull(g);\n    assertNotNull(b);\n}", "repo_id": "9", "comment": "/**\n * This tests that the biounit and operator ids are the right ones when parsing from mmcif\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2220, "method_signature": "void test4A1Immcif()"}, "1613": {"callee_method_ids": [645], "callee_method_names": ["AtomCache.getStructureForPdbId"], "method_name": "SubstructureIdentifier.loadStructure", "method_implementation": "{\n    PdbId pdb = getPdbId();\n    if (pdb == null)\n        return null;\n    return cache.getStructureForPdbId(pdb);\n}", "repo_id": "9", "comment": "/**\n * Loads the complete structure based on {@link #getPdbId()}.\n *\n * @param cache A source of structures\n * @return A Structure containing at least the atoms identified by this,\n *  or null if no PDB ID is set\n * @throws StructureException For errors loading and parsing the structure\n * @throws IOException Errors reading the structure from disk\n */\n", "repo_name": "biojava-master/", "id": 1613, "method_signature": "Structure loadStructure(AtomCache)"}, "878": {"callee_method_names": ["Group.getAtoms", "SparseVector.getElement"], "method_name": "StructureInterface.getSizeNoH", "method_implementation": "{\n    int size = 0;\n    for (Atom a : g.getAtoms()) {\n        if (a.getElement() != Element.H)\n            size++;\n    }\n    return size;\n}", "repo_id": "9", "comment": "/**\n * Calculates the number of non-Hydrogen atoms in the given group\n * @param g\n * @return\n */\n", "repo_name": "biojava-master/", "id": 878, "method_signature": "int getSizeNoH(Group)"}, "1323": {"callee_method_names": [], "method_name": "FileParsingParameters.getAcceptedAtomNames", "method_implementation": "{\n    return fullAtomNames;\n}", "repo_id": "9", "comment": "/**\n * By default the parser will read in all atoms (unless using the CAonly switch). This allows to specify a set of atoms to be read. e.g.\n * {\"CA\", \"CB\" }. Returns null if all atoms are accepted.\n * @return accepted atom names, or null if all atoms are accepted. default null\n */\n", "repo_name": "biojava-master/", "id": 1323, "method_signature": "String[] getAcceptedAtomNames()"}, "3020": {"callee_method_names": [], "method_name": "AbstractReference.setJournal", "method_implementation": "{\n    this.journal = journal;\n}", "repo_id": "9", "comment": "/**\n * Set The journal usually contains the Publication Number, Publication Date and Assignee\n *\n * @param journal\n */\n", "repo_name": "biojava-master/", "id": 3020, "method_signature": "void setJournal(String)"}, "1368": {"callee_method_names": [], "method_name": "DBRef.getParent", "method_implementation": "{\n    return parent;\n}", "repo_id": "9", "comment": "/**\n * Get the structure object that this DBRef relates to.\n *\n * @return s a structure object\n * @see #setParent(Structure)\n */\n", "repo_name": "biojava-master/", "id": 1368, "method_signature": "Structure getParent()"}, "1243": {"callee_method_ids": [1588], "callee_method_names": ["SecStrucCalc.calculate", "Logger.warn", "Element.getMessage"], "method_name": "MmtfUtils.calculateDsspSecondaryStructure", "method_implementation": "{\n    SecStrucCalc ssp = new SecStrucCalc();\n    try {\n        ssp.calculate(bioJavaStruct, true);\n    } catch (StructureException e) {\n        LOGGER.warn(\"Could not calculate secondary structure (error {}). Secondary structure annotation will be missing.\", e.getMessage());\n    }\n}", "repo_id": "9", "comment": "/**\n * Generate the secondary structure for a Biojava structure object.\n * @param bioJavaStruct the Biojava structure for which it is to be calculate.\n */\n", "repo_name": "biojava-master/", "id": 1243, "method_signature": "void calculateDsspSecondaryStructure(Structure)"}, "2422": {"callee_method_names": [], "method_name": "Location.opposite", "method_implementation": "{\n    return new Location(-mEnd, -mStart);\n}", "repo_id": "9", "comment": "/**\n * Return location that is in same position on opposite strand.\n *\n * @return Location on opposite strand.\n */\n", "repo_name": "biojava-master/", "id": 2422, "method_signature": "Location opposite()"}, "935": {"callee_method_names": [], "method_name": "Grid.findFullGridIntBounds", "method_implementation": "{\n    int[] iIntBounds = getIntBounds(ibounds);\n    bounds = new int[6];\n    if (jbounds == null) {\n        bounds = iIntBounds;\n    } else {\n        int[] jIntBounds = getIntBounds(jbounds);\n        bounds[0] = Math.min(iIntBounds[0], jIntBounds[0]);\n        bounds[1] = Math.min(iIntBounds[1], jIntBounds[1]);\n        bounds[2] = Math.min(iIntBounds[2], jIntBounds[2]);\n        bounds[3] = Math.max(iIntBounds[3], jIntBounds[3]);\n        bounds[4] = Math.max(iIntBounds[4], jIntBounds[4]);\n        bounds[5] = Math.max(iIntBounds[5], jIntBounds[5]);\n    }\n}", "repo_id": "9", "comment": "/**\n * Calculates an int array of size 6 into member variable bounds:\n * - elements 0,1,2: minimum x,y,z of the iAtoms and jAtoms\n * - elements 3,4,5: maximum x,y,z of the iAtoms and jAtoms\n */\n", "repo_name": "biojava-master/", "id": 935, "method_signature": "void findFullGridIntBounds()"}, "2464": {"callee_method_names": ["Logger.info", "FeatureList.listIterator", "ListIterator<FeatureI>.hasNext", "ListIterator<FeatureI>.next", "BufferedWriter.close"], "method_name": "GeneIDGFF2Reader.write", "method_implementation": "{\n    logger.info(\"Writing: {}\", filename);\n    BufferedWriter bw = new BufferedWriter(new FileWriter(filename));\n    ListIterator<FeatureI> iter = features.listIterator();\n    while (iter.hasNext()) {\n        Feature feature = (Feature) iter.next();\n        writeLine(feature, bw);\n    }\n    bw.close();\n}", "repo_id": "9", "comment": "/**\n * Write features in FeatureList to file. Each Feature becomes one line in the file.\n * The userMap() data in the features is not written to file.\n *\n * @param features The list of features to write.\n * @param filename The path to the file.\n * @throws IOException Something went wrong -- check exception detail message.\n */\n", "repo_name": "biojava-master/", "id": 2464, "method_signature": "void write(FeatureList, String)"}, "895": {"callee_method_names": ["Logger.warn", "Pair<Chain>.getFirst", "Pair<Chain>.getSecond"], "method_name": "StructureInterface.getParentCompounds", "method_implementation": "{\n    Pair<Chain> chains = getParentChains();\n    if (chains == null) {\n        logger.warn(\"Could not find parents chains, compounds will be null\");\n        return null;\n    }\n    return new Pair<EntityInfo>(chains.getFirst().getEntityInfo(), chains.getSecond().getEntityInfo());\n}", "repo_id": "9", "comment": "/**\n * Finds the parent entities by looking up the references of first atom of each side of this interface\n * @return\n */\n", "repo_name": "biojava-master/", "id": 895, "method_signature": "Pair<EntityInfo> getParentCompounds()"}, "2734": {"callee_method_names": [], "method_name": "EmblId.getSequenceLength", "method_implementation": "{\n    return sequenceLength;\n}", "repo_id": "9", "comment": "/**\n * Sequence length The last item on the ID line is the length of the\n * sequence (the total number of bases in the sequence). This number includes\n * base positions reported as present but undetermined (coded as \"N\").\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2734, "method_signature": "String getSequenceLength()"}, "2804": {"callee_method_names": [], "method_name": "ClasspathResource.getBufferedReader", "method_implementation": "{\n    return new BufferedReader(new InputStreamReader(getInputStream()));\n}", "repo_id": "9", "comment": "/**\n * Returns the reader representation of this classpath resource\n */\n", "repo_name": "biojava-master/", "id": 2804, "method_signature": "BufferedReader getBufferedReader()"}, "2056": {"callee_method_ids": [507], "callee_method_names": ["AFPChain.getTMScore", "CESymmParameters.getUnrefinedScoreThreshold", "CESymmParameters.getRefineMethod", "MultipleAlignment.getScore", "SymmetryAxes.getNumLevels", "SymmetryAxes.getNumLevels", "SymmetryAxes.getElementaryAxis"], "method_name": "CeSymmResult.getReason", "method_implementation": "{\n    // Cases:\n    // 1. Asymmetric because insignificant self-alignment (1itb.A_1-100)\n    double tm = selfAlignment.getTMScore();\n    if (tm < params.getUnrefinedScoreThreshold()) {\n        return String.format(\"Insignificant self-alignment (TM=%.2f)\", tm);\n    }\n    // 2. Asymmetric because order detector returned 1\n    if (numRepeats == 1) {\n        return String.format(\"Order detector found asymmetric alignment (TM=%.2f)\", tm);\n    }\n    // Check that the user requested refinement\n    if (params.getRefineMethod() != RefineMethod.NOT_REFINED) {\n        // 3. Asymmetric because refinement failed\n        if (!refined) {\n            return \"Refinement failed\";\n        }\n        tm = multipleAlignment.getScore(MultipleAlignmentScorer.AVGTM_SCORE);\n        // 4. Asymmetric because refinement & optimization were not\n        // significant\n        if (!isSignificant()) {\n            return String.format(\"Refinement was not significant (TM=%.2f)\", tm);\n        }\n    } else {\n        // 4. Not refined, but result was not significant\n        if (!isSignificant()) {\n            return String.format(\"Result was not significant (TM=%.2f)\", tm);\n        }\n    }\n    String hierarchical = \"\";\n    if (axes.getNumLevels() > 1) {\n        hierarchical = String.format(\"; Contains %d levels of symmetry\", axes.getNumLevels());\n    }\n    // 5. Symmetric.\n    // a. Open. Give # repeats (1n0r.A)\n    if (axes.getElementaryAxis(0).getSymmType() == SymmetryType.OPEN) {\n        return String.format(\"Contains %d open repeats (TM=%.2f)%s\", getNumRepeats(), tm, hierarchical);\n    }\n    // b. Closed, non-hierarchical (1itb.A)\n    // c. Closed, heirarchical (4gcr)\n    return String.format(\"Significant (TM=%.2f)%s\", tm, hierarchical);\n}", "repo_id": "9", "comment": "/**\n * Return a String describing the reasons for the CE-Symm final decision in\n * this particular result.\n *\n * @return String decision reason\n */\n", "repo_name": "biojava-master/", "id": 2056, "method_signature": "String getReason()"}, "3336": {"callee_method_names": ["File.getAccessibleContext", "JMenuItem.setMnemonic", "JMenuItem.addActionListener", "MouseEvent.getActionCommand", "JFileChooser.showOpenDialog", "JFileChooser.getSelectedFile", "PDBFileReader.getStructure", "BiojavaJmol.setStructure", "BiojavaJmol.evalString", "BiojavaJmol.evalString", "File.add", "JMenuItem.setMnemonic", "JMenuItem.addActionListener", "MouseEvent.getActionCommand", "File.add", "JMenuBar.add", "JMenuItem.addActionListener", "MouseEvent.getActionCommand", "JMenu.add", "JMenuBar.add", "JMenuItem.addActionListener", "MouseEvent.getActionCommand", "JMenu.add", "JMenuBar.add", "JMenuBar.add"], "method_name": "MenuCreator.initMenu", "method_implementation": "{\n    // show a menu\n    JMenuBar menu = new JMenuBar();\n    JMenu file = new JMenu(\"File\");\n    file.getAccessibleContext().setAccessibleDescription(\"File Menu\");\n    JMenuItem openI = new JMenuItem(\"Open\");\n    openI.setMnemonic(KeyEvent.VK_O);\n    openI.addActionListener(new ActionListener() {\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            String cmd = e.getActionCommand();\n            if (\"Open\".equals(cmd)) {\n                final JFileChooser fc = new JFileChooser();\n                //\t\t\t\t\tIn response to a button click:\n                int returnVal = fc.showOpenDialog(null);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = fc.getSelectedFile();\n                    PDBFileReader reader = new PDBFileReader();\n                    try {\n                        Structure s = reader.getStructure(file);\n                        BiojavaJmol jmol = new BiojavaJmol();\n                        jmol.setStructure(s);\n                        jmol.evalString(\"select * ; color chain;\");\n                        jmol.evalString(\"select *; spacefill off; wireframe off; backbone 0.4;  \");\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        }\n    });\n    file.add(openI);\n    JMenuItem exitI = new JMenuItem(\"Exit\");\n    exitI.setMnemonic(KeyEvent.VK_X);\n    exitI.addActionListener(new ActionListener() {\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            String cmd = e.getActionCommand();\n            if (\"Exit\".equals(cmd)) {\n                System.exit(0);\n            }\n        }\n    });\n    file.add(exitI);\n    menu.add(file);\n    JMenu align = new JMenu(\"Align\");\n    JMenuItem pairI = new JMenuItem(\"2 protein structures\");\n    pairI.addActionListener(new ActionListener() {\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            String cmd = e.getActionCommand();\n            if (\"2 protein structures\".equals(cmd)) {\n                MenuCreator.showPairDialog();\n            }\n        }\n    });\n    align.add(pairI);\n    menu.add(align);\n    JMenu about = new JMenu(\"About\");\n    JMenuItem aboutI = new JMenuItem(\"PDBview\");\n    aboutI.addActionListener(new ActionListener() {\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            String cmd = e.getActionCommand();\n            if (\"PDBview\".equals(cmd)) {\n                MenuCreator.showAboutDialog();\n            }\n        }\n    });\n    about.add(aboutI);\n    menu.add(Box.createGlue());\n    menu.add(about);\n    return menu;\n}", "repo_id": "9", "comment": "/**\n * provide a JMenuBar that can be added to a JFrame\n *\n * @return a JMenuBar\n */\n", "repo_name": "biojava-master/", "id": 3336, "method_signature": "JMenuBar initMenu()"}, "2887": {"callee_method_names": [], "method_name": "SequenceMixin.indexOf", "method_implementation": "{\n    int index = 1;\n    for (C currentCompound : sequence) {\n        if (currentCompound.equals(compound)) {\n            return index;\n        }\n        index++;\n    }\n    return 0;\n}", "repo_id": "9", "comment": "/**\n * Performs a linear search of the given Sequence for the given compound.\n * Once we find the compound we return the position.\n */\n", "repo_name": "biojava-master/", "id": 2887, "method_signature": "int indexOf(Sequence, C)"}, "3471": {"callee_method_names": ["URLConnection.setDoOutput", "URLConnection.setUseCaches", "URLConnection.setRequestProperty", "URLConnection.setRequestProperty", "URLConnection.setRequestProperty", "URLConnection.setRequestProperty"], "method_name": "NCBIQBlastService.setQBlastServiceProperties", "method_implementation": "{\n    conn.setDoOutput(true);\n    conn.setUseCaches(false);\n    conn.setRequestProperty(\"User-Agent\", \"Biojava/NCBIQBlastService\");\n    conn.setRequestProperty(\"Connection\", \"Keep-Alive\");\n    conn.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n    conn.setRequestProperty(\"Content-length\", \"200\");\n    return conn;\n}", "repo_id": "9", "comment": "/**\n * Sets properties for given URLConnection\n *\n * @param conn URLConnection to set properties for\n * @return given object after setting properties\n */\n", "repo_name": "biojava-master/", "id": 3471, "method_signature": "URLConnection setQBlastServiceProperties(URLConnection)"}, "900": {"callee_method_names": ["List<AtomContact>.add"], "method_name": "AtomContactSet.getContactsWithinDistance", "method_implementation": "{\n    if (distance >= cutoff)\n        throw new IllegalArgumentException(\"Given distance \" + String.format(\"%.2f\", distance) + \" is larger than contacts' distance cutoff \" + String.format(\"%.2f\", cutoff));\n    List<AtomContact> list = new ArrayList<AtomContact>();\n    for (AtomContact contact : this.contacts.values()) {\n        if (contact.getDistance() < distance) {\n            list.add(contact);\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Returns the list of contacts from this set that are within the given distance.\n * @param distance\n * @return\n * @throws IllegalArgumentException if given distance is larger than distance cutoff\n * used for calculation of contacts\n */\n", "repo_name": "biojava-master/", "id": 900, "method_signature": "List<AtomContact> getContactsWithinDistance(double)"}, "3247": {"callee_method_names": ["JDialog.setVisible"], "method_name": "JAutoSuggest.hideSuggest", "method_implementation": "{\n    dialog.setVisible(false);\n}", "repo_id": "9", "comment": "/**\n * Force the suggestions to be hidden (Useful for buttons, e.g. to use\n * JSuggestionField like a ComboBox)\n */\n", "repo_name": "biojava-master/", "id": 3247, "method_signature": "void hideSuggest()"}, "1362": {"callee_method_names": ["List<Atom>.size"], "method_name": "AminoAcidImpl.toString", "method_implementation": "{\n    String str = \"AminoAcid \" + recordType + \":\" + pdb_name + \" \" + amino_char + \" \" + residueNumber + \" \" + pdb_flag + \" \" + recordType;\n    if (pdb_flag) {\n        str = str + \" atoms: \" + atoms.size();\n    }\n    if (!getAltLocs().isEmpty())\n        str += \" has altLocs :\" + getAltLocs().size();\n    return str;\n}", "repo_id": "9", "comment": "/**\n * string representation.\n */\n", "repo_name": "biojava-master/", "id": 1362, "method_signature": "String toString()"}, "345": {"callee_method_names": ["Atom.getX", "Atom.getX", "Atom.getY", "Atom.getY", "Atom.getZ", "Atom.getZ"], "method_name": "Calc.getDistanceFast", "method_implementation": "{\n    double x = a.getX() - b.getX();\n    double y = a.getY() - b.getY();\n    double z = a.getZ() - b.getZ();\n    return x * x + y * y + z * z;\n}", "repo_id": "9", "comment": "/**\n * Will calculate the square of distances between two atoms. This will be\n * faster as it will not perform the final square root to get the actual\n * distance. Use this if doing large numbers of distance comparisons - it is\n * marginally faster than getDistance().\n *\n * @param a\n *            an Atom object\n * @param b\n *            an Atom object\n * @return a double\n */\n", "repo_name": "biojava-master/", "id": 345, "method_signature": "double getDistanceFast(Atom, Atom)"}, "2377": {"callee_method_ids": [2385], "callee_method_names": ["TwoBitParser.close"], "method_name": "TwoBitFacade.close", "method_implementation": "{\n    if (twoBitParser != null)\n        twoBitParser.close();\n}", "repo_id": "9", "comment": "/**\n *  Closes .2bit file twoBitParser.\n */\n", "repo_name": "biojava-master/", "id": 2377, "method_signature": "void close()"}, "282": {"callee_method_names": ["Group.getAtom", "Group.getAtom", "Atom.hasBond", "Atom.getElement", "Atom.getElement", "Atom.getElement", "Atom.getElement", "Atom[].getElement", "Atom[].getElement"], "method_name": "StructureUtil.findLinkage", "method_implementation": "{\n    Atom[] ret = new Atom[2];\n    ret[0] = group1.getAtom(nameOfAtomOnGroup1);\n    ret[1] = group2.getAtom(nameOfAtomOnGroup2);\n    if (ret[0] == null || ret[1] == null) {\n        return null;\n    }\n    Atom a1 = ret[0];\n    Atom a2 = ret[1];\n    boolean hasBond = a1.hasBond(a2);\n    if (hasBond) {\n        return ret;\n    }\n    // is it a metal ?\n    if (a1.getElement().isMetal() || a2.getElement().isMetal()) {\n        MetalBondDistance defined = getMetalDistanceCutoff(a1.getElement().name(), a2.getElement().name());\n        if (defined != null) {\n            if (hasMetalBond(a1, a2, defined))\n                return ret;\n            else\n                return null;\n        }\n    }\n    // not a metal\n    double distance = Calc.getDistance(a1, a2);\n    float radiusOfAtom1 = ret[0].getElement().getCovalentRadius();\n    float radiusOfAtom2 = ret[1].getElement().getCovalentRadius();\n    if (Math.abs(distance - radiusOfAtom1 - radiusOfAtom2) > bondLengthTolerance) {\n        return null;\n    }\n    return ret;\n}", "repo_id": "9", "comment": "/**\n * Find a linkage between two groups within tolerance of bond length.\n * @param group1 the first {@link Group}.\n * @param group2 the second {@link Group}.\n * @param nameOfAtomOnGroup1 atom name of the first group.\n * @param nameOfAtomOnGroup2 atom name of the second group.\n * @param bondLengthTolerance bond length error tolerance.\n * @return an array of two Atoms that form bond between each other\n *  if found; null, otherwise.\n */\n", "repo_name": "biojava-master/", "id": 282, "method_signature": "Atom[] findLinkage(Group, Group, String, String, double)"}, "3748": {"callee_method_ids": [3698], "callee_method_names": ["LinkedHashMap.get", "HeaderInfo.getIndex"], "method_name": "WorkSheet.getRowIndex", "method_implementation": "{\n    HeaderInfo headerInfo = rowLookup.get(row);\n    if (headerInfo == null) {\n        throw new Exception(\"Row \" + row + \" not found\");\n    }\n    return headerInfo.getIndex();\n}", "repo_id": "9", "comment": "/**\n * @param row\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3748, "method_signature": "Integer getRowIndex(String)"}, "1794": {"callee_method_names": [], "method_name": "EcodDomain.getAssemblyId", "method_implementation": "{\n    return assemblyId;\n}", "repo_id": "9", "comment": "/**\n * @return The assembly ID, or the DomainId if not in an assembly, or null if unknown.\n */\n", "repo_name": "biojava-master/", "id": 1794, "method_signature": "Long getAssemblyId()"}, "3419": {"callee_method_ids": [1971, 1885, 1884], "callee_method_names": ["HelixAxisAligner.getSubunits", "QuatSymmetrySubunits.getSubunitCount", "QuatSymmetrySubunits.getModelNumbers", "QuatSymmetrySubunits.getChainIds", "QuatSymmetrySubunits.getClusterIds", "List<Integer>.get", "Map<Color4f, List<String>>.get", "Map<Color4f, List<String>>.put", "List<String>.add"], "method_name": "JmolSymmetryScriptGeneratorH.colorBySequenceCluster", "method_implementation": "{\n    QuatSymmetrySubunits subunits = helixAxisAligner.getSubunits();\n    int n = subunits.getSubunitCount();\n    List<Integer> modelNumbers = subunits.getModelNumbers();\n    List<String> chainIds = subunits.getChainIds();\n    List<Integer> seqClusterIds = subunits.getClusterIds();\n    int clusters = Collections.max(seqClusterIds) + 1;\n    Color[] col = ColorBrewer.BrBG.getColorPalette(clusters);\n    Color4f[] colors = ColorConverter.convertColor4f(col);\n    Map<Color4f, List<String>> colorMap = new HashMap<Color4f, List<String>>();\n    for (int i = 0; i < n; i++) {\n        Color4f c = colors[seqClusterIds.get(i)];\n        List<String> ids = colorMap.get(c);\n        if (ids == null) {\n            ids = new ArrayList<String>();\n            colorMap.put(c, ids);\n        }\n        String id = getChainSpecification(modelNumbers, chainIds, i);\n        ids.add(id);\n    }\n    String coloring = defaultColoring + getJmolColorScript(colorMap);\n    return coloring;\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script that colors subunits by their sequence cluster ids.\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3419, "method_signature": "String colorBySequenceCluster()"}, "3568": {"callee_method_names": [], "method_name": "CoxR.coxsafe", "method_implementation": "{\n    if (x < -200) {\n        return -200;\n    }\n    if (x > 22) {\n        return 22;\n    }\n    return x;\n}", "repo_id": "9", "comment": "/**\n * @param x\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3568, "method_signature": "double coxsafe(double)"}, "1632": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getClustererMethod", "method_implementation": "{\n    return clustererMethod;\n}", "repo_id": "9", "comment": "/**\n * Method to cluster subunits.\n *\n * @return clustererMethod\n */\n", "repo_name": "biojava-master/", "id": 1632, "method_signature": "SubunitClustererMethod getClustererMethod()"}, "1552": {"callee_method_names": ["Logger.info"], "method_name": "ScopInstallation.downloadFileFromRemote", "method_implementation": "{\n    logger.info(\"Downloading \" + remoteURL + \" to: \" + localFile);\n    FileDownloadUtils.createValidationFiles(remoteURL, localFile, null, FileDownloadUtils.Hash.UNKNOWN);\n    FileDownloadUtils.downloadFile(remoteURL, localFile);\n    if (!FileDownloadUtils.validateFile(localFile))\n        throw new IOException(\"Downloaded file invalid: \" + localFile);\n}", "repo_id": "9", "comment": "/**\n * Downloads the SCOP installation file +/- its validation metadata files.\n * @param remoteURL The remote file to download\n * @param localFile the local file to download to\n * @throws IOException in cases of file I/O, including failure to download a healthy (non-corrupted) file.\n */\n", "repo_name": "biojava-master/", "id": 1552, "method_signature": "void downloadFileFromRemote(URL, File)"}, "920": {"callee_method_names": ["HashMap<Pair<ResidueIdentifier>, GroupContact>.get", "Group.getResidueNumber", "Group.getResidueNumber"], "method_name": "GroupContactSet.getContact", "method_implementation": "{\n    return contacts.get(new Pair<ResidueNumber>(group1.getResidueNumber(), group2.getResidueNumber()));\n}", "repo_id": "9", "comment": "/**\n * Returns the corresponding GroupContact or null if no contact exists between the 2 given groups\n * @param group1\n * @param group2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 920, "method_signature": "GroupContact getContact(Group, Group)"}, "779": {"callee_method_names": [], "method_name": "CeCPMain.calculateMinCP", "method_implementation": "{\n    CPRange range = new CPRange();\n    // Find the cut point within the alignment.\n    // Either returns the index i of the alignment such that block[i] == ca2len,\n    // or else returns -i-1 where block[i] is the first element > ca2len.\n    int middle = Arrays.binarySearch(block, ca2len);\n    if (middle < 0) {\n        middle = -middle - 1;\n    }\n    // Middle is now the first res after the duplication\n    range.mid = middle;\n    int minCPntermIndex = middle - minCPlength;\n    if (minCPntermIndex >= 0) {\n        range.n = block[minCPntermIndex];\n    } else {\n        range.n = -1;\n    }\n    int minCPctermIndex = middle + minCPlength - 1;\n    if (minCPctermIndex < blockLen) {\n        range.c = block[minCPctermIndex];\n    } else {\n        range.c = ca2len * 2;\n    }\n    // Stub:\n    // Best-case: assume all residues in the termini are aligned\n    //range.n = ca2len - minCPlength;\n    //range.c = ca2len + minCPlength-1;\n    return range;\n}", "repo_id": "9", "comment": "/**\n * Finds the alignment index of the residues minCPlength before and after\n * the duplication.\n *\n * @param block The permuted block being considered, generally optAln[0][1]\n * @param blockLen The length of the block (in case extra memory was allocated in block)\n * @param ca2len The length, in residues, of the protein specified by block\n * @param minCPlength The minimum number of residues allowed for a CP\n * @return a CPRange with the following components:\n *  <dl><dt>n</dt><dd>Index into <code>block</code> of the residue such that\n *  \t<code>minCPlength</code> residues remain to the end of <code>ca2len</code>,\n *  \tor -1 if no residue fits that criterium.</dd>\n *  <dt>mid</dt><dd>Index of the first residue higher than <code>ca2len</code>.</dd>\n *  <dt>c</dt><dd>Index of <code>minCPlength</code>-th residue after ca2len,\n *  \tor ca2len*2 if no residue fits that criterium.</dd>\n *  </dl>\n */\n", "repo_name": "biojava-master/", "id": 779, "method_signature": "CPRange calculateMinCP(int[], int, int, int)"}, "1787": {"callee_method_names": [], "method_name": "PDBHeader.setRwork", "method_implementation": "{\n    this.rWork = rWork;\n}", "repo_id": "9", "comment": "/**\n * @param rWork  the R-work for this structure.\n */\n", "repo_name": "biojava-master/", "id": 1787, "method_signature": "void setRwork(float)"}, "2423": {"callee_method_ids": [2421, 2421], "callee_method_names": ["Location.isNegative", "Location.isNegative"], "method_name": "Location.isSameStrand", "method_implementation": "{\n    return (isNegative() && other.isNegative()) || (!isNegative() && !other.isNegative());\n}", "repo_id": "9", "comment": "/**\n * Check if this location is on same strand as other location.\n *\n * @param other The location to compare.\n * @return True if on same strand.\n */\n", "repo_name": "biojava-master/", "id": 2423, "method_signature": "boolean isSameStrand(Location)"}, "1348": {"callee_method_names": [], "method_name": "EntityInfo.getChains", "method_implementation": "{\n    return this.chains;\n}", "repo_id": "9", "comment": "/**\n * Get the list of chains that are part of this EntityInfo. Note that for multi-model\n * structures chains from all models are returned.\n *\n * @return a List of Chain objects\n */\n", "repo_name": "biojava-master/", "id": 1348, "method_signature": "List<Chain> getChains()"}, "2474": {"callee_method_names": ["OutputStream.write", "LinkedHashMap<String,ChromosomeSequence>.keySet", "LinkedHashMap<String,ChromosomeSequence>.get", "ChromosomeSequence.getGeneSequences", "OutputStream.write", "String.getBytes", "OutputStream.write", "String.getBytes", "OutputStream.write", "String.getBytes"], "method_name": "GFF3Writer.write", "method_implementation": "{\n    outputStream.write(\"##gff-version 3\\n\".getBytes());\n    for (String key : chromosomeSequenceList.keySet()) {\n        ChromosomeSequence chromosomeSequence = chromosomeSequenceList.get(key);\n        String gff3line = \"\";\n        //         if(source.length() == 0){\n        //             Collection<GeneSequence> genes = chromosomeSequence.getGeneSequences().values();\n        //             for(GeneSequence gene : genes){\n        //                 source = gene.getSource();\n        //                 break;\n        //             }\n        //         }\n        //         gff3line = key + \"\\t\" + source + \"\\t\" + \"size\" + \"\\t\" + \"1\" + \"\\t\" + chromosomeSequence.getBioEnd() + \"\\t.\\t.\\t.\\tName=\" + key + \"\\r\\n\";\n        //         outputStream.write(gff3line.getBytes());\n        for (GeneSequence geneSequence : chromosomeSequence.getGeneSequences().values()) {\n            gff3line = key + \"\\t\" + geneSequence.getSource() + \"\\t\" + \"gene\" + \"\\t\" + geneSequence.getBioBegin() + \"\\t\" + geneSequence.getBioEnd() + \"\\t\";\n            Double score = geneSequence.getSequenceScore();\n            if (score == null) {\n                gff3line = gff3line + \".\\t\";\n            } else {\n                gff3line = gff3line + score + \"\\t\";\n            }\n            gff3line = gff3line + geneSequence.getStrand().getStringRepresentation() + \"\\t\";\n            gff3line = gff3line + \".\\t\";\n            gff3line = gff3line + \"ID=\" + geneSequence.getAccession().getID() + \";Name=\" + geneSequence.getAccession().getID();\n            gff3line = gff3line + getGFF3Note(geneSequence.getNotesList());\n            gff3line = gff3line + \"\\n\";\n            outputStream.write(gff3line.getBytes());\n            int transcriptIndex = 0;\n            for (TranscriptSequence transcriptSequence : geneSequence.getTranscripts().values()) {\n                transcriptIndex++;\n                gff3line = key + \"\\t\" + transcriptSequence.getSource() + \"\\t\" + \"mRNA\" + \"\\t\" + transcriptSequence.getBioBegin() + \"\\t\" + transcriptSequence.getBioEnd() + \"\\t\";\n                score = transcriptSequence.getSequenceScore();\n                if (score == null) {\n                    gff3line = gff3line + \".\\t\";\n                } else {\n                    gff3line = gff3line + score + \"\\t\";\n                }\n                gff3line = gff3line + transcriptSequence.getStrand().getStringRepresentation() + \"\\t\";\n                gff3line = gff3line + \".\\t\";\n                String id = geneSequence.getAccession().getID() + \".\" + transcriptIndex;\n                gff3line = gff3line + \"ID=\" + id + \";Parent=\" + geneSequence.getAccession().getID() + \";Name=\" + id;\n                gff3line = gff3line + getGFF3Note(transcriptSequence.getNotesList());\n                gff3line = gff3line + \"\\n\";\n                outputStream.write(gff3line.getBytes());\n                String transcriptParentName = geneSequence.getAccession().getID() + \".\" + transcriptIndex;\n                ArrayList<CDSSequence> cdsSequenceList = new ArrayList<CDSSequence>(transcriptSequence.getCDSSequences().values());\n                Collections.sort(cdsSequenceList, new SequenceComparator());\n                for (CDSSequence cdsSequence : cdsSequenceList) {\n                    gff3line = key + \"\\t\" + cdsSequence.getSource() + \"\\t\" + \"CDS\" + \"\\t\" + cdsSequence.getBioBegin() + \"\\t\" + cdsSequence.getBioEnd() + \"\\t\";\n                    score = cdsSequence.getSequenceScore();\n                    if (score == null) {\n                        gff3line = gff3line + \".\\t\";\n                    } else {\n                        gff3line = gff3line + score + \"\\t\";\n                    }\n                    gff3line = gff3line + cdsSequence.getStrand().getStringRepresentation() + \"\\t\";\n                    gff3line = gff3line + cdsSequence.getPhase() + \"\\t\";\n                    gff3line = gff3line + \"ID=\" + cdsSequence.getAccession().getID() + \";Parent=\" + transcriptParentName;\n                    gff3line = gff3line + getGFF3Note(cdsSequence.getNotesList());\n                    gff3line = gff3line + \"\\n\";\n                    outputStream.write(gff3line.getBytes());\n                }\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Output gff3 format for a DNA Sequence\n * @param outputStream\n * @param chromosomeSequenceList\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2474, "method_signature": "void write(OutputStream, LinkedHashMap)"}, "526": {"callee_method_names": ["DocumentBuilderFactory.newDocumentBuilder", "InputSource.setCharacterStream", "DocumentBuilder.parse", "Document.getDocumentElement", "Document.getElementsByTagName", "NodeList.getLength", "NodeList.item", "List<MultipleAlignmentEnsemble>.add"], "method_name": "MultipleAlignmentXMLParser.parseXMLfile", "method_implementation": "{\n    List<MultipleAlignmentEnsemble> ensembles = new ArrayList<MultipleAlignmentEnsemble>();\n    //Convert string to XML document\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    DocumentBuilder db = factory.newDocumentBuilder();\n    InputSource inStream = new InputSource();\n    inStream.setCharacterStream(new StringReader(xml));\n    Document doc = db.parse(inStream);\n    doc.getDocumentElement().normalize();\n    //In case there are more than one ensemble in the document (generalize)\n    NodeList listOfEnsembles = doc.getElementsByTagName(\"MultipleAlignmentEnsemble\");\n    //Explore all the ensembles, if multiple ones\n    for (int e = 0; e < listOfEnsembles.getLength(); e++) {\n        Node root = listOfEnsembles.item(e);\n        MultipleAlignmentEnsemble ensemble = parseEnsemble(root);\n        ensembles.add(ensemble);\n    }\n    return ensembles;\n}", "repo_id": "9", "comment": "/**\n * Creates a list of MultipleAlignment ensembles from an XML file.\n * This recovers only the information that was previously stored.\n * If the Atoms are needed, the method getAtomArrays() will automatically\n * download the structures from the stored structure identifiers.\n *\n * @param xml String XML file containing any number of ensembles\n * @return List of ensembles in the file\n * @throws ParserConfigurationException\n * @throws SAXException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 526, "method_signature": "List<MultipleAlignmentEnsemble> parseXMLfile(String)"}, "3545": {"callee_method_names": [], "method_name": "CoxCoefficient.setZ", "method_implementation": "{\n    this.z = z;\n}", "repo_id": "9", "comment": "/**\n * @param z the z to set\n */\n", "repo_name": "biojava-master/", "id": 3545, "method_signature": "void setZ(double)"}, "1587": {"callee_method_names": ["BetaBridge.equals", "BetaBridge.equals", "Logger.info"], "method_name": "SecStrucState.addBridge", "method_implementation": "{\n    if (bridge1 == null) {\n        bridge1 = bridge;\n        return true;\n    } else if (bridge1.equals(bridge)) {\n        return true;\n    } else if (bridge2 == null) {\n        bridge2 = bridge;\n        return true;\n    } else if (bridge2.equals(bridge)) {\n        return true;\n    } else {\n        //no space left, cannot add the bridge\n        logger.info(\"Residue forms more than 2 beta Bridges, \" + \"DSSP output might differ in Bridges column.\");\n        return false;\n    }\n}", "repo_id": "9", "comment": "/**\n * Adds a Bridge to the residue. Each residue can only store two bridges. If\n * the residue contains already two Bridges, the Bridge will not be added\n * and the method returns false.\n *\n * @param bridge\n * @return false if the Bridge was not added, true otherwise\n */\n", "repo_name": "biojava-master/", "id": 1587, "method_signature": "boolean addBridge(BetaBridge)"}, "811": {"callee_method_names": [], "method_name": "AlternativeAlignment.getCluster", "method_implementation": "{\n    return cluster;\n}", "repo_id": "9", "comment": "/**\n * get the number of the cluster this alignment belongs to\n *\n * @return an int giving the number of the cluster\n */\n", "repo_name": "biojava-master/", "id": 811, "method_signature": "int getCluster()"}, "2392": {"callee_method_names": [], "method_name": "Location.bioStrand", "method_implementation": "{\n    return (isNegative()) ? '-' : '+';\n}", "repo_id": "9", "comment": "/**\n * Get character representation of strand.\n *\n * @return '+' or '-'\n */\n", "repo_name": "biojava-master/", "id": 2392, "method_signature": "char bioStrand()"}, "520": {"callee_method_names": ["AFPChain.getName1", "AFPChain.getName2", "String.equals", "String.equals"], "method_name": "AFPChainXMLParser.fromXML", "method_implementation": "{\n    AFPChain[] afps = parseMultiXML(xml);\n    if (afps.length > 0) {\n        AFPChain afpChain = afps[0];\n        String n1 = afpChain.getName1();\n        String n2 = afpChain.getName2();\n        if (n1 == null)\n            n1 = \"\";\n        if (n2 == null)\n            n2 = \"\";\n        //System.out.println(\"from AFPCHAIN: \" + n1 + \" \" + n2);\n        if (n1.equals(name2) && n2.equals(name1)) {\n            // flipped order\n            //System.out.println(\"AfpChain in wrong order, flipping...\");\n            afpChain = AFPChainFlipper.flipChain(afpChain);\n        }\n        rebuildAFPChain(afpChain, ca1, ca2);\n        return afpChain;\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * new utility method that checks that the order of the pair in the XML alignment is correct and flips the direction if needed\n *\n * @param xml\n * @param name1\n * @param name1\n * @param ca1\n * @param ca2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 520, "method_signature": "AFPChain fromXML(String, String, String, Atom[], Atom[])"}, "3053": {"callee_method_names": ["List<Location>.get", "Path.getStrand"], "method_name": "LocationHelper.detectStrand", "method_implementation": "{\n    Strand strand = subLocations.get(0).getStrand();\n    for (Location sub : subLocations) {\n        if (strand != sub.getStrand()) {\n            strand = Strand.UNDEFINED;\n            break;\n        }\n    }\n    return strand;\n}", "repo_id": "9", "comment": "/**\n * Loops through the given list of locations and returns the consensus\n * Strand class. If the class switches then we will return an undefined\n * strand\n */\n", "repo_name": "biojava-master/", "id": 3053, "method_signature": "Strand detectStrand(List)"}, "884": {"callee_method_names": ["Map<ResidueNumber, GroupAsa>.get"], "method_name": "StructureInterface.getFirstGroupAsa", "method_implementation": "{\n    return groupAsas1.get(resNum);\n}", "repo_id": "9", "comment": "/**\n * Gets the GroupAsa for the corresponding residue number of first chain\n * @param resNum\n * @return\n */\n", "repo_name": "biojava-master/", "id": 884, "method_signature": "GroupAsa getFirstGroupAsa(ResidueNumber)"}, "2848": {"callee_method_names": ["S.setOriginalHeader", "S.setAccession"], "method_name": "PlainFastaHeaderParser.parseHeader", "method_implementation": "{\n    sequence.setOriginalHeader(header);\n    String[] data = getHeaderValues(header);\n    if (data.length == 1) {\n        sequence.setAccession(new AccessionID(data[0]));\n    } else {\n        throw new RuntimeException(\"No header or Some Error Occurred while reading header\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Parse the header and set the values in the sequence\n *\n * @param header\n * @param sequence\n */\n", "repo_name": "biojava-master/", "id": 2848, "method_signature": "void parseHeader(String, S)"}, "2808": {"callee_method_names": ["InputStream.read", "OutputStream.write"], "method_name": "IOUtils.copy", "method_implementation": "{\n    byte[] buffer = new byte[BUFFER];\n    int n = 0;\n    while (-1 != (n = input.read(buffer))) {\n        output.write(buffer, 0, n);\n    }\n}", "repo_id": "9", "comment": "/**\n * Moves the bytes from input to output using a 4KB byte array.\n *\n * @param input Input stream of bytes\n * @param output Output stream of bytes\n * @throws IOException If anything occurs in the case of the reads and writes\n */\n", "repo_name": "biojava-master/", "id": 2808, "method_signature": "void copy(InputStream, OutputStream)"}, "2485": {"callee_method_names": ["GeneChromosomePosition.getOrientation"], "method_name": "ChromosomeMappingTools.getCDSExonRanges", "method_implementation": "{\n    if (chromPos.getOrientation() == '+')\n        return getCDSExonRangesForward(chromPos, CDS);\n    return getCDSExonRangesReverse(chromPos, CDS);\n}", "repo_id": "9", "comment": "/**\n * Extracts the exon boundaries in CDS coordinates. (needs to be divided by 3 to get AA positions)\n *\n * @param chromPos\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2485, "method_signature": "List<Range<Integer>> getCDSExonRanges(GeneChromosomePosition)"}, "1854": {"callee_method_names": [], "method_name": "Rotation.setTraceRmsd", "method_implementation": "{\n    this.traceRmsd = traceRmsd;\n}", "repo_id": "9", "comment": "/**\n * @param traceRmsd the traceRmsd to set\n */\n", "repo_name": "biojava-master/", "id": 1854, "method_signature": "void setTraceRmsd(double)"}, "3805": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getxAxisTimeCoordinates", "method_implementation": "{\n    return xAxisTimeCoordinates;\n}", "repo_id": "9", "comment": "/**\n * @return the xAxisTimeValues\n */\n", "repo_name": "biojava-master/", "id": 3805, "method_signature": "ArrayList<Integer> getxAxisTimeCoordinates()"}, "276": {"callee_method_names": ["Atom.getGroup", "Group.getChainId", "StructureGroup.setChainId", "Atom.getName"], "method_name": "StructureUtil.getStructureAtom", "method_implementation": "{\n    Group g = atom.getGroup();\n    String chainId = g.getChainId();\n    StructureGroup strucGroup = getStructureGroup(g, isParentAminoAcid);\n    strucGroup.setChainId(chainId);\n    return new StructureAtom(strucGroup, atom.getName());\n}", "repo_id": "9", "comment": "/**\n * @param atom a {@link Atom} in structure.\n * @param isParentAminoAcid true if the containing group is an amino acid.\n * @return the {@link StructureAtom} of the atom.\n */\n", "repo_name": "biojava-master/", "id": 276, "method_signature": "StructureAtom getStructureAtom(Atom, boolean)"}, "755": {"callee_method_names": [], "method_name": "CeParameters.getORmsdThr", "method_implementation": "{\n    return oRmsdThr;\n}", "repo_id": "9", "comment": "/**\n * Get the Original RMSD threshold from which the alignment optimization is started\n *\n * @return oRMSDThreshold\n */\n", "repo_name": "biojava-master/", "id": 755, "method_signature": "Double getORmsdThr()"}, "2733": {"callee_method_names": [], "method_name": "EmblId.getTaxonomicDivision", "method_implementation": "{\n    return taxonomicDivision;\n}", "repo_id": "9", "comment": "/**\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2733, "method_signature": "String getTaxonomicDivision()"}, "1370": {"callee_method_names": ["Formatter.format", "StringBuffer.append", "Formatter.toString", "Formatter.close"], "method_name": "DBRef.toPDB", "method_implementation": "{\n    Formatter formatter = new Formatter(new StringBuilder(), Locale.UK);\n    //        DBREF  3ETA A  990  1295  UNP    P06213   INSR_HUMAN    1017   1322\n    //        DBREF  3EH2 A    2   767  UNP    P53992   SC24C_HUMAN    329   1094\n    //        DBREF 3EH2 A    2   767     UNP   P53992  SC24C_HUMAN   329   1094\n    //        DBREF  3ETA A  990  1295  UNP    P06213   INSR_HUMAN    1017   1322\n    formatter.format(\"DBREF  %4s %1s %4d%1s %4d%1s %-6s %-8s %-12s%6d%1c%6d%1c            \", idCode, chainName, seqbegin, insertBegin, seqEnd, insertEnd, database, dbAccession, dbIdCode, dbSeqBegin, idbnsBegin, dbSeqEnd, idbnsEnd);\n    buf.append(formatter.toString());\n    formatter.close();\n}", "repo_id": "9", "comment": "/**\n * Append the PDB representation of this DBRef to the provided StringBuffer\n *\n * @param buf the StringBuffer to write to.\n */\n", "repo_name": "biojava-master/", "id": 1370, "method_signature": "void toPDB(StringBuffer)"}, "2552": {"callee_method_names": ["List<Sequence>.size", "List<Sequence>.size", "Map<String, Sequence>.put", "List<Sequence>.get", "List<Sequence>.size", "List<Sequence>.size", "Map<String, Sequence>.put", "List<Sequence>.get"], "method_name": "BlastXMLParser.mapIds", "method_implementation": "{\n    if (queryReferences != null) {\n        queryReferencesMap = new HashMap<String, Sequence>(queryReferences.size());\n        for (int counter = 0; counter < queryReferences.size(); counter++) {\n            String id = \"Query_\" + (counter + 1);\n            queryReferencesMap.put(id, queryReferences.get(counter));\n        }\n    }\n    if (databaseReferences != null) {\n        databaseReferencesMap = new HashMap<String, Sequence>(databaseReferences.size());\n        for (int counter = 0; counter < databaseReferences.size(); counter++) {\n            // this is strange: while Query_id are 1 based, Hit (database) id are 0 based\n            String id = \"gnl|BL_ORD_ID|\" + (counter);\n            databaseReferencesMap.put(id, databaseReferences.get(counter));\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * fill the map association between sequences an a unique id\n */\n", "repo_name": "biojava-master/", "id": 2552, "method_signature": "void mapIds()"}, "1672": {"callee_method_names": [], "method_name": "Subunit.getProteinSequence", "method_implementation": "{\n    if (sequence == null)\n        sequence = new ProteinSequence(getProteinSequenceString());\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Get the protein sequence of the Subunit.\n *\n * @return sequence ProteinSequence\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 1672, "method_signature": "ProteinSequence getProteinSequence()"}, "3772": {"callee_method_names": [], "method_name": "WorkSheet.getIndexColumnName", "method_implementation": "{\n    return indexColumnName;\n}", "repo_id": "9", "comment": "/**\n * @return the indexColumnName\n */\n", "repo_name": "biojava-master/", "id": 3772, "method_signature": "String getIndexColumnName()"}, "3384": {"callee_method_names": ["Polyhedron.getViewCount"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getOrientationCount", "method_implementation": "{\n    return polyhedron.getViewCount();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#getOrientationCount()\n\t */\n", "repo_name": "biojava-master/", "id": 3384, "method_signature": "int getOrientationCount()"}, "1850": {"callee_method_names": [], "method_name": "QuatSymmetryDetector.calcLocalSymmetries", "method_implementation": "{\n    Stoichiometry composition = SubunitClusterer.cluster(subunits, clusterParams);\n    return calcLocalSymmetries(composition, symmParams);\n}", "repo_id": "9", "comment": "/**\n * Returns a List of LOCAL symmetry results. This means that a subset of the\n * {@link SubunitCluster} is left out of the symmetry calculation. Each\n * element of the List is one possible LOCAL symmetry result.\n * <p>\n * Determine local symmetry if global structure is: (1) asymmetric, C1; (2)\n * heteromeric (belongs to more than 1 subunit cluster); (3) more than 2\n * subunits (heteromers with just 2 chains cannot have local symmetry)\n *\n * @param subunits\n *            list of {@link Subunit}\n * @param symmParams\n *            quaternary symmetry parameters\n * @param clusterParams\n *            subunit clustering parameters\n * @return List of LOCAL quaternary structure symmetry results. Empty if\n *         none.\n */\n", "repo_name": "biojava-master/", "id": 1850, "method_signature": "List<QuatSymmetryResults> calcLocalSymmetries(List, QuatSymmetryParameters, SubunitClustererParameters)"}, "2883": {"callee_method_names": ["Appendable.append", "AminoAcidCompound.toString"], "method_name": "SequenceMixin.write", "method_implementation": "{\n    for (C compound : sequence) {\n        appendable.append(compound.toString());\n    }\n}", "repo_id": "9", "comment": "/**\n * Used as a way of sending a Sequence to a writer without the cost of\n * converting to a full length String and then writing the data out\n *\n * @param <C> Type of compound\n * @param writer The writer to send data to\n * @param sequence The sequence to write out\n * @throws IOException Thrown if we encounter a problem\n */\n", "repo_name": "biojava-master/", "id": 2883, "method_signature": "void write(Appendable, Sequence)"}, "2727": {"callee_method_names": [], "method_name": "FastaGeneWriter.setLineLength", "method_implementation": "{\n    this.lineLength = lineLength;\n}", "repo_id": "9", "comment": "/**\n * @param lineLength the lineLength to set\n */\n", "repo_name": "biojava-master/", "id": 2727, "method_signature": "void setLineLength(int)"}, "3796": {"callee_method_names": ["FileWriter.write", "LinkedHashMap<String,ArrayList<CensorStatus>>.keySet", "LinkedHashMap<String,ArrayList<CensorStatus>>.get", "FileWriter.write", "FileWriter.close"], "method_name": "KaplanMeierFigure.saveSurvivalData", "method_implementation": "{\n    FileWriter fw = new FileWriter(fileName);\n    fw.write(\"index\\tTIME\\tSTATUS\\tGROUP\\r\\n\");\n    int index = 0;\n    for (String group : survivalData.keySet()) {\n        ArrayList<CensorStatus> sd = survivalData.get(group);\n        for (CensorStatus cs : sd) {\n            String line = index + \"\\t\" + cs.time + \"\\t\" + cs.censored + \"\\t\" + cs.group + \"\\r\\n\";\n            index++;\n            fw.write(line);\n        }\n    }\n    fw.close();\n}", "repo_id": "9", "comment": "/**\n * Save data from survival curve to text file\n *\n * @param fileName\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3796, "method_signature": "void saveSurvivalData(String)"}, "1991": {"callee_method_names": ["Map<Double, List<Integer>>.get", "Map<Double, List<Integer>>.put", "List<List<Integer>>.clear", "Map<Double, List<Integer>>.values", "List<List<Integer>>.add"], "method_name": "RotationAxisAligner.getOrbitsByXYWidth", "method_implementation": "{\n    Map<Double, List<Integer>> widthMap = new TreeMap<Double, List<Integer>>();\n    double[] width = getSubunitXYWidth();\n    List<List<Integer>> orbits = calcOrbits();\n    // calculate the mean width of orbits in XY-plane\n    for (List<Integer> orbit : orbits) {\n        double meanWidth = 0;\n        for (int subunit : orbit) {\n            meanWidth += width[subunit];\n        }\n        meanWidth /= orbit.size();\n        if (widthMap.get(meanWidth) != null) {\n            meanWidth += 0.01;\n        }\n        widthMap.put(meanWidth, orbit);\n    }\n    // now fill orbits back into list ordered by width\n    orbits.clear();\n    for (List<Integer> orbit : widthMap.values()) {\n        orbits.add(orbit);\n    }\n    return orbits;\n}", "repo_id": "9", "comment": "/**\n */\n", "repo_name": "biojava-master/", "id": 1991, "method_signature": "List<List<Integer>> getOrbitsByXYWidth()"}, "1898": {"callee_method_names": ["Function<List<SubunitCluster>,String>.apply", "ArrayList.forEach", "StringBuilder.append", "double.getAlpha", "double.getAlpha", "double.size", "StringBuilder.append", "double.size", "StringBuilder.toString"], "method_name": "Stoichiometry.toString", "method_implementation": "{\n    if (strategy == StringOverflowStrategy.CUSTOM) {\n        if (customStringGenerator == null) {\n            throw new IllegalStateException(\"The strategy is CUSTOM, yet the string generator function is not defined.\");\n        }\n        return customStringGenerator.apply(orderedClusters);\n    }\n    StringBuilder formula = new StringBuilder();\n    orderedClusters.forEach((SubunitCluster r) -> {\n        formula.append(r.getAlpha());\n        if (r.getAlpha().length() > 1 || r.size() > 1)\n            formula.append(r.size());\n    });\n    return formula.toString();\n}", "repo_id": "9", "comment": "/**\n * @return Human-readable representation of this stoichiometry.\n */\n", "repo_name": "biojava-master/", "id": 1898, "method_signature": "String toString()"}, "1313": {"callee_method_names": ["String.length", "String.toCharArray", "List<Object>.add"], "method_name": "FastaAFPChainConverter.getAlignedUserCollection", "method_implementation": "{\n    List<Object> aligned = new ArrayList<Object>(sequence.length());\n    for (char c : sequence.toCharArray()) {\n        aligned.add(Character.isUpperCase(c));\n    }\n    return aligned;\n}", "repo_id": "9", "comment": "/**\n * Takes a protein sequence string with capital and lowercase letters and sets its {@link ProteinSequence#getUserCollection() user collection} to record which letters are uppercase (aligned) and which are lowercase (unaligned).\n * @param sequence Make sure <em>not</em> to use {@link ProteinSequence#getSequenceAsString()} for this, as it won't preserve upper- and lower-case\n */\n", "repo_name": "biojava-master/", "id": 1313, "method_signature": "List<Object> getAlignedUserCollection(String)"}, "3826": {"callee_method_ids": [3756, 3741, 3756, 3741, 3736, 3736, 3736], "callee_method_names": ["WorkSheet.getRows", "WorkSheet.getCell", "DescriptiveStatistics.addValue", "DescriptiveStatistics.getMean", "WorkSheet.getRows", "WorkSheet.getCell", "WorkSheet.addCell", "WorkSheet.addCell", "WorkSheet.addCell"], "method_name": "MeanQuantizer.process", "method_implementation": "{\n    DescriptiveStatistics ds = new DescriptiveStatistics();\n    for (String row : worksheet.getRows()) {\n        try {\n            Double d = Double.parseDouble(worksheet.getCell(row, column));\n            ds.addValue(d);\n        } catch (Exception e) {\n        }\n    }\n    Double mean = ds.getMean();\n    for (String row : worksheet.getRows()) {\n        try {\n            Double d = Double.parseDouble(worksheet.getCell(row, column));\n            if (d < mean) {\n                worksheet.addCell(row, column, \"L\");\n            } else {\n                worksheet.addCell(row, column, \"H\");\n            }\n        } catch (Exception e) {\n            try {\n                worksheet.addCell(row, column, \"\");\n            } catch (Exception e1) {\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @param worksheet\n * @param column\n */\n", "repo_name": "biojava-master/", "id": 3826, "method_signature": "void process(WorkSheet, String)"}, "646": {"callee_method_names": ["Logger.debug", "MMTFFileReader.setFetchBehavior", "MMTFFileReader.setObsoleteBehavior", "MMTFFileReader.getStructureById"], "method_name": "AtomCache.loadStructureFromMmtfByPdbId", "method_implementation": "{\n    logger.debug(\"Loading structure {} from mmtf file.\", pdbId);\n    MMTFFileReader reader = new MMTFFileReader();\n    reader.setFetchBehavior(fetchBehavior);\n    reader.setObsoleteBehavior(obsoleteBehavior);\n    return reader.getStructureById(pdbId);\n}", "repo_id": "9", "comment": "/**\n * Load a {@link Structure} from MMTF either from the local file system.\n * @param pdbId the input PDB id\n * @return the {@link Structure} object of the parsed structure\n * @throws IOException error reading from Web or file system\n */\n", "repo_name": "biojava-master/", "id": 646, "method_signature": "Structure loadStructureFromMmtfByPdbId(PdbId)"}, "798": {"callee_method_names": [], "method_name": "CeStartupParams.setMaxGapSize", "method_implementation": "{\n    this.maxGapSize = maxGapSize;\n}", "repo_id": "9", "comment": "/**\n * CE specific parameter: set the Max gap size parameter G (during AFP extension). Default: 30\n *\n * @param maxGapSize\n */\n", "repo_name": "biojava-master/", "id": 798, "method_signature": "void setMaxGapSize(int)"}, "2956": {"callee_method_names": ["C.getConstituents", "Set<NucleotideCompound>.add", "C.getConstituents"], "method_name": "AbstractNucleotideCompoundSet.getAmbiguity", "method_implementation": "{\n    Set<NucleotideCompound> settedCompounds = new HashSet<NucleotideCompound>();\n    for (NucleotideCompound compound : compounds) {\n        for (NucleotideCompound subCompound : compound.getConstituents()) {\n            settedCompounds.add(getCompoundForString(subCompound.getBase().toUpperCase()));\n        }\n    }\n    for (NucleotideCompound compound : getAllCompounds()) {\n        if (compound.getConstituents().equals(settedCompounds)) {\n            return compound;\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Calculates the best symbol for a collection of compounds. For example\n * if you gave this method a AC it will return a M which is the ambiguity\n * symbol for these compounds.\n *\n * @param compounds Compounds to calculate ambiguity for\n * @return The ambiguity symbol which represents this set of nucleotides best\n */\n", "repo_name": "biojava-master/", "id": 2956, "method_signature": "NucleotideCompound getAmbiguity(NucleotideCompound[])"}, "3277": {"callee_method_names": ["ActionEvent.getSource", "ActionEvent.getSource", "JComboBox<String>.getSelectedItem"], "method_name": "JmolPanel.actionPerformed", "method_implementation": "{\n    Object mysource = event.getSource();\n    if (!(mysource instanceof JComboBox)) {\n        super.actionPerformed(event);\n        return;\n    }\n    @SuppressWarnings(\"unchecked\")\n    JComboBox<String> source = (JComboBox<String>) event.getSource();\n    String value = source.getSelectedItem().toString();\n    evalString(\"save selection; \");\n    String selectLigand = \"select ligand;wireframe 0.16;spacefill 0.5; color cpk ;\";\n    if (\"Cartoon\".equals(value)) {\n        String script = \"hide null; select all;  spacefill off; wireframe off; backbone off;\" + \" cartoon on; \" + \" select ligand; wireframe 0.16;spacefill 0.5; color cpk; \" + \" select *.FE; spacefill 0.7; color cpk ; \" + \" select *.CU; spacefill 0.7; color cpk ; \" + \" select *.ZN; spacefill 0.7; color cpk ; \" + \" select all; \";\n        this.executeCmd(script);\n    } else if (\"Backbone\".equals(value)) {\n        String script = \"hide null; select all; spacefill off; wireframe off; backbone 0.4;\" + \" cartoon off; \" + \" select ligand; wireframe 0.16;spacefill 0.5; color cpk; \" + \" select *.FE; spacefill 0.7; color cpk ; \" + \" select *.CU; spacefill 0.7; color cpk ; \" + \" select *.ZN; spacefill 0.7; color cpk ; \" + \" select all; \";\n        this.executeCmd(script);\n    } else if (\"CPK\".equals(value)) {\n        String script = \"hide null; select all; spacefill off; wireframe off; backbone off;\" + \" cartoon off; cpk on;\" + \" select ligand; wireframe 0.16;spacefill 0.5; color cpk; \" + \" select *.FE; spacefill 0.7; color cpk ; \" + \" select *.CU; spacefill 0.7; color cpk ; \" + \" select *.ZN; spacefill 0.7; color cpk ; \" + \" select all; \";\n        this.executeCmd(script);\n    } else if (\"Ligands\".equals(value)) {\n        this.executeCmd(\"restrict ligand; cartoon off; wireframe on;  display selected;\");\n    } else if (\"Ligands and Pocket\".equals(value)) {\n        this.executeCmd(\" select within (6.0,ligand); cartoon off; wireframe on; backbone off; display selected; \");\n    } else if (\"Ball and Stick\".equals(value)) {\n        String script = \"hide null; restrict not water;  wireframe 0.2; spacefill 25%;\" + \" cartoon off; backbone off; \" + \" select ligand; wireframe 0.16; spacefill 0.5; color cpk; \" + \" select *.FE; spacefill 0.7; color cpk ; \" + \" select *.CU; spacefill 0.7; color cpk ; \" + \" select *.ZN; spacefill 0.7; color cpk ; \" + \" select all; \";\n        this.executeCmd(script);\n    } else if (\"By Chain\".equals(value)) {\n        jmolColorByChain();\n        String script = \"hide null; select all;set defaultColors Jmol; color_by_chain(\\\"cartoon\\\"); color_by_chain(\\\"\\\"); \" + selectLigand + \"; select all; \";\n        this.executeCmd(script);\n    } else if (\"Rainbow\".equals(value)) {\n        this.executeCmd(\"hide null; select all; set defaultColors Jmol; color group; color cartoon group; \" + selectLigand + \"; select all; \");\n    } else if (\"Secondary Structure\".equals(value)) {\n        this.executeCmd(\"hide null; select all; set defaultColors Jmol; color structure; color cartoon structure;\" + selectLigand + \"; select all; \");\n    } else if (\"By Element\".equals(value)) {\n        this.executeCmd(\"hide null; select all; set defaultColors Jmol; color cpk; color cartoon cpk; \" + selectLigand + \"; select all; \");\n    } else if (\"By Amino Acid\".equals(value)) {\n        this.executeCmd(\"hide null; select all; set defaultColors Jmol; color amino; color cartoon amino; \" + selectLigand + \"; select all; \");\n    } else if (\"Hydrophobicity\".equals(value)) {\n        this.executeCmd(\"hide null; set defaultColors Jmol; select hydrophobic; color red; color cartoon red; select not hydrophobic ; color blue ; color cartoon blue; \" + selectLigand + \"; select all; \");\n    } else if (\"Suggest Domains\".equals(value)) {\n        colorByPDP();\n    } else if (\"Show SCOP Domains\".equals(value)) {\n        colorBySCOP();\n    }\n    evalString(\"restore selection; \");\n}", "repo_id": "9", "comment": "/**\n * The user selected one of the Combo boxes...\n *\n * @param event an ActionEvent\n */\n", "repo_name": "biojava-master/", "id": 3277, "method_signature": "void actionPerformed(ActionEvent)"}, "3797": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getTimeX", "method_implementation": "{\n    double d = left + (((right - left) * value) / (maxTime - minTime));\n    return (int) d;\n}", "repo_id": "9", "comment": "/**\n * Get the X coordinate based on a time value\n *\n * @param value\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3797, "method_signature": "int getTimeX(double)"}, "762": {"callee_method_names": [], "method_name": "CeParameters.isOptimizeAlignment", "method_implementation": "{\n    return optimizeAlignment;\n}", "repo_id": "9", "comment": "/**\n * Whether the CE algorithm should extend the best found trace with dynamic programming,\n * while keeping RMSD at about the same level. This is useful for edge cases with remote homology,\n * but can be slow for large structures.\n *\n * @return optimizeAlignment\n */\n", "repo_name": "biojava-master/", "id": 762, "method_signature": "boolean isOptimizeAlignment()"}, "1452": {"callee_method_names": [], "method_name": "SpaceGroup.getAltShortSymbol", "method_implementation": "{\n    return altShortSymbol;\n}", "repo_id": "9", "comment": "/**\n * Gets the alternative international short name (as sometimes used in PDB),\n * e.g. \"I 1 2 1\" instead of \"I 2\"\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1452, "method_signature": "String getAltShortSymbol()"}, "861": {"callee_method_names": ["TreeMap<Key, Value>.firstKey"], "method_name": "SymbolTable.min", "method_implementation": "{\n    return st.firstKey();\n}", "repo_id": "9", "comment": "/**\n * Return the smallest key in the table.\n */\n", "repo_name": "biojava-master/", "id": 861, "method_signature": "Key min()"}, "1863": {"callee_method_names": [], "method_name": "Rotation.getScores", "method_implementation": "{\n    return scores;\n}", "repo_id": "9", "comment": "/**\n * @return the scores\n */\n", "repo_name": "biojava-master/", "id": 1863, "method_signature": "QuatSymmetryScores getScores()"}, "3702": {"callee_method_names": ["LinkedHashMap.clear", "LinkedHashMap.clear", "HashMap.clear", "HashMap.clear"], "method_name": "WorkSheet.clear", "method_implementation": "{\n    columnLookup.clear();\n    rowLookup.clear();\n    data = null;\n    dataGrid.clear();\n    doubleValues.clear();\n    System.gc();\n}", "repo_id": "9", "comment": "/**\n * See if we can free up memory\n */\n", "repo_name": "biojava-master/", "id": 3702, "method_signature": "void clear()"}, "3461": {"callee_method_names": [], "method_name": "NCBIQBlastOutputProperties.setAlignmentNumber", "method_implementation": "{\n    setOutputOption(ALIGNMENTS, Integer.toString(number));\n}", "repo_id": "9", "comment": "/**\n * Set the number of alignments to fetch\n *\n * @param number : an int with the required number of alignments to fetch\n */\n", "repo_name": "biojava-master/", "id": 3461, "method_signature": "void setAlignmentNumber(int)"}, "3233": {"callee_method_ids": [3022], "callee_method_names": ["InsdcParser.parse", "Location.isComplex", "Logger.info", "Logger.debug", "Location.getAccession", "Location.getAccession"], "method_name": "InsdcParserTest.extractAccessionTest", "method_implementation": "{\n    InsdcParser parser = new InsdcParser(DataSource.GENBANK);\n    Location loc = parser.parse(data);\n    if (!loc.isComplex()) {\n        log.info(\"simple location: {}\", data);\n        log.debug(\"\\taccession: '{}'  expected: '{}'\", loc.getAccession().getID(), expected);\n        assertEquals(expected, loc.getAccession().getID());\n    }\n}", "repo_id": "9", "comment": "/**\n * Test for issue #254\n *\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3233, "method_signature": "void extractAccessionTest(String, String)"}, "390": {"callee_method_names": [], "method_name": "Calc.shift", "method_implementation": "{\n    for (Atom atom : ca) Calc.shift(atom, b);\n}", "repo_id": "9", "comment": "/**\n * Shift an array of atoms at once.\n *\n * @param ca\n *            array of Atoms to shift\n * @param b\n *            reference Atom vector\n */\n", "repo_name": "biojava-master/", "id": 390, "method_signature": "void shift(Atom[], Atom)"}, "611": {"callee_method_names": ["Class<T>.getEnumConstants", "StringBuilder.append", "T[].name", "StringBuilder.append", "T[].name", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "T[].name", "StringBuilder.toString"], "method_name": "CliTools.getEnumValuesAsString", "method_implementation": "{\n    //ScoringStrategy[] vals = ScoringStrategy.values();\n    T[] vals = enumClass.getEnumConstants();\n    StringBuilder str = new StringBuilder();\n    if (vals.length == 1) {\n        str.append(vals[0].name());\n    } else if (vals.length > 1) {\n        for (int i = 0; i < vals.length - 1; i++) {\n            str.append(vals[i].name());\n            str.append(\", \");\n        }\n        str.append(\"or \");\n        str.append(vals[vals.length - 1].name());\n    }\n    return str.toString();\n}", "repo_id": "9", "comment": "/**\n * Constructs a comma-separated list of values for an enum.\n *\n * Example:\n * > getEnumValues(ScoringStrategy.class)\n * \"CA_SCORING, SIDE_CHAIN_SCORING, SIDE_CHAIN_ANGLE_SCORING, CA_AND_SIDE_CHAIN_ANGLE_SCORING, or SEQUENCE_CONSERVATION\"\n * @param enumClass\n * @return\n */\n", "repo_name": "biojava-master/", "id": 611, "method_signature": "String getEnumValuesAsString(Class)"}, "270": {"callee_method_names": [], "method_name": "ModificationLinkage.getLabelOfAtomOnComponent1", "method_implementation": "{\n    return labelOfAtomOnComponent1;\n}", "repo_id": "9", "comment": "/**\n * @return label of the atom on the first component.\n */\n", "repo_name": "biojava-master/", "id": 270, "method_signature": "String getLabelOfAtomOnComponent1()"}, "3491": {"callee_method_names": ["String.split"], "method_name": "NCBIQBlastAlignmentProperties.getBlastGapCreation", "method_implementation": "{\n    String gapCosts = getAlignmentOption(GAPCOSTS);\n    try {\n        String gapCreation = gapCosts.split(\"\\\\+\")[0];\n        return Integer.parseInt(gapCreation);\n    } catch (Exception e) {\n        return -1;\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the value for the GAP_CREATION parameter (first half of GAPCOSTS parameter)\n *\n * @return an integer value for gap creation used by this search, -1 if not set or not a number\n */\n", "repo_name": "biojava-master/", "id": 3491, "method_signature": "int getBlastGapCreation()"}, "205": {"callee_method_names": [], "method_name": "FastaSequence.getOnelineFasta", "method_implementation": "{\n    String fasta = \">\" + getId() + \"\\n\";\n    fasta += getSequence() + \"\\n\";\n    return fasta;\n}", "repo_id": "9", "comment": "/**\n * @return one line name, next line sequence, no matter what the sequence\n *         length is\n */\n", "repo_name": "biojava-master/", "id": 205, "method_signature": "String getOnelineFasta()"}, "3876": {"callee_method_names": ["String.length", "String.length", "String.toCharArray"], "method_name": "PeptideProperties.getPolarityOfAminoAcids", "method_implementation": "{\n    int[] polarity = new int[sequence.length()];\n    for (int i = 0; i < sequence.length(); i++) {\n        char aa = sequence.toCharArray()[i];\n        polarity[i] = AminoAcidProperties.getPolarityOfAminoAcid(aa);\n    }\n    return polarity;\n}", "repo_id": "9", "comment": "/**\n * Returns the array of polarity values of each amino acid in a protein sequence.\n *\n * @param sequence\n * \t\ta protein sequence consisting of non-ambiguous characters only\n * @return the array of polarity of amino acids in the protein (1 if amino acid is polar, 0 if not)\n */\n", "repo_name": "biojava-master/", "id": 3876, "method_signature": "int[] getPolarityOfAminoAcids(String)"}, "20": {"callee_method_names": ["String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "String.equals", "StockholmStructure.getFileAnnotation", "Logger.warn"], "method_name": "StockholmFileParser.handleFileAnnotation", "method_implementation": "{\n    if (featureName.equals(GF_ACCESSION_NUMBER)) {\n        stockholmStructure.getFileAnnotation().setGFAccessionNumber(value);\n    } else if (featureName.equals(GF_IDENTIFICATION)) {\n        stockholmStructure.getFileAnnotation().setGFIdentification(value);\n    } else if (featureName.equals(GF_DB_REFERENCE)) {\n        stockholmStructure.getFileAnnotation().addDBReference(value);\n    } else if (featureName.equals(GF_DEFINITION)) {\n        stockholmStructure.getFileAnnotation().setGFDefinition(value);\n    } else if (featureName.equals(GF_AUTHOR)) {\n        stockholmStructure.getFileAnnotation().setGFAuthors(value);\n    } else if (featureName.equals(GF_ALIGNMENT_METHOD)) {\n        stockholmStructure.getFileAnnotation().setAlignmentMethod(value);\n    } else if (featureName.equals(GF_BUILD_METHOD)) {\n        stockholmStructure.getFileAnnotation().addGFBuildMethod(value);\n    } else if (featureName.equals(GF_SEARCH_METHOD)) {\n        stockholmStructure.getFileAnnotation().setGFSearchMethod(value);\n    } else if (featureName.equals(GF_SOURCE_SEED)) {\n        stockholmStructure.getFileAnnotation().setGFSourceSeed(value);\n    } else if (featureName.equals(GF_SOURCE_STRUCTURE)) {\n        stockholmStructure.getFileAnnotation().setGFSourceStructure(value);\n    } else if (featureName.equals(GF_GATHERING_THRESHOLD)) {\n        stockholmStructure.getFileAnnotation().setGFGatheringThreshs(value);\n    } else if (featureName.equals(GF_TRUSTED_CUTOFF)) {\n        stockholmStructure.getFileAnnotation().setGFTrustedCutoffs(value);\n    } else if (featureName.equals(GF_NOISE_CUTOFF)) {\n        stockholmStructure.getFileAnnotation().setGFNoiseCutoffs(value);\n    } else if (featureName.equals(GF_TYPE_FIELD)) {\n        stockholmStructure.getFileAnnotation().setGFTypeField(value);\n    } else if (featureName.equals(GF_PREVIOUS_IDS)) {\n        stockholmStructure.getFileAnnotation().setGFPreviousIDs(value);\n    } else if (featureName.equals(GF_SEQUENCE)) {\n        // status = STATUS_IN_SEQUENCE;\n        stockholmStructure.getFileAnnotation().setGFNumSequences(value);\n    } else if (featureName.equals(GF_DB_COMMENT)) {\n        stockholmStructure.getFileAnnotation().setGFDBComment(value);\n        // } else if (featureName.equals(GF_DB_REFERENCE)) {\n        // stockholmStructure.getFileAnnotation().addDBReference(value);\n    } else if (featureName.equals(GF_REFERENCE_COMMENT)) {\n        stockholmStructure.getFileAnnotation().setGFRefComment(value);\n    } else if (featureName.equals(GF_REFERENCE_NUMBER)) {\n        StockholmFileAnnotationReference reference = new StockholmFileAnnotationReference();\n        stockholmStructure.getFileAnnotation().getReferences().add(reference);\n    } else if (featureName.equals(GF_REFERENCE_MEDLINE)) {\n        stockholmStructure.getFileAnnotation().getReferences().lastElement().setRefMedline(value);\n    } else if (featureName.equals(GF_REFERENCE_TITLE)) {\n        stockholmStructure.getFileAnnotation().getReferences().lastElement().addToRefTitle(value);\n    } else if (featureName.equals(GF_REFERENCE_AUTHOR)) {\n        stockholmStructure.getFileAnnotation().getReferences().lastElement().addToRefAuthor(value);\n    } else if (featureName.equals(GF_REFERENCE_LOCALTION)) {\n        stockholmStructure.getFileAnnotation().getReferences().lastElement().setRefLocation(value);\n    } else if (featureName.equals(GF_KEYWORDS)) {\n        stockholmStructure.getFileAnnotation().setGFKeywords(value);\n    } else if (featureName.equals(GF_COMMENT)) {\n        stockholmStructure.getFileAnnotation().addToGFComment(value);\n    } else if (featureName.equals(GF_PFAM_ACCESSION)) {\n        stockholmStructure.getFileAnnotation().setGFPfamAccession(value);\n    } else if (featureName.equals(GF_LOCATION)) {\n        stockholmStructure.getFileAnnotation().setGFLocation(value);\n    } else if (featureName.equals(GF_WIKIPEDIA_LINK)) {\n        stockholmStructure.getFileAnnotation().setGFWikipediaLink(value);\n    } else if (featureName.equals(GF_CLAN)) {\n        stockholmStructure.getFileAnnotation().setGFClan(value);\n    } else if (featureName.equals(GF_MEMBERSHIP)) {\n        stockholmStructure.getFileAnnotation().setGFMembership(value);\n    } else if (featureName.equals(GF_NEW_HAMPSHIRE)) {\n        stockholmStructure.getFileAnnotation().addGFNewHampshire(value);\n    } else if (featureName.equals(GF_TREE_ID)) {\n        stockholmStructure.getFileAnnotation().addGFTreeID(value);\n    } else if (featureName.equals(GF_FALSE_DISCOVERY_RATE)) {\n        stockholmStructure.getFileAnnotation().addGFFalseDiscoveryRate(value);\n    } else {\n        // unknown feature\n        logger.warn(\"Unknown File Feature [{}].\\nPlease contact the Biojava team.\", featureName);\n    }\n}", "repo_id": "9", "comment": "/**\n * #=GF &lt;feature&gt; &lt;Generic per-File annotation, free text&gt;\n *\n * @param featureName\n * @param value\n *            the line to be parsed\n */\n", "repo_name": "biojava-master/", "id": 20, "method_signature": "void handleFileAnnotation(String, String)"}, "2563": {"callee_method_names": ["SoftHashMap.size"], "method_name": "FlatFileCache.size", "method_implementation": "{\n    if (cache != null)\n        return cache.size();\n    else\n        return -1;\n}", "repo_id": "9", "comment": "/**\n * Returns the number of items in the cache.\n * If the cache is {@}, returns -1\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2563, "method_signature": "int size()"}, "816": {"callee_method_names": [], "method_name": "AlternativeAlignment.getEqr", "method_implementation": "{\n    return eqr0;\n}", "repo_id": "9", "comment": "/**\n * returns the number of euqivalent residues in this alignment\n *\n * @return the number of equivalent residues\n */\n", "repo_name": "biojava-master/", "id": 816, "method_signature": "int getEqr()"}, "3683": {"callee_method_ids": [3637, 3673, 3675, 3659, 3657, 3661, 3654, 3643], "callee_method_names": ["ArrayList<SurvivalInfo>.size", "CoxInfo.getCoefficientsList", "ArrayList<String>.size", "ArrayList<SurvivalInfo>.get", "SurvivalInfo.getTime", "SurvivalInfo.getStatus", "SurvivalInfo.getStrata", "SurvivalInfo.getWeight", "SurvivalInfo.getScore", "ArrayList<String>.size", "ArrayList<String>.get", "SurvivalInfo.getVariable", "ArrayList<SurvivalInfo>.get", "ArrayList<String>.size", "SurvivalInfo.setResidualVariable", "ArrayList<String>.get"], "method_name": "CoxScore.process", "method_implementation": "{\n    int i, j, k;\n    double temp;\n    int n = survivalInfoList.size();\n    ArrayList<String> variables = new ArrayList<String>(coxInfo.getCoefficientsList().keySet());\n    int nvar = variables.size();\n    double deaths;\n    int dd;\n    double[] time = new double[n];\n    double[] status = new double[n];\n    double[] strata = new double[n];\n    double[] weights = new double[n];\n    double[] score = new double[n];\n    double[] a = new double[nvar];\n    double[] a2 = new double[nvar];\n    double denom = 0, e_denom;\n    double risk;\n    double[][] covar = new double[nvar][n];\n    double[][] resid = new double[nvar][n];\n    double hazard, meanwt;\n    double downwt, temp2;\n    double mean;\n    //  n = *nx;\n    //  nvar  = *nvarx;\n    for (int p = 0; p < n; p++) {\n        SurvivalInfo si = survivalInfoList.get(p);\n        time[p] = si.getTime();\n        status[p] = si.getStatus();\n        if (useStrata) {\n            strata[p] = si.getStrata();\n        } else {\n            strata[p] = 0;\n        }\n        weights[p] = si.getWeight();\n        score[p] = si.getScore();\n        for (int v = 0; v < variables.size(); v++) {\n            String variable = variables.get(v);\n            Double value = si.getVariable(variable);\n            covar[v][p] = value;\n        }\n    }\n    //  a = scratch;\n    //  a2 = a+nvar;\n    /*\n\t\t **  Set up the ragged array\n\t\t */\n    //   covar=  dmatrix(covar2, n, nvar);\n    //   resid=  dmatrix(resid2, n, nvar);\n    e_denom = 0;\n    deaths = 0;\n    meanwt = 0;\n    for (i = 0; i < nvar; i++) {\n        a2[i] = 0;\n    }\n    strata[n - 1] = 1;\n    /*failsafe */\n    for (i = n - 1; i >= 0; i--) {\n        if (strata[i] == 1) {\n            denom = 0;\n            for (j = 0; j < nvar; j++) {\n                a[j] = 0;\n            }\n        }\n        risk = score[i] * weights[i];\n        denom += risk;\n        if (status[i] == 1) {\n            deaths++;\n            e_denom += risk;\n            meanwt += weights[i];\n            for (j = 0; j < nvar; j++) {\n                a2[j] += risk * covar[j][i];\n            }\n        }\n        for (j = 0; j < nvar; j++) {\n            a[j] += risk * covar[j][i];\n            resid[j][i] = 0;\n        }\n        if (deaths > 0 && (i == 0 || strata[i - 1] == 1 || time[i] != time[i - 1])) {\n            /* last obs of a set of tied death times */\n            if (deaths < 2 || method == CoxMethod.Breslow) {\n                hazard = meanwt / denom;\n                for (j = 0; j < nvar; j++) {\n                    temp = (a[j] / denom);\n                    /* xbar */\n                    for (k = i; k < n; k++) {\n                        temp2 = covar[j][k] - temp;\n                        if (time[k] == time[i] && status[k] == 1) {\n                            resid[j][k] += temp2;\n                        }\n                        resid[j][k] -= temp2 * score[k] * hazard;\n                        if (strata[k] == 1) {\n                            break;\n                        }\n                    }\n                }\n            } else {\n                /* the harder case */\n                meanwt /= deaths;\n                for (dd = 0; dd < deaths; dd++) {\n                    downwt = dd / deaths;\n                    temp = denom - downwt * e_denom;\n                    hazard = meanwt / temp;\n                    for (j = 0; j < nvar; j++) {\n                        mean = (a[j] - downwt * a2[j]) / temp;\n                        for (k = i; k < n; k++) {\n                            temp2 = covar[j][k] - mean;\n                            if (time[k] == time[i] && status[k] == 1) {\n                                resid[j][k] += temp2 / deaths;\n                                resid[j][k] -= temp2 * score[k] * hazard * (1 - downwt);\n                            } else {\n                                resid[j][k] -= temp2 * score[k] * hazard;\n                            }\n                            if (strata[k] == 1) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            e_denom = 0;\n            deaths = 0;\n            meanwt = 0;\n            for (j = 0; j < nvar; j++) {\n                a2[j] = 0;\n            }\n        }\n    }\n    for (int p = 0; p < n; p++) {\n        SurvivalInfo si = survivalInfoList.get(p);\n        for (int v = 0; v < variables.size(); v++) {\n            si.setResidualVariable(variables.get(v), resid[v][p]);\n        }\n    }\n    //appears to be backward internally\n    double[][] flipresid = new double[n][nvar];\n    for (int s = 0; s < resid.length; s++) {\n        for (int t = 0; t < resid[0].length; t++) {\n            flipresid[t][s] = resid[s][t];\n        }\n    }\n    return flipresid;\n}", "repo_id": "9", "comment": "/**\n * @param method\n * @param survivalInfoList\n * @param coxInfo\n * @param useStrata\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3683, "method_signature": "double[][] process(CoxMethod, ArrayList, CoxInfo, boolean)"}, "3017": {"callee_method_names": [], "method_name": "AbstractReference.getAuthors", "method_implementation": "{\n    return authors;\n}", "repo_id": "9", "comment": "/**\n * The authors are a list of Inventors that retrieved from the Reference section.\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3017, "method_signature": "String getAuthors()"}, "3379": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorCn.getOrientationName", "method_implementation": "{\n    if (\"C2\".equals(getAxisTransformation().getRotationGroup().getPointGroup())) {\n        if (index == 0) {\n            return \"Front C2 axis\";\n        } else if (index == 2) {\n            return \"Back C2 axis\";\n        }\n    }\n    return getPolyhedron().getViewName(index);\n}", "repo_id": "9", "comment": "/**\n * Returns the name of a specific orientation\n * @param index orientation index\n * @return name of orientation\n */\n", "repo_name": "biojava-master/", "id": 3379, "method_signature": "String getOrientationName(int)"}, "2366": {"callee_method_ids": [2372, 2373, 2372], "callee_method_names": ["Fastq.getQuality", "Fastq.getVariant", "Fastq.getQuality", "FastqVariant.errorProbability"], "method_name": "FastqTools.errorProbabilities", "method_implementation": "{\n    if (fastq == null) {\n        throw new IllegalArgumentException(\"fastq must not be null\");\n    }\n    if (errorProbabilities == null) {\n        throw new IllegalArgumentException(\"errorProbabilities must not be null\");\n    }\n    int size = fastq.getQuality().length();\n    if (errorProbabilities.length != size) {\n        throw new IllegalArgumentException(\"errorProbabilities must be the same length as the FASTQ formatted sequence quality\");\n    }\n    FastqVariant variant = fastq.getVariant();\n    for (int i = 0; i < size; i++) {\n        char c = fastq.getQuality().charAt(i);\n        errorProbabilities[i] = variant.errorProbability(c);\n    }\n    return errorProbabilities;\n}", "repo_id": "9", "comment": "/**\n * Copy the error probabilities from the specified FASTQ formatted sequence into the specified double array.\n *\n * @param fastq FASTQ formatted sequence, must not be null\n * @param errorProbabilities double array of error probabilities, must not be null and must be the same\n *    length as the FASTQ formatted sequence quality\n * @return the specified double array of error probabilities\n */\n", "repo_name": "biojava-master/", "id": 2366, "method_signature": "double[] errorProbabilities(Fastq, double[])"}, "1891": {"callee_method_names": ["Set<SubunitCluster>.addAll", "Set<SubunitCluster>.addAll"], "method_name": "Stoichiometry.combineWith", "method_implementation": "{\n    Set<SubunitCluster> combinedClusters = new LinkedHashSet<>();\n    combinedClusters.addAll(this.orderedClusters);\n    combinedClusters.addAll(other.orderedClusters);\n    Stoichiometry combinedStoichiometry;\n    if (this.strategy == StringOverflowStrategy.CUSTOM) {\n        combinedStoichiometry = new Stoichiometry(new ArrayList<>(combinedClusters), this.customStringGenerator);\n    } else {\n        combinedStoichiometry = new Stoichiometry(new ArrayList<>(combinedClusters), this.strategy, false);\n    }\n    return combinedStoichiometry;\n}", "repo_id": "9", "comment": "/**\n * Make a combined Stoichiometry object of <i>this</> and the <i>other</>.\n * The combined list of clusters will be ordered by the number of subunits.\n * @return new {@link Stoichiometry} object.\n */\n", "repo_name": "biojava-master/", "id": 1891, "method_signature": "Stoichiometry combineWith(Stoichiometry)"}, "3675": {"callee_method_names": [], "method_name": "SurvivalInfo.getStatus", "method_implementation": "{\n    return status;\n}", "repo_id": "9", "comment": "/**\n * @return the status\n */\n", "repo_name": "biojava-master/", "id": 3675, "method_signature": "int getStatus()"}, "2836": {"callee_method_names": [], "method_name": "GenericGenbankHeaderParser.setComment", "method_implementation": "{\n    if (comment == null)\n        throw new ParserException(\"Comment cannot be null\");\n    this.comments.add(comment);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2836, "method_signature": "void setComment(String)"}, "915": {"callee_method_names": [], "method_name": "BoundingBox.contains", "method_implementation": "{\n    double x = atom.x;\n    double y = atom.y;\n    double z = atom.z;\n    return xmin <= x && x <= xmax && ymin <= y && y <= ymax && zmin <= z && z <= zmax;\n}", "repo_id": "9", "comment": "/**\n * Check if a given point falls within this box\n * @param atom\n * @return\n */\n", "repo_name": "biojava-master/", "id": 915, "method_signature": "boolean contains(Point3d)"}, "506": {"callee_method_names": [], "method_name": "AFPChain.setDistanceMatrix", "method_implementation": "{\n    this.distanceMatrix = distanceMatrix;\n    //System.out.println(\"Setting distMatrix \"+(distanceMatrix==null?\"null\":\"not null\"));\n}", "repo_id": "9", "comment": "/**\n * A matrix with <i>ca1length</i> rows and <i>ca2length</i> columns.\n * For CE this is the distance matrix, but the exact interpretation is left\n * up to the alignment algorithm.\n * @param distanceMatrix A matrix with dimensions ca1length x ca2length\n */\n", "repo_name": "biojava-master/", "id": 506, "method_signature": "void setDistanceMatrix(Matrix)"}, "2151": {"callee_method_names": [], "method_name": "StructureImpl.setPDBHeader", "method_implementation": "{\n    this.pdbHeader = pdbHeader;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2151, "method_signature": "void setPDBHeader(PDBHeader)"}, "1235": {"callee_method_names": ["Logger.debug", "String.length", "Logger.debug", "String.length", "Logger.warn", "Element.getMessage", "PairwiseSequenceAligner<ProteinSequence, AminoAcidCompound>.getPair", "SequencePair<ProteinSequence, AminoAcidCompound>.getLength", "Logger.warn", "Logger.warn", "Logger.warn", "Logger.warn", "Logger.debug", "SequencePair<ProteinSequence, AminoAcidCompound>.toString"], "method_name": "SeqRes2AtomAligner.alignProteinChains", "method_implementation": "{\n    Map<Integer, Integer> seqresIndexPosition = new HashMap<Integer, Integer>();\n    Map<Integer, Integer> atomIndexPosition = new HashMap<Integer, Integer>();\n    String seq1 = getFullAtomSequence(seqRes, seqresIndexPosition, false);\n    //\n    String seq2 = getFullAtomSequence(atomRes, atomIndexPosition, false);\n    logger.debug(\"Protein seq1 to align (length \" + seq1.length() + \"): \" + seq1);\n    logger.debug(\"Protein seq2 to align (length \" + seq2.length() + \"): \" + seq2);\n    ProteinSequence s1;\n    ProteinSequence s2;\n    try {\n        s1 = new ProteinSequence(seq1);\n        s2 = new ProteinSequence(seq2);\n    } catch (CompoundNotFoundException e) {\n        logger.warn(\"Could not create protein sequences ({}) to align ATOM and SEQRES groups, they will remain unaligned.\", e.getMessage());\n        return true;\n    }\n    SubstitutionMatrix<AminoAcidCompound> matrix = SubstitutionMatrixHelper.getBlosum65();\n    GapPenalty penalty = new SimpleGapPenalty(8, 1);\n    PairwiseSequenceAligner<ProteinSequence, AminoAcidCompound> smithWaterman = Alignments.getPairwiseAligner(s1, s2, PairwiseSequenceAlignerType.LOCAL, penalty, matrix);\n    SequencePair<ProteinSequence, AminoAcidCompound> pair = smithWaterman.getPair();\n    // sequences that are only X (e.g. 1jnv chain A) produced empty alignments, because nothing aligns to nothing and thus the local alignment is empty\n    // to avoid those empty alignments we catch them here with pair.getLength()==0\n    if (pair == null || pair.getLength() == 0) {\n        logger.warn(\"Could not align protein sequences. ATOM and SEQRES groups will not be aligned.\");\n        logger.warn(\"Sequences: \");\n        logger.warn(seq1);\n        logger.warn(seq2);\n        return true;\n    }\n    logger.debug(\"Alignment:\\n{}\", pair.toString(100));\n    boolean noMatchFound = mapChains(seqRes, atomRes, pair, seqresIndexPosition, atomIndexPosition);\n    return noMatchFound;\n}", "repo_id": "9", "comment": "/**\n * Aligns two chains of groups, where the first parent is representing the\n * list of amino acids as obtained from the SEQRES records, and the second parent\n * represents the groups obtained from the ATOM records (and containing the actual ATOM information).\n * This does the actual alignment and if a group can be mapped to a position in the SEQRES then the corresponding\n * position is replaced with the group that contains the atoms.\n *\n * @param seqRes\n * @param atomRes\n * @return true if no match has been found\n */\n", "repo_name": "biojava-master/", "id": 1235, "method_signature": "boolean alignProteinChains(List, List)"}, "1488": {"callee_method_names": ["Point3d.add"], "method_name": "CalcPoint.translate", "method_implementation": "{\n    for (Point3d p : x) {\n        p.add(trans);\n    }\n}", "repo_id": "9", "comment": "/**\n * Translate all points with a translation vector.\n *\n * @param trans\n *            the translation vector to apply\n * @param x\n *            array of points. Point objects will be modified\n */\n", "repo_name": "biojava-master/", "id": 1488, "method_signature": "void translate(Vector3d, Point3d[])"}, "3016": {"callee_method_names": [], "method_name": "AbstractReference.setTitle", "method_implementation": "{\n    this.title = title;\n}", "repo_id": "9", "comment": "/**\n * Set The title that retrieved from the Reference section.\n *\n * @param title\n */\n", "repo_name": "biojava-master/", "id": 3016, "method_signature": "void setTitle(String)"}, "867": {"callee_method_names": ["SparseVector[].nnz"], "method_name": "SparseSquareMatrix.nnz", "method_implementation": "{\n    int sum = 0;\n    for (int i = 0; i < N; i++) sum += rows[i].nnz();\n    return sum;\n}", "repo_id": "9", "comment": "/**\n *  return the number of nonzero entries (not the most efficient implementation)\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 867, "method_signature": "int nnz()"}, "2596": {"callee_method_names": [], "method_name": "UncompressInputStream.resetbuf", "method_implementation": "{\n    int pos = bit_pos >> 3;\n    System.arraycopy(data, pos, data, 0, end - pos);\n    end -= pos;\n    return 0;\n}", "repo_id": "9", "comment": "/**\n * Moves the unread data in the buffer to the beginning and resets\n * the pointers.\n */\n", "repo_name": "biojava-master/", "id": 2596, "method_signature": "int resetbuf(int)"}, "3814": {"callee_method_names": [], "method_name": "CensorStatus.getCopy", "method_implementation": "{\n    CensorStatus cs = new CensorStatus();\n    cs.row = row;\n    cs.time = time;\n    cs.censored = censored;\n    cs.group = group;\n    cs.value = value;\n    cs.zscore = zscore;\n    return cs;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3814, "method_signature": "CensorStatus getCopy()"}, "1162": {"callee_method_ids": [1770, 1768], "callee_method_names": ["String.trim", "String.substring", "PDBHeader.setClassification", "String.substring", "DateFormat.parse", "PDBHeader.setDepDate", "Logger.info", "String.substring", "Logger.debug", "String.isBlank", "Logger.warn", "Structure.setPdbId", "PDBHeader.setPdbId", "String.equals", "String.substring", "Logger.warn"], "method_name": "PDBFileParser.pdb_HEADER_Handler", "method_implementation": "{\n    String classification = null;\n    String deposition_date = null;\n    String pdbCode = null;\n    int len = line.trim().length();\n    if (len > 10) {\n        classification = line.substring(10, min(len, 50)).trim();\n        pdbHeader.setClassification(classification);\n    }\n    if (len > 50) {\n        deposition_date = line.substring(50, min(len, 59)).trim();\n        try {\n            Date dep = dateFormat.parse(deposition_date);\n            pdbHeader.setDepDate(dep);\n        } catch (ParseException e) {\n            logger.info(\"Could not parse deposition date string '\" + deposition_date + \"'. Will continue without deposition date\");\n        }\n    }\n    if (len > 62) {\n        pdbCode = line.substring(62, min(len, 66)).trim();\n        pdbId = pdbCode;\n        logger.debug(\"Parsing entry {}\", pdbId);\n        PdbId pdbIdToSet;\n        if (pdbCode.isBlank()) {\n            pdbIdToSet = null;\n        } else {\n            try {\n                pdbIdToSet = new PdbId(pdbCode);\n            } catch (IllegalArgumentException e) {\n                logger.warn(\"Malformed PDB ID {}. setting PdbId to null\", pdbCode);\n                pdbIdToSet = null;\n            }\n        }\n        structure.setPdbId(pdbIdToSet);\n        pdbHeader.setPdbId(pdbIdToSet);\n    }\n    //*really* old files (you'll need to hunt to find these as they\n    //should have been remediated) have headers like below. Plus the\n    //pdbId at positions 72-76 is present in every line\n    //HEADER    PROTEINASE INHIBITOR (TRYPSIN)          05-OCT-84   5PTI      5PTI   3\n    //HEADER    TRANSFERASE (ACYLTRANSFERASE)           02-SEP-92   1LAC      1LAC   2\n    if (len > 66) {\n        if (pdbId.equals(line.substring(72, 76))) {\n            isLegacyFormat = true;\n            logger.warn(pdbId + \" is a LEGACY entry - this will most likely not parse correctly.\");\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * \t Handler for\n * \t HEADER Record Format\n * \t <pre>\n * \t COLUMNS        DATA TYPE       FIELD           DEFINITION\n * \t ----------------------------------------------------------------------------------\n * \t 1 -  6        Record name     \"HEADER\"\n * \t 11 - 50        String(40)      classification  Classifies the molecule(s)\n * \t 51 - 59        Date            depDate         Deposition date.  This is the date\n * \t the coordinates were received by\n * \t the PDB\n * \t 63 - 66        IDcode          idCode          This identifier is unique within PDB\n * \t</pre>\n */\n", "repo_name": "biojava-master/", "id": 1162, "method_signature": "void pdb_HEADER_Handler(String)"}, "1147": {"callee_method_names": ["Object.getClass", "String.equals", "String.equals", "String.equals", "String.equals", "String.equals", "String.equals"], "method_name": "SSBondImpl.equals", "method_implementation": "{\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    SSBondImpl other = (SSBondImpl) obj;\n    if (chainID1 == null) {\n        if (other.chainID1 != null)\n            return false;\n    } else if (!chainID1.equals(other.chainID1))\n        return false;\n    if (chainID2 == null) {\n        if (other.chainID2 != null)\n            return false;\n    } else if (!chainID2.equals(other.chainID2))\n        return false;\n    if (insCode1 == null) {\n        if (other.insCode1 != null)\n            return false;\n    } else if (!insCode1.equals(other.insCode1))\n        return false;\n    if (insCode2 == null) {\n        if (other.insCode2 != null)\n            return false;\n    } else if (!insCode2.equals(other.insCode2))\n        return false;\n    if (resnum1 == null) {\n        if (other.resnum1 != null)\n            return false;\n    } else if (!resnum1.equals(other.resnum1))\n        return false;\n    if (resnum2 == null) {\n        if (other.resnum2 != null)\n            return false;\n    } else if (!resnum2.equals(other.resnum2))\n        return false;\n    return true;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n", "repo_name": "biojava-master/", "id": 1147, "method_signature": "boolean equals(Object)"}, "178": {"callee_method_ids": [1633, 1625, 1633, 1631, 1635, 1627], "callee_method_names": ["SubunitClustererParameters.setClustererMethod", "SubunitClustererParameters.setSequenceCoverageThreshold", "List<SubunitCluster>.size", "List<SubunitCluster>.get", "List<SubunitCluster>.get", "List<SubunitCluster>.get", "SubunitClustererParameters.setClustererMethod", "SubunitClustererParameters.setStructureCoverageThreshold", "SubunitClustererParameters.setInternalSymmetry", "SubunitClustererParameters.setRMSDThreshold", "List<SubunitCluster>.size", "List<SubunitCluster>.get", "List<SubunitCluster>.get", "List<SubunitCluster>.get"], "method_name": "TestSubunitClustererExamples.testInternalSymmetry", "method_implementation": "{\n    Structure s = StructureIO.getStructure(\"BIO:4E3E:1\");\n    SubunitClustererParameters params = new SubunitClustererParameters();\n    params.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n    params.setSequenceCoverageThreshold(0.8);\n    List<SubunitCluster> clusters = SubunitClusterer.cluster(s, params).getClusters();\n    // We expect one SEQUENCE cluster with 3 Subunits of length 351\n    assertEquals(clusters.size(), 1);\n    assertEquals(clusters.get(0).size(), 3);\n    assertEquals(clusters.get(0).length(), 351);\n    assertEquals(clusters.get(0).getClustererMethod(), SubunitClustererMethod.SEQUENCE);\n    params.setClustererMethod(SubunitClustererMethod.SEQUENCE_STRUCTURE);\n    params.setStructureCoverageThreshold(0.8);\n    params.setInternalSymmetry(true);\n    params.setRMSDThreshold(3.0);\n    clusters = SubunitClusterer.cluster(s, params).getClusters();\n    // We expect a single INTERNAL_SYMMETRY cluster with 6 Subunits\n    assertEquals(clusters.size(), 1);\n    assertEquals(clusters.get(0).size(), 6);\n    assertTrue(clusters.get(0).length() < 177);\n    assertEquals(clusters.get(0).getClustererMethod(), SubunitClustererMethod.STRUCTURE);\n}", "repo_id": "9", "comment": "/**\n * Test internally symmetric: 4E3E bioassembly 1\n */\n", "repo_name": "biojava-master/", "id": 178, "method_signature": "void testInternalSymmetry()"}, "2096": {"callee_method_names": [], "method_name": "SymmetryAxes.getElementaryAxesObjects", "method_implementation": "{\n    return axes;\n}", "repo_id": "9", "comment": "/**\n * Return all elementary axes of symmetry of the structure, that is,\n * the axes stored in the List as unique and from which all the symmetry\n * axes are constructed.\n *\n * @return axes elementary axes of symmetry.\n */\n", "repo_name": "biojava-master/", "id": 2096, "method_signature": "List<Axis> getElementaryAxesObjects()"}, "17": {"callee_method_names": [], "method_name": "StockholmFileParser.parseNext", "method_implementation": "{\n    return parse(this.cashedInputStream, max);\n}", "repo_id": "9", "comment": "/**\n * Tries to parse and return as maximum as <code>max</code> structures in the last used file or input stream.<br>\n * Please consider calling either {@link #parse(InputStream)}, {@link #parse(InputStream, int)}, or\n * {@link #parse(String, int)} before calling this function.\n *\n * @param max\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 17, "method_signature": "List<StockholmStructure> parseNext(int)"}, "1466": {"callee_method_names": [], "method_name": "CrystalCell.transfToOriginCell", "method_implementation": "{\n    //clone\n    reference = new Point3d(reference);\n    transfToCrystal(reference);\n    int x = (int) Math.floor(reference.x);\n    int y = (int) Math.floor(reference.y);\n    int z = (int) Math.floor(reference.z);\n    for (Tuple3d point : points) {\n        transfToCrystal(point);\n        point.x -= x;\n        point.y -= y;\n        point.z -= z;\n        transfToOrthonormal(point);\n    }\n}", "repo_id": "9", "comment": "/**\n * Converts a set of points so that the reference point falls in the unit cell.\n *\n * This is useful to transform a whole chain at once, allowing some of the\n * atoms to be outside the unit cell, but forcing the centroid to be within it.\n *\n * @param points A set of points to transform (in orthonormal coordinates)\n * @param reference The reference point, which is unmodified but which would\n *    be in the unit cell were it to have been transformed. It is safe to\n *    use a member of the points array here.\n */\n", "repo_name": "biojava-master/", "id": 1466, "method_signature": "void transfToOriginCell(Tuple3d[], Tuple3d)"}, "1772": {"callee_method_names": ["Set<ExperimentalTechnique>.add"], "method_name": "PDBHeader.setExperimentalTechnique", "method_implementation": "{\n    ExperimentalTechnique et = ExperimentalTechnique.getByName(techniqueStr);\n    if (et == null)\n        return false;\n    if (techniques == null) {\n        techniques = EnumSet.of(et);\n        return true;\n    } else {\n        return techniques.add(et);\n    }\n}", "repo_id": "9", "comment": "/**\n * Adds the experimental technique to the set of experimental techniques of this header.\n * Note that if input is not a recognised technique string then no errors will be produced but\n * false will be returned\n * @param techniqueStr\n * @return true if the input corresponds to a recognised technique string (see {@link ExperimentalTechnique})\n * and it was not already present in the current set of ExperimentalTechniques\n */\n", "repo_name": "biojava-master/", "id": 1772, "method_signature": "boolean setExperimentalTechnique(String)"}, "3118": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getLastIndexOf", "method_implementation": "{\n    return this.parsedCompounds.lastIndexOf(compound) + 1;\n}", "repo_id": "9", "comment": "/**\n * @param compound\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3118, "method_signature": "int getLastIndexOf(C)"}, "417": {"callee_method_ids": [484, 486, 487], "callee_method_names": ["AFPChain.setConn", "AFPChain.setDVar", "AFPChain.getMinLen", "AFPChain.getAfpSet", "AFPChain.getDVar", "AFPChain.setAfpChainLen", "AFPChain.getAfpChainList", "AFPChain.getAfpChainTwiBin", "AFPChain.getAfpChainTwiList", "AFPChain.setAfpChainList", "AFPChain.setAfpChainTwiBin", "AFPChain.setAfpChainTwiList", "AFPChain.getAfpChainTwiNum", "AFPChain.getAlignScore", "List<AFP>.get", "List<AFP>.get", "AFPChain.getConn", "AFPChain.setChainRmsd", "AFPChain.setChainLen", "AFPChain.getChainLen", "AFPChain.getBlock2Afp", "AFPChain.getBlockRmsd", "AFPChain.getBlockSize", "List<AFP>.get", "AFPChain.getMisLen", "List<AFP>.get", "List<AFP>.get", "AFPChain.setMisLen", "AFPChain.getGapLen", "List<AFP>.get", "List<AFP>.get", "AFPChain.setGapLen", "AFPChain.setBlock2Afp", "AFPChain.setChainLen", "AFPChain.setBlockSize", "AFPChain.setBlockRmsd", "AFPChain.getBlockNum", "AFPChain.setBlockNum", "AFPChain.setAfpChainList", "AFPChain.setAfpChainTwiList"], "method_name": "AFPChainer.traceBack", "method_implementation": "{\n    afpChain.setConn(0d);\n    afpChain.setDVar(0d);\n    int minLen = afpChain.getMinLen();\n    List<AFP> afpSet = afpChain.getAfpSet();\n    int afpChainLen = 0;\n    //trace-back from currafp (maxsco)\n    int[] afpchain = new int[minLen];\n    int[] afptwibin = new int[minLen];\n    double[] afptwilist = new double[minLen];\n    int currafp = currafp0;\n    int s = 0;\n    afptwibin[s] = 0;\n    afpchain[s++] = currafp;\n    boolean isConnected = false;\n    int prevafp;\n    // int     alnlen = afpSet.get(afpchain[s]).getFragLen();\n    //Double  conn = new Double(0) ;\n    //Double dvar =  new Double(0);\n    while ((prevafp = pre[currafp]) != -1) {\n        isConnected = afpPairConn(prevafp, currafp, params, afpChain);\n        if (isConnected)\n            afptwibin[s - 1] = 1;\n        else\n            afptwibin[s - 1] = 0;\n        Double dvar = afpChain.getDVar();\n        afptwilist[s - 1] = dvar;\n        //note s - 1: the transformation of prevafp-currafp is recorded in currafp\n        currafp = prevafp;\n        // alnlen += afpSet.get(currafp).getFragLen();\n        afpchain[s++] = currafp;\n    }\n    afpChainLen = s;\n    afpChain.setAfpChainLen(afpChainLen);\n    //first afp without transformation\n    if (isConnected)\n        afptwibin[s - 1] = 1;\n    else\n        afptwibin[s - 1] = 0;\n    //if(debug)\n    //   System.out.println(String.format(\"including %d AFPs, %d residues\\n\", afpChainLen, alnlen));\n    //record the optimal alignment in afpChainList (afpChainLen)\n    int[] afpChainList = afpChain.getAfpChainList();\n    double[] afpChainTwiBin = afpChain.getAfpChainTwiBin();\n    double[] afpChainTwiList = afpChain.getAfpChainTwiList();\n    if (afpChainList == null) {\n        afpChainList = new int[s];\n        afpChain.setAfpChainList(afpChainList);\n        afpChainTwiBin = new double[s];\n        afpChain.setAfpChainTwiBin(afpChainTwiBin);\n        afpChainTwiList = new double[s];\n        afpChain.setAfpChainTwiList(afpChainTwiList);\n    }\n    int afpChainTwiNum = afpChain.getAfpChainTwiNum();\n    int i;\n    for (i = 0; i < s; i++) {\n        afpChainList[i] = afpchain[s - 1 - i];\n        afpChainTwiBin[i] = afptwibin[s - 1 - i];\n        afpChainTwiList[i] = afptwilist[s - 1 - i];\n        afpChainTwiNum += afptwibin[s - 1 - i];\n    }\n    if (afpChainTwiNum != twist) {\n        System.err.println(String.format(\"AFPChainer Warning: the twists number is not consistent %d %d\\n\", afpChainTwiNum, twist));\n    }\n    double alignScore = afpChain.getAlignScore();\n    double checkscore = afpSet.get(afpChainList[0]).getScore();\n    for (i = 1; i < afpChainLen; i++) {\n        isConnected = afpPairConn(afpChainList[i - 1], afpChainList[i], params, afpChain);\n        checkscore = checkscore + afpSet.get(afpChainList[i]).getScore() + afpChain.getConn();\n    }\n    if (Math.abs(checkscore - alignScore) > 1e-4) {\n        System.err.println(String.format(\"AFPChainer Warning: fail in alignment score checking %.4f %.4f\\n\", alignScore, checkscore));\n    }\n    if (debug)\n        System.out.println(\"traceBack:\" + afpChainLen + \" \" + afpChainList.length);\n    double rmsd = calAfpRmsd(afpChainLen, afpChainList, 0, afpChain, ca1, ca2);\n    afpChain.setChainRmsd(rmsd);\n    if (debug)\n        System.out.println(\"Chain RMSD: \" + rmsd);\n    int b1 = 0;\n    int bk = 0;\n    int a, b;\n    afpChain.setChainLen(0);\n    int chainLen = afpChain.getChainLen();\n    int[] block2Afp = afpChain.getBlock2Afp();\n    double[] blockRmsd = afpChain.getBlockRmsd();\n    int[] blockSize = afpChain.getBlockSize();\n    block2Afp[0] = 0;\n    for (i = 0; i < afpChainLen; i++) {\n        a = afpChainList[i];\n        chainLen += afpSet.get(a).getFragLen();\n        if (i > 0) {\n            b = afpChainList[i - 1];\n            int misLen = afpChain.getMisLen();\n            misLen += calcMismatch(afpSet.get(a), afpSet.get(b));\n            afpChain.setMisLen(misLen);\n            int gapLen = afpChain.getGapLen();\n            gapLen += calcGap(afpSet.get(a), afpSet.get(b));\n            afpChain.setGapLen(gapLen);\n        }\n        if (afpChainTwiBin[i] == 1) {\n            if (debug)\n                System.out.println(\" ** calAfpTmsd : afpChainWtiBin == 1 : i: \" + i + \" i-b1: \" + (i - b1) + \" b1: \" + b1 + \" afpChainList.len: \" + afpChainList.length);\n            //int len = afpChainList.length - b1 +1;\n            //int[] fakeList = new int[len];\n            //int pos = -1;\n            //for ( int fPos = b1 ; fPos< afpChainList.length ; fPos++){\n            //   pos++;\n            //   fakeList[pos] = afpChainList[fPos];\n            //}\n            if (debug)\n                System.err.println(\"calculation calAfpRmsd \" + i + \" \" + b1 + \" \");\n            rmsd = calAfpRmsd(i - b1, afpChainList, b1, afpChain, ca1, ca2);\n            blockRmsd[bk] = rmsd;\n            blockSize[bk] = i - b1;\n            b1 = i;\n            //System.out.println(\"block2Afp.length:\"+ block2Afp.length + \" \" + bk + \" \" + i + \" \" + afpChain.getMaxTra() );\n            //next-block\n            block2Afp[++bk] = i;\n        }\n    }\n    afpChain.setBlock2Afp(block2Afp);\n    afpChain.setChainLen(chainLen);\n    if (debug)\n        System.out.println(\"after loop over all afpChainList \" + (i - b1) + \" \" + b1);\n    rmsd = calAfpRmsd(i - b1, afpChainList, b1, afpChain, ca1, ca2);\n    if (debug)\n        System.out.println(\"*** i:\" + i + \" b1: \" + b1 + \" i-b1 \" + (i - b1));\n    // argh this is the block RMSD, not the chain RMSD!\n    //afpChain.setChainRmsd(rmsd);\n    //rmsd = calAfpRmsd(i - b1, afpChainList[b1]);\n    blockSize[bk] = i - b1;\n    blockRmsd[bk] = rmsd;\n    afpChain.setBlockSize(blockSize);\n    afpChain.setBlockRmsd(blockRmsd);\n    int blockNum = afpChain.getBlockNum();\n    blockNum = ++bk;\n    if (debug)\n        System.err.println(\"AFPChainser setBlockNUm:\" + blockNum);\n    afpChain.setBlockNum(blockNum);\n    afpChain.setAfpChainList(afpChainList);\n    afpChain.setAfpChainTwiList(afpChainTwiList);\n}", "repo_id": "9", "comment": "/**\n * derive the optimal chaining of AFPs by trace-back\n */\n", "repo_name": "biojava-master/", "id": 417, "method_signature": "void traceBack(int[], int, int, FatCatParameters, AFPChain, Atom[], Atom[])"}, "2846": {"callee_method_names": [], "method_name": "ProteinSequenceCreator.getSequence", "method_implementation": "{\n    return new ProteinSequence(proxyLoader, compoundSet);\n}", "repo_id": "9", "comment": "/**\n * @param proxyLoader\n * @param index not used in this implementation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2846, "method_signature": "AbstractSequence<AminoAcidCompound> getSequence(ProxySequenceReader, long)"}, "2016": {"callee_method_names": [], "method_name": "Prism.getHeight", "method_implementation": "{\n    return height;\n}", "repo_id": "9", "comment": "/**\n * @return the height\n */\n", "repo_name": "biojava-master/", "id": 2016, "method_signature": "double getHeight()"}, "2301": {"callee_method_names": [], "method_name": "TestBond.testSSBonds", "method_implementation": "{\n    for (String pdbCode : new String[] { \"3ZXW\", \"1NTY\", \"4H2I\", \"2K6D\", \"2MLM\" }) {\n        assertEquals(0, countBondedToSelf(pdbCode));\n    }\n}", "repo_id": "9", "comment": "/**\n * Test that Sulphur atoms are not found to be bonded to themselves\n * @throws IOException an error getting the required file\n * @throws StructureException an error parsing the required file\n */\n", "repo_name": "biojava-master/", "id": 2301, "method_signature": "void testSSBonds()"}, "3197": {"callee_method_names": [], "method_name": "HspTest.testEquals", "method_implementation": "{\n    System.out.println(\"equals\");\n    Object o;\n    o = new BlastHspBuilder().setHspNum(1).setHspBitScore(377.211).setHspEvalue(8.04143e-093).setHspQueryFrom(1).setHspQueryTo(224).setHspHitFrom(1035).setHspHitTo(811).setHspQueryFrame(-1).setHspIdentity(213).setHspPositive(213).setHspGaps(5).setHspAlignLen(227).setHspQseq(\"CTGACGACAGCCATGCACCACCTGTCTCGACTTTCCCCCGAAGGGCACCTAATGTATCTCTACCTCGTTAGTCGGATGTCAAGACCTGGTAAGGTTTTTTCGCGTATCTTCGAATTAAACCACATACTCCACTGCTTGTGCGG-CCCCCGTCAATTCCTTTGAGTTTCAACCTTGCGGCCGTACTCCC-AGGTGGA-TACTTATTGTGTTAACTCCGGCACGGAAGG\").setHspHseq(\"CTGACGACAACCATGCACCACCTGTCTCAACTTTCCCC-GAAGGGCACCTAATGTATCTCTACTTCGTTAGTTGGATGTCAAGACCTGGTAAGGTT-CTTCGCGTTGCTTCGAATTAAACCACATACTCCACTGCTTGTGCGGGCCCCCGTCAATTCCTTTGAGTTTCAACCTTGCGGTCGTACTCCCCAGGTGGATTACTTATTGTGTTAACTCCGGCACAGAAGG\").setHspIdentityString(\"||||||||| |||||||||||||||||| ||||||||| |||||||||||||||||||||||| |||||||| |||||||||||||||||||||||  |||||||  |||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||| ||||||||| ||||||| |||||||||||||||||||||||| |||||\").createBlastHsp();\n    Hsp instance = hspImpl;\n    assertEquals(o, instance);\n    // example of Hsp retrieved from uncomplete report.\n    // (Those HSP may come from a tabular format, for example)\n    o = new BlastHspBuilder().setPercentageIdentity(100.00 / 100).setHspAlignLen(48).setMismatchCount(0).setHspGaps(0).setHspQueryFrom(1).setHspQueryTo(48).setHspHitFrom(344).setHspHitTo(391).setHspEvalue(4e-19).setHspBitScore(95.6).createBlastHsp();\n    assertEquals(uncompleteHsp, o);\n}", "repo_id": "9", "comment": "/**\n * Test of equals method, of class Hsp.\n */\n", "repo_name": "biojava-master/", "id": 3197, "method_signature": "void testEquals()"}, "3656": {"callee_method_names": [], "method_name": "SurvivalInfo.setOffset", "method_implementation": "{\n    this.offset = offset;\n}", "repo_id": "9", "comment": "/**\n * @param offset the offset to set\n */\n", "repo_name": "biojava-master/", "id": 3656, "method_signature": "void setOffset(double)"}, "3659": {"callee_method_names": [], "method_name": "SurvivalInfo.getStrata", "method_implementation": "{\n    return strata;\n}", "repo_id": "9", "comment": "/**\n * @return the strata\n */\n", "repo_name": "biojava-master/", "id": 3659, "method_signature": "int getStrata()"}, "2958": {"callee_method_ids": [3076, 3076, 3076], "callee_method_names": ["CDSSequence.getStrand", "CDSSequence.getStrand", "CDSSequence.getBioBegin", "CDSSequence.getBioBegin", "CDSSequence.getStrand", "CDSSequence.getBioBegin", "CDSSequence.getBioBegin", "CDSSequence.getBioBegin", "CDSSequence.getBioBegin"], "method_name": "CDSComparator.compare", "method_implementation": "{\n    if (o1.getStrand() != o2.getStrand()) {\n        return o1.getBioBegin() - o2.getBioBegin();\n    }\n    if (o1.getStrand() == Strand.NEGATIVE) {\n        return -1 * (o1.getBioBegin() - o2.getBioBegin());\n    }\n    return o1.getBioBegin() - o2.getBioBegin();\n}", "repo_id": "9", "comment": "/**\n * Used to sort two CDSSequences where Negative Strand makes it tough\n * @param o1\n * @param o2\n * @return val\n */\n", "repo_name": "biojava-master/", "id": 2958, "method_signature": "int compare(CDSSequence, CDSSequence)"}, "750": {"callee_method_names": [], "method_name": "CeParameters.setMaxGapSize", "method_implementation": "{\n    this.maxGapSize = maxGapSize;\n}", "repo_id": "9", "comment": "/**\n * Set the Max gap size parameter. Default 30. For unlimited gaps set to -1\n *\n * @param maxGapSize\n */\n", "repo_name": "biojava-master/", "id": 750, "method_signature": "void setMaxGapSize(Integer)"}, "1268": {"callee_method_names": [], "method_name": "MmtfStructureReader.setInterGroupBond", "method_implementation": "{\n    // Get the atoms\n    Atom atomOne = allAtoms[indOne];\n    Atom atomTwo = allAtoms[indTwo];\n    // set the new bond (this\n    new BondImpl(atomOne, atomTwo, bondOrder);\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoder\n\t * Interface#setInterGroupBonds(int, int, int)\n\t */\n", "repo_name": "biojava-master/", "id": 1268, "method_signature": "void setInterGroupBond(int, int, int)"}, "2512": {"callee_method_names": [], "method_name": "AAindexFactory.getAAIndexProvider", "method_implementation": "{\n    if (provider == null)\n        provider = new DefaultAAIndexProvider();\n    return provider;\n}", "repo_id": "9", "comment": "/**\n * Gets singleton instance of an {@code AAIndexProvider}, always non-null\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2512, "method_signature": "AAIndexProvider getAAIndexProvider()"}, "602": {"callee_method_names": ["Structure.addModel", "Structure.addModel"], "method_name": "AlignmentTools.getAlignedStructure", "method_implementation": "{\n    /* Previous implementation commented\n\n\t\tStructure s = new StructureImpl();\n\n\n\t\tList<Chain>model1 = getAlignedModel(ca1);\n\t\tList<Chain>model2 = getAlignedModel(ca2);\n\t\ts.addModel(model1);\n\t\ts.addModel(model2);\n\n\t\treturn s;*/\n    Structure s = new StructureImpl();\n    List<Chain> model1 = getAlignedModel(ca1);\n    s.addModel(model1);\n    List<Chain> model2 = getAlignedModel(ca2);\n    s.addModel(model2);\n    return s;\n}", "repo_id": "9", "comment": "/**\n * Get an artifical Structure containing both chains.\n * Does NOT rotate anything\n * @param ca1\n * @param ca2\n * @return a structure object containing two models, one for each set of Atoms.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 602, "method_signature": "Structure getAlignedStructure(Atom[], Atom[])"}, "1226": {"callee_method_names": [], "method_name": "PDBBioAssemblyParser.getTransformationMap", "method_implementation": "{\n    return transformationMap;\n}", "repo_id": "9", "comment": "/**\n * Returns a map of bioassembly transformations\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1226, "method_signature": "Map<Integer,BioAssemblyInfo> getTransformationMap()"}, "3250": {"callee_method_names": ["String.equals", "AutoSuggestProvider.getSuggestion", "Vector<String>.size", "JList.setListData", "JList.setSelectedIndex", "JList.ensureIndexIsVisible", "JDialog.setVisible", "JDialog.setVisible"], "method_name": "JAutoSuggest.doInBackground", "method_implementation": "{\n    try {\n        setFont(busy);\n        String userInput = getText().trim();\n        if (userInput == null || \"\".equals(userInput))\n            return \"\";\n        if (previousWord != null) {\n            if (userInput.equals(previousWord))\n                return \"\";\n        }\n        previousWord = userInput;\n        suggestions = autoSuggestProvider.getSuggestion(userInput);\n        setFont(regular);\n        if (suggestions.size() > 0) {\n            list.setListData(suggestions);\n            list.setSelectedIndex(0);\n            list.ensureIndexIsVisible(0);\n            dialog.setVisible(true);\n        } else {\n            dialog.setVisible(false);\n        }\n    } catch (Exception e) {\n        //e.printStackTrace();\n        // ignore...\n    }\n    return \"Done.\";\n}", "repo_id": "9", "comment": "/**\n * Standard run method used in threads\n * responsible for the actual search\n */\n", "repo_name": "biojava-master/", "id": 3250, "method_signature": "String doInBackground()"}, "3340": {"callee_method_names": ["Color.getRed", "Color.getGreen", "Color.getBlue", "Color.getRed", "Color.getGreen", "Color.getBlue", "Color.getAlpha"], "method_name": "ColorUtils.rotateHue", "method_implementation": "{\n    float[] af = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);\n    float hue = af[0];\n    float saturation = af[1];\n    float brightness = af[2];\n    float hueNew = hue + fraction;\n    Color hsb = Color.getHSBColor(hueNew, saturation, brightness);\n    return new Color(hsb.getRed(), hsb.getGreen(), hsb.getBlue(), color.getAlpha());\n}", "repo_id": "9", "comment": "/**\n * Rotate a color through HSB space\n * @param color Starting color\n * @param fraction Amount to add to the hue. The integer part is discarded to leave a number in [0,1)\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3340, "method_signature": "Color rotateHue(Color, float)"}, "988": {"callee_method_names": [], "method_name": "HetatomImpl.setProperties", "method_implementation": "{\n    properties = props;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 988, "method_signature": "void setProperties(Map)"}, "2916": {"callee_method_names": ["ArrayList.add"], "method_name": "AbstractSequence.addNote", "method_implementation": "{\n    notesList.add(note);\n}", "repo_id": "9", "comment": "/**\n * Add notes about this sequence that will get exported for GFF3\n * @param note\n */\n", "repo_name": "biojava-master/", "id": 2916, "method_signature": "void addNote(String)"}, "2009": {"callee_method_names": [], "method_name": "Tetrahedron.getInscribedRadius", "method_implementation": "{\n    double side = getSideLengthFromCircumscribedRadius(circumscribedRadius);\n    return getInscribedRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of an inscribed sphere, that is tangent to each\n * of the tetrahedrons's faces\n * @return the inscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2009, "method_signature": "double getInscribedRadius()"}, "1016": {"callee_method_names": ["Structure.getChains", "Chain.getAtomLength"], "method_name": "StructureTools.getNrGroups", "method_implementation": "{\n    int nrGroups = 0;\n    List<Chain> chains = s.getChains(0);\n    for (Chain c : chains) {\n        nrGroups += c.getAtomLength();\n    }\n    return nrGroups;\n}", "repo_id": "9", "comment": "/**\n * Count how many groups are contained within a structure object.\n *\n * @param s\n *            the structure object\n * @return the number of groups in the structure\n */\n", "repo_name": "biojava-master/", "id": 1016, "method_signature": "int getNrGroups(Structure)"}, "1988": {"callee_method_names": ["Vector3d.dot", "Vector3d.cross", "Vector3d.normalize", "AxisAngle4d.set", "Vector3d.angle", "Matrix4d.set", "Matrix4d.setElement", "Matrix4d.setIdentity", "Matrix4d.set", "Matrix4d.transform", "Matrix4d.transform", "Vector3d.dot", "Vector3d.cross", "Vector3d.normalize", "AxisAngle4d.set", "Vector3d.angle", "Matrix4d.set", "Matrix4d.setElement", "Matrix4d.setIdentity", "Matrix4d.set", "Matrix4d.transform", "Matrix4d.transform", "Matrix4d.mul", "Logger.warn"], "method_name": "RotationAxisAligner.alignAxes", "method_implementation": "{\n    Matrix4d m1 = new Matrix4d();\n    AxisAngle4d a = new AxisAngle4d();\n    Vector3d axis = new Vector3d();\n    // calculate rotation matrix to rotate refPoints[0] into coordPoints[0]\n    Vector3d v1 = new Vector3d(axisVectors[0]);\n    Vector3d v2 = new Vector3d(referenceVectors[0]);\n    double dot = v1.dot(v2);\n    if (Math.abs(dot) < 0.999) {\n        axis.cross(v1, v2);\n        axis.normalize();\n        a.set(axis, v1.angle(v2));\n        m1.set(a);\n        // make sure matrix element m33 is 1.0. It's 0 on Linux.\n        m1.setElement(3, 3, 1.0);\n    } else if (dot > 0) {\n        // parallel axis, nothing to do -> identity matrix\n        m1.setIdentity();\n    } else if (dot < 0) {\n        // anti-parallel axis, flip around x-axis\n        m1.set(flipX());\n    }\n    // apply transformation matrix to all refPoints\n    m1.transform(axisVectors[0]);\n    m1.transform(axisVectors[1]);\n    // calculate rotation matrix to rotate refPoints[1] into coordPoints[1]\n    v1 = new Vector3d(axisVectors[1]);\n    v2 = new Vector3d(referenceVectors[1]);\n    Matrix4d m2 = new Matrix4d();\n    dot = v1.dot(v2);\n    if (Math.abs(dot) < 0.999) {\n        axis.cross(v1, v2);\n        axis.normalize();\n        a.set(axis, v1.angle(v2));\n        m2.set(a);\n        // make sure matrix element m33 is 1.0. It's 0 on Linux.\n        m2.setElement(3, 3, 1.0);\n    } else if (dot > 0) {\n        // parallel axis, nothing to do -> identity matrix\n        m2.setIdentity();\n    } else if (dot < 0) {\n        // anti-parallel axis, flip around z-axis\n        m2.set(flipZ());\n    }\n    // apply transformation matrix to all refPoints\n    m2.transform(axisVectors[0]);\n    m2.transform(axisVectors[1]);\n    // combine the two rotation matrices\n    m2.mul(m1);\n    // the RMSD should be close to zero\n    Point3d[] axes = new Point3d[2];\n    axes[0] = new Point3d(axisVectors[0]);\n    axes[1] = new Point3d(axisVectors[1]);\n    Point3d[] ref = new Point3d[2];\n    ref[0] = new Point3d(referenceVectors[0]);\n    ref[1] = new Point3d(referenceVectors[1]);\n    if (CalcPoint.rmsd(axes, ref) > 0.1) {\n        logger.warn(\"AxisTransformation: axes alignment is off. RMSD: \" + CalcPoint.rmsd(axes, ref));\n    }\n    return m2;\n}", "repo_id": "9", "comment": "/**\n * Returns a transformation matrix that rotates refPoints to match\n * coordPoints\n * @param refPoints the points to be aligned\n * @param referenceVectors\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1988, "method_signature": "Matrix4d alignAxes(Vector3d[], Vector3d[])"}, "2984": {"callee_method_names": [], "method_name": "BitSequenceReader.setContents", "method_implementation": "{\n    throw new UnsupportedOperationException(getClass().getSimpleName() + \" is an immutable data structure; cannot reset contents\");\n}", "repo_id": "9", "comment": "/**\n * Class is immutable & so this is unsupported\n */\n", "repo_name": "biojava-master/", "id": 2984, "method_signature": "void setContents(String)"}, "2173": {"callee_method_names": ["Structure.getChains", "Chain.getAtomGroups", "Group.getAtoms", "Atom.getCharge"], "method_name": "TestChargeAdder.testBasic", "method_implementation": "{\n    // Get the structure\n    Structure structure = StructureIO.getStructure(\"3AAE\");\n    ChargeAdder.addCharges(structure);\n    // Now count the charges\n    int chargeCount = 0;\n    for (Chain chain : structure.getChains()) {\n        for (Group group : chain.getAtomGroups()) {\n            for (Atom atom : group.getAtoms()) {\n                if (atom.getCharge() != 0) {\n                    chargeCount++;\n                }\n            }\n        }\n    }\n    // Check that the count is as excpected\n    assertEquals(425, chargeCount);\n}", "repo_id": "9", "comment": "/**\n * Test that it works on a very basic level.\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2173, "method_signature": "void testBasic()"}, "882": {"callee_method_ids": [1339, 1339], "callee_method_names": ["Logger.warn", "EntityInfo.getRepresentative", "EntityInfo.getRepresentative"], "method_name": "StructureInterface.isHomomeric", "method_implementation": "{\n    EntityInfo first = getParentChains().getFirst().getEntityInfo();\n    EntityInfo second = getParentChains().getSecond().getEntityInfo();\n    if (first == null || second == null) {\n        logger.warn(\"Some compound of interface {} is null, can't determine whether it is homo/heteromeric. Consider it homomeric\", getId());\n        return true;\n    }\n    return first.getRepresentative().getId().equals(second.getRepresentative().getId());\n}", "repo_id": "9", "comment": "/**\n * Returns true if the 2 molecules of this interface are the same entity (i.e. homomeric interface), false\n * otherwise (i.e. heteromeric interface)\n * @return true if homomeric or if either of the entities is unknonw (null Compounds), false otherwise\n */\n", "repo_name": "biojava-master/", "id": 882, "method_signature": "boolean isHomomeric()"}, "1635": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setInternalSymmetry", "method_implementation": "{\n    this.internalSymmetry = internalSymmetry;\n}", "repo_id": "9", "comment": "/**\n * The internal symmetry option divides each {@link Subunit} of each\n * {@link SubunitCluster} into its internally symmetric repeats.\n * <p>\n * The {@link SubunitClustererMethod#STRUCTURE} must be chosen to consider\n * internal symmetry, otherwise this parameter will be ignored.\n *\n * @param internalSymmetry\n *            true if internal symmetry is considered, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 1635, "method_signature": "void setInternalSymmetry(boolean)"}, "2287": {"callee_method_ids": [1568], "callee_method_names": ["Site.remark800toPDB", "StringBuffer.toString"], "method_name": "SiteTest.testRemark800ToPDB_StringBuffer", "method_implementation": "{\n    //        System.out.println(\"remark800toPDB\");\n    StringBuffer buf = new StringBuffer(\"\");\n    String expResult = \"REMARK 800 SITE_IDENTIFIER: CAT                                                 \" + newline + \"REMARK 800 EVIDENCE_CODE: UNKNOWN                                               \" + newline + \"REMARK 800 SITE_DESCRIPTION: ACTIVE SITE                                        \" + newline;\n    catSite.remark800toPDB(buf);\n    String result = buf.toString();\n    //        System.out.println(result);\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of toPDB method, of class Site.\n */\n", "repo_name": "biojava-master/", "id": 2287, "method_signature": "void testRemark800ToPDB_StringBuffer()"}, "3154": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.toString", "method_implementation": "{\n    return getSequenceAsString();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3154, "method_signature": "String toString()"}, "3153": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.getLastIndexOf", "method_implementation": "{\n    return this.parsedCompounds.lastIndexOf(compound) + 1;\n}", "repo_id": "9", "comment": "/**\n * @param compound\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3153, "method_signature": "int getLastIndexOf(C)"}, "1384": {"callee_method_names": [], "method_name": "DBRef.getDbSeqEnd", "method_implementation": "{\n    return dbSeqEnd;\n}", "repo_id": "9", "comment": "/**\n * Ending sequence position  of the database segment.\n * @return dbSeqEnd\n * @see #setDbSeqEnd(int)\n */\n", "repo_name": "biojava-master/", "id": 1384, "method_signature": "int getDbSeqEnd()"}, "2029": {"callee_method_names": [], "method_name": "RectangularPrism.getCirumscribedRadius", "method_implementation": "{\n    return 0.5 * Math.sqrt(width * width + height * height + length * length);\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a circumscribed sphere (length of diagonal of\n * rectangular prism/2, that goes through at least four vertices\n * @return the cirumscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2029, "method_signature": "double getCirumscribedRadius()"}, "1686": {"callee_method_names": [], "method_name": "AugmentedResidueRange.iterator", "method_implementation": "{\n    return super.iterator(map);\n}", "repo_id": "9", "comment": "/**\n * Returns a new Iterator over every {@link ResidueNumber} in this ResidueRange.\n * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n */\n", "repo_name": "biojava-master/", "id": 1686, "method_signature": "Iterator<ResidueNumber> iterator()"}, "3038": {"callee_method_names": ["int.getEnd", "ResidueNumber.getEnd"], "method_name": "Tools.getMax", "method_implementation": "{\n    return scanLocations(locations, new LocationPredicate() {\n\n        @Override\n        public boolean accept(Location previous, Location current) {\n            int res = current.getEnd().compareTo(previous.getEnd());\n            return res > 0;\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Scans through a list of locations to find the Location with the\n * highest end\n */\n", "repo_name": "biojava-master/", "id": 3038, "method_signature": "Location getMax(List)"}, "2388": {"callee_method_ids": [2449, 2431], "callee_method_names": ["Logger.info", "Path.toString", "FeatureList.addIndexes", "BufferedReader.readLine", "BufferedReader.readLine", "String.trim", "String.length", "String.charAt", "String.startsWith", "FeatureList.add"], "method_name": "GFF3Reader.read", "method_implementation": "{\n    logger.info(\"Reading: {}\", path.toString());\n    FeatureList features = new FeatureList();\n    features.addIndexes(indexes);\n    try (BufferedReader br = Files.newBufferedReader(path)) {\n        String s;\n        for (s = br.readLine(); null != s; s = br.readLine()) {\n            s = s.trim();\n            if (s.length() > 0) {\n                if (s.charAt(0) == '#') {\n                    //ignore comment lines\n                    if (s.startsWith(\"##fasta\"))\n                        break;\n                } else {\n                    FeatureI f = parseLine(s);\n                    if (f != null) {\n                        features.add(f);\n                    }\n                }\n            }\n        }\n    }\n    return features;\n}", "repo_id": "9", "comment": "/**\n * Read a file into a FeatureList. Each line of the file becomes one Feature object.\n *\n * @param path The path to the GFF file.\n * @return A FeatureList.\n * @throws IOException Something went wrong -- check exception detail message.\n */\n", "repo_name": "biojava-master/", "id": 2388, "method_signature": "FeatureList read(Path, List)"}, "3397": {"callee_method_ids": [1885, 1884], "callee_method_names": ["RotationAxisAligner.getSubunits", "QuatSymmetrySubunits.getSubunitCount", "QuatSymmetrySubunits.getModelNumbers", "QuatSymmetrySubunits.getChainIds", "QuatSymmetrySubunits.getClusterIds", "List<Integer>.get", "Map<Color4f, List<String>>.get", "Map<Color4f, List<String>>.put", "List<String>.add"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.colorBySequenceCluster", "method_implementation": "{\n    QuatSymmetrySubunits subunits = rotationAxisAligner.getSubunits();\n    int n = subunits.getSubunitCount();\n    List<Integer> modelNumbers = subunits.getModelNumbers();\n    List<String> chainIds = subunits.getChainIds();\n    List<Integer> seqClusterIds = subunits.getClusterIds();\n    int clusters = Collections.max(seqClusterIds) + 1;\n    Color[] col = ColorBrewer.BrBG.getColorPalette(clusters);\n    Color4f[] colors = ColorConverter.convertColor4f(col);\n    Map<Color4f, List<String>> colorMap = new HashMap<Color4f, List<String>>();\n    for (int i = 0; i < n; i++) {\n        Color4f c = colors[seqClusterIds.get(i)];\n        List<String> ids = colorMap.get(c);\n        if (ids == null) {\n            ids = new ArrayList<String>();\n            colorMap.put(c, ids);\n        }\n        String id = getChainSpecification(modelNumbers, chainIds, i);\n        ids.add(id);\n    }\n    return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#colorBySequenceCluster()\n\t */\n", "repo_name": "biojava-master/", "id": 3397, "method_signature": "String colorBySequenceCluster()"}, "3854": {"callee_method_names": ["HashMap.put"], "method_name": "Constraints.initInstability", "method_implementation": "{\n    double[][] instability = { //W\t\tC\t\tM\t\tH\t\tY\t\tF\t\tQ\t\tN\t\tI\t\tR\t\tD\t\tP\t\tT\t\tK\t\tE\t\tV\t\tS\t\tG\t\tA\t\tL\n    { 1.0, 1.0, 24.68, 24.68, 1.0, 1.0, 1.0, 13.34, 1.0, 1.0, 1.0, 1.0, -14.03, 1.0, 1.0, -7.49, 1.0, -9.37, -14.03, 13.34 }, { 24.68, 1.0, 33.6, 33.6, 1.0, 1.0, -6.54, 1.0, 1.0, 1.0, 20.26, 20.26, 33.6, 1.0, 1.0, -6.54, 1.0, 1.0, 1.0, 20.26 }, { 1.0, 1.0, -1.88, 58.28, 24.68, 1.0, -6.54, 1.0, 1.0, -6.54, 1.0, 44.94, -1.88, 1.0, 1.0, 1.0, 44.94, 1.0, 13.34, 1.0 }, { -1.88, 1.0, 1.0, 1.0, 44.94, -9.37, 1.0, 24.68, 44.94, 1.0, 1.0, -1.88, -6.54, 24.68, 1.0, 1.0, 1.0, -9.37, 1.0, 1.0 }, { -9.37, 1.0, 44.94, 13.34, 13.34, 1.0, 1.0, 1.0, 1.0, -15.91, 24.68, 13.34, -7.49, 1.0, -6.54, 1.0, 1.0, -7.49, 24.68, 1.0 }, { 1.0, 1.0, 1.0, 1.0, 33.6, 1.0, 1.0, 1.0, 1.0, 1.0, 13.34, 20.26, 1.0, -14.03, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }, { 1.0, -6.54, 1.0, 1.0, -6.54, -6.54, 20.26, 1.0, 1.0, 1.0, 20.26, 20.26, 1.0, 1.0, 20.26, -6.54, 44.94, 1.0, 1.0, 1.0 }, { -9.37, -1.88, 1.0, 1.0, 1.0, -14.03, -6.54, 1.0, 44.94, 1.0, 1.0, -1.88, -7.49, 24.68, 1.0, 1.0, 1.0, -14.03, 1.0, 1.0 }, { 1.0, 1.0, 1.0, 13.34, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.88, 1.0, -7.49, 44.94, -7.49, 1.0, 1.0, 1.0, 20.26 }, { 58.28, 1.0, 1.0, 20.26, -6.54, 1.0, 20.26, 13.34, 1.0, 58.28, 1.0, 20.26, 1.0, 1.0, 1.0, 1.0, 44.94, -7.49, 1.0, 1.0 }, { 1.0, 1.0, 1.0, 1.0, 1.0, -6.54, 1.0, 1.0, 1.0, -6.54, 1.0, 1.0, -14.03, -7.49, 1.0, 1.0, 20.26, 1.0, 1.0, 1.0 }, { -1.88, -6.54, -6.54, 1.0, 1.0, 20.26, 20.26, 1.0, 1.0, -6.54, -6.54, 20.26, 1.0, 1.0, 18.38, 20.26, 20.26, 1.0, 20.26, 1.0 }, { -14.03, 1.0, 1.0, 1.0, 1.0, 13.34, -6.54, -14.03, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 20.26, 1.0, 1.0, -7.49, 1.0, 1.0 }, { 1.0, 1.0, 33.6, 1.0, 1.0, 1.0, 24.68, 1.0, -7.49, 33.6, 1.0, -6.54, 1.0, 1.0, 1.0, -7.49, 1.0, -7.49, 1.0, -7.49 }, { -14.03, 44.94, 1.0, -6.54, 1.0, 1.0, 20.26, 1.0, 20.26, 1.0, 20.26, 20.26, 1.0, 1.0, 33.6, 1.0, 20.26, 1.0, 1.0, 1.0 }, { 1.0, 1.0, 1.0, 1.0, -6.54, 1.0, 1.0, 1.0, 1.0, 1.0, -14.03, 20.26, -7.49, -1.88, 1.0, 1.0, 1.0, -7.49, 1.0, 1.0 }, { 1.0, 33.6, 1.0, 1.0, 1.0, 1.0, 20.26, 1.0, 1.0, 20.26, 1.0, 44.94, 1.0, 1.0, 20.26, 1.0, 20.26, 1.0, 1.0, 1.0 }, { 13.34, 1.0, 1.0, 1.0, -7.49, 1.0, 1.0, -7.49, -7.49, 1.0, 1.0, 1.0, -7.49, -7.49, -6.54, 1.0, 1.0, 13.34, -7.49, 1.0 }, { 1.0, 44.94, 1.0, -7.49, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -7.49, 20.26, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }, { 24.68, 1.0, 1.0, 1.0, 1.0, 1.0, 33.6, 1.0, 1.0, 20.26, 1.0, 20.26, 1.0, -7.49, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 } };\n    SingleLetterAACode[] aa = SingleLetterAACode.values();\n    for (int i = 0; i < aa.length; i++) {\n        for (int j = 0; j < aa.length; j++) {\n            diAA2Instability.put(\"\" + aa[i] + aa[j], instability[i][j]);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Does the initialization of dipeptide instability index based on the following paper\n *\n * Guruprasad, K., Reddy, B.V.B. and Pandit, M.W. (1990)\n * Correlation between stability of a protein and its dipeptide composition: a novel approach for predicting in vivo stability of a protein from its primary sequence.\n * Protein Eng. 4,155-161. Table III.\n */\n", "repo_name": "biojava-master/", "id": 3854, "method_signature": "void initInstability()"}, "349": {"callee_method_names": ["Atom.getX", "Atom.getX", "Atom.getY", "Atom.getY", "Atom.getZ", "Atom.getZ"], "method_name": "Calc.scalarProduct", "method_implementation": "{\n    return a.getX() * b.getX() + a.getY() * b.getY() + a.getZ() * b.getZ();\n}", "repo_id": "9", "comment": "/**\n * Scalar product (dot product).\n *\n * @param a\n *            an Atom object\n * @param b\n *            an Atom object\n * @return a double\n */\n", "repo_name": "biojava-master/", "id": 349, "method_signature": "double scalarProduct(Atom, Atom)"}, "1694": {"callee_method_names": [], "method_name": "AtomImpl.getX", "method_implementation": "{\n    return coords.x;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1694, "method_signature": "double getX()"}, "3834": {"callee_method_names": ["double[].getSymbol", "double[].getSymbol", "double[].getSymbol", "double[].getElementList", "double[].getElementList", "ElementTable.getElement", "ElementTable.getElement", "ElementTable.getElement", "double[].getIsotopeList", "double[].getIsotopeList", "ElementTable.getIsotope", "ElementTable.getIsotope", "ElementTable.getIsotope", "double[].getSymbol"], "method_name": "AminoAcidCompositionTable.computeMolecularWeight", "method_implementation": "{\n    this.aaSymbol2MolecularWeight = new HashMap<Character, Double>();\n    for (AminoAcidComposition a : aminoacid) {\n        //Check to ensure that the symbol is of single character\n        if (a.getSymbol().length() != 1) {\n            throw new Error(a.getSymbol() + \" is not allowed. Symbols must be single character.\\r\\nPlease check AminoAcidComposition XML file\");\n        }\n        //Check to ensure that the symbols are not repeated\n        char c = a.getSymbol().charAt(0);\n        if (this.aaSymbol2MolecularWeight.keySet().contains(c)) {\n            throw new Error(\"Symbol \" + c + \" is repeated.\\r\\n\" + \"Please check AminoAcidComposition XML file to ensure there are no repeated symbols. Note that this is case-insensitive.\\r\\n\" + \"This means that having 'A' and 'a' would be repeating.\");\n        }\n        double total = 0.0;\n        if (a.getElementList() != null) {\n            for (Name2Count element : a.getElementList()) {\n                element.getName();\n                if (eTable.getElement(element.getName()) == null) {\n                    throw new Error(\"Element \" + element.getName() + \" could not be found. \" + \"\\r\\nPlease ensure that its name is correct in AminoAcidComposition.xml and is defined in ElementMass.xml.\");\n                }\n                eTable.getElement(element.getName()).getMass();\n                total += eTable.getElement(element.getName()).getMass() * element.getCount();\n            }\n        }\n        if (a.getIsotopeList() != null) {\n            for (Name2Count isotope : a.getIsotopeList()) {\n                isotope.getName();\n                if (eTable.getIsotope(isotope.getName()) == null) {\n                    throw new Error(\"Isotope \" + isotope.getName() + \" could not be found. \" + \"\\r\\nPlease ensure that its name is correct in AminoAcidComposition.xml and is defined in ElementMass.xml.\");\n                }\n                eTable.getIsotope(isotope.getName()).getMass();\n                total += eTable.getIsotope(isotope.getName()).getMass() * isotope.getCount();\n            }\n        }\n        c = a.getSymbol().charAt(0);\n        this.aaSymbol2MolecularWeight.put(c, total);\n    }\n    generatesAminoAcidCompoundSet();\n}", "repo_id": "9", "comment": "/**\n * Computes and store the molecular weight of each amino acid by its symbol in aaSymbol2MolecularWeight.\n *\n * @param eTable\n * \t\tStores the mass of elements and isotopes\n */\n", "repo_name": "biojava-master/", "id": 3834, "method_signature": "void computeMolecularWeight(ElementTable)"}, "759": {"callee_method_names": [], "method_name": "CeParameters.setSeqWeight", "method_implementation": "{\n    this.seqWeight = seqWeight;\n}", "repo_id": "9", "comment": "/**\n * Should sequence conservation be considered as part of the alignment? If yes, this weight factor allows to determine how much.\n *  By default this is set to 0, meaning no contribution of the sequence alignment score.\n *\n * @param seqWeight the weight factor (default 0)\n */\n", "repo_name": "biojava-master/", "id": 759, "method_signature": "void setSeqWeight(double)"}, "2584": {"callee_method_names": ["Element.getOwnerDocument", "Element.appendChild"], "method_name": "XMLHelper.addChildElement", "method_implementation": "{\n    Element childElement = parentElement.getOwnerDocument().createElement(elementName);\n    parentElement.appendChild(childElement);\n    return childElement;\n}", "repo_id": "9", "comment": "/**\n * Creates a new element called {@code}elementName{@code} and adds it to {@code}parentElement{@code}\n * @param parentElement\n * @param elementName\n * @return the new child element\n */\n", "repo_name": "biojava-master/", "id": 2584, "method_signature": "Element addChildElement(Element, String)"}, "1405": {"callee_method_names": ["CrystalCell.getB"], "method_name": "PDBCrystallographicInfo.getB", "method_implementation": "{\n    return (float) cell.getB();\n}", "repo_id": "9", "comment": "/**\n * @return the unit cell parameter b\n */\n", "repo_name": "biojava-master/", "id": 1405, "method_signature": "float getB()"}, "2611": {"callee_method_names": [], "method_name": "ConcurrencyTools.setThreadPoolSingle", "method_implementation": "{\n    setThreadPoolSize(1);\n}", "repo_id": "9", "comment": "/**\n * Sets thread pool to a single background thread.\n */\n", "repo_name": "biojava-master/", "id": 2611, "method_signature": "void setThreadPoolSingle()"}, "3347": {"callee_method_ids": [3356, 3356, 3356, 3356, 3356, 3356, 3356, 3356, 3362, 3356, 3356, 3362], "callee_method_names": ["GradientMapper.put", "GradientMapper.put", "GradientMapper.put", "GradientMapper.put", "GradientMapper.put", "GradientMapper.put", "LinearColorInterpolator.setInterpolationDirection", "GradientMapper.put", "GradientMapper.put", "GradientMapper.setInterpolator", "LinearColorInterpolator.setInterpolationDirection", "GradientMapper.put", "GradientMapper.put", "GradientMapper.setInterpolator"], "method_name": "GradientMapper.getGradientMapper", "method_implementation": "{\n    GradientMapper gm;\n    switch(gradientType) {\n        case BLACK_WHITE_GRADIENT:\n            gm = new GradientMapper(Color.BLACK, Color.WHITE);\n            gm.put(min, Color.BLACK);\n            gm.put(max, Color.WHITE);\n            return gm;\n        case WHITE_BLACK_GRADIENT:\n            gm = new GradientMapper(Color.WHITE, Color.BLACK);\n            gm.put(min, Color.WHITE);\n            gm.put(max, Color.BLACK);\n            return gm;\n        case RED_BLUE_GRADIENT:\n            gm = new GradientMapper(Color.RED, Color.BLUE);\n            gm.put(min, Color.RED);\n            gm.put(max, Color.BLUE);\n            return gm;\n        case RAINBOW_GRADIENT:\n            {\n                //Set up interpolation in HSV colorspace\n                ColorSpace hsv = HSVColorSpace.getHSVColorSpace();\n                LinearColorInterpolator interp = new LinearColorInterpolator(hsv);\n                interp.setInterpolationDirection(0, InterpolationDirection.UPPER);\n                Color hsvLow = new Color(hsv, new float[] { 0f, 1f, 1f }, 1f);\n                Color hsvHigh = new Color(hsv, new float[] { 1f, 1f, 1f }, 1f);\n                gm = new GradientMapper(hsvLow, hsvHigh, hsv);\n                gm.put(min, hsvLow);\n                gm.put(max, hsvHigh);\n                gm.setInterpolator(interp);\n                return gm;\n            }\n        case RAINBOW_INTENSITY_GRADIENT:\n            {\n                //Set up interpolation in HSV colorspace\n                ColorSpace hsv = HSVColorSpace.getHSVColorSpace();\n                LinearColorInterpolator interp = new LinearColorInterpolator(hsv);\n                interp.setInterpolationDirection(0, InterpolationDirection.LOWER);\n                Color hsvLow = new Color(hsv, new float[] { 1f, 1f, 1f }, 1f);\n                Color hsvHigh = new Color(hsv, new float[] { 0f, 1f, 0f }, 1f);\n                gm = new GradientMapper(hsvLow, hsvHigh, hsv);\n                gm.put(min, hsvLow);\n                gm.put(max, hsvHigh);\n                gm.setInterpolator(interp);\n                return gm;\n            }\n        default:\n            throw new IllegalArgumentException(\"Unsupported gradient \" + gradientType);\n    }\n}", "repo_id": "9", "comment": "/**\n * Constructs a gradientMapper to draw one of the pre-defined gradients\n *\n * For example,\n * GradientMapper.getGradientMapper(GradientMapper.RAINBOW_GRADIENT, 0, 10)\n *\n * @param gradientType One of the gradient types, eg GradientMapper.BLACK_WHITE_GRADIENT\n * @param min Start of the gradient\n * @param max End of the gradient\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3347, "method_signature": "GradientMapper getGradientMapper(int, double, double)"}, "160": {"callee_method_names": [], "method_name": "CifFileSupplierIntegrationTest.test2N3J", "method_implementation": "{\n    // an NMR structure (multimodel) with 2 chains\n    testRoundTrip(\"2N3J\");\n}", "repo_id": "9", "comment": "/**\n * MMCIF write test for an NMR structure with 2 chains\n * @throws IOException propagated\n */\n", "repo_name": "biojava-master/", "id": 160, "method_signature": "void test2N3J()"}, "3515": {"callee_method_names": [], "method_name": "StrataInfo.getTime", "method_implementation": "{\n    return time;\n}", "repo_id": "9", "comment": "/**\n * @return the time\n */\n", "repo_name": "biojava-master/", "id": 3515, "method_signature": "ArrayList<Double> getTime()"}, "1929": {"callee_method_names": ["HelixLayers.size", "RotationGroup.getOrder", "RotationGroup.getPointGroup"], "method_name": "QuatSymmetryResults.getSymmetry", "method_implementation": "{\n    if (helixLayers != null && helixLayers.size() > 0) {\n        return \"H\";\n    } else if (rotationGroup != null && rotationGroup.getOrder() > 0) {\n        return rotationGroup.getPointGroup();\n    }\n    return \"\";\n}", "repo_id": "9", "comment": "/**\n * @return the symmetry group symbol. For point groups returns the point\n *         group symbol and for helical symmetry returns \"H\".\n */\n", "repo_name": "biojava-master/", "id": 1929, "method_signature": "String getSymmetry()"}, "3330": {"callee_method_names": [], "method_name": "SequenceDisplay.setIdx2", "method_implementation": "{\n    this.idx2 = idx;\n}", "repo_id": "9", "comment": "/**\n * set the identical positions in the alignment\n *\n * @param idx identical positions for structure2\n */\n", "repo_name": "biojava-master/", "id": 3330, "method_signature": "void setIdx2(int[])"}, "776": {"callee_method_ids": [505, 506], "callee_method_names": ["AFPChain.getDistanceMatrix", "Matrix.getRowDimension", "Matrix.getColumnDimension", "Matrix.getMatrix", "Matrix.getRowDimension", "Matrix.getColumnDimension", "AFPChain.setDistanceMatrix", "AFPChain.getOptLength"], "method_name": "CeCPMain.postProcessAlignment", "method_implementation": "{\n    // remove bottom half of the matrix\n    Matrix doubledMatrix = afpChain.getDistanceMatrix();\n    // the matrix can be null if the alignment is too short.\n    if (doubledMatrix != null) {\n        assert (doubledMatrix.getRowDimension() == ca1.length);\n        assert (doubledMatrix.getColumnDimension() == ca2m.length);\n        Matrix singleMatrix = doubledMatrix.getMatrix(0, ca1.length - 1, 0, (ca2m.length / 2) - 1);\n        assert (singleMatrix.getRowDimension() == ca1.length);\n        assert (singleMatrix.getColumnDimension() == (ca2m.length / 2));\n        afpChain.setDistanceMatrix(singleMatrix);\n    }\n    // Check for circular permutations\n    int alignLen = afpChain.getOptLength();\n    if (alignLen > 0) {\n        afpChain = filterDuplicateAFPs(afpChain, calculator, ca1, ca2m, param);\n    }\n    return afpChain;\n}", "repo_id": "9", "comment": "/**\n * Circular permutation specific code to be run after the standard CE alignment\n *\n * @param afpChain The finished alignment\n * @param ca1 CA atoms of the first protein\n * @param ca2m A duplicated copy of the second protein\n * @param calculator The CECalculator used to create afpChain\n * @param param Parameters\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 776, "method_signature": "AFPChain postProcessAlignment(AFPChain, Atom[], Atom[], CECalculator, CECPParameters)"}, "224": {"callee_method_names": [], "method_name": "ProteinModificationImpl.setResidName", "method_implementation": "{\n    this.residName = residName;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the RESID name.\n * @param residName RESID name.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 224, "method_signature": "Builder setResidName(String)"}, "654": {"callee_method_names": [], "method_name": "MultipleAlignmentTools.getSequenceAlignment", "method_implementation": "{\n    return getSequenceAlignment(msa, new ArrayList<Integer>());\n}", "repo_id": "9", "comment": "/**\n * Calculate the sequence alignment Strings for the whole alignment. This\n * method creates a sequence alignment where aligned residues are in\n * uppercase and unaligned residues are in lowercase, thus providing a more\n * compact way to represent the alignment.\n * <p>\n * Blocks are concatenated in the order returned by\n * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n * sequential. Gaps are represented by '-'. Separation between different\n * Blocks is indicated by a gap in all positions, meaning that there is a\n * possible discontinuity.\n *\n * @param alignment\n *            input MultipleAlignment\n * @return String for each row in the alignment, giving the 1-letter code\n *         for each aligned residue.\n */\n", "repo_name": "biojava-master/", "id": 654, "method_signature": "List<String> getSequenceAlignment(MultipleAlignment)"}, "1998": {"callee_method_names": ["RotationGroup.getRotation", "RotationGroup.getOrder", "RotationGroup.getRotation", "RotationGroup.getRotation", "RotationGroup.getPointGroup", "RotationGroup.getRotation", "Vector3d.normalize", "Vector3d.angle", "Vector3d.negate", "Vector3d.angle", "Vector3d.normalize"], "method_name": "RotationAxisAligner.getReferenceAxisDihedralWithSubunitAlignment", "method_implementation": "{\n    int maxFold = rotationGroup.getRotation(0).getFold();\n    double minAngle = Double.MAX_VALUE;\n    Vector3d refVec = null;\n    Vector3d ref = getSubunitReferenceVector();\n    for (int i = 0; i < rotationGroup.getOrder(); i++) {\n        if (rotationGroup.getRotation(i).getDirection() == 1 && (rotationGroup.getRotation(i).getFold() < maxFold) || \"D2\".equals(rotationGroup.getPointGroup())) {\n            AxisAngle4d axisAngle = rotationGroup.getRotation(i).getAxisAngle();\n            Vector3d v = new Vector3d(axisAngle.x, axisAngle.y, axisAngle.z);\n            v.normalize();\n            //\t\t\t\tSystem.out.println(\"Ref axis angle(+): \" + Math.toDegrees(v.angle(ref)));\n            double angle = v.angle(ref);\n            if (angle < minAngle) {\n                minAngle = angle;\n                refVec = v;\n            }\n            Vector3d vn = new Vector3d(v);\n            vn.negate();\n            //\t\t\t\tSystem.out.println(\"Ref axis angle(-): \" + Math.toDegrees(vn.angle(ref)));\n            angle = vn.angle(ref);\n            if (angle < minAngle) {\n                minAngle = angle;\n                refVec = vn;\n            }\n        }\n    }\n    refVec.normalize();\n    return refVec;\n}", "repo_id": "9", "comment": "/**\n */\n", "repo_name": "biojava-master/", "id": 1998, "method_signature": "Vector3d getReferenceAxisDihedralWithSubunitAlignment()"}, "2800": {"callee_method_names": ["FileInputStream.close"], "method_name": "GenbankReaderHelper.readGenbankDNASequence", "method_implementation": "{\n    FileInputStream inStream = new FileInputStream(file);\n    LinkedHashMap<String, DNASequence> dnaSequences = readGenbankDNASequence(inStream);\n    inStream.close();\n    return dnaSequences;\n}", "repo_id": "9", "comment": "/**\n * @param file\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2800, "method_signature": "LinkedHashMap<String,DNASequence> readGenbankDNASequence(File)"}, "1416": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.setNcsOperators", "method_implementation": "{\n    this.ncsOperators = ncsOperators;\n}", "repo_id": "9", "comment": "/**\n * Set the NCS operators.\n * Some PDB files contain NCS operators necessary to create the full AU.\n * Usually this happens for viral proteins.\n * See http://www.wwpdb.org/documentation/format33/sect8.html#MTRIXn .\n * Note that the \"given\" operators\n * (iGiven field =1 in PDB format, \"given\" string in _struct_ncs_oper.code in mmCIF format)\n * are not stored.\n * @param ncsOperators\n */\n", "repo_name": "biojava-master/", "id": 1416, "method_signature": "void setNcsOperators(Matrix4d[])"}, "335": {"callee_method_names": [], "method_name": "SmallMap.removeMapping", "method_implementation": "{\n    if (num < numMappings) {\n        System.arraycopy(mappings, num * 2, mappings, (num - 1) * 2, (numMappings - num) * 2);\n    }\n    mappings[numMappings * 2 - 1] = null;\n    mappings[numMappings * 2 - 2] = null;\n    numMappings--;\n}", "repo_id": "9", "comment": "// num ranges from 1 to numMappings\n", "repo_name": "biojava-master/", "id": 335, "method_signature": "void removeMapping(int)"}, "751": {"callee_method_names": [], "method_name": "CeParameters.getMaxGapSize", "method_implementation": "{\n    return maxGapSize;\n}", "repo_id": "9", "comment": "/**\n * the Max gap size parameter G . default is 30, which was\n * described to obtained empirically in the CE paper.\n * the larger the max gap size, the longer the compute time,\n * but in same cases drastically improved results. Set to -1 for unlimited gap size.\n *\n * @return max gap size parameter\n */\n", "repo_name": "biojava-master/", "id": 751, "method_signature": "Integer getMaxGapSize()"}, "2181": {"callee_method_ids": [633], "callee_method_names": ["AtomCache.getStructureForDomain", "Structure.getPolyChains", "Structure.getPolyChainByPDB", "Chain.getAtomGroups", "Structure.getNonPolyChains", "Structure.getNonPolyChain", "Chain.getAtomGroups", "Structure.getNonPolyChain", "Chain.getAtomGroups"], "method_name": "AtomCacheTest.testGetStructureForChainlessDomains", "method_implementation": "{\n    // Uses the range '1-135' without a chain\n    ScopDatabase scop = ScopFactory.getSCOP(ScopFactory.VERSION_1_71);\n    Structure structure = cache.getStructureForDomain(\"d1hcy_1\", scop);\n    //System.out.println(cache.getStructure(\"1hcy\"));\n    //System.out.println(structure);\n    assertEquals(1, structure.getPolyChains().size());\n    Chain a = structure.getPolyChainByPDB(\"A\");\n    int expectedLengthA = 135;\n    assertEquals(expectedLengthA, a.getAtomGroups().size());\n    assertEquals(2, structure.getNonPolyChains().size());\n    Chain copperM = structure.getNonPolyChain(\"M\");\n    assertEquals(1, copperM.getAtomGroups().size());\n    Chain copperN = structure.getNonPolyChain(\"N\");\n    assertEquals(1, copperN.getAtomGroups().size());\n}", "repo_id": "9", "comment": "/**\n * Test parsing of chain-less ranges (present in SCOP < 1.73)\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2181, "method_signature": "void testGetStructureForChainlessDomains()"}, "1027": {"callee_method_names": ["Atom[].getGroup", "Group.getChain", "Chain.getStructure", "Set<Chain>.addAll", "Structure.getChains", "Atom.getGroup", "Group.getChain", "Set<Chain>.add", "Set<Chain>.isEmpty", "Set<Group>.addAll", "Chain.getAtomGroups", "Set<Group>.addAll", "Chain.getAtomGroups"], "method_name": "StructureTools.getAllGroupsFromSubset", "method_implementation": "{\n    // Get the full structure\n    Structure s = null;\n    if (atoms.length > 0) {\n        Group g = atoms[0].getGroup();\n        if (g != null) {\n            Chain c = g.getChain();\n            if (c != null) {\n                s = c.getStructure();\n            }\n        }\n    }\n    // Collect all groups from the structure\n    Set<Chain> allChains = new HashSet<>();\n    if (s != null) {\n        allChains.addAll(s.getChains());\n    }\n    // In case the structure wasn't set, need to use ca chains too\n    for (Atom a : atoms) {\n        Group g = a.getGroup();\n        if (g != null) {\n            Chain c = g.getChain();\n            if (c != null) {\n                allChains.add(c);\n            }\n        }\n    }\n    if (allChains.isEmpty()) {\n        return Collections.emptySet();\n    }\n    // Extract all ligand groups\n    Set<Group> full = new HashSet<>();\n    for (Chain c : allChains) {\n        if (types == null) {\n            full.addAll(c.getAtomGroups());\n        } else {\n            full.addAll(c.getAtomGroups(types));\n        }\n    }\n    return full;\n}", "repo_id": "9", "comment": "/**\n * Expand a set of atoms into all groups from the same structure.\n *\n * If the structure is set, only the first atom is used (assuming all\n * atoms come from the same original structure).\n * If the atoms aren't linked to a structure (for instance, for cloned atoms),\n * searches all chains of all atoms for groups.\n * @param atoms Sample of atoms\n * @param types Type of groups to return (useful for getting only ligands, for instance).\n *  Null gets all groups.\n * @return All groups from all chains accessible from the input atoms\n */\n", "repo_name": "biojava-master/", "id": 1027, "method_signature": "Set<Group> getAllGroupsFromSubset(Atom[], GroupType)"}, "3586": {"callee_method_names": [], "method_name": "Matrix.scale", "method_implementation": "{\n    int m = A.length;\n    int n = A[0].length;\n    double[][] y = new double[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            y[i][j] = A[i][j] * x;\n        }\n    }\n    return y;\n}", "repo_id": "9", "comment": "/**\n * @param A\n * @param x\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3586, "method_signature": "double[][] scale(double[][], double)"}, "2980": {"callee_method_names": [], "method_name": "JoiningSequenceReader.linearSearch", "method_implementation": "{\n    int[] minSeqIndex = getMinSequenceIndex();\n    int[] maxSeqIndex = getMaxSequenceIndex();\n    int length = minSeqIndex.length;\n    for (int i = 0; i < length; i++) {\n        if (position >= minSeqIndex[i] && position <= maxSeqIndex[i]) {\n            return i;\n        }\n    }\n    throw new IndexOutOfBoundsException(\"Given position \" + position + \" does not map into this Sequence\");\n}", "repo_id": "9", "comment": "/**\n * Scans through the sequence index arrays in linear time. Not the best\n * performance but easier to code\n */\n", "repo_name": "biojava-master/", "id": 2980, "method_signature": "int linearSearch(int)"}, "2925": {"callee_method_names": [], "method_name": "AbstractSequence.getFeatures", "method_implementation": "{\n    return features;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2925, "method_signature": "List<FeatureInterface<AbstractSequence<C>,C>> getFeatures()"}, "2161": {"callee_method_names": [], "method_name": "StructureImpl.getIdentifier", "method_implementation": "{\n    //1. StructureIdentifier\n    if (getStructureIdentifier() != null) {\n        return getStructureIdentifier().getIdentifier();\n    }\n    //2. Name\n    if (getName() != null) {\n        return getName();\n    }\n    //3. PDBCode + ranges\n    return toCanonical().getIdentifier();\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2161, "method_signature": "String getIdentifier()"}, "2431": {"callee_method_names": [], "method_name": "FeatureList.add", "method_implementation": "{\n    for (FeatureI f : list) {\n        add(f);\n    }\n}", "repo_id": "9", "comment": "/**\n * Add all features in the specified list or collection to this list.\n *\n * @param list The collection of FeatureI objects.\n */\n", "repo_name": "biojava-master/", "id": 2431, "method_signature": "void add(Collection)"}, "1804": {"callee_method_names": ["ReadWriteLock.readLock", "Logger.trace", "Logger.trace", "ReadWriteLock.readLock", "ReadWriteLock.readLock", "Logger.trace", "Logger.trace", "ReadWriteLock.readLock"], "method_name": "EcodInstallation.getAllDomains", "method_implementation": "{\n    domainsFileLock.readLock().lock();\n    logger.trace(\"LOCK readlock\");\n    try {\n        while (allDomains == null) {\n            // unlock to allow ensureDomainsFileInstalled to get the write lock\n            logger.trace(\"UNLOCK readlock\");\n            domainsFileLock.readLock().unlock();\n            ensureDomainsFileInstalled();\n            domainsFileLock.readLock().lock();\n            logger.trace(\"LOCK readlock\");\n        }\n        return allDomains;\n    } finally {\n        logger.trace(\"UNLOCK readlock\");\n        domainsFileLock.readLock().unlock();\n    }\n}", "repo_id": "9", "comment": "/**\n * Get all ECOD domains\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1804, "method_signature": "List<EcodDomain> getAllDomains()"}, "362": {"callee_method_ids": [1831, 1832], "callee_method_names": ["AtomIterator.hasNext", "AtomIterator.next"], "method_name": "Calc.rotate", "method_implementation": "{\n    AtomIterator iter = new AtomIterator(structure);\n    while (iter.hasNext()) {\n        Atom atom = iter.next();\n        rotate(atom, m);\n    }\n}", "repo_id": "9", "comment": "/**\n * Rotate a structure object. The rotation Matrix must be a\n * pre-multiplication Matrix.\n *\n * @param structure\n *            the structure to be rotated\n * @param m\n *            rotation matrix to be applied\n */\n", "repo_name": "biojava-master/", "id": 362, "method_signature": "void rotate(Structure, Matrix)"}, "1527": {"callee_method_names": [], "method_name": "JournalArticle.setIsPublished", "method_implementation": "{\n    this.published = state;\n}", "repo_id": "9", "comment": "/**\n * Sets the publication state of a JournalArticle - TO BE PUBLISHED == false\n * @param state\n */\n", "repo_name": "biojava-master/", "id": 1527, "method_signature": "void setIsPublished(Boolean)"}, "860": {"callee_method_names": ["TreeMap<Key, Value>.keySet"], "method_name": "SymbolTable.keys", "method_implementation": "{\n    return st.keySet();\n}", "repo_id": "9", "comment": "/**\n * Return an <tt>Iterable</tt> for the keys in the table.\n * To iterate over all of the keys in the symbol table <tt>st</tt>, use the\n * foreach notation: <tt>for (Key key : st.keys())</tt>.\n */\n", "repo_name": "biojava-master/", "id": 860, "method_signature": "Iterable<Key> keys()"}, "395": {"callee_method_names": [], "method_name": "Calc.rmsd", "method_implementation": "{\n    return CalcPoint.rmsd(atomsToPoints(x), atomsToPoints(y));\n}", "repo_id": "9", "comment": "/**\n * Calculate the RMSD of two Atom arrays, already superposed.\n *\n * @param x\n *            array of Atoms superposed to y\n * @param y\n *            array of Atoms superposed to x\n * @return RMSD\n */\n", "repo_name": "biojava-master/", "id": 395, "method_signature": "double rmsd(Atom[], Atom[])"}, "1392": {"callee_method_names": [], "method_name": "DBRef.getSeqBegin", "method_implementation": "{\n    return seqbegin;\n}", "repo_id": "9", "comment": "/**\n *   Initial sequence number of the PDB sequence segment.\n *\n * @return start seq. position\n * @see #setSeqBegin\n */\n", "repo_name": "biojava-master/", "id": 1392, "method_signature": "int getSeqBegin()"}, "3294": {"callee_method_names": [], "method_name": "MultipleAlignmentCoordManager.getLegendPosition", "method_implementation": "{\n    int x = DEFAULT_X_SPACE;\n    int y = lineNr * DEFAULT_Y_STEP + DEFAULT_Y_SPACE;\n    y += structure * DEFAULT_LINE_SEPARATION;\n    Point p = new Point(x, y);\n    return p;\n}", "repo_id": "9", "comment": "/**\n * Provide the coordinates for where to draw the legend for\n * line X given the structure index.\n *\n * @param lineNr line of the Panel\n * @param structure the structure index\n * @return get the point where to draw the legend\n */\n", "repo_name": "biojava-master/", "id": 3294, "method_signature": "Point getLegendPosition(int, int)"}, "1234": {"callee_method_names": ["List<Group>.size", "List<Group>.get", "Atom.getAminoType", "Map<Integer,Integer>.put", "StringBuffer.append", "Group.isWater", "Group.size", "Group.getAtom", "Atom.getElement", "Group.getChemComp", "Logger.debug", "Group.toString", "ChemComp.getResidueType", "ChemComp.getPolymerType", "ChemComp.getPolymerType", "ChemComp.getOneLetterCode", "ChemComp.getPolymerType", "String.length", "Logger.info", "Group.toString", "String.length", "Map<Integer,Integer>.put", "StringBuffer.append", "String.charAt", "Logger.debug", "Group.toString", "StringBuffer.toString"], "method_name": "SeqRes2AtomAligner.getFullAtomSequence", "method_implementation": "{\n    StringBuffer sequence = new StringBuffer();\n    // track sequence.length()\n    int seqIndex = 0;\n    for (int i = 0; i < groups.size(); i++) {\n        Group g = groups.get(i);\n        if (g instanceof AminoAcid) {\n            AminoAcid a = (AminoAcid) g;\n            char oneLetter = a.getAminoType();\n            if (oneLetter == '?')\n                oneLetter = 'X';\n            positionIndex.put(seqIndex, i);\n            sequence.append(oneLetter);\n            seqIndex++;\n        } else {\n            // exclude solvents\n            if (g.isWater())\n                continue;\n            // exclude metals\n            if (g.size() == 1) {\n                Atom a = g.getAtom(0);\n                if (a == null)\n                    continue;\n                if (a.getElement().isMetal())\n                    continue;\n            }\n            ChemComp cc = g.getChemComp();\n            if (cc == null) {\n                logger.debug(\"No chem comp available for group {}\", g.toString());\n                // not sure what to do in that case!\n                continue;\n            }\n            if (ResidueType.lPeptideLinking.equals(cc.getResidueType()) || PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {\n                //System.out.println(cc.getOne_letter_code());\n                String c = cc.getOneLetterCode();\n                if (\"?\".equals(c)) {\n                    if (isNucleotideChain && PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {\n                        // the way to represent unknown nucleotides is with 'N', see https://en.wikipedia.org/wiki/Nucleic_acid_notation\n                        c = \"N\";\n                    } else {\n                        c = \"X\";\n                    }\n                }\n                // For some unusual cases the het residue can map to 2 or more standard aas and thus give an\n                // insertion of length >1.\n                //      e.g. 1: SUI maps to DG  (in 1oew,A)\n                //\t\te.g. 2: NRQ maps to MYG (in 3cfh,A)\n                if (c.length() > 1) {\n                    logger.info(\"Group '{}' maps to more than 1 standard aminoacid: {}.\", g.toString(), c);\n                }\n                // because of the mapping to more than 1 aminoacid, we have\n                // to loop through it (99% of cases c will have length 1 anyway)\n                for (int cIdx = 0; cIdx < c.length(); cIdx++) {\n                    positionIndex.put(seqIndex, i);\n                    sequence.append(c.charAt(cIdx));\n                    seqIndex++;\n                }\n            } else {\n                logger.debug(\"Group {} is not lPeptideLinked, nor PROTEIN_ONLY, nor POLYNUCLEOTIDE_ONLY\", g.toString());\n                continue;\n            }\n            //sequence.append(\"X\");\n        }\n    }\n    return sequence.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns the full sequence of the Atom records of a parent\n * with X instead of HETATMSs. The advantage of this is\n * that it allows us to also align HETATM groups back to the SEQRES.\n * @param groups the list of groups in a parent\n * @param positionIndex a Map to keep track of which group is at which sequence position\n * @param isNucleotideChain whether the atom groups are predominantly nucleotides (the groups represent a nucleotide chain), if true\n * non-standard nucleotides will be represented with ambiguous letter 'N' instead of 'X', if false all non-standard residues will be 'X'\n * @return string representations\n */\n", "repo_name": "biojava-master/", "id": 1234, "method_signature": "String getFullAtomSequence(List, Map, boolean)"}, "2408": {"callee_method_names": [], "method_name": "Location.suffix", "method_implementation": "{\n    if (isSameStrand(other)) {\n        if (other.mEnd <= mEnd) {\n            return new Location((other.mEnd > mStart) ? other.mEnd : mStart, mEnd);\n        } else {\n            //other is out of bounds -- no suffix\n            throw new IndexOutOfBoundsException(\"Specified location not within this location.\");\n        }\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * The part of this location after the other location (not inclusive).\n *\n * @param other The other location.\n * @return The part of this location after the other location.\n * @throws IllegalArgumentException Locations are on opposite strands.\n * @throws IndexOutOfBoundsException This location does not contain other location.\n */\n", "repo_name": "biojava-master/", "id": 2408, "method_signature": "Location suffix(Location)"}, "922": {"callee_method_names": ["Grid.getIAtoms", "Grid.getJAtoms", "Grid.getCutoff", "Point3d[].distance", "List<Contact>.add", "Point3d[].distance", "List<Contact>.add"], "method_name": "GridCell.getContactsWithinCell", "method_implementation": "{\n    List<Contact> contacts = new ArrayList<Contact>();\n    Point3d[] iAtoms = grid.getIAtoms();\n    Point3d[] jAtoms = grid.getJAtoms();\n    double cutoff = grid.getCutoff();\n    if (jAtoms == null) {\n        for (int i : iIndices) {\n            for (int j : iIndices) {\n                if (j > i) {\n                    double distance = iAtoms[i].distance(iAtoms[j]);\n                    if (distance < cutoff)\n                        contacts.add(new Contact(i, j, distance));\n                }\n            }\n        }\n    } else {\n        for (int i : iIndices) {\n            for (int j : jIndices) {\n                double distance = iAtoms[i].distance(jAtoms[j]);\n                if (distance < cutoff)\n                    contacts.add(new Contact(i, j, distance));\n            }\n        }\n    }\n    return contacts;\n}", "repo_id": "9", "comment": "/**\n * Calculates all distances of atoms within this cell returning those that are within the given cutoff\n * as a list of Contacts containing the indices of the pair and the calculated distance.\n *\n * If {@link Grid#getJAtoms()} is null, distances are within the iAtoms only\n * @return\n */\n", "repo_name": "biojava-master/", "id": 922, "method_signature": "List<Contact> getContactsWithinCell()"}, "146": {"callee_method_names": [], "method_name": "OffsetMap.entrySet", "method_implementation": "{\n    return Collections.emptySet();\n}", "repo_id": "9", "comment": "/**\n * Always returns the empty set\n */\n", "repo_name": "biojava-master/", "id": 146, "method_signature": "Set<java.util.Map.Entry<Double,Integer>> entrySet()"}, "1985": {"callee_method_names": ["Matrix4d.setTranslation"], "method_name": "RotationAxisAligner.getGeometicCenterTransformation", "method_implementation": "{\n    run();\n    Matrix4d geometricCentered = new Matrix4d(reverseTransformationMatrix);\n    geometricCentered.setTranslation(new Vector3d(getGeometricCenter()));\n    return geometricCentered;\n}", "repo_id": "9", "comment": "/**\n * Returns a transformation matrix transform polyhedra for Cn structures.\n * The center in this matrix is the geometric center, rather then the centroid.\n * In Cn structures those are usually not the same.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1985, "method_signature": "Matrix4d getGeometicCenterTransformation()"}, "1687": {"callee_method_names": [], "method_name": "AtomImpl.setName", "method_implementation": "{\n    name = s;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1687, "method_signature": "void setName(String)"}, "2740": {"callee_method_names": [], "method_name": "EmblRecord.getCreatedDate", "method_implementation": "{\n    return createdDate;\n}", "repo_id": "9", "comment": "/**\n * The DT  line shows when an entry first appeared in the database\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2740, "method_signature": "String getCreatedDate()"}, "2492": {"callee_method_ids": [2379, 2640], "callee_method_names": ["TwoBitFacade.getSequence", "ResidueRangeAndLength.lowerEndpoint", "ResidueRangeAndLength.upperEndpoint", "StringBuilder.append", "Character.equals", "StringBuilder.toString", "StringBuilder.toString", "DNASequence.getComplement", "SequenceView<NucleotideCompound>.getSequenceAsString", "StringBuilder.toString"], "method_name": "ChromosomeMappingTools.getTranscriptDNASequence", "method_implementation": "{\n    List<Range<Integer>> cdsRegion = getCDSRegions(exonStarts, exonEnds, cdsStart, cdsEnd);\n    StringBuilder dnaSequence = new StringBuilder();\n    for (Range<Integer> range : cdsRegion) {\n        String exonSequence = twoBitFacade.getSequence(chromosome, range.lowerEndpoint(), range.upperEndpoint());\n        dnaSequence.append(exonSequence);\n    }\n    if (orientation.equals('-')) {\n        dnaSequence = new StringBuilder(new StringBuilder(dnaSequence.toString()).reverse().toString());\n        DNASequence dna = new DNASequence(dnaSequence.toString());\n        SequenceView<NucleotideCompound> compliment = dna.getComplement();\n        dnaSequence = new StringBuilder(compliment.getSequenceAsString());\n    }\n    return new DNASequence(dnaSequence.toString().toUpperCase());\n}", "repo_id": "9", "comment": "/**\n * Extracts the DNA sequence transcribed from the input genetic coordinates.\n *\n * @param chromosome the name of the chromosome\n * @param exonStarts The list holding the genetic coordinates pointing to the start positions of the exons (including UTR regions)\n * @param exonEnds The list holding the genetic coordinates pointing to the end positions of the exons (including UTR regions)\n * @param cdsStart The start position of a coding region\n * @param cdsEnd The end position of a coding region\n * @param orientation The orientation of the strand where the gene is living\n *\n * @return the DNA sequence transcribed from the input genetic coordinates\n */\n", "repo_name": "biojava-master/", "id": 2492, "method_signature": "DNASequence getTranscriptDNASequence(TwoBitFacade, String, List, List, int, int, Character)"}, "3596": {"callee_method_ids": [3637, 3659, 3657, 3609, 3609, 3607, 3659, 3657, 3659, 3606, 3632, 3634], "callee_method_names": ["CoxInfo.getCoefficientsList", "ArrayList<SurvivalInfo>.size", "ArrayList<SurvivalInfo>.size", "ArrayList<SurvivalInfo>.size", "ArrayList<SurvivalInfo>.get", "ArrayList<Integer>.add", "SurvivalInfo.getStrata", "SurvivalInfo.getWeight", "CoxInfo.getNaiveVariance", "CoxInfo.getNaiveVariance", "CoxInfo.getVariance", "LinkedHashMap<Integer, Double>.get", "LinkedHashMap<Integer, Double>.put", "ArrayList<SurvivalInfo>.size", "ArrayList<SurvivalInfo>.get", "SurvivalInfo.getStrata", "SurvivalInfo.getWeight", "LinkedHashMap<Integer, Double>.get", "LinkedHashMap<Integer, Double>.put", "LinkedHashMap<Integer, Double>.values", "LinkedHashMap<Integer, Double>.keySet", "LinkedHashMap<Integer, Double>.get", "LinkedHashMap<Integer, Double>.get", "LinkedHashMap<Integer, Double>.put", "ArrayList<String>.size", "ArrayList<String>.size", "LinkedHashMap<Integer, Double>.keySet", "LinkedHashMap<Integer, Double>.get", "ArrayList<SurvivalInfo>.size", "ArrayList<SurvivalInfo>.get", "SurvivalInfo.getStrata", "ArrayList<String>.size", "ArrayList<String>.get", "LinkedHashMap<String, DescriptiveStatistics>.get", "LinkedHashMap<String, DescriptiveStatistics>.put", "DescriptiveStatistics.addValue", "ArrayList<String>.size", "ArrayList<String>.size", "ArrayList<String>.size", "ArrayList<String>.get", "ArrayList<String>.size", "ArrayList<String>.get", "LinkedHashMap<String, DescriptiveStatistics>.get", "DescriptiveStatistics.getVariance", "LinkedHashMap<String, DescriptiveStatistics>.get", "LinkedHashMap<String, DescriptiveStatistics>.get", "Covariance.covariance", "DescriptiveStatistics.getValues", "DescriptiveStatistics.getValues", "LinkedHashMap<Integer, Double>.get", "CoxInfo.setVariance", "CoxInfo.setScoreLogrankTest", "CoxInfo.setScoreLogrankTestpvalue"], "method_name": "CoxCC.process", "method_implementation": "{\n    ArrayList<SurvivalInfo> survivalInfoList = ci.survivalInfoList;\n    //r\n    ArrayList<String> variables = new ArrayList<String>(ci.getCoefficientsList().keySet());\n    ArrayList<Integer> strataClass = new ArrayList<Integer>(survivalInfoList.size());\n    double[] wt = new double[survivalInfoList.size()];\n    for (int i = 0; i < survivalInfoList.size(); i++) {\n        SurvivalInfo si = survivalInfoList.get(i);\n        strataClass.add(si.getStrata());\n        wt[i] = si.getWeight();\n    }\n    // dn not use weighted\n    double[][] r = ResidualsCoxph.process(ci, ResidualsCoxph.Type.score, false, null);\n    // ArrayList<String> variables = ci.survivalInfoList.get(0).getDataVariables();\n    //        if (false) {\n    //            for (int i = 0; i < survivalInfoList.size(); i++) {\n    //                SurvivalInfo si = survivalInfoList.get(i);\n    //                System.out.print(\"Cox cc \" + si.getOrder());\n    //                for (int j = 0; j < variables.size(); j++) {\n    //                    System.out.print(\" \" + r[i][j]);\n    //                }\n    //                System.out.println();\n    //            }\n    //        }\n    double[][] rvar = null;\n    if (ci.getNaiveVariance() != null) {\n        rvar = ci.getNaiveVariance();\n    } else {\n        rvar = ci.getVariance();\n    }\n    //nj\n    LinkedHashMap<Integer, Double> nj = new LinkedHashMap<Integer, Double>();\n    Collections.sort(strataClass);\n    for (Integer value : strataClass) {\n        Double count = nj.get(value);\n        if (count == null) {\n            count = 0.0;\n        }\n        count++;\n        nj.put(value, count);\n    }\n    //Nj\n    LinkedHashMap<Integer, Double> Nj = new LinkedHashMap<Integer, Double>();\n    //N = N + Nj[key];\n    double N = 0;\n    for (int i = 0; i < survivalInfoList.size(); i++) {\n        SurvivalInfo si = survivalInfoList.get(i);\n        Integer strata = si.getStrata();\n        Double weight = si.getWeight();\n        Double sum = Nj.get(strata);\n        if (sum == null) {\n            sum = 0.0;\n        }\n        sum = sum + weight;\n        Nj.put(strata, sum);\n    }\n    for (Double value : Nj.values()) {\n        N = N + value;\n    }\n    LinkedHashMap<Integer, Double> k1j = new LinkedHashMap<Integer, Double>();\n    for (Integer key : nj.keySet()) {\n        //trying to copy what R is doing on precision\n        double _nj = (nj.get(key));\n        double _Nj = (Nj.get(key));\n        //         System.out.println(\"nj=\" + _nj + \" Nj=\" + _Nj);\n        k1j.put(key, _Nj * ((_Nj / _nj) - 1));\n    }\n    double[][] V = new double[variables.size()][variables.size()];\n    for (Integer i : k1j.keySet()) {\n        //          System.out.println(\"Strata=\" + i + \" \" + k1j.get(i) + \" \" + Nj.get(i) + \" \" + nj.get(i));\n        if (nj.get(i) > 1) {\n            LinkedHashMap<String, DescriptiveStatistics> variableStatsMap = new LinkedHashMap<String, DescriptiveStatistics>();\n            for (int p = 0; p < survivalInfoList.size(); p++) {\n                SurvivalInfo si = survivalInfoList.get(p);\n                if (si.getStrata() != i) {\n                    continue;\n                }\n                //              System.out.print(si.order + \" \");\n                for (int col = 0; col < variables.size(); col++) {\n                    String v = variables.get(col);\n                    DescriptiveStatistics ds = variableStatsMap.get(v);\n                    if (ds == null) {\n                        ds = new DescriptiveStatistics();\n                        variableStatsMap.put(v, ds);\n                    }\n                    ds.addValue(r[p][col]);\n                    //                  System.out.print(si.getResidualVariable(v) + \"  \");\n                }\n                //              System.out.println();\n            }\n            //calculate variance covariance matrix var(r[class==levels(class)[i],],use='comp')\n            double[][] var_covar = new double[variables.size()][variables.size()];\n            for (int m = 0; m < variables.size(); m++) {\n                String var_m = variables.get(m);\n                for (int n = 0; n < variables.size(); n++) {\n                    String var_n = variables.get(n);\n                    if (m == n) {\n                        DescriptiveStatistics ds = variableStatsMap.get(var_m);\n                        var_covar[m][n] = ds.getVariance();\n                    } else {\n                        DescriptiveStatistics ds_m = variableStatsMap.get(var_m);\n                        DescriptiveStatistics ds_n = variableStatsMap.get(var_n);\n                        Covariance cv = new Covariance();\n                        double covar = cv.covariance(ds_m.getValues(), ds_n.getValues(), true);\n                        var_covar[m][n] = covar;\n                    }\n                }\n            }\n            //              System.out.println();\n            //              System.out.println(\"sstrat=\" + i);\n            //              StdArrayIO.print(var_covar);\n            V = Matrix.add(V, Matrix.scale(var_covar, k1j.get(i)));\n            //       for (int m = 0; m < V.length; m++) {\n            //           for (int n = 0; n < V.length; n++) {\n            //               V[m][n] = V[m][n] + (k1j.get(i) * var_covar[m][n]);\n            //\n            //           }\n            //      }\n        }\n    }\n    //     System.out.println(\"V\");\n    //     StdArrayIO.print(V);\n    //     System.out.println();\n    //z$var <- rvar + rvar %*% V %*% rvar # replace variance in z\n    double[][] imat1 = Matrix.multiply(rvar, V);\n    imat1 = Matrix.multiply(imat1, rvar);\n    imat1 = Matrix.add(rvar, imat1);\n    //  System.out.println(\"New var\");\n    //  StdArrayIO.print(imat1);\n    ci.setVariance(imat1);\n    //need to update walsh stats for overall model\n    CoxR.calculateWaldTestInfo(ci);\n    //per Bob/Kathryn email on 4/23/2014 in a weighted model LogRank p-value is no longer valid so should erase it\n    ci.setScoreLogrankTest(Double.NaN);\n    ci.setScoreLogrankTestpvalue(Double.NaN);\n}", "repo_id": "9", "comment": "/**\n * @param ci\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3596, "method_signature": "void process(CoxInfo)"}, "1459": {"callee_method_names": [], "method_name": "SpaceGroup.getNumOperators", "method_implementation": "{\n    return this.transformations.size();\n}", "repo_id": "9", "comment": "/**\n * Gets the number of symmetry operators corresponding to this SpaceGroup (counting\n * the identity operator)\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1459, "method_signature": "int getNumOperators()"}, "1857": {"callee_method_names": [], "method_name": "Rotation.getPermutation", "method_implementation": "{\n    return permutation;\n}", "repo_id": "9", "comment": "/**\n * @return the permutation\n */\n", "repo_name": "biojava-master/", "id": 1857, "method_signature": "List<Integer> getPermutation()"}, "1665": {"callee_method_names": ["ArrayList.size", "List<Atom[]>.add"], "method_name": "SubunitCluster.getAlignedAtomsSubunits", "method_implementation": "{\n    List<Atom[]> alignedAtoms = new ArrayList<>();\n    // Loop through all subunits and add the aligned positions\n    for (int s = 0; s < subunits.size(); s++) alignedAtoms.add(getAlignedAtomsSubunit(s));\n    return alignedAtoms;\n}", "repo_id": "9", "comment": "/**\n * @return A List of size {@link #size()} of Atom arrays of length\n *         {@link #length()} with the aligned Atoms for each Subunit in the\n *         cluster\n */\n", "repo_name": "biojava-master/", "id": 1665, "method_signature": "List<Atom[]> getAlignedAtomsSubunits()"}, "2943": {"callee_method_names": [], "method_name": "AbstractSequence.getCompoundAt", "method_implementation": "{\n    return getSequenceStorage().getCompoundAt(position);\n}", "repo_id": "9", "comment": "/**\n * @param position The 1-indexed position of the amino acid\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2943, "method_signature": "C getCompoundAt(int)"}, "229": {"callee_method_names": ["LinkedHashSet.add"], "method_name": "ProteinModificationImpl.addKeyword", "method_implementation": "{\n    if (keyword == null)\n        throw new IllegalArgumentException(\"Keyword cannot be null.\");\n    keywords.add(keyword);\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Add a keyword associate with the PTM.\n * @param keyword a keyword.\n * @return the same Builder object so you can chain setters.\n * @throws IllegalArgumentException if the keyword is null.\n */\n", "repo_name": "biojava-master/", "id": 229, "method_signature": "Builder addKeyword(String)"}, "3602": {"callee_method_ids": [3609, 3609, 3607, 3611], "callee_method_names": ["CoxInfo.getNaiveVariance", "CoxInfo.getNaiveVariance", "CoxInfo.getVariance", "CoxInfo.getWeighted", "ArrayList<String>.size"], "method_name": "ResidualsCoxph.process", "method_implementation": "{\n    Type otype = type;\n    if (type == Type.dfbeta || type == Type.dfbetas) {\n        type = Type.score;\n        //if missing weighted is a required so never missing\n    }\n    //64 2 625 310\n    double[][] rr = null;\n    if (type == Type.score) {\n        rr = CoxScore.process(ci.method, ci.survivalInfoList, ci, false);\n    }\n    //debug\n    //        if (false) {\n    //            for (int i = 0; i < ci.survivalInfoList.size(); i++) {\n    //                SurvivalInfo si = ci.survivalInfoList.get(i);\n    //                System.out.print(\"residuals \" + si.getOrder() + \" \" + si.getClusterValue());\n    //                for (int j = 0; j < 2; j++) {\n    //                    System.out.print(\" \" + rr[i][j]);\n    //                }\n    //                System.out.println();\n    //            }\n    //        }\n    double[][] vv = null;\n    if (ci.getNaiveVariance() != null) {\n        vv = ci.getNaiveVariance();\n    } else {\n        vv = ci.getVariance();\n    }\n    if (otype == Type.dfbeta) {\n        //rr <- rr %*% vv\n        rr = Matrix.multiply(rr, vv);\n    } else if (otype == Type.dfbetas) {\n        //rr <- (rr %*% vv) %*% diag(sqrt(1/diag(vv)))\n        double[][] d1 = Matrix.multiply(rr, vv);\n        double[][] d2 = Matrix.diag(Matrix.sqrt(Matrix.oneDivide(Matrix.diag(vv))));\n        rr = Matrix.multiply(d1, d2);\n    }\n    if (useWeighted) {\n        double[] weighted = ci.getWeighted();\n        rr = Matrix.scale(rr, weighted);\n    }\n    if (cluster != null && cluster.size() > 0) {\n        rr = rowsum(rr, cluster);\n    }\n    return rr;\n}", "repo_id": "9", "comment": "/**\n * @param ci\n * @param type\n * @param useWeighted\n * @param cluster\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3602, "method_signature": "double[][] process(CoxInfo, Type, boolean, ArrayList)"}, "791": {"callee_method_names": ["AFPChain.toCE"], "method_name": "OptimalCECPMain.displayAlignment", "method_implementation": "{\n    Atom[] ca1clone = StructureTools.cloneAtomArray(ca1);\n    Atom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n    if (!GuiWrapper.isGuiModuleInstalled()) {\n        System.err.println(\"The biojava-structure-gui and/or JmolApplet modules are not installed. Please install!\");\n        // display alignment in console\n        System.out.println(afpChain.toCE(ca1clone, ca2clone));\n    } else {\n        Object jmol = GuiWrapper.display(afpChain, ca1clone, ca2clone);\n        GuiWrapper.showAlignmentImage(afpChain, ca1clone, ca2clone, jmol);\n    }\n}", "repo_id": "9", "comment": "/**\n * Try showing a the afpChain in a GUI.\n *\n * <p>requires additional dependencies biojava-structure-gui and JmolApplet\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @throws ClassNotFoundException\n * @throws NoSuchMethodException\n * @throws InvocationTargetException\n * @throws IllegalAccessException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 791, "method_signature": "void displayAlignment(AFPChain, Atom[], Atom[])"}, "1698": {"callee_method_names": [], "method_name": "AtomImpl.setGroup", "method_implementation": "{\n    this.parent = parent;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1698, "method_signature": "void setGroup(Group)"}, "1143": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString", "StringBuilder.toString"], "method_name": "LocalPDBDirectory.initPaths", "method_implementation": "{\n    // Hand-rolled String.join(), for java 6\n    String[] split = getSplitDirPath();\n    String[] obsolete = getObsoleteDirPath();\n    //URLs are joined with '/'\n    StringBuilder splitURL = new StringBuilder(\"/pub/pdb\");\n    for (int i = 0; i < split.length; i++) {\n        splitURL.append(\"/\");\n        splitURL.append(split[i]);\n    }\n    StringBuilder obsoleteURL = new StringBuilder(\"/pub/pdb\");\n    for (int i = 0; i < obsolete.length; i++) {\n        obsoleteURL.append(\"/\");\n        obsoleteURL.append(obsolete[i]);\n    }\n    splitDirURL = splitURL.toString();\n    obsoleteDirURL = obsoleteURL.toString();\n    //Files join themselves iteratively\n    splitDirPath = path;\n    for (int i = 0; i < split.length; i++) {\n        splitDirPath = new File(splitDirPath, split[i]);\n    }\n    obsoleteDirPath = path;\n    for (int i = 0; i < obsolete.length; i++) {\n        obsoleteDirPath = new File(obsoleteDirPath, obsolete[i]);\n    }\n}", "repo_id": "9", "comment": "/**\n * Should be called whenever any of the path variables change.\n * Thus, if {@link getSplitDirPath()} or {@link getObsoleteDirPath()}\n * depend on anything, they should call this function when that thing\n * changes (possibly including at the end of the constructor).\n */\n", "repo_name": "biojava-master/", "id": 1143, "method_signature": "void initPaths()"}, "1616": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getMinimumSequenceLength", "method_implementation": "{\n    return minimumSequenceLength;\n}", "repo_id": "9", "comment": "/**\n * Get the minimum number of residues of a subunits to be considered in the\n * clusters.\n *\n * @return minimumSequenceLength\n */\n", "repo_name": "biojava-master/", "id": 1616, "method_signature": "int getMinimumSequenceLength()"}, "2489": {"callee_method_names": ["Logger.debug", "Logger.debug", "List<Range<Integer>>.size", "List<Range<Integer>>.get", "List<Range<Integer>>.get"], "method_name": "ChromosomeMappingTools.getCDSPosReverse", "method_implementation": "{\n    // the genetic coordinate is not in a coding region\n    if ((chromPos < (cdsStart + base)) || (chromPos > (cdsEnd + base))) {\n        logger.debug(\"The {} position is not in a coding region\", format(chromPos));\n        return -1;\n    }\n    logger.debug(\"looking for CDS position for {}\", format(chromPos));\n    // map the genetic coordinate on a stretch of a reverse strand\n    List<Range<Integer>> cdsRegions = getCDSRegions(exonStarts, exonEnds, cdsStart, cdsEnd);\n    int codingLength = 0;\n    int lengthExon = 0;\n    for (int i = cdsRegions.size() - 1; i >= 0; i--) {\n        int start = cdsRegions.get(i).lowerEndpoint();\n        int end = cdsRegions.get(i).upperEndpoint();\n        lengthExon = end - start;\n        // +1 offset to be a base 1\n        if (start + base <= chromPos && end >= chromPos) {\n            return codingLength + (end - chromPos + 1);\n        } else {\n            codingLength += lengthExon;\n        }\n    }\n    return -1;\n}", "repo_id": "9", "comment": "/**\n * Converts the genetic coordinate to the position of the nucleotide on the mRNA sequence for a gene\n * living on the reverse DNA strand.\n *\n * @param chromPos The genetic coordinate on a chromosome\n * @param exonStarts The list holding the genetic coordinates pointing to the start positions of the exons (including UTR regions)\n * @param exonEnds The list holding the genetic coordinates pointing to the end positions of the exons (including UTR regions)\n * @param cdsStart The start position of a coding region\n * @param cdsEnd The end position of a coding region\n *\n * @return the position of the nucleotide base on the mRNA sequence corresponding to the input genetic coordinate (base 1)\n *\n * @author Yana Valasatava\n */\n", "repo_name": "biojava-master/", "id": 2489, "method_signature": "int getCDSPosReverse(int, List, List, int, int)"}, "3522": {"callee_method_names": [], "method_name": "StrataInfo.getNcens", "method_implementation": "{\n    return ncens;\n}", "repo_id": "9", "comment": "/**\n * @return the ncens\n */\n", "repo_name": "biojava-master/", "id": 3522, "method_signature": "ArrayList<Double> getNcens()"}, "974": {"callee_method_names": ["Chain.setId", "Chain.getId", "Chain.setName", "Chain.getName", "Structure.addChain"], "method_name": "BiologicalAssemblyBuilder.addChainFlattened", "method_implementation": "{\n    newChain.setId(newChain.getId() + SYM_CHAIN_ID_SEPARATOR + transformId);\n    newChain.setName(newChain.getName() + SYM_CHAIN_ID_SEPARATOR + transformId);\n    s.addChain(newChain);\n}", "repo_id": "9", "comment": "/**\n * Adds a chain to the given structure to form a biological assembly,\n * adding the symmetry-expanded chains as new chains with renamed\n * chain ids and names (in the form originalAsymId_transformId and originalAuthId_transformId).\n * @param s\n * @param newChain\n * @param transformId\n */\n", "repo_name": "biojava-master/", "id": 974, "method_signature": "void addChainFlattened(Structure, Chain, String)"}, "1999": {"callee_method_names": ["RotationGroup.getRotation", "RotationGroup.getOrder", "RotationGroup.getRotation", "RotationGroup.getRotation", "RotationGroup.getRotation", "Vector3d.normalize"], "method_name": "RotationAxisAligner.getReferenceAxisDihedral", "method_implementation": "{\n    int maxFold = rotationGroup.getRotation(0).getFold();\n    // one exception: D2\n    if (maxFold == 2) {\n        maxFold = 3;\n    }\n    // TODO how about D2, where minor axis = 2 = principal axis??\n    for (int i = 0; i < rotationGroup.getOrder(); i++) {\n        if (rotationGroup.getRotation(i).getDirection() == 1 && rotationGroup.getRotation(i).getFold() < maxFold) {\n            AxisAngle4d axisAngle = rotationGroup.getRotation(i).getAxisAngle();\n            Vector3d v = new Vector3d(axisAngle.x, axisAngle.y, axisAngle.z);\n            v.normalize();\n            return v;\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n */\n", "repo_name": "biojava-master/", "id": 1999, "method_signature": "Vector3d getReferenceAxisDihedral()"}, "2683": {"callee_method_names": [], "method_name": "RNASequence.getInverse", "method_implementation": "{\n    return new ReversedSequenceView<>(this);\n}", "repo_id": "9", "comment": "/**\n * Get the inverse view of the sequence. It is the reverse sequence from\n * end to begin where use reverse could imply complement. Called getInverse()\n * in the hopes of making less confusing.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2683, "method_signature": "SequenceView<NucleotideCompound> getInverse()"}, "2436": {"callee_method_names": ["HashMap.containsKey", "HashMap.get", "Map<String, List<FeatureI>>.keySet", "LinkedHashMap<String, String>.put", "FeatureI.getAttribute", "LinkedHashMap<String, String>.keySet"], "method_name": "FeatureList.attributeValues", "method_implementation": "{\n    if (featindex.containsKey(key)) {\n        Map<String, List<FeatureI>> map = featindex.get(key);\n        Collection<String> result = map.keySet();\n        if (result == null)\n            result = new HashSet<String>();\n        return Collections.unmodifiableCollection(result);\n    }\n    LinkedHashMap<String, String> hash = new LinkedHashMap<String, String>();\n    for (FeatureI f : this) {\n        //enter as a key -- removes duplicates\n        hash.put(f.getAttribute(key), null);\n    }\n    return Collections.unmodifiableCollection(hash.keySet());\n}", "repo_id": "9", "comment": "/**\n * Create a collection of the unique values for the specified key.\n * Example: For GTF files, using the \"gene_id\" key will give the names of all\n * the genes in this list.\n *\n * @return A collection (suitable for iteration using Java's \"for\" loop) of all the\n * values found for this key. The order of the values is undefined; it will not match\n * the order of features in the list.\n */\n", "repo_name": "biojava-master/", "id": 2436, "method_signature": "Collection<String> attributeValues(String)"}, "2097": {"callee_method_names": [], "method_name": "SymmetryAxes.getRepeatRelation", "method_implementation": "{\n    return getRepeatRelation(level, 0);\n}", "repo_id": "9", "comment": "/**\n * Get the indices of participating repeats in Cauchy two-line form.\n * <p>\n * Returns two lists of the same length.\n * The first gives a list of all repeat indices which are aligned\n * at the specified level of symmetry (e.g. 0 through the degree of this level).\n * The second list gives the corresponding repeats after applying the\n * operator once.\n *\n * @param level the axis index\n * @return the double List of repeat relations, or null if the\n * \t\t\tlevel is invalid\n * @see #getRepeatsCyclicForm(int, int) for an equivalent specification with half the memory\n */\n", "repo_name": "biojava-master/", "id": 2097, "method_signature": "List<List<Integer>> getRepeatRelation(int)"}, "1569": {"callee_method_names": [], "method_name": "Site.setSiteID", "method_implementation": "{\n    this.siteID = siteID;\n}", "repo_id": "9", "comment": "/**\n * @param siteID the siteID to set\n * e.g. CAT, AC1, AC2...\n */\n", "repo_name": "biojava-master/", "id": 1569, "method_signature": "void setSiteID(String)"}, "3054": {"callee_method_names": ["List<Location>.get"], "method_name": "LocationHelper.detectStart", "method_implementation": "{\n    return subLocations.get(0).getStart().clonePoint();\n}", "repo_id": "9", "comment": "/**\n * Assumes that the first element is the start & clones it\n */\n", "repo_name": "biojava-master/", "id": 3054, "method_signature": "Point detectStart(List)"}, "2276": {"callee_method_ids": [641, 1318, 641], "callee_method_names": ["AtomCache.setFiletype", "FileParsingParameters.setHeaderOnly", "AtomCache.setFileParsingParams", "AtomCache.setFiletype"], "method_name": "TestHeaderOnly.testAlignSeqres", "method_implementation": "{\n    // Get either PDB or mmCIF with a headerOnly = false.\n    // Test 1: with PDB\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.PDB);\n    FileParsingParameters params = new FileParsingParameters();\n    params.setHeaderOnly(false);\n    // params.setAlignSeqRes(true);  // Now this is default.\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    Structure sPDB = StructureIO.getStructure(pdbID);\n    Assert.assertEquals(true, doSeqResHaveAtoms(sPDB));\n    // Check particular residues to be aligned.\n    check1REPChainC(sPDB);\n    // Test 2: with mmCIF\n    cache.setFiletype(StructureFiletype.CIF);\n    Structure sCIF = StructureIO.getStructure(pdbID);\n    Assert.assertEquals(true, doSeqResHaveAtoms(sCIF));\n    // Check particular residues to be aligned.\n    check1REPChainC(sCIF);\n}", "repo_id": "9", "comment": "/**\n * Test that with alignSeqRes, expected Group(s) have Atoms, while others\n * are present with correct sequence but empty.\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2276, "method_signature": "void testAlignSeqres()"}, "593": {"callee_method_ids": [476, 491], "callee_method_names": ["AFPChain.clone", "AFPChain.setOptLength", "AFPChain.setBlockSize", "AFPChain.setOptLen", "AFPChain.setOptAln", "AFPChain.setBlockNum"], "method_name": "AlignmentTools.replaceOptAln", "method_implementation": "{\n    int optLength = 0;\n    for (int blk = 0; blk < blockNum; blk++) {\n        optLength += optLens[blk];\n    }\n    //set everything\n    AFPChain refinedAFP = (AFPChain) afpChain.clone();\n    refinedAFP.setOptLength(optLength);\n    refinedAFP.setBlockSize(optLens);\n    refinedAFP.setOptLen(optLens);\n    refinedAFP.setOptAln(optAln);\n    refinedAFP.setBlockNum(blockNum);\n    //TODO recalculate properties: superposition, tm-score, etc\n    // don't modify ca2 positions\n    Atom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n    AlignmentTools.updateSuperposition(refinedAFP, ca1, ca2clone);\n    AFPAlignmentDisplay.getAlign(refinedAFP, ca1, ca2clone);\n    return refinedAFP;\n}", "repo_id": "9", "comment": "/**\n * @param afpChain Input afpchain. UNMODIFIED\n * @param ca1\n * @param ca2\n * @param optLens\n * @param optAln\n * @return A NEW AfpChain based off the input but with the optAln modified\n * @throws StructureException if an error occured during superposition\n */\n", "repo_name": "biojava-master/", "id": 593, "method_signature": "AFPChain replaceOptAln(AFPChain, Atom[], Atom[], int, int[], int[][][])"}, "3333": {"callee_method_ids": [3339], "callee_method_names": ["MouseEvent.getX", "SequenceDisplay.getScale", "CoordManager.setScale", "CoordManager.getSeqPos"], "method_name": "SequenceMouseListener.getSeqPos", "method_implementation": "{\n    int x = e.getX();\n    //int y = e.getY();\n    //float scale = seqScale.getScale();\n    //int DEFAULT_X_START = SequenceScalePanel.DEFAULT_X_START;\n    float scale = parent.getScale();\n    coordManager.setScale(scale);\n    int seqpos = coordManager.getSeqPos(x - 2);\n    return seqpos;\n}", "repo_id": "9", "comment": "/**\n * get the sequence position of the current mouse event\n */\n", "repo_name": "biojava-master/", "id": 3333, "method_signature": "int getSeqPos(MouseEvent)"}, "747": {"callee_method_names": [], "method_name": "CeParameters.getRmsdThr", "method_implementation": "{\n    return rmsdThr;\n}", "repo_id": "9", "comment": "/**\n * RMSD Threshold\n *\n * @return RMSD threshold\n */\n", "repo_name": "biojava-master/", "id": 747, "method_signature": "Double getRmsdThr()"}, "3446": {"callee_method_names": [], "method_name": "HmmerDemo.getUniprot", "method_implementation": "{\n    AminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    UniprotProxySequenceReader<AminoAcidCompound> uniprotSequence = new UniprotProxySequenceReader<AminoAcidCompound>(uniProtID, set);\n    ProteinSequence seq = new ProteinSequence(uniprotSequence);\n    return seq;\n}", "repo_id": "9", "comment": "/**\n * Fetch a protein sequence from the UniProt web site\n *\n * @param uniProtID\n * @return a Protein Sequence\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3446, "method_signature": "ProteinSequence getUniprot(String)"}, "256": {"callee_method_names": ["Map<ModificationCategory, Set<ProteinModification>>.get"], "method_name": "ProteinModificationRegistry.getByCategory", "method_implementation": "{\n    lazyInit();\n    Set<ProteinModification> ret = byCategory.get(cat);\n    return Collections.unmodifiableSet(ret);\n}", "repo_id": "9", "comment": "/**\n * @param cat {@link ModificationCategory}.\n * @return set of registered ProteinModifications in a particular category.\n */\n", "repo_name": "biojava-master/", "id": 256, "method_signature": "Set<ProteinModification> getByCategory(ModificationCategory)"}, "2820": {"callee_method_names": [], "method_name": "IOUtils.getPDBConservation", "method_implementation": "{\n    return getPDBString(web, c1, c2, similar, \"|\", \".\", \" \", web ? \"&nbsp;\" : \" \");\n}", "repo_id": "9", "comment": "/**\n * Creates formatted String for displaying conservation in PDB output\n *\n * @param web true for HTML display\n * @param c1 character in first sequence\n * @param c2 character in second sequence\n * @param similar true if c1 and c2 are considered similar compounds\n * @return formatted String\n */\n", "repo_name": "biojava-master/", "id": 2820, "method_signature": "String getPDBConservation(boolean, char, char, boolean)"}, "2687": {"callee_method_names": ["Sequence<C>.getCompoundSet", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "Edit.getTargetSequence", "method_implementation": "{\n    if (sequence == null && stringSequence != null) {\n        try {\n            sequence = new BasicSequence<C>(stringSequence, editingSequence.getCompoundSet());\n        } catch (CompoundNotFoundException e) {\n            // TODO is there a better way to handle this exception?\n            logger.error(\"Problem setting sequence, some unrecognised compounds: {}\", e.getMessage());\n        }\n    }\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Returns the Sequence which is our edit.\n *\n * @param editingSequence Asked for in-case we need to do String to\n * Sequence conversion so we need a CompoundSet which is given\n * by the Sequence we are editing\n * @return The Sequence<C> object we wish to insert\n */\n", "repo_name": "biojava-master/", "id": 2687, "method_signature": "Sequence<C> getTargetSequence(Sequence)"}, "182": {"callee_method_ids": [1190], "callee_method_names": ["PDBFileParser.parsePDBFile", "Structure.getPDBHeader", "Structure.getPDBHeader"], "method_name": "PDBFileParserTest.testDates", "method_implementation": "{\n    String revisionDates = \"REVDAT   5   13-JUL-11 1STP    1       VERSN                                    \" + newline + \"REVDAT   4   24-FEB-09 1STP    1       VERSN                                    \" + newline + \"REVDAT   3   01-APR-03 1STP    1       JRNL                                     \" + newline + \"REVDAT   2   15-OCT-94 1STP    1       AUTHOR                                   \" + newline + \"REVDAT   1   15-OCT-92 1STP    0                                                \" + newline;\n    BufferedReader br = new BufferedReader(new StringReader(revisionDates));\n    Structure s = parser.parsePDBFile(br);\n    // The latest modified date should be 2011\n    assertEquals(s.getPDBHeader().getModDate().getYear() + 1900, 2011);\n    // The release date should be 1992\n    assertEquals(s.getPDBHeader().getRelDate().getYear() + 1900, 1992);\n}", "repo_id": "9", "comment": "/**\n * Test the parsing of release and last modified dates.\n */\n", "repo_name": "biojava-master/", "id": 182, "method_signature": "void testDates()"}, "3709": {"callee_method_names": ["HashMap.clear", "ArrayList<String>.size", "ArrayList<Integer>.add", "ArrayList<String>.size", "ArrayList<String>.get", "ArrayList<Integer>.get", "ArrayList<String>.get", "ArrayList<String>.size", "ArrayList<Integer>.add", "ArrayList<String>.size", "ArrayList<String>.get", "ArrayList<Integer>.get", "ArrayList<String>.get"], "method_name": "WorkSheet.shuffleColumnsAndThenRows", "method_implementation": "{\n    doubleValues.clear();\n    for (String column : columns) {\n        //shuffle all values in the column\n        ArrayList<Integer> rowIndex = new ArrayList<Integer>();\n        for (int i = 0; i < rows.size(); i++) {\n            rowIndex.add(i);\n        }\n        Collections.shuffle(rowIndex);\n        for (int i = 0; i < rows.size(); i++) {\n            String row = rows.get(i);\n            int randomIndex = rowIndex.get(i);\n            String destinationRow = rows.get(randomIndex);\n            String temp = this.getCell(destinationRow, column);\n            String value = this.getCell(row, column);\n            this.addCell(destinationRow, column, value);\n            this.addCell(row, column, temp);\n        }\n    }\n    for (String row : rows) {\n        ArrayList<Integer> columnIndex = new ArrayList<Integer>();\n        for (int i = 0; i < columns.size(); i++) {\n            columnIndex.add(i);\n        }\n        Collections.shuffle(columnIndex);\n        for (int i = 0; i < columns.size(); i++) {\n            String column = columns.get(i);\n            int randomIndex = columnIndex.get(i);\n            String destinationCol = columns.get(randomIndex);\n            String temp = this.getCell(row, destinationCol);\n            String value = this.getCell(row, column);\n            this.addCell(row, destinationCol, value);\n            this.addCell(row, column, temp);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Randomly shuffle the columns and rows. Should be constrained to the same\n * data type if not probably doesn't make any sense.\n *\n * @param columns\n * @param rows\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3709, "method_signature": "void shuffleColumnsAndThenRows(ArrayList, ArrayList)"}, "1753": {"callee_method_names": [], "method_name": "MismatchedBasePairParameters.setMaxStagger", "method_implementation": "{\n    this.maxStagger = maxStagger;\n}", "repo_id": "9", "comment": "/**\n * This method sets the maximum stagger allowed for a base pair, prior to analyze() call\n * @param maxStagger The maximum propeller (in \u00c5) allowed to consider two bases paired\n */\n", "repo_name": "biojava-master/", "id": 1753, "method_signature": "void setMaxStagger(double)"}, "2912": {"callee_method_names": [], "method_name": "AbstractSequence.getParentSequence", "method_implementation": "{\n    return parentSequence;\n}", "repo_id": "9", "comment": "/**\n * @return the parentSequence\n */\n", "repo_name": "biojava-master/", "id": 2912, "method_signature": "AbstractSequence<?> getParentSequence()"}, "3499": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.getBlastToPosition", "method_implementation": "{\n    return Integer.parseInt(getAlignmentOption(QUERY_TO));\n}", "repo_id": "9", "comment": "/**\n * @return QUERY_TO parameter\n * @see #setBlastFromToPosition(int, int)\n */\n", "repo_name": "biojava-master/", "id": 3499, "method_signature": "int getBlastToPosition()"}, "2490": {"callee_method_names": ["List<Integer>.size", "List<Integer>.get", "List<Integer>.get", "List<Integer>.remove", "List<Integer>.remove", "List<Integer>.size", "List<Integer>.remove", "List<Integer>.add", "List<Integer>.remove", "List<Integer>.add", "List<Integer>.get", "List<Integer>.get", "List<Range<Integer>>.add"], "method_name": "ChromosomeMappingTools.getCDSRegions", "method_implementation": "{\n    // remove exons that are fully landed in UTRs\n    List<Integer> exonStarts = new ArrayList<>(origExonStarts);\n    List<Integer> exonEnds = new ArrayList<>(origExonEnds);\n    int j = 0;\n    for (int i = 0; i < origExonStarts.size(); i++) {\n        if ((origExonEnds.get(i) < cdsStart) || (origExonStarts.get(i) > cdsEnd)) {\n            exonStarts.remove(j);\n            exonEnds.remove(j);\n        } else {\n            j++;\n        }\n    }\n    // remove untranslated regions from exons\n    int nExons = exonStarts.size();\n    exonStarts.remove(0);\n    exonStarts.add(0, cdsStart);\n    exonEnds.remove(nExons - 1);\n    exonEnds.add(cdsEnd);\n    List<Range<Integer>> cdsRegion = new ArrayList<>();\n    for (int i = 0; i < nExons; i++) {\n        Range<Integer> r = Range.closed(exonStarts.get(i), exonEnds.get(i));\n        cdsRegion.add(r);\n    }\n    return cdsRegion;\n}", "repo_id": "9", "comment": "/**\n * Extracts the exons boundaries in CDS coordinates corresponding to the forward DNA strand.\n *\n * @param origExonStarts The list holding the genetic coordinates pointing to the start positions of the exons (including UTR regions)\n * @param origExonEnds The list holding the genetic coordinates pointing to the end positions of the exons (including UTR regions)\n * @param cdsStart The start position of a coding region\n * @param cdsEnd The end position of a coding region\n *\n * @return the list of genetic positions corresponding to the exons boundaries in CDS coordinates\n */\n", "repo_name": "biojava-master/", "id": 2490, "method_signature": "List<Range<Integer>> getCDSRegions(List, List, int, int)"}, "1216": {"callee_method_names": [], "method_name": "AbstractCifFileSupplier.toAtomSite", "method_implementation": "{\n    return Collector.of(AtomSiteCollector::new, AtomSiteCollector::accept, AtomSiteCollector::combine, AtomSiteCollector::get);\n}", "repo_id": "9", "comment": "/**\n * Collects {@link WrappedAtom} instances into one {@link org.rcsb.cif.schema.mm.AtomSite}.\n * @return an atom site record containing all atoms\n */\n", "repo_name": "biojava-master/", "id": 1216, "method_signature": "Collector<WrappedAtom,?,Category> toAtomSite()"}, "1448": {"callee_method_ids": [1450, 1451, 1452, 1452, 1450, 1451, 1452, 1452], "callee_method_names": ["BufferedReader.readLine", "String.startsWith", "TreeMap<Integer, SpaceGroup>.put", "SpaceGroup.getId", "HashMap<String, SpaceGroup>.put", "SpaceGroup.getShortSymbol", "SpaceGroup.getAltShortSymbol", "HashMap<String, SpaceGroup>.put", "SpaceGroup.getAltShortSymbol", "String.indexOf", "String.indexOf", "String.indexOf", "String.substring", "String.substring", "String.substring", "Pattern.matcher", "Matcher.matches", "Matcher.group", "Matcher.group", "String.trim", "Matcher.group", "SpaceGroup.addTransformation", "String.trim", "BufferedReader.close", "TreeMap<Integer, SpaceGroup>.put", "SpaceGroup.getId", "HashMap<String, SpaceGroup>.put", "SpaceGroup.getShortSymbol", "SpaceGroup.getAltShortSymbol", "HashMap<String, SpaceGroup>.put", "SpaceGroup.getAltShortSymbol", "Logger.error", "Element.getMessage", "TreeMap<Integer, SpaceGroup>.values", "SpaceGroup.initializeCellTranslations"], "method_name": "SymoplibParser.parseSymopLib", "method_implementation": "{\n    TreeMap<Integer, SpaceGroup> map = new TreeMap<Integer, SpaceGroup>();\n    name2sgs = new HashMap<String, SpaceGroup>();\n    try {\n        BufferedReader br = new BufferedReader(new InputStreamReader(symoplibIS));\n        String line;\n        SpaceGroup currentSG = null;\n        while ((line = br.readLine()) != null) {\n            if (!line.startsWith(\" \")) {\n                if (currentSG != null) {\n                    map.put(currentSG.getId(), currentSG);\n                    name2sgs.put(currentSG.getShortSymbol(), currentSG);\n                    if (currentSG.getAltShortSymbol() != null) {\n                        // we add also alternative name to map so we can look it up\n                        name2sgs.put(currentSG.getAltShortSymbol(), currentSG);\n                    }\n                }\n                int idxFirstSpace = line.indexOf(' ');\n                int idxSecondSpace = line.indexOf(' ', idxFirstSpace + 1);\n                int idxThirdSpace = line.indexOf(' ', idxSecondSpace + 1);\n                int id = Integer.parseInt(line.substring(0, idxFirstSpace));\n                int multiplicity = Integer.parseInt(line.substring(idxFirstSpace + 1, idxSecondSpace));\n                int primitiveMultiplicity = Integer.parseInt(line.substring(idxSecondSpace + 1, idxThirdSpace));\n                Matcher m = namePat.matcher(line);\n                String shortSymbol = null;\n                String altShortSymbol = null;\n                String brav = null;\n                if (m.matches()) {\n                    brav = m.group(1);\n                    // null if there is no match\n                    altShortSymbol = m.group(2);\n                    if (altShortSymbol != null)\n                        altShortSymbol = altShortSymbol.trim().replaceAll(\"'\", \"\");\n                    shortSymbol = m.group(3);\n                }\n                currentSG = new SpaceGroup(id, multiplicity, primitiveMultiplicity, shortSymbol, altShortSymbol, BravaisLattice.getByName(brav));\n            } else {\n                currentSG.addTransformation(line.trim());\n            }\n        }\n        br.close();\n        // and we add the last SG\n        map.put(currentSG.getId(), currentSG);\n        name2sgs.put(currentSG.getShortSymbol(), currentSG);\n        if (currentSG.getAltShortSymbol() != null) {\n            // we add also alternative name to map so we can look it up\n            name2sgs.put(currentSG.getAltShortSymbol(), currentSG);\n        }\n    } catch (IOException e) {\n        logger.error(\"Fatal error! Can't read symop.lib file. Error: \" + e.getMessage() + \". \");\n        System.exit(1);\n    }\n    for (SpaceGroup sg : map.values()) {\n        sg.initializeCellTranslations();\n    }\n    return map;\n}", "repo_id": "9", "comment": "/**\n * A parser for the symop.lib file provided by CCP4. Note: this file is not getting re-distributed by BioJava.\n * It can be downloaded from:\n *\n *  http://www.ccp4.ac.uk/cvs/viewvc.cgi/libccp4/data/symop.lib?revision=1.10&view=markup\n *\n * Note: this file is not needed by BioJava. BioJava loads equivalent information from the file spacegroups.xml\n *\n * @param symoplibIS\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1448, "method_signature": "TreeMap<Integer,SpaceGroup> parseSymopLib(InputStream)"}, "2732": {"callee_method_names": [], "method_name": "EmblId.getMoleculeType", "method_implementation": "{\n    return moleculeType;\n}", "repo_id": "9", "comment": "/**\n * Molecule type this represents the type of molecule as stored\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2732, "method_signature": "String getMoleculeType()"}, "677": {"callee_method_names": ["MultipleAlignment.putScore", "MultipleAlignment.size", "MultipleAlignment.getAtomArrays", "List<Integer>.add", "MultipleAlignment.putScore"], "method_name": "MultipleAlignmentScorer.calculateScores", "method_implementation": "{\n    // Put RMSD\n    List<Atom[]> trans = MultipleAlignmentTools.transformAtoms(alignment);\n    alignment.putScore(RMSD, getRMSD(trans));\n    // Put AvgTM-Score\n    List<Integer> lengths = new ArrayList<Integer>(alignment.size());\n    for (Atom[] atoms : alignment.getAtomArrays()) {\n        lengths.add(atoms.length);\n    }\n    alignment.putScore(AVGTM_SCORE, getAvgTMScore(trans, lengths));\n}", "repo_id": "9", "comment": "/**\n * Calculates and puts the RMSD and the average TM-Score of the\n * MultipleAlignment.\n *\n * @param alignment\n * @throws StructureException\n * @see #getAvgTMScore(MultipleAlignment)\n * @see #getRMSD(MultipleAlignment)\n */\n", "repo_name": "biojava-master/", "id": 677, "method_signature": "void calculateScores(MultipleAlignment)"}, "2684": {"callee_method_names": [], "method_name": "RNASequence.getComplement", "method_implementation": "{\n    return new ComplementSequenceView<>(this);\n}", "repo_id": "9", "comment": "/**\n * Get the complement view of the RNA sequence\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2684, "method_signature": "SequenceView<NucleotideCompound> getComplement()"}, "3707": {"callee_method_ids": [3700], "callee_method_names": ["LinkedHashMap.keySet", "LinkedHashMap.get", "HeaderInfo.isHide", "ArrayList<String>.add"], "method_name": "WorkSheet.getMetaDataRows", "method_implementation": "{\n    ArrayList<String> metaRows = new ArrayList<String>();\n    for (String key : metaDataRowsHashMap.keySet()) {\n        HeaderInfo hi = rowLookup.get(key);\n        if (!hi.isHide()) {\n            metaRows.add(key);\n        }\n    }\n    return metaRows;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3707, "method_signature": "ArrayList<String> getMetaDataRows()"}, "2131": {"callee_method_ids": [1771, 1771], "callee_method_names": ["PDBHeader.getExperimentalTechniques", "PDBHeader.getExperimentalTechniques", "PDBHeader.getCrystallographicInfo", "PDBHeader.getCrystallographicInfo", "PDBHeader.getCrystallographicInfo"], "method_name": "StructureImpl.isCrystallographic", "method_implementation": "{\n    if (pdbHeader.getExperimentalTechniques() != null) {\n        return ExperimentalTechnique.isCrystallographic(pdbHeader.getExperimentalTechniques());\n    } else {\n        // no experimental technique known, we try to guess...\n        if (pdbHeader.getCrystallographicInfo().getSpaceGroup() != null) {\n            // space group defined but no crystal cell: incomplete info, return false\n            return pdbHeader.getCrystallographicInfo().getCrystalCell() != null && pdbHeader.getCrystallographicInfo().getCrystalCell().isCellReasonable();\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Whether this Structure is a crystallographic structure or not.\n * It will first check the experimental technique and if not present it will try\n * to guess from the presence of a space group and sensible cell parameters\n *\n * @return true if crystallographic, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 2131, "method_signature": "boolean isCrystallographic()"}, "343": {"callee_method_names": ["Structure.getChains"], "method_name": "DemoMmtfReader.main", "method_implementation": "{\n    Structure structure = MmtfActions.readFromWeb(\"4cup\");\n    System.out.println(structure.getChains().size());\n}", "repo_id": "9", "comment": "/**\n * Main function to run the demo\n * @param args no args to specify\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 343, "method_signature": "void main(String[])"}, "897": {"callee_method_names": ["List<AbstractCifFileSupplier.WrappedAtom>.add", "List<AbstractCifFileSupplier.WrappedAtom>.add", "Atom.getPDBserial", "List<AbstractCifFileSupplier.WrappedAtom>.add", "List<AbstractCifFileSupplier.WrappedAtom>.add", "Atom.getPDBserial", "List<AbstractCifFileSupplier.WrappedAtom>.stream", "MmCifBlockBuilder.addCategory", "MmCifBlockBuilder.leaveBlock"], "method_name": "StructureInterface.toMMCIF", "method_implementation": "{\n    String molecId1 = getMoleculeIds().getFirst();\n    String molecId2 = getMoleculeIds().getSecond();\n    if (isSymRelated()) {\n        // if both chains are named equally we want to still named them differently in the output mmcif file\n        // so that molecular viewers can handle properly the 2 chains as separate entities\n        molecId2 = molecId2 + \"_\" + getTransforms().getSecond().getTransformId();\n    }\n    MmCifBlockBuilder mmCifBlockBuilder = CifBuilder.enterFile(StandardSchemata.MMCIF).enterBlock(\"BioJava_interface_\" + getId());\n    // we reassign atom ids if sym related (otherwise atom ids would be duplicated and some molecular viewers can't cope with that)\n    int atomId = 1;\n    List<AbstractCifFileSupplier.WrappedAtom> wrappedAtoms = new ArrayList<>();\n    for (Atom atom : this.molecules.getFirst()) {\n        if (isSymRelated()) {\n            wrappedAtoms.add(new AbstractCifFileSupplier.WrappedAtom(1, molecId1, molecId1, atom, atomId));\n        } else {\n            wrappedAtoms.add(new AbstractCifFileSupplier.WrappedAtom(1, molecId1, molecId1, atom, atom.getPDBserial()));\n        }\n        atomId++;\n    }\n    for (Atom atom : this.molecules.getSecond()) {\n        if (isSymRelated()) {\n            wrappedAtoms.add(new AbstractCifFileSupplier.WrappedAtom(1, molecId2, molecId2, atom, atomId));\n        } else {\n            wrappedAtoms.add(new AbstractCifFileSupplier.WrappedAtom(1, molecId2, molecId2, atom, atom.getPDBserial()));\n        }\n        atomId++;\n    }\n    Category atomSite = wrappedAtoms.stream().collect(AbstractCifFileSupplier.toAtomSite());\n    mmCifBlockBuilder.addCategory(atomSite);\n    try {\n        return new String(CifIO.writeText(mmCifBlockBuilder.leaveBlock().leaveFile()));\n    } catch (IOException e) {\n        throw new UncheckedIOException(e);\n    }\n}", "repo_id": "9", "comment": "/**\n * Return a String representing the 2 molecules of this interface in mmCIF format.\n * If the molecule ids (i.e. chain ids) are the same for both molecules, then the second\n * one will be written as chainId_operatorId (with operatorId taken from {@link #getTransforms()}\n * @return the mmCIF-formatted string\n */\n", "repo_name": "biojava-master/", "id": 897, "method_signature": "String toMMCIF()"}, "3374": {"callee_method_names": ["JFileChooser.showOpenDialog", "JFileChooser.getSelectedFile", "JTextField.setText", "File.getAbsolutePath", "JTextField.repaint"], "method_name": "ChooseAction.actionPerformed", "method_implementation": "{\n    // Perform action...\n    final JFileChooser fc = new JFileChooser();\n    //\t\tIn response to a button click:\n    int returnVal = fc.showOpenDialog(null);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n        File file = fc.getSelectedFile();\n        textField.setText(file.getAbsolutePath());\n        textField.repaint();\n    }\n}", "repo_id": "9", "comment": "// This method is called when the button is pressed\n", "repo_name": "biojava-master/", "id": 3374, "method_signature": "void actionPerformed(ActionEvent)"}, "981": {"callee_method_names": [], "method_name": "HetatomImpl.getAtoms", "method_implementation": "{\n    return atoms;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 981, "method_signature": "List<Atom> getAtoms()"}, "3243": {"callee_method_names": ["MultipleAlignmentJmol.setTitle", "MultipleAlignmentJmol.getStructure"], "method_name": "MultipleAlignmentJmolDisplay.display", "method_implementation": "{\n    List<Atom[]> rotatedAtoms = MultipleAlignmentDisplay.getRotatedAtoms(multAln);\n    MultipleAlignmentJmol jmol = new MultipleAlignmentJmol(multAln, rotatedAtoms);\n    jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());\n    return jmol;\n}", "repo_id": "9", "comment": "/**\n * Display a MultipleAlignment with a JmolPanel.\n * New structures are downloaded if they were\n * not cached in the alignment and they are entirely\n * transformed here with the superposition information\n * in the Multiple Alignment.\n *\n * @param multAln\n * @return MultipleAlignmentJmol instance\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3243, "method_signature": "MultipleAlignmentJmol display(MultipleAlignment)"}, "474": {"callee_method_ids": [465], "callee_method_names": ["StructureName.getPdbId"], "method_name": "PdbPair.getPdbId1", "method_implementation": "{\n    return name1.getPdbId();\n}", "repo_id": "9", "comment": "/**\n * @since 6.0.0\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 474, "method_signature": "PdbId getPdbId1()"}, "3140": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.setUniprotbaseURL", "method_implementation": "{\n    uniprotbaseURL = aUniprotbaseURL;\n}", "repo_id": "9", "comment": "/**\n * @param aUniprotbaseURL the uniprotbaseURL to set\n */\n", "repo_name": "biojava-master/", "id": 3140, "method_signature": "void setUniprotbaseURL(String)"}, "1827": {"callee_method_names": ["String.toUpperCase", "ObjectMapper.readValue", "URL.openStream", "JsonNode.get", "JsonNode.get", "JsonNode.get", "JsonNode.asText"], "method_name": "PDBStatus.getCurrent", "method_implementation": "{\n    URL url = new URL(String.format(STATUS_ENDPOINT, DEFAULT_RCSB_DATA_API_SERVER, oldPdbId.toUpperCase()));\n    ObjectMapper objectMapper = new ObjectMapper();\n    JsonNode node = objectMapper.readValue(url.openStream(), JsonNode.class);\n    JsonNode rcsbRepoHoldingsNode = node.get(\"rcsb_repository_holdings_combined\");\n    Status st = Status.fromString(rcsbRepoHoldingsNode.get(\"status\").asText());\n    if (st == Status.REMOVED) {\n        JsonNode replacedByNode = rcsbRepoHoldingsNode.get(\"id_code_replaced_by_latest\");\n        if (replacedByNode != null)\n            return replacedByNode.asText();\n        else\n            return null;\n    } else if (st == Status.CURRENT) {\n        return oldPdbId;\n    } else {\n        return null;\n    }\n}", "repo_id": "9", "comment": "/**\n * Gets the current version of a PDB ID.\n *\n * @param oldPdbId the id\n * @return The replacement for oldPdbId, or null if none are found.\n * If entry is current then the input PDB id is returned\n */\n", "repo_name": "biojava-master/", "id": 1827, "method_signature": "String getCurrent(String)"}, "3576": {"callee_method_names": [], "method_name": "Matrix.abs", "method_implementation": "{\n    int m = A.length;\n    double[] C = new double[m];\n    for (int i = 0; i < m; i++) {\n        C[i] = Math.abs(A[i]);\n    }\n    return C;\n}", "repo_id": "9", "comment": "/**\n * @param A\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3576, "method_signature": "double[] abs(double[])"}, "2767": {"callee_method_names": ["Sequence<?>.getAccession", "GenbankWriter<Sequence<?>, Compound>.process"], "method_name": "GenbankWriterHelper.writeSequences", "method_implementation": "{\n    GenbankHeaderFormatInterface<Sequence<?>, Compound> fhfi = new GenbankHeaderFormatInterface<Sequence<?>, Compound>() {\n\n        @Override\n        public String getHeader(Sequence<?> sequence) {\n            return sequence.getAccession().toString();\n        }\n    };\n    GenbankWriter<Sequence<?>, Compound> genbankWriter = new GenbankWriter<Sequence<?>, Compound>(outputStream, sequences, fhfi);\n    genbankWriter.process();\n}", "repo_id": "9", "comment": "/**\n * Method which will write your given Sequences to the specified\n * {@link OutputStream}. This is a very generic method which writes just the\n * AccessionID of the Sequence as the FASTA header.\n *\n * @param outputStream\n *            Stream to write to; can be System.out\n * @param sequences\n *            The sequences to write out\n * @throws Exception\n *             Thrown normally thanks to IO problems\n */\n", "repo_name": "biojava-master/", "id": 2767, "method_signature": "void writeSequences(OutputStream, Collection)"}, "997": {"callee_method_names": ["Atom.getGroup", "Atom.getGroup", "PDPDistanceMatrix.setNclose", "PDPDistanceMatrix.setIclose", "PDPDistanceMatrix.setJclose", "PDPDistanceMatrix.setDist"], "method_name": "GetDistanceMatrix.getDistanceMatrix", "method_implementation": "{\n    int[][] dist = new int[protein.length + 3][protein.length + 3];\n    int i, j;\n    double d, dt1, dt2, dt3, dt4;\n    int nclose = 0;\n    int[] iclose = new int[protein.length * protein.length];\n    int[] jclose = new int[protein.length * protein.length];\n    if (protein.length >= PDPParameters.MAXLEN) {\n        System.err.println(String.format(\"%d protein.len > MAXLEN %d\\n\", protein.length, PDPParameters.MAXLEN));\n        return null;\n    }\n    for (i = 0; i < protein.length; i++) {\n        for (j = i; j < protein.length; j++) {\n            dist[i][j] = 0;\n            dist[j][i] = 0;\n            d = 0;\n            Atom ca1 = protein[i];\n            Atom ca2 = protein[j];\n            Group g1 = ca1.getGroup();\n            Group g2 = ca2.getGroup();\n            Atom cb1 = getCBeta(g1);\n            Atom cb2 = getCBeta(g2);\n            boolean hasCbeta1 = cb1 != null;\n            boolean hasCbeta2 = cb2 != null;\n            dt1 = 81;\n            dt2 = 64;\n            dt3 = 49;\n            dt4 = 36;\n            if (hasCbeta1 && hasCbeta2) {\n                double distance = Calc.getDistance(cb1, cb2);\n                d += distance * distance;\n            } else if (hasCbeta1 && !hasCbeta2) {\n                double distance = 999;\n                distance = Calc.getDistance(cb1, ca2);\n                d += distance * distance;\n            } else if (!hasCbeta1 && hasCbeta2) {\n                double distance = Calc.getDistance(ca1, cb2);\n                d += distance * distance;\n            } else if (!hasCbeta1 && !hasCbeta2) {\n                double distance = Calc.getDistance(ca1, ca2);\n                d += distance * distance;\n            }\n            if (d < dt1) {\n                dist[i][j] = 1;\n                dist[j][i] = 1;\n                if (d < dt2) {\n                    dist[i][j] = 2;\n                    dist[j][i] = 2;\n                    if (j - i > 35) {\n                        iclose[nclose] = i;\n                        jclose[nclose] = j;\n                        nclose++;\n                    }\n                    if (d < dt3) {\n                        dist[i][j] = 4;\n                        dist[j][i] = 4;\n                        if (d < dt4) {\n                            dist[i][j] = 6;\n                            dist[j][i] = 6;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /* secondary structure interaction */\n    for (i = 1; i < protein.length; i++) {\n        for (j = i; j < protein.length - 1; j++) {\n            /* beta-sheet */\n            if (dist[i][j] >= 2 && j - i > 5) {\n                if (dist[i - 1][j - 1] >= 2 && dist[i + 1][j + 1] >= 2 || dist[i - 1][j + 1] >= 2 && dist[i + 1][j - 1] >= 2) {\n                    dist[i][j] += 4;\n                    dist[j][i] += 4;\n                    /*\n\t\t\t\t\tprintf(\"1: %d %d %d\\n\",i,j,dist[i][j]);\n\t\t\t\t\t\t */\n                } else /* alpha-helices */\n                if (i > 2 && j < protein.length - 2) {\n                    if (dist[i - 3][j - 3] >= 1 && dist[i + 3][j + 3] >= 1 || dist[i - 3][j + 3] >= 1 && dist[i + 3][j - 3] >= 1) {\n                        dist[i][j] += 4;\n                        dist[j][i] += 4;\n                        /*\n\t\t\t\t\t\tprintf(\"3: %d %d %d\\n\",i,j,dist[i][j]);\n\t\t\t\t\t\t\t */\n                    } else if (i > 3 && j < protein.length - 3) {\n                        if ((dist[i - 3][j - 3] >= 1 || dist[i - 3][j - 4] >= 1 || dist[i - 4][j - 3] >= 1 || dist[i - 4][j - 4] >= 1) && (dist[i + 4][j + 4] >= 1 || dist[i + 4][j + 3] >= 1 || dist[i + 3][j + 3] >= 1 || dist[i + 3][j + 4] >= 1) || (dist[i - 4][j + 4] >= 1 || dist[i - 4][j + 3] >= 1 || dist[i - 3][j + 4] >= 1 || dist[i - 3][j + 3] >= 1) && (dist[i + 4][j - 4] >= 1 || dist[i + 4][j - 3] >= 1 || dist[i + 3][j - 4] >= 1 || dist[i + 3][j - 3] >= 1)) {\n                            dist[i][j] += 4;\n                            dist[j][i] += 4;\n                            /*\n\t\t\t\t\t\t\tprintf(\"4: %d %d %d\\n\",i,j,dist[i][j]);\n\t\t\t\t\t\t\t\t */\n                        }\n                    }\n                }\n            }\n        }\n    }\n    PDPDistanceMatrix matrix = new PDPDistanceMatrix();\n    matrix.setNclose(nclose);\n    matrix.setIclose(iclose);\n    matrix.setJclose(jclose);\n    matrix.setDist(dist);\n    return matrix;\n}", "repo_id": "9", "comment": "/**\n * A set of Calpha atoms that are representing the protein\n *\n * @param protein\n */\n", "repo_name": "biojava-master/", "id": 997, "method_signature": "PDPDistanceMatrix getDistanceMatrix(Atom[])"}, "2953": {"callee_method_names": [], "method_name": "SequenceProxyView.getBioEnd", "method_implementation": "{\n    return bioEnd;\n}", "repo_id": "9", "comment": "/**\n * @return the bioEnd\n */\n", "repo_name": "biojava-master/", "id": 2953, "method_signature": "Integer getBioEnd()"}, "2633": {"callee_method_names": [], "method_name": "SequenceOptimizationHints.setSequenceCollection", "method_implementation": "{\n    sequenceCollection = aSequenceColection;\n}", "repo_id": "9", "comment": "/**\n * @param aSequenceColection the sequenceColection to set\n */\n", "repo_name": "biojava-master/", "id": 2633, "method_signature": "void setSequenceCollection(SequenceCollection)"}, "1184": {"callee_method_ids": [1373, 1375, 1393, 1395, 1391, 1377, 1379, 1381, 1383, 1387, 1385, 1389], "callee_method_names": ["Logger.debug", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.length", "String.substring", "DBRef.setIdCode", "DBRef.setChainName", "DBRef.setSeqBegin", "DBRef.setInsertBegin", "String.charAt", "DBRef.setSeqEnd", "DBRef.setInsertEnd", "String.charAt", "DBRef.setDatabase", "String.trim", "DBRef.setDbAccession", "String.trim", "DBRef.setDbIdCode", "String.trim", "DBRef.setDbSeqBegin", "DBRef.setIdbnsBegin", "String.charAt", "DBRef.setDbSeqEnd", "DBRef.setIdbnsEnd", "String.charAt", "List<DBRef>.add"], "method_name": "PDBFileParser.pdb_DBREF_Handler", "method_implementation": "{\n    logger.debug(\"Parsing DBREF {}\", line);\n    DBRef dbref = new DBRef();\n    String idCode = line.substring(7, 11);\n    String chainName = line.substring(12, 13);\n    String seqBegin = line.substring(14, 18);\n    String insertBegin = line.substring(18, 19);\n    String seqEnd = line.substring(20, 24);\n    String insertEnd = line.substring(24, 25);\n    String database = line.substring(26, 32);\n    String dbAccession = line.substring(33, 41);\n    String dbIdCode = line.substring(42, 54);\n    String dbseqBegin = line.substring(55, 60);\n    String idbnsBeg = line.substring(60, 61);\n    String dbseqEnd = line.substring(62, 67);\n    // Support implicit space character at end\n    String dbinsEnd;\n    if (line.length() >= 68)\n        dbinsEnd = line.substring(67, 68);\n    else\n        dbinsEnd = \" \";\n    dbref.setIdCode(idCode);\n    dbref.setChainName(chainName);\n    dbref.setSeqBegin(intFromString(seqBegin));\n    dbref.setInsertBegin(insertBegin.charAt(0));\n    dbref.setSeqEnd(intFromString(seqEnd));\n    dbref.setInsertEnd(insertEnd.charAt(0));\n    dbref.setDatabase(database.trim());\n    dbref.setDbAccession(dbAccession.trim());\n    dbref.setDbIdCode(dbIdCode.trim());\n    dbref.setDbSeqBegin(intFromString(dbseqBegin));\n    dbref.setIdbnsBegin(idbnsBeg.charAt(0));\n    dbref.setDbSeqEnd(intFromString(dbseqEnd));\n    dbref.setIdbnsEnd(dbinsEnd.charAt(0));\n    //System.out.println(dbref.toPDB());\n    dbrefs.add(dbref);\n}", "repo_id": "9", "comment": "/**\n * DBREF handler\n * <pre>\n * COLUMNS       DATA TYPE          FIELD          DEFINITION\n * ----------------------------------------------------------------\n *  1 - 6        Record name        \"DBREF \"\n *  8 - 11       IDcode             idCode         ID code of this entry.\n * 13            Character          chainID        Chain identifier.\n * 15 - 18       Integer            seqBegin       Initial sequence number\n *                                                 of the PDB sequence segment.\n * 19            AChar              insertBegin    Initial insertion code\n *                                                 of the PDB sequence segment.\n * 21 - 24       Integer            seqEnd         Ending sequence number\n *                                                 of the PDB sequence segment.\n * 25            AChar              insertEnd      Ending insertion code\n *                                                 of the PDB sequence segment.\n * 27 - 32       LString            database       Sequence database name.\n * 34 - 41       LString            dbAccession    Sequence database accession code.\n * 43 - 54      LString            dbIdCode        Sequence database\n *                                                 identification code.\n * 56 - 60      Integer            dbseqBegin      Initial sequence number of the\n *                                                 database seqment.\n * 61           AChar              idbnsBeg        Insertion code of initial residue\n *                                                 of the segment, if PDB is the\n *                                                 reference.\n * 63 - 67      Integer            dbseqEnd        Ending sequence number of the\n *                                                 database segment.\n * 68           AChar              dbinsEnd        Insertion code of the ending\n *                                                 residue of the segment, if PDB is\n *                                                 the reference.\n * </pre>\n */\n", "repo_name": "biojava-master/", "id": 1184, "method_signature": "void pdb_DBREF_Handler(String)"}, "2529": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum70", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum70\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 70 matrix by Henikoff & Henikoff\n * @return Blosum 70 matrix\n */\n", "repo_name": "biojava-master/", "id": 2529, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum70()"}, "943": {"callee_method_names": [], "method_name": "InterfaceFinder.setCutoff", "method_implementation": "{\n    this.cutoff = cutoff;\n}", "repo_id": "9", "comment": "/**\n * Set the contact distance cutoff.\n * @param cutoff the distance value in Angstroms\n */\n", "repo_name": "biojava-master/", "id": 943, "method_signature": "void setCutoff(double)"}, "2852": {"callee_method_names": ["FastaReader<ProteinSequence, AminoAcidCompound>.process"], "method_name": "FastaReaderHelper.readFastaProteinSequence", "method_implementation": "{\n    FastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n    return fastaReader.process();\n}", "repo_id": "9", "comment": "/**\n * Read a fasta file containing amino acids with setup that would handle most\n * cases. User is responsible for closing InputStream because you opened it\n *\n * @param inStream\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2852, "method_signature": "LinkedHashMap<String,ProteinSequence> readFastaProteinSequence(InputStream)"}, "2499": {"callee_method_ids": [2438, 2459, 2452, 2459, 2459, 2459, 2459, 2452, 2451, 2451, 2438, 2448, 2438, 2438, 3182, 3181, 3067, 3175, 3177, 2452, 2459, 2454, 2454, 3071, 3169, 2456, 3061], "callee_method_names": ["FeatureList.selectByType", "Feature.getAttribute", "Feature.source", "Feature.getAttribute", "Feature.getAttribute", "String.length", "LinkedHashMap<String, FeatureList>.get", "FeatureList.get", "Feature.getAttribute", "Feature.getAttribute", "Feature.source", "Feature.seqname", "Feature.seqname", "LinkedHashMap<String,ChromosomeSequence>.get", "LinkedHashMap<String, FeatureList>.get", "FeatureList.selectByType", "FeatureList.get", "FeatureI.location", "FeatureList.sortByStart", "FeatureList.selectByType", "FeatureList.size", "FeatureList.get", "FeatureI.location", "FeatureI.location", "FeatureI.getAttribute", "FeatureList.selectByType", "FeatureList.size", "FeatureList.get", "FeatureI.location", "FeatureI.location", "FeatureI.getAttribute", "FeatureList.get", "FeatureI.location", "FeatureList.get", "FeatureI.location", "FeatureList.get", "FeatureList.size", "FeatureI.location", "FeatureList.get", "FeatureList.size", "FeatureI.location", "ChromosomeSequence.getGene", "ChromosomeSequence.addGene", "GeneSequence.setSource", "String.length", "GeneSequence.addNote", "GeneSequence.getBioBegin", "GeneSequence.setBioBegin", "GeneSequence.getBioBegin", "GeneSequence.setBioEnd", "GeneSequence.addTranscript", "TranscriptSequence.setSource", "String.length", "TranscriptSequence.addNote", "String.length", "FeatureI.location", "FeatureI.location", "TranscriptSequence.addStartCodonSequence", "FeatureI.location", "FeatureI.location", "String.length", "FeatureI.location", "FeatureI.location", "TranscriptSequence.addStopCodonSequence", "FeatureI.location", "FeatureI.location", "Feature.source", "Feature.getAttribute", "String.length", "Feature.location", "Feature.location", "GeneSequence.addExon", "ExonSequence.setSource", "String.length", "ExonSequence.addNote", "TranscriptSequence.addCDS", "Feature.frame", "GeneSequence.addIntronsUsingExons"], "method_name": "GeneFeatureHelper.addGmodGFF3GeneFeatures", "method_implementation": "{\n    // key off mRNA as being a known feature that may or may not have a parent gene\n    FeatureList mRNAFeatures = listGenes.selectByType(\"mRNA\");\n    LinkedHashMap<String, FeatureList> featureIDHashMap = FeatureHelper.buildFeatureAtrributeIndex(\"ID\", listGenes);\n    LinkedHashMap<String, FeatureList> featureParentHashMap = FeatureHelper.buildFeatureAtrributeIndex(\"Parent\", listGenes);\n    for (FeatureI f : mRNAFeatures) {\n        String geneID;\n        String geneNote = null;\n        String geneSource = null;\n        String sequenceName = null;\n        ChromosomeSequence seq = null;\n        GeneSequence geneSequence = null;\n        Feature mRNAFeature = (Feature) f;\n        String mRNAID = mRNAFeature.getAttribute(\"ID\");\n        String mRNAsource = mRNAFeature.source();\n        String mRNANote = mRNAFeature.getAttribute(\"Note\");\n        String mRNAParent = mRNAFeature.getAttribute(\"Parent\");\n        if (mRNAParent != null && mRNAParent.length() > 0) {\n            // FeatureList geneFeatureList = listGenes.selectByAttribute(\"ID\", mRNAParent);\n            FeatureList geneFeatureList = featureIDHashMap.get(mRNAParent);\n            Feature geneFeature = (Feature) geneFeatureList.get(0);\n            geneID = geneFeature.getAttribute(\"ID\");\n            geneNote = geneFeature.getAttribute(\"Note\");\n            geneSource = geneFeature.source();\n            sequenceName = geneFeature.seqname();\n            //\n        } else {\n            //deal with cases where no parent gene is given\n            geneID = mRNAID;\n            geneSource = mRNAsource;\n            sequenceName = mRNAFeature.seqname();\n        }\n        seq = chromosomeSequenceList.get(sequenceName);\n        AccessionID geneAccessionID = new AccessionID(geneID);\n        //  FeatureList mRNAChildren = listGenes.selectByAttribute(\"Parent\", mRNAID);\n        FeatureList mRNAChildren = featureParentHashMap.get(mRNAID);\n        FeatureList cdsFeatures = mRNAChildren.selectByType(\"CDS\");\n        FeatureI feature = cdsFeatures.get(0);\n        Strand strand = Strand.POSITIVE;\n        if (feature.location().isNegative()) {\n            strand = Strand.NEGATIVE;\n        }\n        cdsFeatures = cdsFeatures.sortByStart();\n        //String seqName = feature.seqname();\n        FeatureI startCodon = null;\n        FeatureI stopCodon = null;\n        Integer startCodonBegin = null;\n        Integer stopCodonEnd = null;\n        String startCodonName = \"\";\n        String stopCodonName = \"\";\n        FeatureList startCodonList = mRNAChildren.selectByType(\"five_prime_UTR\");\n        if (startCodonList != null && startCodonList.size() > 0) {\n            startCodon = startCodonList.get(0);\n            if (strand == Strand.NEGATIVE) {\n                startCodonBegin = startCodon.location().bioEnd();\n            } else {\n                startCodonBegin = startCodon.location().bioStart();\n            }\n            startCodonName = startCodon.getAttribute(\"ID\");\n        }\n        FeatureList stopCodonList = mRNAChildren.selectByType(\"three_prime_UTR\");\n        if (stopCodonList != null && stopCodonList.size() > 0) {\n            stopCodon = stopCodonList.get(0);\n            if (strand == Strand.NEGATIVE) {\n                stopCodonEnd = stopCodon.location().bioStart();\n            } else {\n                stopCodonEnd = stopCodon.location().bioEnd();\n            }\n            stopCodonName = stopCodon.getAttribute(\"ID\");\n        }\n        if (startCodonBegin == null) {\n            if (strand == Strand.NEGATIVE) {\n                FeatureI firstFeature = cdsFeatures.get(0);\n                startCodonBegin = firstFeature.location().bioEnd();\n            } else {\n                FeatureI firstFeature = cdsFeatures.get(0);\n                startCodonBegin = firstFeature.location().bioStart();\n            }\n        }\n        if (stopCodonEnd == null) {\n            if (strand == Strand.NEGATIVE) {\n                FeatureI lastFeature = cdsFeatures.get(cdsFeatures.size() - 1);\n                stopCodonEnd = lastFeature.location().bioStart();\n            } else {\n                FeatureI lastFeature = cdsFeatures.get(cdsFeatures.size() - 1);\n                stopCodonEnd = lastFeature.location().bioEnd();\n            }\n        }\n        //for gtf ordering can be strand based so first is last and last is first\n        if (startCodonBegin > stopCodonEnd) {\n            int temp = startCodonBegin;\n            startCodonBegin = stopCodonEnd;\n            stopCodonEnd = temp;\n        }\n        AccessionID transcriptAccessionID = new AccessionID(mRNAID);\n        geneSequence = seq.getGene(geneID);\n        if (geneSequence == null) {\n            geneSequence = seq.addGene(geneAccessionID, startCodonBegin, stopCodonEnd, strand);\n            geneSequence.setSource(geneSource);\n            if (geneNote != null && geneNote.length() > 0) {\n                geneSequence.addNote(geneNote);\n            }\n        } else {\n            if (startCodonBegin < geneSequence.getBioBegin()) {\n                geneSequence.setBioBegin(startCodonBegin);\n            }\n            if (stopCodonEnd > geneSequence.getBioBegin()) {\n                geneSequence.setBioEnd(stopCodonEnd);\n            }\n        }\n        TranscriptSequence transcriptSequence = geneSequence.addTranscript(transcriptAccessionID, startCodonBegin, stopCodonEnd);\n        transcriptSequence.setSource(mRNAsource);\n        if (mRNANote != null && mRNANote.length() > 0) {\n            transcriptSequence.addNote(mRNANote);\n        }\n        if (startCodon != null) {\n            if (startCodonName == null || startCodonName.length() == 0) {\n                startCodonName = mRNAID + \"-start_codon-\" + startCodon.location().bioStart() + \"-\" + startCodon.location().bioEnd();\n            }\n            transcriptSequence.addStartCodonSequence(new AccessionID(startCodonName), startCodon.location().bioStart(), startCodon.location().bioEnd());\n        }\n        if (stopCodon != null) {\n            if (stopCodonName == null || stopCodonName.length() == 0) {\n                stopCodonName = mRNAID + \"-stop_codon-\" + stopCodon.location().bioStart() + \"-\" + stopCodon.location().bioEnd();\n            }\n            transcriptSequence.addStopCodonSequence(new AccessionID(stopCodonName), stopCodon.location().bioStart(), stopCodon.location().bioEnd());\n        }\n        for (FeatureI cdsFeature : cdsFeatures) {\n            Feature cds = (Feature) cdsFeature;\n            String cdsNote = cdsFeature.getAttribute(\"Note\");\n            String cdsSource = cds.source();\n            String cdsName = cds.getAttribute(\"ID\");\n            if (cdsName == null || cdsName.length() == 0) {\n                cdsName = mRNAID + \"-cds-\" + cds.location().bioStart() + \"-\" + cds.location().bioEnd();\n            }\n            AccessionID cdsAccessionID = new AccessionID(cdsName);\n            ExonSequence exonSequence = geneSequence.addExon(cdsAccessionID, cdsFeature.location().bioStart(), cdsFeature.location().bioEnd());\n            exonSequence.setSource(cdsSource);\n            if (cdsNote != null && cdsNote.length() > 0) {\n                exonSequence.addNote(cdsNote);\n            }\n            transcriptSequence.addCDS(cdsAccessionID, cdsFeature.location().bioStart(), cdsFeature.location().bioEnd(), cds.frame());\n        }\n        geneSequence.addIntronsUsingExons();\n    }\n}", "repo_id": "9", "comment": "/**\n * Load GFF3 file using mRNA as the gene feature as not all GFF3 files are complete\n * @param chromosomeSequenceList\n * @param listGenes\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2499, "method_signature": "void addGmodGFF3GeneFeatures(LinkedHashMap, FeatureList)"}, "3276": {"callee_method_names": [], "method_name": "JmolPanel.jmolColorByChain", "method_implementation": "{\n    String script = \"function color_by_chain(objtype, color_list) {\" + String.format(\"%n\") + \"\" + String.format(\"%n\") + \"\t\t if (color_list) {\" + String.format(\"%n\") + \"\t\t   if (color_list.type == \\\"string\\\") {\" + String.format(\"%n\") + \"\t\t     color_list = color_list.split(\\\",\\\").trim();\" + String.format(\"%n\") + \"\t\t   }\" + String.format(\"%n\") + \"\t\t } else {\" + String.format(\"%n\") + \"\t\t   color_list = [\\\"104BA9\\\",\\\"AA00A2\\\",\\\"C9F600\\\",\\\"FFA200\\\",\\\"284A7E\\\",\\\"7F207B\\\",\\\"9FB82E\\\",\\\"BF8B30\\\",\\\"052D6E\\\",\\\"6E0069\\\",\\\"83A000\\\",\\\"A66A00\\\",\\\"447BD4\\\",\\\"D435CD\\\",\\\"D8FA3F\\\",\\\"FFBA40\\\",\\\"6A93D4\\\",\\\"D460CF\\\",\\\"E1FA71\\\",\\\"FFCC73\\\"];\" + String.format(\"%n\") + \"\t\t }\" + String.format(\"%n\") + \"\t\t var cmd2 = \\\"\\\";\" + String.format(\"%n\") + \"\t\t if (!objtype) {\" + String.format(\"%n\") + \"\t\t   var type_list  = [ \\\"backbone\\\",\\\"cartoon\\\",\\\"dots\\\",\\\"halo\\\",\\\"label\\\",\\\"meshribbon\\\",\\\"polyhedra\\\",\\\"rocket\\\",\\\"star\\\",\\\"strand\\\",\\\"strut\\\",\\\"trace\\\"];\" + String.format(\"%n\") + \"\t\t   cmd2 = \\\"color \\\" + type_list.join(\\\" none; color \\\") + \\\" none;\\\";\" + String.format(\"%n\") + \"\t\t   objtype = \\\"atoms\\\";\" + String.format(\"%n\") + \"\t\t }\" + String.format(\"%n\") + \"\t\t var chain_list  = script(\\\"show chain\\\").trim().lines;\" + String.format(\"%n\") + \"\t\t var chain_count = chain_list.length;\" + String.format(\"%n\") + \"\t\t var color_count = color_list.length;\" + String.format(\"%n\") + \"\t\t var sel = {selected};\" + String.format(\"%n\") + \"\t\t var cmds = \\\"\\\";\" + String.format(\"%n\") + \"\t\t for (var chain_number=1; chain_number<=chain_count; chain_number++) {\" + String.format(\"%n\") + \"\t\t   // remember, Jmol arrays start with 1, but % can return 0\" + String.format(\"%n\") + \"\t\t   cmds += \\\"select sel and :\\\" + chain_list[chain_number] + \\\";color \\\" + objtype + \\\" [x\\\" + color_list[(chain_number-1) % color_count + 1] + \\\"];\\\" + cmd2;\" + String.format(\"%n\") + \"\t\t }\" + String.format(\"%n\") + \"\t\t script INLINE @{cmds + \\\"select sel\\\"}\" + String.format(\"%n\") + \"}\";\n    executeCmd(script);\n}", "repo_id": "9", "comment": "/**\n * assign a custom color to the Jmol chains command.\n */\n", "repo_name": "biojava-master/", "id": 3276, "method_signature": "void jmolColorByChain()"}, "879": {"callee_method_names": ["Group.getChemComp", "Logger.warn", "Group.getResidueNumber", "Group.getPDBName", "ChemComp.getPolymerType"], "method_name": "StructureInterface.isInChain", "method_implementation": "{\n    ChemComp chemComp = g.getChemComp();\n    if (chemComp == null) {\n        logger.warn(\"Can't determine PolymerType for group \" + g.getResidueNumber() + \" (\" + g.getPDBName() + \"). Will consider it as non-nucleotide/non-protein type.\");\n        return false;\n    }\n    PolymerType polyType = chemComp.getPolymerType();\n    for (PolymerType protOnlyType : PolymerType.PROTEIN_ONLY) {\n        if (polyType == protOnlyType)\n            return true;\n    }\n    for (PolymerType protOnlyType : PolymerType.POLYNUCLEOTIDE_ONLY) {\n        if (polyType == protOnlyType)\n            return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Returns true if the given group is part of the main chain, i.e. if it is\n * a peptide-linked group or a nucleotide\n * @param g\n * @return\n */\n", "repo_name": "biojava-master/", "id": 879, "method_signature": "boolean isInChain(Group)"}, "2120": {"callee_method_names": [], "method_name": "StructureImpl.setStructureIdentifier", "method_implementation": "{\n    this.structureIdentifier = structureIdentifier;\n}", "repo_id": "9", "comment": "/**\n * @param structureIdentifier the structureIdentifier corresponding to this structure\n */\n", "repo_name": "biojava-master/", "id": 2120, "method_signature": "void setStructureIdentifier(StructureIdentifier)"}, "2222": {"callee_method_ids": [641, 628, 1786], "callee_method_names": ["AtomCache.setFiletype", "AtomCache.getStructure", "Structure.getPDBHeader", "PDBHeader.getRfree", "PDBHeader.getRwork"], "method_name": "TestParseMmcifHeader.testRfactors", "method_implementation": "{\n    AtomCache atomCache = new AtomCache();\n    atomCache.setFiletype(StructureFiletype.CIF);\n    Structure structure = atomCache.getStructure(\"4cup\");\n    PDBHeader pdbHeader = structure.getPDBHeader();\n    // Check they are the same\n    assertEquals(pdbHeader.getRfree(), 0.2078f, 0.000001f);\n    assertEquals(pdbHeader.getRwork(), 0.1763f, 0.000001f);\n}", "repo_id": "9", "comment": "/**\n * Test we can parse R-work and R-free effectively.\n */\n", "repo_name": "biojava-master/", "id": 2222, "method_signature": "void testRfactors()"}, "1141": {"callee_method_ids": [1400], "callee_method_names": ["PdbId.getId", "String.length", "String.substring", "LinkedList<File>.add", "LinkedList<File>.add", "String.toLowerCase", "File.exists", "File.length", "File.toPath"], "method_name": "LocalPDBDirectory.getLocalFile", "method_implementation": "{\n    String id = pdbId.getId();\n    int offset = id.length() - 3;\n    // Search for existing files\n    // Search directories:\n    // 1) LOCAL_MMCIF_SPLIT_DIR/<middle>/(pdb)?<pdbId>.<ext>\n    // 2) LOCAL_MMCIF_ALL_DIR/<middle>/(pdb)?<pdbId>.<ext>\n    LinkedList<File> searchdirs = new LinkedList<File>();\n    String middle = id.substring(offset, offset + 2).toLowerCase();\n    File splitdir = new File(splitDirPath, middle);\n    searchdirs.add(splitdir);\n    // Search obsolete files if requested\n    if (getObsoleteBehavior() == ObsoleteBehavior.FETCH_OBSOLETE) {\n        File obsdir = new File(obsoleteDirPath, middle);\n        searchdirs.add(obsdir);\n    }\n    // valid prefixes before the <pdbId> in the filename\n    String[] prefixes = new String[] { \"\", \"pdb\" };\n    for (File searchdir : searchdirs) {\n        for (String prefix : prefixes) {\n            for (String ex : getExtensions()) {\n                File f = new File(searchdir, prefix + id.toLowerCase() + ex);\n                if (f.exists()) {\n                    // delete files that are too short to have contents\n                    if (f.length() < MIN_PDB_FILE_SIZE) {\n                        Files.delete(f.toPath());\n                        return null;\n                    }\n                    return f;\n                }\n            }\n        }\n    }\n    //Not found\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Searches for previously downloaded files\n * @param pdbId\n * @return A file pointing to the existing file, or null if not found\n * @throws IOException If the file exists but is empty and can't be deleted\n */\n", "repo_name": "biojava-master/", "id": 1141, "method_signature": "File getLocalFile(PdbId)"}, "3049": {"callee_method_names": [], "method_name": "LocationHelper.modulateCircularIndex", "method_implementation": "{\n    // Dummy case\n    if (seqLength == 0) {\n        return index;\n    }\n    // Modulate\n    while (index > seqLength) {\n        index -= seqLength;\n    }\n    return index;\n}", "repo_id": "9", "comment": "/**\n * Takes a point on a circular location and moves it left until it falls\n * at the earliest possible point that represents the same base.\n *\n * @param index Index of the position to work with\n * @param seqLength Length of the Sequence\n * @return The shifted point\n */\n", "repo_name": "biojava-master/", "id": 3049, "method_signature": "int modulateCircularIndex(int, int)"}, "808": {"callee_method_names": ["FragmentPair[].clone", "Logger.debug", "Logger.debug", "FragmentPair[].getPos1", "FragmentPair[].getPos2", "FragmentPair[].getLength", "JointFragments.add", "FragmentPair[].getLength", "FragmentPair[].getPos1", "FragmentPair[].getPos2", "FragmentPair[].getLength", "FragmentPair[].getUnitv", "FragmentPair[].getUnitv", "FragmentPair[].getCenter1", "FragmentPair[].getCenter1", "FragmentPair[].getCenter2", "FragmentPair[].getCenter2", "JointFragments.add", "FragmentPair[].getLength", "List<JointFragments>.add", "List<JointFragments>.size", "List<JointFragments>.get", "List<JointFragments>.add", "List<JointFragments>.toArray", "List<JointFragments>.size"], "method_name": "FragmentJoiner.frag_pairwise_compat", "method_implementation": "{\n    FragmentPair[] tmpfidx = new FragmentPair[fraglst.length];\n    for (int i = 0; i < fraglst.length; i++) {\n        tmpfidx[i] = (FragmentPair) fraglst[i].clone();\n    }\n    int n = tmpfidx.length;\n    //indicator if a fragment was already used\n    int[] used = new int[n];\n    //the final list of joined fragments stores as apairs\n    List<JointFragments> fll = new ArrayList<JointFragments>();\n    double adiff = angleDiff * Math.PI / 180d;\n    logger.debug(\"addiff{}\", adiff);\n    //distance between two unit vectors with angle adiff\n    double ddiff = Math.sqrt(2.0 - 2.0 * Math.cos(adiff));\n    logger.debug(\"ddiff{}\", ddiff);\n    // the fpairs in the flist have to be sorted with respect to their positions\n    while (tmpfidx.length > 0) {\n        int i = 0;\n        int j = 1;\n        used[i] = 1;\n        JointFragments f = new JointFragments();\n        int p1i = tmpfidx[i].getPos1();\n        int p1j = tmpfidx[i].getPos2();\n        int maxi = p1i + tmpfidx[i].getLength();\n        f.add(p1i, p1j, 0, tmpfidx[i].getLength());\n        n = tmpfidx.length;\n        while (j < n) {\n            int p2i = tmpfidx[j].getPos1();\n            int p2j = tmpfidx[j].getPos2();\n            int l2 = tmpfidx[j].getLength();\n            if (p2i > maxi) {\n                double dist = Calc.getDistance(tmpfidx[i].getUnitv(), tmpfidx[j].getUnitv());\n                if (dist < ddiff) {\n                    // centroids have to be closer than fragCompatDist\n                    double dd = Calc.getDistance(tmpfidx[i].getCenter1(), tmpfidx[j].getCenter1()) - Calc.getDistance(tmpfidx[i].getCenter2(), tmpfidx[j].getCenter2());\n                    if (dd < 0)\n                        dd = -dd;\n                    if (dd < fragCompatDist) {\n                        maxi = p2i + l2;\n                        used[j] = 1;\n                        f.add(p2i, p2j, 0, tmpfidx[j].getLength());\n                    }\n                }\n            }\n            j += 1;\n        }\n        int red = 0;\n        for (int k = 0; k < n; k++) {\n            if (used[k] == 0) {\n                tmpfidx[red] = tmpfidx[k];\n                red += 1;\n            }\n        }\n        used = new int[n];\n        tmpfidx = (FragmentPair[]) resizeArray(tmpfidx, red);\n        fll.add(f);\n    }\n    Comparator<JointFragments> comp = new JointFragmentsComparator();\n    Collections.sort(fll, comp);\n    Collections.reverse(fll);\n    int m = Math.min(maxRefine, fll.size());\n    List<JointFragments> retlst = new ArrayList<JointFragments>();\n    for (int i = 0; i < m; i++) {\n        JointFragments jf = fll.get(i);\n        retlst.add(jf);\n    }\n    return retlst.toArray(new JointFragments[retlst.size()]);\n}", "repo_id": "9", "comment": "/**\n * Calculate the pairwise compatibility of fpairs.\n * Iterates through a list of fpairs and joins them if\n * they have compatible rotation and translation parameters.\n * @param fraglst FragmentPair[] array\n * @param angleDiff angle cutoff\n * @param fragCompatDist distance cutoff\n * @param maxRefine max number of solutions to keep\n * @return JointFragments[]\n */\n", "repo_name": "biojava-master/", "id": 808, "method_signature": "JointFragments[] frag_pairwise_compat(FragmentPair[], int, float, int)"}, "515": {"callee_method_ids": [489, 490, 487], "callee_method_names": ["StringWriter.append", "StringWriter.append", "AFPChain.getName1", "StringWriter.append", "StringWriter.append", "StringWriter.append", "AFPChain.getName2", "StringWriter.append", "StringWriter.append", "AFPChain.getOptAln", "AFPChain.getOptLen", "AFPChain.getBlockNum", "StringWriter.append", "Atom.getGroup", "StringWriter.append", "StringWriter.append", "Atom.getGroup", "StringWriter.append", "StringWriter.append", "Atom.getGroup", "StringWriter.append", "StringWriter.append", "Atom.getGroup", "StringWriter.append", "StringWriter.append", "Atom.getGroup", "StringWriter.append", "StringWriter.append", "Atom.getGroup", "StringWriter.append", "StringWriter.toString"], "method_name": "AfpChainWriter.toAlignedPairs", "method_implementation": "{\n    StringWriter pairs = new StringWriter();\n    //Write structure names & PDB codes\n    pairs.append(\"#Struct1:\\t\");\n    pairs.append(afpChain.getName1());\n    pairs.append(\"\\n\");\n    pairs.append(\"#Struct2:\\t\");\n    pairs.append(afpChain.getName2());\n    pairs.append(\"\\n\");\n    //Write optimally aligned pairs\n    pairs.append(\"#Num1\\tChain1\\tAA1\\tNum2\\tChain2\\tAA2\\n\");\n    int[][][] optAln = afpChain.getOptAln();\n    int[] blockLen = afpChain.getOptLen();\n    for (int block = 0; block < afpChain.getBlockNum(); block++) {\n        for (int i = 0; i < blockLen[block]; i++) {\n            Atom atom1 = ca1[optAln[block][0][i]];\n            Atom atom2 = ca2[optAln[block][1][i]];\n            pairs.append(atom1.getGroup().getResidueNumber().toString());\n            pairs.append('\\t');\n            pairs.append(atom1.getGroup().getChain().getName());\n            pairs.append('\\t');\n            pairs.append(atom1.getGroup().getPDBName());\n            pairs.append('\\t');\n            pairs.append(atom2.getGroup().getResidueNumber().toString());\n            pairs.append('\\t');\n            pairs.append(atom2.getGroup().getChain().getName());\n            pairs.append('\\t');\n            pairs.append(atom2.getGroup().getPDBName());\n            pairs.append('\\n');\n        }\n    }\n    return pairs.toString();\n}", "repo_id": "9", "comment": "/**\n * Prints the alignment in the simplest form: a list of aligned residues.\n * Format is one line per residue pair, tab delimited:\n * <ul><li>1. PDB number. Includes insertion code</li>\n * <li>1. Chain.</li>\n * <li>1. Amino Acid. Three letter code.</li>\n * <li>2. PDB number.</li>\n * <li>2. Chain.</li>\n * <li>2. Amino Acid.</li>\n * </ul>\n * example:\n * <code>152\tA\tALA\t161S\tA\tVAL</code>\n * <p>Note that this format loses information about blocks.\n * @param afpChain\n * @param ca1\n * @param ca2\n * @return a String representation of the aligned pairs.\n */\n", "repo_name": "biojava-master/", "id": 515, "method_signature": "String toAlignedPairs(AFPChain, Atom[], Atom[])"}, "2248": {"callee_method_names": [], "method_name": "TestMmtfUtils.testGetSpaceGroupAsString", "method_implementation": "{\n    assertEquals(\"NA\", MmtfUtils.getSpaceGroupAsString(null));\n    SpaceGroup spaceGroup = new SpaceGroup(21, 1, 1, \"P212121\", \"P 21 21 21\", BravaisLattice.TRICLINIC);\n    assertEquals(\"P212121\", MmtfUtils.getSpaceGroupAsString(spaceGroup));\n}", "repo_id": "9", "comment": "/**\n * Test that getting the space group info as a string works.\n */\n", "repo_name": "biojava-master/", "id": 2248, "method_signature": "void testGetSpaceGroupAsString()"}, "2999": {"callee_method_names": [], "method_name": "BitSequenceReader.getCompoundsToIndexLookup", "method_implementation": "{\n    if (compoundsToIndexLookup == null) {\n        compoundsToIndexLookup = generateCompoundsToIndex();\n    }\n    return compoundsToIndexLookup;\n}", "repo_id": "9", "comment": "/**\n * Returns a map which converts from compound to an integer representation\n */\n", "repo_name": "biojava-master/", "id": 2999, "method_signature": "Map<C,Integer> getCompoundsToIndexLookup()"}, "39": {"callee_method_names": ["List<S>.size", "List<S>.size", "List<PairwiseSequenceAligner<S, C>>.add", "List<S>.get", "List<S>.get"], "method_name": "Alignments.getAllPairsAligners", "method_implementation": "{\n    List<PairwiseSequenceAligner<S, C>> allPairs = new ArrayList<PairwiseSequenceAligner<S, C>>();\n    for (int i = 0; i < sequences.size(); i++) {\n        for (int j = i + 1; j < sequences.size(); j++) {\n            allPairs.add(getPairwiseAligner(sequences.get(i), sequences.get(j), type, gapPenalty, subMatrix));\n        }\n    }\n    return allPairs;\n}", "repo_id": "9", "comment": "/**\n * Factory method which sets up a sequence alignment for all {@link Sequence} pairs in the given {@link List}.\n *\n * @param <S> each {@link Sequence} of an alignment pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param sequences the {@link List} of {@link Sequence}s to align\n * @param type chosen type from list of pairwise sequence alignment routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return list of pairwise sequence aligners\n */\n", "repo_name": "biojava-master/", "id": 39, "method_signature": "List<PairwiseSequenceAligner<S,C>> getAllPairsAligners(List, PairwiseSequenceAlignerType, GapPenalty, SubstitutionMatrix)"}, "1434": {"callee_method_names": ["Matrix3d.mul", "Matrix3d.add", "Matrix3d.transform", "Vector3d.scale", "Matrix3d.add", "Matrix3d.transform", "Vector3d.scale"], "method_name": "CrystalTransform.getTranslScrewComponent", "method_implementation": "{\n    int foldType = SpaceGroup.getRotAxisType(m);\n    // For reference see:\n    // http://www.crystallography.fr/mathcryst/pdf/Gargnano/Aroyo_Gargnano_1.pdf\n    Vector3d transl = null;\n    Matrix3d W = new Matrix3d(m.m00, m.m01, m.m02, m.m10, m.m11, m.m12, m.m20, m.m21, m.m22);\n    if (foldType >= 0) {\n        // the Y matrix: Y = W^k-1 + W^k-2 ... + W + I  ; with k the fold type\n        Matrix3d Y = new Matrix3d(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        Matrix3d Wk = new Matrix3d(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        for (int k = 0; k < foldType; k++) {\n            // k=0 Wk=W, k=1 Wk=W^2, k=2 Wk=W^3, ... k=foldType-1, Wk=W^foldType\n            Wk.mul(W);\n            if (k != foldType - 1)\n                Y.add(Wk);\n        }\n        transl = new Vector3d(m.m03, m.m13, m.m23);\n        Y.transform(transl);\n        transl.scale(1.0 / foldType);\n    } else {\n        if (foldType == -2) {\n            // there are glide planes only in -2\n            Matrix3d Y = new Matrix3d(1, 0, 0, 0, 1, 0, 0, 0, 1);\n            Y.add(W);\n            transl = new Vector3d(m.m03, m.m13, m.m23);\n            Y.transform(transl);\n            transl.scale(1.0 / 2.0);\n        } else {\n            // for -1, -3, -4 and -6 there's nothing to do: fill with 0s\n            transl = new Vector3d(0, 0, 0);\n        }\n    }\n    return transl;\n}", "repo_id": "9", "comment": "/**\n * Given a transformation matrix containing a rotation and translation returns the\n * screw component of the rotation.\n * See http://www.crystallography.fr/mathcryst/pdf/Gargnano/Aroyo_Gargnano_1.pdf\n * @param m\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1434, "method_signature": "Vector3d getTranslScrewComponent(Matrix4d)"}, "305": {"callee_method_ids": [264, 264, 264, 265, 265, 264, 265, 265, 270, 271, 270, 271], "callee_method_names": ["List<ModificationLinkage>.size", "List<Atom[]>.size", "List<ModificationLinkage>.get", "List<Atom[]>.get", "List<ModificationLinkage>.get", "List<Atom[]>.get", "ModificationLinkage.getIndexOfComponent1", "ModificationLinkage.getIndexOfComponent1", "Atom[].getGroup", "Atom[].getGroup", "ModificationLinkage.getIndexOfComponent1", "ModificationLinkage.getIndexOfComponent2", "Atom[].getGroup", "Atom[].getGroup", "ModificationLinkage.getIndexOfComponent2", "ModificationLinkage.getIndexOfComponent1", "Atom[].getGroup", "Atom[].getGroup", "ModificationLinkage.getIndexOfComponent2", "ModificationLinkage.getIndexOfComponent2", "Atom[].getGroup", "Atom[].getGroup", "ModificationLinkage.getLabelOfAtomOnComponent1", "ModificationLinkage.getLabelOfAtomOnComponent2", "ModificationLinkage.getLabelOfAtomOnComponent1", "ModificationLinkage.getLabelOfAtomOnComponent2", "String.equals", "Atom[].equals", "String.equals", "Atom[].equals", "String.equals", "Atom[].equals", "String.equals", "Atom[].equals"], "method_name": "ProteinModificationIdentifier.matchLinkages", "method_implementation": "{\n    int nLink = linkages.size();\n    if (nLink != atomLinkages.size()) {\n        return false;\n    }\n    for (int i = 0; i < nLink - 1; i++) {\n        ModificationLinkage link1 = linkages.get(i);\n        Atom[] atoms1 = atomLinkages.get(i);\n        for (int j = i + 1; j < nLink; j++) {\n            ModificationLinkage link2 = linkages.get(j);\n            Atom[] atoms2 = atomLinkages.get(j);\n            // check components\n            if (((link1.getIndexOfComponent1() == link2.getIndexOfComponent1()) != (atoms1[0].getGroup().equals(atoms2[0].getGroup()))) || ((link1.getIndexOfComponent1() == link2.getIndexOfComponent2()) != (atoms1[0].getGroup().equals(atoms2[1].getGroup()))) || ((link1.getIndexOfComponent2() == link2.getIndexOfComponent1()) != (atoms1[1].getGroup().equals(atoms2[0].getGroup()))) || ((link1.getIndexOfComponent2() == link2.getIndexOfComponent2()) != (atoms1[1].getGroup().equals(atoms2[1].getGroup())))) {\n                return false;\n            }\n            // check atoms\n            String label11 = link1.getLabelOfAtomOnComponent1();\n            String label12 = link1.getLabelOfAtomOnComponent2();\n            String label21 = link2.getLabelOfAtomOnComponent1();\n            String label22 = link2.getLabelOfAtomOnComponent2();\n            if ((label11 != null && label21 != null && label11.equals(label21)) != (atoms1[0].equals(atoms2[0])) || (label11 != null && label22 != null && label11.equals(label22)) != (atoms1[0].equals(atoms2[1])) || (label12 != null && label21 != null && label12.equals(label21)) != (atoms1[1].equals(atoms2[0])) || (label12 != null && label22 != null && label12.equals(label22)) != (atoms1[1].equals(atoms2[1]))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * @param linkages\n * @param atomLinkages\n * @return true if atomLinkages satisfy the condition; false, otherwise.\n */\n", "repo_name": "biojava-master/", "id": 305, "method_signature": "boolean matchLinkages(List, List)"}, "1314": {"callee_method_names": [], "method_name": "FastaAFPChainConverter.main", "method_implementation": "{\n    if (args.length != 3) {\n        System.err.println(\"Usage: FastaAFPChainConverter fasta-file structure-1-name structure-2-name\");\n        return;\n    }\n    File fasta = new File(args[0]);\n    Structure structure1 = StructureTools.getStructure(args[1]);\n    Structure structure2 = StructureTools.getStructure(args[2]);\n    if (structure1 == null)\n        throw new IllegalArgumentException(\"No structure for \" + args[1] + \" was found\");\n    if (structure2 == null)\n        throw new IllegalArgumentException(\"No structure for \" + args[2] + \" was found\");\n    AFPChain afpChain = fastaFileToAfpChain(fasta, structure1, structure2);\n    String xml = AFPChainXMLConverter.toXML(afpChain);\n    System.out.println(xml);\n}", "repo_id": "9", "comment": "/**\n * Prints out the XML representation of an AFPChain from a file containing exactly two FASTA sequences.\n *\n * @param args\n *            A String array of fasta-file structure-1-name structure-2-name\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1314, "method_signature": "void main(String[])"}, "859": {"callee_method_names": ["TreeMap<Key, Value>.keySet"], "method_name": "SymbolTable.iterator", "method_implementation": "{\n    return st.keySet().iterator();\n}", "repo_id": "9", "comment": "/**\n * Return an <tt>Iterator</tt> for the keys in the table.\n * To iterate over all of the keys in the symbol table <tt>st</tt>, use the\n * foreach notation: <tt>for (Key key : st)</tt>.\n */\n", "repo_name": "biojava-master/", "id": 859, "method_signature": "Iterator<Key> iterator()"}, "1573": {"callee_method_names": [], "method_name": "Site.getDescription", "method_implementation": "{\n    return description;\n}", "repo_id": "9", "comment": "/**\n * gets the REMARK 800 description of the site\n * @return description\n */\n", "repo_name": "biojava-master/", "id": 1573, "method_signature": "String getDescription()"}, "124": {"callee_method_ids": [5, 4], "callee_method_names": ["SimpleGapPenalty.setOpenPenalty", "SimpleGapPenalty.setExtensionPenalty"], "method_name": "TestDNAAlignment.testDNAPairwiseAlignmentWithMixedCompoundSets", "method_implementation": "{\n    DNASequence target = new DNASequence(\"ACTGACGTGTAGCTGACTGA\", DNACompoundSet.getDNACompoundSet());\n    DNASequence query = new DNASequence(\"ACTGACGTGTAGCTGACTGT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    SubstitutionMatrix<NucleotideCompound> matrix = SubstitutionMatrixHelper.getNuc4_4();\n    SimpleGapPenalty gapP = new SimpleGapPenalty();\n    gapP.setOpenPenalty((short) 5);\n    gapP.setExtensionPenalty((short) 2);\n    try {\n        @SuppressWarnings(\"unused\")\n        SequencePair<DNASequence, NucleotideCompound> psa = Alignments.getPairwiseAlignment(query, target, PairwiseSequenceAlignerType.LOCAL, gapP, matrix);\n        Assert.fail(\"Alignments.getPairwiseAlignment() expected exception with differing compound sets\");\n    } catch (IllegalArgumentException ex) {\n        // expected exception\n    }\n}", "repo_id": "9", "comment": "/**\n * @author brandstaetter\n */\n", "repo_name": "biojava-master/", "id": 124, "method_signature": "void testDNAPairwiseAlignmentWithMixedCompoundSets()"}, "2476": {"callee_method_names": ["BufferedReader.readLine", "BufferedReader.readLine", "ArrayList<GeneName>.add", "ArrayList<GeneName>.trimToSize"], "method_name": "GeneNamesParser.getGeneNames", "method_implementation": "{\n    ArrayList<GeneName> geneNames = new ArrayList<GeneName>();\n    BufferedReader reader = new BufferedReader(new InputStreamReader(inStream));\n    // skip reading first line (it is the legend)\n    String line = reader.readLine();\n    while ((line = reader.readLine()) != null) {\n        // process line...\n        //System.out.println(Arrays.toString(line.split(\"\\t\")));\n        GeneName geneName = getGeneName(line);\n        if (geneName != null)\n            geneNames.add(geneName);\n        //System.out.println(geneName);\n    }\n    // since this is a large list, let's free up unused space...\n    geneNames.trimToSize();\n    return geneNames;\n}", "repo_id": "9", "comment": "/**\n * Get a list of GeneNames from an input stream.\n *\n * @param inStream\n * @return list of geneNames\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2476, "method_signature": "List<GeneName> getGeneNames(InputStream)"}, "1728": {"callee_method_names": [], "method_name": "BasePairParameters.getStretch", "method_implementation": "{\n    checkArgument(bp);\n    return pairingParameters[bp][4];\n}", "repo_id": "9", "comment": "/**\n * This method returns the stretch in \u00c5 for the given base pair\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in \u00c5)\n */\n", "repo_name": "biojava-master/", "id": 1728, "method_signature": "Double getStretch(int)"}, "3363": {"callee_method_names": ["GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].put", "LinearColorInterpolator.setInterpolationDirection", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].setInterpolator", "LinearColorInterpolator.setInterpolationDirection", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].setInterpolator", "LinearColorInterpolator.setInterpolationDirection", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].setInterpolator", "LinearColorInterpolator.setInterpolationDirection", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].setInterpolator", "LinearColorInterpolator.setInterpolationDirection", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].setInterpolator", "LinearColorInterpolator.setInterpolationDirection", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].put", "GradientMapper[].setInterpolator", "JPanel.setPreferredSize", "JPanel.add", "JPanel.add", "JFrame.getContentPane", "JFrame.pack", "JFrame.setDefaultCloseOperation", "JFrame.setVisible"], "method_name": "GradientMapper.main", "method_implementation": "{\n    GradientMapper[] mappers = new GradientMapper[20];\n    int i = 0;\n    ColorSpace hsv = HSVColorSpace.getHSVColorSpace();\n    LinearColorInterpolator interp;\n    // RGB colorspace\n    mappers[i] = new GradientMapper(Color.black, Color.white);\n    mappers[i].put(-5., Color.red);\n    mappers[i].put(5., Color.blue);\n    i++;\n    // Premade\n    mappers[i] = GradientMapper.getGradientMapper(BLACK_WHITE_GRADIENT, -5, 5);\n    i++;\n    mappers[i] = GradientMapper.getGradientMapper(RAINBOW_INTENSITY_GRADIENT, -5, 5);\n    //mappers[i].put(Double.NEGATIVE_INFINITY, mappers[i].get(Double.NEGATIVE_INFINITY).brighter());\n    //mappers[i].put(Double.POSITIVE_INFINITY, mappers[i].get(Double.POSITIVE_INFINITY).darker());\n    i++;\n    // Rainbow\n    mappers[i] = new GradientMapper(Color.black, Color.white, hsv);\n    mappers[i].put(-5., new Color(hsv, new float[] { 0f, 1f, 1f }, 1f));\n    mappers[i].put(5., new Color(hsv, new float[] { 1f, 1f, 1f }, 1f));\n    i++;\n    // HSV INNER\n    mappers[i] = new GradientMapper(Color.black, Color.white, hsv);\n    mappers[i].put(5., Color.red);\n    mappers[i].put(-5., Color.blue);\n    i++;\n    // HSV OUTER\n    interp = new LinearColorInterpolator(hsv);\n    interp.setInterpolationDirection(0, InterpolationDirection.OUTER);\n    mappers[i] = new GradientMapper(Color.black, Color.white, hsv);\n    mappers[i].put(5., Color.red);\n    mappers[i].put(-5., Color.blue);\n    mappers[i].setInterpolator(interp);\n    i++;\n    // HSV UPPER\n    interp = new LinearColorInterpolator(hsv);\n    interp.setInterpolationDirection(0, InterpolationDirection.UPPER);\n    mappers[i] = new GradientMapper(Color.black, Color.white, hsv);\n    mappers[i].put(5., Color.red);\n    mappers[i].put(-5., Color.blue);\n    mappers[i].setInterpolator(interp);\n    i++;\n    // HSV LOWER\n    interp = new LinearColorInterpolator(hsv);\n    interp.setInterpolationDirection(0, InterpolationDirection.LOWER);\n    mappers[i] = new GradientMapper(Color.black, Color.white, hsv);\n    mappers[i].put(5., Color.red);\n    mappers[i].put(-5., Color.blue);\n    mappers[i].setInterpolator(interp);\n    i++;\n    // Mimic DefaultMapper\n    interp = new LinearColorInterpolator(hsv);\n    interp.setInterpolationDirection(0, InterpolationDirection.INNER);\n    mappers[i] = new GradientMapper(Color.green, Color.black, hsv);\n    mappers[i].put(0., new Color(hsv, new float[] { 1f, .9f, 1f }, 1f));\n    mappers[i].put(10., new Color(hsv, new float[] { 0f, .9f, 0f }, 1f));\n    mappers[i].setInterpolator(interp);\n    i++;\n    // Better DefaultGradient\n    interp = new LinearColorInterpolator(hsv);\n    interp.setInterpolationDirection(0, InterpolationDirection.INNER);\n    mappers[i] = new GradientMapper(Color.green, Color.black, hsv);\n    mappers[i].put(0., new Color(hsv, new float[] { 1f, .9f, 1f }, 1f));\n    mappers[i].put(1., new Color(hsv, new float[] { 0f, .9f, 1f }, 1f));\n    mappers[i].put(1 + 1e-6, Color.white);\n    mappers[i].put(10., Color.black);\n    mappers[i].setInterpolator(interp);\n    i++;\n    // Better DefaultGradient\n    interp = new LinearColorInterpolator(hsv);\n    interp.setInterpolationDirection(0, InterpolationDirection.INNER);\n    mappers[i] = new GradientMapper(Color.green, Color.black, hsv);\n    mappers[i].put(0., new Color(hsv, new float[] { 1f, .9f, 1f }, 1f));\n    mappers[i].put(1., new Color(hsv, new float[] { .2f, .9f, 1f }, 1f));\n    mappers[i].put(1 + 1e-6, Color.white);\n    mappers[i].put(10., Color.black);\n    mappers[i].setInterpolator(interp);\n    i++;\n    DefaultMatrixMapper defaultMapper = new DefaultMatrixMapper(10f, .9f);\n    JFrame frame = new JFrame(\"GradientMapper\");\n    JPanel main = new JPanel();\n    main.setPreferredSize(new Dimension(300, 500));\n    for (int j = 0; j < i; j++) {\n        GradientPanel grad1 = new GradientPanel(mappers[j], -10, 10);\n        //grad1.setPreferredSize(new Dimension(500,50));\n        main.add(grad1);\n    }\n    GradientPanel grad2 = new GradientPanel(defaultMapper, -10, 10);\n    //grad2.setPreferredSize(new Dimension(500,50));\n    main.add(grad2);\n    //main.add(new GradientPanel(defaultMapper,-10,10));\n    frame.getContentPane().add(main);\n    frame.pack();\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n}", "repo_id": "9", "comment": "/**\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 3363, "method_signature": "void main(String[])"}, "2359": {"callee_method_names": ["DNASequence.addFeature", "DNASequence.getLength"], "method_name": "FastqTools.createDNASequenceWithErrorProbabilities", "method_implementation": "{\n    DNASequence sequence = createDNASequence(fastq);\n    sequence.addFeature(1, sequence.getLength(), createErrorProbabilities(fastq));\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Create and return a new {@link DNASequence} with error probabilities from the specified\n * FASTQ formatted sequence.  The error probabilities are stored in a {@link QuantityFeature}\n * with a type <code>\"errorProbabilities\"</code> the same length as the sequence.\n *\n * @param fastq FASTQ formatted sequence, must not be null\n * @return a new {@link DNASequence} with error probabilities from the specified FASTQ formatted sequence\n * @throws CompoundNotFoundException if DNA sequence in fastq contains unrecognised compounds\n */\n", "repo_name": "biojava-master/", "id": 2359, "method_signature": "DNASequence createDNASequenceWithErrorProbabilities(Fastq)"}, "2140": {"callee_method_ids": [1160], "callee_method_names": ["FileConvert.toMMCIF"], "method_name": "StructureImpl.toMMCIF", "method_implementation": "{\n    FileConvert f = new FileConvert(this);\n    return f.toMMCIF();\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2140, "method_signature": "String toMMCIF()"}, "1919": {"callee_method_names": ["Helix.getContacts", "Helix.getContacts"], "method_name": "HelixLayers.getByLargestContacts", "method_implementation": "{\n    double contacts = 0;\n    Helix largest = null;\n    for (Helix helix : helices) {\n        if (helix.getContacts() > contacts) {\n            contacts = helix.getContacts();\n            largest = helix;\n        }\n    }\n    return largest;\n}", "repo_id": "9", "comment": "/*\n\t * Returns Helix with largest number of intermolecular contacts\n\t * between repeat units\n\t */\n", "repo_name": "biojava-master/", "id": 1919, "method_signature": "Helix getByLargestContacts()"}, "31": {"callee_method_names": ["String.split", "String[].split"], "method_name": "StockholmStructure.splitSeqName", "method_implementation": "{\n    String[] result = new String[3];\n    String[] barSplit = sequenceName.split(\"/\");\n    if (barSplit.length == 2) {\n        result[0] = barSplit[0];\n        String[] positions = barSplit[1].split(\"-\");\n        if (positions.length == 2) {\n            result[1] = positions[0];\n            result[2] = positions[1];\n        }\n    } else {\n        result[0] = sequenceName;\n        result[1] = null;\n        result[2] = null;\n    }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * Returns an array with the following sequence related content: name, start, end.\n *\n * @param sequenceName\n *            the sequence from where to extract the content. It is supposed that it follows the following\n *            convention name/start-end (e.g.: COATB_BPIKE/30-81)\n * @return array with the following sequence related content: name, start, end.\n */\n", "repo_name": "biojava-master/", "id": 31, "method_signature": "String[] splitSeqName(String)"}, "843": {"callee_method_names": [], "method_name": "GroupAsa.getBsaToAsaRatio", "method_implementation": "{\n    return getBsa() / asaU;\n}", "repo_id": "9", "comment": "/**\n * Returns the bsa/asa(uncomplexed) ratio, i.e. the ratio of burial of a residue upon complexation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 843, "method_signature": "double getBsaToAsaRatio()"}, "1902": {"callee_method_names": ["QuatSymmetrySubunits.getSubunitCount", "QuatSymmetrySubunits.getFolds", "List<Integer>.size", "List<Double>.add"], "method_name": "RotationSolver.getAngles", "method_implementation": "{\n    int n = subunits.getSubunitCount();\n    // for spherical symmetric cases, n cannot be higher than 60\n    if (n % 60 == 0 && isSpherical()) {\n        n = 60;\n    }\n    List<Integer> folds = subunits.getFolds();\n    List<Double> angles = new ArrayList<Double>(folds.size() - 1);\n    // note this loop starts at 1, we do ignore 1-fold symmetry, which is the first entry\n    for (int fold : folds) {\n        if (fold > 0 && fold <= n) {\n            angles.add(2 * Math.PI / fold);\n        }\n    }\n    return angles;\n}", "repo_id": "9", "comment": "/**\n * Get valid rotation angles given the number of subunits\n * @return The rotation angle corresponding to each fold of {@link Subunits#getFolds()}\n */\n", "repo_name": "biojava-master/", "id": 1902, "method_signature": "List<Double> getAngles()"}, "3703": {"callee_method_names": ["ArrayList<String>.size", "ArrayList<String>.get", "ArrayList<String>.get", "ArrayList<String>.size", "ArrayList<String>.get", "ArrayList<String>.size", "ArrayList<String>.get"], "method_name": "WorkSheet.randomlyDivideSave", "method_implementation": "{\n    ArrayList<String> rows = this.getDataRows();\n    Collections.shuffle(rows);\n    int portion = (int) (rows.size() * percentage);\n    for (int i = 0; i < portion; i++) {\n        this.hideRow(rows.get(i), true);\n    }\n    this.saveTXT(fileName2);\n    for (int i = 0; i < portion; i++) {\n        this.hideRow(rows.get(i), false);\n    }\n    for (int i = portion; i < rows.size(); i++) {\n        this.hideRow(rows.get(i), true);\n    }\n    this.saveTXT(fileName1);\n    for (int i = portion; i < rows.size(); i++) {\n        this.hideRow(rows.get(i), false);\n    }\n}", "repo_id": "9", "comment": "/**\n * Split a worksheet randomly. Used for creating a discovery/validation data\n * set The first file name will matched the percentage and the second file\n * the remainder\n *\n * @param percentage\n * @param fileName1\n * @param fileName2\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3703, "method_signature": "void randomlyDivideSave(double, String, String)"}, "2240": {"callee_method_names": ["Structure.nrModels", "Structure.nrModels", "Structure.getPDBCode", "Structure.getChains", "Structure.getChains", "List<Chain>.size", "List<Chain>.size", "Structure.getPDBCode", "List<Chain>.size", "List<Chain>.get", "List<Chain>.get", "Chain.getId", "Chain.getId", "Chain.getAtomGroups", "Chain.getAtomGroups", "List<Group>.size", "List<Group>.size", "Structure.getPDBCode", "Chain.getId", "List<Group>.size", "List<Group>.size", "List<Group>.size", "List<Group>.get", "List<Group>.get", "Group.getType", "Group.getType", "Structure.getPDBCode", "Group.getPDBName", "Group.getType", "Group.getPDBName", "Group.getType", "Group.getChemComp", "Group.getChemComp", "Group.getChemComp", "Group.getChemComp", "Group.getPDBName", "Group.getChemComp", "Group.getChemComp", "Group.getType", "Group.getType", "Group.getPDBName", "Group.getPDBName", "Group.getResidueNumber", "Group.getResidueNumber", "Group.getResidueNumber", "Group.getResidueNumber", "Group.getResidueNumber", "Group.getResidueNumber", "Group.getAltLocs", "Group.getAltLocs", "Structure.getPDBCode", "Group.getPDBName", "Group.getResidueNumber", "Group.getAltLocs", "Group.getAltLocs", "Group.getAtoms", "Group.getAtoms", "Group.getAltLocs", "List<Atom>.add", "Group.getAltLocs", "List<Atom>.add", "List<Atom>.size", "List<Atom>.size", "Structure.getPDBCode", "Group.getResidueNumber", "Group.getPDBName", "Group.getPDBName", "List<Atom>.size", "List<Atom>.size", "List<Atom>.size", "List<Atom>.get", "List<Atom>.get", "Atom.getGroup", "Atom.getGroup", "Atom.getCharge", "Atom.getCharge", "Atom.getCoords", "Atom.getCoords", "Atom.getTempFactor", "Atom.getTempFactor", "Atom.getOccupancy", "Atom.getOccupancy", "Atom.getElement", "Atom.getElement", "Atom.getName", "Atom.getName", "Atom.getAltLoc", "Atom.getAltLoc", "Atom.getBonds", "Atom.getBonds", "Atom.getBonds", "Atom.getBonds", "Atom.getBonds", "Structure.getPDBCode", "Atom.getBonds", "Atom.getBonds", "Atom.getBonds", "Atom.getBonds"], "method_name": "TestMmtfRoundTrip.checkIfAtomsSame", "method_implementation": "{\n    // Check the same number of models\n    int numModels = structOne.nrModels();\n    if (numModels != structTwo.nrModels()) {\n        System.out.println(\"Error - diff number models: \" + structOne.getPDBCode());\n        return false;\n    }\n    for (int i = 0; i < numModels; i++) {\n        List<Chain> chainsOne = structOne.getChains(i);\n        List<Chain> chainsTwo = structTwo.getChains(i);\n        if (chainsOne.size() != chainsTwo.size()) {\n            System.out.println(\"Error - diff number chains: \" + structOne.getPDBCode());\n            return false;\n        }\n        // Now make sure they're sorted in the right order\n        sortChains(chainsOne, chainsTwo);\n        // Check that each one has the same number of poly, non-poly and water chains\n        checkDiffChains(structOne, structTwo, i);\n        // Now loop over\n        for (int j = 0; j < chainsOne.size(); j++) {\n            Chain chainOne = chainsOne.get(j);\n            Chain chainTwo = chainsTwo.get(j);\n            // Check they have the same chain id\n            assertEquals(chainOne.getId(), chainTwo.getId());\n            checkSeqresGroups(chainOne, chainTwo);\n            List<Group> groupsOne = chainOne.getAtomGroups();\n            List<Group> groupsTwo = chainTwo.getAtomGroups();\n            if (groupsOne.size() != groupsTwo.size()) {\n                System.out.println(\"Error - diff number groups: \" + structOne.getPDBCode());\n                System.out.println(chainOne.getId() + \":\" + groupsOne.size() + \" \" + groupsTwo.size());\n                return false;\n            }\n            for (int k = 0; k < groupsOne.size(); k++) {\n                Group groupOne = groupsOne.get(k);\n                Group groupTwo = groupsTwo.get(k);\n                // Check if the groups are of the same type\n                if (!groupOne.getType().equals(groupTwo.getType())) {\n                    System.out.println(\"Error - diff group type: \" + structOne.getPDBCode());\n                    System.out.println(groupOne.getPDBName() + \" and type: \" + groupOne.getType());\n                    System.out.println(groupTwo.getPDBName() + \" and type: \" + groupTwo.getType());\n                    ;\n                }\n                // Check the single letter amino acid is correct\n                if (groupOne.getChemComp().getOneLetterCode().length() == 1 && groupTwo.getChemComp().getOneLetterCode().length() == 1) {\n                    if (!groupOne.getChemComp().getOneLetterCode().equals(groupTwo.getChemComp().getOneLetterCode())) {\n                        System.out.println(groupOne.getPDBName());\n                    }\n                    assertEquals(groupOne.getChemComp().getOneLetterCode(), groupTwo.getChemComp().getOneLetterCode());\n                }\n                assertEquals(groupOne.getType(), groupTwo.getType());\n                assertEquals(groupOne.getPDBName(), groupTwo.getPDBName());\n                assertEquals(groupOne.getResidueNumber().getSeqNum(), groupTwo.getResidueNumber().getSeqNum());\n                assertEquals(groupOne.getResidueNumber().getInsCode(), groupTwo.getResidueNumber().getInsCode());\n                assertEquals(groupOne.getResidueNumber().getChainName(), groupTwo.getResidueNumber().getChainName());\n                if (groupTwo.getAltLocs().size() != groupOne.getAltLocs().size()) {\n                    System.out.println(\"Error - diff number alt locs: \" + structOne.getPDBCode() + \" \" + groupOne.getPDBName() + \" \" + groupOne.getResidueNumber().getSeqNum());\n                    System.out.println(groupOne.getAltLocs().size());\n                    System.out.println(groupTwo.getAltLocs().size());\n                }\n                // Get the first conf\n                List<Atom> atomsOne = new ArrayList<>(groupOne.getAtoms());\n                List<Atom> atomsTwo = new ArrayList<>(groupTwo.getAtoms());\n                for (Group altLocOne : groupOne.getAltLocs()) {\n                    for (Atom atomAltLocOne : altLocOne.getAtoms()) {\n                        atomsOne.add(atomAltLocOne);\n                    }\n                }\n                for (Group altLocTwo : groupTwo.getAltLocs()) {\n                    for (Atom atomAltLocTwo : altLocTwo.getAtoms()) {\n                        atomsTwo.add(atomAltLocTwo);\n                    }\n                }\n                if (atomsOne.size() != atomsTwo.size()) {\n                    System.out.println(\"Error - diff number atoms: \" + structOne.getPDBCode());\n                    System.out.println(groupOne.getResidueNumber());\n                    System.out.println(groupOne.getPDBName() + \" vs \" + groupTwo.getPDBName());\n                    System.out.println(atomsOne.size() + \" vs \" + atomsTwo.size());\n                    return false;\n                }\n                // Now sort the atoms\n                sortAtoms(atomsOne, atomsTwo);\n                // Now loop through the atoms\n                for (int l = 0; l < atomsOne.size(); l++) {\n                    Atom atomOne = atomsOne.get(l);\n                    Atom atomTwo = atomsTwo.get(l);\n                    assertEquals(atomOne.getGroup().getPDBName(), atomTwo.getGroup().getPDBName());\n                    assertEquals(atomOne.getCharge(), atomTwo.getCharge());\n                    // Check the coords are the same to three db\n                    assertArrayEquals(atomOne.getCoords(), atomTwo.getCoords(), 0.0009999999);\n                    assertEquals(atomOne.getTempFactor(), atomTwo.getTempFactor(), 0.009999999);\n                    assertEquals(atomOne.getOccupancy(), atomTwo.getOccupancy(), 0.009999999);\n                    assertEquals(atomOne.getElement(), atomTwo.getElement());\n                    assertEquals(atomOne.getName(), atomTwo.getName());\n                    assertEquals(atomOne.getAltLoc(), atomTwo.getAltLoc());\n                    if (i == 0) {\n                        if (atomOne.getBonds() == null) {\n                            if (atomTwo.getBonds() != null) {\n                                System.out.println(\"Null bonds in one and not the other\");\n                                return false;\n                            }\n                        } else if (atomTwo.getBonds() == null) {\n                            System.out.println(\"Null bonds in one and not the other\");\n                            return false;\n                        } else if (atomOne.getBonds().size() != atomTwo.getBonds().size()) {\n                            System.out.println(\"Error different number of bonds: \" + structOne.getPDBCode());\n                            System.out.println(atomOne.getBonds().size() + \" vs. \" + atomTwo.getBonds().size());\n                            System.out.println(atomOne);\n                            System.out.println(atomTwo);\n                            for (Bond bond : atomOne.getBonds()) {\n                                System.out.println(bond);\n                            }\n                            for (Bond bond : atomTwo.getBonds()) {\n                                System.out.println(bond);\n                            }\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Broad test of atom similarity\n * @param structOne the first input structure\n * @param structTwo the second input structure\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2240, "method_signature": "boolean checkIfAtomsSame(Structure, Structure)"}, "1194": {"callee_method_ids": [1292, 1291, 1288], "callee_method_names": ["BondMaker.formLinkRecordBond", "BondMaker.formDisulfideBonds", "BondMaker.makeBonds"], "method_name": "PDBFileParser.formBonds", "method_implementation": "{\n    BondMaker maker = new BondMaker(structure, params);\n    // LINK records should be preserved, they are the way that\n    // inter-residue bonds are created for ligands such as trisaccharides, unusual polymers.\n    // The analogy in mmCIF is the _struct_conn record.\n    for (LinkRecord linkRecord : linkRecords) {\n        maker.formLinkRecordBond(linkRecord);\n    }\n    maker.formDisulfideBonds(ssbonds);\n    maker.makeBonds();\n}", "repo_id": "9", "comment": "/**\n * Handles creation of all bonds. Looks at LINK records, SSBOND (Disulfide\n * bonds), peptide bonds, and intra-residue bonds.\n * <p>\n * Note: the current implementation only looks at the first model of each\n * structure. This may need to be fixed in the future.\n */\n", "repo_name": "biojava-master/", "id": 1194, "method_signature": "void formBonds()"}, "1950": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getRmsdCenters", "method_implementation": "{\n    return rmsdCenters;\n}", "repo_id": "9", "comment": "/**\n * @return the rmsdCenters\n */\n", "repo_name": "biojava-master/", "id": 1950, "method_signature": "double getRmsdCenters()"}, "290": {"callee_method_names": [], "method_name": "ProteinModificationIdentifier.getIdentifiedModifiedCompound", "method_implementation": "{\n    if (identifiedModifiedCompounds == null) {\n        throw new IllegalStateException(\"No result available. Please call parse() first.\");\n    }\n    return identifiedModifiedCompounds;\n}", "repo_id": "9", "comment": "/**\n * @return a set of identified {@link ModifiedCompound}s from\n *  the last parse result.\n * @see ModifiedCompound\n */\n", "repo_name": "biojava-master/", "id": 290, "method_signature": "Set<ModifiedCompound> getIdentifiedModifiedCompound()"}, "3230": {"callee_method_names": [], "method_name": "SequenceTestUtils.any3GeneSequence", "method_implementation": "{\n    ChromosomeSequence chr = new ChromosomeSequence(ChromosomeSequenceTest.CHROMOSOME_SEQ);\n    GeneSequence gene = new GeneSequence(chr, new AccessionID(\"some3PrimeGeneId\"), 10, 200, Strand.NEGATIVE);\n    return gene;\n}", "repo_id": "9", "comment": "/**\n * A gene sequence of 190 bp length on MINUS strand\n *\n * @return\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 3230, "method_signature": "GeneSequence any3GeneSequence()"}, "2195": {"callee_method_names": ["Chain.setId", "Chain.setName", "Atom[].setName", "Atom[].setCoords", "Group.setPDBName", "Group.setResidueNumber", "Group.addAtom", "Chain.addGroup"], "method_name": "CeCPMainTest.makeDummyCA", "method_implementation": "{\n    Atom[] ca1;\n    Chain chain1 = new ChainImpl();\n    chain1.setId(\"A\");\n    chain1.setName(\"A\");\n    //Some dummy Atoms. Just check they're unique\n    ca1 = new Atom[len];\n    for (int i = 0; i < len; i++) {\n        ca1[i] = new AtomImpl();\n        ca1[i].setName(\"CA\");\n        ca1[i].setCoords(new double[] { i, 0, 0 });\n        Group aa = new AminoAcidImpl();\n        aa.setPDBName(\"GLY\");\n        aa.setResidueNumber(ResidueNumber.fromString(i + \"\"));\n        aa.addAtom(ca1[i]);\n        chain1.addGroup(aa);\n    }\n    return ca1;\n}", "repo_id": "9", "comment": "/**\n * Makes dummy CA atoms at 1A intervals\n *\n * @param len\n * @return\n * @throws PDBParseException\n */\n", "repo_name": "biojava-master/", "id": 2195, "method_signature": "Atom[] makeDummyCA(int)"}, "1697": {"callee_method_ids": [1689, 1687, 1701], "callee_method_names": ["AtomImpl.setOccupancy", "AtomImpl.setTempFactor", "AtomImpl.setCharge", "AtomImpl.setX", "AtomImpl.setY", "AtomImpl.setZ", "AtomImpl.setPDBserial", "AtomImpl.setName", "AtomImpl.setElement"], "method_name": "AtomImpl.clone", "method_implementation": "{\n    AtomImpl n = new AtomImpl();\n    n.setOccupancy(getOccupancy());\n    n.setTempFactor(getTempFactor());\n    // since char is a primitive we can do this (to avoid going through getter/setter that check for nulls)\n    n.altLoc = altLoc;\n    n.setCharge(getCharge());\n    double[] coords = getCoords();\n    n.setX(coords[0]);\n    n.setY(coords[1]);\n    n.setZ(coords[2]);\n    n.setPDBserial(getPDBserial());\n    n.setName(getName());\n    n.setElement(getElement());\n    // NOTE bonds can't be cloned here, they would need to be cloned at the\n    //      chain or group level (depending if they are intra or inter group bonds) -- JD 2016-03-02\n    return n;\n}", "repo_id": "9", "comment": "/**\n * returns and identical copy of this  object .\n * @return  and identical copy of this  object\n */\n", "repo_name": "biojava-master/", "id": 1697, "method_signature": "Object clone()"}, "1106": {"callee_method_names": ["ChemComp.hasParent", "Map<String, ChemComp>.get", "ChemComp.getMonNstdParentCompId"], "method_name": "ChemicalComponentDictionary.getParent", "method_implementation": "{\n    if (c.hasParent()) {\n        return dictionary.get(c.getMonNstdParentCompId());\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Get the parent of a component. If component has no parent, return null\n * @param c\n * @return get the parent component or null if ChemComp has no parent.\n */\n", "repo_name": "biojava-master/", "id": 1106, "method_signature": "ChemComp getParent(ChemComp)"}, "2653": {"callee_method_names": [], "method_name": "TranscriptionEngine.table", "method_implementation": "{\n    table = IUPACParser.getInstance().getTable(name);\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Uses the static instance of {@link IUPACParser} to find instances of\n * {@link IUPACTable}s by its String name\n */\n", "repo_name": "biojava-master/", "id": 2653, "method_signature": "Builder table(String)"}, "1752": {"callee_method_names": [], "method_name": "MismatchedBasePairParameters.getMaxStagger", "method_implementation": "{\n    return maxStagger;\n}", "repo_id": "9", "comment": "/**\n * This method returns the maximum stagger between bases used as criteria for the characterization of two bases as being paired.\n * @return the maximum propeller (\"propeller-twist\", in degrees) allowed.\n */\n", "repo_name": "biojava-master/", "id": 1752, "method_signature": "double getMaxStagger()"}, "3565": {"callee_method_ids": [3756, 3740, 3740, 3740, 3740, 3672, 3649, 3649, 3563], "callee_method_names": ["CoxR.getClass", "WorkSheet.getRows", "WorkSheet.getCellDouble", "WorkSheet.getCellDouble", "WorkSheet.getCellDouble", "WorkSheet.getCellDouble", "SurvivalInfo.setOrder", "SurvivalInfo.addContinuousVariable", "SurvivalInfo.addContinuousVariable", "ArrayList<SurvivalInfo>.add", "ArrayList<String>.add", "ArrayList<String>.add", "CoxR.process", "MouseEvent.printStackTrace"], "method_name": "CoxR.main", "method_implementation": "{\n    // TODO code application logic here\n    CoxR coxr = new CoxR();\n    if (true) {\n        try {\n            InputStream is = coxr.getClass().getClassLoader().getResourceAsStream(\"uis-complete.txt\");\n            WorkSheet worksheet = WorkSheet.readCSV(is, '\\t');\n            ArrayList<SurvivalInfo> survivalInfoList = new ArrayList<SurvivalInfo>();\n            int i = 0;\n            for (String row : worksheet.getRows()) {\n                double time = worksheet.getCellDouble(row, \"TIME\");\n                double age = worksheet.getCellDouble(row, \"AGE\");\n                double treat = worksheet.getCellDouble(row, \"TREAT\");\n                double c = worksheet.getCellDouble(row, \"CENSOR\");\n                int censor = (int) c;\n                SurvivalInfo si = new SurvivalInfo(time, censor);\n                si.setOrder(i);\n                si.addContinuousVariable(\"AGE\", age);\n                si.addContinuousVariable(\"TREAT\", treat);\n                survivalInfoList.add(si);\n                i++;\n            }\n            CoxR cox = new CoxR();\n            ArrayList<String> variables = new ArrayList<String>();\n            //               variables.add(\"AGE\");\n            variables.add(\"AGE\");\n            variables.add(\"TREAT\");\n            //       variables.add(\"TREAT:AGE\");\n            //  ArrayList<Integer> cluster = new ArrayList<Integer>();\n            CoxInfo ci = cox.process(variables, survivalInfoList, false, true, false, false);\n            System.out.println(ci);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    //        if (false) {\n    //\n    //            try {\n    //\n    //\n    //                WorkSheet worksheet = WorkSheet.readCSV(\"/Users/Scooter/NetBeansProjects/AssayWorkbench/src/edu/scripps/assayworkbench/cox/uis-complete.txt\", '\\t');\n    //                ArrayList<String> rows = worksheet.getRows();\n    //                ArrayList<String> variables = new ArrayList<String>();\n    //                variables.add(\"AGE\");\n    //                variables.add(\"TREAT\");\n    //                double[] time2 = new double[rows.size()];\n    //                int[] status2 = new int[rows.size()];\n    //                double[][] covar2 = new double[variables.size()][rows.size()];\n    //                double[] offset2 = new double[rows.size()];\n    //                double[] weights2 = new double[rows.size()];\n    //                int[] strata2 = new int[rows.size()];\n    //\n    //\n    //                for (int i = 0; i < rows.size(); i++) {\n    //                    String row = rows.get(i);\n    //                    double time = worksheet.getCellDouble(row, \"TIME\");\n    //                    //      double age = worksheet.getCellDouble(row, \"AGE\");\n    //                    //      double treat = worksheet.getCellDouble(row, \"TREAT\");\n    //                    double c = worksheet.getCellDouble(row, \"CENSOR\");\n    //                    int censor = (int) c;\n    //\n    //                    time2[i] = time;\n    //                    status2[i] = censor;\n    //                    offset2[i] = 0;\n    //                    weights2[i] = 1;\n    //                    strata2[i] = 0;\n    //\n    //                    for (int j = 0; j < variables.size(); j++) {\n    //                        String variable = variables.get(j);\n    //                        double v = worksheet.getCellDouble(row, variable);\n    //                        covar2[j][i] = v;\n    //                    }\n    //\n    //\n    //                }\n    //                //from coxph.control.S\n    //                int maxiter2 = 20;\n    //                double eps2 = 1e-9;\n    //                double toler2 = Math.pow(eps2, .75);\n    //                int doscale2 = 1;\n    //                int method2 = 0;\n    //                //toler.chol = eps ^ .75\n    //                //toler.inf=sqrt(eps)\n    //                //outer.max=10\n    //\n    //                CoxR cox = new CoxR();\n    //                //        cox.coxfit6(maxiter2, time2, status2, covar2, offset2, weights2, strata2, method2, eps2, toler2, time2, doscale2);\n    //\n    //\n    //\n    //\n    //\n    //            } catch (Exception e) {\n    //                e.printStackTrace();\n    //            }\n    //        }\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3565, "method_signature": "void main(String[])"}, "2967": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.setCompoundSet", "method_implementation": "{\n    this.compoundSet = compoundSet;\n}", "repo_id": "9", "comment": "/**\n * @param compoundSet\n */\n", "repo_name": "biojava-master/", "id": 2967, "method_signature": "void setCompoundSet(CompoundSet)"}, "3041": {"callee_method_names": [], "method_name": "Tools.completeCircularPasses", "method_implementation": "{\n    int count = 0;\n    while (index > seqLength) {\n        count++;\n        index -= seqLength;\n    }\n    return count - 1;\n}", "repo_id": "9", "comment": "/**\n * Works in a similar way to modulateCircularLocation but returns\n * the number of complete passes over a Sequence length a circular\n * location makes i.e. if we have a sequence of length 10 and the\n * location 3..52 we make 4 complete passes through the genome to\n * go from position 3 to position 52.\n */\n", "repo_name": "biojava-master/", "id": 3041, "method_signature": "int completeCircularPasses(int, int)"}, "740": {"callee_method_names": [], "method_name": "CeCalculatorEnhanced.zByZ", "method_implementation": "{\n    double p1 = zToP(z1);\n    double p2 = zToP(z2);\n    return (pToZ(p1 * p2));\n}", "repo_id": "9", "comment": "///////////////////////////////////////////////////////////////////////////\n", "repo_name": "biojava-master/", "id": 740, "method_signature": "double zByZ(double, double)"}, "3453": {"callee_method_names": ["HashMap.remove"], "method_name": "NCBIQBlastOutputProperties.removeOutputOption", "method_implementation": "{\n    param.remove(key);\n}", "repo_id": "9", "comment": "/**\n * Removes given parameter\n */\n", "repo_name": "biojava-master/", "id": 3453, "method_signature": "void removeOutputOption(BlastOutputParameterEnum)"}, "341": {"callee_method_names": ["ScopDatabase.getByCategory", "List<ScopDescription>.size", "ScopDatabase.getByCategory", "List<ScopDescription>.size"], "method_name": "DemoSCOP.getCategories", "method_implementation": "{\n    // download SCOP if required and load into memory\n    ScopDatabase scop = ScopFactory.getSCOP();\n    List<ScopDescription> superfams = scop.getByCategory(ScopCategory.Superfamily);\n    System.out.println(\"Total nr. of superfamilies:\" + superfams.size());\n    List<ScopDescription> folds = scop.getByCategory(ScopCategory.Fold);\n    System.out.println(\"Total nr. of folds:\" + folds.size());\n}", "repo_id": "9", "comment": "/**\n * Get various categories\n */\n", "repo_name": "biojava-master/", "id": 341, "method_signature": "void getCategories()"}, "2193": {"callee_method_ids": [619], "callee_method_names": ["List<Atom[]>.add", "AtomCache.getAtoms", "MultipleAlignmentEnsemble.setAtomArrays", "MultipleAlignmentEnsemble.getDistanceMatrix", "MultipleAlignmentEnsemble.setStructureIdentifiers", "MultipleAlignmentEnsemble.setAlgorithmName", "MultipleAlignmentEnsemble.setVersion", "MultipleAlignmentEnsemble.setIoTime", "MultipleAlignmentEnsemble.setCalculationTime", "Block.setAlignRes", "Block.setAlignRes", "Block.setAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "MultipleSuperimposer.superimpose", "MultipleAlignment.length", "MultipleAlignment.getCoreLength"], "method_name": "TestSampleGenerator.testAlignment2", "method_implementation": "{\n    //Download the globin structures\n    List<StructureIdentifier> names = Arrays.<StructureIdentifier>asList(new StructureName(\"1mbc\"), new StructureName(\"1hlb\"), new StructureName(\"1thb.A\"), new StructureName(\"1ith.A\"));\n    AtomCache cache = new AtomCache();\n    List<Atom[]> atomArrays = new ArrayList<Atom[]>();\n    for (StructureIdentifier name : names) atomArrays.add(cache.getAtoms(name));\n    MultipleAlignmentEnsemble ensemble = new MultipleAlignmentEnsembleImpl();\n    MultipleAlignment alignment = new MultipleAlignmentImpl(ensemble);\n    //Set the ensemble properties (all filled)\n    ensemble.setAtomArrays(atomArrays);\n    ensemble.getDistanceMatrix();\n    ensemble.setStructureIdentifiers(names);\n    ensemble.setAlgorithmName(\"testAlignment\");\n    ensemble.setVersion(\"2.0\");\n    ensemble.setIoTime((long) 1000000000);\n    ensemble.setCalculationTime((long) 1000000000);\n    //Build the aligned positions: 2 BlockSets, 3 Blocks\n    BlockSet blockSet1 = new BlockSetImpl(alignment);\n    BlockSet blockSet2 = new BlockSetImpl(alignment);\n    Block block1 = new BlockImpl(blockSet1);\n    Block block2 = new BlockImpl(blockSet1);\n    Block block3 = new BlockImpl(blockSet2);\n    block1.setAlignRes(new ArrayList<List<Integer>>());\n    block2.setAlignRes(new ArrayList<List<Integer>>());\n    block3.setAlignRes(new ArrayList<List<Integer>>());\n    List<Integer> aligned11 = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21);\n    List<Integer> aligned12 = Arrays.asList(29, 30, 31, 32, 33, 34, 35, 36, 38);\n    List<Integer> aligned13 = Arrays.asList(123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134);\n    List<Integer> aligned21 = Arrays.asList(10, 11, 12, 13, null, 15, 16, 17, null, 19, 20, 21, 22, 23, 24, 25, null, 27, 28, 29, 30, null);\n    List<Integer> aligned22 = Arrays.asList(39, 40, 41, 42, 43, 44, 45, 46, 48);\n    List<Integer> aligned23 = Arrays.asList(133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144);\n    List<Integer> aligned31 = Arrays.asList(0, 1, 2, 3, null, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21);\n    List<Integer> aligned32 = Arrays.asList(29, 30, 31, 32, 33, 34, 35, 36, 38);\n    List<Integer> aligned33 = Arrays.asList(117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128);\n    List<Integer> aligned41 = Arrays.asList(0, 1, 2, 3, null, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, null, 17, 18, 19, 20, 21);\n    List<Integer> aligned42 = Arrays.asList(30, 31, 32, 33, 34, 35, 36, 37, 39);\n    List<Integer> aligned43 = Arrays.asList(121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132);\n    block1.getAlignRes().add(aligned11);\n    block1.getAlignRes().add(aligned21);\n    block1.getAlignRes().add(aligned31);\n    block1.getAlignRes().add(aligned41);\n    block2.getAlignRes().add(aligned12);\n    block2.getAlignRes().add(aligned22);\n    block2.getAlignRes().add(aligned32);\n    block2.getAlignRes().add(aligned42);\n    block3.getAlignRes().add(aligned13);\n    block3.getAlignRes().add(aligned23);\n    block3.getAlignRes().add(aligned33);\n    block3.getAlignRes().add(aligned43);\n    //Superposition and scores\n    MultipleSuperimposer imposer = new ReferenceSuperimposer();\n    imposer.superimpose(alignment);\n    MultipleAlignmentScorer.calculateScores(alignment);\n    alignment.length();\n    alignment.getCoreLength();\n    return alignment;\n}", "repo_id": "9", "comment": "/**\n * Method that builds a MultipleAlignment of 4 structures with 2 BlockSets,\n * with 2 and 1 Blocks respectively. The alignment contains gaps\n * and non-consecutive residues, ideal to test for all possible cases.\n * The alignment is manually constructed. All ensemble fields are filled,\n * so that no one is null.<p>\n * Atoms of four structures (globins) are downloaded.\n *\n * @return MultipleAlignment the test multiple alignment\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2193, "method_signature": "MultipleAlignment testAlignment2()"}, "1377": {"callee_method_names": [], "method_name": "DBRef.setDatabase", "method_implementation": "{\n    this.database = database;\n}", "repo_id": "9", "comment": "/**\n * Specifies the database value.\n *\n * @param database the database\n * @see #getDatabase()\n */\n", "repo_name": "biojava-master/", "id": 1377, "method_signature": "void setDatabase(String)"}, "2757": {"callee_method_names": [], "method_name": "EmblReference.getReferenceCrossReference", "method_implementation": "{\n    return referenceCrossReference;\n}", "repo_id": "9", "comment": "/**\n * The RX (reference cross-reference) linetype is\n * an optional linetype which appears if\n * one or more contiguous base spans of the\n * presented sequence can be attributed\n * to the reference in question.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2757, "method_signature": "String getReferenceCrossReference()"}, "712": {"callee_method_names": ["CeParameters.getScoringStrategy", "Atom.getGroup", "Group.hasAtom", "Group.getAtom", "Atom.getGroup", "Group.hasAtom", "Group.getAtom", "CeParameters.getScoringStrategy", "CeParameters.getScoringStrategy", "CeParameters.getScoringStrategy", "CeParameters.getScoringStrategy"], "method_name": "CECalculator.getDistanceWithSidechain", "method_implementation": "{\n    if (params.getScoringStrategy() == CeParameters.ScoringStrategy.CA_SCORING) {\n        return Calc.getDistance(ca1, ca2);\n    }\n    double dist;\n    Group g1 = ca1.getGroup();\n    Atom cb1 = null;\n    if (g1.hasAtom(StructureTools.CB_ATOM_NAME)) {\n        cb1 = g1.getAtom(StructureTools.CB_ATOM_NAME);\n    }\n    //\n    Group g2 = ca2.getGroup();\n    Atom cb2 = null;\n    if (g2.hasAtom(StructureTools.CB_ATOM_NAME)) {\n        cb2 = g2.getAtom(StructureTools.CB_ATOM_NAME);\n    }\n    if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SIDE_CHAIN_SCORING) {\n        // here we are using side chain orientation for scoring...\n        // score type 1    consider side chain distances\n        if (cb1 != null && cb2 != null) {\n            // CB distance\n            dist = Calc.getDistance(cb1, cb2);\n            //dist = dist / 2.;\n        } else {\n            dist = Calc.getDistance(ca1, ca2);\n        }\n        return dist;\n    } else if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SIDE_CHAIN_ANGLE_SCORING) {\n        // score type 2 add angle info\n        if (cb1 != null && cb2 != null) {\n            // If the CA were overlaid, what is the distance between the CB?\n            // Recall c^2 = a^2 + b^2 -2ab*cos(theta), so this is a function of angle\n            Atom c1 = Calc.subtract(cb1, ca1);\n            Atom c2 = Calc.subtract(cb2, ca2);\n            Atom newA = Calc.subtract(c2, c1);\n            dist = Calc.amount(newA);\n        } else {\n            //dist += Calc.getDistance(ca1,ca2);\n            dist = 0;\n        }\n        return dist;\n    } else if (params.getScoringStrategy() == CeParameters.ScoringStrategy.CA_AND_SIDE_CHAIN_ANGLE_SCORING) {\n        // score type 3\n        // CA distance + cos(angle)\n        dist = 0;\n        if (cb1 != null && cb2 != null) {\n            Atom cacb1 = Calc.subtract(cb1, ca1);\n            Atom cacb2 = Calc.subtract(cb2, ca2);\n            Atom newA = Calc.subtract(cacb2, cacb1);\n            //System.out.format(\"CACB 1: %s\\nCACB 2: %s\\ndiff: %s\\nd: %f\\n\",cacb1.toString(),cacb2.toString(),newA.toString(),Calc.amount(newA));\n            dist += Calc.amount(newA);\n        }\n        dist += Calc.getDistance(ca1, ca2);\n        return dist;\n    } else if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SEQUENCE_CONSERVATION) {\n        if (cb1 != null && cb2 != null) {\n            // CB distance\n            dist = Calc.getDistance(cb1, cb2);\n            //dist = dist / 2.;\n        } else {\n            dist = Calc.getDistance(ca1, ca2);\n        }\n        return dist;\n    } else {\n        // unsupported scoring scheme\n        return Calc.getDistance(ca1, ca2);\n    }\n}", "repo_id": "9", "comment": "/**\n * Evaluates the distance between two atoms\n * Several scoring functions are implemented and can be changed by calling\n * {@link CeParameters#setScoringStrategy(Integer) setScoringStrategy()}\n * on {@link CeParameters parameter} object this CECalculator was created with.\n * <p>\n * Scoring Strategies:<dl>\n * <dt>DEFAULT_SCORING_STRATEGY</dt>\n * <dd>Strategy of the original CE publication; CA-CA distance</dd>\n *\n * <dt>SIDE_CHAIN_SCORING</dt>\n * <dd>CB-CB distance. This performs better for sheets and helices than CA.</dd>\n *\n * <dt>SIDE_CHAIN_ANGLE_SCORING</dt>\n * <dd>Use the dot product (eg the cosine) of the two CA-CB vectors.</dd>\n *\n * <dt>CA_AND_SIDE_CHAIN_ANGLE_SCORING</dt>\n * <dd>Equivalent to DEFAULT_SCORING_STRATEGY + SIDE_CHAIN_ANGLE_SCORING</dd>\n * </dl>\n *\n *  <dt>SEQUENCE_CONSERVATION</dt>\n * <dd>A mix between the DEFAULT_SCORING_STRATEGY and a scoring function that favors the alignment of sequence conserved positions in the alignment</dd>\n * </dl>\n *\n * @param ca1 The CA of the first residue\n * @param ca2 The CA of the second residue\n * @return The distance between the two fragments, according to the selected\n * scoring strategy. Lower distances are better alignments.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 712, "method_signature": "double getDistanceWithSidechain(Atom, Atom)"}, "338": {"callee_method_ids": [641], "callee_method_names": ["AtomCache.setFiletype"], "method_name": "DemoMMCIFReader.loadSimple", "method_implementation": "{\n    String pdbId = \"4hhb\";\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    StructureIO.setAtomCache(cache);\n    try {\n        Structure s = StructureIO.getStructure(pdbId);\n        System.out.println(pdbId + \" has nr atoms: \" + StructureTools.getNrAtoms(s));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * A basic example how to load an mmCif file and get a Structure object\n */\n", "repo_name": "biojava-master/", "id": 338, "method_signature": "void loadSimple()"}, "3608": {"callee_method_names": [], "method_name": "CoxInfo.setNaiveVariance", "method_implementation": "{\n    //        if (var[0][1] != var[1][0]) {\n    //            throw new Exception(\"Expecting diagonal to be equal\");\n    //        }\n    naive_imat = new double[var.length][var[0].length];\n    for (int i = 0; i < var.length; i++) {\n        for (int j = 0; j < var[0].length; j++) {\n            naive_imat[i][j] = var[i][j];\n        }\n    }\n    calcSummaryValues();\n}", "repo_id": "9", "comment": "/**\n * @param var\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3608, "method_signature": "void setNaiveVariance(double[][])"}, "963": {"callee_method_names": [], "method_name": "BiologicalAssemblyTransformation.toString", "method_implementation": "{\n    return \"BiologicalAssemblyTransformation [id=\" + id + \", chainId=\" + chainId + \", rotation=\" + rotMatrixToString(transformation) + \", translation=\" + translVecToString(transformation) + \"]\";\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#toString()\n\t */\n", "repo_name": "biojava-master/", "id": 963, "method_signature": "String toString()"}, "488": {"callee_method_names": [], "method_name": "AFPChain.getBlockResList", "method_implementation": "{\n    return blockResList;\n}", "repo_id": "9", "comment": "/**\n * tracks the residues of the initial blocks (before optimization)\n *\n * @return list of block residues\n */\n", "repo_name": "biojava-master/", "id": 488, "method_signature": "int[][][] getBlockResList()"}, "2627": {"callee_method_names": ["File.getAbsolutePath", "File.getAbsolutePath", "File.getAbsolutePath"], "method_name": "InputStreamProvider.getInputStreamFromFile", "method_implementation": "{\n    InputStream stream = null;\n    if (cacheRawFiles) {\n        stream = FlatFileCache.getInputStream(f.getAbsolutePath());\n        if (stream == null) {\n            FlatFileCache.addToCache(f.getAbsolutePath(), f);\n            stream = FlatFileCache.getInputStream(f.getAbsolutePath());\n        }\n    }\n    if (stream == null)\n        stream = new FileInputStream(f);\n    return stream;\n}", "repo_id": "9", "comment": "/**\n * Wrapper for new FileInputStream. if System.property biojava.cache.files is set, will try to load files from memory cache.\n *\n * @param f\n * @return\n * @throws FileNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 2627, "method_signature": "InputStream getInputStreamFromFile(File)"}, "1650": {"callee_method_names": [], "method_name": "SubunitClustererParameters.isHighConfidenceScores", "method_implementation": "{\n    if (useGlobalMetrics)\n        return sequenceIdentity >= hcSequenceIdentityGlobal;\n    else\n        return sequenceIdentity >= hcSequenceIdentityLocal && sequenceCoverage >= hcSequenceCoverageLocal;\n}", "repo_id": "9", "comment": "/**\n * Whether the subunits can be considered \"identical\" by sequence alignment.\n * For local sequence alignment (normalized by the number of aligned pairs)\n * this means 0.95 or higher identity and 0.75 or higher coverage.\n * For global sequence alignment (normalised by the alignment length)\n * this means 0.85 or higher sequence identity.\n *\n * @param sequenceIdentity\n * @param sequenceCoverage\n * @return true if the sequence alignment scores are equal to\n * or better than the \"high confidence\" scores, false otherwise.\n */\n", "repo_name": "biojava-master/", "id": 1650, "method_signature": "boolean isHighConfidenceScores(double, double)"}, "125": {"callee_method_names": ["DNASequence.getLength"], "method_name": "TestDNAAlignment.testMixedCaseInputStringsMatchUnderlyingBases", "method_implementation": "{\n    DNASequence target = new DNASequence(\"AAAAAAAAGTC\", DNACompoundSet.getDNACompoundSet());\n    DNASequence query = new DNASequence(\"aaaaaaaagtc\", DNACompoundSet.getDNACompoundSet());\n    SubstitutionMatrix<NucleotideCompound> matrix = SubstitutionMatrixHelper.getNuc4_4();\n    SimpleGapPenalty gapP = new SimpleGapPenalty((short) 5, (short) 2);\n    // should be a full match with +5 per match\n    Assert.assertEquals(5.0 * query.getLength(), Alignments.getPairwiseAligner(query, target, PairwiseSequenceAlignerType.LOCAL, gapP, matrix).getScore(), PRECISION);\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 125, "method_signature": "void testMixedCaseInputStringsMatchUnderlyingBases()"}, "2561": {"callee_method_ids": [2560], "callee_method_names": ["File.length", "InputStream.read", "InputStream.close", "File.getName", "InputStream.close", "SoftHashMap.put", "Logger.error", "int.getMessage"], "method_name": "FlatFileCache.addToCache", "method_implementation": "{\n    //logger.debug(\"storing \" + key + \" on file cache (cache size: \" + cache.size() + \")\");\n    try (InputStream is = new FileInputStream(fileToCache)) {\n        // Get the size of the file\n        long length = fileToCache.length();\n        // You cannot create an array using a long type.\n        // It needs to be an int type.\n        // Before converting to an int type, check\n        // to ensure that file is not larger than Integer.MAX_VALUE.\n        if (length > Integer.MAX_VALUE) {\n            // File is too large\n            throw new IllegalArgumentException(\"File must be <= \" + Integer.MAX_VALUE + \" bytes long\");\n        }\n        // Create the byte array to hold the data\n        byte[] bytes = new byte[(int) length];\n        // Read in the bytes\n        int offset = 0;\n        int numRead = 0;\n        while (offset < bytes.length && (numRead = is.read(bytes, offset, bytes.length - offset)) >= 0) {\n            offset += numRead;\n        }\n        // Ensure all the bytes have been read in\n        if (offset < bytes.length) {\n            is.close();\n            throw new IOException(\"Could not completely read file \" + fileToCache.getName());\n        }\n        // Close the input stream and return bytes\n        is.close();\n        cache.put(key, bytes);\n    } catch (Exception e) {\n        logger.error(\"Error adding to cache! \" + e.getMessage(), e);\n    }\n}", "repo_id": "9", "comment": "/**\n * The file is read and the bytes stored immediately.\n * <p/>\n * Once added, {@code fileToCache} can be modified or deleted and the cached values will not change.\n * @param key\n * @param fileToCache A readable file, of Integer.MAX bytes length or less.\n */\n", "repo_name": "biojava-master/", "id": 2561, "method_signature": "void addToCache(String, File)"}, "619": {"callee_method_names": [], "method_name": "AtomCache.getAtoms", "method_implementation": "{\n    return getAtoms(new StructureName(name));\n}", "repo_id": "9", "comment": "/**\n * Returns the CA atoms for the provided name. See {@link #getStructure(String)} for supported naming conventions.\n * <p>\n * This method only works with protein chains. Use {@link #getRepresentativeAtoms(String)}\n * for a more general solution.\n * @param name\n * @return an array of Atoms.\n * @throws IOException\n * @throws StructureException\n * @see\n */\n", "repo_name": "biojava-master/", "id": 619, "method_signature": "Atom[] getAtoms(String)"}, "322": {"callee_method_names": ["Set<ModifiedCompound>.isEmpty", "List<ResidueNumber>.isEmpty"], "method_name": "ProteinModificationParserTest.testCookBookTestCases", "method_implementation": "{\n    // identify all modificaitons from PDB:1CAD and print them\n    String pdbId = \"1CAD\";\n    Structure struc = TmpAtomCache.cache.getStructure(pdbId);\n    Set<ModifiedCompound> mcs = identifyAllModfications(struc);\n    Assert.assertFalse(mcs.isEmpty());\n    // identify all phosphosites from PDB:3MVJ and print them\n    pdbId = \"3MVJ\";\n    struc = TmpAtomCache.cache.getStructure(pdbId);\n    List<ResidueNumber> psites = identifyPhosphosites(struc);\n    Assert.assertFalse(psites.isEmpty());\n}", "repo_id": "9", "comment": "/**\n * Note: if you change this unit test, also change the cook book:\n * http://www.biojava.org/wiki/BioJava:CookBook3:ProtMod\n */\n", "repo_name": "biojava-master/", "id": 322, "method_signature": "void testCookBookTestCases()"}, "6": {"callee_method_names": [], "method_name": "SimpleGapPenalty.setType", "method_implementation": "{\n    type = (gop == 0) ? GapPenalty.Type.LINEAR : ((gep == 0) ? GapPenalty.Type.CONSTANT : GapPenalty.Type.AFFINE);\n}", "repo_id": "9", "comment": "// helper method to set the type given the open and extension penalties\n", "repo_name": "biojava-master/", "id": 6, "method_signature": "void setType()"}, "3307": {"callee_method_names": [], "method_name": "MultipleAlignmentGUI.actionPerformed", "method_implementation": "{\n    abortCalc();\n    dispose();\n    System.exit(0);\n}", "repo_id": "9", "comment": "// This method is called when the button is pressed\n", "repo_name": "biojava-master/", "id": 3307, "method_signature": "void actionPerformed(ActionEvent)"}, "1054": {"callee_method_names": ["Set<ResidueNumber>.add", "Group.getResidueNumber", "Group.getAtoms", "Set<Group>.addAll"], "method_name": "StructureTools.getGroupsWithinShell", "method_implementation": "{\n    Set<Group> returnList = new LinkedHashSet<>();\n    Set<ResidueNumber> excludeGroups = new HashSet<>();\n    excludeGroups.add(group.getResidueNumber());\n    for (Atom atom : group.getAtoms()) {\n        Set<Group> set = getGroupsWithinShell(structure, atom, excludeGroups, distance, includeWater);\n        returnList.addAll(set);\n    }\n    return returnList;\n}", "repo_id": "9", "comment": "/**\n * <p>\n * Returns a Set of Groups in a structure within the distance specified of a\n * given group.\n * </p>\n * <p>\n * Updated 18-Sep-2015 sroughley to return a Set so only a unique set of\n * Groups returned\n *\n * @param structure\n *            The structure to work with\n * @param group\n *            The 'query' group\n * @param distance\n *            The cutoff distance\n * @param includeWater\n *            Should water residues be included in the output?\n * @return {@link LinkedHashSet} of {@link Group}s within at least one atom\n *         with {@code distance} of at least one atom in {@code group}\n */\n", "repo_name": "biojava-master/", "id": 1054, "method_signature": "Set<Group> getGroupsWithinShell(Structure, Group, double, boolean)"}, "2309": {"callee_method_ids": [1504, 1510], "callee_method_names": ["Matrix4d.set", "Matrix4d.setTranslation", "Matrix4d.set", "Matrix4d.setTranslation", "Random.nextInt", "Random.nextInt", "Random.nextInt", "Random.nextDouble", "Random.nextDouble", "Random.nextDouble", "SuperPositionQCP.getRmsd", "SuperPositionQCP.superposeAfterRmsd", "SuperPositionQCP.superpose", "Logger.info", "Matrix4d.epsilonEquals"], "method_name": "TestSuperPositionQCP.testAlternativeUsageQCP", "method_implementation": "{\n    // Transformation applied to cloud points 1 that needs to be recovered\n    // by the superposition method\n    AxisAngle4d rotAxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n    Vector3d translation = new Vector3d(0.345, 2.453, 5.324);\n    Matrix4d transform = new Matrix4d();\n    transform.set(rotAxis);\n    transform.setTranslation(translation);\n    // Generate a random artificial array of points\n    Random rnd = new Random(0);\n    transform = new Matrix4d();\n    transform.set(rotAxis);\n    transform.setTranslation(translation);\n    Point3d[] c1 = new Point3d[500];\n    Point3d[] c2 = new Point3d[500];\n    for (int p = 0; p < 500; p++) {\n        Point3d a = new Point3d(rnd.nextInt(100), rnd.nextInt(50), rnd.nextInt(150));\n        c1[p] = a;\n        // Add some noise to the second point\n        Point3d b = new Point3d(a.x + rnd.nextDouble(), a.y + rnd.nextDouble(), a.z + rnd.nextDouble());\n        c2[p] = b;\n    }\n    CalcPoint.transform(transform, c1);\n    SuperPositionQCP qcp = new SuperPositionQCP(false);\n    // Step 1 calculate RMSD\n    long start = System.nanoTime() / 1000;\n    qcp.getRmsd(c1, c2);\n    long rmsdTime = (System.nanoTime() / 1000 - start);\n    // Step 2 Obtain the matrix after RMSD\n    Matrix4d trans1 = qcp.superposeAfterRmsd();\n    long trans1time = (System.nanoTime() / 1000 - start) - rmsdTime;\n    // Now obtain the matrix from scratch\n    Matrix4d trans2 = qcp.superpose(c1, c2);\n    long trans2time = (System.nanoTime() / 1000 - start) - trans1time;\n    LOGGER.info(String.format(\"Time for RMSD: %d us, superposition after RMSD: %d us, and superposition from scratch: %d us\", rmsdTime, trans1time, trans2time));\n    // Check the results are the same\n    assertTrue(trans1.epsilonEquals(trans2, 0.05));\n}", "repo_id": "9", "comment": "/**\n * Test case proposed by Peter Rose to check the alternative use of QCP,\n * where first the RMSD is checked before obtaining the transformation\n * matrix, in order to speed up large-scale calculations.\n */\n", "repo_name": "biojava-master/", "id": 2309, "method_signature": "void testAlternativeUsageQCP()"}, "40": {"callee_method_names": ["List<S>.size", "List<S>.size", "List<PairwiseSequenceScorer<S, C>>.add", "List<S>.get", "List<S>.get"], "method_name": "Alignments.getAllPairsScorers", "method_implementation": "{\n    List<PairwiseSequenceScorer<S, C>> allPairs = new ArrayList<PairwiseSequenceScorer<S, C>>();\n    for (int i = 0; i < sequences.size(); i++) {\n        for (int j = i + 1; j < sequences.size(); j++) {\n            allPairs.add(getPairwiseScorer(sequences.get(i), sequences.get(j), type, gapPenalty, subMatrix));\n        }\n    }\n    return allPairs;\n}", "repo_id": "9", "comment": "/**\n * Factory method which sets up a sequence pair scorer for all {@link Sequence} pairs in the given {@link List}.\n *\n * @param <S> each {@link Sequence} of a pair is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n * @param sequences the {@link List} of {@link Sequence}s to align\n * @param type chosen type from list of pairwise sequence scoring routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return list of sequence pair scorers\n */\n", "repo_name": "biojava-master/", "id": 40, "method_signature": "List<PairwiseSequenceScorer<S,C>> getAllPairsScorers(List, PairwiseSequenceScorerType, GapPenalty, SubstitutionMatrix)"}, "302": {"callee_method_ids": [311, 312, 313], "callee_method_names": ["ModificationCondition.getComponents", "Component.getPdbccIds", "Component.isNTerminal", "Component.isCTerminal", "Map<Component, Set<Component>>.get", "Map<Component, Set<Component>>.put", "Set<Component>.add", "Map<Component, Set<Component>>.get", "Group.getPDBName", "Map<Component, Set<Component>>.get", "Map<Component,Set<Group>>.get", "Map<Component,Set<Group>>.put", "Set<Group>.add", "List<Group>.isEmpty", "Map<Component, Set<Component>>.get", "Group.getPDBName", "Map<Component, Set<Component>>.get", "Map<Component,Set<Group>>.get", "Map<Component,Set<Group>>.put", "Set<Group>.add", "List<Group>.size", "List<Group>.get", "Map<Component, Set<Component>>.get", "Map<Component, Set<Component>>.get", "Group.getPDBName", "Map<Component,Set<Group>>.get", "Map<Component,Set<Group>>.put", "Set<Group>.add", "List<Group>.contains", "List<Group>.size", "List<Group>.get", "Map<Component, Set<Component>>.get", "Map<Component, Set<Component>>.get", "Group.getPDBName", "Map<Component,Set<Group>>.get", "Map<Component,Set<Group>>.put", "Set<Group>.add", "List<Group>.contains"], "method_name": "ProteinModificationIdentifier.addModificationGroups", "method_implementation": "{\n    if (residues == null || ligands == null || modifications == null) {\n        throw new IllegalArgumentException(\"Null argument(s).\");\n    }\n    Map<Component, Set<Component>> mapSingleMultiComps = new HashMap<Component, Set<Component>>();\n    for (ProteinModification mod : modifications) {\n        ModificationCondition condition = mod.getCondition();\n        for (Component comp : condition.getComponents()) {\n            for (String pdbccId : comp.getPdbccIds()) {\n                Component single = Component.of(Collections.singleton(pdbccId), comp.isNTerminal(), comp.isCTerminal());\n                Set<Component> mult = mapSingleMultiComps.get(single);\n                if (mult == null) {\n                    mult = new HashSet<Component>();\n                    mapSingleMultiComps.put(single, mult);\n                }\n                mult.add(comp);\n            }\n        }\n    }\n    {\n        // ligands\n        Set<Component> ligandsWildCard = mapSingleMultiComps.get(Component.of(\"*\"));\n        for (Group group : ligands) {\n            String pdbccId = group.getPDBName().trim();\n            Set<Component> comps = mapSingleMultiComps.get(Component.of(pdbccId));\n            for (Component comp : unionComponentSet(ligandsWildCard, comps)) {\n                Set<Group> gs = saveTo.get(comp);\n                if (gs == null) {\n                    gs = new LinkedHashSet<Group>();\n                    saveTo.put(comp, gs);\n                }\n                gs.add(group);\n            }\n        }\n    }\n    {\n        // residues\n        if (residues.isEmpty()) {\n            return;\n        }\n        Set<Component> residuesWildCard = mapSingleMultiComps.get(Component.of(\"*\"));\n        // for all residues\n        for (Group group : residues) {\n            String pdbccId = group.getPDBName().trim();\n            Set<Component> comps = mapSingleMultiComps.get(Component.of(pdbccId));\n            for (Component comp : unionComponentSet(residuesWildCard, comps)) {\n                Set<Group> gs = saveTo.get(comp);\n                if (gs == null) {\n                    gs = new LinkedHashSet<Group>();\n                    saveTo.put(comp, gs);\n                }\n                gs.add(group);\n            }\n        }\n        // for N-terminal\n        int nRes = residues.size();\n        int iRes = 0;\n        Group res;\n        do {\n            // for all ligands on N terminal and the first residue\n            res = residues.get(iRes++);\n            Set<Component> nTermWildCard = mapSingleMultiComps.get(Component.of(\"*\", true, false));\n            Set<Component> comps = mapSingleMultiComps.get(Component.of(res.getPDBName(), true, false));\n            for (Component comp : unionComponentSet(nTermWildCard, comps)) {\n                Set<Group> gs = saveTo.get(comp);\n                if (gs == null) {\n                    gs = new LinkedHashSet<Group>();\n                    saveTo.put(comp, gs);\n                }\n                gs.add(res);\n            }\n        } while (iRes < nRes && ligands.contains(res));\n        // for C-terminal\n        iRes = residues.size() - 1;\n        do {\n            // for all ligands on C terminal and the last residue\n            res = residues.get(iRes--);\n            Set<Component> cTermWildCard = mapSingleMultiComps.get(Component.of(\"*\", false, true));\n            Set<Component> comps = mapSingleMultiComps.get(Component.of(res.getPDBName(), false, true));\n            for (Component comp : unionComponentSet(cTermWildCard, comps)) {\n                Set<Group> gs = saveTo.get(comp);\n                if (gs == null) {\n                    gs = new LinkedHashSet<Group>();\n                    saveTo.put(comp, gs);\n                }\n                gs.add(res);\n            }\n        } while (iRes >= 0 && ligands.contains(res));\n    }\n}", "repo_id": "9", "comment": "/**\n * @param modifications a set of {@link ProteinModification}s.\n * @param residues\n * @param ligands\n * @param saveTo save result to\n * @return map from component to list of corresponding residues\n *  in the chain.\n */\n", "repo_name": "biojava-master/", "id": 302, "method_signature": "void addModificationGroups(Set, List, List, Map)"}, "3878": {"callee_method_names": ["BufferedReader.readLine", "BufferedReader.readLine", "String.split", "Map<String, String>.put", "String[].trim", "String[].trim", "BufferedReader.close", "BufferedReader.readLine", "String.split", "String[].length", "Logger.info", "String[].trim", "Map<String, String>.get", "String.toLowerCase", "String[].trim", "List<String>.add", "Logger.info", "Logger.info", "Logger.info", "BufferedReader.close", "Logger.info", "Logger.info"], "method_name": "GenerateJavaCodesFromTextTest.generateCodes", "method_implementation": "{\n    BufferedReader input = new BufferedReader(new FileReader(\"./src/test/resources/Symbol2Name.txt\"));\n    Map<String, String> symbol2Name = new HashMap<String, String>();\n    //Header line is not required\n    String line = input.readLine();\n    while ((line = input.readLine()) != null) {\n        String[] sA = line.split(\"\\t\");\n        symbol2Name.put(sA[1].trim(), sA[2].trim());\n    }\n    input.close();\n    input = new BufferedReader(new FileReader(\"./src/test/resources/Symbol2Weight.txt\"));\n    List<String> elementNameList = new ArrayList<String>();\n    String elementName = null;\n    String elementNameLower = null;\n    Double elementMass = null;\n    while ((line = input.readLine()) != null) {\n        String[] sA = line.split(\"\\t\");\n        if (sA[0].length() > 0) {\n            //Elements\n            logger.info(\"{}.setIsotopes(iList);\", elementNameLower);\n            //int decimalPlace = getDecimalPlace(elementMass + \"\");\n            //System.out.println(\"assertEquals(\" + elementMass + \", Utils.roundToDecimals(\" + elementNameLower +\n            //\t\".getMass(), \" + decimalPlace + \"));\");\n            String symbol = sA[1].trim();\n            elementName = symbol2Name.get(symbol);\n            elementNameLower = elementName.toLowerCase();\n            int protonNumber = Integer.parseInt(sA[0].trim());\n            elementMass = cleanNumber(sA[5]);\n            if (protonNumber > 82)\n                break;\n            elementNameList.add(elementNameLower);\n            logger.info(\"iList = new ArrayList<Isotope>();\");\n            logger.info(\"Element {} = new Element(\\\"{}\\\", \\\"{}\\\", {}, null, {});\", elementNameLower, elementName, symbol, protonNumber, elementMass);\n        }\n        int neutronNumber = Integer.parseInt(sA[2]);\n        double weight = cleanNumber(sA[3]);\n        //if(sA.length > 4 && sA[4].length() > 0) abundance = cleanNumber(sA[4]);\n        logger.info(\"iList.add(new Isotope(\\\"{}-{}\\\", {}, {}));\", elementName, neutronNumber, neutronNumber, weight);\n    }\n    input.close();\n    logger.info(\"List<Element> eList = new ArrayList<Element>();\");\n    for (String e : elementNameList) logger.info(\"eList.add({});\", e);\n}", "repo_id": "9", "comment": "//@Test\n", "repo_name": "biojava-master/", "id": 3878, "method_signature": "void generateCodes()"}, "2494": {"callee_method_ids": [2637, 2686], "callee_method_names": ["DNASequence.getRNASequence", "RNASequence.getProteinSequence"], "method_name": "ProteinMappingTools.convertDNAtoProteinSequence", "method_implementation": "{\n    RNASequence mRNA = dnaSequence.getRNASequence();\n    return mRNA.getProteinSequence();\n}", "repo_id": "9", "comment": "/**\n * Converts the DNA sequence to protein sequence.\n *\n * @param dnaSequence the DNA sequence\n *\n * @return the protein sequence\n */\n", "repo_name": "biojava-master/", "id": 2494, "method_signature": "ProteinSequence convertDNAtoProteinSequence(DNASequence)"}, "3103": {"callee_method_names": ["List<Number>.subList"], "method_name": "QualityFeature.getQualities", "method_implementation": "{\n    return qualities.subList(biostart - 1, bioend - 1);\n}", "repo_id": "9", "comment": "/**\n * @param biostart biological start index (starts with 1)\n * @param bioend biological end index (starts with 1)\n * @return a sublist of the qualities between the given biological indices\n */\n", "repo_name": "biojava-master/", "id": 3103, "method_signature": "List<Number> getQualities(int, int)"}, "3165": {"callee_method_names": ["File.exists", "File.mkdirs"], "method_name": "GenbankProxySequenceReader.setGenbankDirectoryCache", "method_implementation": "{\n    if (genbankDirectoryCache != null) {\n        File f = new File(genbankDirectoryCache);\n        if (!f.exists()) {\n            f.mkdirs();\n        }\n    }\n    this.genbankDirectoryCache = genbankDirectoryCache;\n}", "repo_id": "9", "comment": "/**\n * @param genbankDirectoryCache\n */\n", "repo_name": "biojava-master/", "id": 3165, "method_signature": "void setGenbankDirectoryCache(String)"}, "177": {"callee_method_ids": [1633, 1623, 1633, 1627], "callee_method_names": ["SubunitClustererParameters.setClustererMethod", "SubunitClustererParameters.setSequenceIdentityThreshold", "List<SubunitCluster>.size", "List<SubunitCluster>.get", "List<SubunitCluster>.get", "List<SubunitCluster>.get", "List<SubunitCluster>.get", "SubunitClustererParameters.setClustererMethod", "SubunitClustererParameters.setRMSDThreshold", "List<SubunitCluster>.size", "List<SubunitCluster>.get", "List<SubunitCluster>.get"], "method_name": "TestSubunitClustererExamples.testPseudostoichiometry", "method_implementation": "{\n    Structure s = StructureIO.getStructure(\"4HHB\");\n    SubunitClustererParameters params = new SubunitClustererParameters();\n    params.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n    params.setSequenceIdentityThreshold(0.95);\n    List<SubunitCluster> clusters = SubunitClusterer.cluster(s, params).getClusters();\n    // We expect two SEQUENCE clusters with length 141 and 146\n    assertEquals(clusters.size(), 2);\n    assertEquals(clusters.get(0).length(), 141);\n    assertEquals(clusters.get(1).length(), 146);\n    assertEquals(clusters.get(0).getClustererMethod(), SubunitClustererMethod.SEQUENCE);\n    assertEquals(clusters.get(1).getClustererMethod(), SubunitClustererMethod.SEQUENCE);\n    params.setClustererMethod(SubunitClustererMethod.SEQUENCE_STRUCTURE);\n    params.setRMSDThreshold(3.0);\n    clusters = SubunitClusterer.cluster(s, params).getClusters();\n    // We expect a single STRUCTURE cluster with length 140\n    assertEquals(clusters.size(), 1);\n    assertEquals(clusters.get(0).length(), 140, 2);\n    assertEquals(clusters.get(0).getClustererMethod(), SubunitClustererMethod.STRUCTURE);\n}", "repo_id": "9", "comment": "/**\n * Test pseudostoichiometry: 4HHB\n */\n", "repo_name": "biojava-master/", "id": 177, "method_signature": "void testPseudostoichiometry()"}, "1824": {"callee_method_names": [], "method_name": "PDBStatus.fromString", "method_implementation": "{\n    if (statusStr == null)\n        throw new IllegalArgumentException(\"Status string can't be null\");\n    if (\"REMOVED\".equalsIgnoreCase(statusStr))\n        return Status.REMOVED;\n    else if (\"CURRENT\".equalsIgnoreCase(statusStr))\n        return Status.CURRENT;\n    else if (\"UNRELEASED\".equalsIgnoreCase(statusStr))\n        return Status.UNRELEASED;\n    else {\n        throw new IllegalArgumentException(\"Unable to parse status '\" + statusStr + \"'.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * @throws IllegalArgumentException If the string is not recognized\n */\n", "repo_name": "biojava-master/", "id": 1824, "method_signature": "Status fromString(String)"}, "18": {"callee_method_names": ["Scanner.hasNextLine", "Scanner.nextLine", "String.trim", "String.startsWith", "String.startsWith", "String.indexOf", "String.substring", "String.substring", "String.startsWith", "String.indexOf", "String.substring", "String.substring", "String.startsWith", "String.indexOf", "String.substring", "String.charAt", "String.indexOf", "String.substring", "String.substring", "String.startsWith", "String.indexOf", "String.substring", "String.charAt", "String.indexOf", "String.substring", "String.substring", "String.startsWith", "String.split", "String.trim", "Logger.error", "StockholmStructure.getSequences", "Map<String, StringBuffer>.keySet", "Map<String, StringBuffer>.get", "StringBuffer.length", "StringBuffer.length"], "method_name": "StockholmFileParser.parse", "method_implementation": "{\n    if (scanner == null) {\n        if (internalScanner != null) {\n            scanner = internalScanner;\n        } else {\n            throw new IllegalArgumentException(\"No Scanner defined\");\n        }\n    }\n    String line = null;\n    int linesCount = 0;\n    try {\n        while (scanner.hasNextLine()) {\n            line = scanner.nextLine();\n            // if the file is empty\n            // this condition will not happen, just left in case we decided to go for buffereedReader again for\n            // performance purpose.\n            if (linesCount == 0 && line == null) {\n                throw new IOException(\"Could not parse Stockholm file, BufferedReader returns null!\");\n            }\n            // ignore empty lines\n            if ((/* status==STATUS_INSIDE_FILE && */\n            line == null) || line.trim().length() == 0) {\n                continue;\n            }\n            if (line.startsWith(\"#=G\")) {\n                // // comment line or metadata\n                // line = line.substring(1).trim();\n                // line = line.substring(1).trim();\n                if (line.startsWith(GENERIC_PER_FILE_ANNOTATION, 2)) {\n                    // #=GF <featurename> <generic per-file annotation, free text>\n                    int firstSpaceIndex = line.indexOf(' ', 5);\n                    String featureName = line.substring(5, firstSpaceIndex);\n                    String value = line.substring(firstSpaceIndex).trim();\n                    handleFileAnnotation(featureName, value);\n                } else if (line.startsWith(GENERIC_PER_CONSENSUS_ANNOTATION, 2)) {\n                    // Being in a consensus means we are no longer in a sequence.\n                    // this.status = STATUS_INSIDE_FILE;\n                    // #=GC <featurename> <generic per-column annotation, exactly 1 char per column>\n                    int firstSpaceIndex = line.indexOf(' ', 5);\n                    String featureName = line.substring(5, firstSpaceIndex);\n                    String value = line.substring(firstSpaceIndex).trim();\n                    handleConsensusAnnotation(featureName, value);\n                } else if (line.startsWith(GENERIC_PER_SEQUENCE_ANNOTATION, 2)) {\n                    // #=GS <seqname> <featurename> <generic per-sequence annotation, free text>\n                    int index1 = line.indexOf(' ', 5);\n                    String seqName = line.substring(5, index1);\n                    while (line.charAt(++index1) <= ' ') // i.e. white space\n                    ;\n                    // keep advancing\n                    int index2 = line.indexOf(' ', index1);\n                    String featureName = line.substring(index1, index2);\n                    String value = line.substring(index2).trim();\n                    handleSequenceAnnotation(seqName, featureName, value);\n                } else if (line.startsWith(GENERIC_PER_RESIDUE_ANNOTATION, 2)) {\n                    // #=GR <seqname> <featurename> <generic per-sequence AND per-column mark-up, exactly 1\n                    // character per column>\n                    int index1 = line.indexOf(' ', 5);\n                    String seqName = line.substring(5, index1);\n                    while (line.charAt(++index1) == ' ') // keep advancing\n                    ;\n                    int index2 = line.indexOf(' ', index1);\n                    String featureName = line.substring(index1, index2);\n                    String value = line.substring(index2).trim();\n                    handleResidueAnnotation(seqName, featureName, value);\n                }\n            } else if (line.startsWith(\"# STOCKHOLM\")) {\n                // it is the header line\n                // if (status == STATUS_OUTSIDE_FILE) {\n                // status = STATUS_INSIDE_FILE;\n                // String[] header = line.split(\"\\\\s+\");\n                // this.stockholmStructure = new StockholmStructure();\n                // this.stockholmStructure.getFileAnnotation().setFormat(header[1]);\n                // this.stockholmStructure.getFileAnnotation().setVersion(header[2]);\n                // } else {\n                // throw new ParserException(\"Uexpected Format line: [\" + line + \"]\");\n                // }\n                String[] header = line.split(\"\\\\s+\");\n                this.stockholmStructure = new StockholmStructure();\n                this.stockholmStructure.getFileAnnotation().setFormat(header[1]);\n                this.stockholmStructure.getFileAnnotation().setVersion(header[2]);\n            } else if (\"//\".equals(line.trim())) {\n                // status = STATUS_OUTSIDE_FILE;\n                // should we just break immediately or jump next empty lines?\n                break;\n            } else /* if (!line.startsWith(\"#\")) */\n            {\n                // most probably This line corresponds to a sequence. Something like:\n                // O83071/192-246 MTCRAQLIAVPRASSLAEAIACAQKMRVSRVPVYERS\n                // N.B. as long as we don't check the status now, it is somehow error prone\n                handleSequenceLine(line);\n                // //============removed status==========================\n                // if (status == STATUS_IN_SEQUENCE) {\n                // // This line corresponds to a sequence. Something like:\n                // // O83071/192-246 MTCRAQLIAVPRASSLAEAIACAQKMRVSRVPVYERS\n                // handleSequenceLine(line);\n                // // }else if (status==STATUS_OUTSIDE_FILE) {\n                // // throw new\n                // //\n                // ParserException(\"The end of file character was allready reached but there are still sequence lines\");\n                // } else {\n                // System.err.println(\"Error: Unknown or unexpected line [\" + line\n                // + \"].\\nPlease contact the Biojava team.\");\n                // throw new ParserException(\"Error: Unknown or unexpected line [\" + line + \"].\");\n                // }\n                // //============removed status==========================\n            }\n            linesCount++;\n        }\n    } catch (IOException e) {\n        // TODO: Best practice is to catch or throw Exception, never both\n        logger.error(\"IOException: \", e);\n        throw new IOException(\"Error parsing Stockholm file\");\n    }\n    StockholmStructure structure = this.stockholmStructure;\n    this.stockholmStructure = null;\n    if (structure != null) {\n        int length = -1;\n        Map<String, StringBuffer> sequences = structure.getSequences();\n        for (String sequencename : sequences.keySet()) {\n            StringBuffer sequence = sequences.get(sequencename);\n            if (length == -1) {\n                length = sequence.length();\n            } else if (length != sequence.length()) {\n                throw new RuntimeException(\"Sequences have different lengths\");\n            }\n        }\n    }\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * Parses a Stockholm file and returns a {@link StockholmStructure} object with its content. This method returns\n * just after reaching the end of structure delimiter line (\"//\"), leaving any remaining empty lines unconsumed.\n *\n * @param scanner\n *            from where to read the file content\n * @return Stockholm file content, <code>null</code> if couldn't or no more structures.\n * @throws IOException\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 18, "method_signature": "StockholmStructure parse(Scanner)"}, "1259": {"callee_method_names": ["Chain.getSeqResGroups"], "method_name": "MmtfUtils.insertSeqResGroup", "method_implementation": "{\n    List<Group> seqResGroups = chain.getSeqResGroups();\n    addGroupAtId(seqResGroups, group, sequenceIndexId);\n}", "repo_id": "9", "comment": "/**\n * Insert the group in the given position in the sequence.\n * @param chain the chain to add the seq res group to\n * @param group the group to add\n * @param sequenceIndexId the index to add it in\n */\n", "repo_name": "biojava-master/", "id": 1259, "method_signature": "void insertSeqResGroup(Chain, Group, int)"}, "420": {"callee_method_ids": [489, 490, 432, 487, 484, 438, 491], "callee_method_names": ["AFPChain.getMinLen", "FatCatParameters.getFragLen", "AFPChain.getOptAln", "AFPChain.getOptLen", "FatCatParameters.getMaxTra", "AFPChain.getOptRmsd", "AFPChain.getBlockNum", "AFPChain.setOptLen", "AFPChain.setOptRmsd", "AFPChain.getAfpSet", "AFPChain.getOptLength", "AFPChain.getAfpChainList", "AFPChain.getBlock2Afp", "AFPChain.getBlockSize", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "StructureAlignmentOptimizer.runOptimization", "StructureAlignmentOptimizer.optimizeResult", "AFPChain.setOptAln", "AFPChain.setOptAln", "AFPChain.setBlockNum", "AFPChain.setOptLength", "AFPChain.setAfpChainList", "AFPChain.setBlock2Afp", "AFPChain.setBlockSize"], "method_name": "AFPOptimizer.optimizeAln", "method_implementation": "{\n    int minLen = afpChain.getMinLen();\n    int fragLen = params.getFragLen();\n    long optStart = System.currentTimeMillis();\n    int i, a, k, p1, p2, bk, b1, b2, e1, e2, a1, a2;\n    int iniLen;\n    int[][] iniSet = new int[2][minLen];\n    int maxi = 100;\n    int[][][] optAln = afpChain.getOptAln();\n    int[] optLen = afpChain.getOptLen();\n    int maxTra = params.getMaxTra();\n    double[] optRmsd = afpChain.getOptRmsd();\n    int blockNum = afpChain.getBlockNum();\n    if (optAln == null) {\n        optAln = new int[maxTra + 1][2][minLen];\n        optLen = new int[maxTra + 1];\n        afpChain.setOptLen(optLen);\n        optRmsd = new double[maxTra + 1];\n        afpChain.setOptRmsd(optRmsd);\n    }\n    List<AFP> afpSet = afpChain.getAfpSet();\n    int optLength = afpChain.getOptLength();\n    int[] afpChainList = afpChain.getAfpChainList();\n    int[] block2Afp = afpChain.getBlock2Afp();\n    int[] blockSize = afpChain.getBlockSize();\n    if (debug)\n        System.out.println(\"AFPOptimizer got blockNum: \" + blockNum);\n    //optimize each alignment defined by a block\n    b1 = b2 = e1 = e2 = optLength = 0;\n    for (bk = 0; bk < blockNum; bk++) {\n        //initial aligned position\n        iniLen = 0;\n        if (bk > 0) {\n            b1 = e1;\n            b2 = e2;\n        }\n        if (bk < blockNum - 1) {\n            //the last AFP in current block\n            a1 = afpChainList[block2Afp[bk] + blockSize[bk] - 1];\n            //the first AFP in next block\n            a2 = afpChainList[block2Afp[bk + 1]];\n            e1 = (afpSet.get(a1).getP1() + fragLen + afpSet.get(a2).getP1()) / 2;\n            e2 = (afpSet.get(a1).getP2() + fragLen + afpSet.get(a2).getP2()) / 2;\n        } else //use the middle point of the current and next AFPs. old (starting point of next AFP)\n        {\n            e1 = ca1.length;\n            e2 = ca2.length;\n        }\n        for (i = block2Afp[bk]; i < block2Afp[bk] + blockSize[bk]; i++) {\n            a = afpChainList[i];\n            p1 = afpSet.get(a).getP1();\n            p2 = afpSet.get(a).getP2();\n            for (k = 0; k < afpSet.get(a).getFragLen(); k++) {\n                //note -b1\n                iniSet[0][iniLen] = p1 + k - b1;\n                //note -b2\n                iniSet[1][iniLen] = p2 + k - b2;\n                iniLen++;\n            }\n        }\n        //optimize the align by dynamic programming & constraint the optimization region\n        if (debug) {\n            System.err.println(String.format(\"optimize block %d (%d afp), region %d-%d(len %d), %d-%d(len %d)\\n\", bk, blockSize[bk], b1, e1, e1 - b1, b2, e2, e2 - b2));\n            System.err.println(\" initial alignment Length: \" + iniLen);\n        }\n        StructureAlignmentOptimizer opt = new StructureAlignmentOptimizer(b1, e1, ca1, b2, e2, ca2, iniLen, iniSet);\n        opt.runOptimization(maxi);\n        optRmsd[bk] = opt.optimizeResult(optLen, bk, optAln[bk]);\n        //System.out.println(optRmsd[bk]);\n        // SALNOPT *opt = new SALNOPT(e1-b1, &pro1->caCod[3 * b1], e2-b2, &pro2->caCod[3 * b2], iniLen, iniSet, maxi);\n        // optRmsd[bk] = opt->OptimizeResult(&optLen[bk], optAln[bk]);\n        if (debug)\n            System.out.println(String.format(\" optimized len=%d, rmsd %f\\n\", optLen[bk], optRmsd[bk]));\n        for (i = 0; i < optLen[bk]; i++) {\n            //restore the position\n            optAln[bk][0][i] += b1;\n            //restore the position\n            optAln[bk][1][i] += b2;\n        }\n        optLength += optLen[bk];\n    }\n    long optEnd = System.currentTimeMillis();\n    if (debug)\n        System.out.println(\"complete AlignOpt \" + (optEnd - optStart) + \"\\n\");\n    if (optLength < minLen) {\n        int[][][] optAln_trim = new int[maxTra + 1][2][optLength];\n        for (i = 0; i < maxTra + 1; i++) {\n            System.arraycopy(optAln[i][0], 0, optAln_trim[i][0], 0, optLength);\n            System.arraycopy(optAln[i][1], 0, optAln_trim[i][1], 0, optLength);\n        }\n        afpChain.setOptAln(optAln_trim);\n    } else {\n        afpChain.setOptAln(optAln);\n    }\n    afpChain.setBlockNum(blockNum);\n    afpChain.setOptLength(optLength);\n    afpChain.setAfpChainList(afpChainList);\n    afpChain.setBlock2Afp(block2Afp);\n    afpChain.setBlockSize(blockSize);\n}", "repo_id": "9", "comment": "/**\n * optimize the alignment by dynamic programming\n */\n", "repo_name": "biojava-master/", "id": 420, "method_signature": "void optimizeAln(FatCatParameters, AFPChain, Atom[], Atom[])"}, "1750": {"callee_method_names": [], "method_name": "TertiaryBasePairParameters.setMaxPropeller", "method_implementation": "{\n    this.maxPropeller = maxPropeller;\n}", "repo_id": "9", "comment": "/**\n * This method sets the maximum propeller allowed for a base pair, prior to analyze() call\n * @param maxPropeller The maximum propeller (\"propeller-twist\", in degrees) allowed to consider two bases paired\n */\n", "repo_name": "biojava-master/", "id": 1750, "method_signature": "void setMaxPropeller(double)"}, "2971": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.getSubSequence", "method_implementation": "{\n    return new SequenceProxyView<C>(ArrayListSequenceReader.this, bioBegin, bioEnd);\n}", "repo_id": "9", "comment": "/**\n * @param bioBegin\n * @param bioEnd\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2971, "method_signature": "SequenceView<C> getSubSequence(Integer, Integer)"}, "243": {"callee_method_names": ["Logger.error"], "method_name": "ProteinModificationRegistry.registerCommonProteinModifications", "method_implementation": "{\n    try {\n        ProteinModificationXmlReader.registerProteinModificationFromXml(inStream);\n    } catch (Exception e) {\n        logger.error(\"Exception: \", e);\n    }\n}", "repo_id": "9", "comment": "/**\n * register common protein modifications from XML file.\n */\n", "repo_name": "biojava-master/", "id": 243, "method_signature": "void registerCommonProteinModifications(InputStream)"}, "1316": {"callee_method_names": [], "method_name": "FileParsingParameters.setParseSecStruc", "method_implementation": "{\n    this.parseSecStruc = parseSecStruc;\n}", "repo_id": "9", "comment": "/**\n * A flag to tell the parser to parse the Author's secondary structure assignment from the file\n * default is set to false, i.e. do NOT parse.\n * @param parseSecStruc if HELIX STRAND and TURN fields are being parsed\n */\n", "repo_name": "biojava-master/", "id": 1316, "method_signature": "void setParseSecStruc(boolean)"}, "277": {"callee_method_names": [], "method_name": "StructureUtil.getStructureAtomLinkage", "method_implementation": "{\n    StructureAtom strucAtom1 = getStructureAtom(atom1, isParentAminoAcid1);\n    StructureAtom strucAtom2 = getStructureAtom(atom2, isParentAminoAcid2);\n    double distance = getAtomDistance(atom1, atom2);\n    return new StructureAtomLinkage(strucAtom1, strucAtom2, distance);\n}", "repo_id": "9", "comment": "/**\n * @param atom1 the first {@link Atom} in structure.\n * @param isParentAminoAcid1 true if the first containing group is an amino acid..\n * @param atom2 the second {@link Atom} in structure.\n * @param isParentAminoAcid2 true if the second containing group is an amino acid..\n * @return the {@link StructureAtomLinkage} of the two atoms.\n */\n", "repo_name": "biojava-master/", "id": 277, "method_signature": "StructureAtomLinkage getStructureAtomLinkage(Atom, boolean, Atom, boolean)"}, "3058": {"callee_method_names": [], "method_name": "AccessionID.getVersion", "method_implementation": "{\n    return version;\n}", "repo_id": "9", "comment": "/**\n * In case if the {@link #getID() } is not unique keeps the id version.\n * @return the version\n */\n", "repo_name": "biojava-master/", "id": 3058, "method_signature": "Integer getVersion()"}, "3868": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getNetCharge"], "method_name": "PeptideProperties.getNetCharge", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getNetCharge(pSequence, useExpasyValues, pHPoint);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the net charge of sequence at pH 7. The sequence argument must be\n * a protein sequence consisting of only non-ambiguous characters.\n * The net charge will be computed using the approach stated in\n * <a href=\"http://www.innovagen.se/custom-peptide-synthesis/peptide-property-calculator/peptide-property-calculator-notes.asp#PI\">here</a>\n *\n * pKa values used will be either\n * those used by Expasy which referenced \"Electrophoresis 1994, 15, 529-539\"\n * OR\n * A.Lehninger, Principles of Biochemistry, 4th Edition (2005), Chapter 3, page78, Table 3-1.\n *\n * @param sequence\n * \t\ta protein sequence consisting of non-ambiguous characters only\n * @param useExpasyValues\n * \t\twhether to use Expasy values (Default) or Innovagen values\n * @param pHPoint\n * \t\tthe pH value to use for computation of the net charge. Default at 7.\n * @return the net charge of sequence at given pHPoint\n */\n", "repo_name": "biojava-master/", "id": 3868, "method_signature": "double getNetCharge(String, boolean, double)"}, "956": {"callee_method_names": [], "method_name": "BiologicalAssemblyTransformation.setChainId", "method_implementation": "{\n    this.chainId = chainId;\n}", "repo_id": "9", "comment": "/**\n * Sets the chain identifier (asym id) that this transformation should be applied to.\n * @param chainId\n */\n", "repo_name": "biojava-master/", "id": 956, "method_signature": "void setChainId(String)"}, "2582": {"callee_method_names": [], "method_name": "SingleLinkageClusterer.link", "method_implementation": "{\n    if (isScoreMatrix) {\n        return Math.max(d1, d2);\n    } else {\n        return Math.min(d1, d2);\n    }\n}", "repo_id": "9", "comment": "/**\n * The linkage function: minimum of the 2 distances (i.e. single linkage clustering)\n * @param d1\n * @param d2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2582, "method_signature": "double link(double, double)"}, "674": {"callee_method_names": ["PrintWriter.close", "StringWriter.toString"], "method_name": "MultipleAlignmentWriter.toXML", "method_implementation": "{\n    StringWriter result = new StringWriter();\n    PrintWriter writer = new PrintWriter(result);\n    PrettyXMLWriter xml = new PrettyXMLWriter(writer);\n    MultipleAlignmentXMLConverter.printXMLensemble(xml, ensemble);\n    writer.close();\n    return result.toString();\n}", "repo_id": "9", "comment": "/**\n * Converts all the information of a multiple alignment ensemble into an XML\n * String format. Cached variables, like transformation matrices and scores,\n * are also converted.\n *\n * @param ensemble\n *            the MultipleAlignmentEnsemble to convert.\n * @return String XML representation of the ensemble\n * @throws IOException\n * @see MultipleAlignmentXMLConverter Helper methods for XML conversion\n */\n", "repo_name": "biojava-master/", "id": 674, "method_signature": "String toXML(MultipleAlignmentEnsemble)"}, "1785": {"callee_method_names": [], "method_name": "PDBHeader.getNrBioAssemblies", "method_implementation": "{\n    return this.bioAssemblies.size();\n}", "repo_id": "9", "comment": "/**\n * Get the number of biological assemblies available in the PDB header\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1785, "method_signature": "int getNrBioAssemblies()"}, "3503": {"callee_method_names": ["HmmerResult.getDomains"], "method_name": "HmmerResult.getOverlapLength", "method_implementation": "{\n    int overlap = 0;\n    for (HmmerDomain d1 : getDomains()) {\n        for (HmmerDomain d2 : other.getDomains()) {\n            overlap += getOverlap(d1, d2);\n        }\n    }\n    return overlap;\n}", "repo_id": "9", "comment": "/**\n * Get the overlap between two HmmerResult objects\n *\n * @param other\n * @return 0 if no overlap, otherwise the length of the overlap\n */\n", "repo_name": "biojava-master/", "id": 3503, "method_signature": "int getOverlapLength(HmmerResult)"}, "1844": {"callee_method_names": ["Structure.getChains", "Class<?>.getName", "Chain.setName", "Class<?>.getName", "Class<?>.getAtomGroups", "Group.getResidueNumber", "String.equals", "Group.getType", "Chain.addGroup", "Chain.addGroup", "Structure.addChain", "Structure.addChain"], "method_name": "Mutator.mutate", "method_implementation": "{\n    // create a  container for the new structure\n    Structure newstruc = new StructureImpl();\n    // first we need to find our corresponding chain\n    // get the chains for model nr. 0\n    // if structure is xray there will be only one \"model\".\n    List<Chain> chains = struc.getChains(0);\n    // iterate over all chains.\n    for (Chain c : chains) {\n        if (c.getName().equals(chainId)) {\n            // here is our chain!\n            Chain newchain = new ChainImpl();\n            newchain.setName(c.getName());\n            List<Group> groups = c.getAtomGroups();\n            // now iterate over all groups in this chain.\n            // in order to find the amino acid that has this pdbRenum.\n            for (Group g : groups) {\n                String rnum = g.getResidueNumber().toString();\n                // we only mutate amino acids\n                // and ignore hetatoms and nucleotides in this case\n                if (rnum.equals(pdbResnum) && (g.getType() == GroupType.AMINOACID)) {\n                    // create the mutated amino acid and add it to our new chain\n                    AminoAcid newgroup = mutateResidue((AminoAcid) g, newType);\n                    newchain.addGroup(newgroup);\n                } else {\n                    // add the group  to the new chain unmodified.\n                    newchain.addGroup(g);\n                }\n            }\n            // add the newly constructed chain to the structure;\n            newstruc.addChain(newchain);\n        } else {\n            // this chain is not requested, add it to the new structure unmodified.\n            newstruc.addChain(c);\n        }\n    }\n    return newstruc;\n}", "repo_id": "9", "comment": "/**\n * creates a new structure which is identical with the original one.\n * only one amino acid will be different.\n *\n * @param struc the structure object that is the container for the residue to be mutated\n * @param chainId the id (name) of the chain to be mutated. @see Chain.getName()\n * @param pdbResnum the PDB residue number of the residue\n * @param newType the new residue type (3 characters)\n * @return a structure object where one residue has been modified\n * @throws PDBParseException\n */\n", "repo_name": "biojava-master/", "id": 1844, "method_signature": "Structure mutate(Structure, String, String, String)"}, "2458": {"callee_method_names": [], "method_name": "Feature.userData", "method_implementation": "{\n    return mUserMap;\n}", "repo_id": "9", "comment": "/**\n *  Get HashMap of user data. Each Feature object has a Java HashMap object\n *  which can be used to annotate the Feature. JavaGene does not use or interpret\n *  the keys or values. The values can be any subtype of the Java Object class.\n * <br><br>\n *  If a Feature is constructed from data fields, the initial HashMap has no mappings (is empty).\n *  If a Feature is constructed from another Feature, a copy of the mappings is made.\n *  Note that the Objects in the copied mapping are shared, even though the mapping itself\n *  is copied (not shared). Thus removing or adding a mapping to one Feature will not affect the\n *  other, but changing an Object which is part of an established mapping may affect both Features.\n *\n *  @return The user HashMap.\n */\n", "repo_name": "biojava-master/", "id": 2458, "method_signature": "HashMap<String,String> userData()"}, "214": {"callee_method_names": ["Matcher.find"], "method_name": "SequenceUtil.isAmbiguosProtein", "method_implementation": "{\n    sequence = SequenceUtil.cleanSequence(sequence);\n    if (SequenceUtil.isNonAmbNucleotideSequence(sequence)) {\n        return false;\n    }\n    if (SequenceUtil.DIGIT.matcher(sequence).find()) {\n        return false;\n    }\n    if (SequenceUtil.NON_AA.matcher(sequence).find()) {\n        return false;\n    }\n    if (SequenceUtil.AA.matcher(sequence).find()) {\n        return false;\n    }\n    final Matcher amb_prot = SequenceUtil.AMBIGUOUS_AA.matcher(sequence);\n    return amb_prot.find();\n}", "repo_id": "9", "comment": "/**\n * Check whether the sequence confirms to amboguous protein sequence\n *\n * @param sequence\n * @return return true only if the sequence if ambiguous protein sequence\n *         Return false otherwise. e.g. if the sequence is non-ambiguous\n *         protein or DNA\n */\n", "repo_name": "biojava-master/", "id": 214, "method_signature": "boolean isAmbiguosProtein(String)"}, "2567": {"callee_method_names": ["File.getName", "String.lastIndexOf", "String.substring"], "method_name": "FileDownloadUtils.getFileExtension", "method_implementation": "{\n    String fileName = f.getName();\n    String ext = \"\";\n    int mid = fileName.lastIndexOf(\".\");\n    ext = fileName.substring(mid + 1);\n    return ext;\n}", "repo_id": "9", "comment": "/**\n * Gets the file extension of a file, excluding '.'.\n * If the file name has no extension the file name is returned.\n * @param f a File\n * @return The extension\n */\n", "repo_name": "biojava-master/", "id": 2567, "method_signature": "String getFileExtension(File)"}, "3468": {"callee_method_ids": [3447, 3447, 3447], "callee_method_names": ["HashMap.get", "BlastJob.getStartTimestamp", "BlastJob.getExpectedExecutionTime", "BlastJob.setId", "BlastJob.setStartTimestamp", "BlastJob.setExpectedExecutionTime", "BlastJob.getId", "URL.openConnection", "URLConnection.getOutputStream", "OutputStreamWriter.write", "OutputStreamWriter.flush", "URLConnection.getInputStream", "BufferedReader.readLine", "String.contains", "HashMap.put", "BlastJob.getId", "String.contains", "BlastJob.setExpectedExecutionTime", "BlastJob.getExpectedExecutionTime", "HashMap.put", "BlastJob.getId", "String.contains"], "method_name": "NCBIQBlastService.isReady", "method_implementation": "{\n    BlastJob job = jobs.get(id);\n    if (job != null) {\n        long expectedJobFinishTime = job.getStartTimestamp() + job.getExpectedExecutionTime();\n        if (System.currentTimeMillis() < expectedJobFinishTime) {\n            return false;\n        }\n    } else {\n        // it might be a valid job from another session\n        job = new BlastJob();\n        job.setId(id);\n        job.setStartTimestamp(System.currentTimeMillis());\n        job.setExpectedExecutionTime(0);\n    }\n    OutputStreamWriter writer = null;\n    BufferedReader reader = null;\n    try {\n        String checkRequest = \"CMD=Get&RID=\" + job.getId() + \"&FORMAT_OBJECT=SearchInfo\";\n        URLConnection serviceConnection = setQBlastServiceProperties(serviceUrl.openConnection());\n        writer = new OutputStreamWriter(serviceConnection.getOutputStream());\n        writer.write(checkRequest);\n        writer.flush();\n        reader = new BufferedReader(new InputStreamReader(serviceConnection.getInputStream()));\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (line.contains(\"READY\")) {\n                jobs.put(job.getId(), job);\n                return true;\n            } else if (line.contains(\"WAITING\")) {\n                job.setExpectedExecutionTime(job.getExpectedExecutionTime() + WAIT_INCREMENT);\n                jobs.put(job.getId(), job);\n                return false;\n            } else if (line.contains(\"UNKNOWN\")) {\n                throw new IllegalArgumentException(\"Unknown request id - no results exist for it. Given id = \" + id);\n            }\n        }\n        return false;\n    } catch (IOException ioe) {\n        throw new Exception(\"It is not possible to fetch Blast report from NCBI at this time. Cause: \" + ioe.getMessage(), ioe);\n    } finally {\n        IOUtils.close(reader);\n        IOUtils.close(writer);\n    }\n}", "repo_id": "9", "comment": "/**\n * Checks for completion of request.\n * <p/>\n * If expected execution time (RTOE) is available for request, this method will always return false until that time\n * passes. This is done to prevent sending unnecessary requests to the server.\n *\n * @param id : request id, which was returned by {@code sendAlignmentRequest} method\n * @param present : is not used, can be any value\n * @return a boolean value telling if the request has been completed\n */\n", "repo_name": "biojava-master/", "id": 3468, "method_signature": "boolean isReady(String, long)"}, "1045": {"callee_method_names": ["String.trim", "Map<String, Character>.containsKey", "Map<String, Character>.containsKey"], "method_name": "StructureTools.isNucleotide", "method_implementation": "{\n    String code = groupCode3.trim();\n    return nucleotides30.containsKey(code) || nucleotides23.containsKey(code);\n}", "repo_id": "9", "comment": "/**\n * Test if the three-letter code of an ATOM entry corresponds to a\n * nucleotide or to an aminoacid.\n *\n * @param groupCode3\n *            3-character code for a group.\n */\n", "repo_name": "biojava-master/", "id": 1045, "method_signature": "boolean isNucleotide(String)"}, "3625": {"callee_method_names": [], "method_name": "CoxInfo.getDegreeFreedom", "method_implementation": "{\n    return degreeFreedom;\n}", "repo_id": "9", "comment": "/**\n * @return the degreeFreedom\n */\n", "repo_name": "biojava-master/", "id": 3625, "method_signature": "double getDegreeFreedom()"}, "461": {"callee_method_names": [], "method_name": "QsAlignParameters.setMaxRmsd", "method_implementation": "{\n    this.maxRmsd = maxRmsd;\n}", "repo_id": "9", "comment": "/**\n * The maximum allowed RMSD of the alignment, in A.\n *\n * @param maxRmsd\n */\n", "repo_name": "biojava-master/", "id": 461, "method_signature": "void setMaxRmsd(double)"}, "3720": {"callee_method_names": ["LinkedHashMap.put"], "method_name": "WorkSheet.markMetaDataColumn", "method_implementation": "{\n    metaDataColumnsHashMap.put(column, column);\n}", "repo_id": "9", "comment": "/**\n * @param column\n */\n", "repo_name": "biojava-master/", "id": 3720, "method_signature": "void markMetaDataColumn(String)"}, "1172": {"callee_method_ids": [1347, 1352, 1346], "callee_method_names": ["String.trim", "Logger.warn", "ArrayList.add", "Logger.debug", "EntityInfo.setMolId", "EntityInfo.setType", "EntityInfo.setDescription", "StringTokenizer.hasMoreTokens", "StringTokenizer.nextToken", "List<String>.add", "HashMap.put", "EntityInfo.getMolId", "StringTokenizer.hasMoreTokens", "List<String>.add", "StringTokenizer.nextToken", "EntityInfo.setSynonyms", "StringTokenizer.hasMoreTokens", "List<String>.add", "StringTokenizer.nextToken", "EntityInfo.setEcNums", "EntityInfo.setFragment", "EntityInfo.setEngineered", "EntityInfo.setMutation", "EntityInfo.setBiologicalUnit", "EntityInfo.setDetails"], "method_name": "PDBFileParser.compndValueSetter", "method_implementation": "{\n    value = value.trim().replace(\";\", \"\");\n    if (\"MOL_ID:\".equals(field)) {\n        int i = -1;\n        try {\n            i = Integer.valueOf(value);\n        } catch (NumberFormatException e) {\n            logger.warn(\"Value '{}' does not look like a number, while trying to parse COMPND MOL_ID line.\", value);\n        }\n        if (i > 0 && prevMolId != i) {\n            if (current_compound != null)\n                entities.add(current_compound);\n            logger.debug(\"Initialising new Compound with mol_id {}\", i);\n            current_compound = new EntityInfo();\n            current_compound.setMolId(i);\n            // we will set polymer for all defined compounds in PDB file (non-polymer compounds are not defined in header) - JD 2016-03-25\n            current_compound.setType(EntityType.POLYMER);\n            prevMolId = i;\n        }\n    }\n    // if for some reason (e.g. missing mol_id line) the current_compound is null we can't add anything to it, return\n    if (current_compound == null) {\n        return;\n    }\n    if (\"MOLECULE:\".equals(field)) {\n        current_compound.setDescription(value);\n    }\n    if (\"CHAIN:\".equals(field)) {\n        //System.out.println(value);\n        StringTokenizer chainTokens = new StringTokenizer(value, \",\");\n        List<String> chains = new ArrayList<String>();\n        while (chainTokens.hasMoreTokens()) {\n            String chainID = chainTokens.nextToken().trim();\n            // NULL is used in old PDB files to represent empty chain DI\n            if (\"NULL\".equals(chainID))\n                chainID = \" \";\n            chains.add(chainID);\n        }\n        compoundMolIds2chainIds.put(current_compound.getMolId(), chains);\n    }\n    if (\"SYNONYM:\".equals(field)) {\n        StringTokenizer synonyms = new StringTokenizer(value, \",\");\n        List<String> names = new ArrayList<String>();\n        while (synonyms.hasMoreTokens()) {\n            names.add(synonyms.nextToken());\n            current_compound.setSynonyms(names);\n        }\n    }\n    if (\"EC:\".equals(field)) {\n        StringTokenizer ecNumTokens = new StringTokenizer(value, \",\");\n        List<String> ecNums = new ArrayList<String>();\n        while (ecNumTokens.hasMoreTokens()) {\n            ecNums.add(ecNumTokens.nextToken());\n            current_compound.setEcNums(ecNums);\n        }\n    }\n    if (\"FRAGMENT:\".equals(field)) {\n        current_compound.setFragment(value);\n    }\n    if (\"ENGINEERED:\".equals(field)) {\n        current_compound.setEngineered(value);\n    }\n    if (\"MUTATION:\".equals(field)) {\n        current_compound.setMutation(value);\n    }\n    if (\"BIOLOGICAL_UNIT:\".equals(field)) {\n        current_compound.setBiologicalUnit(value);\n    }\n    if (\"OTHER_DETAILS:\".equals(field)) {\n        current_compound.setDetails(value);\n    }\n}", "repo_id": "9", "comment": "/**\n * Set the value in the current molId object\n * @param field\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 1172, "method_signature": "void compndValueSetter(String, String)"}, "2963": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.getIndexOf", "method_implementation": "{\n    return this.parsedCompounds.indexOf(compound) + 1;\n}", "repo_id": "9", "comment": "/**\n * @param compound\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2963, "method_signature": "int getIndexOf(C)"}, "268": {"callee_method_names": [], "method_name": "ModificationLinkage.getPDBNameOfPotentialAtomsOnComponent1", "method_implementation": "{\n    return pdbNameOfPotentialAtomsOnComponent1;\n}", "repo_id": "9", "comment": "/**\n * @return a list of PDB names of potential atoms on the first component.\n */\n", "repo_name": "biojava-master/", "id": 268, "method_signature": "List<String> getPDBNameOfPotentialAtomsOnComponent1()"}, "154": {"callee_method_ids": [641], "callee_method_names": ["AtomCache.setFiletype", "List<Structure>.size", "List<Structure>.size", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get"], "method_name": "TestBioassemblies.test1E17", "method_implementation": "{\n    AtomCache prevAtomCache = StructureIO.getAtomCache();\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    StructureIO.setAtomCache(cache);\n    List<Structure> multiModelBioAssemblies = StructureIO.getBiologicalAssemblies(\"1E17\", true);\n    List<Structure> flattenedBioAssemblies = StructureIO.getBiologicalAssemblies(\"1E17\", false);\n    // 1 bioassembly in this case\n    assertEquals(1, multiModelBioAssemblies.size());\n    assertEquals(1, flattenedBioAssemblies.size());\n    // checking that we have 1 model only (the bioassemblies creation wipes out all models)\n    assertEquals(1, multiModelBioAssemblies.get(0).nrModels());\n    assertEquals(1, flattenedBioAssemblies.get(0).nrModels());\n    // the bioassembly is a monomer\n    assertEquals(1, multiModelBioAssemblies.get(0).getPolyChains().size());\n    assertEquals(1, flattenedBioAssemblies.get(0).getPolyChains().size());\n    StructureIO.setAtomCache(prevAtomCache);\n}", "repo_id": "9", "comment": "/**\n * A test for an NMR structure\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 154, "method_signature": "void test1E17()"}, "3290": {"callee_method_names": [], "method_name": "MultipleAlignmentCoordManager.getPreferredHeight", "method_implementation": "{\n    return alignmentSize * DEFAULT_Y_SPACE + (alignmentLength / DEFAULT_LINE_LENGTH) * DEFAULT_Y_STEP + DEFAULT_LINE_SEPARATION;\n}", "repo_id": "9", "comment": "/**\n * Y coordinate size\n *\n * @return the preferred height\n */\n", "repo_name": "biojava-master/", "id": 3290, "method_signature": "int getPreferredHeight()"}, "1579": {"callee_method_names": [], "method_name": "DSSPParser.parseFile", "method_implementation": "{\n    File file = new File(dsspPath);\n    Reader read = new FileReader(file);\n    BufferedReader reader = new BufferedReader(read);\n    return generalParse(reader, structure, assign);\n}", "repo_id": "9", "comment": "/**\n * Parse a DSSP output file and return the secondary structure\n * annotation as a List of {@link SecStrucState} objects.\n *\n * @param dsspPath path to the DSSP file to parse\n * @param structure Structure object associated to the dssp\n * @param assign assigns the SS to the structure if true\n * @return a List of SS annotation objects\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1579, "method_signature": "List<SecStrucState> parseFile(String, Structure, boolean)"}, "2631": {"callee_method_names": [], "method_name": "SequenceOptimizationHints.setSequenceUsage", "method_implementation": "{\n    sequenceUsage = aSequenceUsage;\n}", "repo_id": "9", "comment": "/**\n * @param aSequenceUsage the sequenceUsage to set\n */\n", "repo_name": "biojava-master/", "id": 2631, "method_signature": "void setSequenceUsage(SequenceUsage)"}, "2884": {"callee_method_names": ["Sequence<C>.getLength", "StringBuilder.append", "AminoAcidCompound.toString"], "method_name": "SequenceMixin.toStringBuilder", "method_implementation": "{\n    StringBuilder sb = new StringBuilder(sequence.getLength());\n    for (C compound : sequence) {\n        sb.append(compound.toString());\n    }\n    return sb;\n}", "repo_id": "9", "comment": "/**\n * For the given Sequence this will return a {@link StringBuilder} object\n * filled with the results of {@link Compound#toString()}. Does not\n * used {@link #write(java.lang.Appendable, org.biojava.nbio.core.sequence.template.Sequence) }\n * because of its {@link IOException} signature.\n */\n", "repo_name": "biojava-master/", "id": 2884, "method_signature": "StringBuilder toStringBuilder(Sequence)"}, "3231": {"callee_method_names": ["GeneSequence.setAccession"], "method_name": "SequenceTestUtils.fromSequence", "method_implementation": "{\n    ChromosomeSequence chr = new ChromosomeSequence(chromosomeSequence);\n    GeneSequence gene = new GeneSequence(chr, new AccessionID(\"Gene\"), bioStart, bioEnd, strand);\n    gene.setAccession(new AccessionID(\"Gene1\"));\n    return gene;\n}", "repo_id": "9", "comment": "/**\n * Generate a GeneSequence as a subsequence of defined chromosome sequence.\n *\n * @param chromosomeSequence\n * @param bioStart\n * @param bioEnd\n * @param strand\n * @return\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 3231, "method_signature": "GeneSequence fromSequence(String, int, int, Strand)"}, "545": {"callee_method_names": [], "method_name": "StructurePairAligner.getAlignments", "method_implementation": "{\n    return alts;\n}", "repo_id": "9", "comment": "/**\n * return the alternative alignments that can be found for the two\n * structures\n *\n * @return AlternativeAlignment[] array\n */\n", "repo_name": "biojava-master/", "id": 545, "method_signature": "AlternativeAlignment[] getAlignments()"}, "1290": {"callee_method_names": ["List<Group>.add", "List<Group>.addAll", "Group.getAltLocs", "Group.getAtom", "String.startsWith", "Group.getAtom", "String.replaceFirst", "Atom.getElement", "List<Atom>.add"], "method_name": "BondMaker.getAtoms", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>();\n    List<Group> groupsWithAltLocs = new ArrayList<>();\n    groupsWithAltLocs.add(g);\n    groupsWithAltLocs.addAll(g.getAltLocs());\n    for (Group group : groupsWithAltLocs) {\n        Atom a = group.getAtom(name);\n        // Check for deuteration\n        if (a == null && name.startsWith(\"H\")) {\n            a = group.getAtom(name.replaceFirst(\"H\", \"D\"));\n            // Check it is actually deuterated\n            if (a != null && !a.getElement().equals(Element.D)) {\n                a = null;\n            }\n        }\n        if (a != null)\n            atoms.add(a);\n    }\n    return atoms;\n}", "repo_id": "9", "comment": "/**\n * Get all atoms (including possible alt locs) in given group that are name with the given atom name\n * @param g the group\n * @param name the atom name\n * @return list of all atoms, or empty list if no atoms with the name\n */\n", "repo_name": "biojava-master/", "id": 1290, "method_signature": "List<Atom> getAtoms(Group, String)"}, "734": {"callee_method_names": [], "method_name": "CeCalculatorEnhanced.getRMSDForBestTrace", "method_implementation": "{\n    int is = 0;\n    for (int jt = 0; jt < bestTracesN[ir]; jt++) {\n        for (int i = 0; i < winSize; i++) {\n            setStrBuf(strBuf1, is + i, ca1, bestTraces1[ir][jt] + i);\n            setStrBuf(strBuf2, is + i, ca2, bestTraces2[ir][jt] + i);\n        }\n        is += winSize;\n    }\n    //sup_str(strBuf1, strBuf2, bestTracesN[ir]*winSize, d_);\n    double rmsdNew = calc_rmsd(strBuf1, strBuf2, bestTracesN[ir] * winSize, true, false);\n    return rmsdNew;\n}", "repo_id": "9", "comment": "// TODO:  consider all requested Atoms?\n", "repo_name": "biojava-master/", "id": 734, "method_signature": "double getRMSDForBestTrace(int, Atom[], Atom[], int[], int[][], int[], int, Atom[], Atom[])"}, "1893": {"callee_method_names": [], "method_name": "Stoichiometry.getStrategy", "method_implementation": "{\n    return strategy;\n}", "repo_id": "9", "comment": "/**\n * @return {@link StringOverflowStrategy} used in this stoichiometry\n *          to construct human-readable representation in case number\n *          of clusters exceeds number of letters in the alphabet.\n */\n", "repo_name": "biojava-master/", "id": 1893, "method_signature": "StringOverflowStrategy getStrategy()"}, "2068": {"callee_method_ids": [487, 490, 489], "callee_method_names": ["AFPChain.getOptLength", "AFPChain.getBlockNum", "AFPChain.getOptLen", "List<Integer>.add", "AFPChain.getOptAln", "List<Integer>.get", "List<Integer>.get", "List<Integer>.size"], "method_name": "SequenceFunctionRefiner.partitionAFPchain", "method_implementation": "{\n    int[][][] newAlgn = new int[order][][];\n    int repeatLen = afpChain.getOptLength() / order;\n    //Extract all the residues considered in the first chain of the alignment\n    List<Integer> alignedRes = new ArrayList<Integer>();\n    for (int su = 0; su < afpChain.getBlockNum(); su++) {\n        for (int i = 0; i < afpChain.getOptLen()[su]; i++) {\n            alignedRes.add(afpChain.getOptAln()[su][0][i]);\n        }\n    }\n    //Build the new alignment\n    for (int su = 0; su < order; su++) {\n        newAlgn[su] = new int[2][];\n        newAlgn[su][0] = new int[repeatLen];\n        newAlgn[su][1] = new int[repeatLen];\n        for (int i = 0; i < repeatLen; i++) {\n            newAlgn[su][0][i] = alignedRes.get(repeatLen * su + i);\n            newAlgn[su][1][i] = alignedRes.get((repeatLen * (su + 1) + i) % alignedRes.size());\n        }\n    }\n    return AlignmentTools.replaceOptAln(newAlgn, afpChain, ca1, ca2);\n}", "repo_id": "9", "comment": "/**\n *  Partitions an afpChain alignment into order blocks of aligned residues.\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @param order\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2068, "method_signature": "AFPChain partitionAFPchain(AFPChain, Atom[], Atom[], int)"}, "1427": {"callee_method_names": [], "method_name": "CrystalTransform.isPureTranslation", "method_implementation": "{\n    if (isPureCrystalTranslation())\n        return true;\n    if (isPureMatrixTranslation())\n        return true;\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Tells whether this transformation is a pure translation:\n * either a pure crystal (lattice) translation or a fractional (within\n * unit cell) translation: space groups Ixxx, Cxxx, Fxxx have operators\n * with fractional translations within the unit cell.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1427, "method_signature": "boolean isPureTranslation()"}, "705": {"callee_method_ids": [771], "callee_method_names": ["StartupParameters.isOutputPDB", "AFPChain.getAlgorithmName", "AFPChain.getVersion", "AFPChain.getName1", "AFPChain.getName2", "Structure.toPDB", "StartupParameters.getOutFile", "StartupParameters.getSaveOutputDir", "StartupParameters.getSaveOutputDir", "AFPChain.getName1", "AFPChain.getName2", "StartupParameters.getSaveOutputDir", "StartupParameters.getOutFile", "StartupParameters.getOutFile", "PrintStream.println", "PrintStream.close"], "method_name": "AbstractUserArgumentProcessor.checkWriteFile", "method_implementation": "{\n    String output = null;\n    if (params.isOutputPDB()) {\n        if (!GuiWrapper.isGuiModuleInstalled()) {\n            System.err.println(\"The biojava-structure-gui module is not installed. Please install!\");\n            output = AFPChainXMLConverter.toXML(afpChain, ca1, ca2);\n        } else {\n            Structure tmp = AFPAlignmentDisplay.createArtificalStructure(afpChain, ca1, ca2);\n            output = \"TITLE  \" + afpChain.getAlgorithmName() + \" \" + afpChain.getVersion() + \" \";\n            output += afpChain.getName1() + \" vs. \" + afpChain.getName2();\n            output += newline;\n            output += tmp.toPDB();\n        }\n    } else if (params.getOutFile() != null) {\n        // output by default is XML\n        // write the XML to a file...\n        output = AFPChainXMLConverter.toXML(afpChain, ca1, ca2);\n    } else if (params.getSaveOutputDir() != null) {\n        output = AFPChainXMLConverter.toXML(afpChain, ca1, ca2);\n    }\n    // no output requested.\n    if (output == null)\n        return;\n    String fileName = null;\n    if (dbsearch) {\n        if (params.getSaveOutputDir() != null) {\n            // we currently don't have a naming convention for how to store results for custom files\n            // they will be re-created on the fly\n            if (afpChain.getName1().startsWith(\"file:\") || afpChain.getName2().startsWith(\"file:\"))\n                return;\n            fileName = params.getSaveOutputDir();\n            fileName += getAutoFileName(afpChain);\n        } else {\n            return;\n        }\n        //\n        //else {\n        //\tfileName = getAutoFileName(afpChain);\n        //}\n    } else if (params.getOutFile() != null) {\n        fileName = params.getOutFile();\n    }\n    if (fileName == null) {\n        System.err.println(\"Can't write outputfile. Either provide a filename using -outFile or set -autoOutputFile to true .\");\n        System.exit(1);\n        return;\n    }\n    //System.out.println(\"writing results to \" + fileName + \" \" + params.getSaveOutputDir());\n    // declare a file output object\n    FileOutputStream out;\n    // declare a print stream object\n    PrintStream p;\n    // Create a new file output stream\n    out = new FileOutputStream(fileName);\n    // Connect print stream to the output stream\n    p = new PrintStream(out);\n    p.println(output);\n    p.close();\n}", "repo_id": "9", "comment": "/**\n * check if the result should be written to the local file system\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @throws IOException If an error occurs when writing the afpChain to XML\n * @throws ClassNotFoundException If an error occurs when invoking jmol\n * @throws NoSuchMethodException If an error occurs when invoking jmol\n * @throws InvocationTargetException If an error occurs when invoking jmol\n * @throws IllegalAccessException If an error occurs when invoking jmol\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 705, "method_signature": "void checkWriteFile(AFPChain, Atom[], Atom[], boolean)"}, "2226": {"callee_method_ids": [641], "callee_method_names": ["AtomCache.setFiletype"], "method_name": "TestNonDepositedFiles.test1B8G", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    StructureIO.setAtomCache(cache);\n    cache.setFiletype(StructureFiletype.CIF);\n    Structure s = StructureIO.getStructure(\"1B8G\");\n    System.out.println(\"Chains from full deposited file: \");\n    checkChains(s);\n}", "repo_id": "9", "comment": "//@Test\n", "repo_name": "biojava-master/", "id": 2226, "method_signature": "void test1B8G()"}, "2847": {"callee_method_names": [], "method_name": "PlainFastaHeaderParser.getHeaderValues", "method_implementation": "{\n    return new String[] { header };\n}", "repo_id": "9", "comment": "/**\n * Parse out the all header as one entity\n *\n * @param header\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2847, "method_signature": "String[] getHeaderValues(String)"}, "1285": {"callee_method_names": ["Atom.getBonds", "Atom.getBonds", "int.getOther", "List<Atom>.indexOf", "List<Atom>.indexOf", "List<Atom>.indexOf", "int.getBondOrder", "StructureAdapterInterface.setGroupBond", "List<Atom>.indexOf", "List<Atom>.indexOf", "int.getBondOrder", "StructureAdapterInterface.setInterGroupBond"], "method_name": "MmtfStructureWriter.addBonds", "method_implementation": "{\n    if (atom.getBonds() == null) {\n        return;\n    }\n    for (Bond bond : atom.getBonds()) {\n        // Now set the bonding information.\n        Atom other = bond.getOther(atom);\n        // If both atoms are in the group\n        if (atomsInGroup.indexOf(other) != -1) {\n            Integer firstBondIndex = atomsInGroup.indexOf(atom);\n            Integer secondBondIndex = atomsInGroup.indexOf(other);\n            // Don't add the same bond twice\n            if (firstBondIndex > secondBondIndex) {\n                int bondOrder = bond.getBondOrder();\n                mmtfDecoderInterface.setGroupBond(firstBondIndex, secondBondIndex, bondOrder);\n            }\n        } else // Otherwise it's an inter group bond - so add it here\n        {\n            Integer firstBondIndex = allAtoms.indexOf(atom);\n            Integer secondBondIndex = allAtoms.indexOf(other);\n            if (firstBondIndex > secondBondIndex) {\n                // Don't add the same bond twice\n                int bondOrder = bond.getBondOrder();\n                mmtfDecoderInterface.setInterGroupBond(firstBondIndex, secondBondIndex, bondOrder);\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Add the bonds for a given atom.\n * @param atom the atom for which bonds are to be formed\n * @param atomsInGroup the list of atoms in the group\n * @param allAtoms the list of atoms in the whole structure\n */\n", "repo_name": "biojava-master/", "id": 1285, "method_signature": "void addBonds(Atom, List, List)"}, "2813": {"callee_method_names": ["File.isFile", "File.getName", "String.endsWith"], "method_name": "IOUtils.openFile", "method_implementation": "{\n    final InputStream is;\n    if (!file.isFile()) {\n        throw new ParserException(\"The file \" + file + \" is not a file.\");\n    }\n    String name = file.getName();\n    if (name.endsWith(\".gz\")) {\n        is = new GZIPInputStream(new FileInputStream(file));\n    } else {\n        is = new FileInputStream(file);\n    }\n    return is;\n}", "repo_id": "9", "comment": "/**\n * For a filename this code will check the extension of the file for a\n * .gz extension. If it finds one then the InputStream given back\n * is a {@link GZIPInputStream}. Otherwise we return a normal\n * {@link FileInputStream}.\n *\n * @param file File which may or may not be GZipped\n * @return The final stream\n * @throws IOExceptio n\n */\n", "repo_name": "biojava-master/", "id": 2813, "method_signature": "InputStream openFile(File)"}, "3033": {"callee_method_names": [], "method_name": "Location.completeCircularPasses", "method_implementation": "{\n    int count = 0;\n    while (index > seqLength) {\n        count++;\n        index -= seqLength;\n    }\n    return count - 1;\n}", "repo_id": "9", "comment": "/**\n * Works in a similar way to modulateCircularLocation but returns\n * the number of complete passes over a Sequence length a circular\n * location makes i.e. if we have a sequence of length 10 and the\n * location 3..52 we make 4 complete passes through the genome to\n * go from position 3 to position 52.\n */\n", "repo_name": "biojava-master/", "id": 3033, "method_signature": "int completeCircularPasses(int, int)"}, "1112": {"callee_method_names": ["HashMap.size"], "method_name": "SiftsChainToUniprotMapping.size", "method_implementation": "{\n    return byChainId.size();\n}", "repo_id": "9", "comment": "/**\n * Returns the number of mapped entries.\n */\n", "repo_name": "biojava-master/", "id": 1112, "method_signature": "int size()"}, "3353": {"callee_method_names": ["NavigableMap<Double, Color>.get"], "method_name": "GradientMapper.get", "method_implementation": "{\n    return mapping.get(position);\n}", "repo_id": "9", "comment": "/**\n * @param position\n * @return The color of the endpoint at position, or null if no endpoint exists there\n * @see java.util.Map#get(java.lang.Object)\n */\n", "repo_name": "biojava-master/", "id": 3353, "method_signature": "Color get(Object)"}, "2551": {"callee_method_names": [], "method_name": "Hit.getHitSequence", "method_implementation": "{\n    return hitSequence;\n}", "repo_id": "9", "comment": "/**\n * returns the reference to the original and whole sequence hit in the database.\n * Available only if the ResultFactory implements setHitReferences and\n * it was used before the parsing with SearchIO\n * @return Sequence object\n */\n", "repo_name": "biojava-master/", "id": 2551, "method_signature": "Sequence getHitSequence()"}, "3380": {"callee_method_names": ["AxisAligner.getSymmetry", "String.startsWith", "String.startsWith"], "method_name": "JmolSymmetryScriptGenerator.getInstance", "method_implementation": "{\n    String symmetry = axisAligner.getSymmetry();\n    if (\"C1\".equals(symmetry)) {\n        return new JmolSymmetryScriptGeneratorC1((RotationAxisAligner) axisAligner, name);\n    } else if (symmetry.startsWith(\"C\")) {\n        return new JmolSymmetryScriptGeneratorCn((RotationAxisAligner) axisAligner, name);\n    } else if (symmetry.startsWith(\"D\")) {\n        return new JmolSymmetryScriptGeneratorDn((RotationAxisAligner) axisAligner, name);\n    } else if (\"T\".equals(symmetry)) {\n        return new JmolSymmetryScriptGeneratorT((RotationAxisAligner) axisAligner, name);\n    } else if (\"O\".equals(symmetry)) {\n        return new JmolSymmetryScriptGeneratorO((RotationAxisAligner) axisAligner, name);\n    } else if (\"I\".equals(symmetry)) {\n        return new JmolSymmetryScriptGeneratorI((RotationAxisAligner) axisAligner, name);\n    } else if (\"H\".equals(symmetry)) {\n        return new JmolSymmetryScriptGeneratorH((HelixAxisAligner) axisAligner, name);\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Returns an instance of a JmolSymmetryScriptGenerator, based on the symmetry of a structure (factory method)\n * @param axisAligner\n * @param rotationGroup\n * @return instance of JmolSymmetryScriptGenerator\n */\n", "repo_name": "biojava-master/", "id": 3380, "method_signature": "JmolSymmetryScriptGenerator getInstance(AxisAligner, String)"}, "1551": {"callee_method_names": ["String.split", "String.compareTo", "String.length", "String.charAt"], "method_name": "ScopInstallation.extractRanges", "method_implementation": "{\n    List<String> ranges;\n    String[] rangeSpl = range.split(\",\");\n    // Recent versions of scop always specify a chain, so no processing is needed\n    if (scopVersion.compareTo(\"1.73\") < 0) {\n        for (int i = 0; i < rangeSpl.length; i++) {\n            String subRange = rangeSpl[i];\n            // Allow single-chains, as well as the '-' special case\n            if (subRange.length() < 2) {\n                continue;\n            }\n            // Allow explicit chain syntax\n            if (subRange.charAt(1) != ':') {\n                // Early versions sometimes skip the chain identifier for single-chain domains\n                // Indicate this with a chain \"_\"\n                rangeSpl[i] = \"_:\" + subRange;\n            }\n        }\n    }\n    ranges = Arrays.asList(rangeSpl);\n    return ranges;\n}", "repo_id": "9", "comment": "/**\n * Converts the SCOP range field into a list of subranges suitable for\n * storage in a ScopDomain object. Each range should be of a format\n * compatible with {@link StructureTools#getSubRanges(Structure,String)}.\n * @param range\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1551, "method_signature": "List<String> extractRanges(String)"}, "2909": {"callee_method_names": [], "method_name": "AbstractSequence.setDescription", "method_implementation": "{\n    this.description = description;\n}", "repo_id": "9", "comment": "/**\n * @param description the description to set\n */\n", "repo_name": "biojava-master/", "id": 2909, "method_signature": "void setDescription(String)"}, "3208": {"callee_method_names": ["List<String>.add", "List<String>.add", "BlastTabularParser.getFileExtensions"], "method_name": "BlastTabularParserTest.testGetFileExtensions", "method_implementation": "{\n    System.out.println(\"getFileExtensions\");\n    BlastTabularParser instance = new BlastTabularParser();\n    List<String> expResult = new ArrayList<String>();\n    expResult.add(\"blasttabular\");\n    expResult.add(\"blasttxt\");\n    List<String> result = instance.getFileExtensions();\n    assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of getFileExtensions method, of class BlastTabularParser.\n */\n", "repo_name": "biojava-master/", "id": 3208, "method_signature": "void testGetFileExtensions()"}, "2893": {"callee_method_names": ["List<SequenceView<C>>.add"], "method_name": "SequenceMixin.nonOverlappingKmers", "method_implementation": "{\n    List<SequenceView<C>> l = new ArrayList<SequenceView<C>>();\n    WindowedSequence<C> w = new WindowedSequence<C>(sequence, kmer);\n    for (SequenceView<C> view : w) {\n        l.add(view);\n    }\n    return l;\n}", "repo_id": "9", "comment": "/**\n * Produces kmers of the specified size e.g. ATGTGA returns two views which\n * have ATG TGA\n *\n * @param <C> Compound to use\n * @param sequence Sequence to build from\n * @param kmer Kmer size\n * @return The list of non-overlapping K-mers\n */\n", "repo_name": "biojava-master/", "id": 2893, "method_signature": "List<SequenceView<C>> nonOverlappingKmers(Sequence, int)"}, "151": {"callee_method_names": ["Method.setAccessible", "Method.invoke", "Method.invoke", "Method.invoke", "Method.invoke", "Method.invoke"], "method_name": "OptimalCECPMainTest.testPermuteArray", "method_implementation": "{\n    //test private member using reflection\n    Method permuteArray = OptimalCECPMain.class.getDeclaredMethod(\"permuteArray\", Object[].class, int.class);\n    permuteArray.setAccessible(true);\n    String[] arr0 = new String[] { \"A\", \"B\", \"C\", \"D\", \"E\", \"F\" };\n    String[] arr1 = new String[] { \"B\", \"C\", \"D\", \"E\", \"F\", \"A\" };\n    String[] arr5 = new String[] { \"F\", \"A\", \"B\", \"C\", \"D\", \"E\" };\n    String[] arrP;\n    arrP = Arrays.copyOf(arr0, arr0.length);\n    Assert.assertTrue(\"Shallow equals!\", Arrays.deepEquals(arr0, arrP));\n    permuteArray.invoke(null, arrP, 0);\n    Assert.assertTrue(String.format(\"Permuting by 0 gave %s%s%s%s%s%s\", (Object[]) arrP), Arrays.deepEquals(arr0, arrP));\n    arrP = Arrays.copyOf(arr0, arr0.length);\n    permuteArray.invoke(null, arrP, 1);\n    Assert.assertTrue(String.format(\"Permuting by 1 gave %s%s%s%s%s%s\", (Object[]) arrP), Arrays.deepEquals(arr1, arrP));\n    arrP = Arrays.copyOf(arr0, arr0.length);\n    permuteArray.invoke(null, arrP, 5);\n    Assert.assertTrue(String.format(\"Permuting by 7 gave %s%s%s%s%s%s\", (Object[]) arrP), Arrays.deepEquals(arr5, arrP));\n    arrP = Arrays.copyOf(arr0, arr0.length);\n    permuteArray.invoke(null, arrP, -1);\n    Assert.assertTrue(String.format(\"Permuting by -1 gave %s%s%s%s%s%s\", (Object[]) arrP), Arrays.deepEquals(arr5, arrP));\n    try {\n        arrP = Arrays.copyOf(arr0, arr0.length);\n        permuteArray.invoke(null, arrP, 6);\n        Assert.fail(\"Illegal index. Should throw exception.\");\n    } catch (InvocationTargetException e) {\n        if (!(e.getCause() instanceof ArrayIndexOutOfBoundsException)) {\n            throw e;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Tests private {@link OptimalCECPMain#permuteArray(Object[], int)}\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 151, "method_signature": "void testPermuteArray()"}, "2236": {"callee_method_ids": [1190], "callee_method_names": ["PDBFileParser.setFileParsingParameters", "PDBFileParser.parsePDBFile", "Structure.getNonPolyChainsByPDB", "Chain.getAtomGroups", "Structure.getNonPolyChainsByPDB", "Chain.getAtomGroups", "Structure.getChains", "Structure.getChains"], "method_name": "CifFileConsumerImplTest.testNewLigandChain", "method_implementation": "{\n    // Test the file parsing speed when the files are already downloaded.\n    InputStream pdbStream = new GZIPInputStream(getClass().getResourceAsStream(\"/ligandTest.pdb.gz\"));\n    InputStream cifStream = new GZIPInputStream(getClass().getResourceAsStream(\"/ligandTest.cif.gz\"));\n    assertNotNull(cifStream);\n    assertNotNull(pdbStream);\n    FileParsingParameters params = new FileParsingParameters();\n    PDBFileParser pdbpars = new PDBFileParser();\n    pdbpars.setFileParsingParameters(params);\n    Structure s1 = pdbpars.parsePDBFile(pdbStream);\n    // The chain B should be present with 1 ligand HEM\n    Chain c1 = s1.getNonPolyChainsByPDB(\"B\").get(0);\n    assertNotNull(c1);\n    int expectedNumLigands = 1;\n    assertEquals(expectedNumLigands, c1.getAtomGroups().size());\n    Structure s2 = new CifFileReader().getStructure(cifStream);\n    // The chain B should be present with 1 ligand HEM\n    Chain c2 = s2.getNonPolyChainsByPDB(\"B\").get(0);\n    assertNotNull(c2);\n    assertEquals(expectedNumLigands, c2.getAtomGroups().size());\n    // pdb and mmcif should have same number of chains\n    assertEquals(s1.getChains().size(), s2.getChains().size());\n}", "repo_id": "9", "comment": "/**\n * This test represents a common situation for a non-deposited structure.\n * When building with common crystallography software, the user often adds new\n * ligands (or solvent) molecules as new chains.  Only prior to deposition\n * then relabel them so that they belong to the same chain as the polymeric residues.\n *\n * In this case, the ligands represent valuable information and should not be discarded.\n */\n", "repo_name": "biojava-master/", "id": 2236, "method_signature": "void testNewLigandChain()"}, "2641": {"callee_method_names": [], "method_name": "DNASequence.getReverseComplement", "method_implementation": "{\n    return getInverse();\n}", "repo_id": "9", "comment": "/**\n * Delegates to {@link #getInverse() } for the reverse complement\n */\n", "repo_name": "biojava-master/", "id": 2641, "method_signature": "SequenceView<NucleotideCompound> getReverseComplement()"}, "253": {"callee_method_names": ["Map<String, Set<ProteinModification>>.get"], "method_name": "ProteinModificationRegistry.getByKeyword", "method_implementation": "{\n    lazyInit();\n    return byKeyword.get(keyword);\n}", "repo_id": "9", "comment": "/**\n * @param keyword a keyword.\n * @return a set of ProteinModifications that have the keyword.\n */\n", "repo_name": "biojava-master/", "id": 253, "method_signature": "Set<ProteinModification> getByKeyword(String)"}, "2270": {"callee_method_ids": [641], "callee_method_names": ["AtomCache.setFileParsingParams", "AtomCache.setFiletype", "Structure.getChain"], "method_name": "TestMmtfStructureReader.checkNonStandardAminoSeqresGroupsPopulated", "method_implementation": "{\n    // 2X3T, see issue https://github.com/biojava/biojava/issues/792\n    // Load a structure in mmtf format\n    AtomCache cache = new AtomCache();\n    FileParsingParameters params = new FileParsingParameters();\n    cache.setFileParsingParams(params);\n    cache.setFiletype(StructureFiletype.MMTF);\n    StructureIO.setAtomCache(cache);\n    ChemCompGroupFactory.setChemCompProvider(new DownloadChemCompProvider());\n    Structure structure1 = StructureIO.getStructure(\"2X3T\");\n    // chain E is a glycopeptide with unobserved non-standard aminoacids. Because of mmtf limitations (representing seqres sequences as 1-letter strings) the non-standard unobserved residues are read as null\n    List<Group> seqresGroups = structure1.getChain(\"E\").getSeqResGroups();\n    for (Group g : seqresGroups) {\n        assertNotNull(\"SeqRes group should not be null\", g);\n    }\n}", "repo_id": "9", "comment": "/**\n * Test for issue https://github.com/biojava/biojava/issues/792\n */\n", "repo_name": "biojava-master/", "id": 2270, "method_signature": "void checkNonStandardAminoSeqresGroupsPopulated()"}, "1429": {"callee_method_names": [], "method_name": "CrystalTransform.isFractionalTranslation", "method_implementation": "{\n    if ((Math.abs(matTransform.m03 - crystalTranslation.x) > SpaceGroup.DELTA) || (Math.abs(matTransform.m13 - crystalTranslation.y) > SpaceGroup.DELTA) || (Math.abs(matTransform.m23 - crystalTranslation.z) > SpaceGroup.DELTA)) {\n        return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Tells whether this transformation contains a fractional translational\n * component (whatever its rotational component). A fractional translation\n * together with a rotation means a screw axis.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1429, "method_signature": "boolean isFractionalTranslation()"}, "639": {"callee_method_names": [], "method_name": "AtomCache.setPath", "method_implementation": "{\n    this.path = FileDownloadUtils.expandUserHome(path);\n}", "repo_id": "9", "comment": "/**\n * Set the path that is used to cache PDB files.\n *\n * @param path\n *            to a directory\n */\n", "repo_name": "biojava-master/", "id": 639, "method_signature": "void setPath(String)"}, "729": {"callee_method_ids": [759, 746], "callee_method_names": ["AFPChain.setCa1Length", "AFPChain.setCa2Length", "CeParameters.getScoringStrategy", "CeParameters.getSeqWeight", "CeParameters.setSeqWeight", "CeParameters.getWinSize"], "method_name": "CeCalculatorEnhanced.extractFragments", "method_implementation": "{\n    int nse1 = ca1.length;\n    int nse2 = ca2.length;\n    afpChain.setCa1Length(nse1);\n    afpChain.setCa2Length(nse2);\n    int traceMaxSize = nse1 < nse2 ? nse1 : nse2;\n    f1 = new int[nse1];\n    f2 = new int[nse2];\n    dist1 = initIntraDistmatrix(ca1, nse1);\n    dist2 = initIntraDistmatrix(ca2, nse2);\n    if (debug)\n        System.out.println(\"parameters: \" + params);\n    if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SEQUENCE_CONSERVATION) {\n        if (params.getSeqWeight() < 1)\n            params.setSeqWeight(2);\n    }\n    int winSize = params.getWinSize();\n    int winSizeComb1 = (winSize - 1) * (winSize - 2) / 2;\n    traceIndexContainer = new int[traceMaxSize];\n    // CE: unused code. distAll is always false and both loops do the same???\n    // CE v2.3 calls this Weight factors for trace extension\n    if (distAll) {\n        for (int i = 0; i < traceMaxSize; i++) traceIndexContainer[i] = (i + 1) * i * winSize * winSize / 2 + (i + 1) * winSizeComb1;\n    } else {\n        for (int i = 0; i < traceMaxSize; i++) {\n            traceIndexContainer[i] = (i + 1) * i * winSize / 2 + (i + 1) * winSizeComb1;\n        }\n    }\n    // verified: a[] is set correctly.\n    mat = initSumOfDistances(nse1, nse2, winSize, winSizeComb1, ca1, ca2);\n    //\t\ttry {\n    //\t\t\tMatrix m2 = new Matrix(mat).copy();\n    //\t\t\tJPanel panel = GuiWrapper.getScaleableMatrixPanel(m2);\n    //\t\t\tJFrame frame = new JFrame();\n    //\t\t\tframe.addWindowListener(new WindowAdapter(){\n    //\t\t\t\tpublic void windowClosing(WindowEvent e){\n    //\t\t\t\t\tJFrame f = (JFrame) e.getSource();\n    //\t\t\t\t\tf.setVisible(false);\n    //\t\t\t\t\tf.dispose();\n    //\t\t\t\t}\n    //\t\t\t});\n    //\n    //\n    //\t\t\tframe.getContentPane().add(panel);\n    //\n    //\t\t\tframe.pack();\n    //\t\t\tframe.setVisible(true);\n    //\t\t} catch (Exception e) {\n    //\t\t\te.printStackTrace();\n    //\t\t}\n    // Set the distance matrix\n    //afpChain.setDistanceMatrix(new Matrix(mat.clone()));\n    //\n    //\t\t\t   double rmsdThr = params.getRmsdThr();\n    //\t\t\t   StringBuffer buf = new StringBuffer(\"  \");\n    //\t\t\t   for(int i=0; i<nse2; i++)\n    //\t\t\t      buf.append(String.format(\"%c\", i%10==0?(i%100)/10+48:32));\n    //\t\t\t   buf.append(\"\\n\");\n    //\t\t\t   for(int i=0; i<nse1; i++) {\n    //\t\t\t      buf.append(String.format(\"%c \", i%10==0?(i%100)/10+48:32));\n    //\t\t\t      for(int j=0; j<nse2; j++)\n    //\t\t\t         buf.append(String.format(\"%c\", (mat[i][j])<rmsdThr?'+':'X'));\n    //\t\t\t      //printf(\"%c\", ((int)*(mat[i]+j)/40)>9?'*':((int)*(mat[i]+j)/40)+48);\n    //\t\t\t      buf.append(\"\\n\");\n    //\t\t\t   }\n    //\t\t\t   buf.append(\"\\n\");\n    //\n    //\t\t\t   System.out.println(buf.toString());\n    //\n    return afpChain;\n}", "repo_id": "9", "comment": "/**\n * @param afpChain A new AFPChain, which will be filled in by this function\n * @param ca1\n * @param ca2\n * @return afpChain\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 729, "method_signature": "AFPChain extractFragments(AFPChain, Atom[], Atom[])"}, "76": {"callee_method_names": [], "method_name": "GuanUberbacher.getCutsPerSection", "method_implementation": "{\n    return cutsPerSection;\n}", "repo_id": "9", "comment": "/**\n * Returns the number of cuts added to each section during each pass.\n *\n * @return the number of cuts added to each section during each pass\n */\n", "repo_name": "biojava-master/", "id": 76, "method_signature": "int getCutsPerSection()"}, "2169": {"callee_method_ids": [995], "callee_method_names": ["HetatomImpl.setResidueNumber", "HetatomImpl.getResidueNumber"], "method_name": "HetatomImplTest.testSetGetResidueNumber", "method_implementation": "{\n    //        System.out.println(\"setGetResidueNumber\");\n    ResidueNumber residueNumber = new ResidueNumber(\"A\", 42, ' ');\n    HetatomImpl instance = new HetatomImpl();\n    instance.setResidueNumber(residueNumber);\n    ResidueNumber expResult = residueNumber;\n    ResidueNumber result = instance.getResidueNumber();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of getSeqNum method, of class HetatomImpl.\n */\n", "repo_name": "biojava-master/", "id": 2169, "method_signature": "void testSetGetResidueNumber()"}, "3068": {"callee_method_names": ["ArrayList.remove", "LinkedHashMap.remove"], "method_name": "GeneSequence.removeIntron", "method_implementation": "{\n    for (IntronSequence intronSequence : intronSequenceList) {\n        if (intronSequence.getAccession().getID().equals(accession)) {\n            intronSequenceList.remove(intronSequence);\n            intronSequenceHashMap.remove(accession);\n            return intronSequence;\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Remove the intron by accession\n * @param accession\n * @return the removed intron sequence, or null if no intron with that accession exists.\n */\n", "repo_name": "biojava-master/", "id": 3068, "method_signature": "IntronSequence removeIntron(String)"}, "131": {"callee_method_names": ["GuanUberbacher<DNASequence, NucleotideCompound>.setCutsPerSection", "GuanUberbacher<DNASequence, NucleotideCompound>.getPair"], "method_name": "GuanUberbacherTest.should_align_multiple_cuts", "method_implementation": "{\n    DNASequence query = new DNASequence(\"AAT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"AATG\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    GuanUberbacher<DNASequence, NucleotideCompound> aligner = new GuanUberbacher<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 0, (short) 2), SubstitutionMatrixHelper.getNuc4_4());\n    // 3 bases with 2 cuts\n    aligner.setCutsPerSection(2);\n    assertEquals(String.format(\"AAT-%nAATG%n\"), aligner.getPair().toString());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 131, "method_signature": "void should_align_multiple_cuts()"}, "263": {"callee_method_names": ["Map<String, Set<ProteinModification>>.keySet"], "method_name": "ProteinModificationRegistry.allKeywords", "method_implementation": "{\n    lazyInit();\n    Set<String> ret = byKeyword.keySet();\n    return Collections.unmodifiableSet(ret);\n}", "repo_id": "9", "comment": "/**\n * @return set of keywords of all registered ProteinModifications.\n */\n", "repo_name": "biojava-master/", "id": 263, "method_signature": "Set<String> allKeywords()"}, "3447": {"callee_method_names": [], "method_name": "BlastJob.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * Request id (RID) as received from QBlast server\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3447, "method_signature": "String getId()"}, "962": {"callee_method_names": ["Matrix4d.epsilonEquals"], "method_name": "BiologicalAssemblyTransformation.isIdentity", "method_implementation": "{\n    return transformation.epsilonEquals(new Matrix4d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), 0.00000000001);\n}", "repo_id": "9", "comment": "/**\n * Tells whether this transformation is in identity.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 962, "method_signature": "boolean isIdentity()"}, "572": {"callee_method_names": [], "method_name": "RotationAxis.getProjectedDistance", "method_implementation": "{\n    Atom projected = getProjectedPoint(point);\n    if (projected == null) {\n        // translation only\n        return Double.NaN;\n    }\n    return Calc.getDistance(point, projected);\n}", "repo_id": "9", "comment": "/**\n * Get the distance from a point to the axis of rotation\n * @param point\n * @return The distance to the axis, or NaN if the RotationAxis is purely translational\n */\n", "repo_name": "biojava-master/", "id": 572, "method_signature": "double getProjectedDistance(Atom)"}, "2976": {"callee_method_names": ["List<C>.add", "CompoundSet<C>.getCompoundForString", "List<C>.add", "CompoundSet<C>.getCompoundForString", "List<C>.add", "CompoundSet<C>.getCompoundForString", "List<C>.add", "CompoundSet<C>.getCompoundForString"], "method_name": "TwoBitSequenceReader.generateIndexToCompounds", "method_implementation": "{\n    CompoundSet<C> cs = getCompoundSet();\n    List<C> result = new ArrayList<C>();\n    result.add(cs.getCompoundForString(\"T\"));\n    result.add(cs.getCompoundForString(\"C\"));\n    result.add(cs.getCompoundForString(\"A\"));\n    result.add(cs.getCompoundForString(\"G\"));\n    return result;\n}", "repo_id": "9", "comment": "/**\n * Returns a List which encodes TCAG into positions 0,1,2,3.\n */\n", "repo_name": "biojava-master/", "id": 2976, "method_signature": "List<C> generateIndexToCompounds()"}, "1322": {"callee_method_names": [], "method_name": "FileParsingParameters.setAlignSeqRes", "method_implementation": "{\n    this.alignSeqRes = alignSeqRes;\n}", "repo_id": "9", "comment": "/**\n * Define if the SEQRES in the structure should be aligned with the ATOM records\n * if yes, the AminoAcids in structure.getSeqRes will have the coordinates set.\n * @param alignSeqRes\n */\n", "repo_name": "biojava-master/", "id": 1322, "method_signature": "void setAlignSeqRes(boolean)"}, "536": {"callee_method_names": [], "method_name": "AlignUtils.rms_dk_diag", "method_implementation": "{\n    //        dk = 0\n    //        for x in range(l-k):\n    //            dk += (dk1[x+i]-dk2[x+j])*(dk1[x+i]-dk2[x+j])\n    //        dk /= (l-k)\n    //        return math.sqrt(dk)\n    double dk = 0.0;\n    for (int x = 0; x < (l - k); x++) dk += (dk1[x + i] - dk2[x + j]) * (dk1[x + i] - dk2[x + j]);\n    dk /= (l - k);\n    return Math.sqrt(dk);\n}", "repo_id": "9", "comment": "/**\n * Given distance matrix diagonals dk1, dk2, get the rmsd of a fpair.\n * i,j is the fpair start in mol1 and mol2, l is the length of the fragment\n *\n * @param dk1 distances of structure 1\n * @param dk2 distance of structure 2\n * @param i position in structure 1\n * @param j position in structure 2\n * @param l length of the fragments\n * @param k diagonal used\n * @return a double\n */\n", "repo_name": "biojava-master/", "id": 536, "method_signature": "double rms_dk_diag(double[], double[], int, int, int, int)"}, "1997": {"callee_method_names": ["RotationGroup.getPointGroup", "List<List<Integer>>.get", "List<List<Integer>>.size", "QuatSymmetrySubunits.getCenters", "List<Integer>.get", "Vector3d.sub", "List<Point3d>.get", "QuatSymmetrySubunits.getCentroid", "Vector3d.normalize"], "method_name": "RotationAxisAligner.getReferenceAxisCylicWithSubunitAlignment", "method_implementation": "{\n    if (\"C2\".equals(rotationGroup.getPointGroup())) {\n        return referenceVector;\n    }\n    // find subunit that extends the most in the xy-plane\n    List<List<Integer>> orbits = getOrbitsByXYWidth();\n    // get the last orbit which is the widest\n    List<Integer> widestOrbit = orbits.get(orbits.size() - 1);\n    List<Point3d> centers = subunits.getCenters();\n    int subunit = widestOrbit.get(0);\n    // calculate reference vector\n    Vector3d refAxis = new Vector3d();\n    refAxis.sub(centers.get(subunit), subunits.getCentroid());\n    refAxis.normalize();\n    return refAxis;\n}", "repo_id": "9", "comment": "/**\n * Returns a reference vector for the alignment of Cn structures.\n * @return reference vector\n */\n", "repo_name": "biojava-master/", "id": 1997, "method_signature": "Vector3d getReferenceAxisCylicWithSubunitAlignment()"}, "2482": {"callee_method_names": ["List<Integer>.size", "List<Integer>.get", "List<Integer>.get", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug"], "method_name": "ChromosomeMappingTools.getChromPosForward", "method_implementation": "{\n    boolean inCoding = false;\n    int codingLength = 0;\n    @SuppressWarnings(\"unused\")\n    int lengthExons = 0;\n    // map forward\n    for (int i = 0; i < exonStarts.size(); i++) {\n        // start can include UTR\n        int start = exonStarts.get(i);\n        int end = exonEnds.get(i);\n        lengthExons += end - start;\n        if (start <= cdsStart + 1 && end >= cdsStart + 1) {\n            // first exon with UTR\n            if (codingLength + (end - cdsStart - 1) >= cdsPos) {\n                // we are reaching our target position\n                int tmp = cdsPos - codingLength;\n                logger.debug(cdsStart + \" | \" + codingLength + \" | \" + tmp);\n                logger.debug(\" -> found position in UTR exon:  #\" + (i + 1) + \" cdsPos:\" + cdsPos + \" return:\" + (cdsStart + 1 + tmp) + \" start:\" + format(start + 1) + \" \" + format(tmp) + \" \" + cdsStart + \" \" + codingLength);\n                // we start 1 after cdsStart...\n                return new ChromPos((cdsStart + 1 + tmp), -1);\n            }\n            inCoding = true;\n            codingLength += (end - cdsStart);\n            logger.debug(\"     UTR         : \" + format(start + 1) + \" - \" + (cdsStart));\n            logger.debug(\" ->  Exon        : \" + format(cdsStart + 1) + \" - \" + format(end) + \" | \" + format(end - cdsStart) + \" | \" + codingLength + \" | \" + (codingLength % 3));\n        } else if (start + 1 <= cdsEnd && end >= cdsEnd) {\n            // LAST EXON with UTR\n            //logger.debug(\" <-- CDS end at: \" + cdsEnd );\n            inCoding = false;\n            if (codingLength + (cdsEnd - start - 1) >= cdsPos) {\n                int tmp = cdsPos - codingLength;\n                logger.debug(\" <-  Exon        : \" + format(start + 1) + \" - \" + format(cdsEnd) + \" | \" + format(cdsEnd - start) + \" | \" + codingLength + \" | \" + (codingLength % 3));\n                logger.debug(\"     UTR         : \" + format(cdsEnd + 1) + \" - \" + format(end));\n                logger.debug(codingLength + \" | \" + tmp + \" | \" + format(start + 1));\n                logger.debug(\" -> chromPosForward found position in non coding exon:  \" + cdsPos + \" \" + format(start + 1) + \" \" + format(tmp) + \" \" + format(cdsStart) + \" \" + codingLength);\n                return new ChromPos((start + 1 + tmp), cdsPos % 3);\n            }\n            codingLength += (cdsEnd - start - 1);\n            logger.debug(\" <-  Exon        : \" + format(start + 1) + \" - \" + format(cdsEnd) + \" | \" + format(cdsEnd - start) + \" | \" + codingLength + \" | \" + (codingLength % 3));\n            logger.debug(\"     UTR         : \" + format(cdsEnd + 1) + \" - \" + format(end));\n        } else if (inCoding) {\n            // A standard coding Exon\n            // tests for the maximum length of this coding exon\n            if (codingLength + (end - start - 1) >= cdsPos) {\n                // we are within the range of this exon\n                int tmp = cdsPos - codingLength;\n                logger.debug(\"     Exon        : \" + format(start + 1) + \" - \" + format(end) + \" | \" + format(end - start) + \" | \" + tmp + \" | \" + codingLength);\n                logger.debug(\" -> found chr position in coding exon #\" + (i + 1) + \":  cdsPos:\" + format(cdsPos) + \" s:\" + format(start) + \"-\" + format(end) + \" tmp:\" + format(tmp) + \" cdsStart:\" + format(cdsStart) + \" codingLength:\" + codingLength);\n                return new ChromPos((start + 1 + tmp), cdsPos % 3);\n            }\n            // full exon is coding\n            codingLength += (end - start);\n            logger.debug(\"     Exon        : \" + format(start + 1) + \" - \" + format(end) + \" | \" + format(end - start) + \" | \" + codingLength + \" | \" + (codingLength % 3));\n        }\n    }\n    return new ChromPos(-1, -1);\n}", "repo_id": "9", "comment": "/**\n * Get the CDS position mapped onto the chromosome position\n *\n * @param exonStarts\n * @param exonEnds\n * @param cdsStart\n * @param cdsEnd\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2482, "method_signature": "ChromPos getChromPosForward(int, List, List, int, int)"}, "1784": {"callee_method_names": [], "method_name": "PDBHeader.getBioAssemblies", "method_implementation": "{\n    return bioAssemblies;\n}", "repo_id": "9", "comment": "/**\n * Return the map of biological assemblies. The keys are the\n * biological assembly identifiers (starting at 1). Non-numerical identifiers\n * such as PAU or XAU are not supported.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1784, "method_signature": "Map<Integer,BioAssemblyInfo> getBioAssemblies()"}, "2443": {"callee_method_ids": [2423, 2422, 2431], "callee_method_names": ["FeatureI.seqname", "Location.isSameStrand", "FeatureI.location", "FeatureI.location", "FeatureI.location", "Location.opposite", "FeatureList.add"], "method_name": "FeatureList.selectOverlapping", "method_implementation": "{\n    FeatureList list = new FeatureList();\n    for (FeatureI feature : this) {\n        boolean overlaps = false;\n        if (feature.seqname().equals(seqname)) {\n            if (location.isSameStrand(feature.location())) {\n                overlaps = feature.location().overlaps(location);\n            } else if (useBothStrands) {\n                overlaps = feature.location().overlaps(location.opposite());\n            }\n        }\n        if (overlaps) {\n            list.add(feature);\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Create a list of all features that overlap the specified location on the specified\n * sequence.\n *\n * @param seqname The sequence name. Only features with this sequence name will be checked for overlap.\n * @param location The location to check.\n * @param useBothStrands If true, locations are mapped to their positive strand image\n * before being checked for overlap. If false, only features whose locations are\n * on the same strand as the specified location will be considered for inclusion.\n * @return The new list of features that overlap the location.\n */\n", "repo_name": "biojava-master/", "id": 2443, "method_signature": "FeatureList selectOverlapping(String, Location, boolean)"}, "2034": {"callee_method_names": [], "method_name": "Icosahedron.setInscribedRadius", "method_implementation": "{\n    double side = getSideLengthFromInscribedRadius(radius);\n    this.circumscribedRadius = getCircumscribedRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Sets the radius of an inscribed sphere, that is tangent to each\n * of the icosahedron's faces\n * @param inscribedRadius the inscribedRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2034, "method_signature": "void setInscribedRadius(double)"}, "1549": {"callee_method_names": ["String.length", "String.substring", "double[].getScopId"], "method_name": "ScopInstallation.getDomainByScopID", "method_implementation": "{\n    try {\n        ensureClaInstalled();\n    } catch (IOException e) {\n        throw new ScopIOException(e);\n    }\n    if (scopId.length() < 6) {\n        throw new ScopIOException(\"Does not look like a scop ID! \" + scopId);\n    }\n    //TODO handle this when you handle extended PdbId (PDB ID)\n    String pdbId = scopId.substring(1, 5);\n    List<ScopDomain> doms = getDomainsForPDB(pdbId);\n    if (doms == null)\n        return null;\n    for (ScopDomain d : doms) {\n        if (d.getScopId().equalsIgnoreCase(scopId))\n            return d;\n    }\n    return null;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getDomainByScopID(java.lang.String)\n\t */\n", "repo_name": "biojava-master/", "id": 1549, "method_signature": "ScopDomain getDomainByScopID(String)"}, "228": {"callee_method_names": [], "method_name": "ProteinModificationImpl.setDescription", "method_implementation": "{\n    // description is created on the fly in getDescription\n    return this;\n}", "repo_id": "9", "comment": "/**\n * @param description description of the modification.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 228, "method_signature": "Builder setDescription(String)"}, "1830": {"callee_method_ids": [402], "callee_method_names": ["GroupIterator.getCurrentModel"], "method_name": "AtomIterator.getCurrentModel", "method_implementation": "{\n    return groupiter.getCurrentModel();\n}", "repo_id": "9", "comment": "/**\n * Get the model number of the model containing the current atom.\n *\n * @return the number of the model\n */\n", "repo_name": "biojava-master/", "id": 1830, "method_signature": "int getCurrentModel()"}, "2107": {"callee_method_names": [], "method_name": "Axis.getOrder", "method_implementation": "{\n    return order;\n}", "repo_id": "9", "comment": "/**\n * Get the order of this axis (closed symm) or the number of repeats\n * (open symm)\n * @return the order\n */\n", "repo_name": "biojava-master/", "id": 2107, "method_signature": "int getOrder()"}, "3115": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getLength", "method_implementation": "{\n    return this.parsedCompounds.size();\n}", "repo_id": "9", "comment": "/**\n * The sequence length\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3115, "method_signature": "int getLength()"}, "970": {"callee_method_ids": [1349], "callee_method_names": ["Structure.clone", "Structure.resetModels", "Structure.setEntityInfos", "Structure.getChain", "Matrix4d.getChainId", "List<Chain>.add", "Structure.getPolyChainByPDB", "Matrix4d.getChainId", "Structure.getNonPolyChainsByPDB", "Matrix4d.getChainId", "Structure.getWaterChainByPDB", "Matrix4d.getChainId", "List<Chain>.add", "List<Chain>.isEmpty", "List<Chain>.addAll", "List<Chain>.add", "Chain.clone", "Matrix4d.getTransformationMatrix", "Matrix4d.getId", "Map<Integer, EntityInfo>.containsKey", "Chain.getEntityInfo", "Chain.getEntityInfo", "Map<Integer, EntityInfo>.put", "Chain.getEntityInfo", "Structure.addEntityInfo", "Map<Integer, EntityInfo>.get", "Chain.getEntityInfo", "Chain.setEntityInfo", "EntityInfo.addChain", "Structure.setBiologicalAssembly"], "method_name": "BiologicalAssemblyBuilder.rebuildQuaternaryStructure", "method_implementation": "{\n    // ensure that new chains are build in the same order as they appear in the asymmetric unit\n    orderTransformationsByChainId(asymUnit, transformations);\n    Structure s = asymUnit.clone();\n    Map<Integer, EntityInfo> entityInfoMap = new HashMap<>();\n    // this resets all models (not only the first one): this is important for NMR (multi-model)\n    // like that we can be sure we start with an empty structures and we add models or chains to it\n    s.resetModels();\n    s.setEntityInfos(new ArrayList<>());\n    for (BiologicalAssemblyTransformation transformation : transformations) {\n        List<Chain> chainsToTransform = new ArrayList<>();\n        // note: for NMR structures (or any multi-model) we use the first model only and throw away the rest\n        if (useAsymIds) {\n            Chain c = asymUnit.getChain(transformation.getChainId());\n            chainsToTransform.add(c);\n        } else {\n            Chain polyC = asymUnit.getPolyChainByPDB(transformation.getChainId());\n            List<Chain> nonPolyCs = asymUnit.getNonPolyChainsByPDB(transformation.getChainId());\n            Chain waterC = asymUnit.getWaterChainByPDB(transformation.getChainId());\n            if (polyC != null)\n                chainsToTransform.add(polyC);\n            if (!nonPolyCs.isEmpty())\n                chainsToTransform.addAll(nonPolyCs);\n            if (waterC != null)\n                chainsToTransform.add(waterC);\n        }\n        for (Chain c : chainsToTransform) {\n            Chain chain = (Chain) c.clone();\n            Calc.transform(chain, transformation.getTransformationMatrix());\n            String transformId = transformation.getId();\n            // note that the Structure.addChain/Structure.addModel methods set the parent reference to the new Structure\n            if (multiModel)\n                addChainMultiModel(s, chain, transformId);\n            else\n                addChainFlattened(s, chain, transformId);\n            EntityInfo entityInfo;\n            if (!entityInfoMap.containsKey(chain.getEntityInfo().getMolId())) {\n                entityInfo = new EntityInfo(chain.getEntityInfo());\n                entityInfoMap.put(chain.getEntityInfo().getMolId(), entityInfo);\n                s.addEntityInfo(entityInfo);\n            } else {\n                entityInfo = entityInfoMap.get(chain.getEntityInfo().getMolId());\n            }\n            chain.setEntityInfo(entityInfo);\n            entityInfo.addChain(chain);\n        }\n    }\n    s.setBiologicalAssembly(true);\n    return s;\n}", "repo_id": "9", "comment": "/**\n * Builds a Structure object containing the quaternary structure built from given asymUnit and transformations,\n * by adding symmetry partners as new models.\n * The output Structure will be different depending on the multiModel parameter:\n * <li>\n * the symmetry-expanded chains are added as new models, one per transformId. All original models but\n * the first one are discarded.\n * </li>\n * <li>\n * as original with symmetry-expanded chains added with renamed chain ids and names (in the form\n * originalAsymId_transformId and originalAuthId_transformId)\n * </li>\n * @param asymUnit\n * @param transformations\n * @param useAsymIds if true use {@link Chain#getId()} to match the ids in the BiologicalAssemblyTransformation (needed if data read from mmCIF),\n * if false use {@link Chain#getName()} for the chain matching (needed if data read from PDB).\n * @param multiModel if true the output Structure will be a multi-model one with one transformId per model,\n * if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId).\n * @return\n */\n", "repo_name": "biojava-master/", "id": 970, "method_signature": "Structure rebuildQuaternaryStructure(Structure, List, boolean, boolean)"}, "618": {"callee_method_names": ["URLConnection.setDoOutput", "URLConnection.getOutputStream", "OutputStreamWriter.write", "OutputStreamWriter.flush", "URLConnection.getInputStream"], "method_name": "URLConnectionTools.doPOST", "method_implementation": "{\n    URLConnection conn = openURLConnection(url, timeout);\n    conn.setDoOutput(true);\n    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n    wr.write(data);\n    wr.flush();\n    return conn.getInputStream();\n}", "repo_id": "9", "comment": "/**\n * Do a POST to a URL and return the response stream for further processing elsewhere.\n * <p>\n * The caller is responsible to close the returned InputStream not to cause\n * resource leaks.\n * @param url the input URL to be read\n * @param data the post data\n * @param timeout\n * @return an {@link InputStream} of response\n * @throws IOException due to an error opening the URL\n */\n", "repo_name": "biojava-master/", "id": 618, "method_signature": "InputStream doPOST(URL, String, int)"}, "2272": {"callee_method_ids": [1322, 641], "callee_method_names": ["AtomCache.getFileParsingParams", "FileParsingParameters.setParseBioAssembly", "FileParsingParameters.setAlignSeqRes", "AtomCache.setFiletype", "Structure.nrModels", "Structure.getModel", "List<Chain>.get"], "method_name": "TestDifficultMmCIFFiles.test2KSA", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    StructureIO.setAtomCache(cache);\n    FileParsingParameters params = cache.getFileParsingParams();\n    params.setParseBioAssembly(true);\n    params.setAlignSeqRes(true);\n    StructureIO.setAtomCache(cache);\n    cache.setFiletype(StructureFiletype.CIF);\n    Structure sCif = StructureIO.getStructure(\"2KSA\");\n    assertNotNull(sCif);\n    // Unit test for each of the chains to show they begin with the correct first residue.\n    for (int i = 0; i < sCif.nrModels(); i++) {\n        List<Chain> chains = sCif.getModel(i);\n        // Chain A first residue should start at ASP 2..\n        // but if replaceGroupSeqPos(PdbxPolySeqScheme ppss) is used, this is incorrect and will be 1.\n        assertEquals(2, chains.get(0).getAtomGroup(0).getResidueNumber().getSeqNum().intValue());\n    }\n}", "repo_id": "9", "comment": "/**\n * The 2KSA mmCIF contains a 5 model NMR structure.  The first residue of the sequence is not visible\n * and the models should all begin with Asp indexed as residue #2.\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2272, "method_signature": "void test2KSA()"}, "651": {"callee_method_names": [], "method_name": "AbstractScoresCache.clone", "method_implementation": "{\n    throw new CloneNotSupportedException(\"Subclasses must override clone\");\n}", "repo_id": "9", "comment": "/**\n * Subclasses should override clone and use the copy constructor.\n *\n * @param e\n * @return\n * @throws CloneNotSupportedException\n */\n", "repo_name": "biojava-master/", "id": 651, "method_signature": "Object clone(Object)"}, "3394": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.showAxes", "method_implementation": "{\n    return \"draw axes* on;\";\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#showAxes()\n\t */\n", "repo_name": "biojava-master/", "id": 3394, "method_signature": "String showAxes()"}, "3688": {"callee_method_ids": [3654, 3654, 3649], "callee_method_names": ["ArrayList<String>.add", "ArrayList<String>.add", "ArrayList<String>.add", "SurvivalInfo.getVariable", "SurvivalInfo.getVariable", "SurvivalInfo.addContinuousVariable"], "method_name": "SurvivalInfoHelper.addInteraction", "method_implementation": "{\n    ArrayList<String> variables = new ArrayList<String>();\n    variables.add(variable1);\n    variables.add(variable2);\n    variables.add(variable1 + \":\" + variable2);\n    for (SurvivalInfo si : survivalInfoList) {\n        Double value1 = si.getVariable(variable1);\n        Double value2 = si.getVariable(variable2);\n        Double value3 = value1 * value2;\n        si.addContinuousVariable(variable1 + \":\" + variable2, value3);\n    }\n    return variables;\n}", "repo_id": "9", "comment": "/**\n * To test for interactions use two variables and create a third variable where the two are multiplied together.\n * @param variable1\n * @param variable2\n * @param survivalInfoList\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3688, "method_signature": "ArrayList<String> addInteraction(String, String, ArrayList)"}, "1430": {"callee_method_ids": [1456], "callee_method_names": ["SpaceGroup.getAxisFoldType"], "method_name": "CrystalTransform.isRotation", "method_implementation": "{\n    // if no SG, that means a non-crystallographic entry (e.g. NMR). We return false\n    if (sg == null)\n        return false;\n    // this also takes care of case <0 (improper rotations): won't be considered as rotations\n    if (sg.getAxisFoldType(this.transformId) > 1)\n        return true;\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Tells whether this transformation is a rotation disregarding the translational component,\n * i.e. either pure rotation or screw rotation, but not improper rotation.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1430, "method_signature": "boolean isRotation()"}, "2666": {"callee_method_names": [], "method_name": "DNAToRNATranslator.wrapToRna", "method_implementation": "{\n    ProxySequenceReader<NucleotideCompound> rnaView = new RnaSequenceView(dna);\n    return new RNASequence(rnaView);\n}", "repo_id": "9", "comment": "/**\n * Takes in the given DNA Sequence and returns an instance of RNASequence\n * which is using {@link RnaSequenceView} as a\n * {@link ProxySequenceReader}.\n */\n", "repo_name": "biojava-master/", "id": 2666, "method_signature": "RNASequence wrapToRna(Sequence)"}, "2102": {"callee_method_ids": [2106, 2107, 2108, 2107], "callee_method_names": ["List<Axis>.get", "Axis.getOperator", "Matrix4d.invert", "Matrix4d.mul", "Matrix4d.mul", "Axis.getOrder", "Axis.getSymmType", "List<Axis>.add", "Matrix4d.mul", "Axis.getOrder", "Matrix4d.mul"], "method_name": "SymmetryAxes.getSymmetryAxes", "method_implementation": "{\n    if (level >= getNumLevels()) {\n        return;\n    }\n    Axis elem = axes.get(level);\n    Matrix4d elemOp = elem.getOperator();\n    // Current axis:\n    // elementary maps B -> A\n    // prior maps I -> A and J -> B\n    // want J -> I = J -> B -> A <- I= inv(prior) * elementary * prior\n    Matrix4d currAxisOp = new Matrix4d(prior);\n    currAxisOp.invert();\n    currAxisOp.mul(elemOp);\n    currAxisOp.mul(prior);\n    Axis currAxis = new Axis(currAxisOp, elem.getOrder(), elem.getSymmType(), level, firstRepeat);\n    symmAxes.add(currAxis);\n    //Remember that all degrees are at least 2\n    getSymmetryAxes(symmAxes, prior, level + 1, firstRepeat);\n    //New prior is elementary^d*prior\n    Matrix4d newPrior = new Matrix4d(elemOp);\n    newPrior.mul(prior);\n    int childSize = getNumRepeats(level + 1);\n    getSymmetryAxes(symmAxes, newPrior, level + 1, firstRepeat + childSize);\n    for (int d = 2; d < elem.getOrder(); d++) {\n        newPrior.mul(elemOp, newPrior);\n        getSymmetryAxes(symmAxes, newPrior, level + 1, firstRepeat + childSize * d);\n    }\n}", "repo_id": "9", "comment": "/**\n * Recursive helper\n * @param symmAxes output list\n * @param prior transformation aligning the first repeat of this axis with the first overall\n * @param level current level\n */\n", "repo_name": "biojava-master/", "id": 2102, "method_signature": "void getSymmetryAxes(List, Matrix4d, int, int)"}, "1889": {"callee_method_names": [], "method_name": "Stoichiometry.getClusters", "method_implementation": "{\n    return orderedClusters;\n}", "repo_id": "9", "comment": "/**\n * @return list of {@link SubunitCluster}, ordered by the number of subunits (decreasing).\n */\n", "repo_name": "biojava-master/", "id": 1889, "method_signature": "List<SubunitCluster> getClusters()"}, "1449": {"callee_method_names": [], "method_name": "SpaceGroup.parseSpaceGroup", "method_implementation": "{\n    return SymoplibParser.getSpaceGroup(shortName);\n}", "repo_id": "9", "comment": "/**\n * Get the space group for the given international short name, using\n * the PDB format, e.g. 'P 21 21 21' or 'C 1 c 1'\n * @param shortName\n * @return the SpaceGroup or null if the shortName is not valid\n * @see SymoplibParser#getSpaceGroup(String)\n */\n", "repo_name": "biojava-master/", "id": 1449, "method_signature": "SpaceGroup parseSpaceGroup(String)"}, "3617": {"callee_method_names": ["LinkedHashMap.values", "double.getRobustStdError", "double.getStdError", "double.getStdError", "double.getName", "double.getCoeff", "double.getZ", "double.getPvalue", "double.getHazardRatio", "double.getHazardRatioLoCI", "double.getHazardRatioHiCI"], "method_name": "CoxInfo.getCoefficientText", "method_implementation": "{\n    String o = \"\";\n    if (header) {\n        String robust = \"\";\n        if (naive_imat != null) {\n            robust = beginCell + \"robust se\" + endCell;\n        }\n        o = o + beginLine + beginCell + fmtpl(\"\", 9) + endCell + beginCell + fmtpl(\"coef\", 9) + endCell + beginCell + fmtpl(\"se(coef)\", 9) + endCell + robust + beginCell + fmtpl(\"z\", 9) + endCell + beginCell + fmtpl(\"p-value\", 9) + endCell + beginCell + fmtpl(\"HR\", 9) + endCell + beginCell + fmtpl(\"lower .95\", 9) + endCell + beginCell + fmtpl(\"upper .95\", 9) + endCell + endLine;\n    }\n    //Coefficients,Coe,StdErr,HR,p-value,HR Lo 95%,HR Hi 95%\n    for (CoxCoefficient coe : coefficientsList.values()) {\n        String robust = \"\";\n        String stderror = \"\";\n        if (naive_imat != null) {\n            stderror = beginCell + fmt(coe.getRobustStdError(), 5, 9) + endCell;\n            robust = beginCell + fmt(coe.getStdError(), 5, 9) + endCell;\n        } else {\n            stderror = beginCell + fmt(coe.getStdError(), 5, 9) + endCell;\n        }\n        o = o + beginLine + beginCell + fmtpr(coe.getName(), 9) + endCell + beginCell + fmt(coe.getCoeff(), 5, 9) + stderror + robust + endCell + beginCell + fmt(coe.getZ(), 5, 9) + endCell + beginCell + fmt(coe.getPvalue(), 6, 9) + endCell + beginCell + fmt(coe.getHazardRatio(), 3, 9) + endCell + beginCell + fmt(coe.getHazardRatioLoCI(), 3, 9) + endCell + beginCell + fmt(coe.getHazardRatioHiCI(), 3, 9) + endCell + endLine;\n    }\n    return o;\n}", "repo_id": "9", "comment": "/**\n * @param header\n * @param beginLine\n * @param beginCell\n * @param endCell\n * @param endLine\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3617, "method_signature": "String getCoefficientText(boolean, String, String, String, String)"}, "1879": {"callee_method_names": [], "method_name": "Helix.setFold", "method_implementation": "{\n    this.fold = fold;\n}", "repo_id": "9", "comment": "/**\n * @param fold the fold to set\n */\n", "repo_name": "biojava-master/", "id": 1879, "method_signature": "void setFold(int)"}, "3629": {"callee_method_names": [], "method_name": "CoxInfo.getRscoreLogrankTestpvalue", "method_implementation": "{\n    return rscoreLogrankTestpvalue;\n}", "repo_id": "9", "comment": "/**\n * @return the rscoreLogrankTestpvalue\n */\n", "repo_name": "biojava-master/", "id": 3629, "method_signature": "Double getRscoreLogrankTestpvalue()"}, "3075": {"callee_method_names": [], "method_name": "CDSSequence.getPhase", "method_implementation": "{\n    return phase;\n}", "repo_id": "9", "comment": "/**\n * @return get the phase\n */\n", "repo_name": "biojava-master/", "id": 3075, "method_signature": "Integer getPhase()"}, "1659": {"callee_method_names": ["Logger.info", "SubunitCluster.get"], "method_name": "SubunitCluster.mergeIdentical", "method_implementation": "{\n    if (!isIdenticalTo(other))\n        return false;\n    logger.info(\"SubunitClusters {}-{} are identical in sequence\", this.subunits.get(this.representative).getName(), other.subunits.get(other.representative).getName());\n    this.subunits.addAll(other.subunits);\n    this.subunitEQR.addAll(other.subunitEQR);\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Merges the other SubunitCluster into this one if it contains exactly the\n * same Subunit. This is checked by {@link #isIdenticalTo(SubunitCluster)}.\n *\n * @param other\n *            SubunitCluster\n * @return true if the SubunitClusters were merged, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 1659, "method_signature": "boolean mergeIdentical(SubunitCluster)"}, "1131": {"callee_method_names": [], "method_name": "LocalPDBDirectory.getStructureById", "method_implementation": "{\n    InputStream inStream = getInputStream(pdbId);\n    return getStructure(inStream);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1131, "method_signature": "Structure getStructureById(PdbId)"}, "95": {"callee_method_names": ["List<Anchor>.size", "List<Anchor>.get", "List<Anchor>.get", "List<Subproblem>.add", "List<Anchor>.get", "List<Anchor>.get", "List<Anchor>.get", "List<Subproblem>.add"], "method_name": "Subproblem.getSubproblems", "method_implementation": "{\n    Collections.sort(anchors, new Anchor.QueryIndexComparator());\n    List<Subproblem> list = new ArrayList<Subproblem>();\n    // sentinal anchor\n    Anchor last = new Anchor(-1, -1);\n    boolean isAnchored = false;\n    for (int i = 0; i < anchors.size(); i++) {\n        if (anchors.get(i).targetIndex <= last.targetIndex || anchors.get(i).queryIndex <= last.queryIndex) {\n            throw new IllegalArgumentException(\"Anchor set must allow at least one possible alignment.\");\n        }\n        list.add(new Subproblem(last.queryIndex + 1, last.targetIndex + 1, anchors.get(i).queryIndex, anchors.get(i).targetIndex, isAnchored));\n        last = anchors.get(i);\n        isAnchored = true;\n    }\n    list.add(new Subproblem(last.queryIndex + 1, last.targetIndex + 1, querySequenceLength, targetSequenceLength, isAnchored));\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Convert a list of anchors into a subproblem list.\n * @param anchors anchored read pairs\n * @param querySequenceLength length of query sequence\n * @param targetSequenceLength length of target sequence\n * @return list alignment subproblems\n */\n", "repo_name": "biojava-master/", "id": 95, "method_signature": "List<Subproblem> getSubproblems(List, int, int)"}, "1810": {"callee_method_names": ["String.equals", "ReadWriteLock.writeLock", "Logger.trace", "Logger.trace", "ReadWriteLock.writeLock"], "method_name": "EcodInstallation.setCacheLocation", "method_implementation": "{\n    if (cacheLocation.equals(this.cacheLocation)) {\n        //no change\n        return;\n    }\n    // update location\n    domainsFileLock.writeLock().lock();\n    logger.trace(\"LOCK writelock\");\n    this.cacheLocation = cacheLocation;\n    logger.trace(\"UNLOCK writelock\");\n    domainsFileLock.writeLock().unlock();\n}", "repo_id": "9", "comment": "/**\n * Set an alternate download location for files\n * @param cacheLocation\n */\n", "repo_name": "biojava-master/", "id": 1810, "method_signature": "void setCacheLocation(String)"}, "1479": {"callee_method_names": [], "method_name": "CrystalCell.isCellReasonable", "method_implementation": "{\n    // this check is necessary mostly when reading PDB files that can contain the default 1 1 1 crystal cell\n    // if we use that further things can go wrong, for instance for interface calculation\n    // For instance programs like coot produce by default a 1 1 1 cell\n    if (this.getA() < MIN_VALID_CELL_SIZE && this.getB() < MIN_VALID_CELL_SIZE && this.getC() < MIN_VALID_CELL_SIZE) {\n        return false;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Checks whether the dimensions of this crystal cell are reasonable for protein\n * crystallography: if all 3 dimensions are below {@value #MIN_VALID_CELL_SIZE} the cell\n * is considered unrealistic and false returned\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1479, "method_signature": "boolean isCellReasonable()"}, "3692": {"callee_method_names": [], "method_name": "SurvFitInfo.setUnweightedStrataInfoHashMap", "method_implementation": "{\n    this.unweightedStrataInfoHashMap = unweightedStrataInfoHashMap;\n}", "repo_id": "9", "comment": "/**\n * @param unweightedStrataInfoHashMap\n */\n", "repo_name": "biojava-master/", "id": 3692, "method_signature": "void setUnweightedStrataInfoHashMap(LinkedHashMap)"}, "2083": {"callee_method_names": ["MultipleAlignment.getStructureIdentifier", "FileWriter.append", "List<Integer>.size", "FileWriter.append", "FileWriter.append", "List<Long>.get", "FileWriter.append", "List<Integer>.get", "FileWriter.append", "List<Double>.get", "FileWriter.append", "List<Double>.get", "FileWriter.append", "List<Double>.get", "FileWriter.flush", "FileWriter.close"], "method_name": "SymmOptimizer.saveHistory", "method_implementation": "{\n    String name = msa.getStructureIdentifier(0).getIdentifier();\n    FileWriter writer = new FileWriter(folder + name + \"-symm_opt.csv\");\n    writer.append(\"Step,Time,RepeatLength,RMSD,TMscore,MCscore\\n\");\n    for (int i = 0; i < lengthHistory.size(); i++) {\n        writer.append(i * saveStep + \",\");\n        writer.append(timeHistory.get(i) + \",\");\n        writer.append(lengthHistory.get(i) + \",\");\n        writer.append(rmsdHistory.get(i) + \",\");\n        writer.append(tmScoreHistory.get(i) + \",\");\n        writer.append(mcScoreHistory.get(i) + \"\\n\");\n    }\n    writer.flush();\n    writer.close();\n}", "repo_id": "9", "comment": "/**\n * Save the evolution of the optimization process as a csv file.\n */\n", "repo_name": "biojava-master/", "id": 2083, "method_signature": "void saveHistory(String)"}, "179": {"callee_method_ids": [1804, 1821], "callee_method_names": ["List<String>.add", "EcodInstallation.getAllDomains", "EcodInstallation.getVersion"], "method_name": "EcodInstallationTest.testAllVersions", "method_implementation": "{\n    // List all versions\n    List<String> versions = getKnownEcodVersions();\n    versions.add(EcodFactory.DEFAULT_VERSION);\n    // Parse all versions\n    for (String version : versions) {\n        EcodInstallation ecod = (EcodInstallation) EcodFactory.getEcodDatabase(version);\n        ecod.getAllDomains();\n        System.out.println(version + \" -> \" + ecod.getVersion());\n        // Force garbage collection of all soft references\n        // This shouldn't be required, but without it we get\n        // 'OutOfMemoryError: GC overhead limit exceeded'.\n        // Probably this is due to synchronization in EcodFactory blocking\n        // the GC during parsing. -Spencer\n        ecod = null;\n        System.gc();\n        try {\n            @SuppressWarnings(\"unused\")\n            Object[] ignored = new Object[(int) Runtime.getRuntime().maxMemory()];\n        } catch (Throwable e) {\n            // Ignore OME\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Parses all known versions. Only fails due to exceptions, so manually check for warnings.\n * Hierarchical field warnings are expected for versions prior to develop68.\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 179, "method_signature": "void testAllVersions()"}, "331": {"callee_method_names": [], "method_name": "OntoTools.getCoreOntology", "method_implementation": "{\n    return CORE_ONTOLOGY;\n}", "repo_id": "9", "comment": "/**\n * Get the Ontology that defines our core \"central dogma\".\n *\n * <p>This contains definitions that we have to have, such as <code>any</code>,\n * <code>predicate</code>, <code>is-a</code> and <code>transient</code>. These\n * are our axioms, upon which the default interpreters build.</p>\n *\n * @return the \"core\" Ontology\n */\n", "repo_name": "biojava-master/", "id": 331, "method_signature": "Ontology getCoreOntology()"}, "1204": {"callee_method_names": ["URL.openStream"], "method_name": "CifStructureConverter.fromURL", "method_implementation": "{\n    return fromInputStream(url.openStream(), parameters);\n}", "repo_id": "9", "comment": "/**\n * Get data from a URL and convert to Structure.\n * @param url the source of information - can be gzipped or binary or text data\n * @param parameters parameters for parsing\n * @return the target\n * @throws IOException thrown when reading fails\n */\n", "repo_name": "biojava-master/", "id": 1204, "method_signature": "Structure fromURL(URL, FileParsingParameters)"}, "2668": {"callee_method_names": ["List<AminoAcidCompound>.get", "List<AminoAcidCompound>.size", "Map<AminoAcidCompound, List<Codon>>.containsKey", "Map<AminoAcidCompound, List<Codon>>.get", "char.isStop", "List<AminoAcidCompound>.remove", "List<AminoAcidCompound>.size"], "method_name": "RNAToAminoAcidTranslator.trimStop", "method_implementation": "{\n    AminoAcidCompound stop = sequence.get(sequence.size() - 1);\n    boolean isStop = false;\n    if (aminoAcidToCodon.containsKey(stop)) {\n        for (Codon c : aminoAcidToCodon.get(stop)) {\n            if (c.isStop()) {\n                isStop = true;\n                break;\n            }\n        }\n    }\n    if (isStop) {\n        sequence.remove(sequence.size() - 1);\n    }\n}", "repo_id": "9", "comment": "/**\n * Imperfect code. Checks the last amino acid to see if a codon could have\n * translated a stop for it. Left in for the moment\n */\n", "repo_name": "biojava-master/", "id": 2668, "method_signature": "void trimStop(List)"}, "696": {"callee_method_names": ["MultipleAlignment.getBlock", "Matrix.get", "Matrix.get", "Random.nextDouble", "Matrix.get", "MultipleAlignment.getBlock", "Block.getCoreLength", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes"], "method_name": "MultipleMcOptimizer.insertGap", "method_implementation": "{\n    // Select residue by maximum distance\n    Matrix residueDistances = MultipleAlignmentTools.getAverageResidueDistances(msa);\n    double maxDist = Double.MIN_VALUE;\n    int structure = 0;\n    int block = 0;\n    int position = 0;\n    int column = 0;\n    for (int b = 0; b < blockNr; b++) {\n        for (int col = 0; col < msa.getBlock(b).length(); col++) {\n            for (int str = 0; str < size; str++) {\n                if (residueDistances.get(str, column) != -1) {\n                    if (residueDistances.get(str, column) > maxDist) {\n                        // Geometric distribution\n                        if (rnd.nextDouble() > 0.5) {\n                            structure = str;\n                            block = b;\n                            position = col;\n                            maxDist = residueDistances.get(str, column);\n                        }\n                    }\n                }\n            }\n            column++;\n        }\n    }\n    Block bk = msa.getBlock(block);\n    if (bk.getCoreLength() <= Lmin)\n        return false;\n    // Insert the gap at the position\n    Integer residueL = bk.getAlignRes().get(structure).get(position);\n    if (residueL != null) {\n        freePool.get(structure).add(residueL);\n    } else\n        // If there was a gap already in the position.\n        return false;\n    bk.getAlignRes().get(structure).set(position, null);\n    checkGaps();\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Insert a gap in one of the structures in a random position of the\n * alignment.\n * <p>\n * The distribution is not uniform, because positions with higher average\n * distance to their aligned neighbors are more likely to be gapped.\n * <p>\n * A gap is a null in the Block position.\n *\n * @return true if the alignment has been changed, false otherwise.\n */\n", "repo_name": "biojava-master/", "id": 696, "method_signature": "boolean insertGap()"}, "2067": {"callee_method_names": [], "method_name": "SequenceFunctionRefiner.scoreAbsError", "method_implementation": "{\n    // Use the absolute error score, |x - f^k(x)|\n    double error;\n    if (image == null) {\n        error = Double.POSITIVE_INFINITY;\n    } else {\n        error = Math.abs(pre - image);\n    }\n    //TODO favor lower degree-in\n    // Add fractional portion relative to sequence position, for uniqueness\n    if (error > 0)\n        error += (double) (pre - minPre) / (1 + maxPre - minPre);\n    return error;\n}", "repo_id": "9", "comment": "/**\n * Calculate the score for a residue, specifically the Absolute Error\n * \tscore(x) = |x-f^k(x)|\n *\n * Also includes a small bias based on residue number, for uniqueness..\n * @param pre x\n * @param image f^k(x)\n * @param minPre lowest possible residue number\n * @param maxPre highest possible residue number\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2067, "method_signature": "double scoreAbsError(Integer, Integer, int, int)"}, "3381": {"callee_method_names": ["String.replaceAll"], "method_name": "JmolSymmetryScriptGenerator.getInstantaneousOrientation", "method_implementation": "{\n    String s = getOrientation(index);\n    return s.replaceAll(\"moveto 4\", \"moveto 0\");\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script that sets a specific orientation instantaneously\n * @param index orientation index\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3381, "method_signature": "String getInstantaneousOrientation(int)"}, "1180": {"callee_method_names": ["String.length", "String.substring"], "method_name": "PDBFileParser.conect_helper", "method_implementation": "{\n    if (line.length() < end)\n        return null;\n    String sbond = line.substring(start, end).trim();\n    int bond = -1;\n    Integer b = null;\n    if (!\"\".equals(sbond)) {\n        bond = Integer.parseInt(sbond);\n        b = bond;\n    }\n    return b;\n}", "repo_id": "9", "comment": "/**\n * safes repeating a few lines ...\n */\n", "repo_name": "biojava-master/", "id": 1180, "method_signature": "Integer conect_helper(String, int, int)"}, "3848": {"callee_method_names": [], "method_name": "ProfeatProperties.getComposition", "method_implementation": "{\n    return new ProfeatPropertiesImpl().getComposition(sequence, attribute, group);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method which returns the composition of the specific grouping for the given attribute.\n *\n * @param sequence\n * \ta protein sequence consisting of non-ambiguous characters only\n * @param attribute\n * \tone of the seven attributes (Hydrophobicity, Volume, Polarity, Polarizability, Charge, SecondaryStructure or SolventAccessibility)\n * @param group\n * \tthe grouping to be computed\n * @return\n * \treturns the composition of the specific grouping for the given attribute\n * @throws Exception\n * \tthrows Exception if attribute or group are unknown\n */\n", "repo_name": "biojava-master/", "id": 3848, "method_signature": "double getComposition(ProteinSequence, ATTRIBUTE, GROUPING)"}, "2607": {"callee_method_names": ["ThreadPoolExecutor.isShutdown"], "method_name": "ConcurrencyTools.getThreadPool", "method_implementation": "{\n    if (pool == null || pool.isShutdown()) {\n        setThreadPoolDefault();\n    }\n    return pool;\n}", "repo_id": "9", "comment": "/**\n * Returns current shared thread pool.  Starts up a new pool, if necessary.\n *\n * @return shared thread pool\n */\n", "repo_name": "biojava-master/", "id": 2607, "method_signature": "ThreadPoolExecutor getThreadPool()"}, "980": {"callee_method_names": ["List<Atom>.size"], "method_name": "HetatomImpl.size", "method_implementation": "{\n    return atoms.size();\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 980, "method_signature": "int size()"}, "784": {"callee_method_names": ["AFPChain.getName2", "AFPChain.setName2", "AFPChain.getName2"], "method_name": "OptimalCECPMain.alignPermuted", "method_implementation": "{\n    // initial permutation\n    permuteArray(ca2, cp);\n    // perform alignment\n    AFPChain afpChain = super.align(ca1, ca2, param);\n    // un-permute alignment\n    permuteAFPChain(afpChain, -cp);\n    if (afpChain.getName2() != null) {\n        afpChain.setName2(afpChain.getName2() + \" CP=\" + cp);\n    }\n    // Specify the permuted\n    return afpChain;\n}", "repo_id": "9", "comment": "/**\n * Aligns ca1 with ca2 permuted by <i>cp</i> residues.\n * <p><strong>WARNING:</strong> Modifies ca2 during the permutation. Be sure\n * to make a copy before calling this method.\n *\n * @param ca1\n * @param ca2\n * @param param\n * @param cp\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 784, "method_signature": "AFPChain alignPermuted(Atom[], Atom[], Object, int)"}, "230": {"callee_method_names": [], "method_name": "ProteinModificationImpl.setFormula", "method_implementation": "{\n    this.formula = formula;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the residue formula.\n * @param formula residue formula.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 230, "method_signature": "Builder setFormula(String)"}, "2515": {"callee_method_names": ["StringTokenizer.hasMoreTokens", "StringTokenizer.nextToken", "String.startsWith", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "SimpleSubstitutionMatrix.toString", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    StringTokenizer st = new StringTokenizer(description, \"\\n\\r\");\n    while (st.hasMoreTokens()) {\n        String line = st.nextToken();\n        if (!line.startsWith(comment)) {\n            s.append(comment);\n        }\n        s.append(String.format(\"%s%n\", line));\n    }\n    s.append(getMatrixAsString());\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns in a format similar to the standard NCBI files.\n */\n", "repo_name": "biojava-master/", "id": 2515, "method_signature": "String toString()"}, "773": {"callee_method_names": ["CECPParameters.getDuplicationHint"], "method_name": "CeCPMain.align", "method_implementation": "{\n    if (!(param instanceof CECPParameters))\n        throw new IllegalArgumentException(\"CE algorithm needs an object of call CeParameters as argument.\");\n    CECPParameters cpparams = (CECPParameters) param;\n    this.params = cpparams;\n    boolean duplicateRight;\n    switch(cpparams.getDuplicationHint()) {\n        case LEFT:\n            duplicateRight = false;\n            break;\n        case RIGHT:\n            duplicateRight = true;\n            break;\n        case SHORTER:\n            duplicateRight = ca1.length >= ca2.length;\n            break;\n        default:\n            duplicateRight = true;\n    }\n    if (duplicateRight) {\n        return alignRight(ca1, ca2, cpparams);\n    } else {\n        if (debug) {\n            System.out.println(\"Swapping alignment order.\");\n        }\n        AFPChain afpChain = this.alignRight(ca2, ca1, cpparams);\n        return invertAlignment(afpChain);\n    }\n}", "repo_id": "9", "comment": "/**\n * Aligns ca1 and ca2 using a heuristic to check for CPs.\n * <p>\n * Aligns ca1 against a doubled ca2, then cleans up the alignment.\n * @param ca1\n * @param ca2\n * @param param\n * @return the alignment, possibly containing a CP.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 773, "method_signature": "AFPChain align(Atom[], Atom[], Object)"}, "3612": {"callee_method_ids": [3644], "callee_method_names": ["LinkedHashMap.keySet", "ArrayList.size", "ArrayList<String>.size", "SurvivalInfo.getResidualVariable"], "method_name": "CoxInfo.getVariableResiduals", "method_implementation": "{\n    ArrayList<String> variables = new ArrayList<String>(coefficientsList.keySet());\n    double[][] rr = new double[survivalInfoList.size()][variables.size()];\n    int p = 0;\n    for (SurvivalInfo si : this.survivalInfoList) {\n        int i = 0;\n        for (String v : variables) {\n            rr[p][i] = si.getResidualVariable(v);\n            i++;\n        }\n        p++;\n    }\n    return rr;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3612, "method_signature": "double[][] getVariableResiduals()"}, "3182": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "ChromosomeSequence.getGene", "method_implementation": "{\n    return geneSequenceHashMap.get(accession);\n}", "repo_id": "9", "comment": "/**\n * Get the gene based on accession. Will return null if not found\n * @param accession\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3182, "method_signature": "GeneSequence getGene(String)"}, "2239": {"callee_method_ids": [641, 1261], "callee_method_names": ["FileParsingParameters.setParseBioAssembly", "AtomCache.setFileParsingParams", "AtomCache.setFiletype", "MmtfStructureReader.getStructure"], "method_name": "TestMmtfRoundTrip.testRoundTrip", "method_implementation": "{\n    // Load a structure in MMCIF format\n    AtomCache cache = new AtomCache();\n    FileParsingParameters params = new FileParsingParameters();\n    params.setParseBioAssembly(true);\n    cache.setFileParsingParams(params);\n    cache.setFiletype(StructureFiletype.CIF);\n    StructureIO.setAtomCache(cache);\n    ChemCompGroupFactory.setChemCompProvider(new DownloadChemCompProvider());\n    // test case for biojava issue #770, order of subunits\n    Structure structure1 = StructureIO.getStructure(\"3BW1\");\n    AdapterToStructureData writerToEncoder = new AdapterToStructureData();\n    new MmtfStructureWriter(structure1, writerToEncoder);\n    MmtfStructureReader mmtfStructureReader = new MmtfStructureReader();\n    new StructureDataToAdapter(writerToEncoder, mmtfStructureReader);\n    Structure structure2 = mmtfStructureReader.getStructure();\n    assertTrue(checkIfAtomsSame(structure1, structure2));\n    checkBioAssemblies1(structure1, structure2);\n}", "repo_id": "9", "comment": "/**\n * Test that we can round trip a simple structure.\n *\n * @throws IOException an error reading the file\n * @throws StructureException an error parsing the structure\n */\n", "repo_name": "biojava-master/", "id": 2239, "method_signature": "void testRoundTrip()"}, "715": {"callee_method_names": ["Atom[].getGroup", "Atom[].getName", "Group.getAtom"], "method_name": "CECalculator.setStrBuf", "method_implementation": "{\n    // TODO Auto-generated method stub\n    //TODO\n    Group parent = ca[j].getGroup();\n    int pos = 0;\n    String atomName = ca[j].getName();\n    Atom a = null;\n    a = parent.getAtom(atomName);\n    if (a != null) {\n        strBuf[i] = a;\n    } else {\n        // \tprobably a GLY and no CB was found...\n        //e.printStackTrace();\n    }\n    strBuf[i + pos] = a;\n    pos++;\n}", "repo_id": "9", "comment": "/**\n * set the Atoms for a particular residue position.\n * Requires that atom.getParent returns the correct group!\n * take care during cloning of atoms. Best to use StructureTools.cloneCaAtoms();\n *\n * @param strBuf\n * @param i\n * @param ca\n * @param j\n */\n", "repo_name": "biojava-master/", "id": 715, "method_signature": "void setStrBuf(Atom[], int, Atom[], int)"}, "1707": {"callee_method_names": [], "method_name": "BondImpl.getAtomA", "method_implementation": "{\n    return atomA;\n}", "repo_id": "9", "comment": "/**\n * Gets atom 'A' of this bond. There is no meaning to which atom is 'A' and\n * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n * which they are passed to this class's constructor.\n *\n * @see #getAtomB()\n * @return one of the two atoms in this bond\n */\n", "repo_name": "biojava-master/", "id": 1707, "method_signature": "Atom getAtomA()"}, "3527": {"callee_method_names": [], "method_name": "StrataInfo.getStdlow", "method_implementation": "{\n    return stdlow;\n}", "repo_id": "9", "comment": "/**\n * @return the stdlow\n */\n", "repo_name": "biojava-master/", "id": 3527, "method_signature": "ArrayList<Double> getStdlow()"}, "675": {"callee_method_ids": [1610], "callee_method_names": ["MultipleAlignment.getEnsemble", "List<Atom[]>.get", "List<Atom[]>.get", "MultipleAlignment.getBlocks", "MultipleAlignment.getEnsemble", "StructureIdentifier.toCanonical", "SubstructureIdentifier.getPdbId", "SubstructureIdentifier.getResidueRanges", "List<Block>.get", "Atom[].getGroup", "StringBuilder.append", "Block.getAlignRes", "Block.getAlignRes", "Block.length", "List<Integer>.get", "List<Integer>.get", "Atom[].toPDB", "Atom[].toPDB", "StringBuilder.append", "String.substring", "StringBuilder.append", "String.substring", "StringBuilder.append", "String.substring", "StringBuilder.append", "StringBuilder.append", "String.substring", "StringBuilder.append", "StringBuilder.toString"], "method_name": "MultipleAlignmentWriter.to3DFormat", "method_implementation": "{\n    List<Atom[]> atomArrays = alignment.getEnsemble().getAtomArrays();\n    Atom[] queryAtoms = atomArrays.get(queryIndex);\n    Atom[] templateAtoms = atomArrays.get(templateIndex);\n    List<Block> blocks = alignment.getBlocks();\n    MultipleAlignmentTools.sortBlocks(blocks, queryIndex);\n    StringBuilder str = new StringBuilder();\n    // Gather info about the template structure\n    StructureIdentifier tName = alignment.getEnsemble().getStructureIdentifiers().get(templateIndex);\n    SubstructureIdentifier canon = tName.toCanonical();\n    PdbId tPdbId = canon.getPdbId();\n    String tChain = null;\n    for (ResidueRange range : canon.getResidueRanges()) {\n        tChain = range.getChainName();\n        break;\n    }\n    if (tChain == null) {\n        // Use the chain of the first template block\n        for (Integer i : blocks.get(0).getAlignRes().get(templateIndex)) {\n            if (i != null) {\n                tChain = templateAtoms[i].getGroup().getChainId();\n                break;\n            }\n        }\n    }\n    str.append(String.format(\"REMARK Template name:%s:%s\\n\", tPdbId, tChain));\n    for (Block block : blocks) {\n        List<Integer> qAlign = block.getAlignRes().get(queryIndex);\n        List<Integer> tAlign = block.getAlignRes().get(templateIndex);\n        for (int i = 0; i < block.length(); i++) {\n            Integer qRes = qAlign.get(i);\n            Integer tRes = tAlign.get(i);\n            // skip gaps\n            if (qRes == null || tRes == null)\n                continue;\n            // Get PDB-format ATOM records\n            String qPDB = queryAtoms[qRes].toPDB();\n            String tPDB = templateAtoms[tRes].toPDB();\n            // merge the two records into 3D format\n            // up through coordinates\n            str.append(qPDB.substring(0, 30));\n            // coordinates\n            str.append(tPDB.substring(30, 54));\n            // residue number\n            str.append(tPDB.substring(22, 27));\n            str.append(' ');\n            str.append(tPDB.substring(17, 20));\n            str.append('\\n');\n        }\n    }\n    return str.toString();\n}", "repo_id": "9", "comment": "/**\n * Outputs a pairwise alignment in I-TASSER's 3D Format for target-template\n * alignment. http://zhanglab.ccmb.med.umich.edu/I-TASSER/option4.html\n *\n * <p>\n * The format is closely related to a standard PDB file, but contains only\n * CA atoms and adds two columns for specifying the alignment:\n *\n * <pre>\n * ATOM   2001  CA  MET     1      41.116 -30.727   6.866  129 THR\n * ATOM   2002  CA  ALA     2      39.261 -27.408   6.496  130 ARG\n * ATOM   2003  CA  ALA     3      35.665 -27.370   7.726  131 THR\n * ATOM   2004  CA  ARG     4      32.662 -25.111   7.172  132 ARG\n * ATOM   2005  CA  GLY     5      29.121 -25.194   8.602  133 ARG\n *\n * Column 1 -30: Atom & Residue records of query sequence.\n * Column 31-54: Coordinates of atoms in query copied from corresponding atoms in template.\n * Column 55-59: Corresponding residue number in template based on alignment\n * Column 60-64: Corresponding residue name in template\n * </pre>\n *\n * <p>\n * Note that the output is a pairwise alignment. Only the first and second\n * rows in the MultipleAlignment will be used, others ignored.\n *\n * <p>\n * This method supports topology-independent alignments. The output will\n * have sequence order matching the query, but include atoms from the\n * template.\n *\n * @param alignment\n *            A <em>full</em> multiple alignment between proteins\n * @param queryIndex\n *            index of the query within the multiple alignment\n * @param templateIndex\n *            index of the template within the multiple alignment\n * @return The file contents as a string\n * @throws StructureException If an error occurs parsing the alignment's structure names\n */\n", "repo_name": "biojava-master/", "id": 675, "method_signature": "String to3DFormat(MultipleAlignment, int, int)"}, "2593": {"callee_method_names": [], "method_name": "SequenceTools.permuteCyclic", "method_implementation": "{\n    if (array.length != fill.length)\n        throw new IllegalArgumentException(\"Lengths do not match\");\n    if (n < 0)\n        n = array.length + n;\n    while (n > array.length) {\n        n -= array.length;\n    }\n    for (int i = 0; i < array.length; i++) {\n        if (i + n < array.length) {\n            fill[i] = array[i + n];\n        } else {\n            fill[i] = array[i - array.length + n];\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Cyclically permute {@code array} <em>forward</em> by {@code n} elements.\n * @param array The original result; will not be changed\n * @param fill The permuted result will be filled into this array\n * @param n The number of elements to permute by; can be positive or negative; values greater than the length of the array are acceptable\n */\n", "repo_name": "biojava-master/", "id": 2593, "method_signature": "void permuteCyclic(T[], T[], int)"}, "2279": {"callee_method_names": ["Structure.nrModels", "Structure.getChains", "Chain.getSeqResGroups"], "method_name": "TestHeaderOnly.doSeqResHaveAtoms", "method_implementation": "{\n    for (int i = 0; i < s.nrModels(); i++) {\n        for (Chain c : s.getChains(i)) {\n            for (Group g : c.getSeqResGroups()) {\n                // Found some Atoms in a Seqres group.\n                if (hasAtoms(g))\n                    return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Scan through SeqResGroups, returns true if any have Atoms.\n * @param s\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2279, "method_signature": "boolean doSeqResHaveAtoms(Structure)"}, "3644": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "SurvivalInfo.getResidualVariable", "method_implementation": "{\n    return residualVariableMap.get(variable);\n}", "repo_id": "9", "comment": "/**\n * @param variable\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3644, "method_signature": "Double getResidualVariable(String)"}, "1718": {"callee_method_names": [], "method_name": "BasePairParameters.getLength", "method_implementation": "{\n    if (structure == null || pairParameters == null)\n        throw new IllegalArgumentException(\"This structure is not analyzed or not initialized.\");\n    return pairingParameters.length;\n}", "repo_id": "9", "comment": "/**\n * This method returns the total number of base pairs that were found, used after the call to analyze().\n * @return An integer value, number of base pairs\n */\n", "repo_name": "biojava-master/", "id": 1718, "method_signature": "int getLength()"}, "2426": {"callee_method_names": ["Object.getClass"], "method_name": "Location.equals", "method_implementation": "{\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    Location other = (Location) obj;\n    if (mEnd != other.mEnd)\n        return false;\n    if (mStart != other.mStart)\n        return false;\n    return true;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n", "repo_name": "biojava-master/", "id": 2426, "method_signature": "boolean equals(Object)"}, "544": {"callee_method_ids": [554, 545, 828], "callee_method_names": ["PDBFileReader.setPath", "Logger.info", "PDBFileReader.getStructureById", "PDBFileReader.getStructureById", "StructurePairAligner.align", "StructurePairAligner.getAlignments", "Logger.info", "AlternativeAlignment.toPDB", "Logger.info", "PrintStream.println", "PrintStream.close", "FileOutputStream.close", "Logger.error"], "method_name": "StructurePairAligner.main", "method_implementation": "{\n    // UPDATE THE FOLLOWING LINES TO MATCH YOUR SETUP\n    PDBFileReader pdbr = new PDBFileReader();\n    pdbr.setPath(\"/Users/andreas/WORK/PDB/\");\n    // String pdb1 = \"1crl\";\n    // String pdb2 = \"1ede\";\n    String pdb1 = \"1buz\";\n    String pdb2 = \"1ali\";\n    String outputfile = \"/tmp/alig_\" + pdb1 + \"_\" + pdb2 + \".pdb\";\n    // NO NEED TO DO CHANGE ANYTHING BELOW HERE...\n    StructurePairAligner sc = new StructurePairAligner();\n    // step1 : read molecules\n    logger.info(\"aligning {} vs. {}\", pdb1, pdb2);\n    Structure s1 = pdbr.getStructureById(pdb1);\n    Structure s2 = pdbr.getStructureById(pdb2);\n    // step 2 : do the calculations\n    sc.align(s1, s2);\n    AlternativeAlignment[] aligs = sc.getAlignments();\n    // cluster similar results together\n    ClusterAltAligs.cluster(aligs);\n    // print the result:\n    // the AlternativeAlignment object gives also access to rotation\n    // matrices / shift vectors.\n    for (AlternativeAlignment aa : aligs) {\n        logger.info(\"Alternative Alignment: {}\", aa);\n    }\n    // convert AlternativeAlignemnt 1 to PDB file, so it can be opened with\n    // a viewer (e.g. Jmol, Rasmol)\n    if (aligs.length > 0) {\n        AlternativeAlignment aa1 = aligs[0];\n        String pdbstr = aa1.toPDB(s1, s2);\n        logger.info(\"writing alignment to {}\", outputfile);\n        FileOutputStream out = new FileOutputStream(outputfile);\n        PrintStream p = new PrintStream(out);\n        p.println(pdbstr);\n        p.close();\n        out.close();\n    }\n    // display the alignment in Jmol\n    // only will work if Jmol is in the Classpath\n    if (aligs.length > 0) {\n        if (!GuiWrapper.isGuiModuleInstalled()) {\n            logger.error(\"Could not find structure-gui modules in classpath, please install first!\");\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * example usage of this class\n *\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 544, "method_signature": "void main(String[])"}, "1885": {"callee_method_names": ["List<SubunitCluster>.size", "List<SubunitCluster>.get", "List<SubunitCluster>.get", "Atom[].getGroup", "Chain.getStructure", "Chain.getStructure", "List<Integer>.add"], "method_name": "QuatSymmetrySubunits.getModelNumbers", "method_implementation": "{\n    List<Integer> models = new ArrayList<Integer>(getSubunitCount());\n    // Loop through all subunits in the clusters and fill Lists\n    for (int c = 0; c < clusters.size(); c++) {\n        for (int s = 0; s < clusters.get(c).size(); s++) {\n            Atom[] atoms = clusters.get(c).getAlignedAtomsSubunit(s);\n            // TODO guess them chain and model (very ugly)\n            Chain chain = atoms[0].getGroup().getChain();\n            int model = 0;\n            for (int m = 0; m < chain.getStructure().nrModels(); m++) {\n                if (chain.getStructure().getModel(m).contains(chain)) {\n                    model = m;\n                    break;\n                }\n            }\n            models.add(model);\n        }\n    }\n    return models;\n}", "repo_id": "9", "comment": "/**\n * This method is provisional and should only be used for coloring Subunits.\n * A new coloring schema has to be implemented to allow the coloring of\n * Subunits, without implying one Subunit = one Chain.\n *\n * @return A List of the Model number of each Subunit\n */\n", "repo_name": "biojava-master/", "id": 1885, "method_signature": "List<Integer> getModelNumbers()"}, "2374": {"callee_method_names": [], "method_name": "Fastq.convertTo", "method_implementation": "{\n    return FastqTools.convert(this, variant);\n}", "repo_id": "9", "comment": "/**\n * Create and return a new FASTQ formatted sequence from this converted to the\n * specified FASTQ sequence format variant.\n *\n * @since 4.2\n * @param variant FASTQ sequence format variant, must not be null\n * @return a new FASTQ formatted sequence from this converted to the\n *    specified FASTQ sequence format variant\n */\n", "repo_name": "biojava-master/", "id": 2374, "method_signature": "Fastq convertTo(FastqVariant)"}, "2882": {"callee_method_names": ["Map<C, Integer>.get", "Map<C, Integer>.put"], "method_name": "SequenceMixin.getComposition", "method_implementation": "{\n    Map<C, Integer> results = new HashMap<C, Integer>();\n    for (C currentCompound : sequence) {\n        Integer currentInteger = results.get(currentCompound);\n        if (currentInteger == null)\n            currentInteger = 0;\n        currentInteger++;\n        results.put(currentCompound, currentInteger);\n    }\n    return results;\n}", "repo_id": "9", "comment": "/**\n * Does a linear scan over the given Sequence and records the number of\n * times each base appears. The returned map will return 0 if a compound\n * is asked for and the Map has no record of it.\n *\n * @param <C> The type of compound to look for\n * @param sequence The type of sequence to look over\n * @return Counts for the instances of all compounds in the sequence\n */\n", "repo_name": "biojava-master/", "id": 2882, "method_signature": "Map<C,Integer> getComposition(Sequence)"}, "2900": {"callee_method_names": [], "method_name": "AbstractSequence.getBioBegin", "method_implementation": "{\n    if (bioBegin == null) {\n        return 1;\n    } else {\n        return bioBegin;\n    }\n}", "repo_id": "9", "comment": "/**\n * @return the bioBegin\n */\n", "repo_name": "biojava-master/", "id": 2900, "method_signature": "Integer getBioBegin()"}, "3009": {"callee_method_names": [], "method_name": "BitArrayWorker.processUnknownCompound", "method_implementation": "{\n    throw new IllegalStateException(\"Do not know how to translate the compound \" + compound + \" to a \" + bitsPerCompound() + \"bit representation\");\n}", "repo_id": "9", "comment": "/**\n * Since bit encoding only supports a finite number of bases\n * it is more than likely when processing sequence you will encounter a\n * compound which is not covered by the encoding e.g. N in a 2bit sequence.\n * You can override this to convert the unknown base into one you can\n * process or store locations of unknown bases for a level of post processing\n * in your subclass.\n *\n * @param compound Compound process\n * @return Byte representation of the compound\n * @throws IllegalStateException Done whenever this method is invoked\n */\n", "repo_name": "biojava-master/", "id": 3009, "method_signature": "byte processUnknownCompound(C, int)"}, "3705": {"callee_method_ids": [3756, 3752, 3736, 3741, 3718, 3706, 3724, 3707], "callee_method_names": ["WorkSheet.getRows", "WorkSheet.getColumns", "WorkSheet.addCell", "WorkSheet.getCell", "WorkSheet.setMetaDataColumns", "WorkSheet.getMetaDataColumns", "WorkSheet.setMetaDataRows", "WorkSheet.getMetaDataRows"], "method_name": "WorkSheet.getCopyWorkSheet", "method_implementation": "{\n    ArrayList<String> rows = copyWorkSheet.getRows();\n    ArrayList<String> columns = copyWorkSheet.getColumns();\n    WorkSheet workSheet = new WorkSheet(rows, columns);\n    for (String row : rows) {\n        for (String col : columns) {\n            workSheet.addCell(row, col, copyWorkSheet.getCell(row, col));\n        }\n    }\n    workSheet.setMetaDataColumns(copyWorkSheet.getMetaDataColumns());\n    workSheet.setMetaDataRows(copyWorkSheet.getMetaDataRows());\n    return workSheet;\n}", "repo_id": "9", "comment": "/**\n * Create a copy of a worksheet. If shuffling of columns or row for testing\n * a way to duplicate original worksheet\n *\n * @param copyWorkSheet\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3705, "method_signature": "WorkSheet getCopyWorkSheet(WorkSheet)"}, "3295": {"callee_method_names": [], "method_name": "AFPChainCoordManager.getPreferredWidth", "method_implementation": "{\n    return 2 * DEFAULT_X_SPACE + DEFAULT_LINE_LENGTH * DEFAULT_CHAR_SIZE + DEFAULT_LEGEND_SIZE + DEFAULT_RIGHT_SPACER + DEFAULT_LEGEND_SIZE;\n}", "repo_id": "9", "comment": "/**\n * X coordinate size\n *\n * @return the preferred width\n */\n", "repo_name": "biojava-master/", "id": 3295, "method_signature": "int getPreferredWidth()"}, "1611": {"callee_method_names": [], "method_name": "SubstructureIdentifier.toCanonical", "method_implementation": "{\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Return itself. SubstructureIdentifiers are canonical!\n */\n", "repo_name": "biojava-master/", "id": 1611, "method_signature": "SubstructureIdentifier toCanonical()"}, "3322": {"callee_method_names": ["JList.getSelectionBackground", "JList.getSelectionForeground", "JList.getBackground", "JList.getForeground", "Map<String, ContinuousColorMapper>.get", "GradientPanel.setPreferredSize", "JPanel.removeAll", "JPanel.add", "JLabel.setText"], "method_name": "GradientRenderer.getListCellRendererComponent", "method_implementation": "{\n    //Get the selected index. (The index param isn't\n    //always valid, so just use the value.)\n    String gradientLabel = (String) value;\n    if (isSelected) {\n        setBackground(list.getSelectionBackground());\n        setForeground(list.getSelectionForeground());\n    } else {\n        setBackground(list.getBackground());\n        setForeground(list.getForeground());\n    }\n    //Set the icon and text.  If icon was null, say so.\n    GradientPanel gradPanel = new GradientPanel(gradients.get(gradientLabel), min, max);\n    gradPanel.setPreferredSize(new Dimension(100, 20));\n    //gradPanel.setBorder(BorderFactory.createLineBorder(Color.cyan));\n    gradientContainer.removeAll();\n    gradientContainer.add(gradPanel, BorderLayout.CENTER);\n    title.setText(gradientLabel);\n    this.validate();\n    return this;\n}", "repo_id": "9", "comment": "/*\n\t\t * This method finds the image and text corresponding\n\t\t * to the selected value and returns the label, set up\n\t\t * to display the text and image.\n\t\t */\n", "repo_name": "biojava-master/", "id": 3322, "method_signature": "Component getListCellRendererComponent(JList, Object, int, boolean, boolean)"}, "2232": {"callee_method_names": ["Structure.toMMCIF", "String.split", "int[].startsWith"], "method_name": "TestMMCIFWriting.testBiounitWriting", "method_implementation": "{\n    Structure s = createDummyStructure();\n    String mmcif = s.toMMCIF();\n    String[] lines = mmcif.split(\"\\n\");\n    long atomLines = Arrays.stream(lines).filter(l -> l.startsWith(\"ATOM\")).count();\n    assertNotNull(mmcif);\n    assertEquals(4, atomLines);\n}", "repo_id": "9", "comment": "/**\n * Tests that structures containing symmetry mates with modified chain identifiers\n * can be written out correctly.\n */\n", "repo_name": "biojava-master/", "id": 2232, "method_signature": "void testBiounitWriting()"}, "2983": {"callee_method_names": [], "method_name": "BitSequenceReader.setCompoundSet", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Cannot reset the CompoundSet; object is immutable\");\n}", "repo_id": "9", "comment": "/**\n * Class is immutable & so this is unsupported\n */\n", "repo_name": "biojava-master/", "id": 2983, "method_signature": "void setCompoundSet(CompoundSet)"}, "509": {"callee_method_names": [], "method_name": "AFPChain.setDescription2", "method_implementation": "{\n    this.description2 = desc;\n}", "repo_id": "9", "comment": "/**\n * Set the textual description for protein 2.\n *\n * @param desc\n */\n", "repo_name": "biojava-master/", "id": 509, "method_signature": "void setDescription2(String)"}, "3543": {"callee_method_names": [], "method_name": "CoxCoefficient.setStdError", "method_implementation": "{\n    this.stdError = stdError;\n}", "repo_id": "9", "comment": "/**\n * @param stdError the stdError to set\n */\n", "repo_name": "biojava-master/", "id": 3543, "method_signature": "void setStdError(double)"}, "1119": {"callee_method_names": [], "method_name": "SiftsChainEntry.getSeqresEnd", "method_implementation": "{\n    return seqresEnd;\n}", "repo_id": "9", "comment": "/**\n * @return A residue number\n */\n", "repo_name": "biojava-master/", "id": 1119, "method_signature": "String getSeqresEnd()"}, "2517": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getMatrixFromAAINDEX", "method_implementation": "{\n    return AAindexFactory.getAAIndexProvider().getMatrix(matrixName);\n}", "repo_id": "9", "comment": "/**\n * Returns any matrix from the AAINDEX database file\n *\n * @param matrixName\n * @return a {@link SubstitutionMatrix}\n */\n", "repo_name": "biojava-master/", "id": 2517, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getMatrixFromAAINDEX(String)"}, "1956": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getSymDeviation", "method_implementation": "{\n    return symDeviation;\n}", "repo_id": "9", "comment": "/**\n * @return the symDeviation\n */\n", "repo_name": "biojava-master/", "id": 1956, "method_signature": "double getSymDeviation()"}, "3475": {"callee_method_names": [], "method_name": "NCBIQBlastService.getEmail", "method_implementation": "{\n    return this.email;\n}", "repo_id": "9", "comment": "/**\n * Get the email for QBlast. Defaults to {@value #DEFAULT_EMAIL}.\n *\n * @return the email\n */\n", "repo_name": "biojava-master/", "id": 3475, "method_signature": "String getEmail()"}, "563": {"callee_method_names": [], "method_name": "RotationAxis.guessOrderFromAngle", "method_implementation": "{\n    double bestDelta = threshold;\n    int bestOrder = 1;\n    for (int order = 2; order < maxOrder; order++) {\n        double delta = Math.abs(2 * Math.PI / order - theta);\n        if (delta < bestDelta) {\n            bestOrder = order;\n            bestDelta = delta;\n        }\n    }\n    return bestOrder;\n}", "repo_id": "9", "comment": "/**\n * Returns the rotation order o that gives the lowest value of {@code |2PI / o - theta},\n * given that the value is strictly lower than {@code threshold}, for orders {@code o=1,...,maxOrder}.\n */\n", "repo_name": "biojava-master/", "id": 563, "method_signature": "int guessOrderFromAngle(double, int)"}, "854": {"callee_method_names": ["TreeMap<Key, Value>.remove", "TreeMap<Key, Value>.put"], "method_name": "SymbolTable.put", "method_implementation": "{\n    if (val == null)\n        st.remove(key);\n    else\n        st.put(key, val);\n}", "repo_id": "9", "comment": "/**\n * Put key-value pair into the symbol table. Remove key from table if\n * value is null.\n */\n", "repo_name": "biojava-master/", "id": 854, "method_signature": "void put(Key, Value)"}, "140": {"callee_method_ids": [449, 452, 451], "callee_method_names": ["QsAlignResult.length", "QsAlignResult.getRelation", "QsAlignResult.getRmsd"], "method_name": "TestQsAlignExamples.testHeteroEquivalent", "method_implementation": "{\n    Structure s1 = StructureIO.getStructure(\"2vml\");\n    Structure s2 = StructureIO.getStructure(\"2bv8\");\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n    QsAlignParameters alignParams = new QsAlignParameters();\n    QsAlignResult result = QsAlign.align(s1, s2, clusterParams, alignParams);\n    assertEquals(result.length(), 12);\n    assertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n    assertTrue(result.getRmsd() < 10.0);\n}", "repo_id": "9", "comment": "/**\n * Phycocyanins (2VML, 2BV8) are equivalent D3 heterododecamers with A6B6\n * stoichiometry.\n */\n", "repo_name": "biojava-master/", "id": 140, "method_signature": "void testHeteroEquivalent()"}, "1219": {"callee_method_names": ["URL.openStream"], "method_name": "ChemCompConverter.fromURL", "method_implementation": "{\n    return fromInputStream(url.openStream());\n}", "repo_id": "9", "comment": "/**\n * Get data from a URL and convert to chem comp dictionary.\n * @param url the source of information - can be gzipped or binary or text data\n * @return the target\n * @throws IOException thrown when reading fails\n */\n", "repo_name": "biojava-master/", "id": 1219, "method_signature": "ChemicalComponentDictionary fromURL(URL)"}, "807": {"callee_method_ids": [820, 817, 818, 824, 825], "callee_method_names": ["AlternativeAlignment.apairs_from_idxlst", "AlternativeAlignment.getIdx1", "AlternativeAlignment.getIdx2", "AlternativeAlignment.calculateSuperpositionByIdx", "AlternativeAlignment.getRotationMatrix", "AlternativeAlignment.getShift"], "method_name": "FragmentJoiner.getRMS", "method_implementation": "{\n    //      now svd ftmp and check if the rms is < X ...\n    AlternativeAlignment ali = new AlternativeAlignment();\n    ali.apairs_from_idxlst(frag);\n    double rms = 999;\n    int[] idx1 = ali.getIdx1();\n    int[] idx2 = ali.getIdx2();\n    Atom[] ca1subset = AlignUtils.getFragmentFromIdxList(ca1, idx1);\n    Atom[] ca2subset = AlignUtils.getFragmentFromIdxList(ca2, idx2);\n    ali.calculateSuperpositionByIdx(ca1, ca2);\n    Matrix rot = ali.getRotationMatrix();\n    Atom atom = ali.getShift();\n    for (Atom a : ca2subset) {\n        Calc.rotate(a, rot);\n        Calc.shift(a, atom);\n    }\n    rms = Calc.rmsd(ca1subset, ca2subset);\n    return rms;\n}", "repo_id": "9", "comment": "/**\n * Get the RMS of the JointFragments pair frag\n *\n * @param ca1 the array of all atoms of structure1\n * @param ca2 the array of all atoms of structure1\n * @param frag the JointFragments object that contains the list of identical positions\n * @return the rms\n */\n", "repo_name": "biojava-master/", "id": 807, "method_signature": "double getRMS(Atom[], Atom[], JointFragments)"}, "3245": {"callee_method_names": [], "method_name": "AlignmentCalc.setNrCPUs", "method_implementation": "{\n    // TODO Auto-generated method stub\n    //\n}", "repo_id": "9", "comment": "/**\n * does not do anything here...\n */\n", "repo_name": "biojava-master/", "id": 3245, "method_signature": "void setNrCPUs(int)"}, "435": {"callee_method_names": [], "method_name": "FatCatParameters.setOptimizeAlignment", "method_implementation": "{\n    this.optimizeAlignment = optimizeAlignment;\n}", "repo_id": "9", "comment": "/**\n * Whether the alignment algorithm should try its best to optimize the alignment,\n * or we are happy with a quick and dirty result.\n * NB: Not implemented in jFatCat\n *\n * @param optimizeAlignment\n */\n", "repo_name": "biojava-master/", "id": 435, "method_signature": "void setOptimizeAlignment(boolean)"}, "1519": {"callee_method_names": ["Matrix.set", "Matrix4d.getElement"], "method_name": "Matrices.getRotationJAMA", "method_implementation": "{\n    Matrix rot = new Matrix(3, 3);\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            // transposed\n            rot.set(j, i, transform.getElement(i, j));\n        }\n    }\n    return rot;\n}", "repo_id": "9", "comment": "/**\n * Convert a transformation matrix into a JAMA rotation matrix. Because the\n * JAMA matrix is a pre-multiplication matrix and the Vecmath matrix is a\n * post-multiplication one, the rotation matrix is transposed to ensure that\n * the transformation they produce is the same.\n *\n * @param transform\n *            Matrix4d with transposed rotation matrix\n * @return rotation matrix as JAMA object\n */\n", "repo_name": "biojava-master/", "id": 1519, "method_signature": "Matrix getRotationJAMA(Matrix4d)"}, "774": {"callee_method_names": ["AFPChain.setName2", "Atom[].getGroup"], "method_name": "CeCPMain.alignRight", "method_implementation": "{\n    long startTime = System.currentTimeMillis();\n    Atom[] ca2m = StructureTools.duplicateCA2(ca2);\n    if (debug) {\n        System.out.format(\"Duplicating ca2 took %s ms\\n\", System.currentTimeMillis() - startTime);\n        startTime = System.currentTimeMillis();\n    }\n    // Do alignment\n    AFPChain afpChain = super.align(ca1, ca2m, params);\n    // since the process of creating ca2m strips the name info away, set it explicitely\n    try {\n        afpChain.setName2(ca2[0].getGroup().getChain().getStructure().getName());\n    } catch (Exception e) {\n    }\n    if (debug) {\n        System.out.format(\"Running %dx2*%d alignment took %s ms\\n\", ca1.length, ca2.length, System.currentTimeMillis() - startTime);\n        startTime = System.currentTimeMillis();\n    }\n    afpChain = postProcessAlignment(afpChain, ca1, ca2m, calculator, cpparams);\n    if (debug) {\n        System.out.format(\"Finding CP point took %s ms\\n\", System.currentTimeMillis() - startTime);\n        startTime = System.currentTimeMillis();\n    }\n    return afpChain;\n}", "repo_id": "9", "comment": "/**\n * Aligns the structures, duplicating ca2 regardless of\n * {@link CECPParameters.getDuplicationHint() param.getDuplicationHint}.\n * @param ca1\n * @param ca2\n * @param cpparams\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 774, "method_signature": "AFPChain alignRight(Atom[], Atom[], CECPParameters)"}, "1751": {"callee_method_names": ["List<Chain>.size", "List<Chain>.get", "Chain.getAtomSequence", "String.length", "List<Chain>.size", "List<Chain>.get", "Chain.getAtomSequence", "Chain.getAtomSequence", "Chain.getAtomSequence", "Chain.getAtomSequence", "String.charAt", "String.charAt", "Chain.getAtomGroup", "Chain.getAtomGroup", "Map<String, Integer>.get", "Group.getPDBName", "Map<String, Integer>.get", "Group.getPDBName", "Group.getAtom", "Group.getAtom", "Atom.getCoordsAsPoint3d", "Atom.getCoordsAsPoint3d", "List<Pair<Group>>.add", "ArrayList.add", "String.length", "String.charAt", "String.length", "Chain.getAtomSequence"], "method_name": "MismatchedBasePairParameters.findPairs", "method_implementation": "{\n    List<Pair<Group>> result = new ArrayList<>();\n    boolean lastFoundPair = false;\n    for (int i = 0; i < chains.size(); i++) {\n        Chain c = chains.get(i);\n        String sequence = c.getAtomSequence();\n        for (int m = 0; m < sequence.length(); m++) {\n            boolean foundPair = false;\n            Integer type1, type2;\n            for (int j = i + 1; j < chains.size() && !foundPair; j++) {\n                Chain c2 = chains.get(j);\n                if (j > i + 1 && c.getAtomSequence().equals(c2.getAtomSequence()) && nonredundant)\n                    continue;\n                String sequence2 = c2.getAtomSequence();\n                for (int k = c2.getAtomSequence().length() - 1; k >= 0 && !foundPair; k--) {\n                    if (canonical && !BasePairParameters.match(sequence.charAt(m), sequence2.charAt(k), useRNA))\n                        continue;\n                    Group g1 = c.getAtomGroup(m);\n                    Group g2 = c2.getAtomGroup(k);\n                    type1 = BASE_MAP.get(g1.getPDBName());\n                    type2 = BASE_MAP.get(g2.getPDBName());\n                    if (type1 == null || type2 == null)\n                        continue;\n                    Atom a1 = g1.getAtom(\"C1'\");\n                    Atom a2 = g2.getAtom(\"C1'\");\n                    if (a1 == null || a2 == null)\n                        continue;\n                    // C1'-C1' distance is one useful criteria\n                    if (Math.abs(a1.getCoordsAsPoint3d().distance(a2.getCoordsAsPoint3d()) - 10.0) > 4.0)\n                        continue;\n                    Pair<Group> ga = new Pair<>(g1, g2);\n                    // TODO is this call needed?? JD 2018-03-07\n                    @SuppressWarnings(\"unused\")\n                    Matrix4d data = basePairReferenceFrame(ga);\n                    // if the stagger is greater than 2 \u00c5, it's not really paired.\n                    if (Math.abs(pairParameters[5]) > maxStagger)\n                        continue;\n                    // similarly, extreme shear and stretch is not a good base pair\n                    if (Math.abs(pairParameters[3]) > maxShear)\n                        continue;\n                    if (Math.abs(pairParameters[4]) > maxStretch)\n                        continue;\n                    // if the propeller is ridiculous it's also not that good of a pair.\n                    if (Math.abs(pairParameters[1]) > maxPropeller) {\n                        continue;\n                    }\n                    result.add(ga);\n                    pairingNames.add(useRNA ? BASE_LIST_RNA[type1] + BASE_LIST_RNA[type2] : BASE_LIST_DNA[type1] + BASE_LIST_DNA[type2]);\n                    foundPair = true;\n                }\n                if (!foundPair && lastFoundPair) {\n                    if (pairSequence.length() > 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                }\n                if (foundPair)\n                    pairSequence += (c.getAtomSequence().charAt(i));\n                lastFoundPair = foundPair;\n            }\n        }\n    }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * This is an implementation for finding non-canonical base pairs when there may be missing or overhanging bases.\n * @param chains The list of chains already found to be nucleic acids.\n * @return The list of the atom groups (residues) that are pairs, as a Pair of nucleic acid Groups.\n */\n", "repo_name": "biojava-master/", "id": 1751, "method_signature": "List<Pair<Group>> findPairs(List)"}, "2964": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.getLastIndexOf", "method_implementation": "{\n    return this.parsedCompounds.lastIndexOf(compound) + 1;\n}", "repo_id": "9", "comment": "/**\n * @param compound\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2964, "method_signature": "int getLastIndexOf(C)"}, "3281": {"callee_method_names": ["ColorBrewer.getColorPalette", "MultipleAlignment.size", "StringBuffer.append", "StringBuffer.append", "MultipleAlignment.size", "List<Atom[]>.get", "List<List<String>>.add", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "Color[].getRed", "Color[].getGreen", "Color[].getBlue", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.toString"], "method_name": "MultipleAlignmentJmol.getJmolString", "method_implementation": "{\n    // Color by blocks if specified\n    if (colorByBlocks)\n        return getMultiBlockJmolString(multAln, transformedAtoms, colorPalette, colorByBlocks);\n    Color[] colors = colorPalette.getColorPalette(multAln.size());\n    StringBuffer j = new StringBuffer();\n    j.append(DEFAULT_SCRIPT);\n    // Color the equivalent residues of every structure\n    StringBuffer sel = new StringBuffer();\n    sel.append(\"select *; color lightgrey; backbone 0.1; \");\n    List<List<String>> allPDB = new ArrayList<List<String>>();\n    // Get the aligned residues of every structure\n    for (int i = 0; i < multAln.size(); i++) {\n        List<String> pdb = MultipleAlignmentJmolDisplay.getPDBresnum(i, multAln, transformedAtoms.get(i));\n        allPDB.add(pdb);\n        sel.append(\"select \");\n        int pos = 0;\n        for (String res : pdb) {\n            if (pos > 0)\n                sel.append(\",\");\n            pos++;\n            sel.append(res);\n            sel.append(\"/\" + (i + 1));\n        }\n        if (pos == 0)\n            sel.append(\"none\");\n        sel.append(\"; backbone 0.3 ; color [\" + colors[i].getRed() + \",\" + colors[i].getGreen() + \",\" + colors[i].getBlue() + \"]; \");\n    }\n    j.append(sel);\n    j.append(\"model 0;  \");\n    j.append(LIGAND_DISPLAY_SCRIPT);\n    return j.toString();\n}", "repo_id": "9", "comment": "/**\n * Generate a Jmol command String that colors the aligned residues of every\n * structure.\n */\n", "repo_name": "biojava-master/", "id": 3281, "method_signature": "String getJmolString(MultipleAlignment, List, ColorBrewer, boolean)"}, "3287": {"callee_method_names": ["Logger.debug", "List<Group>.size", "Atom.setGroup", "List<Atom>.add", "List<Atom>.toArray", "List<Atom>.size"], "method_name": "DisplayAFP.getAtomArray", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<Atom>();\n    Collections.addAll(atoms, ca);\n    logger.debug(\"got {} hetatoms\", hetatms.size());\n    // we only add atom nr 1, since the getAlignedStructure method actually adds the parent group, and not the atoms...\n    for (Group g : hetatms) {\n        if (g.size() < 1)\n            continue;\n        //if (debug)\n        //   System.out.println(\"adding group \" + g);\n        Atom a = g.getAtom(0);\n        //if (debug)\n        //  System.out.println(a);\n        a.setGroup(g);\n        atoms.add(a);\n    }\n    Atom[] arr = atoms.toArray(new Atom[atoms.size()]);\n    return arr;\n}", "repo_id": "9", "comment": "/**\n * Returns the first atom for each group\n * @param ca\n * @param hetatms\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3287, "method_signature": "Atom[] getAtomArray(Atom[], List)"}, "3469": {"callee_method_ids": [3476], "callee_method_names": ["RemotePairwiseAlignmentOutputProperties.getOutputOptions", "Map<String, String>.put", "RemotePairwiseAlignmentOutputProperties.getOutputOption", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "MapToStringTransformer.transform", "URL.openConnection", "URLConnection.getOutputStream", "OutputStreamWriter.write", "OutputStreamWriter.flush", "URLConnection.getInputStream"], "method_name": "NCBIQBlastService.getAlignmentResults", "method_implementation": "{\n    Map<String, String> params = new HashMap<String, String>();\n    for (String key : outputProperties.getOutputOptions()) {\n        params.put(key, outputProperties.getOutputOption(key));\n    }\n    OutputStreamWriter writer = null;\n    while (!isReady(id)) {\n        Thread.sleep(WAIT_INCREMENT + 100);\n    }\n    params.put(CMD.name(), \"Get\");\n    params.put(RID.name(), id);\n    params.put(TOOL.name(), getTool());\n    params.put(EMAIL.name(), getEmail());\n    String getCmd = MAP_TO_STRING_TRANSFORMER.transform(params);\n    try {\n        URLConnection serviceConnection = setQBlastServiceProperties(serviceUrl.openConnection());\n        writer = new OutputStreamWriter(serviceConnection.getOutputStream());\n        writer.write(getCmd);\n        writer.flush();\n        return serviceConnection.getInputStream();\n    } catch (IOException ioe) {\n        throw new Exception(\"It is not possible to fetch Blast report from NCBI at this time. Cause: \" + ioe.getMessage(), ioe);\n    } finally {\n        IOUtils.close(writer);\n    }\n}", "repo_id": "9", "comment": "/**\n * Extracts the actual Blast report for given request id according to options provided in {@code outputProperties}\n * argument.\n * <p/>\n * If the results are not ready yet, sleeps until they are available. If sleeping is not desired, call this method\n * after {@code isReady} returns true\n *\n * @param id : request id, which was returned by {@code sendAlignmentRequest} method\n * @param outputProperties : an object specifying output formatting options\n * @return an {@code InputStream} of results\n * @throws Exception if it is not possible to recover the results\n */\n", "repo_name": "biojava-master/", "id": 3469, "method_signature": "InputStream getAlignmentResults(String, RemotePairwiseAlignmentOutputProperties)"}, "3249": {"callee_method_names": ["JDialog.setLocation"], "method_name": "JAutoSuggest.updateLocation", "method_implementation": "{\n    try {\n        location = getLocationOnScreen();\n        location.y += getHeight();\n        dialog.setLocation(location);\n    } catch (IllegalComponentStateException e) {\n        // might happen on window creation\n        return;\n    }\n}", "repo_id": "9", "comment": "/**\n * Place the suggestion window under the JTextField.\n */\n", "repo_name": "biojava-master/", "id": 3249, "method_signature": "void updateLocation()"}, "2109": {"callee_method_names": [], "method_name": "Axis.getRotationAxis", "method_implementation": "{\n    if (rotAxis == null) {\n        rotAxis = new RotationAxis(operator);\n    }\n    return rotAxis;\n}", "repo_id": "9", "comment": "/**\n * Get the transformation operator as a rotation axis. For open\n * symmetry this will have a non-zero screw component.\n * @return a RotationAxis for this Axis\n */\n", "repo_name": "biojava-master/", "id": 2109, "method_signature": "RotationAxis getRotationAxis()"}, "600": {"callee_method_ids": [487, 490, 489, 1334, 1334, 1334, 1334, 1334, 1334], "callee_method_names": ["AFPChain.getName1", "AFPChain.getName2", "AFPChain.getBlockNum", "AFPChain.getOptLen", "AFPChain.getOptAln", "Atom[].getGroup", "Atom[].getGroup", "ResidueNumber.getChainName", "ResidueNumber.toString", "ResidueNumber.getChainName", "ResidueNumber.toString", "Writer.write", "Atom[].getGroup", "ResidueNumber.getChainName", "ResidueNumber.toString", "Atom[].getGroup", "ResidueNumber.getChainName", "ResidueNumber.toString", "Writer.write", "String.equals", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "ResidueNumber.getChainName", "ResidueNumber.toString", "Atom[].getGroup", "ResidueNumber.getChainName", "ResidueNumber.toString", "Writer.write"], "method_name": "AlignmentTools.alignmentToSIF", "method_implementation": "{\n    //out.write(\"Res1\\tInteraction\\tRes2\\n\");\n    String name1 = afpChain.getName1();\n    String name2 = afpChain.getName2();\n    if (name1 == null)\n        name1 = \"\";\n    else\n        name1 += \":\";\n    if (name2 == null)\n        name2 = \"\";\n    else\n        name2 += \":\";\n    // Print alignment edges\n    int nblocks = afpChain.getBlockNum();\n    int[] blockLen = afpChain.getOptLen();\n    int[][][] optAlign = afpChain.getOptAln();\n    for (int b = 0; b < nblocks; b++) {\n        for (int r = 0; r < blockLen[b]; r++) {\n            int res1 = optAlign[b][0][r];\n            int res2 = optAlign[b][1][r];\n            ResidueNumber rn1 = ca1[res1].getGroup().getResidueNumber();\n            ResidueNumber rn2 = ca2[res2].getGroup().getResidueNumber();\n            String node1 = name1 + rn1.getChainName() + rn1.toString();\n            String node2 = name2 + rn2.getChainName() + rn2.toString();\n            out.write(String.format(\"%s\\t%s\\t%s\\n\", node1, alignmentInteraction, node2));\n        }\n    }\n    // Print first backbone edges\n    ResidueNumber rn = ca1[0].getGroup().getResidueNumber();\n    String last = name1 + rn.getChainName() + rn.toString();\n    for (int i = 1; i < ca1.length; i++) {\n        rn = ca1[i].getGroup().getResidueNumber();\n        String curr = name1 + rn.getChainName() + rn.toString();\n        out.write(String.format(\"%s\\t%s\\t%s\\n\", last, backboneInteraction, curr));\n        last = curr;\n    }\n    // Print second backbone edges, if the proteins differ\n    // Do some quick checks for whether the proteins differ\n    // (Not perfect, but should detect major differences and CPs.)\n    if (!name1.equals(name2) || ca1.length != ca2.length || (ca1.length > 0 && ca1[0].getGroup() != null && ca2[0].getGroup() != null && !ca1[0].getGroup().getResidueNumber().equals(ca2[0].getGroup().getResidueNumber()))) {\n        rn = ca2[0].getGroup().getResidueNumber();\n        last = name2 + rn.getChainName() + rn.toString();\n        for (int i = 1; i < ca2.length; i++) {\n            rn = ca2[i].getGroup().getResidueNumber();\n            String curr = name2 + rn.getChainName() + rn.toString();\n            out.write(String.format(\"%s\\t%s\\t%s\\n\", last, backboneInteraction, curr));\n            last = curr;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Creates a simple interaction format (SIF) file for an alignment.\n *\n * The SIF file can be read by network software (eg Cytoscape) to analyze\n * alignments as graphs.\n *\n * This function creates a graph with residues as nodes and two types of edges:\n *   1. backbone edges, which connect adjacent residues in the aligned protein\n *   2. alignment edges, which connect aligned residues\n *\n * @param out Stream to write to\n * @param afpChain alignment to write\n * @param ca1 First protein, used to generate node names\n * @param ca2 Second protein, used to generate node names\n * @param backboneInteraction Two-letter string used to identify backbone edges\n * @param alignmentInteraction Two-letter string used to identify alignment edges\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 600, "method_signature": "void alignmentToSIF(Writer, AFPChain, Atom[], Atom[], String, String)"}, "3275": {"callee_method_names": ["JFrame.getTitle"], "method_name": "AbstractAlignmentJmol.getTitle", "method_implementation": "{\n    return frame.getTitle();\n}", "repo_id": "9", "comment": "/**\n * Return the title of the AlignmentJmol window.\n */\n", "repo_name": "biojava-master/", "id": 3275, "method_signature": "String getTitle()"}, "3697": {"callee_method_names": [], "method_name": "SurvFitInfo.setWeighted", "method_implementation": "{\n    this.weighted = weighted;\n}", "repo_id": "9", "comment": "/**\n * @param weighted the weighted to set\n */\n", "repo_name": "biojava-master/", "id": 3697, "method_signature": "void setWeighted(boolean)"}, "1581": {"callee_method_names": [], "method_name": "SecStrucElement.getType", "method_implementation": "{\n    return type;\n}", "repo_id": "9", "comment": "/**\n * Returns the {@link SecStrucType} of this element.\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1581, "method_signature": "SecStrucType getType()"}, "3808": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getTimeAxisIncrementPercentage", "method_implementation": "{\n    return adjustedPercentIncrement;\n}", "repo_id": "9", "comment": "/**\n * Get the percentage increment for the time axis\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3808, "method_signature": "Double getTimeAxisIncrementPercentage()"}, "310": {"callee_method_names": [], "method_name": "Component.lazyInit", "method_implementation": "{\n    if (components == null) {\n        components = new HashSet<Component>();\n        nonTerminalComps = new HashMap<Set<String>, Component>();\n        nTerminalAminoAcids = new HashMap<Set<String>, Component>();\n        cTerminalAminoAcids = new HashMap<Set<String>, Component>();\n    }\n}", "repo_id": "9", "comment": "/**\n * Lazy initialization of the static variables.\n */\n", "repo_name": "biojava-master/", "id": 310, "method_signature": "void lazyInit()"}, "1210": {"callee_method_names": [], "method_name": "CifStructureConverter.toBinaryFile", "method_implementation": "{\n    CifIO.writeBinary(toCifFile(structure), path);\n}", "repo_id": "9", "comment": "/**\n * Write a structure to a BCIF file.\n * @param structure the source\n * @param path where to write to\n * @throws IOException thrown when writing fails\n */\n", "repo_name": "biojava-master/", "id": 1210, "method_signature": "void toBinaryFile(Structure, Path)"}, "2158": {"callee_method_names": [], "method_name": "StructureImpl.setBiologicalAssembly", "method_implementation": "{\n    this.biologicalAssembly = biologicalAssembly;\n}", "repo_id": "9", "comment": "/**\n * Sets a flag to indicate if this structure is a biological assembly\n * @param biologicalAssembly true if biological assembly, otherwise false\n * @since 3.2\n */\n", "repo_name": "biojava-master/", "id": 2158, "method_signature": "void setBiologicalAssembly(boolean)"}, "2613": {"callee_method_names": [], "method_name": "ConcurrencyTools.setThreadPool", "method_implementation": "{\n    if (ConcurrencyTools.pool != pool) {\n        shutdown();\n        ConcurrencyTools.pool = pool;\n    }\n}", "repo_id": "9", "comment": "/**\n * Sets thread pool to any given {@link ThreadPoolExecutor} to allow use of an alternative execution style.\n *\n * @param pool thread pool to share\n */\n", "repo_name": "biojava-master/", "id": 2613, "method_signature": "void setThreadPool(ThreadPoolExecutor)"}, "3642": {"callee_method_names": [], "method_name": "CoxInfo.setWaldTestInfo", "method_implementation": "{\n    this.waldTestInfo = waldTestInfo;\n}", "repo_id": "9", "comment": "/**\n * @param waldTestInfo the waldTestInfo to set\n */\n", "repo_name": "biojava-master/", "id": 3642, "method_signature": "void setWaldTestInfo(WaldTestInfo)"}, "2261": {"callee_method_names": [], "method_name": "TestMmtfUtils.testEmptyNcsMatrix", "method_implementation": "{\n    double[][] testData = new double[0][0];\n    testInput(testData);\n    double[][] output = MmtfUtils.getNcsAsArray(new Matrix4d[0]);\n    assertNotNull(output);\n}", "repo_id": "9", "comment": "/**\n * Test that the NCS data can be roundtripped.\n */\n", "repo_name": "biojava-master/", "id": 2261, "method_signature": "void testEmptyNcsMatrix()"}, "856": {"callee_method_names": ["TreeMap<Key, Value>.remove"], "method_name": "SymbolTable.delete", "method_implementation": "{\n    return st.remove(key);\n}", "repo_id": "9", "comment": "/**\n * Delete the key (and paired value) from table.\n * Return the value paired with given key; null if key is not in table.\n */\n", "repo_name": "biojava-master/", "id": 856, "method_signature": "Value delete(Key)"}, "2532": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum85", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum85\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 85 matrix by Henikoff & Henikoff\n * @return Blosum 85 matrix\n */\n", "repo_name": "biojava-master/", "id": 2532, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum85()"}, "1036": {"callee_method_names": ["Atom.getGroup", "Group.getChain", "Chain.getName", "Chain.getName", "Chain.setId", "Chain.getId", "Chain.setName", "Chain.getName", "List<Chain>.add", "Group.clone", "Group.getAtom", "Atom.getName", "Chain.getGroupByPDB", "Group.getResidueNumber", "Chain.addGroup"], "method_name": "StructureTools.cloneAtomArray", "method_implementation": "{\n    Atom[] newCA = new Atom[ca.length];\n    List<Chain> model = new ArrayList<Chain>();\n    int apos = -1;\n    for (Atom a : ca) {\n        apos++;\n        Group parentG = a.getGroup();\n        Chain parentC = parentG.getChain();\n        Chain newChain = null;\n        for (Chain c : model) {\n            if (c.getName().equals(parentC.getName())) {\n                newChain = c;\n                break;\n            }\n        }\n        if (newChain == null) {\n            newChain = new ChainImpl();\n            newChain.setId(parentC.getId());\n            newChain.setName(parentC.getName());\n            model.add(newChain);\n        }\n        Group parentN = (Group) parentG.clone();\n        newCA[apos] = parentN.getAtom(a.getName());\n        try {\n            // if the group doesn't exist yet, this produces a StructureException\n            newChain.getGroupByPDB(parentN.getResidueNumber());\n        } catch (StructureException e) {\n            // the group doesn't exist yet in the newChain, let's add it\n            newChain.addGroup(parentN);\n        }\n    }\n    return newCA;\n}", "repo_id": "9", "comment": "/**\n * Provides an equivalent copy of Atoms in a new array. Clones everything,\n * starting with parent groups and chains. The chain will only contain\n * groups that are part of the input array.\n *\n * @param ca\n *            array of representative atoms, e.g. CA atoms\n * @return Atom array\n * @since Biojava 4.1.0\n */\n", "repo_name": "biojava-master/", "id": 1036, "method_signature": "Atom[] cloneAtomArray(Atom[])"}, "2742": {"callee_method_names": [], "method_name": "EmblRecord.getFeatureTable", "method_implementation": "{\n    return featureTable;\n}", "repo_id": "9", "comment": "/**\n * The FT (Feature Table) lines provide a mechanism for the annotation of the\n * sequence data. Regions or sites in the sequence which are of interest are\n * listed in the table.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2742, "method_signature": "String getFeatureTable()"}, "3084": {"callee_method_names": [], "method_name": "AbstractFeature.setParentFeature", "method_implementation": "{\n    parentFeature = feature;\n}", "repo_id": "9", "comment": "/**\n * A feature can be the child or contained by a parent feature. An example is a Helix feature could contain\n * children features. A PFAM domain could contain secondary structures.\n * @param feature\n */\n", "repo_name": "biojava-master/", "id": 3084, "method_signature": "void setParentFeature(FeatureInterface)"}, "1912": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.setLocalTimeLimit", "method_implementation": "{\n    this.localTimeLimit = localTimeLimit;\n}", "repo_id": "9", "comment": "/**\n * @param localTimeLimit\n *            the localTimeLimit to set\n */\n", "repo_name": "biojava-master/", "id": 1912, "method_signature": "void setLocalTimeLimit(double)"}, "1773": {"callee_method_names": [], "method_name": "PDBHeader.getResolution", "method_implementation": "{\n    return resolution;\n}", "repo_id": "9", "comment": "/**\n * Returns the resolution (or effective resolution) of the experiment. This is\n * related to <code>_refine.ls_d_res_high</code> (DIFFRACTION) or\n * <code>_em_3d_reconstruction.resolution</code> (ELECTRON MICROSCOPY) for mmCif\n * format, or to <code>REMARK 2</code> or <code>REMARK 3</code> for PDB legacy\n * format. If more than one value is available (in rare cases), the last one is\n * reported. If no value is available, it defaults to\n * {@link #DEFAULT_RESOLUTION} ({@value #DEFAULT_RESOLUTION}).\n *\n * @return The reported experiment resolution, {@link #DEFAULT_RESOLUTION}\n *         ({@value #DEFAULT_RESOLUTION}) if no value is available.\n */\n", "repo_name": "biojava-master/", "id": 1773, "method_signature": "float getResolution()"}, "3735": {"callee_method_names": ["Object.getClass"], "method_name": "WorkSheet.resizeArray", "method_implementation": "{\n    int oldSize = java.lang.reflect.Array.getLength(oldArray);\n    Class<?> elementType = oldArray.getClass().getComponentType();\n    Object newArray = java.lang.reflect.Array.newInstance(elementType, newSize);\n    int preserveLength = Math.min(oldSize, newSize);\n    if (preserveLength > 0) {\n        System.arraycopy(oldArray, 0, newArray, 0, preserveLength);\n    }\n    return newArray;\n}", "repo_id": "9", "comment": "/**\n * Reallocates an array with a new size, and copies the contents of the old\n * array to the new array.\n *\n * @param oldArray the old array, to be reallocated.\n * @param newSize the new array size.\n * @return A new array with the same contents.\n */\n", "repo_name": "biojava-master/", "id": 3735, "method_signature": "Object resizeArray(Object, int)"}, "2343": {"callee_method_names": ["String.length"], "method_name": "FastqBuilder.withSequence", "method_implementation": "{\n    if (sequence == null) {\n        throw new IllegalArgumentException(\"sequence must not be null\");\n    }\n    if (this.sequence == null) {\n        this.sequence = new StringBuilder(sequence.length());\n    }\n    this.sequence.replace(0, this.sequence.length(), sequence);\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Return this FASTQ formatted sequence builder configured with the specified sequence.\n *\n * @param sequence sequence for this FASTQ formatted sequence builder, must not be null\n * @return this FASTQ formatted sequence builder configured with the specified sequence\n */\n", "repo_name": "biojava-master/", "id": 2343, "method_signature": "FastqBuilder withSequence(String)"}, "3558": {"callee_method_names": [], "method_name": "CoxVariables.getCohortName", "method_implementation": "{\n    return cohortName;\n}", "repo_id": "9", "comment": "/**\n * @return the cohortName\n */\n", "repo_name": "biojava-master/", "id": 3558, "method_signature": "String getCohortName()"}, "858": {"callee_method_names": ["TreeMap<Key, Value>.size"], "method_name": "SymbolTable.size", "method_implementation": "{\n    return st.size();\n}", "repo_id": "9", "comment": "/**\n * How many keys are in the table?\n */\n", "repo_name": "biojava-master/", "id": 858, "method_signature": "int size()"}, "1583": {"callee_method_ids": [1716], "callee_method_names": ["ResidueRangeAndLength.getLength"], "method_name": "SecStrucElement.getLength", "method_implementation": "{\n    return range.getLength();\n}", "repo_id": "9", "comment": "/**\n * Return the length (number of residues) in the SSE.\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1583, "method_signature": "int getLength()"}, "2821": {"callee_method_names": [], "method_name": "IOUtils.getPDBString", "method_implementation": "{\n    if (c1 == c2)\n        return web ? \"<span class=\\\"m\\\">\" + m + \"</span>\" : m;\n    else if (similar)\n        return web ? \"<span class=\\\"sm\\\">\" + sm + \"</span>\" : sm;\n    else if (c1 == '-' || c2 == '-')\n        return web ? \"<span class=\\\"dm\\\">\" + dm + \"</span>\" : dm;\n    else\n        return web ? \"<span class=\\\"qg\\\">\" + qg + \"</span>\" : qg;\n}", "repo_id": "9", "comment": "// helper method for getPDBCharacter and getPDBConservation\n", "repo_name": "biojava-master/", "id": 2821, "method_signature": "String getPDBString(boolean, char, char, boolean, String, String, String, String)"}, "2154": {"callee_method_names": ["List<Bond>.add"], "method_name": "StructureImpl.addSSBond", "method_implementation": "{\n    ssbonds.add(ssbond);\n}", "repo_id": "9", "comment": "/**\n * Adds a single disulfide Bond to this structure\n *\n * @param ssbond the SSBond.\n */\n", "repo_name": "biojava-master/", "id": 2154, "method_signature": "void addSSBond(Bond)"}, "3684": {"callee_method_names": [], "method_name": "CoxScore.main", "method_implementation": "{\n    // TODO code application logic here\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3684, "method_signature": "void main(String[])"}, "1389": {"callee_method_names": [], "method_name": "DBRef.setIdbnsEnd", "method_implementation": "{\n    this.idbnsEnd = idbnsEnd;\n}", "repo_id": "9", "comment": "/**\n *  Insertion code of the ending\n * \tresidue of the segment, if PDB is\n * \tthe reference.\n *  @param idbnsEnd the insertion code\n *  @see #setIdbnsEnd(char)\n */\n", "repo_name": "biojava-master/", "id": 1389, "method_signature": "void setIdbnsEnd(char)"}, "3646": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "SurvivalInfo.getOriginalMetaData", "method_implementation": "{\n    return originalMetaData.get(variable);\n}", "repo_id": "9", "comment": "/**\n * @param variable\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3646, "method_signature": "String getOriginalMetaData(String)"}, "212": {"callee_method_names": ["Pattern.matcher"], "method_name": "SequenceUtil.deepCleanSequence", "method_implementation": "{\n    sequence = SequenceUtil.cleanSequence(sequence);\n    sequence = SequenceUtil.DIGIT.matcher(sequence).replaceAll(\"\");\n    sequence = SequenceUtil.NONWORD.matcher(sequence).replaceAll(\"\");\n    final Pattern othernonSeqChars = Pattern.compile(\"[_-]+\");\n    sequence = othernonSeqChars.matcher(sequence).replaceAll(\"\");\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Removes all special characters and digits as well as whitespace chars\n * from the sequence\n *\n * @param sequence\n * @return cleaned up sequence\n */\n", "repo_name": "biojava-master/", "id": 212, "method_signature": "String deepCleanSequence(String)"}, "50": {"callee_method_names": [], "method_name": "Alignments.getProfileProfileAlignment", "method_implementation": "{\n    return getProfileProfileAligner(profile1, profile2, type, gapPenalty, subMatrix).getPair();\n}", "repo_id": "9", "comment": "/**\n * Factory method which computes a profile alignment for the given {@link Profile} pair.\n *\n * @param <S> each {@link Sequence} of the {@link Profile} pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param profile1 the first {@link Profile} to align\n * @param profile2 the second {@link Profile} to align\n * @param type chosen type from list of profile-profile alignment routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return alignment profile\n */\n", "repo_name": "biojava-master/", "id": 50, "method_signature": "ProfilePair<S,C> getProfileProfileAlignment(Profile, Profile, ProfileProfileAlignerType, GapPenalty, SubstitutionMatrix)"}, "2414": {"callee_method_names": [], "method_name": "Location.contains", "method_implementation": "{\n    if (isSameStrand(other)) {\n        return (mStart <= other.mStart && mEnd >= other.mEnd);\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Check if this location contains the other.\n *\n * @param other The location to compare.\n * @return True if other is entirely contained by this location.\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2414, "method_signature": "boolean contains(Location)"}, "3696": {"callee_method_names": [], "method_name": "SurvFitInfo.isWeighted", "method_implementation": "{\n    return weighted;\n}", "repo_id": "9", "comment": "/**\n * @return the weighted\n */\n", "repo_name": "biojava-master/", "id": 3696, "method_signature": "boolean isWeighted()"}, "74": {"callee_method_names": ["int[].add"], "method_name": "AnchoredPairwiseSequenceAligner.addAnchor", "method_implementation": "{\n    anchors.add(new Anchor(queryIndex, targetIndex));\n}", "repo_id": "9", "comment": "/**\n * Adds an additional anchor to the set of anchored compounds\n * @param queryIndex 0-based index of query sequence compound\n * @param targetIndex 0-base index of target sequence compound to anchor to\n */\n", "repo_name": "biojava-master/", "id": 74, "method_signature": "void addAnchor(int, int)"}, "3628": {"callee_method_names": [], "method_name": "CoxInfo.setRscore", "method_implementation": "{\n    this.rscore = rscore;\n    if (rscore != null) {\n        rscoreLogrankTestpvalue = ChiSq.chiSq(rscore, (int) degreeFreedom);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param rscore the rscore to set\n */\n", "repo_name": "biojava-master/", "id": 3628, "method_signature": "void setRscore(Double)"}, "3178": {"callee_method_names": [], "method_name": "ChromosomeSequence.getChromosomeNumber", "method_implementation": "{\n    return chromosomeNumber;\n}", "repo_id": "9", "comment": "/**\n * @return the chromosomeNumber\n */\n", "repo_name": "biojava-master/", "id": 3178, "method_signature": "int getChromosomeNumber()"}, "1768": {"callee_method_names": [], "method_name": "PDBHeader.setPdbId", "method_implementation": "{\n    this.pdbId = pdbId;\n}", "repo_id": "9", "comment": "/**\n * Sets the PDB identifier code for this protein structure.\n *\n * @param pdbId the PDB identifier\n * @see #getPdbId()\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 1768, "method_signature": "void setPdbId(PdbId)"}, "1545": {"callee_method_names": ["String.length", "String.substring", "String.toLowerCase", "double[].getScopId", "List<ScopDomain>.add"], "method_name": "ScopInstallation.filterByDomainName", "method_implementation": "{\n    List<ScopDomain> domains = new ArrayList<ScopDomain>();\n    if (query.length() < 5) {\n        return domains;\n    }\n    String pdbId = query.substring(1, 5);\n    List<ScopDomain> doms = getDomainsForPDB(pdbId);\n    if (doms == null)\n        return domains;\n    query = query.toLowerCase();\n    for (ScopDomain d : doms) {\n        if (d.getScopId().toLowerCase().contains(query)) {\n            domains.add(d);\n        }\n    }\n    return domains;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#filterByDomainName(java.lang.String)\n\t */\n", "repo_name": "biojava-master/", "id": 1545, "method_signature": "List<ScopDomain> filterByDomainName(String)"}, "1769": {"callee_method_names": [], "method_name": "PDBHeader.getDepDate", "method_implementation": "{\n    return depDate;\n}", "repo_id": "9", "comment": "/**\n * Return the deposition date of the structure in the PDB.\n *\n * @return the deposition date\n */\n", "repo_name": "biojava-master/", "id": 1769, "method_signature": "Date getDepDate()"}, "1597": {"callee_method_names": ["SecStrucGroup.hasAtom", "SecStrucGroup.getC", "SecStrucGroup.getO", "SecStrucGroup.getN", "SecStrucGroup.setH"], "method_name": "SecStrucCalc.calculateHAtoms", "method_implementation": "{\n    for (int i = 0; i < groups.length - 1; i++) {\n        SecStrucGroup a = groups[i];\n        SecStrucGroup b = groups[i + 1];\n        if (!b.hasAtom(\"H\")) {\n            //Atom H = calc_H(a.getC(), b.getN(), b.getCA());\n            Atom H = calcSimple_H(a.getC(), a.getO(), b.getN());\n            b.setH(H);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Calculate the coordinates of the H atoms. They are usually\n * missing in the PDB files as only few experimental methods allow\n * to resolve their location.\n */\n", "repo_name": "biojava-master/", "id": 1597, "method_signature": "void calculateHAtoms()"}, "2130": {"callee_method_names": ["List<Model>.size"], "method_name": "StructureImpl.nrModels", "method_implementation": "{\n    return models.size();\n}", "repo_id": "9", "comment": "/**\n * return number of models.\n */\n", "repo_name": "biojava-master/", "id": 2130, "method_signature": "int nrModels()"}, "1669": {"callee_method_names": [], "method_name": "Subunit.getRepresentativeAtoms", "method_implementation": "{\n    return reprAtoms;\n}", "repo_id": "9", "comment": "/**\n * Get all the representative Atoms of the Subunit. These Atoms are used for\n * clustering and displaying the Subunit.\n *\n * @return representative Atom[]\n */\n", "repo_name": "biojava-master/", "id": 1669, "method_signature": "Atom[] getRepresentativeAtoms()"}, "1675": {"callee_method_names": [], "method_name": "Subunit.getStructure", "method_implementation": "{\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * The parent Structure from which the Subunit atoms were obtained.\n *\n * @return Structure object\n */\n", "repo_name": "biojava-master/", "id": 1675, "method_signature": "Structure getStructure()"}, "2594": {"callee_method_names": [], "method_name": "SequenceTools.getSequenceFromString", "method_implementation": "{\n    if (isNucleotideSequence(sequence)) {\n        return new DNASequence(sequence);\n    } else {\n        return new ProteinSequence(sequence);\n    }\n}", "repo_id": "9", "comment": "/**\n * Attempts to parse String as a DNA sequence first.<br/>\n * If this fails it tries to  parse as a ProteinSequence.\n * <br/>\n * This method does not attempt to create an RNASequence.\n * <p>\n * Also, a sequence such as 'ATCGTA' which is both a\n * peptide sequence and a DNA sequence, will always be returned\n * as a DNA sequence.\n * </p>\n * <p>\n * An empty string argument returns a ProteinSequence of length 0.\n * A null argument throws a {@link NullPointerException}\n * @param sequence\n * @return Either a DNASequence or a ProteinSequence\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 2594, "method_signature": "Sequence<?> getSequenceFromString(String)"}, "1188": {"callee_method_names": ["List<Chain>.size", "List<Chain>.get", "String.equals", "Chain.getName"], "method_name": "PDBFileParser.isKnownChain", "method_implementation": "{\n    for (int i = 0; i < chains.size(); i++) {\n        Chain testchain = chains.get(i);\n        if (chainID.equals(testchain.getName())) {\n            return testchain;\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Finds in the given list of chains the first one that has as name the given chainID.\n * If no such Chain can be found it returns null.\n */\n", "repo_name": "biojava-master/", "id": 1188, "method_signature": "Chain isKnownChain(String, List)"}, "1653": {"callee_method_names": ["Structure.getPolyChains", "char.isProtein", "Logger.debug", "char.getId", "char.getSeqResSequence", "List<Subunit>.add", "char.getId", "Logger.debug", "List<Subunit>.size", "List<Subunit>.get", "List<Subunit>.remove"], "method_name": "SubunitExtractor.extractSubunits", "method_implementation": "{\n    // The extracted subunit container\n    List<Subunit> subunits = new ArrayList<Subunit>();\n    for (Chain c : structure.getPolyChains()) {\n        // Only take protein chains\n        if (c.isProtein()) {\n            Atom[] ca = StructureTools.getRepresentativeAtomArray(c);\n            logger.debug(\"Chain \" + c.getId() + \"; CA Atoms: \" + ca.length + \"; SEQRES: \" + c.getSeqResSequence());\n            if (ca.length == 0)\n                continue;\n            subunits.add(new Subunit(ca, c.getId(), null, structure));\n        }\n    }\n    // Calculate the minimum length of a Subunit\n    int adjustedMinLen = calcAdjustedMinimumSequenceLength(subunits, absMinLen, fraction, minLen);\n    logger.debug(\"Adjusted minimum sequence length: {}\", adjustedMinLen);\n    // Filter out short Subunits\n    for (int s = subunits.size() - 1; s >= 0; s--) {\n        if (subunits.get(s).size() < adjustedMinLen)\n            subunits.remove(s);\n    }\n    return subunits;\n}", "repo_id": "9", "comment": "/**\n * Extract the information of each protein Chain in a Structure and converts\n * them into a List of Subunit. The name of the Subunits is set to\n * {@link Chain#getId()}.\n *\n * @param structure\n *            Structure object with protein Chains\n * @param absMinLen\n *            {@link SubunitClustererParameters#getAbsoluteMinimumSequenceLength()}\n * @param fraction\n *            {@link SubunitClustererParameters#getMinimumSequenceLengthFraction()}\n * @param minLen\n *            {@link SubunitClustererParameters#getMinimumSequenceLength()}\n * @return List of Subunits\n */\n", "repo_name": "biojava-master/", "id": 1653, "method_signature": "List<Subunit> extractSubunits(Structure, int, double, int)"}, "3760": {"callee_method_ids": [3736, 3718, 3724], "callee_method_names": ["WorkSheet.addCell", "WorkSheet.setMetaDataColumns", "WorkSheet.setMetaDataRows"], "method_name": "WorkSheet.swapRowAndColumns", "method_implementation": "{\n    WorkSheet swappedWorkSheet = new WorkSheet(getColumns(), getRows());\n    for (String row : getRows()) {\n        for (String col : getColumns()) {\n            String value = getCell(row, col);\n            swappedWorkSheet.addCell(col, row, value);\n        }\n    }\n    ArrayList<String> metadataRows = this.getMetaDataRows();\n    ArrayList<String> metadataColumns = this.getMetaDataColumns();\n    swappedWorkSheet.setMetaDataColumns(metadataRows);\n    swappedWorkSheet.setMetaDataRows(metadataColumns);\n    return swappedWorkSheet;\n}", "repo_id": "9", "comment": "/**\n * Swap the row and columns returning a new worksheet\n *\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3760, "method_signature": "WorkSheet swapRowAndColumns()"}, "768": {"callee_method_names": [], "method_name": "StartupParameters.setPdb1", "method_implementation": "{\n    this.pdb1 = pdb1;\n}", "repo_id": "9", "comment": "/**\n * mandatory argument to set the first PDB (and optionally chain ID) to be aligned.\n *\n * @param pdb1\n */\n", "repo_name": "biojava-master/", "id": 768, "method_signature": "void setPdb1(String)"}, "3258": {"callee_method_names": [], "method_name": "MenuCreator.createImageIcon", "method_implementation": "{\n    java.net.URL imgURL = MenuCreator.class.getResource(path);\n    if (imgURL != null) {\n        return new ImageIcon(imgURL);\n    } else {\n        System.err.println(\"Couldn't find file: \" + path);\n        return null;\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns an ImageIcon, or null if the path was invalid.\n * @param path the path to the icon\n * @return ImageIcon object\n */\n", "repo_name": "biojava-master/", "id": 3258, "method_signature": "ImageIcon createImageIcon(String)"}, "2156": {"callee_method_names": [], "method_name": "StructureImpl.getJournalArticle", "method_implementation": "{\n    return this.pdbHeader.getJournalArticle();\n}", "repo_id": "9", "comment": "/**\n * get the associated publication as defined by the JRNL records in a PDB\n * file.\n * @return a JournalArticle\n */\n", "repo_name": "biojava-master/", "id": 2156, "method_signature": "JournalArticle getJournalArticle()"}, "118": {"callee_method_names": ["NeedlemanWunsch<DNASequence, NucleotideCompound>.setAnchors", "NeedlemanWunsch<DNASequence, NucleotideCompound>.getPair"], "method_name": "NeedlemanWunschTest.should_align_middle_anchor", "method_implementation": "{\n    DNASequence query = new DNASequence(\"ACTTT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"ACGTTT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    NeedlemanWunsch<DNASequence, NucleotideCompound> aligner = new NeedlemanWunsch<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 0, (short) 10), SubstitutionMatrixHelper.getNuc4_4());\n    aligner.setAnchors(new int[] { -1, 2, -1 });\n    assertEquals(String.format(\"A-CTTT%nACGTTT%n\"), aligner.getPair().toString());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 118, "method_signature": "void should_align_middle_anchor()"}, "1150": {"callee_method_names": [], "method_name": "FileConvert.setPrintConnections", "method_implementation": "{\n    this.printConnections = printConnections;\n}", "repo_id": "9", "comment": "/**\n * enable/disable printing of connections\n * connections are sometimes buggy in PDB files\n * so there are some cases where one might turn this off.\n * @param printConnections\n */\n", "repo_name": "biojava-master/", "id": 1150, "method_signature": "void setPrintConnections(boolean)"}, "3121": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getAsList", "method_implementation": "{\n    return this.parsedCompounds;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3121, "method_signature": "List<C> getAsList()"}, "3248": {"callee_method_names": ["JDialog.isVisible"], "method_name": "JAutoSuggest.isSuggestVisible", "method_implementation": "{\n    return dialog.isVisible();\n}", "repo_id": "9", "comment": "/**\n * @return boolean Visibility of the suggestion window\n */\n", "repo_name": "biojava-master/", "id": 3248, "method_signature": "boolean isSuggestVisible()"}, "1457": {"callee_method_names": ["List<Matrix4d>.get"], "method_name": "SpaceGroup.getTransformation", "method_implementation": "{\n    return transformations.get(i);\n}", "repo_id": "9", "comment": "/**\n * Gets a transformation by index expressed in crystal axes basis.\n * Index 0 corresponds always to the identity transformation.\n * Beware the returned Matrix4d is not a copy but it stays linked\n * to the one stored in this SpaceGroup object\n * @param i\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1457, "method_signature": "Matrix4d getTransformation(int)"}, "1263": {"callee_method_names": ["List<Map<String, Chain>>.get", "Map<String, Chain>.containsKey", "Map<String, Chain>.get", "Chain.setId", "String.trim", "Chain.setName", "Chain.setAtomGroups", "Map<String, Chain>.put", "List<Chain>.add"], "method_name": "MmtfStructureReader.setChainInfo", "method_implementation": "{\n    // First check to see if the chain exists\n    Map<String, Chain> modelChainMap = chainMap.get(modelNumber);\n    if (modelChainMap.containsKey(chainId)) {\n        chain = modelChainMap.get(chainId);\n    } else // If we need to set a new chain do this\n    {\n        chain = new ChainImpl();\n        chain.setId(chainId.trim());\n        chain.setName(chainName);\n        chain.setAtomGroups(new ArrayList<>(groupCount));\n        modelChainMap.put(chainId, chain);\n        chainList.add(chain);\n    }\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface\n\t * #setChainInfo(java.lang.String, int)\n\t */\n", "repo_name": "biojava-master/", "id": 1263, "method_signature": "void setChainInfo(String, String, int)"}, "470": {"callee_method_ids": [467], "callee_method_names": ["PdbId.compareTo", "StructureName.getIdentifier", "String.compareTo"], "method_name": "StructureName.compareTo", "method_implementation": "{\n    if (this.equals(o))\n        return 0;\n    PdbId pdb1 = null;\n    PdbId pdb2 = null;\n    try {\n        pdb1 = this.getPdbId();\n    } catch (StructureException e) {\n    }\n    try {\n        pdb2 = this.getPdbId();\n    } catch (StructureException e) {\n    }\n    int comp = 0;\n    // Sort those with PDBIDs before those without\n    if (pdb1 == null) {\n        if (pdb2 != null) {\n            // this > o\n            return 1;\n        }\n        // both null\n    } else if (pdb2 == null) {\n        // this < o\n        return -1;\n    } else {\n        // neither null\n        comp = pdb1.compareTo(pdb2);\n    }\n    if (comp != 0) {\n        return comp;\n    }\n    // break tie with full identifiers\n    String pdb1Str = this.getIdentifier();\n    String pdb2Str = o.getIdentifier();\n    // Throws NPE for nulls\n    return pdb1Str.compareTo(pdb2Str);\n}", "repo_id": "9", "comment": "/**\n * Orders identifiers lexicographically by PDB ID and then full Identifier\n */\n", "repo_name": "biojava-master/", "id": 470, "method_signature": "int compareTo(StructureName)"}, "1688": {"callee_method_names": [], "method_name": "AtomImpl.getName", "method_implementation": "{\n    return name;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1688, "method_signature": "String getName()"}, "3765": {"callee_method_ids": [3717, 3716], "callee_method_names": ["WorkSheet.setMetaDataColumnsAfterColumn", "WorkSheet.setMetaDataRowsAfterRow"], "method_name": "WorkSheet.readCSV", "method_implementation": "{\n    CompactCharSequence[][] data = getAllValuesCompactCharSequence(is, delimiter);\n    WorkSheet workSheet = new WorkSheet(data);\n    workSheet.setMetaDataColumnsAfterColumn();\n    workSheet.setMetaDataRowsAfterRow();\n    return workSheet;\n}", "repo_id": "9", "comment": "/**\n * Read a CSV/Tab delimited file where you pass in the delimiter\n *\n * @param f\n * @param delimiter\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3765, "method_signature": "WorkSheet readCSV(InputStream, char)"}, "876": {"callee_method_ids": [832], "callee_method_names": ["AsaCalculator.calculateAsas", "Atom[].getGroup", "Group.getType", "Map<ResidueNumber, GroupAsa>.containsKey", "Group.getResidueNumber", "GroupAsa.addAtomAsaU", "GroupAsa.addAtomAsaC", "Map<ResidueNumber, GroupAsa>.put", "Group.getResidueNumber", "Map<ResidueNumber, GroupAsa>.get", "Group.getResidueNumber", "GroupAsa.addAtomAsaU", "GroupAsa.addAtomAsaC", "Atom[].getGroup", "Group.getType", "Map<ResidueNumber, GroupAsa>.containsKey", "Group.getResidueNumber", "GroupAsa.addAtomAsaU", "GroupAsa.addAtomAsaC", "Map<ResidueNumber, GroupAsa>.put", "Group.getResidueNumber", "Map<ResidueNumber, GroupAsa>.get", "Group.getResidueNumber", "GroupAsa.addAtomAsaU", "GroupAsa.addAtomAsaC"], "method_name": "StructureInterface.setAsas", "method_implementation": "{\n    Atom[] atoms = getAtomsForAsa(cofactorSizeToUse);\n    AsaCalculator asaCalc = new AsaCalculator(atoms, AsaCalculator.DEFAULT_PROBE_SIZE, nSpherePoints, nThreads);\n    double[] complexAsas = asaCalc.calculateAsas();\n    if (complexAsas.length != asas1.length + asas2.length)\n        throw new IllegalArgumentException(\"The size of ASAs of complex doesn't match that of ASAs 1 + ASAs 2\");\n    groupAsas1 = new TreeMap<>();\n    groupAsas2 = new TreeMap<>();\n    this.totalArea = 0;\n    for (int i = 0; i < asas1.length; i++) {\n        Group g = atoms[i].getGroup();\n        if (!g.getType().equals(GroupType.HETATM) || isInChain(g)) {\n            // interface area should be only for protein/nucleotide but not hetatoms that are not part of the chain\n            this.totalArea += (asas1[i] - complexAsas[i]);\n        }\n        if (!groupAsas1.containsKey(g.getResidueNumber())) {\n            GroupAsa groupAsa = new GroupAsa(g);\n            groupAsa.addAtomAsaU(asas1[i]);\n            groupAsa.addAtomAsaC(complexAsas[i]);\n            groupAsas1.put(g.getResidueNumber(), groupAsa);\n        } else {\n            GroupAsa groupAsa = groupAsas1.get(g.getResidueNumber());\n            groupAsa.addAtomAsaU(asas1[i]);\n            groupAsa.addAtomAsaC(complexAsas[i]);\n        }\n    }\n    for (int i = 0; i < asas2.length; i++) {\n        Group g = atoms[i + asas1.length].getGroup();\n        if (!g.getType().equals(GroupType.HETATM) || isInChain(g)) {\n            // interface area should be only for protein/nucleotide but not hetatoms that are not part of the chain\n            this.totalArea += (asas2[i] - complexAsas[i + asas1.length]);\n        }\n        if (!groupAsas2.containsKey(g.getResidueNumber())) {\n            GroupAsa groupAsa = new GroupAsa(g);\n            groupAsa.addAtomAsaU(asas2[i]);\n            groupAsa.addAtomAsaC(complexAsas[i + asas1.length]);\n            groupAsas2.put(g.getResidueNumber(), groupAsa);\n        } else {\n            GroupAsa groupAsa = groupAsas2.get(g.getResidueNumber());\n            groupAsa.addAtomAsaU(asas2[i]);\n            groupAsa.addAtomAsaC(complexAsas[i + asas1.length]);\n        }\n    }\n    // our interface area definition: average of bsa of both molecules\n    this.totalArea = this.totalArea / 2.0;\n}", "repo_id": "9", "comment": "/**\n * Set ASA annotations by passing the uncomplexed ASA values of the 2 partners.\n * This will calculate complexed ASA and set the ASA values in the member variables.\n * @param asas1 ASA values for atoms of partner 1\n * @param asas2 ASA values for atoms of partner 2\n * @param nSpherePoints the number of sphere points to be used for complexed ASA calculation\n * @param nThreads the number of threads to be used for complexed ASA calculation\n * @param cofactorSizeToUse the minimum size of cofactor molecule (non-chain HET atoms) that will be used in ASA calculation\n */\n", "repo_name": "biojava-master/", "id": 876, "method_signature": "void setAsas(double[], double[], int, int, int)"}, "3502": {"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "ProteinSequence.getSequenceAsString", "URL.openConnection", "HttpURLConnection.setDoOutput", "HttpURLConnection.setDoInput", "HttpURLConnection.setConnectTimeout", "HttpURLConnection.setInstanceFollowRedirects", "HttpURLConnection.setRequestMethod", "HttpURLConnection.setRequestProperty", "HttpURLConnection.setRequestProperty", "HttpURLConnection.setRequestProperty", "StringBuffer.toString", "HttpURLConnection.getOutputStream", "DataOutputStream.write", "StringBuffer.toString", "DataOutputStream.flush", "DataOutputStream.close", "HttpURLConnection.getHeaderField", "HttpURLConnection.getResponseCode", "Logger.warn", "HttpURLConnection.getResponseMessage", "URL.openConnection", "HttpURLConnection.setRequestMethod", "HttpURLConnection.setRequestProperty", "HttpURLConnection.setConnectTimeout", "HttpURLConnection.getInputStream", "BufferedReader.readLine", "StringBuffer.append", "BufferedReader.close", "StringBuffer.toString", "JSONObject.getJSONObject", "JSONObject.getJSONArray", "JSONArray.size", "JSONArray.getJSONObject", "JSONObject.get", "Long.intValue", "HmmerResult.setAcc", "JSONObject.get", "HmmerResult.setDcl", "HmmerResult.setDesc", "JSONObject.get", "HmmerResult.setEvalue", "JSONObject.get", "HmmerResult.setName", "JSONObject.get", "HmmerResult.setNdom", "JSONObject.get", "HmmerResult.setNreported", "JSONObject.get", "HmmerResult.setPvalue", "JSONObject.get", "HmmerResult.setScore", "JSONObject.get", "JSONObject.getJSONArray", "JSONArray.size", "JSONArray.getJSONObject", "JSONObject.get", "JSONObject.get", "JSONObject.get", "HmmerDomain.setAliLenth", "JSONObject.get", "HmmerDomain.setHmmAcc", "JSONObject.get", "HmmerDomain.setHmmDesc", "JSONObject.get", "HmmerDomain.setHmmFrom", "JSONObject.get", "HmmerDomain.setHmmTo", "JSONObject.get", "HmmerDomain.setSimCount", "JSONObject.get", "HmmerDomain.setSqFrom", "JSONObject.get", "HmmerDomain.setSqTo", "JSONObject.get", "HmmerDomain.setHmmName", "JSONObject.get", "HmmerDomain.setEvalue", "JSONObject.get", "SortedSet<HmmerDomain>.add", "HmmerResult.setDomains", "SortedSet<HmmerResult>.add", "Logger.warn", "MouseEvent.getMessage"], "method_name": "RemoteHmmerScan.scan", "method_implementation": "{\n    StringBuffer postContent = new StringBuffer();\n    postContent.append(\"hmmdb=pfam\");\n    // by default hmmscan runs with the HMMER3 cut_ga parameter enabled, the \"gathering threshold\", which depends on\n    // the cutoffs defined in the underlying HMM files.\n    // to request a different cutoff by e-value this could be enabled:\n    //postContent.append(\"&E=1\");\n    postContent.append(\"&seq=\");\n    postContent.append(sequence.getSequenceAsString());\n    HttpURLConnection connection = (HttpURLConnection) serviceLocation.openConnection();\n    connection.setDoOutput(true);\n    connection.setDoInput(true);\n    // 15 sec\n    connection.setConnectTimeout(15000);\n    connection.setInstanceFollowRedirects(false);\n    connection.setRequestMethod(\"POST\");\n    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    connection.setRequestProperty(\"Accept\", \"application/json\");\n    connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postContent.toString().getBytes().length));\n    //Send request\n    DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n    wr.write(postContent.toString().getBytes());\n    wr.flush();\n    wr.close();\n    //Now get the redirect URL\n    URL respUrl = new URL(connection.getHeaderField(\"Location\"));\n    int responseCode = connection.getResponseCode();\n    if (responseCode == 500) {\n        LOGGER.warn(\"Got 500 response code for URL {}. Response message: {}.\", serviceLocation, connection.getResponseMessage());\n    }\n    HttpURLConnection connection2 = (HttpURLConnection) respUrl.openConnection();\n    connection2.setRequestMethod(\"GET\");\n    connection2.setRequestProperty(\"Accept\", \"application/json\");\n    // 1 minute\n    connection2.setConnectTimeout(60000);\n    //Get the response\n    BufferedReader in = new BufferedReader(new InputStreamReader(connection2.getInputStream()));\n    String inputLine;\n    StringBuffer result = new StringBuffer();\n    while ((inputLine = in.readLine()) != null) {\n        result.append(inputLine);\n    }\n    in.close();\n    // process the response and build up a container for the data.\n    SortedSet<HmmerResult> results = new TreeSet<HmmerResult>();\n    try {\n        JSONObject json = JSONObject.fromObject(result.toString());\n        JSONObject hmresults = json.getJSONObject(\"results\");\n        JSONArray hits = hmresults.getJSONArray(\"hits\");\n        for (int i = 0; i < hits.size(); i++) {\n            JSONObject hit = hits.getJSONObject(i);\n            HmmerResult hmmResult = new HmmerResult();\n            Object dclO = hit.get(\"dcl\");\n            Integer dcl = -1;\n            if (dclO instanceof Long) {\n                Long dclL = (Long) dclO;\n                dcl = dclL.intValue();\n            } else if (dclO instanceof Integer) {\n                dcl = (Integer) dclO;\n            }\n            hmmResult.setAcc((String) hit.get(\"acc\"));\n            hmmResult.setDcl(dcl);\n            hmmResult.setDesc((String) hit.get(\"desc\"));\n            hmmResult.setEvalue(Float.parseFloat((String) hit.get(\"evalue\")));\n            hmmResult.setName((String) hit.get(\"name\"));\n            hmmResult.setNdom((Integer) hit.get(\"ndom\"));\n            hmmResult.setNreported((Integer) hit.get(\"nreported\"));\n            hmmResult.setPvalue((Double) hit.get(\"pvalue\"));\n            hmmResult.setScore(Float.parseFloat((String) hit.get(\"score\")));\n            JSONArray hmmdomains = hit.getJSONArray(\"domains\");\n            SortedSet<HmmerDomain> domains = new TreeSet<HmmerDomain>();\n            for (int j = 0; j < hmmdomains.size(); j++) {\n                JSONObject d = hmmdomains.getJSONObject(j);\n                Integer is_included = getInteger(d.get(\"is_included\"));\n                if (is_included == 0) {\n                    continue;\n                }\n                // this filters out multiple hits to the same clan\n                Integer outcompeted = getInteger(d.get(\"outcompeted\"));\n                if (outcompeted != null && outcompeted == 1) {\n                    continue;\n                }\n                Integer significant = getInteger(d.get(\"significant\"));\n                if (significant != 1) {\n                    continue;\n                }\n                HmmerDomain dom = new HmmerDomain();\n                dom.setAliLenth((Integer) d.get(\"aliL\"));\n                dom.setHmmAcc((String) d.get(\"alihmmacc\"));\n                dom.setHmmDesc((String) d.get(\"alihmmdesc\"));\n                dom.setHmmFrom(getInteger(d.get(\"alihmmfrom\")));\n                dom.setHmmTo(getInteger(d.get(\"alihmmto\")));\n                dom.setSimCount((Integer) d.get(\"aliSimCount\"));\n                dom.setSqFrom(getInteger(d.get(\"alisqfrom\")));\n                dom.setSqTo(getInteger(d.get(\"alisqto\")));\n                dom.setHmmName((String) d.get(\"alihmmname\"));\n                dom.setEvalue(Float.parseFloat((String) d.get(\"ievalue\")));\n                domains.add(dom);\n            }\n            hmmResult.setDomains(domains);\n            results.add(hmmResult);\n        }\n    } catch (NumberFormatException e) {\n        LOGGER.warn(\"Could not parse number in Hmmer web service json response: {}\", e.getMessage());\n    }\n    return results;\n}", "repo_id": "9", "comment": "/**\n * Scans a protein sequence for Pfam profile matches.\n *\n * @param sequence\n * @param serviceLocation\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 3502, "method_signature": "SortedSet<HmmerResult> scan(ProteinSequence, URL)"}, "1875": {"callee_method_names": [], "method_name": "Helix.setTransformation", "method_implementation": "{\n    this.transformation = transformation;\n}", "repo_id": "9", "comment": "/**\n * @param transformation the transformation to set\n */\n", "repo_name": "biojava-master/", "id": 1875, "method_signature": "void setTransformation(Matrix4d)"}, "2589": {"callee_method_names": ["Element.getParentNode", "Node.getNodeType", "Element.getTagName"], "method_name": "XMLHelper.selectParentElement", "method_implementation": "{\n    Node parentNode = element.getParentNode();\n    if (parentNode == null) {\n        return null;\n    }\n    // check that parent is actually an element, else return null\n    // this is to prevent ClassCastExceptions if element's parent is not an Element.\n    Element parentElement = null;\n    if (Node.ELEMENT_NODE == parentNode.getNodeType()) {\n        parentElement = (Element) parentNode;\n    } else {\n        return null;\n    }\n    if (parentElement.getTagName().equals(parentName)) {\n        return parentElement;\n    }\n    return selectParentElement(parentElement, parentName);\n}", "repo_id": "9", "comment": "/**\n * Given an element, searches upwards through ancestor Elements till the first Element\n * matching the requests {@code}parentName{@code} is found.\n * @param element The starting element\n * @param parentName The tag name of the requested Element.\n * @return The found element, or {@code}null{@code} if no matching element is found,\n */\n", "repo_name": "biojava-master/", "id": 2589, "method_signature": "Element selectParentElement(Element, String)"}, "995": {"callee_method_names": [], "method_name": "HetatomImpl.getResidueNumber", "method_implementation": "{\n    return residueNumber;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 995, "method_signature": "ResidueNumber getResidueNumber()"}, "936": {"callee_method_names": [], "method_name": "Grid.getIntBounds", "method_implementation": "{\n    int[] bs = new int[6];\n    bs[0] = getFloor(coordbounds.xmin);\n    bs[1] = getFloor(coordbounds.ymin);\n    bs[2] = getFloor(coordbounds.zmin);\n    bs[3] = getFloor(coordbounds.xmax);\n    bs[4] = getFloor(coordbounds.ymax);\n    bs[5] = getFloor(coordbounds.zmax);\n    return bs;\n}", "repo_id": "9", "comment": "/**\n * Returns an int array of size 6 :\n * - elements 0,1,2: minimum x,y,z (in grid int coordinates) of the given atoms\n * - elements 3,4,5: maximum x,y,z (in grid int coordinates) of the given atoms\n * @return\n */\n", "repo_name": "biojava-master/", "id": 936, "method_signature": "int[] getIntBounds(BoundingBox)"}, "934": {"callee_method_ids": [914], "callee_method_names": ["BoundingBox.overlaps"], "method_name": "Grid.fillGrid", "method_implementation": "{\n    if (jbounds != null && !ibounds.overlaps(jbounds, cutoff)) {\n        //System.out.print(\"-\");\n        noOverlap = true;\n        return;\n    }\n    findFullGridIntBounds();\n    cells = new GridCell[1 + (bounds[3] - bounds[0]) / cellSize][1 + (bounds[4] - bounds[1]) / cellSize][1 + (bounds[5] - bounds[2]) / cellSize];\n    int i = 0;\n    for (Point3d atom : iAtoms) {\n        int xind = xintgrid2xgridindex(getFloor(atom.x));\n        int yind = yintgrid2ygridindex(getFloor(atom.y));\n        int zind = zintgrid2zgridindex(getFloor(atom.z));\n        if (cells[xind][yind][zind] == null) {\n            cells[xind][yind][zind] = new GridCell(this);\n        }\n        cells[xind][yind][zind].addIindex(i);\n        i++;\n    }\n    if (jAtoms == null)\n        return;\n    int j = 0;\n    for (Point3d atom : jAtoms) {\n        int xind = xintgrid2xgridindex(getFloor(atom.x));\n        int yind = yintgrid2ygridindex(getFloor(atom.y));\n        int zind = zintgrid2zgridindex(getFloor(atom.z));\n        if (cells[xind][yind][zind] == null) {\n            cells[xind][yind][zind] = new GridCell(this);\n        }\n        cells[xind][yind][zind].addJindex(j);\n        j++;\n    }\n}", "repo_id": "9", "comment": "/**\n * Creates the grid based on the boundaries defined by all atoms given (iAtoms and jAtoms)\n * and places the atoms in their corresponding grid cells.\n * Checks also if the i and j grid overlap, i.e. the enclosing bounds of\n * the 2 grids (i and j) are no more than one cell size apart. If they don't\n * overlap then they are too far apart so there's nothing to calculate, we set\n * the noOverlap flag and then {@link #getIndicesContacts()} will do no calculation at all.\n */\n", "repo_name": "biojava-master/", "id": 934, "method_signature": "void fillGrid()"}, "385": {"callee_method_names": ["AminoAcid.getN", "AminoAcid.getCA", "AminoAcid.getC", "AminoAcid.getCB", "AminoAcid.getN", "AminoAcid.getCA", "AminoAcid.getC", "SuperPositionSVD.superpose", "Atom.setName"], "method_name": "Calc.createVirtualCBAtom", "method_implementation": "{\n    AminoAcid ala = StandardAminoAcid.getAminoAcid(\"ALA\");\n    Atom aN = ala.getN();\n    Atom aCA = ala.getCA();\n    Atom aC = ala.getC();\n    Atom aCB = ala.getCB();\n    Atom[] arr1 = new Atom[3];\n    arr1[0] = aN;\n    arr1[1] = aCA;\n    arr1[2] = aC;\n    Atom[] arr2 = new Atom[3];\n    arr2[0] = amino.getN();\n    arr2[1] = amino.getCA();\n    arr2[2] = amino.getC();\n    // ok now we got the two arrays, do a Superposition:\n    SuperPositionSVD svd = new SuperPositionSVD(false);\n    Matrix4d transform = svd.superpose(Calc.atomsToPoints(arr1), Calc.atomsToPoints(arr2));\n    Matrix rotMatrix = Matrices.getRotationJAMA(transform);\n    Atom tranMatrix = getTranslationVector(transform);\n    Calc.rotate(aCB, rotMatrix);\n    Atom virtualCB = Calc.add(aCB, tranMatrix);\n    virtualCB.setName(\"CB\");\n    return virtualCB;\n}", "repo_id": "9", "comment": "/**\n * creates a virtual C-beta atom. this might be needed when working with GLY\n *\n * thanks to Peter Lackner for a python template of this method.\n *\n * @param amino\n *            the amino acid for which a \"virtual\" CB atom should be\n *            calculated\n * @return a \"virtual\" CB atom\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 385, "method_signature": "Atom createVirtualCBAtom(AminoAcid)"}, "1841": {"callee_method_names": ["String.toLowerCase", "SecStrucType.getExtensions", "String.endsWith"], "method_name": "StructureIO.guessFiletype", "method_implementation": "{\n    String lower = filename.toLowerCase();\n    for (StructureFiletype type : StructureFiletype.values()) {\n        for (String ext : type.getExtensions()) {\n            if (lower.endsWith(ext.toLowerCase())) {\n                return type;\n            }\n        }\n    }\n    return StructureFiletype.UNKNOWN;\n}", "repo_id": "9", "comment": "/**\n * Attempts to guess the type of a structure file based on the extension\n * @param filename\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1841, "method_signature": "StructureFiletype guessFiletype(String)"}, "2960": {"callee_method_names": ["SequenceAsStringHelper<C>.getSequenceAsString"], "method_name": "ArrayListSequenceReader.getSequenceAsString", "method_implementation": "{\n    // TODO Optimise/cache.\n    SequenceAsStringHelper<C> sequenceAsStringHelper = new SequenceAsStringHelper<C>();\n    return sequenceAsStringHelper.getSequenceAsString(this.parsedCompounds, compoundSet, begin, end, strand);\n}", "repo_id": "9", "comment": "/**\n * @param begin\n * @param end\n * @param strand\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2960, "method_signature": "String getSequenceAsString(Integer, Integer, Strand)"}, "1396": {"callee_method_names": ["Pattern.matcher"], "method_name": "PdbId.isValidShortPdbId", "method_implementation": "{\n    return PATTERN_SHORT_PDBID.matcher(id).matches();\n}", "repo_id": "9", "comment": "/**\n * Check whether <code>id</code> represents a valid PDB ID in the <em>short</em> format.\n * @param id Prospect ID\n * @return <code>true</code> if <code>id</code> is a valid short PDB ID, <code>false</code> otherwise.\n * @throws NullPointerException if <code>id</code> is <code>null</code>.\n * @see #isValidExtendedPdbId(String)\n */\n", "repo_name": "biojava-master/", "id": 1396, "method_signature": "boolean isValidShortPdbId(String)"}, "3367": {"callee_method_names": [], "method_name": "DefaultMatrixMapper.getSaturation", "method_implementation": "{\n    return saturation;\n}", "repo_id": "9", "comment": "/**\n * @return the saturation\n */\n", "repo_name": "biojava-master/", "id": 3367, "method_signature": "float getSaturation()"}, "127": {"callee_method_names": ["PairwiseSequenceAligner<DNASequence, NucleotideCompound>.getPair"], "method_name": "TestDNAAlignment.testLinearAlignment", "method_implementation": "{\n    DNASequence query = new DNASequence(\"GTAAAAG\", DNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"GAAAACGTTTTTTTTTT\", DNACompoundSet.getDNACompoundSet());\n    SubstitutionMatrix<NucleotideCompound> matrix = SubstitutionMatrixHelper.getNuc4_4();\n    SimpleGapPenalty gapP = new SimpleGapPenalty((short) 0, (short) 3);\n    PairwiseSequenceAligner<DNASequence, NucleotideCompound> aligner = Alignments.getPairwiseAligner(query, target, PairwiseSequenceAlignerType.GLOBAL, gapP, matrix);\n    Assert.assertEquals(String.format(\"GTAAAA-G----------%nG-AAAACGTTTTTTTTTT%n\"), aligner.getPair().toString());\n    ;\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 127, "method_signature": "void testLinearAlignment()"}, "109": {"callee_method_names": ["Logger.info", "MultipleSequenceAlignment<C,D>.getSize", "MultipleSequenceAlignment<C,D>.getAlignedSequence", "Logger.info", "DistanceMatrix.setIdentifier", "MultipleSequenceAlignment<C,D>.getAlignedSequence", "DistanceMatrix.setValue", "DistanceMatrix.setValue", "DistanceMatrix.setValue", "DistanceMatrix.getValue", "Logger.info"], "method_name": "DistanceMatrixCalculator.percentageIdentity", "method_implementation": "{\n    logger.info(\"{}:{}\", \"Determing Distances\", 0);\n    int n = msa.getSize();\n    String[] sequenceString = new String[n];\n    for (int i = 0; i < n; i++) {\n        sequenceString[i] = msa.getAlignedSequence(i + 1).getSequenceAsString();\n    }\n    DistanceMatrix distance = new BasicSymmetricalDistanceMatrix(n);\n    int totalloopcount = (n / 2) * (n + 1);\n    int loopcount = 0;\n    for (int i = 0; i < (n - 1); i++) {\n        logger.info(\"{}:{}\", \"Determining Distances\", (loopcount * 100) / totalloopcount);\n        distance.setIdentifier(i, msa.getAlignedSequence(i + 1).getAccession().getID());\n        for (int j = i; j < n; j++) {\n            loopcount++;\n            if (j == i) {\n                distance.setValue(i, j, 0);\n            } else {\n                distance.setValue(i, j, 100 - Comparison.PID(sequenceString[i], sequenceString[j]));\n                distance.setValue(j, i, distance.getValue(i, j));\n            }\n        }\n    }\n    logger.info(\"{}:{}\", \"Determining Distances\", 100);\n    return distance;\n}", "repo_id": "9", "comment": "/**\n * BioJava implementation for percentage of identity (PID). Although the\n * name of the method is percentage of identity, the DistanceMatrix contains\n * the fractional dissimilarity (D), computed as D = 1 - PID.\n * <p>\n * It is recommended to use the method\n * {@link DistanceMatrixCalculator#fractionalDissimilarity(MultipleSequenceAlignment)}\n * instead of this one.\n *\n * @param msa\n *            MultipleSequenceAlignment\n * @return DistanceMatrix\n */\n", "repo_name": "biojava-master/", "id": 109, "method_signature": "DistanceMatrix percentageIdentity(MultipleSequenceAlignment)"}, "1169": {"callee_method_names": ["String.length", "String.substring", "String.substring", "String.length", "PDBHeader.getTitle", "String.endsWith", "PDBHeader.setTitle"], "method_name": "PDBFileParser.pdb_TITLE_Handler", "method_implementation": "{\n    String title;\n    if (line.length() > 79)\n        title = line.substring(10, 80).trim();\n    else\n        title = line.substring(10, line.length()).trim();\n    String t = pdbHeader.getTitle();\n    if ((t != null) && (!\"\".equals(t))) {\n        if (t.endsWith(\"-\"))\n            // if last line ends with a hyphen then we don't add space\n            t += \"\";\n        else\n            t += \" \";\n    } else\n        t = \"\";\n    t += title;\n    pdbHeader.setTitle(t);\n}", "repo_id": "9", "comment": "/**\n *  Handler for\n *  TITLE Record Format\n *  <pre>\n * \t COLUMNS        DATA TYPE       FIELD          DEFINITION\n * \t ----------------------------------------------------------------------------------\n * \t 1 -  6        Record name     \"TITLE \"\n * \t 9 - 10        Continuation    continuation   Allows concatenation of multiple\n * \t records.\n * \t 11 - 70        String          title          Title of the experiment.\n *  </pre>\n */\n", "repo_name": "biojava-master/", "id": 1169, "method_signature": "void pdb_TITLE_Handler(String)"}, "623": {"callee_method_ids": [970], "callee_method_names": ["Structure.getPDBHeader", "Structure.getPDBHeader", "Logger.info", "Structure.getPDBHeader", "Structure.getPDBHeader", "List<BiologicalAssemblyTransformation>.size", "BiologicalAssemblyBuilder.rebuildQuaternaryStructure"], "method_name": "AtomCache.getBiologicalAssembly", "method_implementation": "{\n    boolean prevIsParseBioAssembly = getFileParsingParams().isParseBioAssembly();\n    if (!getFileParsingParams().isParseBioAssembly()) {\n        getFileParsingParams().setParseBioAssembly(true);\n    }\n    Structure asymUnit = getStructureForPdbId(pdbId);\n    getFileParsingParams().setParseBioAssembly(prevIsParseBioAssembly);\n    if (asymUnit.getPDBHeader() == null || asymUnit.getPDBHeader().getBioAssemblies() == null) {\n        logger.info(\"No bioassembly information found for {}, returning asymmetric unit as biological assembly\", pdbId);\n        return asymUnit;\n    }\n    int bioAssemblyId = 1;\n    // does it exist?\n    if (!asymUnit.getPDBHeader().getBioAssemblies().containsKey(bioAssemblyId)) {\n        return asymUnit;\n    }\n    List<BiologicalAssemblyTransformation> transformations = asymUnit.getPDBHeader().getBioAssemblies().get(bioAssemblyId).getTransforms();\n    if (transformations == null || transformations.size() == 0) {\n        throw new StructureException(\"Could not load transformations to recreate biological assembly id \" + bioAssemblyId + \" of \" + pdbId);\n    }\n    BiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n    // if we use mmcif or mmtf, then we need to pass useAsymIds=true\n    boolean useAsymIds = false;\n    if (filetype == StructureFiletype.CIF || filetype == StructureFiletype.BCIF || filetype == StructureFiletype.MMTF) {\n        useAsymIds = true;\n    }\n    return builder.rebuildQuaternaryStructure(asymUnit, transformations, useAsymIds, multiModel);\n}", "repo_id": "9", "comment": "/**\n * Returns the default biological unit (bioassemblyId=1, known in PDB as pdb1.gz). If it is not available,\n * the asymmetric unit will be returned, e.g. for NMR structures.\n *\n * <p>Biological assemblies can also be accessed using\n * <tt>getStructure(\"BIO:<i>[pdbId]</i>\")</tt>\n * @param pdbId the PDB id\n * @param multiModel if true the output Structure will be a multi-model one with one transformId per model,\n * if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId).\n * @return a structure object\n * @throws IOException\n * @throws StructureException\n * @since 4.2\n */\n", "repo_name": "biojava-master/", "id": 623, "method_signature": "Structure getBiologicalAssembly(String, boolean)"}, "330": {"callee_method_ids": [336], "callee_method_names": ["OntologyFactory.createOntology", "OboFileParser.addOboFileEventListener", "OboFileParser.parseOBO"], "method_name": "OboParser.parseOBO", "method_implementation": "{\n    try {\n        OntologyFactory factory = OntoTools.getDefaultFactory();\n        Ontology ontology = factory.createOntology(ontoName, ontoDescription);\n        OboFileParser parser = new OboFileParser();\n        OboFileEventListener handler = new OboFileHandler(ontology);\n        parser.addOboFileEventListener(handler);\n        parser.parseOBO(oboFile);\n        return ontology;\n    } catch (AlreadyExistsException ex) {\n        throw new RuntimeException(\"Duplication in ontology\");\n    } catch (OntologyException ex) {\n        throw new RuntimeException(ex);\n    }\n}", "repo_id": "9", "comment": "/**\n * Parse a OBO file and return its content as a BioJava Ontology object\n *\n * @param oboFile the file to be parsed\n * @param ontoName\n * @param ontoDescription\n *\n * @return the ontology represented as a BioJava ontology file\n * @throws ParseException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 330, "method_signature": "Ontology parseOBO(BufferedReader, String, String)"}, "1078": {"callee_method_names": ["String.length", "String.substring", "ChemComp.setOneLetterCode", "ChemComp.setThreeLetterCode", "ChemComp.setPolymerType", "ChemComp.setResidueType"], "method_name": "ZipChemCompProvider.getEmptyChemComp", "method_implementation": "{\n    // Empty string is default\n    String pdbName = \"\";\n    if (null != resName && resName.length() >= 3) {\n        pdbName = resName.substring(0, 3);\n    }\n    final ChemComp comp = new ChemComp();\n    comp.setOneLetterCode(\"?\");\n    comp.setThreeLetterCode(pdbName);\n    comp.setPolymerType(PolymerType.unknown);\n    comp.setResidueType(ResidueType.atomn);\n    return comp;\n}", "repo_id": "9", "comment": "/**\n * Return an empty ChemComp group for a three-letter resName.\n * @param resName\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1078, "method_signature": "ChemComp getEmptyChemComp(String)"}, "2637": {"callee_method_names": [], "method_name": "DNASequence.getRNASequence", "method_implementation": "{\n    return getRNASequence(TranscriptionEngine.getDefault(), frame);\n}", "repo_id": "9", "comment": "/**\n * Allows the user to pass in the Frame shift.\n * @param frame\n * @return rna sequence\n */\n", "repo_name": "biojava-master/", "id": 2637, "method_signature": "RNASequence getRNASequence(Frame)"}, "971": {"callee_method_names": ["List<String>.indexOf", "List<String>.indexOf"], "method_name": "BiologicalAssemblyBuilder.orderTransformationsByChainId", "method_implementation": "{\n    final List<String> chainIds = getChainIds(asymUnit);\n    Collections.sort(transformations, new Comparator<BiologicalAssemblyTransformation>() {\n\n        @Override\n        public int compare(BiologicalAssemblyTransformation t1, BiologicalAssemblyTransformation t2) {\n            // set sort order only if the two ids are identical\n            if (t1.getId().equals(t2.getId())) {\n                return chainIds.indexOf(t1.getChainId()) - chainIds.indexOf(t2.getChainId());\n            } else {\n                return t1.getId().compareTo(t2.getId());\n            }\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Orders model transformations by chain ids in the same order as in the asymmetric unit\n * @param asymUnit\n * @param transformations\n */\n", "repo_name": "biojava-master/", "id": 971, "method_signature": "void orderTransformationsByChainId(Structure, List)"}, "2536": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getNuc4_4", "method_implementation": "{\n    return getNucleotideMatrix(\"nuc-4_4\");\n}", "repo_id": "9", "comment": "/**\n * Returns Nuc 4.4 matrix by Lowe\n * Both of the nucleotide sequences to align can contain ambiguous nucleotides\n * @return Nuc 4.4 matrix\n */\n", "repo_name": "biojava-master/", "id": 2536, "method_signature": "SubstitutionMatrix<NucleotideCompound> getNuc4_4()"}, "413": {"callee_method_ids": [432, 484], "callee_method_names": ["FatCatParameters.getFragLen", "FatCatParameters.getMaxGapFrag", "FatCatParameters.getMisCut", "FatCatParameters.getMaxTra", "AFPChain.getAfpSet", "List<AFP>.get", "List<AFP>.get", "AFPChain.getAfpAftIndex", "AFPChain.getAfpBefIndex", "AFPChain.getTwi"], "method_name": "AFPChainer.getCompatibleAfps", "method_implementation": "{\n    int i, j, i1, j1, f, G, c, a1, a2, a3, b1, b2, b3, s1, s2;\n    int fragLen = params.getFragLen();\n    int maxGapFrag = params.getMaxGapFrag();\n    int misCut = params.getMisCut();\n    int maxTra = params.getMaxTra();\n    List<AFP> afpSet = afpChain.getAfpSet();\n    f = fragLen;\n    G = maxGapFrag;\n    c = misCut;\n    i1 = afpSet.get(afp).getP1();\n    j1 = afpSet.get(afp).getP2();\n    a3 = i1 - f;\n    a2 = a3 - c;\n    a1 = i1 - G;\n    a2 = a2 > 0 ? a2 : 0;\n    a1 = a1 > 0 ? a1 : 0;\n    b3 = j1 - f;\n    b2 = b3 - c;\n    b1 = j1 - G;\n    b2 = (b2 > 0) ? b2 : 0;\n    b1 = (b1 > 0) ? b1 : 0;\n    int[][] afpAftIndex = afpChain.getAfpAftIndex();\n    int[][] afpBefIndex = afpChain.getAfpBefIndex();\n    int[] twi = afpChain.getTwi();\n    int n = 0;\n    //compatible region 1-2, [a1,a3][b2,b3]\n    for (i = a1; i <= a3; i++) {\n        //i <= a3 instead of i < a3\n        //note afpAftIndex, not afpIndex\n        s1 = afpAftIndex[i][b2];\n        //no AFP for the given i with j > b2\n        if (s1 < 0)\n            continue;\n        //afps is sorted by j given a i,it's sparse matrix\n        s2 = afpBefIndex[i][b3];\n        //no AFP for the given i with j < b3\n        if (s2 < 0)\n            continue;\n        for (j = s1; j <= s2; j++) {\n            //j <= s2 instead of j < s2\n            if (twi[j] <= maxTra) {\n                list[n++] = j;\n            }\n        }\n    }\n    //compatible region 3  [a2,a3][b1,b2]\n    for (i = a2; i <= a3; i++) {\n        s1 = afpAftIndex[i][b1];\n        if (s1 < 0)\n            continue;\n        //afps is sorted by j given a i\n        s2 = afpBefIndex[i][b2];\n        if (s2 < 0)\n            continue;\n        //note j < s2, as the cases of j == s2 is alread considered in previous region\n        for (j = s1; j < s2; j++) {\n            if (twi[j] <= maxTra) {\n                list[n++] = j;\n            }\n        }\n    }\n    return n;\n}", "repo_id": "9", "comment": "/*\n\n\tderive the compabitle AFP lists for AFP-chaining\n\tthis is important for speeding up the process\n\tfor a given AFP(i1,j1), there are three regions that could be the starting\n\tpoint for the compabitle AFPs of AFP(i1,j1)\n\t//                 a1        a2   a3\n\t//               i1-G    i1-f-c i1-f+1 i1\n\t//                 |          |   |   |\n\t//              ----------------------------\n\t//              | B               |   |\n\t//b1  j1-G  -|  ---------------|   |\n\t//              |  |          |   |   |\n\t//              |  |     C    | 3 |   |\n\t//              |  |          |   |   |\n\t//b2 j1-f-c -|  |--------------|   |\n\t//              |  |     2    | 1 |   |\n\t//b3 j1-f+1 -|------------------   |\n\t//              |                   A |\n\t//          j1 -|---------------------\\\n\t//              |                      \\ (AFP(i1,j1))\n\t//              -----------------------------\n\t//\n\tf: the length of AFPs (we use segments of same length)\n\tG: g + f, where g is the maximum allowed gaps\n\tc: the maximum allowed cross-over in AFP-connection,\n\t\t here we use c = f, and j1-f-c = j1-2f\n\tincompatible region A: its AFPs overlap with given AFP(i1,j1)\n\tincompatible region B: the gaps between its AFP with given AFP is larger than g\n\tincompatible region C: its AFPs connect with given AFP but cross a given threshold.\n\tcompatible region 1: [i1-f-c,i1-f+1>,[j1-f-c,j1-f+1> or [a2,a3],[b2,b3]\n\tcompatible region 2: [i1-G,i1-f-c],[j1-f-c,j1-f] or [a1,a2],[b2,b3]\n\tcombine 1 and 2    : [i1-G,i1-f],[j1-f-c,j1-f]   or [a1,a3],[b2,b3]\n\tcompatible region 3: [i1-f-c,i1-f],[j1-G,j1-f-c] or [a2,a3],[b1,b2]\n\tc->misCut\n\tf->fragLen\n\tG->fragLen+maxGap->maxGapFrag\n\t *\n\t *\n\t */\n", "repo_name": "biojava-master/", "id": 413, "method_signature": "int getCompatibleAfps(int, int[], FatCatParameters, AFPChain)"}, "965": {"callee_method_names": ["String.split", "List<String>.add"], "method_name": "BioAssemblyTools.expandRange", "method_implementation": "{\n    int first = 0;\n    int last = 0;\n    try {\n        String[] range = expression.split(\"-\");\n        first = Integer.parseInt(range[0]);\n        last = Integer.parseInt(range[1]);\n    } catch (Exception e) {\n        throw new IllegalArgumentException(\"Invalid range specification in oper_expression: \" + expression);\n    }\n    List<String> expandedExpression = new ArrayList<String>(last - first + 1);\n    for (int i = first; i <= last; i++) {\n        expandedExpression.add(String.valueOf(i));\n    }\n    return expandedExpression;\n}", "repo_id": "9", "comment": "/**\n * Expands a range expression, i.e. (1-6) to a list 1,2,3,4,5,6\n * @param expression the expression to be expanded\n * @return list of items in range\n * @throws IllegalArgumentException\n */\n", "repo_name": "biojava-master/", "id": 965, "method_signature": "List<String> expandRange(String)"}, "1780": {"callee_method_names": [], "method_name": "PDBHeader.getAuthors", "method_implementation": "{\n    return authors;\n}", "repo_id": "9", "comment": "/**\n * Return the names of the authors as listed in the AUTHORS section of a PDB file.\n * Not necessarily the same authors as listed in the AUTH section of the primary citation!\n *\n * @return Authors as a string\n */\n", "repo_name": "biojava-master/", "id": 1780, "method_signature": "String getAuthors()"}, "3329": {"callee_method_names": [], "method_name": "SequenceDisplay.getIdx2", "method_implementation": "{\n    return idx2;\n}", "repo_id": "9", "comment": "/**\n * get the identical position in the alignment\n *\n * @return identical positions for structure2\n */\n", "repo_name": "biojava-master/", "id": 3329, "method_signature": "int[] getIdx2()"}, "1133": {"callee_method_names": ["File.exists"], "method_name": "LocalPDBDirectory.prefetchStructure", "method_implementation": "{\n    // Check existing\n    File file = downloadStructure(new PdbId(pdbId));\n    if (!file.exists()) {\n        throw new IOException(\"Structure \" + pdbId + \" not found and unable to download.\");\n    }\n    if (!FileDownloadUtils.validateFile(file))\n        throw new IOException(\"Downloaded file invalid: \" + file);\n}", "repo_id": "9", "comment": "/**\n * Download a structure, but don't parse it yet or store it in memory.\n *\n * Used to pre-fetch large numbers of structures.\n * @param pdbId\n * @throws IOException in cases of file I/O, including failure to download a healthy (non-corrupted) file.\n */\n", "repo_name": "biojava-master/", "id": 1133, "method_signature": "void prefetchStructure(String)"}, "689": {"callee_method_names": ["List<Atom[]>.get", "List<Matrix>.add"], "method_name": "MultipleAlignmentEnsembleImpl.updateDistanceMatrix", "method_implementation": "{\n    // Reset the distance Matrix variable\n    distanceMatrix = new ArrayList<Matrix>();\n    for (int s = 0; s < size(); s++) {\n        Atom[] ca = atomArrays.get(s);\n        Matrix distMat = AlignUtils.getDistanceMatrix(ca, ca);\n        distanceMatrix.add(distMat);\n    }\n}", "repo_id": "9", "comment": "/**\n * Force recalculation of the distance matrices.\n */\n", "repo_name": "biojava-master/", "id": 689, "method_signature": "void updateDistanceMatrix()"}, "2776": {"callee_method_names": ["Map<Integer, IUPACTable>.get"], "method_name": "IUPACParser.getTable", "method_implementation": "{\n    populateLookups();\n    return idLookup.get(id);\n}", "repo_id": "9", "comment": "/**\n * Returns a table by its identifier i.e. 1 means universal codon tables\n */\n", "repo_name": "biojava-master/", "id": 2776, "method_signature": "IUPACTable getTable(Integer)"}, "3040": {"callee_method_names": [], "method_name": "Tools.modulateCircularIndex", "method_implementation": "{\n    // Dummy case\n    if (seqLength == 0) {\n        return index;\n    }\n    // Modulate\n    while (index > seqLength) {\n        index -= seqLength;\n    }\n    return index;\n}", "repo_id": "9", "comment": "/**\n * Takes a point on a circular location and moves it left until it falls\n * at the earliest possible point that represents the same base.\n *\n * @param index Index of the position to work with\n * @param seqLength Length of the Sequence\n * @return The shifted point\n */\n", "repo_name": "biojava-master/", "id": 3040, "method_signature": "int modulateCircularIndex(int, int)"}, "782": {"callee_method_names": [], "method_name": "OptimalCECPMain.setParameters", "method_implementation": "{\n    if (!(params instanceof OptimalCECPParameters)) {\n        throw new IllegalArgumentException(\"provided parameter object is not of type CeParameter\");\n    }\n    this.params = (OptimalCECPParameters) params;\n}", "repo_id": "9", "comment": "/**\n * @param params Should be an {@link OptimalCECPParameters} object specifying alignment options\n */\n", "repo_name": "biojava-master/", "id": 782, "method_signature": "void setParameters(ConfigStrucAligParams)"}, "206": {"callee_method_names": ["String.length", "String.length", "StringBuilder.length", "StringBuilder.insert", "StringBuilder.toString"], "method_name": "FastaSequence.getFormatedSequence", "method_implementation": "{\n    if (sequence == null) {\n        return \"\";\n    }\n    assert width >= 0 : \"Wrong width parameter \";\n    final StringBuilder sb = new StringBuilder(sequence);\n    int nchunks = sequence.length() / width;\n    // add up inserted new line chars\n    nchunks = (nchunks + sequence.length()) / width;\n    int nlineCharcounter = 0;\n    for (int i = 1; i <= nchunks; i++) {\n        final int insPos = width * i + nlineCharcounter;\n        // to prevent inserting new line in the very end of a sequence then\n        // it would have failed.\n        // Also covers the case when the sequences shorter than width\n        if (sb.length() <= insPos) {\n            break;\n        }\n        sb.insert(insPos, \"\\n\");\n        nlineCharcounter++;\n    }\n    return sb.toString();\n}", "repo_id": "9", "comment": "/**\n * Format sequence per width letter in one string. Without spaces.\n *\n * @return multiple line formated sequence, one line width letters length\n */\n", "repo_name": "biojava-master/", "id": 206, "method_signature": "String getFormatedSequence(int)"}, "402": {"callee_method_names": [], "method_name": "GroupIterator.getCurrentModel", "method_implementation": "{\n    return current_model_pos;\n}", "repo_id": "9", "comment": "/**\n * Get the model number of the current model.\n *\n * @return the number of the model\n */\n", "repo_name": "biojava-master/", "id": 402, "method_signature": "int getCurrentModel()"}, "3130": {"callee_method_names": ["Document.getDocumentElement", "Element.getTextContent", "String.trim", "ArrayList<String>.add", "Element.getTextContent", "String.trim", "ArrayList<String>.add", "Element.getTextContent", "String.trim", "ArrayList<String>.add", "Element.getTextContent", "String.trim", "ArrayList<String>.add"], "method_name": "UniprotProxySequenceReader.getProteinAliases", "method_implementation": "{\n    ArrayList<String> aliasList = new ArrayList<String>();\n    if (uniprotDoc == null) {\n        return aliasList;\n    }\n    Element uniprotElement = uniprotDoc.getDocumentElement();\n    Element entryElement = XMLHelper.selectSingleElement(uniprotElement, \"entry\");\n    Element proteinElement = XMLHelper.selectSingleElement(entryElement, \"protein\");\n    ArrayList<Element> keyWordElementList;\n    getProteinAliasesFromNameGroup(aliasList, proteinElement);\n    keyWordElementList = XMLHelper.selectElements(proteinElement, \"component\");\n    for (Element element : keyWordElementList) {\n        getProteinAliasesFromNameGroup(aliasList, element);\n    }\n    keyWordElementList = XMLHelper.selectElements(proteinElement, \"domain\");\n    for (Element element : keyWordElementList) {\n        getProteinAliasesFromNameGroup(aliasList, element);\n    }\n    keyWordElementList = XMLHelper.selectElements(proteinElement, \"submittedName\");\n    for (Element element : keyWordElementList) {\n        getProteinAliasesFromNameGroup(aliasList, element);\n    }\n    keyWordElementList = XMLHelper.selectElements(proteinElement, \"cdAntigenName\");\n    for (Element element : keyWordElementList) {\n        String cdAntigenName = element.getTextContent();\n        if (null != cdAntigenName && !cdAntigenName.trim().isEmpty()) {\n            aliasList.add(cdAntigenName);\n        }\n    }\n    keyWordElementList = XMLHelper.selectElements(proteinElement, \"innName\");\n    for (Element element : keyWordElementList) {\n        String cdAntigenName = element.getTextContent();\n        if (null != cdAntigenName && !cdAntigenName.trim().isEmpty()) {\n            aliasList.add(cdAntigenName);\n        }\n    }\n    keyWordElementList = XMLHelper.selectElements(proteinElement, \"biotechName\");\n    for (Element element : keyWordElementList) {\n        String cdAntigenName = element.getTextContent();\n        if (null != cdAntigenName && !cdAntigenName.trim().isEmpty()) {\n            aliasList.add(cdAntigenName);\n        }\n    }\n    keyWordElementList = XMLHelper.selectElements(proteinElement, \"allergenName\");\n    for (Element element : keyWordElementList) {\n        String cdAntigenName = element.getTextContent();\n        if (null != cdAntigenName && !cdAntigenName.trim().isEmpty()) {\n            aliasList.add(cdAntigenName);\n        }\n    }\n    return aliasList;\n}", "repo_id": "9", "comment": "/**\n * Pull uniprot protein aliases associated with this sequence\n * @return\n * @throws XPathExpressionException\n */\n", "repo_name": "biojava-master/", "id": 3130, "method_signature": "ArrayList<String> getProteinAliases()"}, "3653": {"callee_method_names": ["LinkedHashMap.size"], "method_name": "SurvivalInfo.getNumberVariables", "method_implementation": "{\n    return data.size();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3653, "method_signature": "int getNumberVariables()"}, "3351": {"callee_method_names": ["NavigableMap<Double, Color>.containsValue"], "method_name": "GradientMapper.containsValue", "method_implementation": "{\n    return mapping.containsValue(color);\n}", "repo_id": "9", "comment": "/**\n * @param color\n * @return\n * @see java.util.Map#containsValue(java.lang.Object)\n */\n", "repo_name": "biojava-master/", "id": 3351, "method_signature": "boolean containsValue(Object)"}, "1300": {"callee_method_ids": [1352, 1347, 1349, 1352, 1347, 1349], "callee_method_names": ["List<List<Chain>>.isEmpty", "List<EntityInfo>.isEmpty", "List<List<Chain>>.get", "String.getAtomGroup", "EntityInfo.setDescription", "EntityInfo.setType", "EntityInfo.setMolId", "List<EntityInfo>.add", "EntityInfo.addChain", "String.setEntityInfo", "List<EntityInfo>.addAll", "List<List<Chain>>.get", "EntityInfo.setType", "EntityInfo.setDescription", "EntityInfo.setMolId", "EntityInfo.addChain", "List<EntityInfo>.add"], "method_name": "EntityFinder.createPurelyNonPolyEntities", "method_implementation": "{\n    if (nonPolyModels.isEmpty())\n        return;\n    // let's find first the max entity id to assign entity ids to the newly found entities\n    int maxMolId = 0;\n    if (!entities.isEmpty()) {\n        maxMolId = Collections.max(entities, Comparator.comparingInt(EntityInfo::getMolId)).getMolId();\n    }\n    // we go one over the max\n    int molId = maxMolId + 1;\n    if (!nonPolyModels.get(0).isEmpty()) {\n        List<EntityInfo> nonPolyEntities = new ArrayList<>();\n        for (List<Chain> model : nonPolyModels) {\n            for (Chain c : model) {\n                // we assume there's only 1 group per non-poly chain\n                String molecPdbName = c.getAtomGroup(0).getPDBName();\n                EntityInfo nonPolyEntity = findNonPolyEntityWithDescription(molecPdbName, nonPolyEntities);\n                if (nonPolyEntity == null) {\n                    nonPolyEntity = new EntityInfo();\n                    nonPolyEntity.setDescription(molecPdbName);\n                    nonPolyEntity.setType(EntityType.NONPOLYMER);\n                    nonPolyEntity.setMolId(molId++);\n                    nonPolyEntities.add(nonPolyEntity);\n                }\n                nonPolyEntity.addChain(c);\n                c.setEntityInfo(nonPolyEntity);\n            }\n        }\n        entities.addAll(nonPolyEntities);\n    }\n    if (!waterModels.get(0).isEmpty()) {\n        EntityInfo waterEntity = new EntityInfo();\n        waterEntity.setType(EntityType.WATER);\n        waterEntity.setDescription(\"water\");\n        waterEntity.setMolId(molId);\n        for (List<Chain> model : waterModels) {\n            for (Chain waterChain : model) {\n                waterEntity.addChain(waterChain);\n                waterChain.setEntityInfo(waterEntity);\n            }\n        }\n        entities.add(waterEntity);\n    }\n}", "repo_id": "9", "comment": "/**\n * Given all chains of all models find entities for the nonpolymers and water chains within them,\n * assigning entity ids, types and descriptions to them. The result is written back to the passed entities List.\n * @param nonPolyModels\n * @param waterModels\n * @param entities\n */\n", "repo_name": "biojava-master/", "id": 1300, "method_signature": "void createPurelyNonPolyEntities(List, List, List)"}, "2754": {"callee_method_names": [], "method_name": "EmblReference.getReferenceNumber", "method_implementation": "{\n    return referenceNumber;\n}", "repo_id": "9", "comment": "/**\n * The RN (Reference Number) line gives a unique number to each reference\n * Citation within an entry. This number is used to designate the reference\n * in comments and in the feature table.\n *\n * @return referenceNumber\n */\n", "repo_name": "biojava-master/", "id": 2754, "method_signature": "String getReferenceNumber()"}, "2948": {"callee_method_names": [], "method_name": "AbstractSequence.iterator", "method_implementation": "{\n    return getSequenceStorage().iterator();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2948, "method_signature": "Iterator<C> iterator()"}, "342": {"callee_method_ids": [641, 1322, 1451, 1450, 1459, 1438, 903, 909, 911, 901, 881, 872, 872, 875, 875, 1431, 1434, 1431, 1456, 887, 873, 893], "callee_method_names": ["AtomCache.setFiletype", "FileParsingParameters.setAlignSeqRes", "AtomCache.setFileParsingParams", "Structure.getPDBCode", "Structure.getCrystallographicInfo", "SpaceGroup.getShortSymbol", "SpaceGroup.getId", "SpaceGroup.getNumOperators", "CrystalBuilder.getUniqueInterfaces", "StructureInterfaceList.calcAsas", "StructureInterfaceList.removeInterfacesBelowArea", "StructureInterfaceList.getClusters", "StructureInterfaceList.size", "StructureInterfaceList.size", "StructureInterfaceList.get", "StructureInterface.isInfinite", "StructureInterface.getCrystalIds", "StructureInterface.getCrystalIds", "StructureInterface.getContacts", "List<AtomContact>.size", "List<AtomContact>.size", "StructureInterface.getTransforms", "StructureInterface.getTransforms", "CrystalTransform.getMatTransform", "CrystalTransform.getMatTransform", "CrystalTransform.getTransformType", "CrystalTransform.getTranslScrewComponent", "CrystalTransform.getTransformType", "Structure.isCrystallographic", "SpaceGroup.getAxisFoldType", "CrystalTransform.getTransformId", "SpaceGroup.getRotAxisAngle", "CrystalTransform.getTransformId", "StructureInterface.getContacts", "StructureInterface.getCoreResidues", "Pair<List<Group>>.getFirst", "Pair<List<Group>>.getSecond", "StructureInterface.getTotalArea", "StructureInterface.isIsologous"], "method_name": "DemoCrystalInterfaces.main", "method_implementation": "{\n    String pdbCode = \"1smt\";\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    FileParsingParameters params = new FileParsingParameters();\n    params.setAlignSeqRes(true);\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    Structure structure = StructureIO.getStructure(pdbCode);\n    System.out.println(structure.getPDBCode());\n    SpaceGroup sg = structure.getCrystallographicInfo().getSpaceGroup();\n    if (sg != null) {\n        System.out.println(sg.getShortSymbol() + \" (\" + sg.getId() + \")\");\n        System.out.println(\"Symmetry operators: \" + sg.getNumOperators());\n    }\n    System.out.println(\"Calculating possible interfaces... (using \" + NTHREADS + \" CPUs for ASA calculation)\");\n    long start = System.currentTimeMillis();\n    CrystalBuilder cb = new CrystalBuilder(structure);\n    StructureInterfaceList interfaces = cb.getUniqueInterfaces(CUTOFF);\n    interfaces.calcAsas(N_SPHERE_POINTS, NTHREADS, CONSIDER_COFACTORS);\n    interfaces.removeInterfacesBelowArea(MIN_AREA_TO_KEEP);\n    List<StructureInterfaceCluster> clusters = interfaces.getClusters();\n    //interfaces.initialiseClusters(pdb, CLUSTERING_CUTOFF, MINATOMS_CLUSTERING, \"CA\");\n    long end = System.currentTimeMillis();\n    long total = (end - start) / 1000;\n    System.out.println(\"Total time for interface calculation: \" + total + \"s\");\n    System.out.println(\"Total number of interfaces found: \" + interfaces.size());\n    for (int i = 0; i < interfaces.size(); i++) {\n        StructureInterface interf = interfaces.get(i + 1);\n        String infiniteStr = \"\";\n        if (interf.isInfinite())\n            infiniteStr = \" -- INFINITE interface\";\n        System.out.println(\"\\n##Interface \" + (i + 1) + \" \" + interf.getCrystalIds().getFirst() + \"-\" + interf.getCrystalIds().getSecond() + infiniteStr);\n        // warning if more than 10 clashes found at interface\n        List<AtomContact> clashing = interf.getContacts().getContactsWithinDistance(CLASH_DISTANCE);\n        if (clashing.size() > 10)\n            System.out.println(clashing.size() + \" CLASHES!!!\");\n        CrystalTransform transf1 = interf.getTransforms().getFirst();\n        CrystalTransform transf2 = interf.getTransforms().getSecond();\n        System.out.println(\"Transf1: \" + SpaceGroup.getAlgebraicFromMatrix(transf1.getMatTransform()) + \". Transf2: \" + SpaceGroup.getAlgebraicFromMatrix(transf2.getMatTransform()));\n        String screwStr = \"\";\n        if (transf2.getTransformType().isScrew()) {\n            Vector3d screwTransl = transf2.getTranslScrewComponent();\n            screwStr = \" -- \" + transf2.getTransformType().getShortName() + \" with translation \" + String.format(\"(%5.2f,%5.2f,%5.2f)\", screwTransl.x, screwTransl.y, screwTransl.z);\n        }\n        if (structure.isCrystallographic()) {\n            int foldType = sg.getAxisFoldType(transf2.getTransformId());\n            AxisAngle4d axisAngle = sg.getRotAxisAngle(transf2.getTransformId());\n            System.out.println(\" \" + foldType + \"-fold on axis \" + String.format(\"(%5.2f,%5.2f,%5.2f)\", axisAngle.x, axisAngle.y, axisAngle.z) + screwStr);\n        }\n        System.out.println(\"Number of contacts: \" + interf.getContacts().size());\n        //System.out.println(\"Number of contacting atoms (from both molecules): \"+interf.getNumAtomsInContact());\n        Pair<List<Group>> cores = interf.getCoreResidues(BSATOASA_CUTOFF, MIN_ASA_FOR_SURFACE);\n        System.out.println(\"Number of core residues at \" + String.format(\"%4.2f\", BSATOASA_CUTOFF) + \" bsa to asa cutoff: \" + cores.getFirst().size() + \" \" + cores.getSecond().size());\n        System.out.printf(\"Interface area: %8.2f\\n\", interf.getTotalArea());\n        if (interf.isIsologous()) {\n            System.out.println(\"Isologous\");\n        } else {\n            System.out.println(\"Heterologous\");\n        }\n    }\n    System.out.println(\"Interface clusters (one per line): \");\n    for (StructureInterfaceCluster cluster : clusters) {\n        System.out.print(cluster.getId() + \": \");\n        for (StructureInterface member : cluster.getMembers()) {\n            System.out.print(member.getId() + \" \");\n        }\n        System.out.println();\n    }\n}", "repo_id": "9", "comment": "/**\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 342, "method_signature": "void main(String[])"}, "386": {"callee_method_names": ["Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get"], "method_name": "Calc.getZYZEuler", "method_implementation": "{\n    double m22 = m.get(2, 2);\n    double rY = Math.toDegrees(Math.acos(m22));\n    double rZ1, rZ2;\n    if (m22 > .999d || m22 < -.999d) {\n        rZ1 = Math.toDegrees(Math.atan2(m.get(1, 0), m.get(1, 1)));\n        rZ2 = 0;\n    } else {\n        rZ1 = Math.toDegrees(Math.atan2(m.get(2, 1), -m.get(2, 0)));\n        rZ2 = Math.toDegrees(Math.atan2(m.get(1, 2), m.get(0, 2)));\n    }\n    return new double[] { rZ1, rY, rZ2 };\n}", "repo_id": "9", "comment": "/**\n * Gets euler angles for a matrix given in ZYZ convention. (as e.g. used by\n * Jmol)\n *\n * @param m\n *            the rotation matrix\n * @return the euler values for a rotation around Z, Y, Z in degrees...\n */\n", "repo_name": "biojava-master/", "id": 386, "method_signature": "double[] getZYZEuler(Matrix)"}, "1680": {"callee_method_ids": [1004, 1007, 1004, 1008, 1004], "callee_method_names": ["AtomPositionMap.getPosition", "ResidueNumber.printFull", "AtomPositionMap.getFirst", "AtomPositionMap.getPosition", "AtomPositionMap.getLast", "AtomPositionMap.getPosition"], "method_name": "ResidueRange.contains", "method_implementation": "{\n    if (residueNumber == null)\n        throw new NullPointerException(\"Can't find the ResidueNumber because it is null\");\n    if (map == null)\n        throw new NullPointerException(\"The AtomPositionMap must be non-null\");\n    Integer pos = map.getPosition(residueNumber);\n    if (pos == null)\n        throw new IllegalArgumentException(\"Couldn't find residue \" + residueNumber.printFull());\n    ResidueNumber startResidue = getStart() == null ? map.getFirst(getChainName()) : getStart();\n    Integer startPos = map.getPosition(startResidue);\n    if (startPos == null)\n        throw new IllegalArgumentException(\"Couldn't find the start position\");\n    ResidueNumber endResidue = getEnd() == null ? map.getLast(getChainName()) : getEnd();\n    Integer endPos = map.getPosition(endResidue);\n    if (endPos == null)\n        throw new IllegalArgumentException(\"Couldn't find the end position\");\n    return pos >= startPos && pos <= endPos;\n}", "repo_id": "9", "comment": "/**\n * @return True if and only if {@code residueNumber} is within this ResidueRange\n */\n", "repo_name": "biojava-master/", "id": 1680, "method_signature": "boolean contains(ResidueNumber, AtomPositionMap)"}, "2150": {"callee_method_names": [], "method_name": "StructureImpl.getPDBHeader", "method_implementation": "{\n    return pdbHeader;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2150, "method_signature": "PDBHeader getPDBHeader()"}, "56": {"callee_method_names": [], "method_name": "AbstractPairwiseSequenceAligner.setTarget", "method_implementation": "{\n    this.target = target;\n    reset();\n}", "repo_id": "9", "comment": "/**\n * Sets the target {@link Sequence}.\n *\n * @param target the second {@link Sequence} of the pair to align\n */\n", "repo_name": "biojava-master/", "id": 56, "method_signature": "void setTarget(S)"}, "2209": {"callee_method_names": ["Chain.getAtomGroup", "Group.getAltLocs", "Group.getAtom", "Group.getAtom", "Atom.getX", "Atom.getY", "Atom.getZ", "Atom.getX", "Atom.getY", "Atom.getZ"], "method_name": "TestCalc.testChainTransform", "method_implementation": "{\n    Chain c = createDummyChain();\n    // shift of 1 in x axis\n    Matrix4d m = new Matrix4d(1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    Calc.transform(c, m);\n    Group thegroup = c.getAtomGroup(0);\n    Group thealtlocgroup = thegroup.getAltLocs().get(0);\n    Atom atom1 = thegroup.getAtom(\"CA\");\n    Atom atom2 = thealtlocgroup.getAtom(\"CA\");\n    // x should be shifted by 1\n    assertEquals(2, atom1.getX(), 0.00001);\n    assertEquals(1, atom1.getY(), 0.00001);\n    assertEquals(1, atom1.getZ(), 0.00001);\n    // x should be shifted by 1\n    assertEquals(3, atom2.getX(), 0.00001);\n    assertEquals(2, atom2.getY(), 0.00001);\n    assertEquals(2, atom2.getZ(), 0.00001);\n}", "repo_id": "9", "comment": "/**\n * Issue https://github.com/biojava/biojava/issues/715\n */\n", "repo_name": "biojava-master/", "id": 2209, "method_signature": "void testChainTransform()"}, "726": {"callee_method_names": [], "method_name": "CECalculator.getMatMatrix", "method_implementation": "{\n    return mat;\n}", "repo_id": "9", "comment": "/**\n * Caution: this matrix is overwriten with very different data at several\n * points in the alignment algorithm. After\n * {@link #initSumOfDistances(int, int, int, int, Atom[], Atom[]) initSumOfDistances}\n * is run, this will hold the distance matrix between AFPs.\n * @return mat\n */\n", "repo_name": "biojava-master/", "id": 726, "method_signature": "double[][] getMatMatrix()"}, "3651": {"callee_method_names": ["LinkedHashMap.keySet", "String.startsWith", "ArrayList<String>.add"], "method_name": "SurvivalInfo.getGroupCategories", "method_implementation": "{\n    ArrayList<String> groupNameList = new ArrayList<String>();\n    for (String key : data.keySet()) {\n        if (key.startsWith(groupName + \"_\")) {\n            groupNameList.add(key);\n        }\n    }\n    return groupNameList;\n}", "repo_id": "9", "comment": "/**\n * @param groupName\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3651, "method_signature": "ArrayList<String> getGroupCategories(String)"}, "2639": {"callee_method_names": [], "method_name": "DNASequence.getReverse", "method_implementation": "{\n    return new ReversedSequenceView<NucleotideCompound>(this);\n}", "repo_id": "9", "comment": "/**\n * Returns a Sequence which runs in the current reverse order\n */\n", "repo_name": "biojava-master/", "id": 2639, "method_signature": "SequenceView<NucleotideCompound> getReverse()"}, "3518": {"callee_method_names": [], "method_name": "StrataInfo.getUpper", "method_implementation": "{\n    return upper;\n}", "repo_id": "9", "comment": "/**\n * @return the upper\n */\n", "repo_name": "biojava-master/", "id": 3518, "method_signature": "ArrayList<Double> getUpper()"}, "198": {"callee_method_names": ["List<Range>.add", "List<Range>.add", "List<Range>.toArray", "List<Range>.size"], "method_name": "Jronn.scoresToRanges", "method_implementation": "{\n    assert scores != null && scores.length > 0;\n    assert probability > 0 && probability < 1;\n    int count = 0;\n    int regionLen = 0;\n    List<Range> ranges = new ArrayList<Range>();\n    for (float score : scores) {\n        count++;\n        // Round to 2 decimal points before comparison\n        score = (float) (Math.round(score * 100.0) / 100.0);\n        if (score > probability) {\n            regionLen++;\n        } else {\n            if (regionLen > 0) {\n                ranges.add(new Range(count - regionLen, count - 1, score));\n            }\n            regionLen = 0;\n        }\n    }\n    // In case of the range to boundary runs to the very end of the sequence\n    if (regionLen > 1) {\n        ranges.add(new Range(count - regionLen + 1, count, scores[scores.length - 1]));\n    }\n    return ranges.toArray(new Range[ranges.size()]);\n}", "repo_id": "9", "comment": "/**\n * Convert raw scores to ranges. Gives ranges for given probability of disorder value\n * @param scores the raw probability of disorder scores for each residue in the sequence.\n * @param probability the cut off threshold. Include all residues with the probability of disorder greater then this value\n * @return the array of ranges if there are any residues predicted to have the\n * probability of disorder greater then {@code probability}, null otherwise.\n */\n", "repo_name": "biojava-master/", "id": 198, "method_signature": "Range[] scoresToRanges(float[], float)"}, "524": {"callee_method_names": ["ResidueNumber.setChainName", "Atom[].getGroup", "ResidueNumber.setChainName", "Group.getChain", "Group.getResidueNumber", "Group.getChain", "Chain.getName"], "method_name": "AFPChainXMLParser.getPositionForPDBresunm", "method_implementation": "{\n    ResidueNumber residueNumber = ResidueNumber.fromString(pdbresnum);\n    residueNumber.setChainName(authId);\n    boolean blankChain = authId == null || \"null\".equalsIgnoreCase(authId) || \"_\".equals(authId);\n    for (int i = 0; i < atoms.length; i++) {\n        Group g = atoms[i].getGroup();\n        // match _ to any chain\n        if (blankChain) {\n            residueNumber.setChainName(g.getChain().getName());\n        }\n        //System.out.println(g.getResidueNumber() + \"< ? >\" + residueNumber +\"<\");\n        if (g.getResidueNumber().equals(residueNumber)) {\n            //System.out.println(g + \" == \" + residueNumber );\n            Chain c = g.getChain();\n            if (blankChain || c.getName().equals(authId)) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}", "repo_id": "9", "comment": "/**\n * get the position of PDB residue nr X in the ato marray\n *\n * @param pdbresnum pdbresidue number\n * @param authId chain name\n * @param atoms atom array\n * @return\n */\n", "repo_name": "biojava-master/", "id": 524, "method_signature": "int getPositionForPDBresunm(String, String, Atom[])"}, "2454": {"callee_method_names": [], "method_name": "Feature.location", "method_implementation": "{\n    return mLocation;\n}", "repo_id": "9", "comment": "/**\n * Get location of feature. Note that feature objects have\n * no link or reference to the actual sequence object to which\n * they refer; they are completely uncoupled.\n *\n * @return Location of feature.\n */\n", "repo_name": "biojava-master/", "id": 2454, "method_signature": "Location location()"}, "2284": {"callee_method_names": ["Site.toPDB"], "method_name": "SiteTest.testToPDB_0args", "method_implementation": "{\n    //        System.out.println(\"toPDB_0args\");\n    String expResult = \"SITE     1 AC1  6 ARG H 221A LYS H 224  HOH H 403  HOH H 460                    \" + newline + \"SITE     2 AC1  6 HOH H 464  HOH H 497                                          \" + newline;\n    String result = bindingSite.toPDB();\n    //        System.out.println(\"Expected:\");\n    //        System.out.println(expResult);\n    //        System.out.println(\"Got:\");\n    //        System.out.println(result);\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of toPDB method, of class Site.\n */\n", "repo_name": "biojava-master/", "id": 2284, "method_signature": "void testToPDB_0args()"}, "744": {"callee_method_names": [], "method_name": "CeCalculatorEnhanced.getRotationMatrix", "method_implementation": "{\n    return r;\n}", "repo_id": "9", "comment": "/**\n * Gets the rotation matrix from the last call to\n * {@link #calc_rmsd(Atom[], Atom[], int, boolean, boolean) calc_rmsd}.\n * @return The rotatiokn matrix\n */\n", "repo_name": "biojava-master/", "id": 744, "method_signature": "Matrix getRotationMatrix()"}, "220": {"callee_method_names": ["ScopedProperty.close", "ScopedProperty.close"], "method_name": "JronnTest.checkJronn", "method_implementation": "{\n    // Windows CRLF\n    ScopedProperty lineSepProp = new ScopedProperty(\"line.separator\", \"\\r\\n\");\n    verifyRanges();\n    lineSepProp.close();\n    // UNIX LF\n    ScopedProperty lineSepPropUnix = new ScopedProperty(\"line.separator\", \"\\n\");\n    verifyRanges();\n    lineSepPropUnix.close();\n}", "repo_id": "9", "comment": "/**\n * Jronn was breaking on Windows platform due to the different System.getProperty(\"line.separator\") values\n * (CRLF vs LF).  This wraps the existing unit testing to show that it works on windows or unix.\n */\n", "repo_name": "biojava-master/", "id": 220, "method_signature": "void checkJronn()"}, "2798": {"callee_method_names": ["GenbankReader<ProteinSequence, AminoAcidCompound>.process"], "method_name": "GenbankReaderHelper.readGenbankProteinSequence", "method_implementation": "{\n    GenbankReader<ProteinSequence, AminoAcidCompound> GenbankReader = new GenbankReader<ProteinSequence, AminoAcidCompound>(inStream, new GenericGenbankHeaderParser<ProteinSequence, AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n    return GenbankReader.process();\n}", "repo_id": "9", "comment": "/**\n * Read a Genbank file containing amino acids with setup that would handle most\n * cases. User is responsible for closing InputStream because you opened it\n *\n * @param inStream\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2798, "method_signature": "LinkedHashMap<String,ProteinSequence> readGenbankProteinSequence(InputStream)"}, "3116": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getCompoundAt", "method_implementation": "{\n    return this.parsedCompounds.get(position - 1);\n}", "repo_id": "9", "comment": "/**\n * @param position\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3116, "method_signature": "C getCompoundAt(int)"}, "264": {"callee_method_names": [], "method_name": "ModificationLinkage.getIndexOfComponent1", "method_implementation": "{\n    return indexOfComponent1;\n}", "repo_id": "9", "comment": "/**\n * @return index of the first component.\n */\n", "repo_name": "biojava-master/", "id": 264, "method_signature": "int getIndexOfComponent1()"}, "939": {"callee_method_ids": [922, 923], "callee_method_names": ["List<Contact>.addAll", "GridCell.getContactsWithinCell", "List<Contact>.addAll", "GridCell.getContactsToOtherCell"], "method_name": "Grid.getIndicesContacts", "method_implementation": "{\n    List<Contact> list = new ArrayList<>();\n    // if the 2 sets of atoms are not overlapping they are too far away and no need to calculate anything\n    // this won't apply if there's only one set of atoms (iAtoms), where we would want all-to-all contacts\n    if (noOverlap)\n        return list;\n    for (int xind = 0; xind < cells.length; xind++) {\n        for (int yind = 0; yind < cells[xind].length; yind++) {\n            for (int zind = 0; zind < cells[xind][yind].length; zind++) {\n                // distances of points within this cell\n                GridCell thisCell = cells[xind][yind][zind];\n                if (thisCell == null)\n                    continue;\n                list.addAll(thisCell.getContactsWithinCell());\n                // distances of points from this box to all neighbouring boxes: 26 iterations (26 neighbouring boxes)\n                for (int x = xind - 1; x <= xind + 1; x++) {\n                    for (int y = yind - 1; y <= yind + 1; y++) {\n                        for (int z = zind - 1; z <= zind + 1; z++) {\n                            if (x == xind && y == yind && z == zind)\n                                continue;\n                            if (x >= 0 && x < cells.length && y >= 0 && y < cells[x].length && z >= 0 && z < cells[x][y].length) {\n                                if (cells[x][y][z] == null)\n                                    continue;\n                                list.addAll(thisCell.getContactsToOtherCell(cells[x][y][z]));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Returns all contacts, i.e. all atoms that are within the cutoff distance, as simple Contact objects containing the atom indices pairs and the distance.\n * If both iAtoms and jAtoms are defined then contacts are between iAtoms and jAtoms,\n * if jAtoms is null, then contacts are within the iAtoms.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 939, "method_signature": "List<Contact> getIndicesContacts()"}, "2989": {"callee_method_names": [], "method_name": "BitSequenceReader.getSubSequence", "method_implementation": "{\n    return SequenceMixin.createSubSequence(this, start, end);\n}", "repo_id": "9", "comment": "/**\n * Returns a sub sequence view\n */\n", "repo_name": "biojava-master/", "id": 2989, "method_signature": "SequenceView<C> getSubSequence(int, int)"}, "1742": {"callee_method_names": [], "method_name": "BasePairParameters.cross", "method_implementation": "{\n    assert a.length >= 3 && b.length >= 3;\n    double[] result = new double[4];\n    result[0] = a[1] * b[2] - a[2] * b[1];\n    result[1] = a[2] * b[0] - a[0] * b[2];\n    result[2] = a[0] * b[1] - a[1] * b[0];\n    return result;\n}", "repo_id": "9", "comment": "/**\n * This does a 3D Vector cross product of two vectors as double arrays. (used internally)\n *\n * @param a An array of length 3 or 4 (4th component is ignored)\n * @param b An array of length 3 or 4 (4th component is ignored)\n * @return The cross product of the vectors (just the first three components\n */\n", "repo_name": "biojava-master/", "id": 1742, "method_signature": "double[] cross(double[], double[])"}, "2265": {"callee_method_ids": [641, 638, 1330, 1322, 1095], "callee_method_names": ["AtomCache.setFiletype", "AtomCache.setFetchBehavior", "AtomCache.getFileParsingParams", "FileParsingParameters.setCreateAtomBonds", "FileParsingParameters.setAlignSeqRes", "FileParsingParameters.setParseBioAssembly", "DownloadChemCompProvider.checkDoFirstInstall", "AtomCache.setFileParsingParams", "Structure.getChains", "Chain.getAtomGroups", "Chain.getAtoms", "Block.getBonds", "Block.getBonds", "Chain.getOther", "List<Atom>.indexOf", "List<Atom>.size"], "method_name": "TestBondFinding.getInterBonds", "method_implementation": "{\n    // Download parameters\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    cache.setFetchBehavior(FetchBehavior.FETCH_FILES);\n    FileParsingParameters params = cache.getFileParsingParams();\n    params.setCreateAtomBonds(true);\n    params.setAlignSeqRes(true);\n    params.setParseBioAssembly(true);\n    DownloadChemCompProvider dcc = new DownloadChemCompProvider();\n    ChemCompGroupFactory.setChemCompProvider(dcc);\n    dcc.checkDoFirstInstall();\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    // Get the structure\n    Structure newStruc = StructureIO.getStructure(pdbId);\n    int counter = 0;\n    // Loop through the atoms and count the bonds\n    for (Chain c : newStruc.getChains()) {\n        for (Group g : c.getAtomGroups()) {\n            List<Atom> theseAtoms = g.getAtoms();\n            for (Atom a : theseAtoms) {\n                List<Bond> theseBonds = a.getBonds();\n                if (theseBonds != null) {\n                    for (Bond b : a.getBonds()) {\n                        Atom other = b.getOther(a);\n                        int indexOther = theseAtoms.indexOf(other);\n                        // Check if the index is within the group\n                        if (indexOther < 0 || indexOther >= theseAtoms.size()) {\n                            counter++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return counter;\n}", "repo_id": "9", "comment": "/**\n * Find all of the inter group bonds in a structure.\n *\n * @param pdbId the pdb id of the structure to determine\n * @return the number of inter group bonds (double counted) in a structure\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2265, "method_signature": "int getInterBonds(String)"}, "2601": {"callee_method_names": ["Object.getClass", "Object.getClass"], "method_name": "Equals.classEqual", "method_implementation": "{\n    return one == two || !(one == null || two == null) && one.getClass() == two.getClass();\n}", "repo_id": "9", "comment": "/**\n * This method should be called before beginning any equals methods. In order\n * to return true the method:\n *\n * <ol>\n * <li>The two given objects are the same instance using ==. This also means\n * if both Objects are null then this method will return true (well\n * technically they are equal)</li>\n * <li>Tests that neither object is null</li>\n * <li>The the two classes from the objects are equal using ==</li>\n * </ol>\n *\n * The boilerplate using this method then becomes:\n *\n * <pre>\n * boolean equals = false;\n * if (EqualsHelper.classEqual(this, obj)) {\n *   TargetClass casted = (TargetClass) obj;\n *   equals = (EqualsHelper.equal(this.getId(), casted.getId()) &amp;&amp; EqualsHelper\n *       .equal(this.getName(), casted.getName()));\n * }\n * return equals;\n * </pre>\n *\n * @param one\n *          The first object to test\n * @param two\n *          The second object to test\n * @return A boolean indicating if  these two objects are\n *         equal at the class level\n */\n", "repo_name": "biojava-master/", "id": 2601, "method_signature": "boolean classEqual(Object, Object)"}, "388": {"callee_method_names": ["Matrix.set", "Matrix.set", "Matrix.set", "Matrix.set", "Matrix.set", "Matrix.set", "Matrix.set", "Matrix.set", "Matrix.set"], "method_name": "Calc.matrixFromEuler", "method_implementation": "{\n    // Assuming the angles are in radians.\n    double ch = Math.cos(heading);\n    double sh = Math.sin(heading);\n    double ca = Math.cos(attitude);\n    double sa = Math.sin(attitude);\n    double cb = Math.cos(bank);\n    double sb = Math.sin(bank);\n    Matrix m = new Matrix(3, 3);\n    m.set(0, 0, ch * ca);\n    m.set(0, 1, sh * sb - ch * sa * cb);\n    m.set(0, 2, ch * sa * sb + sh * cb);\n    m.set(1, 0, sa);\n    m.set(1, 1, ca * cb);\n    m.set(1, 2, -ca * sb);\n    m.set(2, 0, -sh * ca);\n    m.set(2, 1, sh * sa * cb + ch * sb);\n    m.set(2, 2, -sh * sa * sb + ch * cb);\n    return m;\n}", "repo_id": "9", "comment": "/**\n * This conversion uses NASA standard aeroplane conventions as described on\n * page:\n *   http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n * Coordinate System: right hand Positive angle: right hand Order of euler\n * angles: heading first, then attitude, then bank. matrix row column\n * ordering: [m00 m01 m02] [m10 m11 m12] [m20 m21 m22]\n *\n * @param heading\n *            in radians\n * @param attitude\n *            in radians\n * @param bank\n *            in radians\n * @return the rotation matrix\n */\n", "repo_name": "biojava-master/", "id": 388, "method_signature": "Matrix matrixFromEuler(double, double, double)"}, "781": {"callee_method_names": [], "method_name": "OptimalCECPMain.getParameters", "method_implementation": "{\n    return params;\n}", "repo_id": "9", "comment": "/**\n * @return an {@link OptimalCECPParameters} object\n */\n", "repo_name": "biojava-master/", "id": 781, "method_signature": "ConfigStrucAligParams getParameters()"}, "964": {"callee_method_names": ["String.indexOf", "String.lastIndexOf"], "method_name": "BioAssemblyTools.isUnaryExpression", "method_implementation": "{\n    int first = expression.indexOf(\"(\");\n    int last = expression.lastIndexOf(\"(\");\n    if (first < 0 || last < 0) {\n        return true;\n    }\n    return !(first == 0 && last > first);\n}", "repo_id": "9", "comment": "/**\n * Checks if the passed in expression is a unary operator expression\n * Example: (1,2,3) or (1-60) are unary operator expressions\n *          (1-60)(61-88) is a binary operator expression, representing\n *          a cartesian product of the two parenthesised lists\n *\n * @param expression\n * @return true if expression is a unary operator expression\n */\n", "repo_name": "biojava-master/", "id": 964, "method_signature": "boolean isUnaryExpression(String)"}, "525": {"callee_method_ids": [490, 487, 489, 481, 492, 485, 484, 486, 500, 491, 499, 501, 496, 495, 498, 497, 507, 3580], "callee_method_names": ["AFPChain.getAlgorithmName", "AFPChain.setVersion", "AFPChain.getVersion", "AFPChain.setName2", "AFPChain.getName1", "AFPChain.setName1", "AFPChain.getName2", "AFPChain.setCa1Length", "AFPChain.getCa2Length", "AFPChain.setCa2Length", "AFPChain.getCa1Length", "AFPChain.getOptLen", "AFPChain.setOptLen", "AFPChain.getBlockNum", "AFPChain.setBlockNum", "AFPChain.setBlockSize", "AFPChain.getBlockSize", "AFPChain.setBlockScore", "AFPChain.getBlockScore", "AFPChain.setBlockRmsd", "AFPChain.getBlockRmsd", "AFPChain.setBlockGap", "AFPChain.getBlockGap", "AFPChain.getCa1Length", "AFPChain.getCa2Length", "AFPChain.getOptAln", "AFPChain.getPdbAln", "AFPChain.setOptAln", "AFPChain.setPdbAln", "AFPChain.setAlnLength", "AFPChain.getAlnLength", "AFPChain.setAlignScore", "AFPChain.getAlignScore", "AFPChain.setAlignScoreUpdate", "AFPChain.getAlignScoreUpdate", "AFPChain.setAfpSet", "AFPChain.getAfpSet", "AFPChain.setChainRmsd", "AFPChain.getChainRmsd", "AFPChain.setFocusRes1", "AFPChain.getFocusRes2", "AFPChain.setFocusRes2", "AFPChain.getFocusRes1", "AFPChain.setFocusResn", "AFPChain.getFocusResn", "AFPChain.setGapLen", "AFPChain.getGapLen", "AFPChain.setIdentity", "AFPChain.getIdentity", "AFPChain.setNormAlignScore", "AFPChain.getNormAlignScore", "AFPChain.setOptLength", "AFPChain.getOptLength", "AFPChain.setProbability", "AFPChain.getProbability", "AFPChain.setSimilarity", "AFPChain.getSimilarity", "AFPChain.setTotalLenIni", "AFPChain.getTotalLenIni", "AFPChain.setTotalRmsdIni", "AFPChain.getTotalRmsdIni", "AFPChain.setTotalRmsdOpt", "AFPChain.getTotalRmsdOpt", "AFPChain.setTMScore", "AFPChain.getTMScore", "AFPChain.getBlockRotationMatrix", "AFPChain.getBlockShiftVector", "Matrix.transpose", "AFPChain.setBlockRotationMatrix", "AFPChain.setBlockShiftVector"], "method_name": "AFPChainFlipper.flipChain", "method_implementation": "{\n    AFPChain n = new AFPChain(o.getAlgorithmName());\n    n.setVersion(o.getVersion());\n    n.setName2(o.getName1());\n    n.setName1(o.getName2());\n    n.setCa1Length(o.getCa2Length());\n    n.setCa2Length(o.getCa1Length());\n    int[] optLen = o.getOptLen();\n    n.setOptLen(optLen);\n    int blockNum = o.getBlockNum();\n    n.setBlockNum(blockNum);\n    n.setBlockSize(o.getBlockSize());\n    n.setBlockScore(o.getBlockScore());\n    n.setBlockRmsd(o.getBlockRmsd());\n    n.setBlockGap(o.getBlockGap());\n    int minLength = Math.min(n.getCa1Length(), n.getCa2Length());\n    int[][][] optAlnN = new int[blockNum][2][minLength];\n    int[][][] optAlnO = o.getOptAln();\n    String[][][] pdbAlnN = new String[blockNum][2][minLength];\n    String[][][] pdbAlnO = o.getPdbAln();\n    if ((optAlnO == null) && (pdbAlnO == null)) {\n        System.err.println(\"Can't get either optAln or pdbAln data from original AFPChain. Not enough information to recreate alignment!\");\n    }\n    for (int blockNr = 0; blockNr < blockNum; blockNr++) {\n        for (int eqrNr = 0; eqrNr < optLen[blockNr]; eqrNr++) {\n            if (optAlnO != null) {\n                optAlnN[blockNr][0][eqrNr] = optAlnO[blockNr][1][eqrNr];\n                optAlnN[blockNr][1][eqrNr] = optAlnO[blockNr][0][eqrNr];\n            }\n            if (pdbAlnO != null) {\n                pdbAlnN[blockNr][0][eqrNr] = pdbAlnO[blockNr][1][eqrNr];\n                pdbAlnN[blockNr][1][eqrNr] = pdbAlnO[blockNr][0][eqrNr];\n            }\n        }\n    }\n    n.setOptAln(optAlnN);\n    if (pdbAlnO != null) {\n        n.setPdbAln(pdbAlnN);\n    }\n    n.setAlnLength(o.getAlnLength());\n    n.setAlignScore(o.getAlignScore());\n    n.setAlignScoreUpdate(o.getAlignScoreUpdate());\n    n.setAfpSet(o.getAfpSet());\n    n.setChainRmsd(o.getChainRmsd());\n    n.setFocusRes1(o.getFocusRes2());\n    n.setFocusRes2(o.getFocusRes1());\n    n.setFocusResn(o.getFocusResn());\n    n.setGapLen(o.getGapLen());\n    n.setIdentity(o.getIdentity());\n    n.setNormAlignScore(o.getNormAlignScore());\n    n.setOptLength(o.getOptLength());\n    n.setProbability(o.getProbability());\n    n.setSimilarity(o.getSimilarity());\n    n.setTotalLenIni(o.getTotalLenIni());\n    n.setTotalRmsdIni(o.getTotalRmsdIni());\n    n.setTotalRmsdOpt(o.getTotalRmsdOpt());\n    n.setTMScore(o.getTMScore());\n    // change direction of the Matrix and shift!\n    //\n    Matrix[] maxO = o.getBlockRotationMatrix();\n    Matrix[] maxN = new Matrix[maxO.length];\n    int i = -1;\n    Atom[] shiftO = o.getBlockShiftVector();\n    Atom[] shiftN = new Atom[shiftO.length];\n    for (Matrix m : maxO) {\n        i++;\n        if (m == null) {\n            // alignment too short probably\n            continue;\n        }\n        Matrix mnew = m;\n        Atom a = shiftO[i];\n        maxN[i] = mnew.transpose();\n        shiftN[i] = Calc.invert(a);\n        Calc.rotate(shiftN[i], maxN[i]);\n    }\n    n.setBlockRotationMatrix(maxN);\n    n.setBlockShiftVector(shiftN);\n    return n;\n}", "repo_id": "9", "comment": "/**\n * Flip the position of name1 and name2 (as well as all underlying data) in an AFPChain.\n * This is a utility function for AFPChainXMLParser.\n * You will have to call AFPCHainXMLParser.rebuildAFPChain in order to get twisted groups...\n *\n * @param o ... the original AFPCHain that should be flipped\n * @return a cloned AFPCHain which the positions of name1 and name2 flipped.\n */\n", "repo_name": "biojava-master/", "id": 525, "method_signature": "AFPChain flipChain(AFPChain)"}, "1949": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setTm", "method_implementation": "{\n    this.tm = tm;\n}", "repo_id": "9", "comment": "/**\n * @param tm the tm to set\n */\n", "repo_name": "biojava-master/", "id": 1949, "method_signature": "void setTm(double)"}, "1853": {"callee_method_names": [], "method_name": "Rotation.getTraceRmsd", "method_implementation": "{\n    return traceRmsd;\n}", "repo_id": "9", "comment": "/**\n * @return the traceRmsd\n */\n", "repo_name": "biojava-master/", "id": 1853, "method_signature": "double getTraceRmsd()"}, "471": {"callee_method_names": ["ScopDatabase.getDomainByScopID", "Logger.warn", "Pattern.matcher", "Matcher.matches", "Matcher.group", "Matcher.group", "Matcher.group", "ScopDatabase.getDomainsForPDB", "Pattern.matcher", "Matcher.matches", "String.equals", "Matcher.group", "Matcher.group", "Matcher.group", "String.equals", "Matcher.group", "Matcher.group", "List<ScopDomain>.add", "List<ScopDomain>.iterator", "Iterator<ScopDomain>.hasNext", "Iterator<ScopDomain>.next", "Logger.isWarnEnabled", "StringBuilder.append", "ScopDomain.getScopId", "Iterator<ScopDomain>.hasNext", "StringBuilder.append", "Iterator<ScopDomain>.hasNext", "StringBuilder.append", "Iterator<ScopDomain>.next", "StringBuilder.append", "Logger.warn", "StringBuilder.toString"], "method_name": "StructureName.guessScopDomain", "method_implementation": "{\n    List<ScopDomain> matches = new LinkedList<ScopDomain>();\n    // Try exact match first\n    ScopDomain domain = scopDB.getDomainByScopID(name);\n    if (domain != null) {\n        return domain;\n    }\n    // Didn't work. Guess it!\n    logger.warn(\"Warning, could not find SCOP domain: \" + name);\n    Matcher scopMatch = scopPattern.matcher(name);\n    if (scopMatch.matches()) {\n        String pdbID = scopMatch.group(1);\n        String chainName = scopMatch.group(2);\n        String domainID = scopMatch.group(3);\n        for (ScopDomain potentialSCOP : scopDB.getDomainsForPDB(pdbID)) {\n            Matcher potMatch = scopPattern.matcher(potentialSCOP.getScopId());\n            if (potMatch.matches()) {\n                if (chainName.equals(potMatch.group(2)) || \"_\".equals(chainName) || \".\".equals(chainName) || \"_\".equals(potMatch.group(2)) || \".\".equals(potMatch.group(2))) {\n                    if (domainID.equals(potMatch.group(3)) || \"_\".equals(domainID) || \"_\".equals(potMatch.group(3))) {\n                        // Match, or near match\n                        matches.add(potentialSCOP);\n                    }\n                }\n            }\n        }\n    }\n    Iterator<ScopDomain> match = matches.iterator();\n    if (match.hasNext()) {\n        ScopDomain bestMatch = match.next();\n        if (logger.isWarnEnabled()) {\n            StringBuilder warnMsg = new StringBuilder();\n            warnMsg.append(\"Trying domain \" + bestMatch.getScopId() + \".\");\n            if (match.hasNext()) {\n                warnMsg.append(\" Other possibilities: \");\n                while (match.hasNext()) {\n                    warnMsg.append(match.next().getScopId()).append(\" \");\n                }\n            }\n            warnMsg.append(System.getProperty(\"line.separator\"));\n            logger.warn(warnMsg.toString());\n        }\n        return bestMatch;\n    } else {\n        return null;\n    }\n}", "repo_id": "9", "comment": "/**\n * <p>\n * Guess a scop domain. If an exact match is found, return that.\n *\n * <p>\n * Otherwise, return the first scop domain found for the specified protein such that\n * <ul>\n * <li>The chains match, or one of the chains is '_' or '.'.\n * <li>The domains match, or one of the domains is '_'.\n * </ul>\n *\n * In some cases there may be several valid matches. In this case a warning\n * will be logged.\n *\n * @param name SCOP domain name, or a guess thereof\n * @param scopDB SCOP domain provider\n * @return The best match for name among the domains of scopDB, or null if none match.\n */\n", "repo_name": "biojava-master/", "id": 471, "method_signature": "ScopDomain guessScopDomain(String, ScopDatabase)"}, "2843": {"callee_method_names": ["S.getNotesList", "ArrayList<String>.remove"], "method_name": "GenericGenbankHeaderFormat._write_comment", "method_implementation": "{\n    ArrayList<String> comments = sequence.getNotesList();\n    String output = _write_multi_line(\"COMMENT\", comments.remove(0));\n    for (String comment : comments) {\n        output += _write_multi_line(\"\", comment);\n    }\n    return output;\n}", "repo_id": "9", "comment": "/**\n * This is a bit complicated due to the range of possible ways people might\n * have done their annotation... Currently the parser uses a single string\n * with newlines. A list of lines is also reasonable. A single (long) string\n * is perhaps the most natural of all. This means we may need to deal with\n * line wrapping.\n *\n * @param sequence\n */\n", "repo_name": "biojava-master/", "id": 2843, "method_signature": "String _write_comment(S)"}, "3664": {"callee_method_names": [], "method_name": "SurvivalInfo.setLinearPredictor", "method_implementation": "{\n    this.linearPredictor = linearPredictor;\n}", "repo_id": "9", "comment": "/**\n * @param linearPredictor the linearPredictor to set\n */\n", "repo_name": "biojava-master/", "id": 3664, "method_signature": "void setLinearPredictor(double)"}, "2695": {"callee_method_names": ["ArrayListProxySequenceReader<NucleotideCompound>.setCompoundSet", "ArrayListProxySequenceReader<NucleotideCompound>.setContents"], "method_name": "RNASequenceCreator.getSequence", "method_implementation": "{\n    ArrayListProxySequenceReader<NucleotideCompound> store = new ArrayListProxySequenceReader<NucleotideCompound>();\n    store.setCompoundSet(compoundSet);\n    store.setContents(list);\n    return new RNASequence(store);\n}", "repo_id": "9", "comment": "/**\n * @param list\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2695, "method_signature": "AbstractSequence<NucleotideCompound> getSequence(List)"}, "2612": {"callee_method_names": [], "method_name": "ConcurrencyTools.setThreadPoolSize", "method_implementation": "{\n    setThreadPool(new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>()));\n}", "repo_id": "9", "comment": "/**\n * Sets thread pool to given size.\n *\n * @param threads number of threads in pool\n */\n", "repo_name": "biojava-master/", "id": 2612, "method_signature": "void setThreadPoolSize(int)"}, "2680": {"callee_method_names": ["ArrayList.get", "ArrayList.get", "ArrayList.get", "StringBuilder.append", "S.getAccession", "S.getSubSequence", "S.getSubSequence", "S.getSubSequence", "String.length", "String.length", "String.length", "String.charAt", "String.charAt", "String.charAt", "StringBuilder.append", "CompoundSet<C>.compoundsEquivalent", "S.getCompoundAt", "S.getCompoundAt", "StringBuilder.append"], "method_name": "MultipleSequenceAlignment.printSequenceAlignmentWeb", "method_implementation": "{\n    S as = sequences.get(counter - 1), seq1 = sequences.get(0), seq2 = sequences.get(1);\n    if (idFormat != null) {\n        s.append(String.format(idFormat, as.getAccession()));\n    }\n    String mySeq = as.getSubSequence(start, end).getSequenceAsString();\n    String s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n    String s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n    CompoundSet<C> cs = getCompoundSet();\n    for (int i = 0; i < s1.length(); i++) {\n        if (i >= s2.length() || i >= mySeq.length())\n            break;\n        char c1 = s1.charAt(i);\n        char c2 = s2.charAt(i);\n        char c = mySeq.charAt(i);\n        s.append(IOUtils.getPDBCharacter(true, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i), seq2.getCompoundAt(i)), c));\n    }\n    s.append(String.format(\"%n\"));\n}", "repo_id": "9", "comment": "/**\n * @param s\n * @param counter\n * @param idFormat\n * @param start\n * @param end\n */\n", "repo_name": "biojava-master/", "id": 2680, "method_signature": "void printSequenceAlignmentWeb(StringBuilder, int, String, int, int)"}, "464": {"callee_method_names": ["String.split", "String[].toUpperCase", "String.startsWith", "File.canRead", "File.isDirectory", "String.matches", "Logger.warn", "File.getAbsoluteFile", "File.getAbsolutePath", "Logger.info", "File.getAbsoluteFile", "File.getAbsolutePath"], "method_name": "StructureName.init", "method_implementation": "{\n    // First try identifying a prefix\n    String[] prefix = name.split(\":\", 2);\n    mySource = null;\n    if (prefix.length > 1) {\n        // Match Source prefixes\n        String suffix = prefix[1];\n        try {\n            mySource = Source.valueOf(prefix[0].toUpperCase());\n        } catch (IllegalArgumentException e) {\n            // unrecognized prefix; fall back on guessing\n            mySource = null;\n        }\n        if (mySource != null) {\n            switch(mySource) {\n                case SCOP:\n                    if (!initFromScop(suffix))\n                        throw new IllegalArgumentException(\"Malformed SCOP domain name:\" + suffix);\n                    return;\n                case CATH:\n                    if (!initFromCATH(suffix))\n                        throw new IllegalArgumentException(\"Malformed CATH domain name:\" + suffix);\n                    return;\n                case BIO:\n                    if (!initFromBIO(name))\n                        throw new IllegalArgumentException(\"Malformed BIO name:\" + suffix);\n                    return;\n                case ECOD:\n                    if (!initFromECOD(suffix))\n                        throw new IllegalArgumentException(\"Malformed ECOD domain name:\" + suffix);\n                    return;\n                case PDB:\n                    if (!initFromPDB(suffix))\n                        throw new IllegalArgumentException(\"Malformed PDB specification:\" + suffix);\n                    return;\n                case FILE:\n                    // Treat file:/ prefixes as URLs\n                    if (!suffix.startsWith(\"/\")) {\n                        // Otherwise, treat as file\n                        initFromFile();\n                        return;\n                    }\n                // fall through to URL case\n                case URL:\n                    if (!initFromURL(name))\n                        throw new IllegalArgumentException(\"Malformed URL specification:\" + suffix);\n                    return;\n                default:\n                    throw new IllegalStateException(\"Unimplemented Source \" + mySource);\n            }\n        }\n    }\n    // No known prefix, so revert to guessing\n    // First guess regex-based identifiers\n    // SCOP domain\n    if (initFromScop(name))\n        return;\n    // CATH\n    if (initFromCATH(name))\n        return;\n    // ECOD\n    if (initFromECOD(name))\n        return;\n    // Never guess BIO or PDP\n    // URL\n    if (initFromURL(name))\n        return;\n    // Guess FILE based on file existence\n    File file = new File(FileDownloadUtils.expandUserHome(name));\n    if (file.canRead() && !file.isDirectory()) {\n        // an attempt to mitigate issue #398. It doesn't fix it but it catches the most common case of passing a pdb id and finding a file in working dir matching it\n        if (name.matches(\"\\\\d\\\\w\\\\w\\\\w\")) {\n            // the plain pdb id case, this is unlikely to be what the user wants: let's let it through but warn about it\n            logger.warn(\"Provided 4-letter structure name '{}' matches \" + \"file name in directory {}. Will read structure \" + \"data from file {} and not consider the name as a \" + \"structure identifier. If this is not what you \" + \"want, use 'FILE:{}'\", name, file.getAbsoluteFile().getParent(), file.getAbsolutePath(), name);\n        } else {\n            logger.info(\"Provided structure name '{}' matches \" + \"file name in directory {}. Will read structure \" + \"data from file {}.\", name, file.getAbsoluteFile().getParent(), file.getAbsolutePath());\n        }\n        initFromFile();\n        return;\n    }\n    // Default to PDB\n    initFromPDB(name);\n}", "repo_id": "9", "comment": "/**\n * Tries to determine the source and pdbId without fully realizing the identifier,\n * which could require I/O depending on the source\n * @throws IllegalArgumentException if the source is recognizable but invalid\n */\n", "repo_name": "biojava-master/", "id": 464, "method_signature": "void init()"}, "1292": {"callee_method_ids": [1319], "callee_method_names": ["LinkRecord.getAltLoc1", "LinkRecord.getAltLoc2", "Structure.getPolyChainByPDB", "LinkRecord.getChainID1", "Structure.getPolyChainByPDB", "LinkRecord.getChainID2", "Structure.getNonPolyChainsByPDB", "LinkRecord.getChainID1", "Structure.getNonPolyChainsByPDB", "LinkRecord.getChainID2", "Structure.getWaterChainByPDB", "LinkRecord.getChainID1", "Structure.getWaterChainByPDB", "LinkRecord.getChainID2", "List<String>.add", "Chain.getId", "List<String>.add", "Chain.getId", "List<Chain>.forEach", "List<String>.add", "List<Chain>.forEach", "List<String>.add", "LinkRecord.getResName1", "List<String>.add", "Chain.getId", "LinkRecord.getResName2", "List<String>.add", "Chain.getId", "LinkRecord.getName1", "LinkRecord.getAltLoc1", "LinkRecord.getResSeq1", "LinkRecord.getiCode1", "LinkRecord.getName2", "LinkRecord.getAltLoc2", "LinkRecord.getResSeq2", "LinkRecord.getiCode2", "Structure.nrModels", "Map<Integer, Atom>.containsKey", "Map<Integer, Atom>.containsKey", "Map<Integer, Atom>.get", "Map<Integer, Atom>.get", "Map<Integer, Atom>.get", "Map<Integer, Atom>.get", "FileParsingParameters.isParseCAOnly", "Logger.warn", "LinkRecord.toString", "Logger.debug"], "method_name": "BondMaker.formLinkRecordBond", "method_implementation": "{\n    // only work with atoms that aren't alternate locations\n    if (\" \".equals(linkRecord.getAltLoc1()) || \" \".equals(linkRecord.getAltLoc2()))\n        return;\n    try {\n        // The PDB format uses author chain ids to reference chains. But one author chain id corresponds to multiple asym ids,\n        // thus we need to grab all the possible asym ids (poly and nonpoly) and then try to find the atoms\n        // See issue https://github.com/biojava/biojava/issues/943\n        Chain polyChain1 = structure.getPolyChainByPDB(linkRecord.getChainID1());\n        Chain polyChain2 = structure.getPolyChainByPDB(linkRecord.getChainID2());\n        List<Chain> nonpolyChains1 = structure.getNonPolyChainsByPDB(linkRecord.getChainID1());\n        List<Chain> nonpolyChains2 = structure.getNonPolyChainsByPDB(linkRecord.getChainID2());\n        Chain waterChain1 = structure.getWaterChainByPDB(linkRecord.getChainID1());\n        Chain waterChain2 = structure.getWaterChainByPDB(linkRecord.getChainID2());\n        List<String> allChainIds1 = new ArrayList<>();\n        List<String> allChainIds2 = new ArrayList<>();\n        if (polyChain1 != null)\n            allChainIds1.add(polyChain1.getId());\n        if (polyChain2 != null)\n            allChainIds2.add(polyChain2.getId());\n        if (nonpolyChains1 != null)\n            nonpolyChains1.forEach(npc -> allChainIds1.add(npc.getId()));\n        if (nonpolyChains2 != null)\n            nonpolyChains2.forEach(npc -> allChainIds2.add(npc.getId()));\n        if (waterChain1 != null && \"HOH\".equals(linkRecord.getResName1()))\n            allChainIds1.add(waterChain1.getId());\n        if (waterChain2 != null && \"HOH\".equals(linkRecord.getResName2()))\n            allChainIds2.add(waterChain2.getId());\n        Map<Integer, Atom> a = getAtomFromRecordTryMultipleChainIds(linkRecord.getName1(), linkRecord.getAltLoc1(), linkRecord.getResSeq1(), linkRecord.getiCode1(), allChainIds1);\n        Map<Integer, Atom> b = getAtomFromRecordTryMultipleChainIds(linkRecord.getName2(), linkRecord.getAltLoc2(), linkRecord.getResSeq2(), linkRecord.getiCode2(), allChainIds2);\n        for (int i = 0; i < structure.nrModels(); i++) {\n            if (a.containsKey(i) && b.containsKey(i)) {\n                // TODO determine what the actual bond order of this bond is; for\n                // now, we're assuming they're single bonds\n                if (!a.get(i).equals(b.get(i))) {\n                    new BondImpl(a.get(i), b.get(i), 1);\n                }\n            }\n        }\n    } catch (StructureException e) {\n        // Note, in Calpha only mode the link atoms may not be present.\n        if (!params.isParseCAOnly()) {\n            logger.warn(\"Could not find atoms specified in LINK record: {}\", linkRecord.toString());\n        } else {\n            logger.debug(\"Could not find atoms specified in LINK record while parsing in parseCAonly mode.\");\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Creates bond objects from a LinkRecord as parsed from a PDB file\n * @param linkRecord the PDB-format LINK record\n */\n", "repo_name": "biojava-master/", "id": 1292, "method_signature": "void formLinkRecordBond(LinkRecord)"}, "107": {"callee_method_names": [], "method_name": "DistanceMatrixCalculator.poissonDistance", "method_implementation": "{\n    Msa fMsa = ForesterWrapper.convert(msa);\n    DistanceMatrix DM = PairwiseDistanceCalculator.calcPoissonDistances(fMsa);\n    return DM;\n}", "repo_id": "9", "comment": "/**\n * The Poisson (correction) evolutionary distance (d) is a function of the\n * fractional dissimilarity (D), given by:\n *\n * <pre>\n * d = -log(1 - D)\n * </pre>\n *\n * The gapped positons in the alignment are ignored in the calculation. This\n * method is a wrapper to the forester implementation of the calculation:\n * {@link PairwiseDistanceCalculator#calcPoissonDistances(Msa)}\n *\n * @param msa\n *            MultipleSequenceAlignment\n * @return DistanceMatrix\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 107, "method_signature": "DistanceMatrix poissonDistance(MultipleSequenceAlignment)"}, "870": {"callee_method_ids": [873], "callee_method_names": ["StructureInterface.getTotalArea", "List<StructureInterface>.size"], "method_name": "StructureInterfaceCluster.getTotalArea", "method_implementation": "{\n    double area = 0;\n    for (StructureInterface interf : members) {\n        area += interf.getTotalArea();\n    }\n    return area / members.size();\n}", "repo_id": "9", "comment": "/**\n * Return the average buried surface area for this interface cluster\n * @return\n */\n", "repo_name": "biojava-master/", "id": 870, "method_signature": "double getTotalArea()"}, "3704": {"callee_method_ids": [3752, 3736, 3741, 3718, 3706, 3724, 3707], "callee_method_names": ["WorkSheet.getColumns", "WorkSheet.addCell", "WorkSheet.getCell", "WorkSheet.setMetaDataColumns", "WorkSheet.getMetaDataColumns", "WorkSheet.setMetaDataRows", "WorkSheet.getMetaDataRows"], "method_name": "WorkSheet.getCopyWorkSheetSelectedRows", "method_implementation": "{\n    ArrayList<String> columns = copyWorkSheet.getColumns();\n    WorkSheet workSheet = new WorkSheet(rows, columns);\n    for (String row : rows) {\n        for (String col : columns) {\n            workSheet.addCell(row, col, copyWorkSheet.getCell(row, col));\n        }\n    }\n    workSheet.setMetaDataColumns(copyWorkSheet.getMetaDataColumns());\n    workSheet.setMetaDataRows(copyWorkSheet.getMetaDataRows());\n    return workSheet;\n}", "repo_id": "9", "comment": "/**\n * Create a copy of a worksheet. If shuffling of columns or row for testing\n * a way to duplicate original worksheet\n *\n * @param copyWorkSheet\n * @param rows\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3704, "method_signature": "WorkSheet getCopyWorkSheetSelectedRows(WorkSheet, ArrayList)"}, "441": {"callee_method_names": [], "method_name": "StructureAlignmentOptimizer.calMatrix", "method_implementation": "{\n    int i, j;\n    double dis;\n    for (i = 0; i < pro1Len; i++) {\n        for (j = 0; j < pro2Len; j++) {\n            dis = Calc.getDistance(cod1[i], cod2[j]);\n            if (dis < Dc) {\n                sij[i][j] = Dc - dis;\n            } else {\n                sij[i][j] = 0;\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "//--------------------------------------------------------------------------------------------------------\n", "repo_name": "biojava-master/", "id": 441, "method_signature": "void calMatrix()"}, "1855": {"callee_method_names": [], "method_name": "Rotation.setTraceTmScoreMin", "method_implementation": "{\n    this.traceTmScoreMin = traceTmScoreMin;\n}", "repo_id": "9", "comment": "/**\n * @param traceTmScoreMin the traceTmScore to set\n */\n", "repo_name": "biojava-master/", "id": 1855, "method_signature": "void setTraceTmScoreMin(double)"}, "2524": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum50", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum50\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 50 matrix by Henikoff & Henikoff\n * @return Blosum 50 matrix\n */\n", "repo_name": "biojava-master/", "id": 2524, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum50()"}, "2145": {"callee_method_names": [], "method_name": "StructureImpl.addEntityInfo", "method_implementation": "{\n    this.entityInfos.add(entityInfo);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2145, "method_signature": "void addEntityInfo(EntityInfo)"}, "3368": {"callee_method_names": [], "method_name": "DefaultMatrixMapper.setSaturation", "method_implementation": "{\n    this.saturation = saturation;\n}", "repo_id": "9", "comment": "/**\n * @param saturation the saturation to set\n */\n", "repo_name": "biojava-master/", "id": 3368, "method_signature": "void setSaturation(float)"}, "2288": {"callee_method_ids": [1570], "callee_method_names": ["Site.getSiteID"], "method_name": "SiteTest.testGetSiteID", "method_implementation": "{\n    //        System.out.println(\"getSiteID\");\n    String expResult = \"CAT\";\n    String result = catSite.getSiteID();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of getSiteID method, of class Site.\n */\n", "repo_name": "biojava-master/", "id": 2288, "method_signature": "void testGetSiteID()"}, "1275": {"callee_method_ids": [1261], "callee_method_names": ["MmtfStructureReader.getStructure"], "method_name": "MmtfActions.readFromWeb", "method_implementation": "{\n    // Get the reader - this is the bit that people need to implement.\n    MmtfStructureReader mmtfStructureReader = new MmtfStructureReader();\n    // Do the inflation\n    new StructureDataToAdapter(new GenericDecoder(ReaderUtils.getDataFromUrl(pdbId)), mmtfStructureReader);\n    // Get the structue\n    return mmtfStructureReader.getStructure();\n}", "repo_id": "9", "comment": "/**\n * Get a Biojava structure from the mmtf REST service.\n * @param pdbId the PDB code of the required structure\n * @return a Structure object relating to the input byte array\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1275, "method_signature": "Structure readFromWeb(String)"}, "2302": {"callee_method_names": ["TestSpaceGroup.testTransfConversion"], "method_name": "TestSpaceGroup.main", "method_implementation": "{\n    TestSpaceGroup test = new TestSpaceGroup();\n    test.testTransfConversion();\n}", "repo_id": "9", "comment": "// to debug the testing code (run as java program so that we can use normal debugger)\n", "repo_name": "biojava-master/", "id": 2302, "method_signature": "void main(String[])"}, "904": {"callee_method_names": ["StructureInterface.setId"], "method_name": "StructureInterfaceList.sort", "method_implementation": "{\n    Collections.sort(list);\n    int i = 1;\n    for (StructureInterface interf : list) {\n        interf.setId(i);\n        i++;\n    }\n}", "repo_id": "9", "comment": "/**\n * Sorts the interface list and reassigns ids based on new sorting\n */\n", "repo_name": "biojava-master/", "id": 904, "method_signature": "void sort()"}, "1455": {"callee_method_names": ["Vector3d.angle"], "method_name": "SpaceGroup.areInSameAxis", "method_implementation": "{\n    if (tId1 == tId2)\n        return true;\n    if (axisAngles == null)\n        calcRotAxesAndAngles();\n    if (getAxisFoldType(tId1) == 1 && getAxisFoldType(tId2) == 1)\n        return true;\n    // we can't deal yet with improper rotations: we return false whenever either of them is improper\n    if (getAxisFoldType(tId1) < 0 || getAxisFoldType(tId2) < 0)\n        return false;\n    Vector3d axis1 = new Vector3d(axisAngles[tId1].x, axisAngles[tId1].y, axisAngles[tId1].z);\n    Vector3d axis2 = new Vector3d(axisAngles[tId2].x, axisAngles[tId2].y, axisAngles[tId2].z);\n    // TODO revise: we might need to consider that the 2 are in same direction but opposite senses\n    // the method is not used at the moment anyway\n    if (deltaComp(axis1.angle(axis2), 0.0, DELTA))\n        return true;\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Returns true if both given transform ids belong to the same crystallographic axis (a, b or c)\n * For two non-rotation transformations (i.e. identity operators) it returns true\n * @param tId1\n * @param tId2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1455, "method_signature": "boolean areInSameAxis(int, int)"}, "3630": {"callee_method_names": [], "method_name": "CoxInfo.setRscoreLogrankTestpvalue", "method_implementation": "{\n    this.rscoreLogrankTestpvalue = rscoreLogrankTestpvalue;\n}", "repo_id": "9", "comment": "/**\n * @param rscoreLogrankTestpvalue the rscoreLogrankTestpvalue to set\n */\n", "repo_name": "biojava-master/", "id": 3630, "method_signature": "void setRscoreLogrankTestpvalue(Double)"}, "2139": {"callee_method_ids": [1156], "callee_method_names": ["FileConvert.toPDB"], "method_name": "StructureImpl.toPDB", "method_implementation": "{\n    FileConvert f = new FileConvert(this);\n    return f.toPDB();\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2139, "method_signature": "String toPDB()"}, "2267": {"callee_method_ids": [1772], "callee_method_names": ["PDBHeader.setExperimentalTechnique", "Structure.setPDBHeader", "Structure.setEntityInfos", "Chain.setId", "Chain.setName", "Group.setPDBName", "ChemComp.setType", "ChemComp.setOneLetterCode", "Group.setChemComp", "Atom.setName", "Atom.setElement", "Atom.setCoords", "Chain.addGroup", "Group.addAtom", "ResidueNumber.setInsCode", "ResidueNumber.setSeqNum", "Group.setResidueNumber", "Structure.addChain", "TemporaryFolder.newFile", "File.toPath"], "method_name": "TestMmtfStructureWriter.testWrite", "method_implementation": "{\n    // Create a structure\n    Structure structure = new StructureImpl();\n    // Add some header information\n    PDBHeader pdbHeader = new PDBHeader();\n    pdbHeader.setExperimentalTechnique(\"X-RAY DIFFRACTION\");\n    structure.setPDBHeader(pdbHeader);\n    // Create one chain\n    structure.setEntityInfos(new ArrayList<EntityInfo>());\n    Chain chain = new ChainImpl();\n    chain.setId(\"A\");\n    chain.setName(\"A\");\n    Group group = new AminoAcidImpl();\n    group.setPDBName(\"FKF\");\n    ChemComp chemComp = new ChemComp();\n    chemComp.setType(\"TYPfdl\");\n    chemComp.setOneLetterCode(\"A\");\n    group.setChemComp(chemComp);\n    // Create one Atom\n    Atom atom = new AtomImpl();\n    atom.setName(\"A\");\n    atom.setElement(Element.Ag);\n    atom.setCoords(new double[] { 1.0, 2.0, 3.0 });\n    // Link together the objects\n    chain.addGroup(group);\n    group.addAtom(atom);\n    ResidueNumber residueNumber = new ResidueNumber();\n    residueNumber.setInsCode('A');\n    residueNumber.setSeqNum(100);\n    group.setResidueNumber(residueNumber);\n    structure.addChain(chain);\n    File tempFile = testFolder.newFile(\"tmpfile\");\n    MmtfActions.writeToFile(structure, tempFile.toPath());\n}", "repo_id": "9", "comment": "/**\n * Test the writing of Structure objects to a file.\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2267, "method_signature": "void testWrite()"}, "2043": {"callee_method_names": ["CeSymmResult.isRefined", "CeSymmResult.getMultipleAlignment", "MultipleAlignment.size", "MultipleAlignment.getBlock", "MultipleAlignment.getBlocks", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "MultipleAlignment.getBlockSet"], "method_name": "SymmetryTools.toFullAlignment", "method_implementation": "{\n    if (!symm.isRefined())\n        throw new IllegalArgumentException(\"The symmetry result \" + \"is not refined, repeats cannot be defined\");\n    MultipleAlignment full = symm.getMultipleAlignment().clone();\n    for (int str = 1; str < full.size(); str++) {\n        // Create a new Block with swapped AlignRes (move first to last)\n        Block b = full.getBlock(full.getBlocks().size() - 1).clone();\n        b.getAlignRes().add(b.getAlignRes().get(0));\n        b.getAlignRes().remove(0);\n        full.getBlockSet(0).getBlocks().add(b);\n    }\n    return full;\n}", "repo_id": "9", "comment": "/**\n * Method that converts a repeats symmetric alignment into an alignment of\n * whole structures.\n * <p>\n * Example: if the structure has repeats A,B and C, the original alignment\n * is A-B-C, and the returned alignment is ABC-BCA-CAB.\n *\n * @param symm\n *            CeSymmResult\n * @return MultipleAlignment of the full structure superpositions\n */\n", "repo_name": "biojava-master/", "id": 2043, "method_signature": "MultipleAlignment toFullAlignment(CeSymmResult)"}, "3844": {"callee_method_names": ["Logger.warn", "Logger.warn"], "method_name": "Utils.checkSequence", "method_implementation": "{\n    boolean containInvalid = false;\n    if (cSet != null) {\n        containInvalid = sequence != null && doesSequenceContainInvalidChar(sequence, cSet);\n    } else {\n        containInvalid = sequence != null && doesSequenceContainInvalidChar(sequence, PeptideProperties.standardAASet);\n    }\n    if (containInvalid) {\n        String cSeq = cleanSequence(sequence, cSet);\n        logger.warn(\"There exists invalid characters in the sequence. Computed results might not be precise.\");\n        logger.warn(\"To remove this warning: Please use org.biojava.nbio.aaproperties.Utils.cleanSequence to clean sequence.\");\n        return cSeq;\n    } else {\n        return sequence;\n    }\n}", "repo_id": "9", "comment": "/**\n * Checks if the sequence contains invalid characters.\n * Note that any character outside of the 20 standard protein amino acid codes are considered as invalid.\n * If yes, it will return a new sequence where invalid characters are replaced with '-'.\n * If no, it will simply return the input sequence.\n *\n * @param sequence\n * \t\tprotein sequence to be check for invalid characters.\n * @param cSet\n * \t\tcharacter set which define the valid characters.\n * @return\n * \t\ta sequence with no invalid characters.\n */\n", "repo_name": "biojava-master/", "id": 3844, "method_signature": "String checkSequence(String, Set)"}, "2119": {"callee_method_names": [], "method_name": "StructureImpl.getStructureIdentifier", "method_implementation": "{\n    return structureIdentifier;\n}", "repo_id": "9", "comment": "/**\n * @return The StructureIdentifier used to create this structure\n */\n", "repo_name": "biojava-master/", "id": 2119, "method_signature": "StructureIdentifier getStructureIdentifier()"}, "2480": {"callee_method_names": [], "method_name": "ChromosomeMappingTools.format", "method_implementation": "{\n    return String.format(\"%,d\", chromosomePosition);\n}", "repo_id": "9", "comment": "/**\n * Returns a nicely formatted representation of the position\n *\n * @param chromosomePosition\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2480, "method_signature": "String format(int)"}, "2055": {"callee_method_names": [], "method_name": "CeSymmResult.getNumRepeats", "method_implementation": "{\n    if (isSignificant())\n        return numRepeats;\n    else\n        return 1;\n}", "repo_id": "9", "comment": "/**\n * Return the symmetry order determined by the order detector if the\n * symmetry is significant. Return 1 otherwise.\n *\n * @return the order of symmetry if the result is significant\n */\n", "repo_name": "biojava-master/", "id": 2055, "method_signature": "int getNumRepeats()"}, "2393": {"callee_method_names": [], "method_name": "Location.bioStart", "method_implementation": "{\n    return plus().start() + 1;\n}", "repo_id": "9", "comment": "/**\n * Get start index, in biocoordinates.\n *\n * @return The origin 1 index of the first symbol in location.\n */\n", "repo_name": "biojava-master/", "id": 2393, "method_signature": "int bioStart()"}, "2183": {"callee_method_ids": [639, 634, 641, 628], "callee_method_names": ["Logger.info", "Path.toString", "Path.toString", "Path.toString", "AtomCache.setPath", "Path.toString", "AtomCache.setCachePath", "Path.toString", "AtomCache.setFiletype", "Path.toString", "Path.resolve", "Path.getParent", "Path.toFile", "FileOutputStream.flush", "Path.resolve", "Path.getParent", "URL.getPath", "File.toPath", "AtomCache.getStructure", "Structure.getChain", "Group.getPDBName", "Group.getChemComp", "ChemComp.getAtoms", "ChemComp.getType"], "method_name": "AtomCacheTest.testEmptyGZChemComp", "method_implementation": "{\n    Path tmpCache = Paths.get(System.getProperty(\"java.io.tmpdir\"), \"BIOJAVA_TEST_CACHE\");\n    logger.info(\"Testing AtomCache at {}\", tmpCache.toString());\n    System.setProperty(UserConfiguration.PDB_DIR, tmpCache.toString());\n    System.setProperty(UserConfiguration.PDB_CACHE_DIR, tmpCache.toString());\n    FileDownloadUtils.deleteDirectory(tmpCache);\n    Files.createDirectory(tmpCache);\n    try {\n        cache.setPath(tmpCache.toString());\n        cache.setCachePath(tmpCache.toString());\n        cache.setFiletype(StructureFiletype.CIF);\n        ChemCompGroupFactory.setChemCompProvider(new DownloadChemCompProvider(tmpCache.toString()));\n        // Create an empty chemcomp\n        Path sub = tmpCache.resolve(Paths.get(\"chemcomp\", \"ATP.cif.gz\"));\n        Files.createDirectories(sub.getParent());\n        try (GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(sub.toFile()))) {\n            // don't write anything\n            out.flush();\n        }\n        assertTrue(Files.exists(sub));\n        assertTrue(0 < Files.size(sub) && Files.size(sub) < LocalPDBDirectory.MIN_PDB_FILE_SIZE);\n        // Copy stub file into place\n        Path testCif = tmpCache.resolve(Paths.get(\"data\", \"structures\", \"divided\", \"mmCIF\", \"ab\", \"1abc.cif.gz\"));\n        Files.createDirectories(testCif.getParent());\n        URL resource = AtomCacheTest.class.getResource(\"/atp.cif.gz\");\n        File src = new File(resource.getPath());\n        Files.copy(src.toPath(), testCif, StandardCopyOption.REPLACE_EXISTING);\n        // Load structure\n        Structure s = cache.getStructure(\"1ABC\");\n        // Should have re-downloaded the file\n        assertTrue(Files.size(sub) > LocalPDBDirectory.MIN_PDB_FILE_SIZE);\n        // Structure should have valid ChemComp\n        assertNotNull(s);\n        Group g = s.getChain(\"A\").getAtomGroup(0);\n        assertTrue(g.getPDBName().equals(\"ATP\"));\n        // should be unknown\n        ChemComp chem = g.getChemComp();\n        assertNotNull(chem);\n        assertTrue(chem.getAtoms().size() > 0);\n        assertEquals(\"NON-POLYMER\", chem.getType());\n    } finally {\n        FileDownloadUtils.deleteDirectory(tmpCache);\n    }\n}", "repo_id": "9", "comment": "/**\n * Test for #703 - Chemical component cache poisoning\n *\n * Handle empty CIF files\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2183, "method_signature": "void testEmptyGZChemComp()"}, "1927": {"callee_method_names": [], "method_name": "QuatSymmetryResults.getHelixLayers", "method_implementation": "{\n    return helixLayers;\n}", "repo_id": "9", "comment": "/**\n * @return helix layers (layer lines) as a list of helices that describe a\n *         helical structure.\n */\n", "repo_name": "biojava-master/", "id": 1927, "method_signature": "HelixLayers getHelixLayers()"}, "2630": {"callee_method_names": [], "method_name": "SequenceOptimizationHints.getSequenceUsage", "method_implementation": "{\n    return sequenceUsage;\n}", "repo_id": "9", "comment": "/**\n * @return the sequenceUsage\n */\n", "repo_name": "biojava-master/", "id": 2630, "method_signature": "SequenceUsage getSequenceUsage()"}, "916": {"callee_method_names": [], "method_name": "BoundingBox.getMinMax", "method_implementation": "{\n    double[] minmax = new double[2];\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    for (double value : array) {\n        if (value > max)\n            max = value;\n        if (value < min)\n            min = value;\n    }\n    minmax[0] = min;\n    minmax[1] = max;\n    return minmax;\n}", "repo_id": "9", "comment": "/**\n * Returns an array of size 2 with min and max values of given double array\n * @param array\n * @return\n */\n", "repo_name": "biojava-master/", "id": 916, "method_signature": "double[] getMinMax(double[])"}, "529": {"callee_method_names": [], "method_name": "StrucAligParameters.reduceInitialFragments", "method_implementation": "{\n    return reduceInitialFragments;\n}", "repo_id": "9", "comment": "/**\n * if this is set to false, the time spent to joint the initial fragments (step 2)\n * is increased. - particular for large structures this increases calc. time a lot.\n * advantage: more combinations of fragments are used.\n *\n * @return a flag if the inital fragments should be reduced\n */\n", "repo_name": "biojava-master/", "id": 529, "method_signature": "boolean reduceInitialFragments()"}, "1618": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getAbsoluteMinimumSequenceLength", "method_implementation": "{\n    return absoluteMinimumSequenceLength;\n}", "repo_id": "9", "comment": "/**\n * If the shortest subunit sequence length is higher or equal the\n * minimumSequenceLengthFraction times the median subunit sequence length,\n * then the minimumSequenceLength is set to shortest subunit sequence\n * length, but not shorter than the absoluteMinimumSequenceLength.\n * <p>\n * This adaptive feature allows the consideration of structures mainly\n * constructed by very short chains, such as collagen (1A3I)\n *\n * @return the absoluteMinimumSequenceLength\n */\n", "repo_name": "biojava-master/", "id": 1618, "method_signature": "int getAbsoluteMinimumSequenceLength()"}, "3725": {"callee_method_names": ["String.length"], "method_name": "WorkSheet.hideEmptyRows", "method_implementation": "{\n    ArrayList<String> rows = this.getDataRows();\n    ArrayList<String> columns = this.getDataColumns();\n    for (String row : rows) {\n        boolean emptyRow = true;\n        for (String column : columns) {\n            String value = this.getCell(row, column).trim();\n            if (value.length() > 0) {\n                emptyRow = false;\n                break;\n            }\n        }\n        if (emptyRow) {\n            hideRow(row, true);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3725, "method_signature": "void hideEmptyRows()"}, "447": {"callee_method_names": [], "method_name": "QsAlignResult.getSubunitMap", "method_implementation": "{\n    if (subunitMap == null)\n        return Collections.emptyMap();\n    return Collections.unmodifiableMap(subunitMap);\n}", "repo_id": "9", "comment": "/**\n * Map of Subunit equivalencies from the first to the second group.\n *\n * @return an unmodifiable view of the original Map\n */\n", "repo_name": "biojava-master/", "id": 447, "method_signature": "Map<Integer,Integer> getSubunitMap()"}, "145": {"callee_method_names": [], "method_name": "AlignmentToolsTest.entrySet", "method_implementation": "{\n    return Collections.emptySet();\n}", "repo_id": "9", "comment": "/**\n * Always returns the empty set\n */\n", "repo_name": "biojava-master/", "id": 145, "method_signature": "Set<java.util.Map.Entry<Double,Integer>> entrySet()"}, "1510": {"callee_method_names": ["Matrix4d.set"], "method_name": "SuperPositionQCP.superposeAfterRmsd", "method_implementation": "{\n    if (!rmsdCalculated) {\n        throw new IllegalStateException(\"The RMSD was not yet calculated. Use the superpose() method instead.\");\n    }\n    getRotationMatrix();\n    if (!centered) {\n        calcTransformation();\n    } else {\n        transformation.set(rotmat);\n    }\n    return transformation;\n}", "repo_id": "9", "comment": "/**\n * The QCP method can be used as a two-step calculation: first compute the\n * RMSD (fast) and then compute the superposition.\n *\n * This method assumes that the RMSD of two arrays of points has been\n * already calculated using {@link #getRmsd(Point3d[], Point3d[])} method\n * and calculates the transformation of the same two point arrays.\n *\n * @param fixed\n * @param moved\n * @return transformation matrix as a Matrix4d to superpose moved onto fixed\n *         point arrays\n */\n", "repo_name": "biojava-master/", "id": 1510, "method_signature": "Matrix4d superposeAfterRmsd()"}, "3061": {"callee_method_names": ["ArrayList.size", "ArrayList.size", "ArrayList.get", "ArrayList.get", "ExonSequence.getBioEnd", "ExonSequence.getBioBegin"], "method_name": "GeneSequence.addIntronsUsingExons", "method_implementation": "{\n    if (intronAdded) {\n        //going to assume introns are correct\n        return;\n    }\n    if (exonSequenceList.size() == 0) {\n        return;\n    }\n    ExonComparator exonComparator = new ExonComparator();\n    //sort based on start position and sense;\n    Collections.sort(exonSequenceList, exonComparator);\n    int shift = -1;\n    if (getStrand() == Strand.NEGATIVE) {\n        shift = 1;\n    }\n    //ExonSequence firstExonSequence = exonSequenceList.get(0);\n    int intronIndex = 1;\n    //       if (firstExonSequence.getBioBegin().intValue() != getBioBegin().intValue()) {\n    //           this.addIntron(new AccessionID(this.getAccession().getID() + \"-\" + \"intron\" + intronIndex), getBioBegin(), firstExonSequence.getBioBegin() + shift);\n    //           intronIndex++;\n    //       }\n    for (int i = 0; i < exonSequenceList.size() - 1; i++) {\n        ExonSequence exon1 = exonSequenceList.get(i);\n        ExonSequence exon2 = exonSequenceList.get(i + 1);\n        AccessionID intronId = new AccessionID(this.getAccession().getID() + \"-\" + \"intron\" + intronIndex);\n        this.addIntron(intronId, exon1.getBioEnd() - shift, exon2.getBioBegin() + shift);\n        intronIndex++;\n    }\n    //       ExonSequence lastExonSequence = exonSequenceList.get(exonSequenceList.size() - 1);\n    //       if (lastExonSequence.getBioEnd().intValue() != getBioEnd().intValue()) {\n    //           this.addIntron(new AccessionID(this.getAccession().getID() + \"-\" + \"intron\" + intronIndex), lastExonSequence.getBioEnd() - shift, getBioEnd());\n    //           intronIndex++;\n    //       }\n    //    log.severe(\"Add in support for building introns based on added exons\");\n}", "repo_id": "9", "comment": "/**\n * Once everything has been added to the gene sequence where you might have added exon sequences only then you\n * can infer the intron sequences and add them. You may also have the case where you only added one or more\n * TranscriptSequences and from that you can infer the exon sequences and intron sequences.\n * Currently not implement\n */\n", "repo_name": "biojava-master/", "id": 3061, "method_signature": "void addIntronsUsingExons()"}, "1868": {"callee_method_names": [], "method_name": "Rotation.setAxisAngle", "method_implementation": "{\n    this.axisAngle = axisAngle;\n}", "repo_id": "9", "comment": "/**\n * @param axisAngle the axisAngle to set\n */\n", "repo_name": "biojava-master/", "id": 1868, "method_signature": "void setAxisAngle(AxisAngle4d)"}, "1009": {"callee_method_names": ["TreeMap<ResidueNumber, Integer>.keySet", "ResidueNumber.getChainName", "List<ResidueRangeAndLength>.add", "ResidueNumber.getChainName", "List<ResidueRangeAndLength>.add"], "method_name": "AtomPositionMap.getRanges", "method_implementation": "{\n    String currentChain = \"\";\n    ResidueNumber first = null;\n    ResidueNumber prev = null;\n    List<ResidueRangeAndLength> ranges = new ArrayList<ResidueRangeAndLength>();\n    for (ResidueNumber rn : treeMap.keySet()) {\n        if (!rn.getChainName().equals(currentChain)) {\n            if (first != null) {\n                ResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.getLength(first, prev));\n                ranges.add(newRange);\n            }\n            first = rn;\n        }\n        prev = rn;\n        currentChain = rn.getChainName();\n    }\n    ResidueRangeAndLength newRange = new ResidueRangeAndLength(currentChain, first, prev, this.getLength(first, prev));\n    ranges.add(newRange);\n    return ranges;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of {@link ResidueRange ResidueRanges} corresponding to this entire AtomPositionMap.\n */\n", "repo_name": "biojava-master/", "id": 1009, "method_signature": "List<ResidueRangeAndLength> getRanges()"}, "748": {"callee_method_names": [], "method_name": "CeParameters.getRmsdThrJoin", "method_implementation": "{\n    return rmsdThrJoin;\n}", "repo_id": "9", "comment": "/**\n * RMSD threshold for joining of AFPs\n *\n * @return rmsd threshold\n */\n", "repo_name": "biojava-master/", "id": 748, "method_signature": "Double getRmsdThrJoin()"}, "1598": {"callee_method_names": ["AtomContactSet.iterator", "Iterator<AtomContact>.hasNext", "Iterator<AtomContact>.next", "AtomContact.getPair", "Pair<Atom>.getFirst", "Pair<Atom>.getSecond", "Map<ResidueNumber, Integer>.get", "Group.getResidueNumber", "Map<ResidueNumber, Integer>.get", "Group.getResidueNumber"], "method_name": "SecStrucCalc.calculateHBonds", "method_implementation": "{\n    /**\n     * More efficient method for calculating C-Alpha pairs\n     */\n    if (groups.length < 5)\n        return;\n    Iterator<AtomContact> otu = contactSet.iterator();\n    while (otu.hasNext()) {\n        AtomContact ac = otu.next();\n        Pair<Atom> pair = ac.getPair();\n        Group g1 = pair.getFirst().getGroup();\n        Group g2 = pair.getSecond().getGroup();\n        // Now I need to get the index of the Group in the list groups\n        int i = indResMap.get(g1.getResidueNumber());\n        int j = indResMap.get(g2.getResidueNumber());\n        // Now check this\n        checkAddHBond(i, j);\n        //\"backwards\" hbonds are not allowed\n        if (j != (i + 1))\n            checkAddHBond(j, i);\n    }\n}", "repo_id": "9", "comment": "/**\n * Calculate the HBonds between different groups.\n * see Creighton page 147 f\n * Modified to use only the contact map\n */\n", "repo_name": "biojava-master/", "id": 1598, "method_signature": "void calculateHBonds()"}, "3338": {"callee_method_names": ["JDialog.setSize", "JEditorPane.setEditable", "Box.add", "JButton.addActionListener", "ActionEvent.getSource", "JButton.getParent", "JDialog.dispose", "Box.add", "Box.add", "Box.add", "JDialog.getContentPane", "JDialog.setVisible"], "method_name": "MenuCreator.showAboutDialog", "method_implementation": "{\n    JDialog dialog = new JDialog();\n    dialog.setSize(new Dimension(300, 300));\n    String msg = \"This viewer is based on <b>BioJava</b> and <b>Jmol</>. <br>Author: Andreas Prlic <br> \";\n    msg += \"Structure Alignment algorithm based on a variation of the PSC++ algorithm by Peter Lackner.\";\n    JEditorPane txt = new JEditorPane(\"text/html\", msg);\n    txt.setEditable(false);\n    JScrollPane scroll = new JScrollPane(txt);\n    Box vBox = Box.createVerticalBox();\n    vBox.add(scroll);\n    JButton close = new JButton(\"Close\");\n    close.addActionListener(new ActionListener() {\n\n        @Override\n        public void actionPerformed(ActionEvent event) {\n            Object source = event.getSource();\n            JButton but = (JButton) source;\n            Container parent = but.getParent().getParent().getParent().getParent().getParent().getParent();\n            JDialog dia = (JDialog) parent;\n            dia.dispose();\n        }\n    });\n    Box hBoxb = Box.createHorizontalBox();\n    hBoxb.add(Box.createGlue());\n    hBoxb.add(close, BorderLayout.EAST);\n    vBox.add(hBoxb);\n    dialog.getContentPane().add(vBox);\n    dialog.setVisible(true);\n}", "repo_id": "9", "comment": "/**\n * show some info about this gui\n */\n", "repo_name": "biojava-master/", "id": 3338, "method_signature": "void showAboutDialog()"}, "503": {"callee_method_names": [], "method_name": "AFPChain.isSequentialAlignment", "method_implementation": "{\n    return sequentialAlignment;\n}", "repo_id": "9", "comment": "/**\n * Get whether this alignment has the normal topology, ie the residues\n * aligned in each block increase sequentially over the original protein.\n *\n * This will be false if a circular permutation was detected.\n * @return true if the alignment is sequential\n */\n", "repo_name": "biojava-master/", "id": 503, "method_signature": "boolean isSequentialAlignment()"}, "764": {"callee_method_names": [], "method_name": "StartupParameters.getSearchFile", "method_implementation": "{\n    return searchFile;\n}", "repo_id": "9", "comment": "/**\n * An input file to be used for the DB search\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 764, "method_signature": "String getSearchFile()"}, "1124": {"callee_method_names": ["List<String>.add"], "method_name": "LocalPDBDirectory.addExtension", "method_implementation": "{\n    //System.out.println(\"add Extension \"+s);\n    extensions.add(s);\n}", "repo_id": "9", "comment": "/**\n * define supported file extensions\n * compressed extensions .Z,.gz do not need to be specified\n * they are dealt with automatically.\n */\n", "repo_name": "biojava-master/", "id": 1124, "method_signature": "void addExtension(String)"}, "1910": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.setHelixRmsdToRiseRatio", "method_implementation": "{\n    this.helixRmsdToRiseRatio = helixRmsdToRiseRatio;\n}", "repo_id": "9", "comment": "/**\n * @param helixRmsdToRiseRatio\n *            the helixRmsdToRiseRatio to set\n */\n", "repo_name": "biojava-master/", "id": 1910, "method_signature": "void setHelixRmsdToRiseRatio(double)"}, "2111": {"callee_method_names": [], "method_name": "Axis.setLevel", "method_implementation": "{\n    if (level < 0)\n        throw new IndexOutOfBoundsException(\"Level must be positive\");\n    this.level = level;\n}", "repo_id": "9", "comment": "/**\n * @param level The level of this axis within it's parent hierarchy. Must be positive\n */\n", "repo_name": "biojava-master/", "id": 2111, "method_signature": "void setLevel(int)"}, "2809": {"callee_method_names": ["BufferedReader.readLine", "ReaderProcessor.process"], "method_name": "IOUtils.processReader", "method_implementation": "{\n    String line;\n    try {\n        while ((line = br.readLine()) != null) {\n            processor.process(line);\n        }\n    } catch (IOException e) {\n        throw new ParserException(\"Could not read from the given BufferedReader\");\n    } finally {\n        close(br);\n    }\n}", "repo_id": "9", "comment": "/**\n * Takes in a reader and a processor, reads every line from the given\n * file and then invokes the processor. What you do with the lines is\n * dependent on your processor.\n *\n * The code will automatically close the given BufferedReader.\n *\n * @param br The reader to process\n * @param processor The processor to invoke on all lines\n * @throws ParserException Can throw this if we cannot parse the given reader\n */\n", "repo_name": "biojava-master/", "id": 2809, "method_signature": "void processReader(BufferedReader, ReaderProcessor)"}, "1822": {"callee_method_names": [], "method_name": "EcodParser.getDomains", "method_implementation": "{\n    return domains;\n}", "repo_id": "9", "comment": "/**\n * @return a list of all EcodDomains\n */\n", "repo_name": "biojava-master/", "id": 1822, "method_signature": "List<EcodDomain> getDomains()"}, "202": {"callee_method_names": ["String.trim"], "method_name": "InputParameters.parseThreadNum", "method_implementation": "{\n    key = key.trim().substring(InputParameters.threadKey.length());\n    final int nthreads = Integer.parseInt(key);\n    return nthreads;\n}", "repo_id": "9", "comment": "/**\n * @param key\n * @return\n * @throws NumberFormatException\n */\n", "repo_name": "biojava-master/", "id": 202, "method_signature": "int parseThreadNum(String)"}, "2643": {"callee_method_names": [], "method_name": "DNASequence.setDNAType", "method_implementation": "{\n    this.dnaType = dnaType;\n}", "repo_id": "9", "comment": "/**\n * @param dnaType the dnaType to set\n */\n", "repo_name": "biojava-master/", "id": 2643, "method_signature": "void setDNAType(DNAType)"}, "1651": {"callee_method_names": [], "method_name": "SubunitClustererParameters.isUseEntityIdForSeqIdentityDetermination", "method_implementation": "{\n    return useEntityIdForSeqIdentityDetermination;\n}", "repo_id": "9", "comment": "/**\n * Whether to use the entity id of subunits to infer that sequences are identical.\n * Only applies if the {@link SubunitClustererMethod} is a sequence based one.\n * @return the flag\n * @since 5.4.0\n */\n", "repo_name": "biojava-master/", "id": 1651, "method_signature": "boolean isUseEntityIdForSeqIdentityDetermination()"}, "2898": {"callee_method_names": ["SequenceReader<C>.setCompoundSet", "SequenceReader<C>.setContents"], "method_name": "AbstractSequence.initSequenceStorage", "method_implementation": "{\n    sequenceStorage = new ArrayListSequenceReader<C>();\n    sequenceStorage.setCompoundSet(this.getCompoundSet());\n    sequenceStorage.setContents(seqString);\n}", "repo_id": "9", "comment": "//  so it can be called from subclass constructors\n", "repo_name": "biojava-master/", "id": 2898, "method_signature": "void initSequenceStorage(String)"}, "2124": {"callee_method_ids": [1842], "callee_method_names": ["List<Model>.get", "Model.getChains"], "method_name": "StructureImpl.getChainByIndex", "method_implementation": "{\n    Model model = models.get(modelnr);\n    return model.getChains().get(number);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2124, "method_signature": "Chain getChainByIndex(int, int)"}, "543": {"callee_method_names": ["Logger.info", "Atom.getGroup"], "method_name": "AFPTwister.calCaRmsd", "method_implementation": "{\n    Atom[] cod1 = getAtoms(ca1, res1, resn, false);\n    Atom[] cod2 = getAtoms(pro, res2, resn, false);\n    if (cod1.length == 0 || cod2.length == 0) {\n        logger.info(\"length of atoms  == 0!\");\n        return 99;\n    }\n    Matrix4d transform = SuperPositions.superpose(Calc.atomsToPoints(cod1), Calc.atomsToPoints(cod2));\n    for (Atom a : cod2) Calc.transform(a.getGroup(), transform);\n    return Calc.rmsd(cod1, cod2);\n}", "repo_id": "9", "comment": "/**\n * Return the rmsd of the CAs between the input pro and this protein, at\n * given positions. quite similar to transPdb but while that one transforms\n * the whole ca2, this one only works on the res1 and res2 positions.\n *\n * Modifies the coordinates in the second set of Atoms (pro).\n *\n * @return rmsd of CAs\n */\n", "repo_name": "biojava-master/", "id": 543, "method_signature": "double calCaRmsd(Atom[], Atom[], int, int[], int[])"}, "2352": {"callee_method_names": [], "method_name": "FastqParser.setState", "method_implementation": "{\n    this.state = state;\n}", "repo_id": "9", "comment": "/**\n * Set the parser state to <code>state</code>.\n *\n * @param state parser state\n */\n", "repo_name": "biojava-master/", "id": 2352, "method_signature": "void setState(State)"}, "3746": {"callee_method_names": ["LinkedHashMap.get", "LinkedHashMap.remove", "LinkedHashMap.put", "LinkedHashMap.remove", "LinkedHashMap.put"], "method_name": "WorkSheet.changeColumnHeader", "method_implementation": "{\n    HeaderInfo value = columnLookup.get(col);\n    if (value == null) {\n        throw new Exception(\"Column not found \" + col);\n    }\n    columnLookup.remove(col);\n    columnLookup.put(newCol, value);\n    if (this.isMetaDataColumn(col)) {\n        metaDataColumnsHashMap.remove(col);\n        metaDataColumnsHashMap.put(newCol, newCol);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param col\n * @param newCol\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3746, "method_signature": "void changeColumnHeader(String, String)"}, "2026": {"callee_method_names": [], "method_name": "RectangularPrism.getLength", "method_implementation": "{\n    return length;\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a circumscribed sphere, that goes\n * through all vertices\n * @return the cirumscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2026, "method_signature": "double getLength()"}, "1596": {"callee_method_names": ["StringBuffer.append", "SecStrucGroup[].getChain", "StringBuffer.append", "StringBuffer.toString"], "method_name": "SecStrucCalc.printFASTA", "method_implementation": "{\n    StringBuffer buf = new StringBuffer();\n    String nl = System.getProperty(\"line.separator\");\n    buf.append(\">\" + groups[0].getChain().getStructure().getIdentifier() + nl);\n    for (int g = 0; g < groups.length; g++) {\n        buf.append(getSecStrucState(g).getType());\n    }\n    return buf.toString();\n}", "repo_id": "9", "comment": "/**\n * Generate a FASTA sequence with the SS annotation letters in the\n * aminoacid sequence order.\n * @return String in FASTA sequence format\n */\n", "repo_name": "biojava-master/", "id": 1596, "method_signature": "String printFASTA()"}, "2386": {"callee_method_names": ["RandomAccessFile.close"], "method_name": "TwoBitParser.closeParser", "method_implementation": "{\n    raf.close();\n}", "repo_id": "9", "comment": "/**\n * Method closes random access file descriptor. You can't use any reading methods\n * after it.\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2386, "method_signature": "void closeParser()"}, "3711": {"callee_method_names": ["HashMap.clear", "ArrayList<String>.size", "ArrayList<Integer>.add", "ArrayList<String>.size", "ArrayList<String>.get", "ArrayList<Integer>.get", "ArrayList<String>.get"], "method_name": "WorkSheet.shuffleRowValues", "method_implementation": "{\n    doubleValues.clear();\n    ArrayList<String> columns = this.getColumns();\n    for (String row : rows) {\n        ArrayList<Integer> columnIndex = new ArrayList<Integer>();\n        for (int i = 0; i < columns.size(); i++) {\n            columnIndex.add(i);\n        }\n        Collections.shuffle(columnIndex);\n        for (int i = 0; i < columns.size(); i++) {\n            String column = columns.get(i);\n            int randomIndex = columnIndex.get(i);\n            String destinationCol = columns.get(randomIndex);\n            String temp = this.getCell(row, destinationCol);\n            String value = this.getCell(row, column);\n            this.addCell(row, destinationCol, value);\n            this.addCell(row, column, temp);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Need to shuffle rows values to allow for randomized testing. The rows in\n * the list will be shuffled together\n *\n * @param rows\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3711, "method_signature": "void shuffleRowValues(ArrayList)"}, "1820": {"callee_method_names": [], "method_name": "EcodInstallation.getDomains", "method_implementation": "{\n    return domains;\n}", "repo_id": "9", "comment": "/**\n * @return a list of all EcodDomains\n */\n", "repo_name": "biojava-master/", "id": 1820, "method_signature": "List<EcodDomain> getDomains()"}, "3356": {"callee_method_names": ["NavigableMap<Double, Color>.put"], "method_name": "GradientMapper.put", "method_implementation": "{\n    if (position == null) {\n        throw new NullPointerException(\"Null endpoint position\");\n    }\n    if (color == null) {\n        throw new NullPointerException(\"Null colors are not allowed.\");\n    }\n    return mapping.put(position, color);\n}", "repo_id": "9", "comment": "/**\n * Adds a gradient endpoint at the specified position.\n * @param position The endpoint position. May be Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY for endpoints.\n * @param color\n * @return\n * @see java.util.Map#put(java.lang.Object, java.lang.Object)\n */\n", "repo_name": "biojava-master/", "id": 3356, "method_signature": "Color put(Double, Color)"}, "2146": {"callee_method_names": [], "method_name": "StructureImpl.getEntityInfos", "method_implementation": "{\n    return entityInfos;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2146, "method_signature": "List<EntityInfo> getEntityInfos()"}, "2978": {"callee_method_names": ["List<C>.add", "CompoundSet<C>.getCompoundForString", "List<C>.add", "CompoundSet<C>.getCompoundForString", "List<C>.add", "CompoundSet<C>.getCompoundForString", "List<C>.add", "CompoundSet<C>.getCompoundForString"], "method_name": "TwoBitArrayWorker.generateIndexToCompounds", "method_implementation": "{\n    CompoundSet<C> cs = getCompoundSet();\n    List<C> result = new ArrayList<C>();\n    result.add(cs.getCompoundForString(\"T\"));\n    result.add(cs.getCompoundForString(\"C\"));\n    result.add(cs.getCompoundForString(\"A\"));\n    result.add(cs.getCompoundForString(\"G\"));\n    return result;\n}", "repo_id": "9", "comment": "/**\n * Returns a List which encodes TCAG into positions 0,1,2,3.\n */\n", "repo_name": "biojava-master/", "id": 2978, "method_signature": "List<C> generateIndexToCompounds()"}, "324": {"callee_method_ids": [298, 290], "callee_method_names": ["ProteinModificationIdentifier.identify", "ProteinModificationIdentifier.getIdentifiedModifiedCompound", "ModifiedCompound.getGroups", "List<ResidueNumber>.add", "String.getPDBResidueNumber"], "method_name": "ProteinModificationParserTest.identifyPhosphosites", "method_implementation": "{\n    List<ResidueNumber> phosphosites = new ArrayList<ResidueNumber>();\n    ProteinModificationIdentifier parser = new ProteinModificationIdentifier();\n    parser.identify(struc, ProteinModificationRegistry.getByKeyword(\"phosphoprotein\"));\n    Set<ModifiedCompound> mcs = parser.getIdentifiedModifiedCompound();\n    for (ModifiedCompound mc : mcs) {\n        Set<StructureGroup> groups = mc.getGroups(true);\n        for (StructureGroup group : groups) {\n            phosphosites.add(group.getPDBResidueNumber());\n        }\n    }\n    return phosphosites;\n}", "repo_id": "9", "comment": "/**\n * Note: if you change this unit test, also change the cook book:\n * http://www.biojava.org/wiki/BioJava:CookBook3:ProtMod\n */\n", "repo_name": "biojava-master/", "id": 324, "method_signature": "List<ResidueNumber> identifyPhosphosites(Structure)"}, "2621": {"callee_method_names": [], "method_name": "StringManipulationHelper.padLeft", "method_implementation": "{\n    validatePadding(n);\n    return String.format(\"%1$\" + n + \"s\", s);\n}", "repo_id": "9", "comment": "/**\n * Adds padding to left of supplied string\n * @param s The String to pad\n * @param n an integer >= 1\n * @return The left-padded string.\n * @throws IllegalArgumentException if n <= 0\n */\n", "repo_name": "biojava-master/", "id": 2621, "method_signature": "String padLeft(String, int)"}, "966": {"callee_method_names": [], "method_name": "BioAssemblyTools.getMaximumExtend", "method_implementation": "{\n    double[][] bounds = getAtomCoordinateBounds(structure);\n    double xMax = Math.abs(bounds[0][0] - bounds[1][0]);\n    double yMax = Math.abs(bounds[0][1] - bounds[1][1]);\n    double zMax = Math.abs(bounds[0][2] - bounds[1][2]);\n    return Math.max(xMax, Math.max(yMax, zMax));\n}", "repo_id": "9", "comment": "/**\n * Returns the maximum extend of the structure in the x, y, or z direction.\n * @param structure\n * @return maximum extend\n */\n", "repo_name": "biojava-master/", "id": 966, "method_signature": "double getMaximumExtend(Structure)"}, "2059": {"callee_method_names": ["List<CeSymmResult>.size", "List<CeSymmResult>.get", "CeSymmResult.setSelfAlignment", "List<CeSymmResult>.get", "CeSymmResult.setStructureId", "List<CeSymmResult>.get", "CeSymmResult.setAtoms", "List<CeSymmResult>.get", "CeSymmResult.setParams", "List<CeSymmResult>.get", "MultipleAlignment.getEnsemble", "MultipleAlignment.getEnsemble", "MultipleAlignment.getEnsemble", "MultipleAlignment.getEnsemble", "Block.setAlignRes", "ConnectivityInspector<Integer, DefaultEdge>.connectedSets", "List<Set<Integer>>.size", "List<ResidueGroup>.add", "Block.getAlignRes", "Group.order", "Group.combineWith", "Block.getAlignRes", "Block.length", "List<CeSymmResult>.get", "Block.getAlignRes", "MultipleAlignment.getEnsemble", "MultipleAlignment.getEnsemble", "CeSymmResult.getStructureId", "CeSymmResult.setMultipleAlignment", "CeSymmResult.setRefined", "CeSymmResult.setNumRepeats", "CeSymmResult.setAxes", "CeSymmResult.getAxes", "MultipleAlignment.size", "MultipleAlignment.putScore", "MultipleAlignment.putScore"], "method_name": "CeSymmIterative.reconstructSymmResult", "method_implementation": "{\n    // If one level, nothing to build or calculate\n    if (levels.size() == 1)\n        return levels.get(0);\n    CeSymmResult result = new CeSymmResult();\n    result.setSelfAlignment(levels.get(0).getSelfAlignment());\n    result.setStructureId(levels.get(0).getStructureId());\n    result.setAtoms(levels.get(0).getAtoms());\n    result.setParams(levels.get(0).getParams());\n    // Initialize a new multiple alignment\n    MultipleAlignment msa = new MultipleAlignmentImpl();\n    msa.getEnsemble().setAtomArrays(new ArrayList<Atom[]>());\n    msa.getEnsemble().setStructureIdentifiers(new ArrayList<StructureIdentifier>());\n    msa.getEnsemble().setAlgorithmName(CeSymm.algorithmName);\n    msa.getEnsemble().setVersion(CeSymm.version);\n    BlockSet bs = new BlockSetImpl(msa);\n    Block b = new BlockImpl(bs);\n    b.setAlignRes(new ArrayList<List<Integer>>());\n    // Calculate the connected groups of the alignment graph\n    ConnectivityInspector<Integer, DefaultEdge> inspector = new ConnectivityInspector<Integer, DefaultEdge>(alignGraph);\n    List<Set<Integer>> comps = inspector.connectedSets();\n    List<ResidueGroup> groups = new ArrayList<ResidueGroup>(comps.size());\n    for (Set<Integer> comp : comps) groups.add(new ResidueGroup(comp));\n    // Calculate the total number of repeats\n    int order = 1;\n    for (CeSymmResult sr : levels) order *= sr.getMultipleAlignment().size();\n    for (int su = 0; su < order; su++) b.getAlignRes().add(new ArrayList<Integer>());\n    // Construct the resulting MultipleAlignment from ResidueGroups\n    for (ResidueGroup group : groups) {\n        if (group.order() != order)\n            continue;\n        group.combineWith(b.getAlignRes());\n    }\n    // The reconstruction failed, so the top level is returned\n    if (b.length() == 0)\n        return levels.get(0);\n    for (int su = 0; su < order; su++) {\n        Collections.sort(b.getAlignRes().get(su));\n        msa.getEnsemble().getAtomArrays().add(atoms);\n        msa.getEnsemble().getStructureIdentifiers().add(result.getStructureId());\n    }\n    result.setMultipleAlignment(msa);\n    result.setRefined(true);\n    result.setNumRepeats(order);\n    SymmetryAxes axes = recoverAxes(result);\n    result.setAxes(axes);\n    // Set the transformations and scores of the final alignment\n    SymmetryTools.updateSymmetryTransformation(result.getAxes(), msa);\n    double tmScore = MultipleAlignmentScorer.getAvgTMScore(msa) * msa.size();\n    double rmsd = MultipleAlignmentScorer.getRMSD(msa);\n    msa.putScore(MultipleAlignmentScorer.AVGTM_SCORE, tmScore);\n    msa.putScore(MultipleAlignmentScorer.RMSD, rmsd);\n    return result;\n}", "repo_id": "9", "comment": "/**\n * After all the analysis iterations have finished, the final Result object\n * is reconstructed using the cumulative alignment graph.\n *\n * @param atoms\n *            the original structure atoms\n * @return CeSymmResult reconstructed symmetry result\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2059, "method_signature": "CeSymmResult reconstructSymmResult(Atom[])"}, "2995": {"callee_method_names": [], "method_name": "BitSequenceReader.setCompoundAt", "method_implementation": "{\n    hashcode = null;\n    int arrayIndex = biologicalIndexToArrayIndex(position);\n    int currentInt = sequence[arrayIndex];\n    int shiftBy = shiftBy(position);\n    Integer integerValue = getCompoundsToIndexLookup().get(compound);\n    //If we got nothing then throw an error as it's wrong\n    if (integerValue == null) {\n        processUnknownCompound(compound, position);\n    }\n    int shiftedValue = integerValue << shiftBy;\n    sequence[arrayIndex] = currentInt | shiftedValue;\n}", "repo_id": "9", "comment": "/**\n * Sets the compound at the specified biological index\n */\n", "repo_name": "biojava-master/", "id": 2995, "method_signature": "void setCompoundAt(C, int)"}, "700": {"callee_method_names": [], "method_name": "MultipleMcOptimizer.probabilityFunction", "method_implementation": "{\n    double prob = (C + AS) / (m * C);\n    // Normalization factor\n    double norm = (1 - (m * 1.0) / maxIter);\n    return Math.min(Math.max(prob * norm, 0.0), 1.0);\n}", "repo_id": "9", "comment": "/**\n * Calculates the probability of accepting a bad move given the iteration\n * step and the score change.\n * <p>\n * Function: p=(C-AS)/(m*C) , slightly different from the CEMC algorithm.\n * <p>\n * Added a normalization factor so that the probability approaches 0 as the\n * final of the optimization gets closer.\n */\n", "repo_name": "biojava-master/", "id": 700, "method_signature": "double probabilityFunction(double, int, int)"}, "3594": {"callee_method_names": [], "method_name": "StdArrayIO.print", "method_implementation": "{\n    int M = a.length;\n    int N = a[0].length;\n    System.out.println(M + \" \" + N);\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            if (a[i][j])\n                System.out.print(\"1 \");\n            else\n                System.out.print(\"0 \");\n        }\n        System.out.println();\n    }\n}", "repo_id": "9", "comment": "/**\n * Print the  M-by-N array of booleans to standard output.\n * @param a\n */\n", "repo_name": "biojava-master/", "id": 3594, "method_signature": "void print(boolean[][])"}, "3159": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.iterator", "method_implementation": "{\n    return this.parsedCompounds.iterator();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3159, "method_signature": "Iterator<C> iterator()"}, "3641": {"callee_method_names": [], "method_name": "CoxInfo.setDegreeFreedom", "method_implementation": "{\n    this.degreeFreedom = degreeFreedom;\n}", "repo_id": "9", "comment": "/**\n * @param degreeFreedom the degreeFreedom to set\n */\n", "repo_name": "biojava-master/", "id": 3641, "method_signature": "void setDegreeFreedom(double)"}, "77": {"callee_method_names": [], "method_name": "GuanUberbacher.setCutsPerSection", "method_implementation": "{\n    this.cutsPerSection = Math.max(1, cutsPerSection);\n}", "repo_id": "9", "comment": "/**\n * Sets the number of cuts added to each section during each pass.\n *\n * @param cutsPerSection the number of cuts added to each section during each pass\n */\n", "repo_name": "biojava-master/", "id": 77, "method_signature": "void setCutsPerSection(int)"}, "2803": {"callee_method_names": [], "method_name": "ClasspathResource.getInputStream", "method_implementation": "{\n    return createClasspathInputStream();\n}", "repo_id": "9", "comment": "/**\n * Returns the InputStream instance of this classpath resource\n */\n", "repo_name": "biojava-master/", "id": 2803, "method_signature": "InputStream getInputStream()"}, "1917": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.setOnTheFly", "method_implementation": "{\n    this.onTheFly = useJmolBioAssemblies;\n}", "repo_id": "9", "comment": "/**\n * On-the-fly Jmol bioassembly generation.\n *\n * @param useJmolBioAssemblies\n *            true if Jmol on the fly bioassembly generation is used, false\n *            otherwise\n */\n", "repo_name": "biojava-master/", "id": 1917, "method_signature": "void setOnTheFly(boolean)"}, "1760": {"callee_method_names": ["Class<?>.getMethods", "int.getName", "String.substring", "int.invoke", "StringBuilder.append", "String.substring", "String.length", "StringBuilder.append", "Logger.error", "Logger.error", "Logger.error", "StringBuilder.toString"], "method_name": "PDBHeader.toString", "method_implementation": "{\n    StringBuilder buf = new StringBuilder();\n    try {\n        Class<?> c = Class.forName(PDBHeader.class.getName());\n        Method[] methods = c.getMethods();\n        for (Method m : methods) {\n            String name = m.getName();\n            if (\"get\".equals(name.substring(0, 3))) {\n                if (\"getClass\".equals(name)) {\n                    continue;\n                }\n                Object o = m.invoke(this);\n                if (o != null) {\n                    buf.append(name.substring(3, name.length()));\n                    buf.append(\": \").append(o).append(\" \");\n                }\n            }\n        }\n    } catch (ClassNotFoundException e) {\n        logger.error(\"Exception caught while creating toString  \", e);\n    } catch (InvocationTargetException e) {\n        logger.error(\"Exception caught while creating toString \", e);\n    } catch (IllegalAccessException e) {\n        logger.error(\"Exception caught while creating toString \", e);\n    }\n    return buf.toString();\n}", "repo_id": "9", "comment": "/**\n * String representation\n */\n", "repo_name": "biojava-master/", "id": 1760, "method_signature": "String toString()"}, "3414": {"callee_method_ids": [1966], "callee_method_names": ["HelixAxisAligner.calcCenterOfRotation", "HelixAxisAligner.getHelixLayers", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Point3d.scale", "HelixAxisAligner.getDimension", "Point3d.negate", "Point3d.add", "Point3d.add", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorH.drawAxes", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    //\t\tPoint3d centroid = helixAxisAligner.getCentroid();\n    //\t\tSystem.out.println(\"Centroid: \" + helixAxisAligner.getCentroid());\n    //\t\tPoint3d centroid = helixAxisAligner.getGeometricCenter();\n    Point3d centroid = helixAxisAligner.calcCenterOfRotation();\n    //\t\tSystem.out.println(\"Geometric center: \" + centroid);\n    AxisAngle4d axisAngle = helixAxisAligner.getHelixLayers().getByLowestAngle().getAxisAngle();\n    Vector3d axis = new Vector3d(axisAngle.x, axisAngle.y, axisAngle.z);\n    s.append(\"draw axesHelical\");\n    s.append(name);\n    s.append(0);\n    s.append(\" \");\n    s.append(\"line\");\n    Point3d v1 = new Point3d(axis);\n    v1.scale(AXIS_SCALE_FACTOR * (helixAxisAligner.getDimension().y + SIDE_CHAIN_EXTENSION));\n    Point3d v2 = new Point3d(v1);\n    v2.negate();\n    v1.add(centroid);\n    v2.add(centroid);\n    s.append(getJmolPoint(v1));\n    s.append(getJmolPoint(v2));\n    s.append(\"width 1.0 \");\n    s.append(\" color red\");\n    s.append(\" off;\");\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script that draws symmetry or inertia axes for a structure.\n * Use showAxes() and hideAxes() to toggle visibility.\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3414, "method_signature": "String drawAxes()"}, "3621": {"callee_method_names": ["String.length"], "method_name": "CoxInfo.fmtpr", "method_implementation": "{\n    int length = d.length();\n    int extra = pad - length;\n    if (extra < 0) {\n        extra = 0;\n    }\n    String v = d;\n    for (int i = 0; i < extra; i++) {\n        v = v + \" \";\n    }\n    return v;\n}", "repo_id": "9", "comment": "/**\n * @param d\n * @param pad\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3621, "method_signature": "String fmtpr(String, int)"}, "1947": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setMaxTm", "method_implementation": "{\n    this.maxTm = maxTm;\n}", "repo_id": "9", "comment": "/**\n * @param maxTm the maxTm to set\n */\n", "repo_name": "biojava-master/", "id": 1947, "method_signature": "void setMaxTm(double)"}, "3429": {"callee_method_names": ["MultipleAlignmentJmol.setColorByBlocks", "MultipleAlignmentJmol.setTitle"], "method_name": "SymmetryDisplay.displayFull", "method_implementation": "{\n    MultipleAlignment full = SymmetryTools.toFullAlignment(symm);\n    MultipleAlignmentJmol jmol = MultipleAlignmentJmolDisplay.display(full);\n    jmol.setColorByBlocks(true);\n    jmol.setTitle(getSymmTitle(symm));\n    return jmol;\n}", "repo_id": "9", "comment": "/**\n * Displays a multiple alignment of the whole structure transformations\n * colored by blocks, corresponding to the symmetric protodomains.\n *\n * @param symm\n *            CeSymmResult\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3429, "method_signature": "MultipleAlignmentJmol displayFull(CeSymmResult)"}, "803": {"callee_method_names": [], "method_name": "AlignmentResult.setAlignments", "method_implementation": "{\n    if (alignments.length > 0) {\n        this.alignments = new AlternativeAlignment[1];\n        this.alignments[0] = alignments[0];\n    }\n}", "repo_id": "9", "comment": "/**\n * we only keep the first alternative...\n *\n * @param alignments\n */\n", "repo_name": "biojava-master/", "id": 803, "method_signature": "void setAlignments(AlternativeAlignment[])"}, "2542": {"callee_method_names": [], "method_name": "SimpleAlignedSequence.toString", "method_implementation": "{\n    return getSequenceAsString();\n}", "repo_id": "9", "comment": "/**\n * Provides standard Java language access to results of {@link #getSequenceAsString()}.\n */\n", "repo_name": "biojava-master/", "id": 2542, "method_signature": "String toString()"}, "3654": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "SurvivalInfo.getVariable", "method_implementation": "{\n    Double value = data.get(variable);\n    return value;\n}", "repo_id": "9", "comment": "/**\n * @param variable\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3654, "method_signature": "Double getVariable(String)"}, "831": {"callee_method_names": ["Atom[].getGroup", "TreeMap<ResidueNumber, GroupAsa>.containsKey", "Group.getResidueNumber", "GroupAsa.addAtomAsaU", "TreeMap<ResidueNumber, GroupAsa>.put", "Group.getResidueNumber", "TreeMap<ResidueNumber, GroupAsa>.get", "Group.getResidueNumber", "GroupAsa.addAtomAsaU", "TreeMap<ResidueNumber, GroupAsa>.values"], "method_name": "AsaCalculator.getGroupAsas", "method_implementation": "{\n    TreeMap<ResidueNumber, GroupAsa> asas = new TreeMap<>();\n    double[] asasPerAtom = calculateAsas();\n    for (int i = 0; i < atomCoords.length; i++) {\n        Group g = atoms[i].getGroup();\n        if (!asas.containsKey(g.getResidueNumber())) {\n            GroupAsa groupAsa = new GroupAsa(g);\n            groupAsa.addAtomAsaU(asasPerAtom[i]);\n            asas.put(g.getResidueNumber(), groupAsa);\n        } else {\n            GroupAsa groupAsa = asas.get(g.getResidueNumber());\n            groupAsa.addAtomAsaU(asasPerAtom[i]);\n        }\n    }\n    return asas.values().toArray(new GroupAsa[0]);\n}", "repo_id": "9", "comment": "/**\n * Calculates ASA for all atoms and return them as a GroupAsa\n * array (one element per residue in structure) containing ASAs per residue\n * and per atom.\n * The sorting of Groups in returned array is as specified by {@link org.biojava.nbio.structure.ResidueNumber}\n * @return\n */\n", "repo_name": "biojava-master/", "id": 831, "method_signature": "GroupAsa[] getGroupAsas()"}, "742": {"callee_method_names": ["AFPChain.setBlockNum", "AFPChain.setBlockRotationMatrix", "AFPChain.setBlockShiftVector", "AFPChain.setDisTable1", "AFPChain.setDisTable1", "AFPChain.setDisTable2", "AFPChain.setDisTable2", "AFPChain.setOptAln", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "AFPChain.setAlnseq1", "AFPChain.setAlnseq2", "AFPChain.setAlnsymb", "AFPChain.setIdentity", "AFPChain.setSimilarity", "AFPChain.setIdentity", "AFPChain.setSimilarity"], "method_name": "CeCalculatorEnhanced.convertAfpChain", "method_implementation": "{\n    afpChain.setBlockNum(1);\n    //afpChain.setAlignScore(z);\n    Matrix[] m;\n    if (r != null) {\n        m = new Matrix[1];\n        m[0] = r;\n    } else {\n        m = new Matrix[0];\n    }\n    Atom[] as;\n    if (t != null) {\n        as = new Atom[1];\n        as[0] = t;\n    } else {\n        as = new Atom[0];\n    }\n    afpChain.setBlockRotationMatrix(m);\n    afpChain.setBlockShiftVector(as);\n    int nse1 = ca1.length;\n    int nse2 = ca2.length;\n    //System.out.println(\"dist1 :\" + dist1.length + \" \" + dist2.length);\n    if (nse1 > 0 && dist1.length > 0)\n        afpChain.setDisTable1(new Matrix(dist1));\n    else\n        afpChain.setDisTable1(Matrix.identity(3, 3));\n    if (nse2 > 0 && dist2.length > 0)\n        afpChain.setDisTable2(new Matrix(dist2));\n    else\n        afpChain.setDisTable2(Matrix.identity(3, 3));\n    char[] alnseq1 = new char[nse1 + nse2 + 1];\n    char[] alnseq2 = new char[nse1 + nse2 + 1];\n    char[] alnsymb = new char[nse1 + nse2 + 1];\n    int[][][] optAln = new int[1][2][nAtom];\n    afpChain.setOptAln(optAln);\n    int pos = 0;\n    int nrIdent = 0;\n    int nrSim = 0;\n    for (int ia = 0; ia < alignmentPositionOrLength; ia++) {\n        // no gap\n        if (align_se1[ia] != -1 && align_se2[ia] != -1) {\n            //System.out.println(\"ia \" + ia + \" pos \" + pos + \" \"  + align_se1[ia] + \" \" + align_se2[ia]);\n            optAln[0][0][pos] = align_se1[ia];\n            optAln[0][1][pos] = align_se2[ia];\n            char l1 = getOneLetter(ca1[align_se1[ia]].getGroup());\n            char l2 = getOneLetter(ca2[align_se2[ia]].getGroup());\n            alnseq1[ia] = Character.toUpperCase(l1);\n            alnseq2[ia] = Character.toUpperCase(l2);\n            alnsymb[ia] = ' ';\n            if (l1 == l2) {\n                nrIdent++;\n                nrSim++;\n                alnsymb[ia] = '|';\n            } else if (AFPAlignmentDisplay.aaScore(l1, l2) > 0) {\n                nrSim++;\n                alnsymb[ia] = ':';\n            }\n            pos++;\n        } else {\n            // there is a gap at this position\n            alnsymb[ia] = ' ';\n            if (align_se1[ia] == -1) {\n                alnseq1[ia] = '-';\n            } else {\n                char l1 = getOneLetter(ca1[align_se1[ia]].getGroup());\n                alnseq1[ia] = Character.toUpperCase(l1);\n            }\n            if (align_se2[ia] == -1) {\n                alnseq2[ia] = '-';\n            } else {\n                char l2 = getOneLetter(ca2[align_se2[ia]].getGroup());\n                alnseq2[ia] = Character.toUpperCase(l2);\n            }\n        }\n    }\n    afpChain.setAlnseq1(alnseq1);\n    afpChain.setAlnseq2(alnseq2);\n    afpChain.setAlnsymb(alnsymb);\n    // CE uses the aligned pairs as reference not the whole alignment including gaps...\n    if (pos > 0) {\n        afpChain.setIdentity(nrIdent * 1.0 / pos);\n        afpChain.setSimilarity(nrSim * 1.0 / pos);\n    } else {\n        afpChain.setIdentity(0);\n        afpChain.setSimilarity(0);\n    }\n    //AFPAlignmentDisplay.getAlign( afpChain,ca1,ca2);\n}", "repo_id": "9", "comment": "/**\n * copy data from this class into AFPChain container object.\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n */\n", "repo_name": "biojava-master/", "id": 742, "method_signature": "void convertAfpChain(AFPChain, Atom[], Atom[])"}, "601": {"callee_method_names": ["AFPChain.getGroup", "Group.getChain", "double.getId", "Chain.getId", "Chain.setId", "Chain.getId", "List<Chain>.add", "Chain.addGroup"], "method_name": "AlignmentTools.getAlignedModel", "method_implementation": "{\n    List<Chain> model = new ArrayList<Chain>();\n    for (Atom a : ca) {\n        Group g = a.getGroup();\n        Chain parentC = g.getChain();\n        Chain newChain = null;\n        for (Chain c : model) {\n            if (c.getId().equals(parentC.getId())) {\n                newChain = c;\n                break;\n            }\n        }\n        if (newChain == null) {\n            newChain = new ChainImpl();\n            newChain.setId(parentC.getId());\n            model.add(newChain);\n        }\n        newChain.addGroup(g);\n    }\n    return model;\n}", "repo_id": "9", "comment": "/**\n * get an artificial List of chains containing the Atoms and groups.\n * Does NOT rotate anything.\n * @param ca\n * @return a list of Chains that is built up from the Atoms in the ca array\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 601, "method_signature": "List<Chain> getAlignedModel(Atom[])"}, "2452": {"callee_method_names": [], "method_name": "Feature.source", "method_implementation": "{\n    return mSource;\n}", "repo_id": "9", "comment": "/**\n * Get source (aka method). (GFF field 2). This is often the name of\n * the program or procedure that created the features.\n *\n * @return Source field.\n */\n", "repo_name": "biojava-master/", "id": 2452, "method_signature": "String source()"}, "3556": {"callee_method_names": ["String.replaceAll", "String.replaceAll", "String.replaceAll"], "method_name": "CoxVariables.encodeFileURL", "method_implementation": "{\n    file = file.replaceAll(\" \", \"%20\");\n    file = file.replaceAll(\"<\", \"%3C\");\n    file = file.replaceAll(\">\", \"%3E\");\n    return file;\n}", "repo_id": "9", "comment": "/**\n * @param file\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3556, "method_signature": "String encodeFileURL(String)"}, "448": {"callee_method_names": ["Map<Integer,Integer>.keySet", "List<Subunit>.size", "Map<Integer,Integer>.values", "List<Subunit>.size", "Map<Integer,Integer>.size", "Map<Integer,Integer>.keySet", "List<Subunit>.size", "Map<Integer,Integer>.values", "List<Subunit>.size", "Map<Integer,Integer>.values", "List<Subunit>.size"], "method_name": "QsAlignResult.setSubunitMap", "method_implementation": "{\n    // Check consistency of the map\n    if (Collections.max(subunitMap.keySet()) > subunits1.size() | Collections.max(subunitMap.values()) > subunits2.size())\n        throw new IndexOutOfBoundsException(\"Subunit Map index higher than Subunit List size.\");\n    // Update the relation enum\n    if (subunitMap.size() == 0) {\n        relation = QsRelation.DIFFERENT;\n    } else if (subunitMap.keySet().size() == subunits1.size()) {\n        if (subunitMap.values().size() == subunits2.size()) {\n            relation = QsRelation.EQUIVALENT;\n        } else {\n            relation = QsRelation.PARTIAL_COMPLETE;\n        }\n    } else {\n        if (subunitMap.values().size() == subunits2.size()) {\n            relation = QsRelation.PARTIAL_COMPLETE;\n        } else {\n            relation = QsRelation.PARTIAL_INCOMPLETE;\n        }\n    }\n    this.subunitMap = subunitMap;\n}", "repo_id": "9", "comment": "/**\n * Map of Subunit equivalencies from the first to the second group.\n *\n * @param subunitMap\n */\n", "repo_name": "biojava-master/", "id": 448, "method_signature": "void setSubunitMap(Map)"}, "660": {"callee_method_names": ["List<Atom[]>.size", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.get", "Matrix.get", "Matrix.set", "Matrix.set", "Matrix.get", "Matrix.get", "Matrix.set", "Matrix.set", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.set", "Matrix.get"], "method_name": "MultipleAlignmentTools.getAverageResidueDistances", "method_implementation": "{\n    int size = transformed.size();\n    int length = transformed.get(0).length;\n    Matrix resDist = new Matrix(size, length, -1);\n    // Calculate the average residue distances\n    for (int r1 = 0; r1 < size; r1++) {\n        for (int c = 0; c < transformed.get(r1).length; c++) {\n            Atom refAtom = transformed.get(r1)[c];\n            if (refAtom == null)\n                continue;\n            for (int r2 = r1 + 1; r2 < size; r2++) {\n                Atom atom = transformed.get(r2)[c];\n                if (atom != null) {\n                    double distance = Calc.getDistance(refAtom, atom);\n                    if (resDist.get(r1, c) == -1) {\n                        resDist.set(r1, c, 1 + distance);\n                    } else {\n                        resDist.set(r1, c, resDist.get(r1, c) + distance);\n                    }\n                    if (resDist.get(r2, c) == -1) {\n                        resDist.set(r2, c, 1 + distance);\n                    } else {\n                        resDist.set(r2, c, resDist.get(r2, c) + distance);\n                    }\n                }\n            }\n        }\n    }\n    for (int c = 0; c < length; c++) {\n        int nonNullRes = 0;\n        for (int r = 0; r < size; r++) {\n            if (resDist.get(r, c) != -1)\n                nonNullRes++;\n        }\n        for (int r = 0; r < size; r++) {\n            if (resDist.get(r, c) != -1) {\n                resDist.set(r, c, resDist.get(r, c) / nonNullRes);\n            }\n        }\n    }\n    return resDist;\n}", "repo_id": "9", "comment": "/**\n * The average residue distance Matrix contains the average distance from\n * each residue to all other residues aligned with it.\n * <p>\n * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n * length.\n *\n * @param transformed\n *            List of Atom arrays containing only the aligned atoms of each\n *            structure, or null if there is a gap.\n * @return Matrix containing all average residue distances. Entry -1 means\n *         there is a gap in the position.\n */\n", "repo_name": "biojava-master/", "id": 660, "method_signature": "Matrix getAverageResidueDistances(List)"}, "1061": {"callee_method_names": ["Atom.getElement", "Group.hasAtom", "Atom.getName"], "method_name": "StructureTools.hasDeuteratedEquiv", "method_implementation": "{\n    // If it's hydrogen and has a deuterated brother\n    return atom.getElement() == Element.H && currentGroup.hasAtom(replaceFirstChar(atom.getName(), 'H', 'D'));\n}", "repo_id": "9", "comment": "/**\n * Check to see if a Hydrogen has a  Deuterated brother in the group.\n * @param atom the input atom that is putatively hydorgen\n * @param currentGroup the group the atom is in\n * @return true if the atom is hydrogen and it's Deuterium equiv exists.\n */\n", "repo_name": "biojava-master/", "id": 1061, "method_signature": "boolean hasDeuteratedEquiv(Atom, Group)"}, "1185": {"callee_method_ids": [1317], "callee_method_names": ["FileParsingParameters.isHeaderOnly", "String.length", "Logger.info", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.length", "String.substring", "String.substring", "Logger.info", "SSBondImpl.setChainID1", "SSBondImpl.setResnum1", "SSBondImpl.setChainID2", "SSBondImpl.setResnum2", "SSBondImpl.setInsCode1", "SSBondImpl.setInsCode2", "ArrayList.add"], "method_name": "PDBFileParser.pdb_SSBOND_Handler", "method_implementation": "{\n    if (params.isHeaderOnly())\n        return;\n    if (line.length() < 36) {\n        logger.info(\"SSBOND line has length under 36. Ignoring it.\");\n        return;\n    }\n    String chain1 = line.substring(15, 16);\n    String seqNum1 = line.substring(17, 21).trim();\n    String icode1 = line.substring(21, 22);\n    String chain2 = line.substring(29, 30);\n    String seqNum2 = line.substring(31, 35).trim();\n    String icode2 = line.substring(35, 36);\n    if (line.length() >= 72) {\n        String symop1 = line.substring(59, 65).trim();\n        String symop2 = line.substring(66, 72).trim();\n        // until we implement proper treatment of symmetry in biojava #220, we can't deal with sym-related parteners properly, skipping them\n        if (// in case the field is missing\n        !\"\".equals(symop1) && !\"\".equals(symop2) && (!\"1555\".equals(symop1) || !\"1555\".equals(symop2))) {\n            logger.info(\"Skipping ss bond between groups {} and {} belonging to different symmetry partners, because it is not supported yet\", seqNum1 + icode1, seqNum2 + icode2);\n            return;\n        }\n    }\n    if (\" \".equals(icode1))\n        icode1 = \"\";\n    if (\" \".equals(icode2))\n        icode2 = \"\";\n    SSBondImpl ssbond = new SSBondImpl();\n    ssbond.setChainID1(chain1);\n    ssbond.setResnum1(seqNum1);\n    ssbond.setChainID2(chain2);\n    ssbond.setResnum2(seqNum2);\n    ssbond.setInsCode1(icode1);\n    ssbond.setInsCode2(icode2);\n    ssbonds.add(ssbond);\n}", "repo_id": "9", "comment": "/**\n *  Process the disulfide bond info provided by an SSBOND record\n *\n *  <pre>\n * \tCOLUMNS        DATA TYPE       FIELD         DEFINITION\n * \t-------------------------------------------------------------------\n * \t 1 -  6        Record name     \"SSBOND\"\n * \t 8 - 10        Integer         serNum       Serial number.\n * \t12 - 14        LString(3)      \"CYS\"        Residue name.\n * \t16             Character       chainID1     Chain identifier.\n * \t18 - 21        Integer         seqNum1      Residue sequence number.\n * \t22             AChar           icode1       Insertion code.\n * \t26 - 28        LString(3)      \"CYS\"        Residue name.\n * \t30             Character       chainID2     Chain identifier.\n * \t32 - 35        Integer         seqNum2      Residue sequence number.\n * \t36             AChar           icode2       Insertion code.\n * \t60 - 65        SymOP           sym1         Symmetry oper for 1st resid\n * \t67 - 72        SymOP           sym2         Symmetry oper for 2nd resid\n *  </pre>\n */\n", "repo_name": "biojava-master/", "id": 1185, "method_signature": "void pdb_SSBOND_Handler(String)"}, "3207": {"callee_method_names": [], "method_name": "BlastXMLParserTest.testStoreObjects", "method_implementation": "{\n    // not implemented yet\n}", "repo_id": "9", "comment": "/**\n * Test of storeObjects method, of class BlastXMLParser.\n */\n", "repo_name": "biojava-master/", "id": 3207, "method_signature": "void testStoreObjects()"}, "94": {"callee_method_names": [], "method_name": "Subproblem.isStartAnchored", "method_implementation": "{\n    return isAnchored;\n}", "repo_id": "9", "comment": "/**\n * Indicates whether the start query and start target index compounds\n * are anchored to each other\n * @return true if the compounds are anchored in the alignment, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 94, "method_signature": "boolean isStartAnchored()"}, "3513": {"callee_method_names": ["ArrayList.size", "ArrayList.get", "DecimalFormat.format", "ArrayList.size", "ArrayList.get"], "method_name": "StrataInfo.getNearestAtRisk", "method_implementation": "{\n    Integer index = 0;\n    /*       String timeValue = t + \"\";\n\t\tString format = \"#\";\n\t\tint numDecimals = 0;\n\t\tint decimalIndex = timeValue.indexOf(\".\");\n\t\tif (decimalIndex > 0) {\n\t\t\tfor (int i = timeValue.length() - 1; i > decimalIndex; i--) {\n\t\t\t\tif (timeValue.charAt(i) == '0' && numDecimals == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (i == decimalIndex - 1) {\n\t\t\t\t\tformat = format + \".#\";\n\t\t\t\t} else {\n\t\t\t\t\tformat = format + \"#\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n */\n    //used to round on expected precision of time. Not correct but trying to match the other packages\n    DecimalFormat newFormat = new DecimalFormat(\"#.#\");\n    for (int i = 0; i < time.size(); i++) {\n        Double compareTime = time.get(i);\n        //  compareTime = new Double(Math.round(compareTime)); //this is rounding up so that we stop on the first match trying to get this to match another report. Not correct or the other report is wrong\n        compareTime = Double.valueOf(newFormat.format(compareTime));\n        if (compareTime < t) {\n            index = i + 1;\n        } else if (compareTime == t) {\n            index = i;\n            break;\n        } else {\n            break;\n        }\n    }\n    //http://www.inside-r.org/packages/cran/rms/docs/survplot\n    //per validation using survplot from RMS package and ggkm they select the next\n    //time in the future which doesn't seem to be correct as the next time represents\n    //knowledge about the future but maybe nrisk at that point in time is defined\n    //as the nrisk prior to that time. This appears to be the case where at time 0\n    //you would expect that everyone is at risk and you should report that time which\n    //is the case in survplot. Added in index = 0 or if the time you are requesting has\n    //an exact match\n    //survplot(kma,n.risk=TRUE,time.inc=1090)\n    //ggkm(kma,timeby=1090)\n    //     if(index != 0 && time.get(index) != t){\n    //      index++;\n    //     }\n    if (index >= nrisk.size()) {\n        return null;\n    } else {\n        return nrisk.get(index);\n    }\n}", "repo_id": "9", "comment": "/**\n * Selection of number of risk will depend on the precision and rounding of\n * time in the survival table. If you are asking for 12 and entry exists for\n * 11.9999999 then 12 is greater than 11.99999 unless you round.\n *\n * @param t\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3513, "method_signature": "Double getNearestAtRisk(double)"}, "1126": {"callee_method_names": [], "method_name": "LocalPDBDirectory.setObsoleteBehavior", "method_implementation": "{\n    obsoleteBehavior = behavior;\n}", "repo_id": "9", "comment": "/**\n * <b>[Optional]</b> This method changes the behavior when obsolete entries\n * are requested. Current behaviors are:\n * <ul>\n * <li>{@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}\n *   Throw a {@link StructureException} (the default)\n * <li>{@link ObsoleteBehavior#FETCH_OBSOLETE FETCH_OBSOLETE}\n *   Load the requested ID from the PDB's obsolete repository\n * <li>{@link ObsoleteBehavior#FETCH_CURRENT FETCH_CURRENT}\n *   Load the most recent version of the requested structure\n *\n * <p>This setting may be silently ignored by implementations which do not have\n * access to the server to determine whether an entry is obsolete, such as\n * if {@link #isAutoFetch()} is false. Note that an obsolete entry may still be\n * returned even this is FETCH_CURRENT if the entry is found locally.\n *\n * @param fetchFileEvenIfObsolete Whether to fetch obsolete records\n * @see #setFetchCurrent(boolean)\n * @since 4.0.0\n */\n", "repo_name": "biojava-master/", "id": 1126, "method_signature": "void setObsoleteBehavior(ObsoleteBehavior)"}, "877": {"callee_method_names": ["SparseVector.getElement", "SparseVector.getGroup", "Group.getType", "List<Atom>.add", "List<Atom>.toArray"], "method_name": "StructureInterface.getAllNonHAtomArray", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>();\n    for (Atom a : m) {\n        if (a.getElement() == Element.H)\n            continue;\n        Group g = a.getGroup();\n        if (g.getType().equals(GroupType.HETATM) && !isInChain(g) && getSizeNoH(g) < minSizeHetAtomToInclude) {\n            continue;\n        }\n        atoms.add(a);\n    }\n    return atoms.toArray(new Atom[0]);\n}", "repo_id": "9", "comment": "/**\n * Returns and array of all non-Hydrogen atoms in the given molecule, including all\n * main chain HETATOM groups. Non main-chain HETATOM groups with fewer than minSizeHetAtomToInclude\n * non-Hydrogen atoms are not included.\n * @param m\n * @param minSizeHetAtomToInclude HETATOM groups (non main-chain) with fewer number of\n * non-Hydrogen atoms are not included\n * @return\n */\n", "repo_name": "biojava-master/", "id": 877, "method_signature": "Atom[] getAllNonHAtomArray(Atom[], int)"}, "2063": {"callee_method_names": ["List<Integer>.isEmpty", "Map<Integer, Double>.get", "Map<Integer,Integer>.get", "Map<Integer, Double>.put", "Map<Integer, Double>.put", "Map<Integer,Integer>.put", "Map<Integer, Double>.size", "Map<Integer, Double>.size", "Map<Integer, Double>.keySet", "Map<Integer, Double>.containsKey", "Map<Integer, Double>.get", "Map<Integer, Double>.get", "Map<Integer, Double>.get", "Map<Integer, Double>.get", "Map<Integer,Integer>.keySet", "Iterator<Integer>.hasNext", "Iterator<Integer>.next", "Map<Integer, Double>.get", "Iterator<Integer>.remove"], "method_name": "SequenceFunctionRefiner.refineSymmetry", "method_implementation": "{\n    // Store scores\n    Map<Integer, Double> scores = null;\n    scores = initializeScores(alignment, scores, k);\n    // Store eligible residues\n    // Eligible if:\n    //  1. score(x)>0\n    //  2. f^K-1(x) is defined\n    //\t3. score(f^K-1(x))>0\n    TreeSet<Integer> forwardLoops = new TreeSet<Integer>();\n    TreeSet<Integer> backwardLoops = new TreeSet<Integer>();\n    List<Integer> eligible = null;\n    eligible = initializeEligible(alignment, scores, eligible, k, forwardLoops, backwardLoops);\n    /* For future heap implementation\n\t\tComparator<Integer> scoreComparator = new Comparator<Integer>() {\n\t\t\t@Override public int compare(Integer o1, Integer o2) {\n\t\t\t\tif(scores.containsKey(o1)) {\n\t\t\t\t\tif(scores.containsKey(o2)) {\n\t\t\t\t\t\t// If both have defined scores, compare the scores\n\t\t\t\t\t\treturn scores.get(o1).compareTo(scores.get(o2));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// o2 has infinite score, so o1 < o2\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//o1 has infinite score\n\t\t\t\t\tif(scores.containsKey(o2)) {\n\t\t\t\t\t\t// o1 > o2\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//both undefined\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tPriorityQueue<Integer> heap = new PriorityQueue<Integer>(alignment.size(), scoreComparator);\n\t\t */\n    //int step = 0;\n    while (!eligible.isEmpty()) {\n        //System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n        // Find eligible residue with lowest scores\n        Integer bestRes = null;\n        double bestResScore = Double.POSITIVE_INFINITY;\n        for (Integer res : eligible) {\n            Double score = scores.get(res);\n            if (score != null && score < bestResScore) {\n                bestResScore = score;\n                bestRes = res;\n            }\n        }\n        // Find f^k-1(bestRes)\n        Integer resK1 = bestRes;\n        for (int i = 0; i < k - 1; i++) {\n            assert (resK1 != null);\n            resK1 = alignment.get(resK1);\n            // Update scores\n            scores.put(resK1, 0.0);\n        }\n        scores.put(bestRes, 0.0);\n        // Modify alignment\n        alignment.put(resK1, bestRes);\n        scores = initializeScores(alignment, scores, k);\n        Map<Integer, Double> virginScores = initializeScores(alignment, null, k);\n        if (scores.size() != virginScores.size()) {\n            System.out.println(\"Size missmatch\");\n        } else {\n            for (Integer key : scores.keySet()) {\n                if (!virginScores.containsKey(key) || !scores.get(key).equals(virginScores.get(key))) {\n                    System.out.format(\"Mismatch %d -> %f/%f%n\", key, scores.get(key), virginScores.get(key));\n                }\n            }\n        }\n        // Update eligible\n        // TODO only update residues which could become ineligible\n        eligible = initializeEligible(alignment, scores, eligible, k, forwardLoops, backwardLoops);\n        // System.out.format(\"Modifying %d -> %d. %d now eligible.%n\", resK1,bestRes,eligible.size());\n    }\n    //System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n    // Remove remaining edges\n    Iterator<Integer> alignmentIt = alignment.keySet().iterator();\n    while (alignmentIt.hasNext()) {\n        Integer res = alignmentIt.next();\n        Double score = scores.get(res);\n        if (score == null || score > 0.0) {\n            alignmentIt.remove();\n        }\n    }\n    //System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n    return alignment;\n}", "repo_id": "9", "comment": "/**\n * Refines a CE-Symm alignment so that it is perfectly symmetric.\n *\n * The resulting alignment will have a one-to-one correspondance between\n * aligned residues of each symmetric part.\n * @param alignment The input alignment, as a map. This will be modified.\n * @param k Symmetry order. This can be guessed by {@link CeSymm#getSymmetryOrder(AFPChain)}\n * @return A modified map with the refined alignment\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2063, "method_signature": "Map<Integer,Integer> refineSymmetry(Map, int)"}, "379": {"callee_method_names": ["Atom.getX", "Atom.getY", "Atom.getZ", "Atom.setX", "Atom.setY", "Atom.setZ"], "method_name": "Calc.scale", "method_implementation": "{\n    double x = a.getX();\n    double y = a.getY();\n    double z = a.getZ();\n    Atom b = new AtomImpl();\n    b.setX(x * s);\n    b.setY(y * s);\n    b.setZ(z * s);\n    return b;\n}", "repo_id": "9", "comment": "/**\n * Multiply elements of a by s\n *\n * @param a\n * @param s\n * @return A new Atom with s*a\n */\n", "repo_name": "biojava-master/", "id": 379, "method_signature": "Atom scale(Atom, double)"}, "1809": {"callee_method_names": [], "method_name": "EcodInstallation.getCacheLocation", "method_implementation": "{\n    return cacheLocation;\n}", "repo_id": "9", "comment": "/**\n * Get the location of the cache directory (usually set to the PDB_CACHE_DIR\n * property). ECOD files will be downloaded to this directory\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1809, "method_signature": "String getCacheLocation()"}, "3192": {"callee_method_names": [], "method_name": "TestFASTAReader.testProcess1", "method_implementation": "{\n    testProcess1(\"org/biojava/nbio/core/fasta/P02768.fasta\");\n}", "repo_id": "9", "comment": "/**\n * Test file contains one sequence (P02768 from swissprot). Read one\n * sequence at a time by calling {@link FastaReader#process(int)} and verify\n * that the first call get one sequence and the second call get none.\n *\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3192, "method_signature": "void testProcess1()"}, "921": {"callee_method_names": ["List<AtomContact>.add"], "method_name": "GroupContact.getContactsWithinDistance", "method_implementation": "{\n    List<AtomContact> list = new ArrayList<AtomContact>();\n    for (AtomContact contact : this.atomContacts) {\n        if (contact.getDistance() < distance) {\n            list.add(contact);\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Returns the list of atom contacts in this GroupContact that are within the given distance.\n * @param distance\n * @return\n */\n", "repo_name": "biojava-master/", "id": 921, "method_signature": "List<AtomContact> getContactsWithinDistance(double)"}, "181": {"callee_method_ids": [1190, 1190], "callee_method_names": ["PDBFileParser.parsePDBFile", "Structure.toPDB", "String.equals", "PDBFileParser.parsePDBFile", "Structure.toPDB", "String.equals"], "method_name": "PDBFileParserTest.testMissingElements", "method_implementation": "{\n    // A two residue structure without Element column\n    String missingElement = \"ATOM      1  N   ASP L   1A     11.095  19.341  20.188  1.00 30.14\" + newline + \"ATOM      2  CA  ASP L   1A     10.070  18.634  19.379  1.00 28.34\" + newline + \"ATOM      3  C   ASP L   1A      9.846  17.102  19.503  1.00 26.08\" + newline + \"ATOM      4  O   ASP L   1A      8.744  16.584  19.162  1.00 23.47\" + newline + \"ATOM      5  CB  ASP L   1A     10.255  18.858  17.853  1.00 37.55\" + newline + \"ATOM      6  CG  ASP L   1A      8.836  19.264  17.401  1.00 42.76\" + newline + \"ATOM      7  OD1 ASP L   1A      8.058  19.292  18.400  1.00 44.03\" + newline + \"ATOM      8  OD2 ASP L   1A      8.616  19.668  16.244  1.00 46.88\" + newline + \"ATOM      9  N   CYS L   1      10.835  16.440  20.113  1.00 23.72\" + newline + \"ATOM     10 CA   CYS L   1      10.769  14.970  20.210  1.00 20.89\" + newline + \"ATOM     11  C   CYS L   1       9.580  14.524  21.006  1.00 18.64\" + newline + \"ATOM     12  O   CYS L   1       9.110  15.220  21.912  1.00 19.03\" + newline + \"ATOM     13  CB  CYS L   1      12.117  14.468  20.771  1.00 21.77\" + newline + \"ATOM     14  SG  CYS L   1      12.247  14.885  22.538  1.00 20.55\" + newline + \"TER                                                               \" + newline;\n    // A two residue structure with empty Element column\n    String emptyElement = \"ATOM      1  N   ASP L   1A     11.095  19.341  20.188  1.00 30.14            \" + newline + \"ATOM      2  CA  ASP L   1A     10.070  18.634  19.379  1.00 28.34            \" + newline + \"ATOM      3  C   ASP L   1A      9.846  17.102  19.503  1.00 26.08            \" + newline + \"ATOM      4  O   ASP L   1A      8.744  16.584  19.162  1.00 23.47            \" + newline + \"ATOM      5  CB  ASP L   1A     10.255  18.858  17.853  1.00 37.55            \" + newline + \"ATOM      6  CG  ASP L   1A      8.836  19.264  17.401  1.00 42.76            \" + newline + \"ATOM      7  OD1 ASP L   1A      8.058  19.292  18.400  1.00 44.03            \" + newline + \"ATOM      8  OD2 ASP L   1A      8.616  19.668  16.244  1.00 46.88            \" + newline + \"ATOM      9  N   CYS L   1      10.835  16.440  20.113  1.00 23.72            \" + newline + \"ATOM     10  CA  CYS L   1      10.769  14.970  20.210  1.00 20.89            \" + newline + \"ATOM     11  C   CYS L   1       9.580  14.524  21.006  1.00 18.64            \" + newline + \"ATOM     12  O   CYS L   1       9.110  15.220  21.912  1.00 19.03            \" + newline + \"ATOM     13  CB  CYS L   1      12.117  14.468  20.771  1.00 21.77            \" + newline + \"ATOM     14  SG  CYS L   1      12.247  14.885  22.538  1.00 20.55            \" + newline + \"TER                                                                             \" + newline;\n    String original = \"ATOM      1  N   ASP L   1A     11.095  19.341  20.188  1.00 30.14           N\" + newline + \"ATOM      2  CA  ASP L   1A     10.070  18.634  19.379  1.00 28.34           C\" + newline + \"ATOM      3  C   ASP L   1A      9.846  17.102  19.503  1.00 26.08           C\" + newline + \"ATOM      4  O   ASP L   1A      8.744  16.584  19.162  1.00 23.47           O\" + newline + \"ATOM      5  CB  ASP L   1A     10.255  18.858  17.853  1.00 37.55           C\" + newline + \"ATOM      6  CG  ASP L   1A      8.836  19.264  17.401  1.00 42.76           C\" + newline + \"ATOM      7  OD1 ASP L   1A      8.058  19.292  18.400  1.00 44.03           O\" + newline + \"ATOM      8  OD2 ASP L   1A      8.616  19.668  16.244  1.00 46.88           O\" + newline + \"ATOM      9  N   CYS L   1      10.835  16.440  20.113  1.00 23.72           N\" + newline + \"ATOM     10  CA  CYS L   1      10.769  14.970  20.210  1.00 20.89           C\" + newline + \"ATOM     11  C   CYS L   1       9.580  14.524  21.006  1.00 18.64           C\" + newline + \"ATOM     12  O   CYS L   1       9.110  15.220  21.912  1.00 19.03           O\" + newline + \"ATOM     13  CB  CYS L   1      12.117  14.468  20.771  1.00 21.77           C\" + newline + \"ATOM     14  SG  CYS L   1      12.247  14.885  22.538  1.00 20.55           S\" + newline + \"TER                                                                             \" + newline;\n    BufferedReader br = new BufferedReader(new StringReader(missingElement));\n    Structure s = parser.parsePDBFile(br);\n    String pdb = s.toPDB();\n    assertTrue(\"the Element column has not been filled correctly\", pdb.equals(original));\n    br = new BufferedReader(new StringReader(emptyElement));\n    s = parser.parsePDBFile(br);\n    pdb = s.toPDB();\n    assertTrue(\"the Element column has not been filled correctly\", pdb.equals(original));\n}", "repo_id": "9", "comment": "/**\n * Test handling of missing Element column. Issue 537 in github.\n */\n", "repo_name": "biojava-master/", "id": 181, "method_signature": "void testMissingElements()"}, "1737": {"callee_method_names": ["List<Chain>.size", "List<Chain>.get", "List<Chain>.size", "List<Chain>.get", "Chain.getAtomSequence", "Logger.isDebugEnabled", "Logger.debug", "Chain.getAtomSequence", "List<Chain>.get", "Chain.getAtomSequence", "String.length", "String.indexOf", "String.length", "Chain.getAtomGroup", "List<Chain>.get", "Map<String, Integer>.get", "Group.getPDBName", "Map<String, Integer>.get", "Group.getPDBName", "String.length", "String.charAt", "String.length", "Group.getAtom", "Map<Integer, List<String>>.get", "Group.getAtom", "Map<Integer, List<String>>.get", "Logger.info", "Group.getPDBName", "String.length", "String.charAt", "String.length", "Logger.info", "Group.getPDBName", "String.length", "String.charAt", "String.length", "Atom.getX", "Atom.getX", "Atom.getY", "Atom.getY", "Atom.getZ", "Atom.getZ", "Map<Integer, List<String>>.get", "Group.getAtom", "Map<Integer, List<String>>.get", "Group.getAtom", "List<Pair<Group>>.add", "ArrayList.add", "Chain.getAtomSequence", "String.length", "String.charAt", "String.length", "String.length", "String.charAt", "String.length", "String.length", "String.charAt", "String.length", "Logger.info"], "method_name": "BasePairParameters.findPairs", "method_implementation": "{\n    List<Pair<Group>> result = new ArrayList<>();\n    for (int i = 0; i < chains.size(); i++) {\n        Chain c = chains.get(i);\n        for (int j = i + 1; j < chains.size(); j++) {\n            String complement = complement(chains.get(j).getAtomSequence(), useRNA);\n            String match = longestCommonSubstring(c.getAtomSequence(), complement);\n            if (log.isDebugEnabled()) {\n                log.debug(c.getAtomSequence() + \" \" + chains.get(j).getAtomSequence() + \" \" + match);\n            }\n            int index1 = c.getAtomSequence().indexOf(match);\n            int index2 = complement.length() - complement.indexOf(match) - 1;\n            for (int k = 0; k < match.length(); k++) {\n                Group g1 = c.getAtomGroup(index1 + k);\n                Group g2 = chains.get(j).getAtomGroup(index2 - k);\n                Integer type1 = BASE_MAP.get(g1.getPDBName());\n                Integer type2 = BASE_MAP.get(g2.getPDBName());\n                if (type1 == null || type2 == null) {\n                    if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                    continue;\n                }\n                Atom a1 = g1.getAtom(RING_MAP.get(type1).get(0));\n                Atom a2 = g2.getAtom(RING_MAP.get(type2).get(0));\n                if (a1 == null) {\n                    log.info(\"Error processing \" + g1.getPDBName());\n                    if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                    continue;\n                }\n                if (a2 == null) {\n                    log.info(\"Error processing \" + g2.getPDBName());\n                    if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                    continue;\n                }\n                double dx = a1.getX() - a2.getX();\n                double dy = a1.getY() - a2.getY();\n                double dz = a1.getZ() - a2.getZ();\n                double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                //log.info(\"C8-C6 Distance (\u00c5): \" + distance);\n                // could be a base pair\n                if (Math.abs(distance - 10.0) < 4.0) {\n                    boolean valid = true;\n                    for (String atomname : RING_MAP.get(type1)) {\n                        Atom a = g1.getAtom(atomname);\n                        if (a == null)\n                            valid = false;\n                    }\n                    if (valid)\n                        for (String atomname : RING_MAP.get(type2)) {\n                            Atom a = g2.getAtom(atomname);\n                            if (a == null)\n                                valid = false;\n                        }\n                    if (valid) {\n                        result.add(new Pair<Group>(g1, g2));\n                        pairingNames.add((useRNA ? BASE_LIST_RNA[type1] + BASE_LIST_RNA[type2] : BASE_LIST_DNA[type1] + BASE_LIST_DNA[type2]));\n                        pairSequence += c.getAtomSequence().charAt(index1 + k);\n                    } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                    pairSequence += ' ';\n            }\n            if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                pairSequence += ' ';\n        }\n        //log.info();\n    }\n    log.info(\"Matched: \" + pairSequence);\n    return result;\n}", "repo_id": "9", "comment": "/**\n * This method performs a search for base pairs in the structure.  The criteria is alignment of\n * sequences and the canonical base pairs of DNA or RNA. Use MismatchedBasePairParameters\n * or TertiaryBasePairParameters for finding higher-order associations.\n * @param chains The list of chains already found to be nucleic acids\n * @return The list of corresponding Watson-Crick groups as pairs, as a Pair of nucleic acid Groups\n */\n", "repo_name": "biojava-master/", "id": 1737, "method_signature": "List<Pair<Group>> findPairs(List)"}, "3190": {"callee_method_names": [], "method_name": "TestFASTAReader.testProcessAll", "method_implementation": "{\n    testProcessAll(\"org/biojava/nbio/core/fasta/P02768.fasta\");\n}", "repo_id": "9", "comment": "/**\n * Test file contains one sequence (P02768 from swissprot). Read the whole\n * file all at once by calling {@link FastaReader#process()} and verify that\n * one sequence is read.\n *\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3190, "method_signature": "void testProcessAll()"}, "1423": {"callee_method_names": [], "method_name": "UnitCellBoundingBox.getTranslatedBbs", "method_implementation": "{\n    UnitCellBoundingBox translatedBbs = new UnitCellBoundingBox(numOperatorsSg, numPolyChainsAu);\n    for (int i = 0; i < numOperatorsSg; i++) {\n        for (int j = 0; j < numPolyChainsAu; j++) {\n            translatedBbs.chainBbs[i][j] = new BoundingBox(this.chainBbs[i][j]);\n            translatedBbs.chainBbs[i][j].translate(translation);\n        }\n        translatedBbs.auBbs[i] = new BoundingBox(translatedBbs.chainBbs[i]);\n    }\n    return translatedBbs;\n}", "repo_id": "9", "comment": "/**\n * Returns a new BoundingBoxes object containing the same bounds as this\n * BoundingBoxes object translated by the given translation\n * @param translation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1423, "method_signature": "UnitCellBoundingBox getTranslatedBbs(Vector3d)"}, "2544": {"callee_method_names": ["Object.getClass"], "method_name": "Hsp.equals", "method_implementation": "{\n    if (obj == null) {\n        return false;\n    }\n    if (getClass() != obj.getClass()) {\n        return false;\n    }\n    final Hsp<?, ?> other = (Hsp<?, ?>) obj;\n    if ((this.hspQseq == null) ? (other.hspQseq != null) : !this.hspQseq.equals(other.hspQseq)) {\n        return false;\n    }\n    if ((this.hspHseq == null) ? (other.hspHseq != null) : !this.hspHseq.equals(other.hspHseq)) {\n        return false;\n    }\n    if ((this.hspIdentityString == null) ? (other.hspIdentityString != null) : !this.hspIdentityString.equals(other.hspIdentityString)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Experimental.\n * Wants to implement conceptual comparisons of search results.\n * Fields unrelated to search are deliberately not considered.\n *\n * In HSP case, alignment representation strings are considered.\n * @return true if HSP alignments are the same,\n * false otherwise or if alignment strings are undetermined\n */\n", "repo_name": "biojava-master/", "id": 2544, "method_signature": "boolean equals(Object)"}, "3099": {"callee_method_names": [], "method_name": "Qualifier.setValue", "method_implementation": "{\n    this.value = value;\n}", "repo_id": "9", "comment": "/**\n * @param value the value to set\n */\n", "repo_name": "biojava-master/", "id": 3099, "method_signature": "void setValue(String)"}, "820": {"callee_method_names": ["JointFragments.getIdxlist", "List<int[]>.size", "List<int[]>.size", "List<int[]>.size", "List<int[]>.size", "List<int[]>.get"], "method_name": "AlternativeAlignment.apairs_from_idxlst", "method_implementation": "{\n    List<int[]> il = jf.getIdxlist();\n    //System.out.println(\"Alt Alig apairs_from_idxlst\");\n    aligpath = new IndexPair[il.size()];\n    idx1 = new int[il.size()];\n    idx2 = new int[il.size()];\n    for (int i = 0; i < il.size(); i++) {\n        int[] p = il.get(i);\n        //System.out.print(\" idx1 \" + p[0] + \" idx2 \" + p[1]);\n        idx1[i] = p[0];\n        idx2[i] = p[1];\n        aligpath[i] = new IndexPair((short) p[0], (short) p[1]);\n    }\n    eqr0 = idx1.length;\n    //System.out.println(\"eqr \" + eqr0);\n    gaps0 = count_gaps(idx1, idx2);\n}", "repo_id": "9", "comment": "/**\n * Set apairs according to a list of (i,j) tuples.\n *\n * @param jf a JoingFragment\n */\n", "repo_name": "biojava-master/", "id": 820, "method_signature": "void apairs_from_idxlst(JointFragments)"}, "1913": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.getLocalTimeStart", "method_implementation": "{\n    return localTimeStart;\n}", "repo_id": "9", "comment": "/**\n * @return the localTimeStart\n */\n", "repo_name": "biojava-master/", "id": 1913, "method_signature": "double getLocalTimeStart()"}, "1629": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setTMThreshold", "method_implementation": "{\n    this.tmThreshold = tmThreshold;\n}", "repo_id": "9", "comment": "/**\n * Structure similarity threshold (measured with TMScore) to consider for the\n * structural subunit clustering.\n *\n * @param tmThreshold\n */\n", "repo_name": "biojava-master/", "id": 1629, "method_signature": "void setTMThreshold(double)"}, "3146": {"callee_method_names": ["Document.getDocumentElement", "Element.getAttribute", "Element.getAttribute", "Map<String, List<DBReferenceInfo>>.get", "Map<String, List<DBReferenceInfo>>.put", "DBReferenceInfo.addProperty", "List<DBReferenceInfo>.add", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "UniprotProxySequenceReader.getDatabaseReferences", "method_implementation": "{\n    Map<String, List<DBReferenceInfo>> databaseReferencesHashMap = new LinkedHashMap<>();\n    if (uniprotDoc == null) {\n        return databaseReferencesHashMap;\n    }\n    try {\n        Element uniprotElement = uniprotDoc.getDocumentElement();\n        Element entryElement = XMLHelper.selectSingleElement(uniprotElement, \"entry\");\n        ArrayList<Element> dbreferenceElementList = XMLHelper.selectElements(entryElement, \"dbReference\");\n        for (Element element : dbreferenceElementList) {\n            String type = element.getAttribute(\"type\");\n            String id = element.getAttribute(\"id\");\n            List<DBReferenceInfo> idlist = databaseReferencesHashMap.get(type);\n            if (idlist == null) {\n                idlist = new ArrayList<DBReferenceInfo>();\n                databaseReferencesHashMap.put(type, idlist);\n            }\n            DBReferenceInfo dbreferenceInfo = new DBReferenceInfo(type, id);\n            ArrayList<Element> propertyElementList = XMLHelper.selectElements(element, \"property\");\n            for (Element propertyElement : propertyElementList) {\n                String propertyType = propertyElement.getAttribute(\"type\");\n                String propertyValue = propertyElement.getAttribute(\"value\");\n                dbreferenceInfo.addProperty(propertyType, propertyValue);\n            }\n            idlist.add(dbreferenceInfo);\n        }\n    } catch (XPathExpressionException e) {\n        logger.error(\"Problems while parsing db references in UniProt XML: {}. No db references will be available.\", e.getMessage());\n        return new LinkedHashMap<>();\n    }\n    return databaseReferencesHashMap;\n}", "repo_id": "9", "comment": "/**\n * The Uniprot mappings to other database identifiers for this sequence\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3146, "method_signature": "Map<String,List<DBReferenceInfo>> getDatabaseReferences()"}, "1964": {"callee_method_names": [], "method_name": "HelixAxisAligner.getRotationReferenceAxis", "method_implementation": "{\n    run();\n    return referenceVector;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getRotationReferenceAxis()\n\t */\n", "repo_name": "biojava-master/", "id": 1964, "method_signature": "Vector3d getRotationReferenceAxis()"}, "2996": {"callee_method_names": [], "method_name": "BitSequenceReader.getCompoundAt", "method_implementation": "{\n    //Avoids asking for something which is not encoded by a bit-pair\n    if (position > getLength()) {\n        throw new IllegalArgumentException(position + \" is greater than length. Cannot access this position\");\n    }\n    //Just stops us from using 0 indexing\n    if (position < 1) {\n        throw new IllegalArgumentException(position + \" is less than 1; you must use biological indexing (indexing from 1)\");\n    }\n    int arrayIndex = biologicalIndexToArrayIndex(position);\n    int currentByte = sequence[arrayIndex];\n    int shiftBy = shiftBy(position);\n    int shifted = currentByte >>> shiftBy;\n    int masked = shifted & bitMask();\n    //If we could encode 4 compounds then our max masked value is 3\n    if (masked > (compoundsPerDatatype() - 1)) {\n        throw new IllegalStateException(\"Got a masked value of \" + masked + \"; do not understand values greater than \" + (compoundsPerDatatype() - 1));\n    }\n    return getIndexToCompoundsLookup().get(masked);\n}", "repo_id": "9", "comment": "/**\n * Returns the compound at the specified biological index\n */\n", "repo_name": "biojava-master/", "id": 2996, "method_signature": "C getCompoundAt(int)"}, "1561": {"callee_method_names": [], "method_name": "ScopDomain.setPdbId", "method_implementation": "{\n    this.pdbId = pdbId;\n}", "repo_id": "9", "comment": "/**\n * @param pdbId\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 1561, "method_signature": "void setPdbId(PdbId)"}, "719": {"callee_method_names": [], "method_name": "CECalculator.dpAlign", "method_implementation": "{\n    // isGlobal1,isGlobal2 are always false...\n    int i, j, is, js, iMax, jMax, k;\n    boolean ge = (gapE != 0.0 ? true : false);\n    double sum, sum_ret, sum_brk;\n    boolean[][] brk_flg = new boolean[nSeq1][nSeq2];\n    for (i = 0; i < nSeq1; i++) brk_flg[i] = new boolean[nSeq2];\n    brk_flg = notifyBreakFlagListener(brk_flg);\n    // ge = true here...\n    /*\n\t\t  for(i=0; i<nSeq1; i++)\n\t\t   {\n\t\t     printf(\"\\n\");\n\t\t     for(j=0; j<nSeq2; j++)\n\t\t       {\n\t\t\t printf(\"%4d\", (int)(*(mat[i]+j)*10));\n\t\t       }\n\t\t   }\n\t\t printf(\"\\n\\n\\n\");\n\t\t */\n    if (!ge) {\n        for (i = nSeq1 - 1; i >= 0; i--) for (j = nSeq2 - 1; j >= 0; j--) {\n            brk_flg[i][j] = false;\n            if (j < nSeq2 - 1 && i < nSeq1 - 1) {\n                sum = mat[i + 1][j + 1];\n            } else {\n                sum = 0.0;\n                if ((isGlobal1 && i != nSeq1 - 1) || (isGlobal2 && j != nSeq2 - 1))\n                    sum = -gapI;\n            }\n            if (j + 1 < nSeq2)\n                for (k = i + 2; k < nSeq1; k++) {\n                    if (mat[k][j + 1] - gapI > sum)\n                        sum = mat[k][j + 1] - gapI;\n                }\n            if (i + 1 < nSeq1)\n                for (k = j + 2; k < nSeq2; k++) {\n                    if (mat[i + 1][k] - gapI > sum)\n                        sum = mat[i + 1][k] - gapI;\n                }\n            sum += mat[i][j];\n            sum_brk = (isGlobal1 ? -gapI : 0.0) + (isGlobal2 ? -gapI : 0.0);\n            if (sum < sum_brk) {\n                sum = sum_brk;\n                brk_flg[i][j] = true;\n                //System.out.println(\"break at: \" + i + \" \" + j);\n            }\n            mat[i][j] = sum;\n        }\n    } else {\n        for (i = nSeq1 - 1; i >= 0; i--) for (j = nSeq2 - 1; j >= 0; j--) {\n            brk_flg[i][j] = false;\n            if (j < nSeq2 - 1 && i < nSeq1 - 1) {\n                sum = mat[i + 1][j + 1];\n            } else {\n                sum = 0.0;\n                if (isGlobal1 && i != nSeq1 - 1)\n                    sum = -gapI - gapE * (nSeq1 - i - 1);\n                if (isGlobal2 && j != nSeq2 - 1)\n                    sum = -gapI - gapE * (nSeq2 - j - 1);\n            }\n            if (j + 1 < nSeq2)\n                for (k = i + 2; k < nSeq1; k++) if (mat[k][j + 1] - gapI - gapE * (k - i - 1) > sum)\n                    sum = mat[k][j + 1] - gapI - gapE * (k - i - 1);\n            if (i + 1 < nSeq1)\n                for (k = j + 2; k < nSeq2; k++) if (mat[i + 1][k] - gapI - gapE * (k - j - 1) > sum)\n                    sum = mat[i + 1][k] - gapI - gapE * (k - j - 1);\n            sum += mat[i][j];\n            sum_brk = (isGlobal1 ? (-gapI - gapE * (nSeq1 - 1 - i)) : 0.0) + (isGlobal2 ? (-gapI - gapE * (nSeq2 - 1 - j)) : 0.0);\n            if (sum < sum_brk) {\n                sum = sum_brk;\n                brk_flg[i][j] = true;\n            }\n            mat[i][j] = sum;\n        }\n    }\n    //\t\tif (debug ){\n    //\t\t\tScaleableMatrixPanel smp = new ScaleableMatrixPanel();\n    //\t\t\tJFrame frame = new JFrame(\"CE alignment matrix in dpAlign \" );\n    //\t\t\tframe.addWindowListener(new WindowAdapter(){\n    //\t\t\t\tpublic void windowClosing(WindowEvent e){\n    //\t\t\t\t\tJFrame f = (JFrame) e.getSource();\n    //\t\t\t\t\tf.setVisible(false);\n    //\t\t\t\t\tf.dispose();\n    //\t\t\t\t}\n    //\n    //\t\t\t});\n    //\n    //\t\t\tsmp.getMatrixPanel().setScalevalue(100);\n    //\t\t\tMatrix mx = (Matrix) new Matrix(mat).clone();\n    //\t\t\tsmp.setMatrix(mx);\n    //\n    //\t\t\tframe.getContentPane().add(smp);\n    //\n    //\t\t\tframe.pack();\n    //\t\t\tframe.setVisible(true);\n    //\t\t}\n    /*\n\t\t for(i=0; i<nSeq1; i++)\n\t\t   {\n\t\t     printf(\"\\n\");\n\t\t     for(j=0; j<nSeq2; j++)\n\t\t       {\n\t\t\t printf(\"%4d\", (int)(*(mat[i]+j)*10));\n\t\t       }\n\t\t   }\n\t\t printf(\"\\n\\n\\n\");\n\t\t for(i=0; i<nSeq1; i++)\n\t\t   {\n\t\t     printf(\"\\n\");\n\t\t     for(j=0; j<nSeq2; j++)\n\t\t       {\n\t\t\t printf(\"%4d\", (int)(*(brk_flg[i]+j)));\n\t\t       }\n\t\t   }\n\t\t // exit(0);\n\t\t */\n    is = 0;\n    js = 0;\n    lcmp = 0;\n    // no nc-end penalty - begin\n    sum_ret = mat[0][0];\n    // look for the highest score in mat[i][j]\n    for (i = 0; i < nSeq1; i++) for (j = 0; j < nSeq2; j++) {\n        if (i == 0 && j == 0)\n            continue;\n        sum = mat[i][j];\n        if (isGlobal1)\n            sum += -gapI - gapE * i;\n        if (isGlobal2)\n            sum += -gapI - gapE * j;\n        if (sum > sum_ret) {\n            sum_ret = sum;\n            is = i;\n            js = j;\n        }\n    }\n    //System.out.println(\"start at \" + is + \"  \" + js);\n    //for(k=0; k<is; k++) align1[k]=-1;\n    //for(k=0; k<js; k++) align2[k]=-1;\n    // no nc-end penalty - end\n    for (i = is, j = js; i < nSeq1 && j < nSeq2; i++, j++) {\n        iMax = i;\n        jMax = j;\n        sum = mat[i][j];\n        if (!ge) {\n            for (k = i + 1; k < nSeq1; k++) if (mat[k][j] - gapI > sum) {\n                iMax = k;\n                jMax = j;\n                sum = mat[k][j] - gapI;\n            }\n            for (k = j + 1; k < nSeq2; k++) if (mat[i][k] - gapI > sum) {\n                iMax = i;\n                jMax = k;\n                sum = mat[i][k] - gapI;\n            }\n        } else {\n            for (k = i + 1; k < nSeq1; k++) if (mat[k][j] - gapI - gapE * (k - i) > sum) {\n                //System.out.println(\"gap1 \" + k + \" \" + j + \" \" + sum + \"<\" +(mat[k][j]-gapI-gapE*(k-i)));\n                iMax = k;\n                jMax = j;\n                sum = mat[k][j] - gapI - gapE * (k - i);\n            }\n            for (k = j + 1; k < nSeq2; k++) if (mat[i][k] - gapI - gapE * (k - j) > sum) {\n                //System.out.println(\"gap2 \" + i + \" \" + k + \" \" + sum + \"<\"+ (mat[i][k]-gapI-gapE*(k-j)));\n                iMax = i;\n                jMax = k;\n                sum = mat[i][k] - gapI - gapE * (k - j);\n            }\n        }\n        //if ( i != iMax || j != jMax )\n        //\tSystem.out.println(\"FOUND GAP AT: \" + i+ \" \" + iMax + \" \" + j + \" \" + jMax);\n        //System.out.println(\" iMax \" + iMax + \" jMax \" +  jMax);\n        // set the gap positions:\n        //printf(\"%d %d\\n\", iMax, jMax);\n        for (k = i; k < iMax; k++, i++) {\n            align_se1[lcmp] = k;\n            align_se2[lcmp] = -1;\n            lcmp++;\n        }\n        for (k = j; k < jMax; k++, j++) {\n            align_se1[lcmp] = -1;\n            align_se2[lcmp] = k;\n            lcmp++;\n        }\n        align_se1[lcmp] = iMax;\n        align_se2[lcmp] = jMax;\n        lcmp++;\n        if (brk_flg[i][j]) {\n            //System.out.println(\"hit break flag at: \" + i + \"  \" + j + \" sum \" + sum_ret + \" lcmp \" + lcmp);\n            break;\n        }\n    }\n    return sum_ret;\n}", "repo_id": "9", "comment": "/**\n * On input, mat[i][j] should give the score for aligning positions i and j.\n * On output, mat[i][j] gives the maximum score possible for aligning 1..i\n * of protein 1 with 1..j of protein 2.\n *\n * @param nSeq1 The length of protein 1 (mat.length)\n * @param nSeq2 The length of protein 2 (mat[0].length)\n * @param gapI gap initiation penalty\n * @param gapE gap extension penalty\n * @param isGlobal1 The alignment is global for protein 1\n * @param isGlobal2 The alignment is global for protein 2\n * @return The maximum score\n */\n", "repo_name": "biojava-master/", "id": 719, "method_signature": "double dpAlign(int, int, double, double, boolean, boolean)"}, "1287": {"callee_method_names": ["Map<Integer,BioAssemblyInfo>.entrySet", "SiftsChainEntry.getValue", "Map<double[], int[]>.entrySet", "StructureAdapterInterface.setBioAssemblyTrans", "SiftsChainEntry.getKey"], "method_name": "MmtfStructureWriter.storeBioassemblyInformation", "method_implementation": "{\n    int bioAssemblyIndex = 0;\n    for (Entry<Integer, BioAssemblyInfo> entry : inputBioAss.entrySet()) {\n        Map<double[], int[]> transformMap = MmtfUtils.getTransformMap(entry.getValue(), chainIdToIndexMap);\n        for (Entry<double[], int[]> transformEntry : transformMap.entrySet()) {\n            mmtfDecoderInterface.setBioAssemblyTrans(bioAssemblyIndex, transformEntry.getValue(), transformEntry.getKey(), entry.getKey().toString());\n        }\n        bioAssemblyIndex++;\n    }\n}", "repo_id": "9", "comment": "/**\n * Generate the bioassembly information on in the desired form.\n */\n", "repo_name": "biojava-master/", "id": 1287, "method_signature": "void storeBioassemblyInformation(Map, Map)"}, "3149": {"callee_method_names": ["String.length", "CompoundSet<C>.getMaxSingleCompoundStringLength", "String.substring", "CompoundSet<C>.getCompoundForString", "String.length"], "method_name": "SequenceFileProxyLoader.setContents", "method_implementation": "{\n    // Horrendously inefficient - pretty much the way the old BJ did things.\n    // TODO Should be optimised.\n    this.parsedCompounds.clear();\n    for (int i = 0; i < sequence.length(); ) {\n        String compoundStr = null;\n        C compound = null;\n        for (int compoundStrLength = 1; compound == null && compoundStrLength <= compoundSet.getMaxSingleCompoundStringLength(); compoundStrLength++) {\n            compoundStr = sequence.substring(i, i + compoundStrLength);\n            compound = compoundSet.getCompoundForString(compoundStr);\n        }\n        if (compound == null) {\n            throw new CompoundNotFoundException(\"Compound \" + compoundStr + \" not found\");\n        } else {\n            i += compoundStr.length();\n        }\n        this.parsedCompounds.add(compound);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param sequence\n */\n", "repo_name": "biojava-master/", "id": 3149, "method_signature": "void setContents(String)"}, "3551": {"callee_method_names": [], "method_name": "CoxCoefficient.setStandardDeviation", "method_implementation": "{\n    this.standardDeviation = standardDeviation;\n}", "repo_id": "9", "comment": "/**\n * @param standardDeviation the standardDeviation to set\n */\n", "repo_name": "biojava-master/", "id": 3551, "method_signature": "void setStandardDeviation(double)"}, "3459": {"callee_method_names": [], "method_name": "NCBIQBlastOutputProperties.setDescriptionNumber", "method_implementation": "{\n    setOutputOption(DESCRIPTIONS, Integer.toString(number));\n}", "repo_id": "9", "comment": "/**\n * Sets the number of descriptions to fetch\n *\n * @param number : an int with the required number of descriptions to fetch\n */\n", "repo_name": "biojava-master/", "id": 3459, "method_signature": "void setDescriptionNumber(int)"}, "652": {"callee_method_names": [], "method_name": "AbstractScoresCache.clear", "method_implementation": "{\n    scores = null;\n}", "repo_id": "9", "comment": "/**\n * Clear the cached scores. This frees memory after the alignment changed.\n */\n", "repo_name": "biojava-master/", "id": 652, "method_signature": "void clear()"}, "301": {"callee_method_names": ["Set<StructureAtomLinkage>.addAll", "ModifiedCompound.getAtomLinkages", "List<Group>.size", "List<Group>.get", "List<Group>.get", "Set<StructureAtomLinkage>.add", "List<Group>.size", "List<Group>.get", "List<Group>.get", "Group.equals", "Set<StructureAtomLinkage>.add"], "method_name": "ProteinModificationIdentifier.recordUnidentifiableAtomLinkages", "method_implementation": "{\n    // first put identified linkages in a map for fast query\n    Set<StructureAtomLinkage> identifiedLinkages = new HashSet<StructureAtomLinkage>();\n    for (ModifiedCompound mc : modComps) {\n        identifiedLinkages.addAll(mc.getAtomLinkages());\n    }\n    // record\n    // cross link\n    int nRes = residues.size();\n    for (int i = 0; i < nRes - 1; i++) {\n        Group group1 = residues.get(i);\n        for (int j = i + 1; j < nRes; j++) {\n            Group group2 = residues.get(j);\n            List<Atom[]> linkages = StructureUtil.findAtomLinkages(group1, group2, true, bondLengthTolerance);\n            for (Atom[] atoms : linkages) {\n                StructureAtomLinkage link = StructureUtil.getStructureAtomLinkage(atoms[0], true, atoms[1], true);\n                unidentifiableAtomLinkages.add(link);\n            }\n        }\n    }\n    // attachment\n    int nLig = ligands.size();\n    for (int i = 0; i < nRes; i++) {\n        Group group1 = residues.get(i);\n        for (int j = 0; j < nLig; j++) {\n            Group group2 = ligands.get(j);\n            if (group1.equals(group2)) {\n                // overlap between residues and ligands\n                continue;\n            }\n            List<Atom[]> linkages = StructureUtil.findAtomLinkages(group1, group2, false, bondLengthTolerance);\n            for (Atom[] atoms : linkages) {\n                StructureAtomLinkage link = StructureUtil.getStructureAtomLinkage(atoms[0], true, atoms[1], false);\n                unidentifiableAtomLinkages.add(link);\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Record unidentifiable atom linkages in a chain. Only linkages between two\n * residues or one residue and one ligand will be recorded.\n */\n", "repo_name": "biojava-master/", "id": 301, "method_signature": "void recordUnidentifiableAtomLinkages(List, List)"}, "1372": {"callee_method_names": [], "method_name": "DBRef.getIdCode", "method_implementation": "{\n    return idCode;\n}", "repo_id": "9", "comment": "/**\n * get the idCode for this entry\n *\n * @return the idCode\n * @see #setIdCode(String)\n */\n", "repo_name": "biojava-master/", "id": 1372, "method_signature": "String getIdCode()"}, "3875": {"callee_method_names": ["String.length", "String.length", "String.toCharArray"], "method_name": "PeptideProperties.getChargesOfAminoAcids", "method_implementation": "{\n    int[] charges = new int[sequence.length()];\n    for (int i = 0; i < sequence.length(); i++) {\n        char aa = sequence.toCharArray()[i];\n        charges[i] = AminoAcidProperties.getChargeOfAminoAcid(aa);\n    }\n    return charges;\n}", "repo_id": "9", "comment": "/**\n * Returns the array of charges of each amino acid in a protein. At pH=7, two are negative charged: aspartic acid (Asp, D) and glutamic acid (Glu, E) (acidic side chains),\n * and three are positive charged: lysine (Lys, K), arginine (Arg, R) and histidine (His, H) (basic side chains).\n *\n * @param sequence\n * \t\ta protein sequence consisting of non-ambiguous characters only\n * @return the array of charges of amino acids in the protein (1 if amino acid is positively charged, -1 if negatively charged, 0 if not charged)\n */\n", "repo_name": "biojava-master/", "id": 3875, "method_signature": "int[] getChargesOfAminoAcids(String)"}, "1790": {"callee_method_names": [], "method_name": "EcodDomain.getPdbId", "method_implementation": "{\n    return pdbId;\n}", "repo_id": "9", "comment": "/**\n * Gets the {@link PdbId} object.<br>\n * Before 6.0.0, this method used to return a {@link String}.\n * @return the {@link PdbId} object associated with this domain.\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 1790, "method_signature": "PdbId getPdbId()"}, "1599": {"callee_method_names": ["SecStrucGroup.getN", "SecStrucGroup.getH", "SecStrucGroup.getO", "SecStrucGroup.getC", "Logger.debug", "SecStrucGroup.getResidueNumber", "SecStrucGroup.getPDBName", "SecStrucGroup.getResidueNumber", "SecStrucGroup.getPDBName", "Atom.getPDBserial", "Atom.getPDBserial", "Logger.debug", "Atom.getPDBserial", "Atom.getPDBserial"], "method_name": "SecStrucCalc.calculateHBondEnergy", "method_implementation": "{\n    Atom N = one.getN();\n    Atom H = one.getH();\n    Atom O = two.getO();\n    Atom C = two.getC();\n    double dno = Calc.getDistance(O, N);\n    double dhc = Calc.getDistance(C, H);\n    double dho = Calc.getDistance(O, H);\n    double dnc = Calc.getDistance(C, N);\n    logger.debug(\" cccc: {} {} {} {} O ({})..N ({}):{}  |  ho:{} - hc:{} + nc:{} - no:{}\", one.getResidueNumber(), one.getPDBName(), two.getResidueNumber(), two.getPDBName(), O.getPDBserial(), N.getPDBserial(), dno, dho, dhc, dnc, dno);\n    //there seems to be a contact!\n    if ((dno < MINDIST) || (dhc < MINDIST) || (dnc < MINDIST) || (dno < MINDIST)) {\n        return HBONDLOWENERGY;\n    }\n    double e1 = Q / dho - Q / dhc;\n    double e2 = Q / dnc - Q / dno;\n    double energy = e1 + e2;\n    logger.debug(\" N ({}) O({}): {} : {} \", N.getPDBserial(), O.getPDBserial(), (float) dno, energy);\n    //Avoid too strong energy\n    if (energy > HBONDLOWENERGY)\n        return energy;\n    return HBONDLOWENERGY;\n}", "repo_id": "9", "comment": "/**\n * Calculate HBond energy of two groups in cal/mol\n * see Creighton page 147 f\n * <p>\n * Jeffrey, George A., An introduction to hydrogen bonding,\n * Oxford University Press, 1997.\n * categorizes hbonds with donor-acceptor distances of\n * 2.2-2.5 &aring; as \"strong, mostly covalent\",\n * 2.5-3.2 &aring; as \"moderate, mostly electrostatic\",\n * 3.2-4.0 &aring; as \"weak, electrostatic\".\n * Energies are given as 40-14, 15-4, and <4 kcal/mol respectively.\n */\n", "repo_name": "biojava-master/", "id": 1599, "method_signature": "double calculateHBondEnergy(SecStrucGroup, SecStrucGroup)"}, "3619": {"callee_method_ids": [3543, 3544, 3545, 3531, 3532, 3549, 3531, 3532, 3547, 3531, 3532, 3548, 3531, 3532], "callee_method_names": ["LinkedHashMap.keySet", "ArrayList<String>.size", "ArrayList<String>.get", "LinkedHashMap.get", "CoxCoefficient.setStdError", "CoxCoefficient.setRobustStdError", "CoxCoefficient.setZ", "CoxCoefficient.getCoeff", "CoxCoefficient.getStdError", "CoxCoefficient.setPvalue", "CoxCoefficient.getCoeff", "CoxCoefficient.getStdError", "CoxCoefficient.setHazardRatioLoCI", "CoxCoefficient.getCoeff", "CoxCoefficient.getStdError", "CoxCoefficient.setHazardRatioHiCI", "CoxCoefficient.getCoeff", "CoxCoefficient.getStdError"], "method_name": "CoxInfo.calcSummaryValues", "method_implementation": "{\n    //beta\n    ArrayList<String> variables = new ArrayList<String>(coefficientsList.keySet());\n    for (int i = 0; i < variables.size(); i++) {\n        String variable = variables.get(i);\n        CoxCoefficient coe = coefficientsList.get(variable);\n        //values can be updated to reflect new error\n        coe.setStdError(Math.sqrt(imat[i][i]));\n        if (naive_imat != null) {\n            coe.setRobustStdError(Math.sqrt(naive_imat[i][i]));\n        }\n        coe.setZ(coe.getCoeff() / coe.getStdError());\n        coe.setPvalue(ChiSq.norm(Math.abs(coe.getCoeff() / coe.getStdError())));\n        //z <- qnorm((1 + conf.int)/2, 0, 1)\n        double z = 1.959964;\n        coe.setHazardRatioLoCI(Math.exp(coe.getCoeff() - z * coe.getStdError()));\n        coe.setHazardRatioHiCI(Math.exp(coe.getCoeff() + z * coe.getStdError()));\n    }\n    logTest = -2 * (loglikInit - loglikFinal);\n    logTestpval = ChiSq.chiSq(logTest, (int) degreeFreedom);\n    scoreLogrankTestpvalue = ChiSq.chiSq(scoreLogrankTest, (int) degreeFreedom);\n    if (rscore != null) {\n        rscoreLogrankTestpvalue = ChiSq.chiSq(rscore, (int) degreeFreedom);\n    }\n}", "repo_id": "9", "comment": "/**\n */\n", "repo_name": "biojava-master/", "id": 3619, "method_signature": "void calcSummaryValues()"}, "2078": {"callee_method_names": ["Matrix.get", "Matrix.get", "Random.nextDouble", "Matrix.get", "List<List<Integer>>.get", "List<Integer>.add", "List<List<Integer>>.get"], "method_name": "SymmOptimizer.insertGap", "method_implementation": "{\n    // Let gaps only if the repeat is larger than the minimum length\n    if (repeatCore <= Lmin)\n        return false;\n    // Select residue by maximum distance\n    updateMultipleAlignment();\n    Matrix residueDistances = MultipleAlignmentTools.getAverageResidueDistances(msa);\n    double maxDist = Double.MIN_VALUE;\n    int su = 0;\n    int res = 0;\n    for (int col = 0; col < length; col++) {\n        for (int s = 0; s < order; s++) {\n            if (residueDistances.get(s, col) != -1) {\n                if (residueDistances.get(s, col) > maxDist) {\n                    // geometric distribution\n                    if (rnd.nextDouble() > 0.5) {\n                        su = s;\n                        res = col;\n                        maxDist = residueDistances.get(s, col);\n                    }\n                }\n            }\n        }\n    }\n    // Insert the gap at the position\n    Integer residueL = block.get(su).get(res);\n    if (residueL != null) {\n        freePool.add(residueL);\n        Collections.sort(freePool);\n    } else\n        // If there was a gap already in the position.\n        return false;\n    block.get(su).set(res, null);\n    checkGaps();\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Insert a gap in one of the repeats into selected position (by higher\n * distances) in the alignment. Calculates the average residue distance to\n * make the choice. A gap is a null in the block.\n *\n * @throws StructureException\n * @throws RefinerFailedException\n */\n", "repo_name": "biojava-master/", "id": 2078, "method_signature": "boolean insertGap()"}, "3473": {"callee_method_names": [], "method_name": "NCBIQBlastService.getTool", "method_implementation": "{\n    return this.tool;\n}", "repo_id": "9", "comment": "/**\n * Get the tool identifier for QBlast. Defaults to {@value #DEFAULT_TOOL}\n *\n * @return the identifier\n */\n", "repo_name": "biojava-master/", "id": 3473, "method_signature": "String getTool()"}, "2753": {"callee_method_names": [], "method_name": "EmblRecord.getSequence", "method_implementation": "{\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * The Sequence Data Line\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2753, "method_signature": "String getSequence()"}, "3090": {"callee_method_names": [], "method_name": "AbstractFeature.getShortDescription", "method_implementation": "{\n    return shortDescription;\n}", "repo_id": "9", "comment": "/**\n * @return the shortDescription\n */\n", "repo_name": "biojava-master/", "id": 3090, "method_signature": "String getShortDescription()"}, "152": {"callee_method_ids": [619, 619, 773, 490, 489, 487, 490, 489, 487, 490, 489, 487], "callee_method_names": ["Method.setAccessible", "CeCPMain.getParameters", "CECPParameters.setDuplicationHint", "AtomCache.getAtoms", "AtomCache.getAtoms", "Method.setAccessible", "Method.invoke", "CeCPMain.align", "AFPChain.getOptLen", "AFPChain.getOptAln", "AFPChain.getOptLength", "AFPChain.getBlockNum", "Method.invoke", "AFPChain.getOptLen", "AFPChain.getOptAln", "AFPChain.getOptLength", "AFPChain.getBlockNum", "Method.invoke", "AFPChain.getOptLen", "AFPChain.getOptAln", "AFPChain.getOptLength", "AFPChain.getBlockNum"], "method_name": "OptimalCECPMainTest.testPermuteOptAln", "method_implementation": "{\n    //test private member using reflection\n    Method permuteOptAln = OptimalCECPMain.class.getDeclaredMethod(\"permuteOptAln\", AFPChain.class, int.class);\n    permuteOptAln.setAccessible(true);\n    // Two structures with nearly 100% sequence identity\n    /*\n\t\t * Aligned (0-based index):\n\t\t * \t3LB9.A\t1HV1\n\t\t * \t------\t----\n\t\t * \t0-62\t122-184\n\t\t * \t63\t\t0\n\t\t * \t65-181\t1-117\n\t\t *\n\t\t * unaligned:\n\t\t * \t64\t\t-\n\t\t * \t-\t\t118-121\n\t\t *\n\t\t * PDB numbering:\n\t\t * \t+2\t\t+1\n\t\t *\n\t\t */\n    String name1, name2;\n    name1 = \"3LB9.A\";\n    name2 = \"1HV1\";\n    CeCPMain ce = (CeCPMain) StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n    CECPParameters param = (CECPParameters) ce.getParameters();\n    param.setDuplicationHint(DuplicationHint.RIGHT);\n    Atom[] ca1 = cache.getAtoms(name1);\n    Atom[] ca2 = cache.getAtoms(name2);\n    // Create permuted CA chain\n    Method permuteArray = OptimalCECPMain.class.getDeclaredMethod(\"permuteArray\", Object[].class, int.class);\n    permuteArray.setAccessible(true);\n    Atom[] ca2p = StructureTools.cloneAtomArray(ca2);\n    permuteArray.invoke(null, ca2p, 63);\n    AFPChain cpAlignment = ce.align(ca1, ca2);\n    //System.out.println(cpAlignment.toCE(ca1, ca2));\n    //printOptAln(cpAlignment);\n    Assert.assertNotNull(cpAlignment);\n    int[] optLen = cpAlignment.getOptLen();\n    int[][][] optAln = cpAlignment.getOptAln();\n    Assert.assertEquals(\"Wrong total length\", 181, cpAlignment.getOptLength());\n    Assert.assertEquals(\"Wrong number of blocks\", 2, cpAlignment.getBlockNum());\n    Assert.assertEquals(\"Wrong block 0 length\", 63, optLen[0]);\n    Assert.assertEquals(\"Wrong block 1 length\", 118, optLen[1]);\n    //just test some key positions in each block\n    Assert.assertEquals(\"Wrong residue at start of block 0, protein 0\", 0, optAln[0][0][0]);\n    Assert.assertEquals(\"Wrong residue at start of block 0, protein 1\", 122, optAln[0][1][0]);\n    Assert.assertEquals(\"Wrong residue at end of block 0, protein 0\", 62, optAln[0][0][62]);\n    Assert.assertEquals(\"Wrong residue at end of block 0, protein 1\", 184, optAln[0][1][62]);\n    Assert.assertEquals(\"Wrong residue at start of block 1, protein 0\", 63, optAln[1][0][0]);\n    Assert.assertEquals(\"Wrong residue at start of block 1, protein 1\", 0, optAln[1][1][0]);\n    Assert.assertEquals(\"Wrong residue at pos 1 of block 1, protein 0\", 65, optAln[1][0][1]);\n    Assert.assertEquals(\"Wrong residue at pos 1 of block 1, protein 1\", 1, optAln[1][1][1]);\n    Assert.assertEquals(\"Wrong residue at pos 54 of block 1, protein 0\", 118, optAln[1][0][54]);\n    Assert.assertEquals(\"Wrong residue at pos 54 of block 1, protein 1\", 54, optAln[1][1][54]);\n    Assert.assertEquals(\"Wrong residue at pos 55 of block 1, protein 0\", 119, optAln[1][0][55]);\n    Assert.assertEquals(\"Wrong residue at pos 55 of block 1, protein 1\", 55, optAln[1][1][55]);\n    Assert.assertEquals(\"Wrong residue at end of block 1, protein 0\", 181, optAln[1][0][117]);\n    Assert.assertEquals(\"Wrong residue at end of block 1, protein 1\", 117, optAln[1][1][117]);\n    // permute! should align at 0,0\n    //System.out.println(\"Permuting by 63 residues...\");\n    permuteOptAln.invoke(null, cpAlignment, 63);\n    //System.out.println(cpAlignment.toCE(ca1, ca2p));\n    //printOptAln(cpAlignment);\n    optLen = cpAlignment.getOptLen();\n    optAln = cpAlignment.getOptAln();\n    Assert.assertEquals(\"Wrong total length\", 181, cpAlignment.getOptLength());\n    Assert.assertEquals(\"Wrong number of blocks\", 2, cpAlignment.getBlockNum());\n    Assert.assertEquals(\"Wrong block 0 length\", 63, optLen[0]);\n    Assert.assertEquals(\"Wrong block 1 length\", 118, optLen[1]);\n    //just test some key positions in each block\n    Assert.assertEquals(\"Wrong residue at start of block 0, protein 0\", 0, optAln[0][0][0]);\n    Assert.assertEquals(\"Wrong residue at start of block 0, protein 1\", 0, optAln[0][1][0]);\n    Assert.assertEquals(\"Wrong residue at end of block 0, protein 0\", 62, optAln[0][0][62]);\n    Assert.assertEquals(\"Wrong residue at end of block 0, protein 1\", 62, optAln[0][1][62]);\n    Assert.assertEquals(\"Wrong residue at start of block 1, protein 0\", 63, optAln[1][0][0]);\n    Assert.assertEquals(\"Wrong residue at start of block 1, protein 1\", 63, optAln[1][1][0]);\n    Assert.assertEquals(\"Wrong residue at pos 1 of block 1, protein 0\", 65, optAln[1][0][1]);\n    Assert.assertEquals(\"Wrong residue at pos 1 of block 1, protein 1\", 64, optAln[1][1][1]);\n    Assert.assertEquals(\"Wrong residue at end of block 1, protein 0\", 181, optAln[1][0][117]);\n    Assert.assertEquals(\"Wrong residue at end of block 1, protein 1\", 180, optAln[1][1][117]);\n    // undo permutation\n    //System.out.println(\"Permuting by -63 residues...\");\n    permuteOptAln.invoke(null, cpAlignment, -63);\n    //System.out.println(cpAlignment.toCE(ca1, ca2));\n    //printOptAln(cpAlignment);\n    optLen = cpAlignment.getOptLen();\n    optAln = cpAlignment.getOptAln();\n    Assert.assertEquals(\"Wrong total length\", 181, cpAlignment.getOptLength());\n    Assert.assertEquals(\"Wrong number of blocks\", 2, cpAlignment.getBlockNum());\n    Assert.assertEquals(\"Wrong block 0 length\", 63, optLen[0]);\n    Assert.assertEquals(\"Wrong block 1 length\", 118, optLen[1]);\n    //just test some key positions in each block\n    Assert.assertEquals(\"Wrong residue at start of block 0, protein 0\", 0, optAln[0][0][0]);\n    Assert.assertEquals(\"Wrong residue at start of block 0, protein 1\", 122, optAln[0][1][0]);\n    Assert.assertEquals(\"Wrong residue at end of block 0, protein 0\", 62, optAln[0][0][62]);\n    Assert.assertEquals(\"Wrong residue at end of block 0, protein 1\", 184, optAln[0][1][62]);\n    Assert.assertEquals(\"Wrong residue at start of block 1, protein 0\", 63, optAln[1][0][0]);\n    Assert.assertEquals(\"Wrong residue at start of block 1, protein 1\", 0, optAln[1][1][0]);\n    Assert.assertEquals(\"Wrong residue at pos 1 of block 1, protein 0\", 65, optAln[1][0][1]);\n    Assert.assertEquals(\"Wrong residue at pos 1 of block 1, protein 1\", 1, optAln[1][1][1]);\n    Assert.assertEquals(\"Wrong residue at pos 54 of block 1, protein 0\", 118, optAln[1][0][54]);\n    Assert.assertEquals(\"Wrong residue at pos 54 of block 1, protein 1\", 54, optAln[1][1][54]);\n    Assert.assertEquals(\"Wrong residue at pos 55 of block 1, protein 0\", 119, optAln[1][0][55]);\n    Assert.assertEquals(\"Wrong residue at pos 55 of block 1, protein 1\", 55, optAln[1][1][55]);\n    Assert.assertEquals(\"Wrong residue at end of block 1, protein 0\", 181, optAln[1][0][117]);\n    Assert.assertEquals(\"Wrong residue at end of block 1, protein 1\", 117, optAln[1][1][117]);\n}", "repo_id": "9", "comment": "/**\n * Tests private {@link OptimalCECPMain#permuteOptAln(AFPChain, int)}\n */\n", "repo_name": "biojava-master/", "id": 152, "method_signature": "void testPermuteOptAln()"}, "1781": {"callee_method_names": [], "method_name": "PDBHeader.hasJournalArticle", "method_implementation": "{\n    return this.journalArticle != null;\n}", "repo_id": "9", "comment": "/**\n * Return whether or not the entry has an associated journal article\n * or publication. The JRNL section is not mandatory and thus may not be\n * present.\n * @return flag if a JournalArticle could be found.\n */\n", "repo_name": "biojava-master/", "id": 1781, "method_signature": "boolean hasJournalArticle()"}, "454": {"callee_method_names": [], "method_name": "QsAlignResult.getAlignment", "method_implementation": "{\n    return alignment;\n}", "repo_id": "9", "comment": "/**\n * The alignment that specifies the residue equivalencies of the equivalent\n * Subunits.\n *\n * @return alignment as a MultipleAlignment object\n */\n", "repo_name": "biojava-master/", "id": 454, "method_signature": "MultipleAlignment getAlignment()"}, "724": {"callee_method_names": [], "method_name": "CECalculator.zGaps", "method_implementation": "{\n    if (nTrace < 2)\n        return (0.0);\n    double scoreAv_, scoreSd_;\n    if (winSize == 8) {\n        if (nTrace < 21) {\n            scoreAv_ = gapsAv8[nTrace - 1];\n            scoreSd_ = gapsSd8[nTrace - 1];\n        } else {\n            scoreAv_ = 14.949173 * nTrace - 14.581193;\n            scoreSd_ = 2.045067 * nTrace + 13.191095;\n        }\n        if (nGaps > scoreAv_)\n            return (0.0);\n        return ((scoreAv_ - nGaps) / scoreSd_);\n    }\n    if (winSize == 6) {\n        if (nTrace < 21) {\n            scoreAv_ = gapsAv6[nTrace - 1];\n            scoreSd_ = gapsSd6[nTrace - 1];\n        } else {\n            scoreAv_ = 13.574490 * nTrace - 13.977223;\n            scoreSd_ = 1.719977 * nTrace + 19.615014;\n        }\n        if (nGaps > scoreAv_)\n            return (0.0);\n        return ((scoreAv_ - nGaps) / scoreSd_);\n    }\n    return (0.0);\n}", "repo_id": "9", "comment": "///////////////////////////////////////////////////////////////////////////\n", "repo_name": "biojava-master/", "id": 724, "method_signature": "double zGaps(int, int, int)"}, "1052": {"callee_method_names": [], "method_name": "StructureTools.getAtomsInContact", "method_implementation": "{\n    return getAtomsInContact(chain1, chain2, null, cutoff, hetAtoms);\n}", "repo_id": "9", "comment": "/**\n * Returns the set of inter-chain contacts between the two given chains for\n * all non-H atoms. Uses a spatial hashing algorithm that speeds up the\n * calculation without need of full distance matrix. The parsing mode\n * {@link FileParsingParameters#setAlignSeqRes(boolean)} needs to be set to\n * true for this to work.\n *\n * @param chain1\n * @param chain2\n * @param cutoff\n * @param hetAtoms\n *            if true HET atoms are included, if false they are not\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1052, "method_signature": "AtomContactSet getAtomsInContact(Chain, Chain, double, boolean)"}, "2394": {"callee_method_names": [], "method_name": "Location.bioEnd", "method_implementation": "{\n    return plus().end();\n}", "repo_id": "9", "comment": "/**\n * Get end index, in biocoordinates.\n *\n * @return The origin 1 index of the final symbol in location.\n */\n", "repo_name": "biojava-master/", "id": 2394, "method_signature": "int bioEnd()"}, "1701": {"callee_method_names": [], "method_name": "AtomImpl.setElement", "method_implementation": "{\n    this.element = e;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1701, "method_signature": "void setElement(Element)"}, "690": {"callee_method_names": ["List<Atom[]>.size", "List<List<AFPChain>>.add", "List<List<AFPChain>>.get", "MultipleMcParameters.getNrThreads", "List<Atom[]>.get", "List<Atom[]>.get", "StructureAlignment.getAlgorithmName", "StructureAlignment.getParameters", "ExecutorService.submit", "List<Future<AFPChain>>.add", "List<List<AFPChain>>.get", "List<Future<AFPChain>>.get", "List<List<AFPChain>>.get", "List<Future<AFPChain>>.get", "ExecutorService.shutdown", "StructureAlignment.getAlgorithmName", "List<List<AFPChain>>.get"], "method_name": "MultipleMcMain.generateSeed", "method_implementation": "{\n    int size = atomArrays.size();\n    //List to store the all-to-all alignments\n    List<List<AFPChain>> afpAlignments = new ArrayList<List<AFPChain>>();\n    for (int i = 0; i < size; i++) {\n        afpAlignments.add(new ArrayList<AFPChain>());\n        for (int j = 0; j < size; j++) afpAlignments.get(i).add(null);\n    }\n    int threads = params.getNrThreads();\n    ExecutorService executor = Executors.newFixedThreadPool(threads);\n    List<Future<AFPChain>> afpFuture = new ArrayList<Future<AFPChain>>();\n    //Create all the possible protein pairwise combinations\n    //(N*(N-1)/2) and call the pairwise alignment algorithm\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            Callable<AFPChain> worker = new CallableStructureAlignment(atomArrays.get(i), atomArrays.get(j), pairwise.getAlgorithmName(), pairwise.getParameters());\n            Future<AFPChain> submit = executor.submit(worker);\n            afpFuture.add(submit);\n        }\n    }\n    //Store the resulting AFPChains in the 2D List\n    //the alignment index\n    int index = 0;\n    for (int i = 0; i < size; i++) {\n        for (int j = i; j < size; j++) {\n            if (i != j) {\n                afpAlignments.get(i).add(j, afpFuture.get(index).get());\n                afpAlignments.get(j).add(i, afpFuture.get(index).get());\n                index++;\n            }\n        }\n    }\n    executor.shutdown();\n    reference = chooseReferenceRMSD(afpAlignments);\n    boolean flexible = false;\n    if (pairwise.getAlgorithmName().contains(\"flexible\"))\n        flexible = true;\n    return combineReferenceAlignments(afpAlignments.get(reference), atomArrays, reference, flexible);\n}", "repo_id": "9", "comment": "/**\n * Creates a MultipleAlignment seed for MC optimization from the\n * representative Atoms of the structures. If there are N structures:\n * <ul><li>Generate (N*(N-1))/2 all-to-all alignments in parallel using\n * the Java API.\n * <li>Choose the closest structure to all others as the reference.\n * <li>Generate a MultipleAlignment by combining all the alignments to\n * the reference, that will be used as a seed for the MC optimization.\n * </ul>\n *\n * @param atomArrays List of Atoms to align of the structures\n * @return MultipleAlignment seed alignment\n * @throws ExecutionException\n * @throws InterruptedException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 690, "method_signature": "MultipleAlignment generateSeed(List)"}, "3689": {"callee_method_ids": [3650, 3650, 3649, 3649], "callee_method_names": ["ArrayList<String>.add", "ArrayList<String>.add", "SurvivalInfo.getContinuousVariable", "SurvivalInfo.toString", "ArrayList<String>.get", "ArrayList<String>.contains", "ArrayList<String>.add", "SurvivalInfo.getContinuousVariable", "SurvivalInfo.toString", "ArrayList<String>.get", "SurvivalInfo.addContinuousVariable", "SurvivalInfo.addContinuousVariable"], "method_name": "SurvivalInfoHelper.groupByRange", "method_implementation": "{\n    ArrayList<String> labels = new ArrayList<String>();\n    for (int i = 0; i < range.length; i++) {\n        String label = \"\";\n        if (i == 0) {\n            label = \"[<=\" + range[i] + \"]\";\n        } else if (i == range.length - 1) {\n            label = \"[\" + (range[i - 1] + 1) + \"-\" + range[i] + \"]\";\n            labels.add(label);\n            label = \"[>\" + range[i] + \"]\";\n        } else {\n            label = \"[\" + (range[i - 1] + 1) + \"-\" + range[i] + \"]\";\n        }\n        labels.add(label);\n    }\n    ArrayList<String> validLabels = new ArrayList<String>();\n    //need to find the categories so we can set 1 and 0 and not include ranges with no values\n    for (SurvivalInfo si : survivalInfoList) {\n        Double value = si.getContinuousVariable(variable);\n        if (value == null) {\n            throw new Exception(\"Variable \" + variable + \" not found in \" + si.toString());\n        }\n        int rangeIndex = getRangeIndex(range, value);\n        String label = labels.get(rangeIndex);\n        if (!validLabels.contains(groupName + \"_\" + label)) {\n            validLabels.add(groupName + \"_\" + label);\n        }\n    }\n    Collections.sort(validLabels);\n    System.out.println(\"Valid Lables:\" + validLabels);\n    for (SurvivalInfo si : survivalInfoList) {\n        Double value = si.getContinuousVariable(variable);\n        if (value == null) {\n            throw new Exception(\"Variable \" + variable + \" not found in \" + si.toString());\n        }\n        int rangeIndex = getRangeIndex(range, value);\n        String label = labels.get(rangeIndex);\n        String inLable = groupName + \"_\" + label;\n        for (String gl : validLabels) {\n            if (gl.equals(inLable)) {\n                si.addContinuousVariable(gl, 1.0);\n            } else {\n                si.addContinuousVariable(gl, 0.0);\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Need to allow a range of values similar to cut in R and a continuous c\n *\n * @param range\n * @param variable\n * @param groupName\n * @param survivalInfoList\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3689, "method_signature": "void groupByRange(double[], String, String, ArrayList)"}, "2770": {"callee_method_names": ["BufferedOutputStream.close", "FileOutputStream.close"], "method_name": "FastaWriterHelper.writeProteinSequence", "method_implementation": "{\n    FileOutputStream outputStream = new FileOutputStream(file);\n    BufferedOutputStream bo = new BufferedOutputStream(outputStream);\n    writeProteinSequence(bo, proteinSequences);\n    bo.close();\n    outputStream.close();\n}", "repo_id": "9", "comment": "/**\n * Write collection of protein sequences to a file\n *\n * @param file\n * @param proteinSequences\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2770, "method_signature": "void writeProteinSequence(File, Collection)"}, "3638": {"callee_method_names": [], "method_name": "CoxInfo.getWaldTestInfo", "method_implementation": "{\n    return waldTestInfo;\n}", "repo_id": "9", "comment": "/**\n * @return the waldTestInfo\n */\n", "repo_name": "biojava-master/", "id": 3638, "method_signature": "WaldTestInfo getWaldTestInfo()"}, "431": {"callee_method_names": [], "method_name": "FatCatParameters.getDisCut", "method_implementation": "{\n    return disCut;\n}", "repo_id": "9", "comment": "/**\n * Get the distance cutoff used during AFP chain connectivity checks\n *\n * @return distance Cutoff\n */\n", "repo_name": "biojava-master/", "id": 431, "method_signature": "Double getDisCut()"}, "993": {"callee_method_names": [], "method_name": "HetatomImpl.getChain", "method_implementation": "{\n    return parent;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 993, "method_signature": "Chain getChain()"}, "3526": {"callee_method_names": [], "method_name": "StrataInfo.getVarhaz", "method_implementation": "{\n    return varhaz;\n}", "repo_id": "9", "comment": "/**\n * @return the varhaz\n */\n", "repo_name": "biojava-master/", "id": 3526, "method_signature": "ArrayList<Double> getVarhaz()"}, "1530": {"callee_method_names": [], "method_name": "JournalArticle.getRef", "method_implementation": "{\n    return ref;\n}", "repo_id": "9", "comment": "/**\n * Get the value of REF field.\n * For example: TO BE PUBLISHED\n *\n * @return the value of ref\n */\n", "repo_name": "biojava-master/", "id": 1530, "method_signature": "String getRef()"}, "3438": {"callee_method_names": ["StructureViewer.repaint"], "method_name": "StructureViewerTest.testRepaint", "method_implementation": "{\n    if (java.awt.GraphicsEnvironment.isHeadless())\n        return;\n    StructureViewer instance = new StructureViewerImpl();\n    instance.repaint();\n    // TODO review the generated test code and remove the default call to fail.\n    // fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of repaint method, of class StructureViewer.\n */\n", "repo_name": "biojava-master/", "id": 3438, "method_signature": "void testRepaint()"}, "1693": {"callee_method_names": [], "method_name": "AtomImpl.getCoordsAsPoint3d", "method_implementation": "{\n    return coords;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1693, "method_signature": "Point3d getCoordsAsPoint3d()"}, "3408": {"callee_method_names": ["RotationGroup.getPointGroup", "String.startsWith", "String.startsWith"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getSymmetryColors", "method_implementation": "{\n    String pointGroup = rotationGroup.getPointGroup();\n    Color[] col = null;\n    Color4f[] colors = null;\n    if (\"C1\".equals(pointGroup)) {\n        col = ColorBrewer.Greys.getColorPalette(nColors);\n        colors = ColorConverter.convertColor4f(col);\n    } else if (pointGroup.startsWith(\"C\")) {\n        col = ColorBrewer.YlGnBu.getColorPalette(nColors);\n        colors = ColorConverter.convertColor4f(col);\n    } else if (pointGroup.startsWith(\"D\")) {\n        col = ColorBrewer.YlOrRd.getColorPalette(nColors);\n        colors = ColorConverter.convertColor4f(col);\n    } else if (\"T\".equals(pointGroup)) {\n        col = ColorBrewer.Greens.getColorPalette(nColors);\n        colors = ColorConverter.convertColor4f(col);\n    } else if (\"O\".equals(pointGroup)) {\n        col = ColorBrewer.Blues.getColorPalette(nColors);\n        colors = ColorConverter.convertColor4f(col);\n    } else if (\"I\".equals(pointGroup)) {\n        col = ColorBrewer.BuPu.getColorPalette(nColors);\n        colors = ColorConverter.convertColor4f(col);\n    } else {\n        col = ColorBrewer.Greys.getColorPalette(nColors);\n        colors = ColorConverter.convertColor4f(col);\n    }\n    System.arraycopy(colors, 0, colors, 0, nColors);\n    return colors;\n}", "repo_id": "9", "comment": "/**\n * Returns a unique color palette based on point group\n * @param nColors\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3408, "method_signature": "Color4f[] getSymmetryColors(int)"}, "1576": {"callee_method_names": [], "method_name": "Site.setEvCode", "method_implementation": "{\n    this.evCode = evCode;\n}", "repo_id": "9", "comment": "/**\n * sets the REMARK 800 EVIDENCE CODE for the site.\n */\n", "repo_name": "biojava-master/", "id": 1576, "method_signature": "void setEvCode(String)"}, "3479": {"callee_method_names": ["HashMap.keySet", "Set<String>.add"], "method_name": "NCBIQBlastAlignmentProperties.getAlignmentOptions", "method_implementation": "{\n    Set<String> result = new HashSet<String>();\n    for (BlastAlignmentParameterEnum parameter : param.keySet()) {\n        result.add(parameter.name());\n    }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * Gets parameters, which are currently set\n */\n", "repo_name": "biojava-master/", "id": 3479, "method_signature": "Set<String> getAlignmentOptions()"}, "440": {"callee_method_names": ["Atom[].clone"], "method_name": "StructureAlignmentOptimizer.superimposeBySet", "method_implementation": "{\n    //extract the coordinations of equivalent residues\n    Atom[] tmp1 = new Atom[equLen];\n    Atom[] tmp2 = new Atom[equLen];\n    int i, r1, r2;\n    for (i = 0; i < equLen; i++) {\n        r1 = equSet[0][i];\n        r2 = equSet[1][i];\n        tmp1[i] = cod1[r1];\n        // have to be cloned!\n        tmp2[i] = (Atom) cod2[r2].clone();\n        //tmp2[i] = cod2[ r2 ];\n        /*try {\n\t\t\t\tSystem.out.println(\"before superimpos: \" + equSet[0][i]+\"-\"+ equSet[1][i]+ \" dist:\" + Calc.getDistance(tmp1[i], cod2[equSet[1][i]]));\n\t\t\t} catch (Exception e){\n\t\t\t\te.printStackTrace();\n\t\t\t}*/\n    }\n    //superimpose the equivalent residues\n    Matrix4d trans = SuperPositions.superpose(Calc.atomsToPoints(tmp1), Calc.atomsToPoints(tmp2));\n    Calc.transform(tmp2, trans);\n    // weird, why does it take the RMSD before the rotation?\n    // the rmsd is only for the subset contained in the tmp arrays.\n    rmsd = Calc.rmsd(tmp1, tmp2);\n    //System.err.println(\"rmsd after superimpose by set: \" + rmsd);\n    //transform structure 2 according to the superimposition of the equivalent residues\n    Calc.transform(cod2, trans);\n    //      for(i = 0; i < equLen; i ++)    {\n    //         try {\n    //            System.err.println(\"after superimpos: \" + equSet[0][i]+\"-\"+ equSet[1][i]+ \" dist:\" + Calc.getDistance(tmp1[i], cod2[equSet[1][i]]));\n    //         } catch (Exception e){\n    //            e.printStackTrace();\n    //         }\n    //      }\n}", "repo_id": "9", "comment": "/**\n * superimpose two structures according to the equivalent residues\n */\n", "repo_name": "biojava-master/", "id": 440, "method_signature": "void superimposeBySet()"}, "2599": {"callee_method_names": ["UncompressInputStream.read", "OutputStream.write"], "method_name": "UncompressInputStream.uncompress", "method_implementation": "{\n    UncompressInputStream ucis = new UncompressInputStream(in);\n    long total = 0;\n    byte[] buffer = new byte[100000];\n    while (true) {\n        int bytesRead = ucis.read(buffer);\n        if (bytesRead == -1)\n            break;\n        out.write(buffer, 0, bytesRead);\n        total += bytesRead;\n    }\n    return total;\n}", "repo_id": "9", "comment": "/**\n * Read an input stream and uncompress it to an output stream.\n * @param in the incoming InputStream. It is NOT closed.\n * @param out the destination OutputStream. It is NOT closed.\n * @return number of bytes sent to the output stream\n * @throws IOException for any error\n */\n", "repo_name": "biojava-master/", "id": 2599, "method_signature": "long uncompress(InputStream, OutputStream)"}, "2966": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.iterator", "method_implementation": "{\n    return this.parsedCompounds.iterator();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2966, "method_signature": "Iterator<C> iterator()"}, "3435": {"callee_method_names": ["StringBuffer.append", "CeSymmResult.getMultipleAlignment", "StringBuffer.append", "StringBuffer.append", "CeSymmResult.getMultipleAlignment", "StringBuffer.append", "StringBuffer.append", "CeSymmResult.toString", "StringBuffer.toString"], "method_name": "SymmetryDisplay.getSymmTitle", "method_implementation": "{\n    StringBuffer buff = new StringBuffer();\n    // Add algorithm name and version\n    buff.append(result.getMultipleAlignment().getEnsemble().getAlgorithmName());\n    buff.append(\" V\");\n    buff.append(result.getMultipleAlignment().getEnsemble().getVersion());\n    buff.append(\": \");\n    // Add the result summary string\n    buff.append(result.toString());\n    return buff.toString();\n}", "repo_id": "9", "comment": "/**\n * Create a symmetry title for a display frame (Jmol, alignment, etc). The\n * title contains information about the algorithm, structure id and\n * parameters used.\n *\n * @param result\n * @return title String\n */\n", "repo_name": "biojava-master/", "id": 3435, "method_signature": "String getSymmTitle(CeSymmResult)"}, "170": {"callee_method_names": ["Structure.getPDBCode", "Structure.getChainByIndex", "Chain.getAtomGroups", "Chain.getAtomGroups", "Structure.getChainByIndex", "Chain.getAtomGroups", "Chain.getAtomGroups", "Structure.getEntityInfos", "List<EntityInfo>.size", "List<EntityInfo>.get", "EntityInfo.getDescription"], "method_name": "StructureTest.testReadPDBFile", "method_implementation": "{\n    assertEquals(\"pdb code not set!\", \"5PTI\", structure.getPDBCode());\n    // since biojava 5.0, we have 4 chains here: 1 protein, 2 non-poly (ligands), 1 water\n    Chain c = structure.getChainByIndex(0);\n    assertEquals(\"did not find the expected 58 amino acids!\", 58, c.getAtomGroups(GroupType.AMINOACID).size());\n    assertEquals(0, c.getAtomGroups(GroupType.HETATM).size());\n    Chain c4 = structure.getChainByIndex(3);\n    // The fourth chain in the file contains 63 molecules of deutarated\n    assertEquals(63, c4.getAtomGroups(GroupType.HETATM).size());\n    assertEquals(0, c4.getAtomGroups(GroupType.NUCLEOTIDE).size());\n    List<EntityInfo> compounds = structure.getEntityInfos();\n    assertEquals(4, compounds.size());\n    EntityInfo mol = compounds.get(0);\n    assertTrue(mol.getDescription().startsWith(\"TRYPSIN INHIBITOR\"));\n}", "repo_id": "9", "comment": "/**\n * Tests if a PDB file can be parsed\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 170, "method_signature": "void testReadPDBFile()"}, "3578": {"callee_method_names": [], "method_name": "Matrix.identity", "method_implementation": "{\n    double[][] I = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        I[i][i] = 1;\n    }\n    return I;\n}", "repo_id": "9", "comment": "/**\n * @param n\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3578, "method_signature": "double[][] identity(int)"}, "1544": {"callee_method_names": ["ScopDomain.getSunid", "ScopNode.getParentSunid", "List<ScopNode>.add"], "method_name": "ScopInstallation.getTree", "method_implementation": "{\n    ScopNode node = getScopNode(domain.getSunid());\n    List<ScopNode> tree = new ArrayList<ScopNode>();\n    while (node != null) {\n        //System.out.println(\"This node: sunid:\" + node.getSunid() );\n        //System.out.println(getScopDescriptionBySunid(node.getSunid()));\n        node = getScopNode(node.getParentSunid());\n        if (node != null)\n            tree.add(node);\n    }\n    Collections.reverse(tree);\n    return tree;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getTree(org.biojava.nbio.structure.scop.ScopDomain)\n\t */\n", "repo_name": "biojava-master/", "id": 1544, "method_signature": "List<ScopNode> getTree(ScopDomain)"}, "273": {"callee_method_names": ["DocumentBuilderFactory.newDocumentBuilder", "DocumentBuilder.parse", "Document.getElementsByTagName", "NodeList.getLength", "NodeList.item", "Map<String, List<Node>>.get", "List<Node>.size", "List<Node>.get", "Map<String, List<Node>>.get", "List<Node>.size", "List<Node>.get", "List<Node>.get", "Map<String, List<Node>>.get", "List<Node>.size", "List<Node>.get", "List<Node>.get", "Map<String, List<Node>>.get", "List<Node>.size", "List<Node>.get", "Map<String, List<Node>>.get", "List<Node>.size", "List<Node>.get", "Node.getAttributes", "NamedNodeMap.getNamedItem", "Node.getTextContent", "Map<String, Integer>.containsKey", "NamedNodeMap.getNamedItem", "Node.getTextContent", "String.isEmpty", "Set<String>.addAll", "String.split", "Set<String>.isEmpty", "List<Node>.size", "List<Node>.get", "List<Component>.add", "Map<String, Integer>.put", "List<Component>.size", "Map<String, List<Node>>.get", "List<Node>.size", "List<Node>.get", "Map<String, List<Node>>.get", "List<Node>.size", "List<Node>.get", "NamedNodeMap.getNamedItem", "Node.getTextContent", "Map<String, Integer>.get", "NamedNodeMap.getNamedItem", "Node.getTextContent", "List<Node>.get", "String.isEmpty", "String.split", "List<Node>.get", "NamedNodeMap.getNamedItem", "Node.getTextContent", "Map<String, Integer>.get", "NamedNodeMap.getNamedItem", "Node.getTextContent", "List<Node>.get", "String.isEmpty", "String.split", "List<ModificationLinkage>.add", "Map<String, List<Node>>.get", "List<Node>.isEmpty", "ProteinModificationImpl.Builder.setDescription", "List<Node>.get", "Map<String, List<Node>>.get", "Map<String, List<Node>>.get", "List<Node>.size", "List<Node>.get", "Map<String, List<Node>>.get", "List<Node>.size", "List<Node>.get", "Map<String, List<Node>>.get", "List<Node>.isEmpty", "List<Node>.get", "ProteinModificationImpl.Builder.setPdbccId", "ProteinModificationImpl.Builder.setResidId", "ProteinModificationImpl.Builder.setPsimodId", "Map<String, List<Node>>.get", "List<Node>.isEmpty", "ProteinModificationImpl.Builder.setFormula", "List<Node>.get", "Map<String, List<Node>>.get", "List<Node>.isEmpty", "ProteinModificationImpl.Builder.addKeyword", "ScopNode.getTextContent", "ProteinModificationImpl.Builder.build"], "method_name": "ProteinModificationXmlReader.registerProteinModificationFromXml", "method_implementation": "{\n    if (isXml == null) {\n        throw new IllegalArgumentException(\"Null argument.\");\n    }\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n    DocumentBuilder builder = factory.newDocumentBuilder();\n    Document doc = builder.parse(isXml);\n    NodeList modNodes = doc.getElementsByTagName(\"Entry\");\n    int modSize = modNodes.getLength();\n    List<Node> nodes;\n    for (int iMod = 0; iMod < modSize; iMod++) {\n        Node modNode = modNodes.item(iMod);\n        Map<String, List<Node>> infoNodes = getChildNodes(modNode);\n        // ID\n        nodes = infoNodes.get(\"Id\");\n        if (nodes == null || nodes.size() != 1) {\n            throw new RuntimeException(\"Each modification must have exact \" + \"one <Id> field.\");\n        }\n        String id = nodes.get(0).getTextContent();\n        // modification category\n        nodes = infoNodes.get(\"Category\");\n        if (nodes == null || nodes.size() != 1) {\n            throw new RuntimeException(\"Each modification must have exact \" + \"one <Category> field. See Modification \" + id + \".\");\n        }\n        ModificationCategory cat = ModificationCategory.getByLabel(nodes.get(0).getTextContent());\n        if (cat == null) {\n            throw new RuntimeException(nodes.get(0).getTextContent() + \" is not defined as an modification category.\" + \" See Modification \" + id + \".\");\n        }\n        // occurrence type\n        nodes = infoNodes.get(\"Occurrence\");\n        if (nodes == null || nodes.size() != 1) {\n            throw new RuntimeException(\"Each modification must have exact \" + \"one <Occurrence> field. See Modification \" + id + \".\");\n        }\n        ModificationOccurrenceType occType = ModificationOccurrenceType.getByLabel(nodes.get(0).getTextContent());\n        if (occType == null) {\n            throw new RuntimeException(nodes.get(0).getTextContent() + \" is not defined as an modification occurence type.\" + \" See Modification \" + id + \".\");\n        }\n        // condition\n        ModificationCondition condition = null;\n        {\n            nodes = infoNodes.get(\"Condition\");\n            if (nodes == null || nodes.size() != 1) {\n                throw new RuntimeException(\"Each modification must have exact \" + \"one <Condition> field. See Modification \" + id + \".\");\n            }\n            Node compsNode = nodes.get(0);\n            // keep track of the labels of component indices\n            Map<String, Integer> mapLabelComp = new HashMap<String, Integer>();\n            Map<String, List<Node>> compInfoNodes = getChildNodes(compsNode);\n            // components\n            List<Node> compNodes = compInfoNodes.get(\"Component\");\n            int sizeComp = compNodes.size();\n            List<Component> comps = new ArrayList<Component>(sizeComp);\n            for (int iComp = 0; iComp < sizeComp; iComp++) {\n                Node compNode = compNodes.get(iComp);\n                // comp label\n                NamedNodeMap compNodeAttrs = compNode.getAttributes();\n                Node labelNode = compNodeAttrs.getNamedItem(\"component\");\n                if (labelNode == null) {\n                    throw new RuntimeException(\"Each component must have a label.\" + \" See Modification \" + id + \".\");\n                }\n                String label = labelNode.getTextContent();\n                if (mapLabelComp.containsKey(label)) {\n                    throw new RuntimeException(\"Each component must have a unique label.\" + \" See Modification \" + id + \".\");\n                }\n                // comp PDBCC ID\n                Set<String> compIds = new HashSet<String>();\n                List<Node> compIdNodes = getChildNodes(compNode).get(\"Id\");\n                if (compIdNodes != null) {\n                    for (Node compIdNode : compIdNodes) {\n                        NamedNodeMap compIdNodeAttr = compIdNode.getAttributes();\n                        Node compIdSource = compIdNodeAttr.getNamedItem(\"source\");\n                        if (compIdSource != null && \"PDBCC\".equals(compIdSource.getTextContent())) {\n                            String strComps = compIdNode.getTextContent();\n                            if (strComps.isEmpty()) {\n                                throw new RuntimeException(\"Empty component.\" + \" See Modification \" + id + \".\");\n                            }\n                            compIds.addAll(Arrays.asList(strComps.split(\",\")));\n                        }\n                    }\n                }\n                if (compIds.isEmpty()) {\n                    throw new RuntimeException(\"Each component must have a PDBCC ID.\" + \" See Modification \" + id + \".\");\n                }\n                // terminal\n                boolean nTerminal = false;\n                boolean cTerminal = false;\n                List<Node> compTermNode = getChildNodes(compNode).get(\"Terminal\");\n                if (compTermNode != null) {\n                    if (compTermNode.size() != 1) {\n                        throw new RuntimeException(\"Only one <Terminal> condition is allowed for \" + \"each component. See Modification \" + id + \".\");\n                    }\n                    String nc = compTermNode.get(0).getTextContent();\n                    if (\"N\".equals(nc)) {\n                        nTerminal = true;\n                    } else if (\"C\".equals(nc)) {\n                        cTerminal = true;\n                    } else {\n                        throw new RuntimeException(\"Only N or C is allowed for <Terminal>.\" + \" See Modification \" + id + \".\");\n                    }\n                }\n                // register\n                Component comp = Component.of(compIds, nTerminal, cTerminal);\n                comps.add(comp);\n                mapLabelComp.put(label, comps.size() - 1);\n            }\n            // bonds\n            List<Node> bondNodes = compInfoNodes.get(\"Bond\");\n            List<ModificationLinkage> linkages = null;\n            if (bondNodes != null) {\n                int sizeBonds = bondNodes.size();\n                linkages = new ArrayList<ModificationLinkage>(sizeBonds);\n                for (int iBond = 0; iBond < sizeBonds; iBond++) {\n                    Node bondNode = bondNodes.get(iBond);\n                    Map<String, List<Node>> bondChildNodes = getChildNodes(bondNode);\n                    if (bondChildNodes == null) {\n                        throw new RuntimeException(\"Each bond must contain two atoms\" + \" See Modification \" + id + \".\");\n                    }\n                    List<Node> atomNodes = bondChildNodes.get(\"Atom\");\n                    if (atomNodes == null || atomNodes.size() != 2) {\n                        throw new RuntimeException(\"Each bond must contain two atoms\" + \" See Modification \" + id + \".\");\n                    }\n                    // atom 1\n                    NamedNodeMap atomNodeAttrs = atomNodes.get(0).getAttributes();\n                    Node compNode = atomNodeAttrs.getNamedItem(\"component\");\n                    if (compNode == null) {\n                        throw new RuntimeException(\"Each atom must on a component.\" + \" See Modification \" + id + \".\");\n                    }\n                    String labelComp1 = compNode.getTextContent();\n                    int iComp1 = mapLabelComp.get(labelComp1);\n                    Node labelNode = atomNodeAttrs.getNamedItem(\"atom\");\n                    String labelAtom1 = labelNode == null ? null : labelNode.getTextContent();\n                    String atom1 = atomNodes.get(0).getTextContent();\n                    if (atom1.isEmpty()) {\n                        throw new RuntimeException(\"Each atom must have a name. Please use wildcard * if unknown.\" + \" See Modification \" + id + \".\");\n                    }\n                    List<String> potentialAtoms1 = Arrays.asList(atom1.split(\",\"));\n                    // atom 2\n                    atomNodeAttrs = atomNodes.get(1).getAttributes();\n                    compNode = atomNodeAttrs.getNamedItem(\"component\");\n                    if (compNode == null) {\n                        throw new RuntimeException(\"Each atom must on a component.\" + \" See Modification \" + id + \".\");\n                    }\n                    String labelComp2 = compNode.getTextContent();\n                    int iComp2 = mapLabelComp.get(labelComp2);\n                    labelNode = atomNodeAttrs.getNamedItem(\"atom\");\n                    String labelAtom2 = labelNode == null ? null : labelNode.getTextContent();\n                    String atom2 = atomNodes.get(1).getTextContent();\n                    if (atom2.isEmpty()) {\n                        throw new RuntimeException(\"Each atom must have a name. Please use wildcard * if unknown.\" + \" See Modification \" + id + \".\");\n                    }\n                    List<String> potentialAtoms2 = Arrays.asList(atom2.split(\",\"));\n                    // add linkage\n                    ModificationLinkage linkage = new ModificationLinkage(comps, iComp1, potentialAtoms1, labelAtom1, iComp2, potentialAtoms2, labelAtom2);\n                    linkages.add(linkage);\n                }\n            }\n            condition = new ModificationConditionImpl(comps, linkages);\n        }\n        // end of condition\n        ProteinModificationImpl.Builder modBuilder = new ProteinModificationImpl.Builder(id, cat, occType, condition);\n        // description\n        nodes = infoNodes.get(\"Description\");\n        if (nodes != null && !nodes.isEmpty()) {\n            modBuilder.setDescription(nodes.get(0).getTextContent());\n        }\n        // cross references\n        nodes = infoNodes.get(\"CrossReference\");\n        if (nodes != null) {\n            for (Node node : nodes) {\n                Map<String, List<Node>> xrefInfoNodes = getChildNodes(node);\n                // source\n                List<Node> xrefNode = xrefInfoNodes.get(\"Source\");\n                if (xrefNode == null || xrefNode.size() != 1) {\n                    throw new RuntimeException(\"Error in XML file: \" + \"a cross reference must contain exactly one <Source> field.\" + \" See Modification \" + id + \".\");\n                }\n                String xrefDb = xrefNode.get(0).getTextContent();\n                // id\n                xrefNode = xrefInfoNodes.get(\"Id\");\n                if (xrefNode == null || xrefNode.size() != 1) {\n                    throw new RuntimeException(\"Error in XML file: \" + \"a cross reference must contain exactly one <Id> field.\" + \" See Modification \" + id + \".\");\n                }\n                String xrefId = xrefNode.get(0).getTextContent();\n                // name\n                String xrefName = null;\n                xrefNode = xrefInfoNodes.get(\"Name\");\n                if (xrefNode != null && !xrefNode.isEmpty()) {\n                    xrefName = xrefNode.get(0).getTextContent();\n                }\n                if (\"PDBCC\".equals(xrefDb)) {\n                    modBuilder.setPdbccId(xrefId).setPdbccName(xrefName);\n                } else if (\"RESID\".equals(xrefDb)) {\n                    modBuilder.setResidId(xrefId).setResidName(xrefName);\n                } else if (\"PSI-MOD\".equals(xrefDb)) {\n                    modBuilder.setPsimodId(xrefId).setPsimodName(xrefName);\n                }\n            }\n        }\n        // end of cross references\n        // formula\n        nodes = infoNodes.get(\"Formula\");\n        if (nodes != null && !nodes.isEmpty()) {\n            modBuilder.setFormula(nodes.get(0).getTextContent());\n        }\n        // keywords\n        nodes = infoNodes.get(\"Keyword\");\n        if (nodes != null && !nodes.isEmpty()) {\n            for (Node node : nodes) {\n                modBuilder.addKeyword(node.getTextContent());\n            }\n        }\n        ProteinModificationRegistry.register(modBuilder.build());\n    }\n}", "repo_id": "9", "comment": "/**\n * Read protein modifications from XML file and register them.\n * @param isXml {@link InputStream} of the XML file.\n * @throws IOException if failed to read the XML file.\n * @throws ParserConfigurationException if parse errors occur.\n * @throws SAXException the {@link DocumentBuilder} cannot be created.\n */\n", "repo_name": "biojava-master/", "id": 273, "method_signature": "void registerProteinModificationFromXml(InputStream)"}, "2037": {"callee_method_names": [], "method_name": "SymmetryTools.getResetVal", "method_implementation": "{\n    if (Double.isNaN(unpenalizedScore))\n        // what else?\n        return 0;\n    // We can actually return a positive value if this is high enough\n    double updateVal = unpenalizedScore;\n    updateVal -= gradientExpCoeff * Math.pow(Math.E, -nResFromMainDiag);\n    for (int p = 0; p < gradientPolyCoeff.length; p++) {\n        updateVal -= gradientPolyCoeff[gradientPolyCoeff.length - 1 - p] * Math.pow(nResFromMainDiag, -p);\n    }\n    return updateVal;\n}", "repo_id": "9", "comment": "/**\n * Returns the \"reset value\" for graying out the main diagonal. If we're\n * blanking out the main diagonal, this value is always Integer.MIN_VALUE.\n * <p>\n * This is possible if {@code gradientPolyCoeff = Integer.MIN_VALUE} and\n * {@code gradientExpCoeff = 0}.\n *\n * @param unpenalizedScore\n * @param nResFromMainDiag\n * @param gradientPolyCoeff\n * @param gradientExpCoeff\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2037, "method_signature": "double getResetVal(double, double, double[], double)"}, "1757": {"callee_method_names": [], "method_name": "MismatchedBasePairParameters.setMaxStretch", "method_implementation": "{\n    this.maxStretch = maxStretch;\n}", "repo_id": "9", "comment": "/**\n * This method sets the maximum stretch allowed for a base pair, prior to analyze() call.\n * @param maxStretch The maximum stretch (in \u00c5) allowed to consider two bases paired\n */\n", "repo_name": "biojava-master/", "id": 1757, "method_signature": "void setMaxStretch(double)"}, "1521": {"callee_method_names": ["Matrix4d.get"], "method_name": "Matrices.getTranslationVector", "method_implementation": "{\n    Vector3d transl = new Vector3d();\n    transform.get(transl);\n    return transl;\n}", "repo_id": "9", "comment": "/**\n * Extract the translational vector of a transformation matrix.\n *\n * @param transform\n *            Matrix4d\n * @return Vector3d translation vector\n */\n", "repo_name": "biojava-master/", "id": 1521, "method_signature": "Vector3d getTranslationVector(Matrix4d)"}, "587": {"callee_method_names": [], "method_name": "AlignmentTools.get", "method_implementation": "{\n    return (K) key;\n}", "repo_id": "9", "comment": "/**\n * @param key\n * @return the key\n * @throws ClassCastException if key is not of type K\n */\n", "repo_name": "biojava-master/", "id": 587, "method_signature": "K get(Object)"}, "3820": {"callee_method_names": [], "method_name": "ExpressionFigure.getFileName", "method_implementation": "{\n    return fileName;\n}", "repo_id": "9", "comment": "/**\n * @return the fileName\n */\n", "repo_name": "biojava-master/", "id": 3820, "method_signature": "String getFileName()"}, "2894": {"callee_method_names": ["List<Iterator<SequenceView<C>>>.add", "Sequence<C>.getSubSequence", "Sequence<C>.getLength", "List<Iterator<SequenceView<C>>>.add", "List<Iterator<SequenceView<C>>>.get", "Iterator<SequenceView<C>>.hasNext", "List<SequenceView<C>>.add", "Iterator<SequenceView<C>>.next"], "method_name": "SequenceMixin.overlappingKmers", "method_implementation": "{\n    List<SequenceView<C>> l = new ArrayList<SequenceView<C>>();\n    List<Iterator<SequenceView<C>>> windows = new ArrayList<Iterator<SequenceView<C>>>();\n    for (int i = 1; i <= kmer; i++) {\n        if (i == 1) {\n            windows.add(new WindowedSequence<C>(sequence, kmer).iterator());\n        } else {\n            SequenceView<C> sv = sequence.getSubSequence(i, sequence.getLength());\n            windows.add(new WindowedSequence<C>(sv, kmer).iterator());\n        }\n    }\n    OUTER: while (true) {\n        for (int i = 0; i < kmer; i++) {\n            Iterator<SequenceView<C>> iterator = windows.get(i);\n            boolean breakLoop = true;\n            if (iterator.hasNext()) {\n                l.add(iterator.next());\n                breakLoop = false;\n            }\n            if (breakLoop) {\n                break OUTER;\n            }\n        }\n    }\n    return l;\n}", "repo_id": "9", "comment": "/**\n * Used to generate overlapping k-mers such i.e. ATGTA will give rise to\n * ATG, TGT & GTA\n *\n * @param <C> Compound to use\n * @param sequence Sequence to build from\n * @param kmer Kmer size\n * @return The list of overlapping K-mers\n */\n", "repo_name": "biojava-master/", "id": 2894, "method_signature": "List<SequenceView<C>> overlappingKmers(Sequence, int)"}, "2044": {"callee_method_names": ["CeSymmResult.isRefined", "CeSymmResult.getMultipleAlignment", "MultipleAlignment.getEnsemble", "MultipleAlignmentEnsemble.getMultipleAlignment", "MultipleAlignment.getBlock", "List<Atom[]>.add", "MultipleAlignmentEnsemble.setAtomArrays", "Block.size", "Block.getStartResidue", "Block.length", "Block.getAlignRes", "Block.getAlignRes"], "method_name": "SymmetryTools.toRepeatsAlignment", "method_implementation": "{\n    if (!result.isRefined())\n        throw new IllegalArgumentException(\"The symmetry result \" + \"is not refined, repeats cannot be defined\");\n    MultipleAlignment msa = result.getMultipleAlignment();\n    MultipleAlignmentEnsemble newEnsemble = msa.getEnsemble().clone();\n    List<Structure> repSt = SymmetryTools.divideStructure(result);\n    MultipleAlignment repeats = newEnsemble.getMultipleAlignment(0);\n    Block block = repeats.getBlock(0);\n    List<Atom[]> atomArrays = new ArrayList<Atom[]>();\n    for (Structure s : repSt) atomArrays.add(StructureTools.getRepresentativeAtomArray(s));\n    newEnsemble.setAtomArrays(atomArrays);\n    for (int su = 0; su < block.size(); su++) {\n        Integer start = block.getStartResidue(su);\n        // Normalize aligned residues\n        for (int res = 0; res < block.length(); res++) {\n            Integer residue = block.getAlignRes().get(su).get(res);\n            if (residue != null)\n                residue -= start;\n            block.getAlignRes().get(su).set(res, residue);\n        }\n    }\n    return repeats;\n}", "repo_id": "9", "comment": "/**\n * Method that converts a symmetry alignment into an alignment of the\n * repeats only, as new independent structures.\n * <p>\n * This method changes the structure identifiers, the Atom arrays and\n * re-scles the aligned residues in the Blocks corresponding to those\n * changes.\n * <p>\n * Application: display superimposed repeats in Jmol.\n *\n * @param result\n *            CeSymmResult of symmetry\n * @return MultipleAlignment of the repeats\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2044, "method_signature": "MultipleAlignment toRepeatsAlignment(CeSymmResult)"}, "115": {"callee_method_names": ["NeedlemanWunsch<DNASequence, NucleotideCompound>.setAnchors", "NeedlemanWunsch<DNASequence, NucleotideCompound>.getPair"], "method_name": "NeedlemanWunschTest.should_align_all_anchored", "method_implementation": "{\n    DNASequence query = new DNASequence(\"ACG\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"CGT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    NeedlemanWunsch<DNASequence, NucleotideCompound> aligner = new NeedlemanWunsch<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 0, (short) 10), SubstitutionMatrixHelper.getNuc4_4());\n    aligner.setAnchors(new int[] { 0, 1, 2 });\n    assertEquals(String.format(\"ACG%nCGT%n\"), aligner.getPair().toString());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 115, "method_signature": "void should_align_all_anchored()"}, "382": {"callee_method_names": ["Atom.getX", "Atom.getY", "Atom.getZ", "Atom.setCoords"], "method_name": "Calc.getCenterVector", "method_implementation": "{\n    double[] coords = new double[3];\n    coords[0] = 0 - centroid.getX();\n    coords[1] = 0 - centroid.getY();\n    coords[2] = 0 - centroid.getZ();\n    Atom shiftVec = new AtomImpl();\n    shiftVec.setCoords(coords);\n    return shiftVec;\n}", "repo_id": "9", "comment": "/**\n * Returns the Vector that needs to be applied to shift a set of atoms to\n * the Centroid, if the centroid is already known\n *\n * @param atomSet\n *            array of Atoms\n * @return the vector needed to shift the set of atoms to its geometric\n *         center\n */\n", "repo_name": "biojava-master/", "id": 382, "method_signature": "Atom getCenterVector(Atom[], Atom)"}, "3014": {"callee_method_names": [], "method_name": "BitArrayWorker.getCompoundSet", "method_implementation": "{\n    return compoundSet;\n}", "repo_id": "9", "comment": "/**\n * Returns the compound set backing this store\n */\n", "repo_name": "biojava-master/", "id": 3014, "method_signature": "CompoundSet<C> getCompoundSet()"}, "3348": {"callee_method_names": ["NavigableMap<Double, Color>.floorKey", "NavigableMap<Double, Color>.higherKey", "Double.isInfinite", "NavigableMap<Double, Color>.get", "Double.isInfinite", "NavigableMap<Double, Color>.get", "ColorInterpolator.interpolate", "NavigableMap<Double, Color>.get", "NavigableMap<Double, Color>.get"], "method_name": "GradientMapper.getColor", "method_implementation": "{\n    Double left = mapping.floorKey(value);\n    Double right = mapping.higherKey(value);\n    //don't interpolate to infinity\n    if (right == null || right.isInfinite()) {\n        return mapping.get(Double.POSITIVE_INFINITY);\n    }\n    if (left == null || left.isInfinite()) {\n        return mapping.get(Double.NEGATIVE_INFINITY);\n    }\n    // fraction of left color to use\n    float alpha = (float) ((right - value) / (right - left));\n    return interpolator.interpolate(mapping.get(left), mapping.get(right), alpha);\n}", "repo_id": "9", "comment": "/**\n * @param value\n * @return\n * @see org.biojava.nbio.structure.gui.util.color.ContinuousColorMapper#getColor(double)\n */\n", "repo_name": "biojava-master/", "id": 3348, "method_signature": "Color getColor(double)"}, "3324": {"callee_method_names": [], "method_name": "WrapLayout.minimumLayoutSize", "method_implementation": "{\n    Dimension minimum = layoutSize(target, false);\n    minimum.width -= (getHgap() + 1);\n    return minimum;\n}", "repo_id": "9", "comment": "/**\n * Returns the minimum dimensions needed to layout the <i>visible</i>\n * components contained in the specified target container.\n * @param target the component which needs to be laid out\n * @return the minimum dimensions to lay out the\n * subcomponents of the specified container\n */\n", "repo_name": "biojava-master/", "id": 3324, "method_signature": "Dimension minimumLayoutSize(Container)"}, "1467": {"callee_method_names": [], "method_name": "CrystalCell.transfToOriginCellOrthonormal", "method_implementation": "{\n    // reference in crystal coords\n    Point3d refXtal = new Point3d(reference);\n    transfToCrystal(refXtal);\n    // Convert to crystal coords\n    Matrix4d[] opsXtal = new Matrix4d[ops.length];\n    for (int i = 0; i < ops.length; i++) {\n        opsXtal[i] = transfToCrystal(ops[i]);\n    }\n    Matrix4d[] transformed = transfToOriginCellCrystal(opsXtal, refXtal);\n    // Convert back to orthonormal\n    for (int i = 0; i < ops.length; i++) {\n        transformed[i] = transfToOrthonormal(transformed[i]);\n    }\n    return transformed;\n}", "repo_id": "9", "comment": "/**\n * @param ops Set of operations in orthonormal coordinates\n * @param reference Reference point, which should be in the unit cell after\n *  each operation (also in orthonormal coordinates)\n * @return A set of orthonormal operators with equivalent rotation to the\n *  inputs, but with translation such that the reference point would fall\n *  within the unit cell\n */\n", "repo_name": "biojava-master/", "id": 1467, "method_signature": "Matrix4d[] transfToOriginCellOrthonormal(Matrix4d[], Tuple3d)"}, "3366": {"callee_method_names": [], "method_name": "DefaultMatrixMapper.setScalevalue", "method_implementation": "{\n    this.scalevalue = scalevalue;\n}", "repo_id": "9", "comment": "/**\n * @param scalevalue the scalevalue to set\n */\n", "repo_name": "biojava-master/", "id": 3366, "method_signature": "void setScalevalue(double)"}, "1110": {"callee_method_names": ["UserConfiguration.getCacheFilePath", "File.exists", "File.length", "Logger.info", "int.getMessage"], "method_name": "SiftsChainToUniprotMapping.load", "method_implementation": "{\n    UserConfiguration config = new UserConfiguration();\n    File cacheDir = new File(config.getCacheFilePath());\n    DEFAULT_FILE = new File(cacheDir, DEFAULT_FILENAME);\n    if (!DEFAULT_FILE.exists() || DEFAULT_FILE.length() == 0) {\n        if (useOnlyLocal)\n            throw new IOException(DEFAULT_FILE + \" does not exist, and did not download\");\n        download();\n    }\n    try {\n        return build();\n    } catch (IOException e) {\n        logger.info(\"Caught IOException while reading {}. Error: {}\", DEFAULT_FILE, e.getMessage());\n        if (useOnlyLocal)\n            throw new IOException(DEFAULT_FILE + \" could not be read, and did not redownload\");\n        download();\n        return build();\n    }\n}", "repo_id": "9", "comment": "/**\n * Loads the SIFTS mapping.\n * Attempts to load the mapping file in the PDB cache directory.\n * If the file does not exist or could not be parsed, downloads and stores a GZ-compressed file.\n * @param useOnlyLocal If true, will throw an IOException if the file needs to be downloaded\n * @return\n * @throws IOException If the local file could not be read and could not be downloaded (including if onlyLocal is true)\n */\n", "repo_name": "biojava-master/", "id": 1110, "method_signature": "SiftsChainToUniprotMapping load(boolean)"}, "1183": {"callee_method_names": [], "method_name": "PDBFileParser.pdb_TER_Handler", "method_implementation": "{\n    startOfMolecule = true;\n}", "repo_id": "9", "comment": "/**\n * Handler for TER record. The record is used in deposited PDB files and many others,\n * but it's often forgotten by some softwares. In any case it helps identifying the\n * start of ligand molecules so we use it for that.\n */\n", "repo_name": "biojava-master/", "id": 1183, "method_signature": "void pdb_TER_Handler()"}, "3481": {"callee_method_names": ["HashMap.put"], "method_name": "NCBIQBlastAlignmentProperties.setAlignmentOption", "method_implementation": "{\n    param.put(key, val);\n}", "repo_id": "9", "comment": "/**\n * Sets the value of specified parameter\n */\n", "repo_name": "biojava-master/", "id": 3481, "method_signature": "void setAlignmentOption(BlastAlignmentParameterEnum, String)"}, "3345": {"callee_method_names": ["ColorSpace.fromRGB"], "method_name": "HSVColorSpace.toCIEXYZ", "method_implementation": "{\n    float[] rgb = this.toRGB(hsv);\n    ColorSpace CIEXYZcs = ColorSpace.getInstance(CS_CIEXYZ);\n    return CIEXYZcs.fromRGB(rgb);\n}", "repo_id": "9", "comment": "/**\n * @param hsv\n * @return\n * @see java.awt.color.ColorSpace#toCIEXYZ(float[])\n */\n", "repo_name": "biojava-master/", "id": 3345, "method_signature": "float[] toCIEXYZ(float[])"}, "3774": {"callee_method_names": [], "method_name": "WorkSheet.getColumnLookup", "method_implementation": "{\n    return columnLookup;\n}", "repo_id": "9", "comment": "/**\n * @return the columnLookup\n */\n", "repo_name": "biojava-master/", "id": 3774, "method_signature": "LinkedHashMap<String,HeaderInfo> getColumnLookup()"}, "1331": {"callee_method_names": [], "method_name": "FileParsingParameters.shouldCreateAtomCharges", "method_implementation": "{\n    return createAtomCharges;\n}", "repo_id": "9", "comment": "/**\n * Should we create charges on atoms when parsing a file?\n *\n * @return true if we should create the charges, false if not\n */\n", "repo_name": "biojava-master/", "id": 1331, "method_signature": "boolean shouldCreateAtomCharges()"}, "1023": {"callee_method_ids": [929, 940], "callee_method_names": ["Grid.addAtoms", "Group.isWater", "Group.isPolymeric", "Group.getAtoms", "Grid.hasAnyContact", "List<Group>.add"], "method_name": "StructureTools.getLigandsByProximity", "method_implementation": "{\n    // Spatial hashing of the reduced structure\n    Grid grid = new Grid(cutoff);\n    grid.addAtoms(query);\n    List<Group> ligands = new ArrayList<>();\n    for (Group g : target) {\n        // don't worry about waters\n        if (g.isWater()) {\n            continue;\n        }\n        if (g.isPolymeric()) {\n            // Polymers aren't ligands\n            continue;\n        }\n        // It is a ligand!\n        // Check that it's within cutoff of something in reduced\n        List<Atom> groupAtoms = g.getAtoms();\n        if (!grid.hasAnyContact(Calc.atomsToPoints(groupAtoms))) {\n            continue;\n        }\n        ligands.add(g);\n    }\n    return ligands;\n}", "repo_id": "9", "comment": "/**\n * Finds all ligand groups from the target which fall within the cutoff distance\n * of some atom from the query set.\n *\n * @param target Set of groups including the ligands\n * @param query Atom selection\n * @param cutoff Distance from query atoms to consider, in angstroms\n * @return All groups from the target with at least one atom within cutoff of a query atom\n * @see StructureTools#DEFAULT_LIGAND_PROXIMITY_CUTOFF\n */\n", "repo_name": "biojava-master/", "id": 1023, "method_signature": "List<Group> getLigandsByProximity(Collection, Atom[], double)"}, "758": {"callee_method_names": [], "method_name": "CeParameters.setMaxNrIterationsForOptimization", "method_implementation": "{\n    this.maxNrIterationsForOptimization = maxNrIterationsForOptimization;\n}", "repo_id": "9", "comment": "/**\n * Set the maximum nr of times the (slow) optimiziation of alignment should iterate. Default: unlimited\n *\n * @param maxNrIterationsForOptimization\n */\n", "repo_name": "biojava-master/", "id": 758, "method_signature": "void setMaxNrIterationsForOptimization(int)"}, "3048": {"callee_method_names": ["LocationPredicate.accept"], "method_name": "LocationHelper.scanLocations", "method_implementation": "{\n    Location location = null;\n    for (Location l : locations) {\n        if (location == null) {\n            location = l;\n        } else {\n            if (predicate.accept(location, l)) {\n                location = l;\n            }\n        }\n    }\n    return location;\n}", "repo_id": "9", "comment": "/**\n * Used for scanning through a list of locations; assumes the\n * locations given will have at least one value otherwise\n * we will get a null pointer\n */\n", "repo_name": "biojava-master/", "id": 3048, "method_signature": "Location scanLocations(List, LocationPredicate)"}, "2174": {"callee_method_names": ["Structure.getChains", "Chain.getAtomGroups", "Group.getAtoms", "Atom.getCharge"], "method_name": "TestChargeAdder.testQuestionMark", "method_implementation": "{\n    // Get the structure\n    Structure structure = StructureIO.getStructure(\"3PE6\");\n    ChargeAdder.addCharges(structure);\n    // Now count the charges\n    int chargeCount = 0;\n    for (Chain chain : structure.getChains()) {\n        for (Group group : chain.getAtomGroups()) {\n            for (Atom atom : group.getAtoms()) {\n                if (atom.getCharge() != 0) {\n                    chargeCount++;\n                }\n            }\n        }\n    }\n    assertEquals(39, chargeCount);\n}", "repo_id": "9", "comment": "/**\n * Test that it can parse '?' values in the CCD.\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2174, "method_signature": "void testQuestionMark()"}, "3572": {"callee_method_names": [], "method_name": "Matrix.oneDivide", "method_implementation": "{\n    double[] d = new double[A.length];\n    for (int i = 0; i < d.length; i++) {\n        d[i] = 1.0 / A[i];\n    }\n    return d;\n}", "repo_id": "9", "comment": "/**\n * @param A\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3572, "method_signature": "double[] oneDivide(double[])"}, "2221": {"callee_method_names": ["Structure.nrModels", "Structure.getPolyChains", "Structure.getPolyChains", "Set<String>.add", "PolymerType.getName", "Set<String>.size", "Set<String>.contains", "Set<String>.contains", "Set<String>.contains", "Set<String>.contains", "Structure.getPolyChainByPDB", "Structure.getPolyChainByPDB", "Structure.getPolyChains", "Chain.getName", "Chain.getName", "SuperPosition.superposeAndTransform", "SuperPosition.superposeAndTransform"], "method_name": "TestHardBioUnits.test4A1I", "method_implementation": "{\n    String pdbId = \"4A1I\";\n    int biolAssemblyNr = 2;\n    Structure bioAssembly = StructureIO.getBiologicalAssembly(pdbId, biolAssemblyNr);\n    if (bioAssembly == null) {\n        System.err.println(\"Could not generate the biological assembly \" + pdbId + \" nr \" + biolAssemblyNr);\n    }\n    /*\n\t\t * loop_\n\t\t\t\t_pdbx_struct_assembly_gen.assembly_id\n\t\t\t\t_pdbx_struct_assembly_gen.oper_expression\n\t\t\t\t_pdbx_struct_assembly_gen.asym_id_list\n\t\t\t\t1 1 A,I,J,K,L,M,N,UA,H,PA,QA,RA,SA,TA,BB\n\t\t\t\t2 1 G,KA,LA,MA,NA,OA,AB\n\t\t\t\t2 2 B,O,P,Q,R,VA\n\t\t\t\t3 1 B,O,P,Q,R,VA\n\t\t\t\t3 3 G,KA,LA,MA,NA,OA,AB\n\t\t\t\t4 1 C,S,T,U,V,W,WA,F,FA,GA,HA,IA,JA,ZA\n\t\t\t\t5 1 D,X,Y,Z,XA,E,AA,BA,CA,DA,EA,YA\n\t\t */\n    //System.out.println(bioAssembly.toPDB());\n    assertEquals(1, bioAssembly.nrModels());\n    assertEquals(2, bioAssembly.getPolyChains().size());\n    // here we'll store all author chain ids without the operator id part\n    Set<String> chainIdsNoOps = new HashSet<String>();\n    for (Chain poly : bioAssembly.getPolyChains()) {\n        chainIdsNoOps.add(poly.getName().split(\"_\")[0]);\n    }\n    assertEquals(2, chainIdsNoOps.size());\n    // we should have B and G only\n    assertTrue(chainIdsNoOps.contains(\"B\"));\n    assertTrue(chainIdsNoOps.contains(\"G\"));\n    assertFalse(chainIdsNoOps.contains(\"A\"));\n    assertFalse(chainIdsNoOps.contains(\"H\"));\n    // now let's check that the right operators were applied to the right chains\n    // first we need the original structure\n    Structure original = StructureIO.getStructure(pdbId);\n    Point3d[] atomsOrigChainG = Calc.atomsToPoints(StructureTools.getAtomCAArray(original.getPolyChainByPDB(\"G\")));\n    Point3d[] atomsOrigChainB = Calc.atomsToPoints(StructureTools.getAtomCAArray(original.getPolyChainByPDB(\"B\")));\n    List<Chain> bioAssemblyChains = bioAssembly.getPolyChains();\n    Chain transfChainB = null;\n    Chain transfChainG = null;\n    // get the bioassembly's equivalent chains B and G\n    for (Chain c : bioAssemblyChains) {\n        if (c.getName().startsWith(\"B\"))\n            transfChainB = c;\n        if (c.getName().startsWith(\"G\"))\n            transfChainG = c;\n    }\n    assertNotNull(transfChainB);\n    assertNotNull(transfChainG);\n    Point3d[] atomsTransfChainG = Calc.atomsToPoints(StructureTools.getAtomCAArray(transfChainG));\n    Point3d[] atomsTransfChainB = Calc.atomsToPoints(StructureTools.getAtomCAArray(transfChainB));\n    SuperPosition superPosition = new SuperPositionSVD(false);\n    // operator 1 is the identity, trace should be == 3\n    Matrix4d m1 = superPosition.superposeAndTransform(atomsOrigChainG, atomsTransfChainG);\n    assertEquals(3.0, m1.m00 + m1.m11 + m1.m22, 0.00001);\n    assertEquals(0.0, CalcPoint.rmsd(atomsOrigChainG, atomsTransfChainG), 0.00001);\n    // operator 2 is a 2-fold, trace should be == -1\n    Matrix4d m2 = superPosition.superposeAndTransform(atomsOrigChainB, atomsTransfChainB);\n    assertEquals(-1.0, m2.m00 + m2.m11 + m2.m22, 0.00001);\n    assertEquals(0.0, CalcPoint.rmsd(atomsOrigChainB, atomsTransfChainB), 0.00001);\n}", "repo_id": "9", "comment": "/**\n * This tests that the biounit is correctly represented (should work from all sources mmcif, pdb, mmtf)\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2221, "method_signature": "void test4A1I()"}, "219": {"callee_method_names": [], "method_name": "JronnTest.verifyRanges", "method_implementation": "{\n    Range[] ranges = Jronn.getDisorder(new FastaSequence(\"name\", \"LLRGRHLMNGTMIMRPWNFLNDHHFPKFFPHLIEQQAIWLADWWRKKHC\" + \"RPLPTRAPTMDQWDHFALIQKHWTANLWFLTFPFNDKWGWIWFLKDWTPGSADQAQRACTWFFCHGHDTN\" + \"CQIIFEGRNAPERADPMWTGGLNKHIIARGHFFQSNKFHFLERKFCEMAEIERPNFTCRTLDCQKFPWDDP\" + \"CSSTHSDCPKLEDLISFTETHGCSAADNADRPSQACHIGWAAMCEPTAMFMLMGSRCRCSFWPQNNAARHR\" + \"NFLIQIEMHSHLEHWIQTLHPQRPFLCNTWDDNWPICQFASQARGNSPDHHP\"));\n    assertEquals(4, ranges.length);\n    assertEquals(53, ranges[0].from);\n    assertEquals(59, ranges[0].to);\n    assertEquals(190, ranges[1].from);\n    assertEquals(196, ranges[1].to);\n    assertEquals(210, ranges[2].from);\n    assertEquals(226, ranges[2].to);\n    assertEquals(305, ranges[3].from);\n    assertEquals(313, ranges[3].to);\n    //System.out.println(Arrays.toString(ranges));\n}", "repo_id": "9", "comment": "// Implemented with two platform checks.\n", "repo_name": "biojava-master/", "id": 219, "method_signature": "void verifyRanges()"}, "2629": {"callee_method_names": ["PrintWriter.println"], "method_name": "PrettyXMLWriter.printRaw", "method_implementation": "{\n    writer.println(data);\n}", "repo_id": "9", "comment": "// does not work for adding literal XML elements.\n", "repo_name": "biojava-master/", "id": 2629, "method_signature": "void printRaw(String)"}, "604": {"callee_method_names": ["AFPChain.getGroup", "Group.hasAltLoc", "Group.getAltLocs", "Group.getAtoms"], "method_name": "AlignmentTools.shiftCA2", "method_implementation": "{\n    int i = -1;\n    for (Atom a : ca2) {\n        i++;\n        Group g = a.getGroup();\n        Calc.rotate(g, m);\n        Calc.shift(g, shift);\n        if (g.hasAltLoc()) {\n            for (Group alt : g.getAltLocs()) {\n                for (Atom alta : alt.getAtoms()) {\n                    if (g.getAtoms().contains(alta))\n                        continue;\n                    Calc.rotate(alta, m);\n                    Calc.shift(alta, shift);\n                }\n            }\n        }\n        twistedGroups[i] = g;\n    }\n}", "repo_id": "9", "comment": "/**\n * only shift CA positions.\n */\n", "repo_name": "biojava-master/", "id": 604, "method_signature": "void shiftCA2(AFPChain, Atom[], Matrix, Atom, Group[])"}, "2696": {"callee_method_names": [], "method_name": "FastaStreamer.each", "method_implementation": "{\n    return () -> stream().iterator();\n}", "repo_id": "9", "comment": "/**\n * Enable iteration through the proteins in the file using syntax such as:\n * <pre>\n *     for(ProteinSequence sequence : FastaStreamer.from(path).each()) {\n *         .\n *         .\n *         .\n *     }\n * </pre>\n *\n * @return an iterable suitable for an iteration loop\n */\n", "repo_name": "biojava-master/", "id": 2696, "method_signature": "Iterable<ProteinSequence> each()"}, "3106": {"callee_method_names": [], "method_name": "DBReferenceInfo.getDatabase", "method_implementation": "{\n    return database;\n}", "repo_id": "9", "comment": "/**\n * @return the database\n */\n", "repo_name": "biojava-master/", "id": 3106, "method_signature": "String getDatabase()"}, "3606": {"callee_method_names": [], "method_name": "CoxInfo.setVariance", "method_implementation": "{\n    //   if (Math.abs(var[0][1] - var[1][0]) > .0000000000001) { //in the CoxCC correction looks like a precision error keeps these from being equal 10-19\n    //       throw new Exception(\"Expecting diagonal to be equal\");\n    //   }\n    imat = new double[var.length][var[0].length];\n    for (int i = 0; i < var.length; i++) {\n        for (int j = 0; j < var[0].length; j++) {\n            imat[i][j] = var[i][j];\n        }\n    }\n    calcSummaryValues();\n}", "repo_id": "9", "comment": "/**\n * @param var\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3606, "method_signature": "void setVariance(double[][])"}, "1593": {"callee_method_names": ["AtomContactSet.iterator", "Iterator<AtomContact>.hasNext", "Iterator<AtomContact>.next", "AtomContact.getPair", "AtomContact.getPair", "Map<ResidueNumber, Integer>.get", "Group.getResidueNumber", "Map<ResidueNumber, Integer>.get", "Group.getResidueNumber", "List<Pair<Integer>>.add", "Point3d.getFirst", "Point3d.getSecond"], "method_name": "SecStrucCalc.findBridges", "method_implementation": "{\n    // Get the interator of contacts\n    Iterator<AtomContact> myIter = contactSet.iterator();\n    List<Pair<Integer>> outList = new ArrayList<Pair<Integer>>();\n    // Now iterate through this\n    while (myIter.hasNext()) {\n        // Get the next atom contact\n        AtomContact ac = myIter.next();\n        Group g1 = ac.getPair().getFirst().getGroup();\n        Group g2 = ac.getPair().getSecond().getGroup();\n        // Get the indices\n        int i = indResMap.get(g1.getResidueNumber());\n        int j = indResMap.get(g2.getResidueNumber());\n        // If i>j switch them over\n        if (i > j) {\n            // Switch them over\n            int old = i;\n            i = j;\n            j = old;\n        }\n        // Only these\n        if (j < i + 3) {\n            continue;\n        }\n        // If it's the first\n        if (i == 0) {\n            continue;\n        }\n        if (j == 0) {\n            continue;\n        }\n        // If it's the last\n        if (i == groups.length - 1) {\n            continue;\n        }\n        if (j == groups.length - 1) {\n            continue;\n        }\n        Pair<Integer> thisPair = new Pair<Integer>(i, j);\n        outList.add(thisPair);\n    }\n    //\n    Collections.sort(outList, new Comparator<Pair<Integer>>() {\n\n        @Override\n        public int compare(Pair<Integer> o1, Pair<Integer> o2) {\n            if (o1.getFirst() < o2.getFirst()) {\n                return -1;\n            } else if (o1.getFirst() > o2.getFirst()) {\n                return +1;\n            } else {\n                if (o1.getSecond() < o2.getSecond()) {\n                    return -1;\n                } else if (o1.getSecond() > o2.getSecond()) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    });\n    for (Pair<Integer> p : outList) {\n        int i = p.getFirst();\n        int j = p.getSecond();\n        BridgeType btype = null;\n        // Now do the bonding\n        if ((isBonded(i - 1, j) && isBonded(j, i + 1)) || (isBonded(j - 1, i) && isBonded(i, j + 1))) {\n            btype = BridgeType.parallel;\n        } else if ((isBonded(i, j) && isBonded(j, i)) || (isBonded(i - 1, j + 1) && (isBonded(j - 1, i + 1)))) {\n            btype = BridgeType.antiparallel;\n        }\n        if (btype != null) {\n            registerBridge(i, j, btype);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Two nonoverlapping stretches of three residues each, i-1,i,i+1 and\n * j-1,j,j+1, form either a parallel or antiparallel bridge, depending on\n * which of two basic patterns is matched. We assign a bridge between\n * residues i and j if there are two H bonds characteristic of beta-\n * structure; in particular:\n * <p>\n * Parallel Bridge(i,j) =: [Hbond(i-1,j) and Hbond(j,i+1)]\n * \t\t\t\t\t\t\tor [Hbond(j-1,i) and Hbond(i,j+1)]\n * <p>\n * Antiparallel Bridge(i,j) =: [Hbond(i,j) and Hbond(j,i)]\n * \t\t\t\t\t\t\t\tor [Hbond(i-1,j+1) and Hbond(j-1,i+1)]\n *\n * Optimised to use the contact set\n */\n", "repo_name": "biojava-master/", "id": 1593, "method_signature": "void findBridges()"}, "1734": {"callee_method_names": [], "method_name": "BasePairParameters.getSlide", "method_implementation": "{\n    if (bp < 0 || bp >= getStepParameters().length)\n        throw new IllegalArgumentException(\"Base pair number is out of range.\");\n    return stepParameters[bp][4];\n}", "repo_id": "9", "comment": "/**\n * This method returns the slide for the given base pair, relative to the one before it.\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in \u00c5)\n */\n", "repo_name": "biojava-master/", "id": 1734, "method_signature": "Double getSlide(int)"}, "1805": {"callee_method_names": ["ReadWriteLock.writeLock", "Logger.trace", "Logger.trace", "ReadWriteLock.writeLock"], "method_name": "EcodInstallation.clear", "method_implementation": "{\n    domainsFileLock.writeLock().lock();\n    logger.trace(\"LOCK writelock\");\n    allDomains = null;\n    domainMap = null;\n    logger.trace(\"UNLOCK writelock\");\n    domainsFileLock.writeLock().unlock();\n}", "repo_id": "9", "comment": "/**\n * Clears all domains, requiring the file to be reparsed for subsequent accesses\n */\n", "repo_name": "biojava-master/", "id": 1805, "method_signature": "void clear()"}, "1151": {"callee_method_names": ["Structure.getChains", "ChemComp.getAtomGroups", "Group.getAtoms", "Atom.getBonds", "Atom.getBonds", "StringBuilder.append", "SparseVector.getAtomA", "SparseVector.getAtomB", "StringBuilder.toString"], "method_name": "FileConvert.printPDBConnections", "method_implementation": "{\n    StringBuilder str = new StringBuilder();\n    for (Chain c : structure.getChains()) {\n        for (Group g : c.getAtomGroups()) {\n            for (Atom a : g.getAtoms()) {\n                if (a.getBonds() != null) {\n                    for (Bond b : a.getBonds()) {\n                        //7890123456789012345678901234567890123456789012345678901234567890\n                        str.append(String.format(\"CONECT%5d%5d                                                                \" + newline, b.getAtomA().getPDBserial(), b.getAtomB().getPDBserial()));\n                    }\n                }\n            }\n        }\n    }\n    return str.toString();\n}", "repo_id": "9", "comment": "/**\n * Prints the connections in PDB style\n *\n * Rewritten since 5.0 to use {@link Bond}s\n * Will produce strictly one CONECT record per bond (won't group several bonds in one line)\n */\n", "repo_name": "biojava-master/", "id": 1151, "method_signature": "String printPDBConnections()"}, "1480": {"callee_method_names": [], "method_name": "SuperPositionAbstract.checkInput", "method_implementation": "{\n    if (fixed.length != moved.length)\n        throw new IllegalArgumentException(\"Point arrays to superpose are of different lengths.\");\n}", "repo_id": "9", "comment": "/**\n * Check that the input to the superposition algorithms is valid.\n *\n * @param fixed\n * @param moved\n */\n", "repo_name": "biojava-master/", "id": 1480, "method_signature": "void checkInput(Point3d[], Point3d[])"}, "2463": {"callee_method_ids": [2421], "callee_method_names": ["String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.charAt", "Location.isNegative", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.substring"], "method_name": "GeneIDGFF2Reader.parseLine", "method_implementation": "{\n    //FIXME update to use regex split on tabs\n    //FIXME better errors on parse failures\n    int start = 0;\n    int end = 0;\n    start = end;\n    end = s.indexOf('\\t', start);\n    String seqname = s.substring(start, end).trim();\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    String source = s.substring(start, end).trim();\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    String type = s.substring(start, end);\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    String locStart = s.substring(start, end);\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    String locEnd = s.substring(start, end);\n    Double score;\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    try {\n        score = Double.parseDouble(s.substring(start, end));\n    } catch (Exception e) {\n        score = 0.0;\n    }\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    char strand = s.charAt(end - 1);\n    Location location = Location.fromBio(Integer.parseInt(locStart), Integer.parseInt(locEnd), strand);\n    assert (strand == '-') == location.isNegative();\n    int frame;\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    try {\n        frame = Integer.parseInt(s.substring(start, end));\n    } catch (Exception e) {\n        frame = -1;\n    }\n    //grab everything until end of line (or # comment)\n    start = end + 1;\n    end = s.indexOf('#', start);\n    String attributes = null;\n    if (end < 0) {\n        attributes = s.substring(start);\n    } else {\n        attributes = s.substring(start, end);\n    }\n    //need to add in attribute assignment for geneid where it just provides a gene name and will make it gtf like\n    attributes = \"gene_id \" + '\"' + attributes + '\"' + \";\";\n    return new Feature(seqname, source, type, location, score, frame, attributes);\n}", "repo_id": "9", "comment": "/**\n * create Feature from line of GFF file\n */\n", "repo_name": "biojava-master/", "id": 2463, "method_signature": "Feature parseLine(String)"}, "2381": {"callee_method_names": [], "method_name": "TwoBitParser.reset", "method_implementation": "{\n    cur_seq_pos = 0;\n    cur_nn_block_num = (cur_nn_blocks.length > 0) ? 0 : -1;\n    cur_mask_block_num = (cur_mask_blocks.length > 0) ? 0 : -1;\n    cur_bits = new int[4];\n    file_pos = start_file_pos;\n    buffer_size = 0;\n    buffer_pos = -1;\n}", "repo_id": "9", "comment": "/**\n * Method resets current position to the begining of sequence stream.\n */\n", "repo_name": "biojava-master/", "id": 2381, "method_signature": "void reset()"}, "317": {"callee_method_names": ["Map<Set<String>, Component>.get", "Map<Set<String>, Component>.put", "Map<Set<String>, Component>.get", "Map<Set<String>, Component>.put", "Map<Set<String>, Component>.get", "Map<Set<String>, Component>.put", "Set<Component>.add"], "method_name": "Component.of", "method_implementation": "{\n    if (isNTerminal && isCTerminal) {\n        throw new IllegalArgumentException(\"An amino acid can be at\" + //TODO: is this true?\n        \"N-terminal or C-terminal but not both.\");\n    }\n    lazyInit();\n    Component comp;\n    if (isNTerminal) {\n        comp = nTerminalAminoAcids.get(pdbccIds);\n        if (comp == null) {\n            comp = new Component(pdbccIds, isNTerminal, isCTerminal);\n            nTerminalAminoAcids.put(pdbccIds, comp);\n        }\n    } else if (isCTerminal) {\n        comp = cTerminalAminoAcids.get(pdbccIds);\n        if (comp == null) {\n            comp = new Component(pdbccIds, isNTerminal, isCTerminal);\n            cTerminalAminoAcids.put(pdbccIds, comp);\n        }\n    } else {\n        comp = nonTerminalComps.get(pdbccIds);\n        if (comp == null) {\n            comp = new Component(pdbccIds, isNTerminal, isCTerminal);\n            nonTerminalComps.put(pdbccIds, comp);\n        }\n    }\n    components.add(comp);\n    return comp;\n}", "repo_id": "9", "comment": "/**\n * Get or create a Component.\n * @param pdbccIds a set of possible Protein Data Bank ID.\n * @param isNTerminal true if occurring at N-terminal. false, otherwise.\n * @param isCTerminal true if occurring at C-terminal. false, otherwise.\n * @return a component.\n * @throws IllegalArgumentException if pdbccId or type is null,\n *  or the pdbccId has been registered as a different type,\n *  or terminal condition is indicated for non-amino-acid component,\n *  or both N-terminal and C-terminal are true.\n */\n", "repo_name": "biojava-master/", "id": 317, "method_signature": "Component of(Set, boolean, boolean)"}, "2098": {"callee_method_ids": [2107, 2108], "callee_method_names": ["List<Axis>.get", "Axis.getOrder", "Axis.getSymmType", "List<Integer>.add", "List<List<Integer>>.add"], "method_name": "SymmetryAxes.getRepeatsCyclicForm", "method_implementation": "{\n    Axis axis = axes.get(level);\n    //size of the children\n    int m = getNumRepeats(level + 1);\n    // degree of this node\n    int d = axis.getOrder();\n    // number of repeats included\n    int n = m * d;\n    if (firstRepeat % n != 0) {\n        throw new IllegalArgumentException(String.format(\"Repeat %d cannot start a block at level %s of this tree\", firstRepeat, level));\n    }\n    if (axis.getSymmType() == SymmetryType.OPEN) {\n        // leave off last child for open symm\n        n -= m;\n    }\n    List<List<Integer>> repeats = new ArrayList<>(m);\n    for (int i = 0; i < m; i++) {\n        List<Integer> cycle = new ArrayList<>(d);\n        for (int j = 0; j < d; j++) {\n            cycle.add(firstRepeat + i + j * m);\n        }\n        repeats.add(cycle);\n    }\n    return repeats;\n}", "repo_id": "9", "comment": "/**\n * Get the indices of participating repeats in cyclic form.\n * <p>\n * Each inner list gives a set of equivalent repeats and should have length\n * equal to the order of the axis' operator.\n * @param level\n * @param firstRepeat\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2098, "method_signature": "List<List<Integer>> getRepeatsCyclicForm(int, int)"}, "1594": {"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "SecStrucState.printDSSPline", "StringBuffer.toString"], "method_name": "SecStrucCalc.printDSSP", "method_implementation": "{\n    StringBuffer buf = new StringBuffer();\n    String nl = System.getProperty(\"line.separator\");\n    //Header Line\n    buf.append(\"==== Secondary Structure Definition by BioJava\" + \" DSSP implementation, Version October 2015 ====\" + nl);\n    //First line with column definition\n    buf.append(\"  #  RESIDUE AA STRUCTURE BP1 BP2  ACC     \" + \"N-H-->O    O-->H-N    N-H-->O    O-->H-N    \" + \"TCO  KAPPA ALPHA  PHI    PSI    \" + \"X-CA   Y-CA   Z-CA \");\n    for (int i = 0; i < groups.length; i++) {\n        buf.append(nl);\n        SecStrucState ss = getSecStrucState(i);\n        buf.append(ss.printDSSPline(i));\n    }\n    return buf.toString();\n}", "repo_id": "9", "comment": "/**\n * Generate a DSSP file format ouput String of this SS prediction.\n * @return String in DSSP output file format\n */\n", "repo_name": "biojava-master/", "id": 1594, "method_signature": "String printDSSP()"}, "3138": {"callee_method_names": ["Document.getDocumentElement", "Element.getTextContent", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "UniprotProxySequenceReader.getSequence", "method_implementation": "{\n    try {\n        Element uniprotElement = uniprotDoc.getDocumentElement();\n        Element entryElement = XMLHelper.selectSingleElement(uniprotElement, \"entry\");\n        Element sequenceElement = XMLHelper.selectSingleElement(entryElement, \"sequence\");\n        String seqdata = sequenceElement.getTextContent();\n        return seqdata;\n    } catch (XPathExpressionException e) {\n        logger.error(\"Problems while parsing sequence in UniProt XML: {}. Sequence will be blank.\", e.getMessage());\n        return \"\";\n    }\n}", "repo_id": "9", "comment": "/**\n * @param uniprotDoc\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3138, "method_signature": "String getSequence(Document)"}, "1610": {"callee_method_names": [], "method_name": "SubstructureIdentifier.getPdbId", "method_implementation": "{\n    return pdbId;\n}", "repo_id": "9", "comment": "/**\n * Get the PDB identifier part of the SubstructureIdentifier\n * @return the PDB ID\n */\n", "repo_name": "biojava-master/", "id": 1610, "method_signature": "PdbId getPdbId()"}, "1303": {"callee_method_names": ["Logger.error"], "method_name": "EntityFinder.getRNASequence", "method_implementation": "{\n    try {\n        RNASequence s = new RNASequence(str);\n        return s;\n    } catch (CompoundNotFoundException e) {\n        logger.error(\"Unexpected error when creating RNASequence \", e);\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Returns the RNASequence or null if one can't be created\n * @param str\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1303, "method_signature": "RNASequence getRNASequence(String)"}, "1132": {"callee_method_ids": [2626], "callee_method_names": ["File.exists", "InputStreamProvider.getInputStream"], "method_name": "LocalPDBDirectory.getInputStream", "method_implementation": "{\n    // Check existing\n    File file = downloadStructure(pdbId);\n    if (!file.exists()) {\n        throw new IOException(\"Structure \" + pdbId + \" not found and unable to download.\");\n    }\n    if (!FileDownloadUtils.validateFile(file))\n        throw new IOException(\"Downloaded file invalid: \" + file);\n    InputStreamProvider isp = new InputStreamProvider();\n    InputStream inputStream = isp.getInputStream(file);\n    return inputStream;\n}", "repo_id": "9", "comment": "/**\n * Load or download the specified structure and return it as an InputStream\n * for direct parsing.\n * @param pdbId\n * @return\n * @throws IOException in cases of file I/O, including failure to download a healthy (non-corrupted) file.\n */\n", "repo_name": "biojava-master/", "id": 1132, "method_signature": "InputStream getInputStream(PdbId)"}, "3609": {"callee_method_names": [], "method_name": "CoxInfo.getNaiveVariance", "method_implementation": "{\n    double[][] var = new double[imat.length][imat[0].length];\n    for (int i = 0; i < var.length; i++) {\n        for (int j = 0; j < var[0].length; j++) {\n            var[i][j] = naive_imat[i][j];\n        }\n    }\n    return var;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3609, "method_signature": "double[][] getNaiveVariance()"}, "1756": {"callee_method_names": [], "method_name": "MismatchedBasePairParameters.getMaxStretch", "method_implementation": "{\n    return maxStretch;\n}", "repo_id": "9", "comment": "/**\n * This method returns the maximum stretch between bases used as criteria for the characterization of two bases as being paired.\n * @return the maximum stretch (in \u00c5) allowed.\n */\n", "repo_name": "biojava-master/", "id": 1756, "method_signature": "double getMaxStretch()"}, "2348": {"callee_method_names": [], "method_name": "FastqBuilder.withVariant", "method_implementation": "{\n    if (variant == null) {\n        throw new IllegalArgumentException(\"variant must not be null\");\n    }\n    this.variant = variant;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Return this FASTQ formatted sequence builder configured with the specified FASTQ sequence format variant.\n *\n * @param variant FASTQ sequence format variant for this FASTQ formatted sequence builder, must not be null\n * @return this FASTQ formatted sequence builder configured with the specified FASTQ sequence format variant\n */\n", "repo_name": "biojava-master/", "id": 2348, "method_signature": "FastqBuilder withVariant(FastqVariant)"}, "691": {"callee_method_names": ["List<List<AFPChain>>.size", "List<List<AFPChain>>.size", "List<List<AFPChain>>.get", "List<Double>.add", "List<Double>.get", "List<Double>.get", "Logger.info"], "method_name": "MultipleMcMain.chooseReferenceRMSD", "method_implementation": "{\n    int size = afpAlignments.size();\n    List<Double> RMSDs = new ArrayList<Double>();\n    for (int i = 0; i < afpAlignments.size(); i++) {\n        double rmsd = 0.0;\n        for (int j = 0; j < size; j++) {\n            if (i != j)\n                rmsd += afpAlignments.get(i).get(j).getTotalRmsdOpt();\n        }\n        RMSDs.add(rmsd);\n    }\n    int reference = 0;\n    for (int i = 1; i < size; i++) {\n        if (RMSDs.get(i) < RMSDs.get(reference))\n            reference = i;\n    }\n    logger.info(\"Reference structure is \" + reference);\n    return reference;\n}", "repo_id": "9", "comment": "/**\n * This method takes the all-to-all pairwise alignments Matrix (as a\n * double List of AFPChain) and calculates the structure with the\n * lowest average RMSD against all others.\n * The index of this structure is returned.\n *\n * @param alignments List double containing all-to-all pairwise alignments\n * @return int reference index\n */\n", "repo_name": "biojava-master/", "id": 691, "method_signature": "int chooseReferenceRMSD(List)"}, "3831": {"callee_method_names": ["Set<String>.contains", "Set<String>.contains"], "method_name": "AminoAcidProperties.getChargeOfAminoAcid", "method_implementation": "{\n    if (negChargedAAs.contains(String.valueOf(aa))) {\n        return -1;\n    } else if (posChargedAAs.contains(String.valueOf(aa))) {\n        return 1;\n    }\n    return 0;\n}", "repo_id": "9", "comment": "/**\n * Returns the charge of amino acid. At pH=7, two are negative charged: aspartic acid (Asp, D) and glutamic acid (Glu, E) (acidic side chains),\n * and three are positive charged: lysine (Lys, K), arginine (Arg, R) and histidine (His, H) (basic side chains).\n *\n * @param aa The one-letter amino acid code\n * @return the charge of amino acid (1 if positively charged, -1 if negatively charged, 0 if not charged)\n */\n", "repo_name": "biojava-master/", "id": 3831, "method_signature": "int getChargeOfAminoAcid(char)"}, "3769": {"callee_method_ids": [3752, 3737, 3741], "callee_method_names": ["WorkSheet.getColumns", "WorkSheet.isValidRow", "WorkSheet.getCell"], "method_name": "WorkSheet.appendWorkSheetColumns", "method_implementation": "{\n    ArrayList<String> newColumns = worksheet.getColumns();\n    this.addColumns(newColumns, \"\");\n    ArrayList<String> rows = this.getRows();\n    for (String row : rows) {\n        for (String col : newColumns) {\n            if (worksheet.isValidRow(row)) {\n                String value = worksheet.getCell(row, col);\n                this.addCell(row, col, value);\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Add columns from a second worksheet to be joined by common row. If the\n * appended worksheet doesn't contain a row in the master worksheet then\n * default value of \"\" is used. Rows in the appended worksheet not found in\n * the master worksheet are not added.\n *\n * @param worksheet\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3769, "method_signature": "void appendWorkSheetColumns(WorkSheet)"}, "3567": {"callee_method_names": [], "method_name": "CoxR.chsolve2", "method_implementation": "{\n    int i, j;\n    double temp;\n    /*\n\t\t ** solve Fb =y\n\t\t */\n    for (i = 0; i < n; i++) {\n        temp = y[i];\n        for (j = 0; j < i; j++) {\n            temp -= y[j] * matrix[i][j];\n        }\n        y[i] = temp;\n    }\n    /*\n\t\t ** solve DF'z =b\n\t\t */\n    for (i = (n - 1); i >= 0; i--) {\n        if (matrix[i][i] == 0) {\n            y[i] = 0;\n        } else {\n            temp = y[i] / matrix[i][i];\n            for (j = i + 1; j < n; j++) {\n                temp -= y[j] * matrix[j][i];\n            }\n            y[i] = temp;\n        }\n    }\n}", "repo_id": "9", "comment": "/*  $Id: chsolve2.c 11376 2009-12-14 22:53:57Z therneau $\n\t **\n\t ** Solve the equation Ab = y, where the cholesky decomposition of A and y\n\t **   are the inputs.\n\t **\n\t ** Input  **matrix, which contains the chol decomp of an n by n\n\t **   matrix in its lower triangle.\n\t **        y[n] contains the right hand side\n\t **\n\t **  y is overwriten with b\n\t **\n\t **  Terry Therneau\n\t */\n", "repo_name": "biojava-master/", "id": 3567, "method_signature": "void chsolve2(double[][], int, double[])"}, "2806": {"callee_method_names": [], "method_name": "ClasspathResource.isGzip", "method_implementation": "{\n    if (isGzip != null) {\n        return isGzip;\n    } else {\n        return this.location.endsWith(\".gz\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns true if the location given ends with a .gz extension. No magic\n * number investigation is done.\n */\n", "repo_name": "biojava-master/", "id": 2806, "method_signature": "boolean isGzip()"}, "3131": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getProteinAliasesFromNameGroup", "method_implementation": "{\n    ArrayList<Element> keyWordElementList = XMLHelper.selectElements(proteinElement, \"alternativeName\");\n    for (Element element : keyWordElementList) {\n        getProteinAliasesFromElement(aliasList, element);\n    }\n    keyWordElementList = XMLHelper.selectElements(proteinElement, \"recommendedName\");\n    for (Element element : keyWordElementList) {\n        getProteinAliasesFromElement(aliasList, element);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param aliasList\n * @param proteinElement\n * @throws XPathExpressionException\n */\n", "repo_name": "biojava-master/", "id": 3131, "method_signature": "void getProteinAliasesFromNameGroup(ArrayList, Element)"}, "442": {"callee_method_names": [], "method_name": "StructureAlignmentOptimizer.defineEquPos", "method_implementation": "{\n    int i, r1, r2;\n    int equLenOld = equLen;\n    int[][] equSetOld = new int[2][equLenOld];\n    for (i = 0; i < equLen; i++) {\n        equSetOld[0][i] = equSet[0][i];\n        equSetOld[1][i] = equSet[1][i];\n    }\n    double rmsdOld = rmsd;\n    double dis;\n    equLen = 0;\n    //if (debug)\n    //   System.out.println(String.format(\" OPT: Dc %f, equLenOld %d, rmsdOld %f, alnLen %d\", Dc, equLenOld, rmsdOld, alnLen));\n    for (i = 0; i < alnLen; i++) {\n        r1 = alnList[0][i];\n        r2 = alnList[1][i];\n        dis = Calc.getDistance(cod1[r1], cod2[r2]);\n        if (dis <= Dc) {\n            //System.out.println(r1 + \"-\"  + r2 + \" d:\" + dis);\n            equSet[0][equLen] = r1;\n            equSet[1][equLen] = r2;\n            equLen++;\n        }\n    }\n    superimposeBySet();\n    //if (debug)\n    //   System.out.println(String.format(\" OPT: new equLen %d rmsd %f\", equLen, rmsd));\n    boolean ifstop = false;\n    //      if (debug) {\n    //         System.out.print(\" OPT: rmsd diff: \" + Math.abs(rmsd - rmsdOld) + \" equLens: \" + equLenOld + \":\"+ equLen);\n    //         if ( Math.abs(rmsd - rmsdOld) < 1e-10)\n    //            System.out.println(\" NO DIFF!\");\n    //         else\n    //            System.out.println(\" DIFF!\");\n    //      }\n    if ((Math.abs(rmsd - rmsdOld) < 1e-10) && (equLenOld == equLen))\n        keepStep++;\n    else\n        keepStep = 0;\n    if (keepStep > maxKeepStep) {\n        //converge\n        ifstop = true;\n    } else //allowing up to maxKeepStep instead of 1 is essential for some special cases\n    if (stopRmsd < 0) {\n        //condition 1, continue\n        ifstop = false;\n    } else if ((rmsd <= stopRmsd * stopRmsdPer) || (rmsd < rmsdCut)) {\n        //condition 2, continue\n        ifstop = false;\n    } else //rmsdCut is adopted or not? to be tuned\n    {\n        //get worse\n        ifstop = true;\n    }\n    if ((stopRmsd < 0) && (equLen >= stopLenPer * equLen0)) {\n        //System.err.println(\"stopRmsd: \" + stopRmsd + \" setting to rmsd:\" + rmsd);\n        //condition 1\n        stopRmsd = rmsd;\n    }\n    return ifstop;\n}", "repo_id": "9", "comment": "/**\n * the equivalent residues: residues where Dij &lt;= Dc and i,j is an aligned pair\n * use the previous superimposing\n */\n", "repo_name": "biojava-master/", "id": 442, "method_signature": "boolean defineEquPos(int, int[][])"}, "2317": {"callee_method_ids": [1623, 1625, 1662, 1662, 1663, 1662, 1662, 1663, 1662, 1662, 1663], "callee_method_names": ["SubunitClustererParameters.setSequenceIdentityThreshold", "SubunitClustererParameters.setSequenceCoverageThreshold", "SubunitCluster.mergeSequence", "SubunitCluster.size", "SubunitCluster.size", "SubunitCluster.length", "SubunitCluster.mergeSequence", "SubunitCluster.size", "SubunitCluster.size", "SubunitCluster.length", "SubunitCluster.mergeSequence", "SubunitCluster.size", "SubunitCluster.size", "SubunitCluster.length"], "method_name": "TestSubunitCluster.testMergeSequence", "method_implementation": "{\n    // Create an Atom Array of poly-alanine\n    Atom[] reprAtoms = mockAtomArray(100, \"ALA\", -1, null);\n    // Create two identical SubunitCluster\n    SubunitCluster sc1 = new SubunitCluster(new Subunit(reprAtoms, \"subunit 1\", null, null));\n    SubunitCluster sc2 = new SubunitCluster(new Subunit(reprAtoms, \"subunit 2\", null, null));\n    SubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n    clustererParameters.setSequenceIdentityThreshold(0.9);\n    clustererParameters.setSequenceCoverageThreshold(0.9);\n    boolean merged = sc1.mergeSequence(sc2, clustererParameters);\n    // Merged have to be true, and the merged SubunitCluster is sc1\n    assertTrue(merged);\n    assertEquals(2, sc1.size());\n    assertEquals(1, sc2.size());\n    assertEquals(100, sc1.length());\n    // Create an Atom Array of poly-glycine\n    Atom[] reprAtoms2 = mockAtomArray(100, \"GLY\", -1, null);\n    SubunitCluster sc3 = new SubunitCluster(new Subunit(reprAtoms2, \"subunit 3\", null, null));\n    merged = sc1.mergeSequence(sc3, clustererParameters);\n    // Merged have to be false, and Clusters result inmodified\n    assertFalse(merged);\n    assertEquals(2, sc1.size());\n    assertEquals(1, sc2.size());\n    assertEquals(100, sc1.length());\n    // Create an Atom Array of 9 glycine and 91 alanine\n    Atom[] reprAtoms3 = mockAtomArray(9, \"GLY\", 91, \"ALA\");\n    SubunitCluster sc4 = new SubunitCluster(new Subunit(reprAtoms3, \"subunit 4\", null, null));\n    merged = sc1.mergeSequence(sc4, clustererParameters);\n    // Merged have to be true, and the merged SubunitCluster is sc1\n    assertTrue(merged);\n    assertEquals(3, sc1.size());\n    assertEquals(1, sc2.size());\n    assertEquals(91, sc1.length());\n}", "repo_id": "9", "comment": "/**\n * Test {@link SubunitCluster#mergeSequence(SubunitCluster, SubunitClustererParameters)}\n *\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 2317, "method_signature": "void testMergeSequence()"}, "1101": {"callee_method_names": [], "method_name": "DownloadChemCompProvider.isDownloadAll", "method_implementation": "{\n    return downloadAll;\n}", "repo_id": "9", "comment": "/**\n * By default this provider will download only some of the {@link ChemComp} files.\n * The user has to request that all files should be downloaded by setting this parameter to true.\n *\n *  @return flag if the all components should be downloaded and installed at startup. (default: false)\n */\n", "repo_name": "biojava-master/", "id": 1101, "method_signature": "boolean isDownloadAll()"}, "2429": {"callee_method_ids": [2421], "callee_method_names": ["String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.indexOf", "String.charAt", "Location.isNegative", "String.indexOf", "String.substring", "String.indexOf", "String.substring", "String.substring"], "method_name": "GeneMarkGTFReader.parseLine", "method_implementation": "{\n    //FIXME update to use regex split on tabs\n    //FIXME better errors on parse failures\n    int start = 0;\n    int end = 0;\n    start = end;\n    end = s.indexOf('\\t', start);\n    String seqname = s.substring(start, end).trim();\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    String source = s.substring(start, end).trim();\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    String type = s.substring(start, end);\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    String locStart = s.substring(start, end);\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    String locEnd = s.substring(start, end);\n    Double score;\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    try {\n        score = Double.parseDouble(s.substring(start, end));\n    } catch (Exception e) {\n        score = 0.0;\n    }\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    char strand = s.charAt(end - 1);\n    Location location = Location.fromBio(Integer.parseInt(locStart), Integer.parseInt(locEnd), strand);\n    assert (strand == '-') == location.isNegative();\n    int frame;\n    start = end + 1;\n    end = s.indexOf('\\t', start);\n    try {\n        frame = Integer.parseInt(s.substring(start, end));\n    } catch (Exception e) {\n        frame = -1;\n    }\n    //grab everything until end of line (or # comment)\n    start = end + 1;\n    end = s.indexOf('#', start);\n    String attributes = null;\n    if (end < 0) {\n        attributes = s.substring(start);\n    } else {\n        attributes = s.substring(start, end);\n    }\n    return new Feature(seqname, source, type, location, score, frame, attributes);\n}", "repo_id": "9", "comment": "/**\n * create Feature from line of GFF file\n */\n", "repo_name": "biojava-master/", "id": 2429, "method_signature": "Feature parseLine(String)"}, "3055": {"callee_method_names": ["Path.getEnd", "Point.getPosition", "List<Location>.get", "List<Location>.size", "Point.getPosition", "Point.isUnknown", "Point.isUncertain"], "method_name": "LocationHelper.detectEnd", "method_implementation": "{\n    int end = 0;\n    Point lastPoint = null;\n    if (isCircular) {\n        for (Location sub : subLocations) {\n            lastPoint = sub.getEnd();\n            end += lastPoint.getPosition();\n        }\n    } else {\n        lastPoint = subLocations.get(subLocations.size() - 1).getEnd();\n        end = lastPoint.getPosition();\n    }\n    return new SimplePoint(end, lastPoint.isUnknown(), lastPoint.isUncertain());\n}", "repo_id": "9", "comment": "/**\n * This will attempt to find what the last point is and returns that\n * position. If the location is circular this will return the total length\n * of the location and does not mean the maximum point on the Sequence\n * we may find the locations on\n */\n", "repo_name": "biojava-master/", "id": 3055, "method_signature": "Point detectEnd(List, boolean)"}, "7": {"callee_method_names": ["List<PairwiseSequenceScorer<S, C>>.size"], "method_name": "GuideTree.getAllPairsScores", "method_implementation": "{\n    double[] scores = new double[scorers.size()];\n    int n = 0;\n    for (PairwiseSequenceScorer<S, C> scorer : scorers) {\n        scores[n++] = scorer.getScore();\n    }\n    return scores;\n}", "repo_id": "9", "comment": "/**\n * Returns a sequence pair score for all {@link Sequence} pairs in the given {@link List}.\n *\n * @return list of sequence pair scores\n */\n", "repo_name": "biojava-master/", "id": 7, "method_signature": "double[] getAllPairsScores()"}, "1729": {"callee_method_names": [], "method_name": "BasePairParameters.getStagger", "method_implementation": "{\n    checkArgument(bp);\n    return pairingParameters[bp][5];\n}", "repo_id": "9", "comment": "/**\n * This method returns the stagger in \u00c5 for the given base pair\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in \u00c5)\n */\n", "repo_name": "biojava-master/", "id": 1729, "method_signature": "Double getStagger(int)"}, "3013": {"callee_method_names": [], "method_name": "BitArrayWorker.shiftBy", "method_implementation": "{\n    return (byte) (((index - 1) % compoundsPerDatatype()) * bitsPerCompound());\n}", "repo_id": "9", "comment": "/**\n * Convert from bio to 0 index, remainder & then multiply by 2\n * <ul>\n * <li>Using 2bit encoding and working with position 19</li>\n * <li>19 is the 3rd position in the second int</li>\n * <li>Means a shift of 4 into that int to get the right data out</li>\n * <li>Also must convert into the non-bio index</li>\n * <li>19 - 1 = 18</li>\n * <li>18 % compoundsPerDatatype() (16) = 2</li>\n * <li>2 * bits per compound (2) = 4</li>\n * </ul>\n */\n", "repo_name": "biojava-master/", "id": 3013, "method_signature": "byte shiftBy(int)"}, "3719": {"callee_method_names": ["LinkedHashMap.put"], "method_name": "WorkSheet.markMetaDataColumns", "method_implementation": "{\n    for (String column : metaDataColumns) {\n        metaDataColumnsHashMap.put(column, column);\n    }\n}", "repo_id": "9", "comment": "/**\n * marks columns as containing meta data\n *\n * @param metaDataColumns\n */\n", "repo_name": "biojava-master/", "id": 3719, "method_signature": "void markMetaDataColumns(ArrayList)"}, "288": {"callee_method_names": [], "method_name": "ProteinModificationIdentifier.setRecordAdditionalAttachments", "method_implementation": "{\n    this.recordAdditionalAttachments = recordAdditionalAttachments;\n}", "repo_id": "9", "comment": "/**\n * @param recordAdditionalAttachments true if choosing to record additional attachments\n *  that are not directly attached to a modified residue.\n * @see #getRecordAdditionalAttachments\n */\n", "repo_name": "biojava-master/", "id": 288, "method_signature": "void setRecordAdditionalAttachments(boolean)"}, "2390": {"callee_method_names": [], "method_name": "Location.fromBio", "method_implementation": "{\n    int s = start - 1;\n    int e = end;\n    if (!(strand == '-' || strand == '+' || strand == '.')) {\n        throw new IllegalArgumentException(\"Strand must be '+', '-', or '.'\");\n    }\n    if (strand == '-') {\n        //negate\n        s = -end;\n        e = -(start - 1);\n    }\n    return new Location(s, e);\n}", "repo_id": "9", "comment": "/**\n * Create location from \"biocoordinates\", as in GFF file. In biocoordinates,\n * the start index of a range is represented in origin 1 (ie the very first index is 1, not 0),\n * and end= start + length - 1.\n *\n * @param start Origin 1 index of first symbol.\n * @param end Origin 1 index of last symbol.\n * @param strand '+' or '-' or '.' ('.' is interpreted as '+').\n * @return Created location.\n * @throws IllegalArgumentException strand must be '+', '-' or '.'\n */\n", "repo_name": "biojava-master/", "id": 2390, "method_signature": "Location fromBio(int, int, char)"}, "478": {"callee_method_names": [], "method_name": "AFPChain.getCoverage1", "method_implementation": "{\n    if (myResultsSimilarity1 < 0) {\n        int distance = ca1Length + ca2Length - 2 * getNrEQR();\n        int similarity = (ca1Length + ca2Length - distance) / 2;\n        myResultsSimilarity1 = Math.round(similarity / (float) ca1Length * 100);\n    }\n    return myResultsSimilarity1;\n}", "repo_id": "9", "comment": "/**\n * Get the coverage of protein 1 with the alignment\n *\n * @return percentage of coverage, between 0 and 100.\n */\n", "repo_name": "biojava-master/", "id": 478, "method_signature": "int getCoverage1()"}, "169": {"callee_method_names": ["ScopInstallation.setScopVersion", "ScopInstallation.getMirrors", "ArrayList<Object[]>.add"], "method_name": "ScopInstallationTest.availableDatabases", "method_implementation": "{\n    ArrayList<Object[]> databases = new ArrayList<Object[]>();\n    ScopInstallation scop;\n    for (String version : new String[] { ScopFactory.VERSION_1_75, ScopFactory.VERSION_1_73, ScopFactory.VERSION_1_71 }) {\n        scop = new ScopInstallation();\n        scop.setScopVersion(version);\n        // Don't fail if the server is down\n        boolean reachable = false;\n        for (ScopMirror mirror : scop.getMirrors()) {\n            if (mirror.isReachable()) {\n                reachable = true;\n                break;\n            }\n        }\n        Assume.assumeTrue(\"SCOP server is currently unreachable.\", reachable);\n        databases.add(new Object[] { version, scop });\n    }\n    return databases;\n}", "repo_id": "9", "comment": "//@Parameters\n", "repo_name": "biojava-master/", "id": 169, "method_signature": "Collection<Object[]> availableDatabases()"}, "2981": {"callee_method_names": [], "method_name": "JoiningSequenceReader.binarySearch", "method_implementation": "{\n    int[] minSeqIndex = getMinSequenceIndex();\n    int[] maxSeqIndex = getMaxSequenceIndex();\n    int low = 0;\n    int high = minSeqIndex.length - 1;\n    while (low <= high) {\n        //Go to the mid point in the array\n        int mid = (low + high) >>> 1;\n        //Get the max position represented by this Sequence\n        int midMinPosition = minSeqIndex[mid];\n        int midMaxPosition = maxSeqIndex[mid];\n        //if current position is greater than the current bounds then\n        //increase search space\n        if (midMinPosition < position && midMaxPosition < position) {\n            low = mid + 1;\n        } else //if current position is less than current bounds then decrease\n        //search space\n        if (midMinPosition > position && midMaxPosition > position) {\n            high = mid - 1;\n        } else {\n            return mid;\n        }\n    }\n    throw new IndexOutOfBoundsException(\"Given position \" + position + \" does not map into this Sequence\");\n}", "repo_id": "9", "comment": "/**\n * Scans through the sequence index arrays using binary search\n */\n", "repo_name": "biojava-master/", "id": 2981, "method_signature": "int binarySearch(int)"}, "3851": {"callee_method_names": ["HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put"], "method_name": "Constraints.initMolecularWeight", "method_implementation": "{\n    //\t\tAlanine (A)\t71.03711\t71.0788\n    aa2MolecularWeight.put(A, 71.0788);\n    //\t\tArginine (R)\t156.10111\t156.1875\n    aa2MolecularWeight.put(R, 156.1875);\n    //\t\tAsparagine (N)\t114.04293\t114.1038\n    aa2MolecularWeight.put(N, 114.1038);\n    //\t\tAspartic acid (D)\t115.02694\t115.0886\n    aa2MolecularWeight.put(D, 115.0886);\n    //\t\tCysteine (C)\t103.00919\t103.1388\n    aa2MolecularWeight.put(C, 103.1388);\n    //\t\tGlutamic acid (E)\t129.04259\t129.1155\n    aa2MolecularWeight.put(E, 129.1155);\n    //\t\tGlutamine (Q)\t128.05858\t128.1307\n    aa2MolecularWeight.put(Q, 128.1307);\n    //\t\tGlycine (G)\t57.02146\t57.0519\n    aa2MolecularWeight.put(G, 57.0519);\n    //\t\tHistidine (H)\t137.05891\t137.1411\n    aa2MolecularWeight.put(H, 137.1411);\n    //\t\tIsoleucine (I)\t113.08406\t113.1594\n    aa2MolecularWeight.put(I, 113.1594);\n    //\t\tLeucine (L)\t113.08406\t113.1594\n    aa2MolecularWeight.put(L, 113.1594);\n    //\t\tLysine (K)\t128.09496\t128.1741\n    aa2MolecularWeight.put(K, 128.1741);\n    //\t\tMethionine (M)\t131.04049\t131.1926\n    aa2MolecularWeight.put(M, 131.1926);\n    //\t\tPhenylalanine (F)\t147.06841\t147.1766\n    aa2MolecularWeight.put(F, 147.1766);\n    //\t\tProline (P)\t97.05276\t97.1167\n    aa2MolecularWeight.put(P, 97.1167);\n    //\t\tSerine (S)\t87.03203\t87.0782\n    aa2MolecularWeight.put(S, 87.0782);\n    //\t\tThreonine (T)\t101.04768\t101.1051\n    aa2MolecularWeight.put(T, 101.1051);\n    //\t\tTryptophan (W)\t186.07931\t186.2132\n    aa2MolecularWeight.put(W, 186.2132);\n    //\t\tTyrosine (Y)\t163.06333\t163.1760\n    aa2MolecularWeight.put(Y, 163.1760);\n    //\t\tValine (V)\t99.06841\t99.1326\n    aa2MolecularWeight.put(V, 99.1326);\n}", "repo_id": "9", "comment": "/**\n * Does the initialization of molecular weights based on http://au.expasy.org/tools/findmod/findmod_masses.html#AA\n */\n", "repo_name": "biojava-master/", "id": 3851, "method_signature": "void initMolecularWeight()"}, "2455": {"callee_method_names": [], "method_name": "Feature.score", "method_implementation": "{\n    return mScore;\n}", "repo_id": "9", "comment": "/**\n * Get score. (GFF field 7). The meaning of the score varies from file to file.\n *\n * @return Score value.\n */\n", "repo_name": "biojava-master/", "id": 2455, "method_signature": "double score()"}, "2421": {"callee_method_names": [], "method_name": "Location.isNegative", "method_implementation": "{\n    return (mStart <= 0 && mEnd <= 0);\n}", "repo_id": "9", "comment": "/**\n * Check if location is on negative strand.\n * Note that Location( 0, 0 ) is by construction defined to be on the\n * positive strand.\n *\n * @return True if on negative (reverse) strand.\n */\n", "repo_name": "biojava-master/", "id": 2421, "method_signature": "boolean isNegative()"}, "885": {"callee_method_names": [], "method_name": "StructureInterface.getSecondGroupAsas", "method_implementation": "{\n    return groupAsas2;\n}", "repo_id": "9", "comment": "/**\n * Gets a map of ResidueNumbers to GroupAsas for all groups of second chain.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 885, "method_signature": "Map<ResidueNumber,GroupAsa> getSecondGroupAsas()"}, "1072": {"callee_method_names": ["URL.getQuery", "String.isEmpty", "URL.getQuery", "Pair<Group>.indexOf", "Pair<Group>.substring", "Pair<Group>.length", "Pair<Group>.substring", "Map<String, String>.put", "String.toLowerCase"], "method_name": "URLIdentifier.parseQuery", "method_implementation": "{\n    Map<String, String> params = new LinkedHashMap<>();\n    String query = url.getQuery();\n    if (query == null || query.isEmpty()) {\n        // empty query\n        return params;\n    }\n    String[] pairs = url.getQuery().split(\"&\");\n    for (String pair : pairs) {\n        int i = pair.indexOf(\"=\");\n        String key = pair;\n        if (i > 0) {\n            key = URLDecoder.decode(pair.substring(0, i), \"UTF-8\");\n        }\n        String value = null;\n        if (i > 0 && pair.length() > i + 1) {\n            value = URLDecoder.decode(pair.substring(i + 1), \"UTF-8\");\n        }\n        // note that this uses the last instance if a parameter is specified multiple times\n        params.put(key.toLowerCase(), value);\n    }\n    return params;\n}", "repo_id": "9", "comment": "/**\n * Parses URL parameters into a map. Keys are stored lower-case.\n *\n * @param url\n * @return\n * @throws UnsupportedEncodingException\n */\n", "repo_name": "biojava-master/", "id": 1072, "method_signature": "Map<String,String> parseQuery(URL)"}, "3139": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getUniprotbaseURL", "method_implementation": "{\n    return uniprotbaseURL;\n}", "repo_id": "9", "comment": "/**\n * The current UniProt URL to deal with caching issues. www.uniprot.org is load balanced\n * but you can access pir.uniprot.org directly.\n * @return the uniprotbaseURL\n */\n", "repo_name": "biojava-master/", "id": 3139, "method_signature": "String getUniprotbaseURL()"}, "287": {"callee_method_names": [], "method_name": "ProteinModificationIdentifier.getRecordUnidentifiableCompounds", "method_implementation": "{\n    return recordUnidentifiableModifiedCompounds;\n}", "repo_id": "9", "comment": "/**\n * @return true if choosing to record unidentifiable\n *  atoms; false, otherwise.\n * @see #setRecordUnidentifiableCompounds\n * @see #getUnidentifiableModifiedResidues\n * @see #getUnidentifiableAtomLinkages\n */\n", "repo_name": "biojava-master/", "id": 287, "method_signature": "boolean getRecordUnidentifiableCompounds()"}, "508": {"callee_method_names": [], "method_name": "AFPChain.getDescription2", "method_implementation": "{\n    return description2;\n}", "repo_id": "9", "comment": "/**\n * Get a textual description for the protein 2 of the alignment.\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 508, "method_signature": "String getDescription2()"}, "548": {"callee_method_names": [], "method_name": "StructurePairAligner.setParams", "method_implementation": "{\n    this.params = params;\n}", "repo_id": "9", "comment": "/**\n * set the parameters to be used for the algorithm\n *\n * @param params\n *            the Parameter object\n */\n", "repo_name": "biojava-master/", "id": 548, "method_signature": "void setParams(StrucAligParameters)"}, "1120": {"callee_method_names": [], "method_name": "SiftsChainEntry.getSeqresStart", "method_implementation": "{\n    return seqresStart;\n}", "repo_id": "9", "comment": "/**\n * @return A residue number\n */\n", "repo_name": "biojava-master/", "id": 1120, "method_signature": "String getSeqresStart()"}, "3079": {"callee_method_names": ["AminoAcidCompound.toString", "AminoAcidCompound.getLongName"], "method_name": "AminoAcidCompound.equals", "method_implementation": "{\n    if (obj == null) {\n        return false;\n    }\n    if (!(obj instanceof AminoAcidCompound)) {\n        return false;\n    }\n    AminoAcidCompound them = (AminoAcidCompound) obj;\n    if (toString().equals(them.toString())) {\n        return true;\n    }\n    return getLongName().equals(them.getLongName());\n}", "repo_id": "9", "comment": "// TODO need to allow for modified name; that's not equality though is it?\n", "repo_name": "biojava-master/", "id": 3079, "method_signature": "boolean equals(Object)"}, "3133": {"callee_method_names": ["Document.getDocumentElement", "ArrayList<String>.add", "Element.getTextContent"], "method_name": "UniprotProxySequenceReader.getGeneAliases", "method_implementation": "{\n    ArrayList<String> aliasList = new ArrayList<String>();\n    if (uniprotDoc == null) {\n        return aliasList;\n    }\n    Element uniprotElement = uniprotDoc.getDocumentElement();\n    Element entryElement = XMLHelper.selectSingleElement(uniprotElement, \"entry\");\n    ArrayList<Element> proteinElements = XMLHelper.selectElements(entryElement, \"gene\");\n    for (Element proteinElement : proteinElements) {\n        ArrayList<Element> keyWordElementList = XMLHelper.selectElements(proteinElement, \"name\");\n        for (Element element : keyWordElementList) {\n            aliasList.add(element.getTextContent());\n        }\n    }\n    return aliasList;\n}", "repo_id": "9", "comment": "/**\n * Pull uniprot gene aliases associated with this sequence\n * @return\n * @throws XPathExpressionException\n */\n", "repo_name": "biojava-master/", "id": 3133, "method_signature": "ArrayList<String> getGeneAliases()"}, "648": {"callee_method_ids": [487, 490, 489, 493, 494], "callee_method_names": ["AFPChain.getAlnsymb", "AFPChain.getAlnseq1", "AFPChain.getAlnseq2", "AFPChain.setAlnseq1", "AFPChain.setAlnseq2", "AFPChain.setAlnsymb", "AFPChain.getBlockNum", "AFPChain.getOptLen", "AFPChain.getOptAln", "AFPChain.getAlnbeg1", "AFPChain.getAlnbeg2", "AFPChain.getOptLength", "Logger.warn", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "String.charAt", "AFPChain.setOptAln", "AFPChain.setOptLen", "AFPChain.setAlnbeg1", "AFPChain.setAlnbeg2", "AFPChain.setAlnLength", "AFPChain.setGapLen"], "method_name": "AFPAlignmentDisplay.getAlign", "method_implementation": "{\n    char[] alnsymb = afpChain.getAlnsymb();\n    char[] alnseq1 = afpChain.getAlnseq1();\n    char[] alnseq2 = afpChain.getAlnseq2();\n    int i, j, k, p1, p2, p1b, p2b, lmax;\n    int pro1Len = ca1.length;\n    int pro2Len = ca2.length;\n    p1b = p2b = 0;\n    if (alnsymb == null) {\n        alnseq1 = new char[pro1Len + pro2Len + 1];\n        alnseq2 = new char[pro1Len + pro2Len + 1];\n        alnsymb = new char[pro1Len + pro2Len + 1];\n        afpChain.setAlnseq1(alnseq1);\n        afpChain.setAlnseq2(alnseq2);\n        afpChain.setAlnsymb(alnsymb);\n    }\n    int blockNum = afpChain.getBlockNum();\n    int[] optLen = afpChain.getOptLen();\n    int[][][] optAln = afpChain.getOptAln();\n    // immediately overwritten\n    int alnbeg1 = afpChain.getAlnbeg1();\n    // immediately overwritten\n    int alnbeg2 = afpChain.getAlnbeg2();\n    // immediately overwritten\n    int alnLength;\n    int optLength = afpChain.getOptLength();\n    if (optLen == null) {\n        optLen = new int[blockNum];\n        for (int oi = 0; oi < blockNum; oi++) optLen[oi] = 0;\n    }\n    int len = 0;\n    for (i = 0; i < blockNum; i++) {\n        for (j = 0; j < optLen[i]; j++) {\n            p1 = optAln[i][0][j];\n            p2 = optAln[i][1][j];\n            // weird, could not find a residue in the Atom array. Did something change in the underlying data?\n            if ((p1 == -1) || (p2 == -1)) {\n                logger.warn(\"Could not get atom on position \" + j);\n                continue;\n            }\n            if (len > 0) {\n                lmax = (p1 - p1b - 1) > (p2 - p2b - 1) ? (p1 - p1b - 1) : (p2 - p2b - 1);\n                for (k = 0; k < lmax; k++) {\n                    if (k >= (p1 - p1b - 1))\n                        alnseq1[len] = '-';\n                    else {\n                        char oneletter = getOneLetter(ca1[p1b + 1 + k].getGroup());\n                        alnseq1[len] = oneletter;\n                    }\n                    if (k >= (p2 - p2b - 1))\n                        alnseq2[len] = '-';\n                    else {\n                        char oneletter = getOneLetter(ca2[p2b + 1 + k].getGroup());\n                        alnseq2[len] = oneletter;\n                    }\n                    alnsymb[len++] = ' ';\n                }\n            } else {\n                //the first position of sequence in alignment\n                alnbeg1 = p1;\n                alnbeg2 = p2;\n            }\n            if (p1 < ca1.length && p2 < ca2.length) {\n                alnseq1[len] = getOneLetter(ca1[p1].getGroup());\n                alnseq2[len] = getOneLetter(ca2[p2].getGroup());\n            } else {\n                //TODO handle permutations\n                alnseq1[len] = '?';\n                alnseq2[len] = '?';\n            }\n            if (showSeq) {\n                if (alnseq1[len] == alnseq2[len]) {\n                    alnsymb[len++] = '|';\n                } else {\n                    double score = aaScore(alnseq1[len], alnseq2[len]);\n                    if (score > 1)\n                        alnsymb[len++] = ':';\n                    else\n                        alnsymb[len++] = '.';\n                }\n            } else {\n                String tmpS = String.format(\"%d\", i + 1);\n                alnsymb[len++] = tmpS.charAt(0);\n            }\n            p1b = p1;\n            p2b = p2;\n        }\n    }\n    alnLength = len;\n    afpChain.setOptAln(optAln);\n    afpChain.setOptLen(optLen);\n    afpChain.setAlnbeg1(alnbeg1);\n    afpChain.setAlnbeg2(alnbeg2);\n    afpChain.setAlnLength(alnLength);\n    afpChain.setGapLen(alnLength - optLength);\n}", "repo_id": "9", "comment": "/**\n * Sets the following properties:\n * <ul>\n * <li>The alignment strings {@link AFPChain#setAlnseq1(char[]) alnseq1},\n *  {@link AFPChain#setAlnseq2(char[]) alnseq2},\n *  and {@link AFPChain#setAlnsymb(char[]) alnsymb}</li>\n * <li>{@link AFPChain#setAlnbeg1(int) alnbeg1} and 2</li>\n * <li>{@link AFPChain#setAlnLength(int) alnLength} and\n *  {@link AFPChain#setGapLen(int) gapLen}</li>\n * </ul>\n * <p>\n * Expects the following properties to be previously computed:\n * <ul>\n * <li>{@link AFPChain#getOptAln()} and lengths\n * </ul>\n *\n * <section>Known Bugs</section>\n * Expects the alignment to have linear topology. May give odd results\n * for circular permutations and other complicated topologies.\n *\n * @param afpChain Alignment between ca1 and ca2\n * @param ca1 CA atoms of the first protein\n * @param ca2 CA atoms of the second protein\n * @param showSeq Use symbols reflecting sequence similarity: '|' for identical,\n *  ':' for similar, '.' for dissimilar. Otherwise, use the block number\n *  to show aligned residues.\n */\n", "repo_name": "biojava-master/", "id": 648, "method_signature": "void getAlign(AFPChain, Atom[], Atom[], boolean)"}, "1957": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setSymDeviation", "method_implementation": "{\n    this.symDeviation = symDeviation;\n}", "repo_id": "9", "comment": "/**\n * @param symDeviation the symDeviation to set\n */\n", "repo_name": "biojava-master/", "id": 1957, "method_signature": "void setSymDeviation(double)"}, "1654": {"callee_method_names": ["List<Subunit>.size", "List<Subunit>.get", "List<Subunit>.get", "List<Subunit>.get", "List<Integer>.add", "List<Subunit>.get", "List<Integer>.size", "List<Integer>.size", "List<Integer>.size", "List<Integer>.get", "List<Integer>.size", "List<Integer>.get", "List<Integer>.get"], "method_name": "SubunitExtractor.calcAdjustedMinimumSequenceLength", "method_implementation": "{\n    int maxLength = Integer.MIN_VALUE;\n    int minLength = Integer.MAX_VALUE;\n    // Extract the length List, the min and the max\n    List<Integer> lengths = new ArrayList<Integer>();\n    for (int i = 0; i < subunits.size(); i++) {\n        if (subunits.get(i).size() >= absMinLen) {\n            maxLength = Math.max(subunits.get(i).size(), maxLength);\n            minLength = Math.min(subunits.get(i).size(), minLength);\n            lengths.add(subunits.get(i).size());\n        }\n    }\n    int adjustedMinimumSequenceLength = minLen;\n    if (lengths.size() < 2)\n        return adjustedMinimumSequenceLength;\n    // Calculate the median of the lengths\n    double median = 0;\n    Collections.sort(lengths);\n    if (lengths.size() % 2 == 1) {\n        int middle = (lengths.size() - 1) / 2;\n        median = lengths.get(middle);\n    } else {\n        int middle2 = lengths.size() / 2;\n        int middle1 = middle2 - 1;\n        median = 0.5 * (lengths.get(middle1) + lengths.get(middle2));\n    }\n    // If the median * fraction is lower than the minLength\n    if (minLength >= median * fraction) {\n        adjustedMinimumSequenceLength = Math.min(minLength, minLen);\n    }\n    return adjustedMinimumSequenceLength;\n}", "repo_id": "9", "comment": "/**\n * Returns an adapted minimum sequence length. This method ensure that\n * structure that only have short chains are not excluded by the\n * minimumSequenceLength cutoff value.\n *\n * @return adjustedMinimumSequenceLength\n */\n", "repo_name": "biojava-master/", "id": 1654, "method_signature": "int calcAdjustedMinimumSequenceLength(List, int, double, int)"}, "1525": {"callee_method_names": [], "method_name": "JournalArticle.getDoi", "method_implementation": "{\n    return doi;\n}", "repo_id": "9", "comment": "/**\n * Get the value of DOI field.\n * For example: 10.1016/S0969-2126(02)00720-7\n *\n * @return the value of doi\n */\n", "repo_name": "biojava-master/", "id": 1525, "method_signature": "String getDoi()"}, "2042": {"callee_method_ids": [2054], "callee_method_names": ["CeSymmResult.isRefined", "CeSymmResult.getMultipleAlignment", "CeSymmResult.getAtoms", "CeSymmResult.getRepeatsID", "Structure.addModel", "Structure.setStructureIdentifier", "List<StructureIdentifier>.get", "CeSymmResult.getMultipleAlignment", "Block.getStartResidue", "Block.getFinalResidue", "Atom[].getGroup", "List<Atom>.addAll", "Group.getAtoms", "List<Atom>.toArray", "List<Atom>.size", "Logger.warn", "List<Group>.size", "CeSymmResult.getMultipleAlignment", "List<Structure>.add"], "method_name": "SymmetryTools.divideStructure", "method_implementation": "{\n    if (!symmetry.isRefined())\n        throw new IllegalArgumentException(\"The symmetry result \" + \"is not refined, repeats cannot be defined\");\n    int order = symmetry.getMultipleAlignment().size();\n    Atom[] atoms = symmetry.getAtoms();\n    Set<Group> allGroups = StructureTools.getAllGroupsFromSubset(atoms, GroupType.HETATM);\n    List<StructureIdentifier> repeatsId = symmetry.getRepeatsID();\n    List<Structure> repeats = new ArrayList<Structure>(order);\n    // Create new structure containing the repeat atoms\n    for (int i = 0; i < order; i++) {\n        Structure s = new StructureImpl();\n        s.addModel(new ArrayList<Chain>(1));\n        s.setStructureIdentifier(repeatsId.get(i));\n        Block align = symmetry.getMultipleAlignment().getBlock(0);\n        // Get the start and end of the repeat\n        // Repeats are always sequential blocks\n        int res1 = align.getStartResidue(i);\n        int res2 = align.getFinalResidue(i);\n        // All atoms from the repeat, used for ligand search\n        // AA have an average of 8.45 atoms, so guess capacity with that\n        List<Atom> repeat = new ArrayList<>(Math.max(9 * (res2 - res1 + 1), 9));\n        // speedy chain lookup\n        Chain prevChain = null;\n        for (int k = res1; k <= res2; k++) {\n            Group g = atoms[k].getGroup();\n            prevChain = StructureTools.addGroupToStructure(s, g, 0, prevChain, true);\n            repeat.addAll(g.getAtoms());\n        }\n        List<Group> ligands = StructureTools.getLigandsByProximity(allGroups, repeat.toArray(new Atom[repeat.size()]), StructureTools.DEFAULT_LIGAND_PROXIMITY_CUTOFF);\n        logger.warn(\"Adding {} ligands to {}\", ligands.size(), symmetry.getMultipleAlignment().getStructureIdentifier(i));\n        for (Group ligand : ligands) {\n            prevChain = StructureTools.addGroupToStructure(s, ligand, 0, prevChain, true);\n        }\n        repeats.add(s);\n    }\n    return repeats;\n}", "repo_id": "9", "comment": "/**\n * Method that converts the symmetric units of a structure into different\n * structures, so that they can be individually visualized.\n *\n * @param symmetry\n *            CeSymmResult\n * @throws StructureException\n * @result List of structures, by repeat index sequentially\n */\n", "repo_name": "biojava-master/", "id": 2042, "method_signature": "List<Structure> divideStructure(CeSymmResult)"}, "3391": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.showPolyhedron", "method_implementation": "{\n    return \"draw polyhedron* on;\";\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#showPolyhedron()\n\t */\n", "repo_name": "biojava-master/", "id": 3391, "method_signature": "String showPolyhedron()"}, "98": {"callee_method_names": ["S.getAsList", "SubstitutionMatrix<C>.getRow"], "method_name": "SubstitutionMatrixScorer.getMaxScore", "method_implementation": "{\n    // assume nothing about the matrix\n    double score = 0;\n    for (C queryC : query.getAsList()) {\n        short max = Short.MIN_VALUE;\n        for (Short value : matrix.getRow(queryC).values()) {\n            if (value > max)\n                max = value;\n        }\n        score += max;\n    }\n    return score;\n}", "repo_id": "9", "comment": "/**\n * @return The maximum score the query could be assigned when aligned against any target sequence.\n */\n", "repo_name": "biojava-master/", "id": 98, "method_signature": "double getMaxScore()"}, "1400": {"callee_method_names": [], "method_name": "PdbId.getId", "method_implementation": "{\n    if (prefereShort && isInternalShortCompatible(idCode))\n        return internalToShortNoCheck(idCode);\n    return PREFIX_PDB_ + idCode;\n}", "repo_id": "9", "comment": "/**\n * Get a <code>String</code> representation of this PdbId instance, using the <i>passed in</i> behavior.<br>\n * @param prefereShort when it is <code>true</code>, the class will try to produce the short ID whenever possible.\n * @return The PdbId in short format if possible and <code>prefereShort</code> is <code>true</code>, the extended PDB ID form otherwise.\n */\n", "repo_name": "biojava-master/", "id": 1400, "method_signature": "String getId(boolean)"}, "2913": {"callee_method_names": [], "method_name": "AbstractSequence.setParentSequence", "method_implementation": "{\n    this.parentSequence = parentSequence;\n}", "repo_id": "9", "comment": "/**\n * @param parentSequence the parentSequence to set\n */\n", "repo_name": "biojava-master/", "id": 2913, "method_signature": "void setParentSequence(AbstractSequence)"}, "173": {"callee_method_names": [], "method_name": "StringManipulationTestsHelper.assertEqualsIgnoreEndline", "method_implementation": "{\n    Assert.assertTrue(StringManipulationHelper.equalsToIgnoreEndline(expected, actual));\n}", "repo_id": "9", "comment": "/**\n * Asserts that two strings are equal, line by line, ignoring any difference\n * of end line delimiters contained within the 2 Strings. This method should\n * be used if and only if two XMLs are considered identical when all nodes\n * are identical including their relative order. Generally useful when\n * asserting identity of <b>automatically regenerated</b> XML.\n *\n * @param expected\n * @param actual\n */\n", "repo_name": "biojava-master/", "id": 173, "method_signature": "void assertEqualsIgnoreEndline(String, String)"}, "3390": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.hidePolyhedron", "method_implementation": "{\n    return \"draw polyhedron* off;\";\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#hidePolyhedron()\n\t */\n", "repo_name": "biojava-master/", "id": 3390, "method_signature": "String hidePolyhedron()"}, "3632": {"callee_method_names": [], "method_name": "CoxInfo.setScoreLogrankTest", "method_implementation": "{\n    this.scoreLogrankTest = scoreLogrankTest;\n}", "repo_id": "9", "comment": "/**\n * @param scoreLogrankTest the scoreLogrankTest to set\n */\n", "repo_name": "biojava-master/", "id": 3632, "method_signature": "void setScoreLogrankTest(Double)"}, "2314": {"callee_method_names": ["Structure.addModel", "Structure.addChain", "Chain.getStructure", "Chain.addGroup", "Group.getChain", "Group.addAtom", "Group.getChain", "Atom.clone", "Structure.addModel", "Structure.addChain", "Chain.addGroup", "Group.addAtom", "Atom.getGroup", "Atom.getGroup", "Group.clone", "Group.getAtom", "Structure.addModel", "Structure.addChain", "Chain.addGroup", "Group.getChain", "Atom.getGroup", "Group.getChain", "Atom.getGroup"], "method_name": "TestStructureImpl.testLinks", "method_implementation": "{\n    // Create new Structure and assign one Chain to it\n    Structure s1 = new StructureImpl();\n    s1.addModel(new ArrayList<Chain>(1));\n    Chain c1 = new ChainImpl();\n    s1.addChain(c1);\n    // Test that chains parent is s1\n    assertEquals(s1, c1.getStructure());\n    // Populate the Chain with one Group\n    Group g1 = new HetatomImpl();\n    c1.addGroup(g1);\n    // Test that the group parent is c1\n    assertEquals(c1, g1.getChain());\n    // Add a single Atom to the Group\n    Atom a1 = new AtomImpl();\n    g1.addAtom(a1);\n    // Test that the atom parent is g1\n    assertEquals(c1, g1.getChain());\n    // Now clone the Atom and assign it to a second structure\n    Atom a2 = (Atom) a1.clone();\n    Structure s2 = new StructureImpl();\n    s2.addModel(new ArrayList<Chain>(1));\n    Chain c2 = new ChainImpl();\n    s2.addChain(c2);\n    Group g2 = new HetatomImpl();\n    c2.addGroup(g2);\n    g2.addAtom(a2);\n    // Test correct parent links in Atoms\n    assertEquals(g1, a1.getGroup());\n    assertEquals(g2, a2.getGroup());\n    // Now clone the Group and assign it to new third structure\n    Group g3 = (Group) g1.clone();\n    Atom a3 = g3.getAtom(0);\n    Structure s3 = new StructureImpl();\n    s3.addModel(new ArrayList<Chain>(1));\n    Chain c3 = new ChainImpl();\n    s3.addChain(c3);\n    c3.addGroup(g3);\n    // Test correct parent links in Groups and Atoms\n    assertEquals(c1, g1.getChain());\n    assertEquals(g1, a1.getGroup());\n    assertEquals(c3, g3.getChain());\n    assertEquals(g3, a3.getGroup());\n}", "repo_id": "9", "comment": "/**\n * This tests the correctness of the Links between the different objects\n * that create a Structure (Chains, Groups, Atoms). The correct behavior is\n * that objects higher in the hierarchy should set the links of lower level\n * objects.\n */\n", "repo_name": "biojava-master/", "id": 2314, "method_signature": "void testLinks()"}, "2283": {"callee_method_names": ["Diff.overrideElementQualifier", "Diff.similar", "FileReader.close", "FileReader.close"], "method_name": "FastaAFPChainConverterTest.compareXml", "method_implementation": "{\n    try {\n        FileReader expectedFr = new FileReader(expectedFile);\n        FileReader actualFr = new FileReader(actualFile);\n        Diff diff = new Diff(expectedFr, actualFr);\n        // ignore order\n        // look at element, id, and weight (weight is a nested element)\n        diff.overrideElementQualifier(new RecursiveElementNameAndTextQualifier());\n        final boolean isSimilar = diff.similar();\n        if (!isSimilar)\n            printDetailedDiff(diff, System.err);\n        expectedFr.close();\n        actualFr.close();\n        return isSimilar;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    } catch (SAXException e) {\n        throw new RuntimeException(e);\n    }\n}", "repo_id": "9", "comment": "/**\n * Compares two XML files without regard to the order of elements or attributes, and ignoring any element named \\\"releaseDate\\\".\n * @return Whether the files are \\\"similar\\\"\n */\n", "repo_name": "biojava-master/", "id": 2283, "method_signature": "boolean compareXml(File, File)"}, "666": {"callee_method_names": ["MultipleAlignment.size", "MultipleAlignment.size", "MultipleAlignment.size", "MultipleAlignment.size", "Matrix.set", "List<Atom[]>.add", "List<Atom[]>.get", "List<Atom[]>.add", "List<Atom[]>.get", "Matrix.set", "Matrix.set"], "method_name": "MultipleAlignmentTools.getRMSDMatrix", "method_implementation": "{\n    Matrix rmsdMat = new Matrix(msa.size(), msa.size());\n    List<Atom[]> superposed = transformAtoms(msa);\n    for (int i = 0; i < msa.size(); i++) {\n        for (int j = i; j < msa.size(); j++) {\n            if (i == j)\n                rmsdMat.set(i, j, 0.0);\n            List<Atom[]> compared = new ArrayList<Atom[]>();\n            compared.add(superposed.get(i));\n            compared.add(superposed.get(j));\n            double rmsd = MultipleAlignmentScorer.getRMSD(compared);\n            rmsdMat.set(i, j, rmsd);\n            rmsdMat.set(j, i, rmsd);\n        }\n    }\n    return rmsdMat;\n}", "repo_id": "9", "comment": "/**\n * Calculate the RMSD matrix of a MultipleAlignment, that is, entry (i,j) of\n * the matrix contains the RMSD between structures i and j.\n *\n * @param msa\n *            Multiple Structure Alignment\n * @return Matrix of RMSD with size the number of structures squared\n */\n", "repo_name": "biojava-master/", "id": 666, "method_signature": "Matrix getRMSDMatrix(MultipleAlignment)"}, "1261": {"callee_method_names": [], "method_name": "MmtfStructureReader.getStructure", "method_implementation": "{\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * Gets the structure.\n *\n * @return the structure\n */\n", "repo_name": "biojava-master/", "id": 1261, "method_signature": "Structure getStructure()"}, "2632": {"callee_method_names": [], "method_name": "SequenceOptimizationHints.getSequenceCollection", "method_implementation": "{\n    return sequenceCollection;\n}", "repo_id": "9", "comment": "/**\n * @return the sequenceColection\n */\n", "repo_name": "biojava-master/", "id": 2632, "method_signature": "SequenceCollection getSequenceCollection()"}, "1816": {"callee_method_names": [], "method_name": "EcodInstallation.getUpdateFrequency", "method_implementation": "{\n    return updateFrequency;\n}", "repo_id": "9", "comment": "/**\n * The expected ECOD update frequency determines whether the version\n * \"latest\" should be re-downloaded\n * @return the expected ECOD update frequency, in days\n */\n", "repo_name": "biojava-master/", "id": 1816, "method_signature": "Integer getUpdateFrequency()"}, "3365": {"callee_method_names": [], "method_name": "DefaultMatrixMapper.getScalevalue", "method_implementation": "{\n    return scalevalue;\n}", "repo_id": "9", "comment": "/**\n * @return the scalevalue\n */\n", "repo_name": "biojava-master/", "id": 3365, "method_signature": "double getScalevalue()"}, "1703": {"callee_method_names": ["Block.getAtomA", "Block.getAtomB"], "method_name": "AtomImpl.hasBond", "method_implementation": "{\n    if (bonds == null)\n        return false;\n    for (Bond b : bonds) {\n        if (b.getAtomA().equals(other) || b.getAtomB().equals(other))\n            return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1703, "method_signature": "boolean hasBond(Atom)"}, "415": {"callee_method_names": ["AFP.getP1", "AFP.getP1", "AFP.getFragLen", "AFP.getP2", "AFP.getP2", "AFP.getFragLen"], "method_name": "AFPChainer.calcMismatch", "method_implementation": "{\n    int l1 = afp1.getP1() - afp2.getP1() - afp2.getFragLen();\n    int l2 = afp1.getP2() - afp2.getP2() - afp2.getFragLen();\n    return (l1 > l2 ? l2 : l1);\n}", "repo_id": "9", "comment": "//--------------------------------------------\n", "repo_name": "biojava-master/", "id": 415, "method_signature": "int calcMismatch(AFP, AFP)"}, "59": {"callee_method_names": ["List<C>.get", "List<C>.get"], "method_name": "AbstractProfileProfileAligner.getSubstitutionScore", "method_implementation": "{\n    float score = 0.0f;\n    for (int q = 0; q < qv.length; q++) {\n        if (qv[q] > 0.0f) {\n            for (int t = 0; t < tv.length; t++) {\n                if (tv[t] > 0.0f) {\n                    score += qv[q] * tv[t] * getSubstitutionMatrix().getValue(cslist.get(q), cslist.get(t));\n                }\n            }\n        }\n    }\n    return Math.round(score);\n}", "repo_id": "9", "comment": "// helper method that scores alignment of two column vectors\n", "repo_name": "biojava-master/", "id": 59, "method_signature": "int getSubstitutionScore(float[], float[])"}, "3520": {"callee_method_names": [], "method_name": "StrataInfo.getStatus", "method_implementation": "{\n    return status;\n}", "repo_id": "9", "comment": "/**\n * @return the status\n */\n", "repo_name": "biojava-master/", "id": 3520, "method_signature": "ArrayList<Integer> getStatus()"}, "3547": {"callee_method_names": [], "method_name": "CoxCoefficient.setHazardRatioLoCI", "method_implementation": "{\n    this.hazardRatioLoCI = hazardRatioLoCI;\n}", "repo_id": "9", "comment": "/**\n * @param hazardRatioLoCI the hazardRatioLoCI to set\n */\n", "repo_name": "biojava-master/", "id": 3547, "method_signature": "void setHazardRatioLoCI(double)"}, "2200": {"callee_method_ids": [619, 1004, 1002], "callee_method_names": ["AtomCache.getAtoms", "AtomPositionMap.getNavMap", "NavigableMap<ResidueNumber, Integer>.keySet", "AtomPositionMap.getPosition", "NavigableMap<ResidueNumber, Integer>.get", "AtomPositionMap.getLength"], "method_name": "AtomPositionMapTest.testEasy", "method_implementation": "{\n    // no insertion codes\n    // Straightforward case. Density for residues 25-777 (743 residues)\n    String pdbId = \"1w0p\";\n    int length = 93;\n    ResidueNumber start = new ResidueNumber(\"A\", 25, null);\n    ResidueNumber end = new ResidueNumber(\"A\", 117, null);\n    AtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n    NavigableMap<ResidueNumber, Integer> navMap = map.getNavMap();\n    for (ResidueNumber n : navMap.keySet()) {\n        assertEquals(\"An element is missing\", map.getPosition(n).intValue(), navMap.get(n).intValue());\n    }\n    int realLength = map.getLength(start, end);\n    assertEquals(\"Real atom length is wrong\", length, realLength);\n}", "repo_id": "9", "comment": "/**\n * Tests with no insertion codes.\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2200, "method_signature": "void testEasy()"}, "1864": {"callee_method_names": [], "method_name": "Rotation.setScores", "method_implementation": "{\n    this.scores = scores;\n}", "repo_id": "9", "comment": "/**\n * @param scores the scores to set\n */\n", "repo_name": "biojava-master/", "id": 1864, "method_signature": "void setScores(QuatSymmetryScores)"}, "3201": {"callee_method_names": ["URL.getFile"], "method_name": "SearchIOTest.testConstructorWithEvalueHspFilter", "method_implementation": "{\n    //\n    String resource = \"/org/biojava/nbio/core/search/io/blast/testBlastReport.blastxml\";\n    URL resourceURL = getClass().getResource(resource);\n    File file = new File(resourceURL.getFile());\n    ResultFactory blastResultFactory = new BlastXMLParser();\n    final SearchIO instance;\n    try {\n        instance = new SearchIO(file, blastResultFactory, 10e-10);\n    } catch (Exception e) {\n        fail(\"test failed:\\n\" + e.getMessage());\n    }\n}", "repo_id": "9", "comment": "/**\n * Constructor test specifying Factory and using a evalue threshold filter\n */\n", "repo_name": "biojava-master/", "id": 3201, "method_signature": "void testConstructorWithEvalueHspFilter()"}, "2060": {"callee_method_ids": [2092], "callee_method_names": ["List<CeSymmResult>.size", "List<CeSymmResult>.get", "MultipleAlignment.getBlockSet", "List<CeSymmResult>.get", "MultipleAlignment.size", "SymmetryAxes.addAxis"], "method_name": "CeSymmIterative.recoverAxes", "method_implementation": "{\n    SymmetryAxes axes = new SymmetryAxes();\n    for (int m = 0; m < levels.size(); m++) {\n        MultipleAlignment align = levels.get(m).getMultipleAlignment();\n        Matrix4d axis = align.getBlockSet(0).getTransformations().get(1);\n        SymmetryType type = levels.get(m).getAxes().getElementaryAxis(0).getSymmType();\n        int order = align.size();\n        axes.addAxis(axis, order, type);\n    }\n    return axes;\n}", "repo_id": "9", "comment": "/**\n * The symmetry axes of each level are recovered after the symmetry analysis\n * iterations have finished, using the stored MultipleAlignment at each\n * symmetry level.\n * @return SymmetryAxes\n */\n", "repo_name": "biojava-master/", "id": 2060, "method_signature": "SymmetryAxes recoverAxes(CeSymmResult)"}, "3278": {"callee_method_names": [], "method_name": "JmolPanel.destroy", "method_implementation": "{\n    executeCmd(\"zap;\");\n    structure = null;\n    viewer = null;\n    adapter = null;\n}", "repo_id": "9", "comment": "/**\n * Clean up this instance for garbage collection, to avoid memory leaks...\n */\n", "repo_name": "biojava-master/", "id": 3278, "method_signature": "void destroy()"}, "120": {"callee_method_names": ["NeedlemanWunsch<DNASequence, NucleotideCompound>.addAnchor", "NeedlemanWunsch<DNASequence, NucleotideCompound>.addAnchor", "NeedlemanWunsch<DNASequence, NucleotideCompound>.addAnchor", "NeedlemanWunsch<DNASequence, NucleotideCompound>.addAnchor", "NeedlemanWunsch<DNASequence, NucleotideCompound>.getScore", "NeedlemanWunsch<DNASequence, NucleotideCompound>.getScore"], "method_name": "NeedlemanWunschTest.anchors_should_not_change_score", "method_implementation": "{\n    DNASequence query = new DNASequence(\"ACGT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"ACGT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    NeedlemanWunsch<DNASequence, NucleotideCompound> aligner = new NeedlemanWunsch<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 5, (short) 10), SubstitutionMatrixHelper.getNuc4_4());\n    NeedlemanWunsch<DNASequence, NucleotideCompound> anchored = new NeedlemanWunsch<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 5, (short) 10), SubstitutionMatrixHelper.getNuc4_4());\n    anchored.addAnchor(0, 0);\n    anchored.addAnchor(1, 1);\n    anchored.addAnchor(2, 2);\n    anchored.addAnchor(3, 3);\n    assertEquals(aligner.getScore(), anchored.getScore(), PRECISION);\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 120, "method_signature": "void anchors_should_not_change_score()"}, "3505": {"callee_method_names": [], "method_name": "ChiSq.norm", "method_implementation": "{\n    return ChiSq.chiSq(z * z, 1);\n}", "repo_id": "9", "comment": "/**\n * @param z\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3505, "method_signature": "double norm(double)"}, "1374": {"callee_method_names": [], "method_name": "DBRef.getChainName", "method_implementation": "{\n    return chainName;\n}", "repo_id": "9", "comment": "/**\n * The name of the corresponding chain.\n *\n * @return chainName the name of the corresponding chain.\n */\n", "repo_name": "biojava-master/", "id": 1374, "method_signature": "String getChainName()"}, "3222": {"callee_method_ids": [3080], "callee_method_names": ["DNASequence.setAccession", "AbstractFeature.setLocation", "AbstractFeature.addQualifier", "AbstractFeature.addQualifier", "AbstractFeature.addQualifier", "AbstractFeature.addQualifier", "AbstractFeature.addQualifier", "AbstractFeature.addQualifier", "AbstractFeature.addQualifier", "DNASequence.addFeature", "ByteArrayOutputStream.close", "ByteArrayOutputStream.toByteArray", "DNASequence.getFeaturesByType", "AbstractFeature.getQualifiers", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get"], "method_name": "GenbankWriterTest.testGithub886", "method_implementation": "{\n    DNASequence seq = new DNASequence(\"ATGC\");\n    seq.setAccession(new AccessionID(\".\"));\n    AbstractFeature feature = new TextFeature(\"CDS\", \"source\", \"short description\", \"description\");\n    feature.setLocation(new SimpleLocation(1, 10, Strand.POSITIVE));\n    // no percent symbols in key or value\n    feature.addQualifier(\"note1\", new Qualifier(\"note1\", \"50\", true));\n    // percent symbol in key\n    feature.addQualifier(\"note2\", new Qualifier(\"%note2\", \"50\", true));\n    feature.addQualifier(\"note3\", new Qualifier(\"not%e3\", \"50\", true));\n    feature.addQualifier(\"note4\", new Qualifier(\"note4%\", \"50\", true));\n    // percent symbol in value\n    feature.addQualifier(\"note5\", new Qualifier(\"note5\", \"%50\", true));\n    feature.addQualifier(\"note6\", new Qualifier(\"note6\", \"5%0\", true));\n    feature.addQualifier(\"note7\", new Qualifier(\"note7\", \"50%\", true));\n    seq.addFeature(feature);\n    ByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n    GenbankWriterHelper.writeNucleotideSequence(fragwriter, Arrays.asList(seq), GenbankWriterHelper.LINEAR_DNA);\n    fragwriter.close();\n    //System.out.println(fragwriter.toString().replaceAll(\"\\r\\n\", \"\\n\"));\n    // now read in the file that was created and check that the qualifiers were created correctly\n    InputStream readerInputStream = new ByteArrayInputStream(fragwriter.toByteArray());\n    DNASequence newSeq = GenbankReaderHelper.readGenbankDNASequence(readerInputStream).values().iterator().next();\n    AbstractFeature newFeature = (TextFeature) seq.getFeaturesByType(\"CDS\").get(0);\n    Map<String, List<Qualifier>> newQualifiers = newFeature.getQualifiers();\n    assertEquals(\"note1\", newQualifiers.get(\"note1\").get(0).getName());\n    assertEquals(\"50\", newQualifiers.get(\"note1\").get(0).getValue());\n    assertEquals(\"%note2\", newQualifiers.get(\"note2\").get(0).getName());\n    assertEquals(\"50\", newQualifiers.get(\"note2\").get(0).getValue());\n    assertEquals(\"not%e3\", newQualifiers.get(\"note3\").get(0).getName());\n    assertEquals(\"50\", newQualifiers.get(\"note3\").get(0).getValue());\n    assertEquals(\"note4%\", newQualifiers.get(\"note4\").get(0).getName());\n    assertEquals(\"50\", newQualifiers.get(\"note4\").get(0).getValue());\n    assertEquals(\"note5\", newQualifiers.get(\"note5\").get(0).getName());\n    assertEquals(\"%50\", newQualifiers.get(\"note5\").get(0).getValue());\n    assertEquals(\"note6\", newQualifiers.get(\"note6\").get(0).getName());\n    assertEquals(\"5%0\", newQualifiers.get(\"note6\").get(0).getValue());\n    assertEquals(\"note7\", newQualifiers.get(\"note7\").get(0).getName());\n    assertEquals(\"50%\", newQualifiers.get(\"note7\").get(0).getValue());\n}", "repo_id": "9", "comment": "/**\n * String Formatter error when key or value of Qualifier has character \"%\"\n * https://github.com/biojava/biojava/issues/886\n */\n", "repo_name": "biojava-master/", "id": 3222, "method_signature": "void testGithub886()"}, "299": {"callee_method_names": ["List<Group>.isEmpty", "ModifiedCompound.getGroups", "ResidueNumber.setChainName", "ResidueNumber.setSeqNum", "ResidueNumber.setInsCode", "Logger.error", "List<Group>.add", "List<Group>.size", "List<Group>.get", "List<Group>.contains", "List<Atom[]>.isEmpty", "ModifiedCompound.addAtomLinkage", "List<Group>.add", "List<Group>.size"], "method_name": "ProteinModificationIdentifier.identifyAdditionalAttachments", "method_implementation": "{\n    if (ligands.isEmpty()) {\n        return;\n    }\n    // TODO: should the additional groups only be allowed to the identified\n    // ligands or both amino acids and ligands? Currently only on ligands\n    // ligands to amino acid bonds for same modification of unknown category\n    // will be combined in mergeModComps()\n    // TODO: how about chain-chain links?\n    List<Group> identifiedGroups = new ArrayList<Group>();\n    for (StructureGroup num : mc.getGroups(false)) {\n        Group group;\n        try {\n            //String numIns = \"\" + num.getResidueNumber();\n            //if (num.getInsCode() != null) {\n            //\tnumIns += num.getInsCode();\n            //}\n            ResidueNumber resNum = new ResidueNumber();\n            resNum.setChainName(num.getChainId());\n            resNum.setSeqNum(num.getResidueNumber());\n            resNum.setInsCode(num.getInsCode());\n            //group = chain.getGroupByPDB(numIns);\n            group = getGroup(num, chains);\n            //group = mapChainIdChain.get(num.getChainId()).getGroupByPDB(resNum);\n        } catch (StructureException e) {\n            logger.error(\"Exception: \", e);\n            // should not happen\n            continue;\n        }\n        identifiedGroups.add(group);\n    }\n    int start = 0;\n    int n = identifiedGroups.size();\n    while (n > start) {\n        for (Group group1 : ligands) {\n            for (int i = start; i < n; i++) {\n                Group group2 = identifiedGroups.get(i);\n                if (!identifiedGroups.contains(group1)) {\n                    List<Atom[]> linkedAtoms = StructureUtil.findAtomLinkages(group1, group2, false, bondLengthTolerance);\n                    if (!linkedAtoms.isEmpty()) {\n                        for (Atom[] atoms : linkedAtoms) {\n                            mc.addAtomLinkage(StructureUtil.getStructureAtomLinkage(atoms[0], false, atoms[1], false));\n                        }\n                        identifiedGroups.add(group1);\n                        break;\n                    }\n                }\n            }\n        }\n        start = n;\n        n = identifiedGroups.size();\n    }\n}", "repo_id": "9", "comment": "/**\n * identify additional groups that are not directly attached to amino acids.\n * @param mc {@link ModifiedCompound}\n * @param ligands {@link Group}\n * @param chains List of {@link Chain}s\n * @return a list of added groups\n */\n", "repo_name": "biojava-master/", "id": 299, "method_signature": "void identifyAdditionalAttachments(ModifiedCompound, List, List)"}, "2331": {"callee_method_ids": [638, 635, 641, 628, 628, 641, 628, 628], "callee_method_names": ["AtomCache.setFetchBehavior", "AtomCache.setObsoleteBehavior", "AtomCache.setFiletype", "AtomCache.getStructure", "Structure.getPdbId", "AtomCache.getStructure", "Structure.getPdbId", "AtomCache.setFiletype", "AtomCache.getStructure", "Structure.getPdbId", "AtomCache.getStructure", "Structure.getPdbId"], "method_name": "TestAtomCache.testFetchObsolete", "method_implementation": "{\n    cache.setFetchBehavior(FetchBehavior.FETCH_FILES);\n    cache.setObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);\n    Structure s;\n    cache.setFiletype(StructureFiletype.PDB);\n    s = cache.getStructure(\"1CMW\");\n    assertEquals(\"Failed to get OBSOLETE file 1CMW.\", \"1CMW\", s.getPdbId().getId());\n    s = cache.getStructure(\"1HHB\");\n    assertEquals(\"Failed to get OBSOLETE file 1HHB.\", \"1HHB\", s.getPdbId().getId());\n    cache.setFiletype(StructureFiletype.CIF);\n    s = cache.getStructure(\"1CMW\");\n    assertEquals(\"Failed to get OBSOLETE file 1CMW.\", \"1CMW\", s.getPdbId().getId());\n    s = cache.getStructure(\"1HHB\");\n    assertEquals(\"Failed to get OBSOLETE file 1HHB.\", \"1HHB\", s.getPdbId().getId());\n}", "repo_id": "9", "comment": "// Fetching obsolete directly\n", "repo_name": "biojava-master/", "id": 2331, "method_signature": "void testFetchObsolete()"}, "1408": {"callee_method_names": ["CrystalCell.getBeta"], "method_name": "PDBCrystallographicInfo.getBeta", "method_implementation": "{\n    return (float) cell.getBeta();\n}", "repo_id": "9", "comment": "/**\n * @return the unit cell parameter beta (degrees)\n */\n", "repo_name": "biojava-master/", "id": 1408, "method_signature": "float getBeta()"}, "1802": {"callee_method_names": ["String.split", "Integer.equals", "double[].getXGroup", "Integer.equals", "double[].getHGroup", "Integer.equals", "double[].getTGroup", "Logger.warn", "List<EcodDomain>.add"], "method_name": "EcodInstallation.filterByHierarchy", "method_implementation": "{\n    String[] xhtGroup = hierarchy.split(\"\\\\.\");\n    Integer xGroup = xhtGroup.length > 0 ? Integer.parseInt(xhtGroup[0]) : null;\n    Integer hGroup = xhtGroup.length > 1 ? Integer.parseInt(xhtGroup[1]) : null;\n    Integer tGroup = xhtGroup.length > 2 ? Integer.parseInt(xhtGroup[2]) : null;\n    List<EcodDomain> filtered = new ArrayList<EcodDomain>();\n    for (EcodDomain d : getAllDomains()) {\n        boolean match = true;\n        if (xhtGroup.length > 0) {\n            match = match && xGroup.equals(d.getXGroup());\n        }\n        if (xhtGroup.length > 1) {\n            match = match && hGroup.equals(d.getHGroup());\n        }\n        if (xhtGroup.length > 2) {\n            match = match && tGroup.equals(d.getTGroup());\n        }\n        if (xhtGroup.length > 3) {\n            logger.warn(\"Ignoring unexpected additional parts of ECOD {}\", hierarchy);\n        }\n        if (match) {\n            filtered.add(d);\n        }\n    }\n    return filtered;\n}", "repo_id": "9", "comment": "/**\n * Get a list of domains within a particular level of the hierarchy\n * @param hierarchy A dot-separated list giving the X-group, H-group, and/or\n *  T-group (e.g. \"1.1\" for all members of the RIFT-related H-group)\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1802, "method_signature": "List<EcodDomain> filterByHierarchy(String)"}, "1948": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getTm", "method_implementation": "{\n    return tm;\n}", "repo_id": "9", "comment": "/**\n * @return the tm\n */\n", "repo_name": "biojava-master/", "id": 1948, "method_signature": "double getTm()"}, "458": {"callee_method_names": [], "method_name": "QsAlignParameters.getdCutoff", "method_implementation": "{\n    return dCutoff;\n}", "repo_id": "9", "comment": "/**\n * The maximum allowed distance between the centroids of two equivalent\n * Subunits, in A.\n *\n * @return dCutoff\n */\n", "repo_name": "biojava-master/", "id": 458, "method_signature": "double getdCutoff()"}, "2409": {"callee_method_names": [], "method_name": "Location.upstream", "method_implementation": "{\n    if (length < 0) {\n        throw new IllegalArgumentException(\"Parameter must be >= 0; is=\" + length);\n    }\n    if (Math.signum(mStart - length) == Math.signum(mStart) || 0 == Math.signum(mStart - length)) {\n        return new Location(mStart - length, mStart);\n    } else {\n        throw new IndexOutOfBoundsException(\"Specified length causes crossing of origin: \" + length + \"; \" + toString());\n    }\n}", "repo_id": "9", "comment": "/**\n * Return the adjacent location of specified length directly upstream of this location.\n *\n * @return Upstream location.\n * @param length The length of the upstream location.\n * @throws IndexOutOfBoundsException Specified length causes crossing of origin.\n */\n", "repo_name": "biojava-master/", "id": 2409, "method_signature": "Location upstream(int)"}, "3849": {"callee_method_names": [], "method_name": "ProfeatProperties.getTransition", "method_implementation": "{\n    return new ProfeatPropertiesImpl().getTransition(sequence, attribute, transition);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method which returns the number of transition between the specified groups for the given attribute with respect to the length of sequence.\n *\n * @param sequence\n * \ta protein sequence consisting of non-ambiguous characters only\n * @param attribute\n * \tone of the seven attributes (Hydrophobicity, Volume, Polarity, Polarizability, Charge, SecondaryStructure or SolventAccessibility)\n * @param transition\n * \tthe interested transition between the groups\n * @return\n *  returns the number of transition between the specified groups for the given attribute with respect to the length of sequence.\n * @throws Exception\n * \tthrows Exception if attribute or group are unknown\n */\n", "repo_name": "biojava-master/", "id": 3849, "method_signature": "double getTransition(ProteinSequence, ATTRIBUTE, TRANSITION)"}, "2699": {"callee_method_names": [], "method_name": "FastaStreamer.createSequence", "method_implementation": "{\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Create the sequence with the information from the header.  This implementation return the sequence as-is, but\n * this is an opportunity for the implementer to build specific information into the user collection space\n * of the sequence\n *\n * @param sequence the protein sequence\n * @return the sequence\n */\n", "repo_name": "biojava-master/", "id": 2699, "method_signature": "ProteinSequence createSequence(ProteinSequence)"}, "2449": {"callee_method_names": [], "method_name": "FeatureList.addIndexes", "method_implementation": "{\n    for (String index : indexes) {\n        addIndex(index);\n    }\n}", "repo_id": "9", "comment": "/**\n * Add a list of attributes that will be used as indexes for queries\n * @param indexes  the List containing the attribute_id\n */\n", "repo_name": "biojava-master/", "id": 2449, "method_signature": "void addIndexes(List)"}, "183": {"callee_method_ids": [1929], "callee_method_names": ["QuatSymmetryResults.getSymmetry", "QuatSymmetryResults.getStoichiometry", "QuatSymmetryResults.isPseudoStoichiometric"], "method_name": "TestQuatSymmetryDetectorExamples.testNMR", "method_implementation": "{\n    // as of mmCIF v5 there's no bioassemblies for NMR entries, so now we use the AU (bioassembly 0) - JD 2017-08-02\n    Structure pdb = StructureIO.getStructure(\"BIO:1b4c:0\");\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n    QuatSymmetryParameters symmParams = new QuatSymmetryParameters();\n    QuatSymmetryResults symmetry = QuatSymmetryDetector.calcGlobalSymmetry(pdb, symmParams, clusterParams);\n    // C2 symmetry non pseudosymmetric\n    assertEquals(\"C2\", symmetry.getSymmetry());\n    assertEquals(\"A2\", symmetry.getStoichiometry().toString());\n    assertFalse(symmetry.isPseudoStoichiometric());\n}", "repo_id": "9", "comment": "/**\n * An NMR multi-model entry: 1B4C\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 183, "method_signature": "void testNMR()"}, "1351": {"callee_method_names": [], "method_name": "EntityInfo.getType", "method_implementation": "{\n    return this.type;\n}", "repo_id": "9", "comment": "/**\n * Get the type of entity this EntityInfo describes.\n * Options are polymer, non-polymer or water.\n * @return a string describing the type of entity. (polymer, non-polymer or water).\n */\n", "repo_name": "biojava-master/", "id": 1351, "method_signature": "EntityType getType()"}, "3676": {"callee_method_names": [], "method_name": "SurvivalInfo.setStatus", "method_implementation": "{\n    this.status = status;\n}", "repo_id": "9", "comment": "/**\n * @param status the status to set\n */\n", "repo_name": "biojava-master/", "id": 3676, "method_signature": "void setStatus(int)"}, "380": {"callee_method_names": ["Atom.getX", "Atom.getX", "Atom.getY", "Atom.getY", "Atom.getZ", "Atom.getZ", "Atom.setX", "Atom.setY", "Atom.setZ"], "method_name": "Calc.scaleAdd", "method_implementation": "{\n    double xc = s * x.getX() + b.getX();\n    double yc = s * x.getY() + b.getY();\n    double zc = s * x.getZ() + b.getZ();\n    //Atom a = new AtomImpl();\n    b.setX(xc);\n    b.setY(yc);\n    b.setZ(zc);\n    return b;\n}", "repo_id": "9", "comment": "/**\n * Perform linear transformation s*X+B, and store the result in b\n *\n * @param s\n *            Amount to scale x\n * @param x\n *            Input coordinate\n * @param b\n *            Vector to translate (will be modified)\n * @return b, after modification\n */\n", "repo_name": "biojava-master/", "id": 380, "method_signature": "Atom scaleAdd(double, Atom, Atom)"}, "3496": {"callee_method_names": ["BlastMatrixEnum.name"], "method_name": "NCBIQBlastAlignmentProperties.setBlastMatrix", "method_implementation": "{\n    setAlignmentOption(MATRIX_NAME, matrix.name());\n    boolean gapCostsSet = getBlastGapCreation() != -1 || getBlastGapExtension() != -1;\n    if (!gapCostsSet) {\n        /*\n\t\t\t * Setting default values for -G/-E if no other values have been set is necessary because, since BLOSUM62 is\n\t\t\t * default, the expected values are -G 11 -E 1. If your matrix choice is different, the request will fail,\n\t\t\t * implicitly expecting GAPCOSTS=11+1\n\t\t\t */\n        switch(matrix) {\n            case PAM30:\n                setBlastGapCosts(9, 1);\n                break;\n            case PAM70:\n                setBlastGapCosts(10, 1);\n                break;\n            case PAM250:\n                setBlastGapCosts(14, 2);\n                break;\n            case BLOSUM45:\n                setBlastGapCosts(15, 2);\n                break;\n            case BLOSUM50:\n                setBlastGapCosts(13, 2);\n                break;\n            case BLOSUM80:\n            case BLOSUM90:\n                setBlastGapCosts(10, 1);\n                break;\n            case BLOSUM62:\n                break;\n            default:\n                break;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Sets the value for the MATRIX parameter to use for blastall\n * <p>\n * Blastall equivalent: -M\n *\n * @param matrix : a String to use as gap creation value\n * @see BlastMatrixEnum\n */\n", "repo_name": "biojava-master/", "id": 3496, "method_signature": "void setBlastMatrix(BlastMatrixEnum)"}, "3560": {"callee_method_names": [], "method_name": "CoxVariables.getGenes", "method_implementation": "{\n    return genes;\n}", "repo_id": "9", "comment": "/**\n * @return the genes\n */\n", "repo_name": "biojava-master/", "id": 3560, "method_signature": "String getGenes()"}, "2944": {"callee_method_names": [], "method_name": "AbstractSequence.getIndexOf", "method_implementation": "{\n    return getSequenceStorage().getIndexOf(compound);\n}", "repo_id": "9", "comment": "/**\n * @param compound\n * @return The first index of compound in this sequence (1-based)\n */\n", "repo_name": "biojava-master/", "id": 2944, "method_signature": "int getIndexOf(C)"}, "1149": {"callee_method_names": [], "method_name": "FileConvert.doPrintConnections", "method_implementation": "{\n    return printConnections;\n}", "repo_id": "9", "comment": "/**\n * Returns if the Connections should be added\n * default is true;\n * @return if the printConnections flag is set\n */\n", "repo_name": "biojava-master/", "id": 1149, "method_signature": "boolean doPrintConnections()"}, "1338": {"callee_method_names": ["Integer.equals", "Integer.compareTo", "Character.equals", "Character.compareTo"], "method_name": "ResidueNumber.compareToPositional", "method_implementation": "{\n    // sequence number\n    if (seqNum != null && other.seqNum != null) {\n        if (!seqNum.equals(other.seqNum))\n            return seqNum.compareTo(other.seqNum);\n    }\n    if (seqNum != null && other.seqNum == null) {\n        return 1;\n    } else if (seqNum == null && other.seqNum != null) {\n        return -1;\n    }\n    // insertion code\n    if (insCode != null && other.insCode != null) {\n        if (!insCode.equals(other.insCode))\n            return insCode.compareTo(other.insCode);\n    }\n    if (insCode != null && other.insCode == null) {\n        return 1;\n    } else if (insCode == null && other.insCode != null) {\n        return -1;\n    }\n    return 0;\n}", "repo_id": "9", "comment": "/**\n * Compare residue numbers by sequence number and insertion code,\n * ignoring the chain\n * @param other\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1338, "method_signature": "int compareToPositional(ResidueNumber)"}, "2516": {"callee_method_names": ["StringTokenizer.hasMoreTokens", "StringTokenizer.nextToken", "String.startsWith", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ScaledSubstitutionMatrix.toString", "method_implementation": "{\n    String newline = System.getProperty(\"line.separator\");\n    StringBuilder s = new StringBuilder();\n    StringTokenizer st = new StringTokenizer(description, newline);\n    while (st.hasMoreTokens()) {\n        String line = st.nextToken();\n        if (!line.startsWith(comment)) {\n            s.append(comment);\n        }\n        s.append(String.format(\"%s%n\", line));\n    }\n    if (scale != 1)\n        s.append(\"# Matrix scaled by a factor of \").append(scale).append(newline);\n    s.append(getMatrixAsString());\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns in a format similar to the standard NCBI files.\n */\n", "repo_name": "biojava-master/", "id": 2516, "method_signature": "String toString()"}, "3057": {"callee_method_names": [], "method_name": "AccessionID.getDataSource", "method_implementation": "{\n    return source;\n}", "repo_id": "9", "comment": "/**\n * @return the source\n */\n", "repo_name": "biojava-master/", "id": 3057, "method_signature": "DataSource getDataSource()"}, "1357": {"callee_method_names": [], "method_name": "AminoAcidImpl.getCB", "method_implementation": "{\n    return getAtom(\"CB\");\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1357, "method_signature": "Atom getCB()"}, "745": {"callee_method_names": [], "method_name": "CeCalculatorEnhanced.getShift", "method_implementation": "{\n    return t;\n}", "repo_id": "9", "comment": "/**\n * Gets the shift from the last call to\n * {@link #calc_rmsd(Atom[], Atom[], int, boolean, boolean) calc_rmsd}.\n * @return The shift\n */\n", "repo_name": "biojava-master/", "id": 745, "method_signature": "Atom getShift()"}, "597": {"callee_method_names": [], "method_name": "AlignmentTools.toConciseAlignmentString", "method_implementation": "{\n    return toConciseAlignmentString(alignment, new IdentityMap<T>());\n}", "repo_id": "9", "comment": "/**\n * @see #toConciseAlignmentString(Map, Map)\n */\n", "repo_name": "biojava-master/", "id": 597, "method_signature": "String toConciseAlignmentString(Map)"}, "2571": {"callee_method_names": ["URLConnection.getContentLengthLong", "Logger.warn", "URLConnection.getURL", "Logger.debug", "File.getParentFile", "File.getName", "Logger.warn", "int.getMessage", "File.getParentFile", "File.getName", "Logger.warn", "int.getMessage"], "method_name": "FileDownloadUtils.createValidationFiles", "method_implementation": "{\n    long size = resourceUrlConnection.getContentLengthLong();\n    if (size == -1) {\n        logger.warn(\"could not find expected file size for resource {}.\", resourceUrlConnection.getURL());\n    } else {\n        logger.debug(\"Content-Length: {}\", size);\n        File sizeFile = new File(localDestination.getParentFile(), localDestination.getName() + SIZE_EXT);\n        try (PrintStream sizePrintStream = new PrintStream(sizeFile)) {\n            sizePrintStream.print(size);\n            sizePrintStream.close();\n        } catch (FileNotFoundException e) {\n            logger.warn(\"could not write size validation file due to exception: {}\", e.getMessage());\n        }\n    }\n    if (hashURL == null)\n        return;\n    if (hash == Hash.UNKNOWN)\n        throw new IllegalArgumentException(\"Hash URL given but algorithm is unknown\");\n    try {\n        File hashFile = new File(localDestination.getParentFile(), String.format(\"%s%s_%s\", localDestination.getName(), HASH_EXT, hash));\n        downloadFile(hashURL, hashFile);\n    } catch (IOException e) {\n        logger.warn(\"could not write validation hash file due to exception: {}\", e.getMessage());\n    }\n}", "repo_id": "9", "comment": "/**\n * Creates validation files beside a file to be downloaded.<br>\n * Whenever possible, for a <code>file.ext</code> file, it creates\n * <code>file.ext.size</code> and <code>file.hash_XXXX</code> in the same\n * folder where <code>file.ext</code> exists (XXXX may be DM5, SHA1, or SHA256).\n * If the file connection size could not be deduced from the resourceUrlConnection\n * {@link URLConnection}, no size file is created.\n * If <code>hashURL</code> is <code>null</code>, no hash file is created.<br>\n * <b>N.B.</b> None of the hashing algorithms is implemented (yet), because we did not need any of them yet.\n * @param resourceUrlConnection the remote file URLConnection to download\n * @param localDestination the local file to download into\n * @param hashURL the URL of the hash file to download. Can be <code>null</code>.\n * @param hash The Hashing algorithm. Ignored if <code>hashURL</code> is <code>null</code>.\n * @since 7.0.0\n */\n", "repo_name": "biojava-master/", "id": 2571, "method_signature": "void createValidationFiles(URLConnection, File, URL, Hash)"}, "2647": {"callee_method_names": [], "method_name": "CaseInsensitiveTriplet.intValue", "method_implementation": "{\n    return (16 * compoundToInt(getOne())) + (4 * compoundToInt(getTwo())) + (compoundToInt(getThree()));\n}", "repo_id": "9", "comment": "/**\n * Attempts to provide an int version of this codon which multiplies\n * each position by\n */\n", "repo_name": "biojava-master/", "id": 2647, "method_signature": "int intValue()"}, "1146": {"callee_method_names": ["String.hashCode", "String.hashCode", "String.hashCode", "String.hashCode", "String.hashCode", "String.hashCode"], "method_name": "SSBondImpl.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((chainID1 == null) ? 0 : chainID1.hashCode());\n    result = prime * result + ((chainID2 == null) ? 0 : chainID2.hashCode());\n    result = prime * result + ((insCode1 == null) ? 0 : insCode1.hashCode());\n    result = prime * result + ((insCode2 == null) ? 0 : insCode2.hashCode());\n    result = prime * result + ((resnum1 == null) ? 0 : resnum1.hashCode());\n    result = prime * result + ((resnum2 == null) ? 0 : resnum2.hashCode());\n    return result;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#hashCode()\n\t */\n", "repo_name": "biojava-master/", "id": 1146, "method_signature": "int hashCode()"}, "933": {"callee_method_names": [], "method_name": "Grid.addCoords", "method_implementation": "{\n    this.iAtoms = atoms;\n    this.iAtomObjects = null;\n    if (bounds != null) {\n        this.ibounds = bounds;\n    } else {\n        this.ibounds = new BoundingBox(iAtoms);\n    }\n    this.jAtoms = null;\n    this.jAtomObjects = null;\n    this.jbounds = null;\n    fillGrid();\n}", "repo_id": "9", "comment": "/**\n * Adds a set of coordinates, subsequent call to {@link #getIndicesContacts()} will produce the\n * contacts, i.e. the set of points within distance cutoff.\n * The bounds calculated elsewhere can be passed, or if null they are computed.\n * Subsequent calls to method {@link #getAtomContacts()} will produce a NullPointerException\n * since this only adds coordinates and no atom information.\n * @param atoms\n * @param bounds\n */\n", "repo_name": "biojava-master/", "id": 933, "method_signature": "void addCoords(Point3d[], BoundingBox)"}, "3396": {"callee_method_ids": [1885, 1884], "callee_method_names": ["RotationAxisAligner.getSubunits", "QuatSymmetrySubunits.getModelNumbers", "QuatSymmetrySubunits.getChainIds", "RotationAxisAligner.getOrbits", "RotationGroup.getRotation", "List<List<Integer>>.size", "List<List<Integer>>.size", "List<List<Integer>>.get", "Map<Color4f, List<String>>.get", "Map<Color4f, List<String>>.put", "List<String>.add"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.colorBySubunit", "method_implementation": "{\n    QuatSymmetrySubunits subunits = rotationAxisAligner.getSubunits();\n    List<Integer> modelNumbers = subunits.getModelNumbers();\n    List<String> chainIds = subunits.getChainIds();\n    List<List<Integer>> orbits = rotationAxisAligner.getOrbits();\n    int fold = rotationGroup.getRotation(0).getFold();\n    Color[] col = null;\n    Color4f[] colors = null;\n    if (fold > 1) {\n        col = ColorBrewer.Spectral.getColorPalette(2 * fold);\n        colors = ColorConverter.convertColor4f(col);\n    } else {\n        col = ColorBrewer.Spectral.getColorPalette(orbits.size());\n        colors = ColorConverter.convertColor4f(col);\n    }\n    int half = colors.length / 2;\n    for (int i = 0; i < half; i++) {\n        if (i % 2 != 0) {\n            Color4f temp = colors[i];\n            colors[i] = colors[half + i];\n            colors[half + i] = temp;\n        }\n    }\n    Map<Color4f, List<String>> colorMap = new HashMap<Color4f, List<String>>();\n    for (int i = 0; i < orbits.size(); i++) {\n        for (int j = 0; j < fold; j++) {\n            // assign alternating color sets to adjacent orbits\n            int colorIndex = i;\n            if (fold > 1) {\n                if (i % 2 == 0) {\n                    colorIndex = j;\n                } else {\n                    colorIndex = fold + j;\n                }\n            }\n            int subunit = orbits.get(i).get(j);\n            Color4f c = colors[colorIndex];\n            List<String> ids = colorMap.get(c);\n            if (ids == null) {\n                ids = new ArrayList<String>();\n                colorMap.put(c, ids);\n            }\n            String id = getChainSpecification(modelNumbers, chainIds, subunit);\n            ids.add(id);\n        }\n    }\n    return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#colorBySubunit()\n\t */\n", "repo_name": "biojava-master/", "id": 3396, "method_signature": "String colorBySubunit()"}, "722": {"callee_method_names": [], "method_name": "CECalculator.pToZ", "method_implementation": "{\n    int ind = (int) (-Math.log10(p) * 3.0);\n    if (ind < 0)\n        ind = 0;\n    if (ind > 149)\n        ind = 149;\n    return (tablePtoZ[ind]);\n}", "repo_id": "9", "comment": "///////////////////////////////////////////////////////////////////////////\n", "repo_name": "biojava-master/", "id": 722, "method_signature": "double pToZ(double)"}, "3579": {"callee_method_names": [], "method_name": "Matrix.dot", "method_implementation": "{\n    if (x.length != y.length) {\n        throw new RuntimeException(\"Illegal vector dimensions.\");\n    }\n    double sum = 0.0;\n    for (int i = 0; i < x.length; i++) {\n        sum += x[i] * y[i];\n    }\n    return sum;\n}", "repo_id": "9", "comment": "/**\n * @param x\n * @param y\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3579, "method_signature": "double dot(double[], double[])"}, "1168": {"callee_method_names": ["String.substring", "String.substring", "String.substring", "String.substring", "String.equals", "Chain.setId", "Chain.setName", "StringTokenizer.hasMoreTokens", "StringTokenizer.nextToken", "Group.setPDBName", "AminoAcid.setRecordType", "Chain.addGroup", "List<Chain>.add", "Group.trimToSize"], "method_name": "PDBFileParser.pdb_SEQRES_Handler", "method_implementation": "{\n    /*\n\t\t *          1         2         3         4         5         6         7\n\t\t * 1234567890123456789012345678901234567890123456789012345678901234567890\n\t\t * SEQRES   1 A  376  LYS PRO VAL THR VAL LYS LEU VAL ASP SER GLN ALA THR\n\t\t * SEQRES   1 A   21  GLY ILE VAL GLU GLN CYS CYS THR SER ILE CYS SER LEU\n\t\t * SEQRES   2 A   21  TYR GLN LEU GLU ASN TYR CYS ASN\n\t\t * SEQRES   1 B   30  PHE VAL ASN GLN HIS LEU CYS GLY SER HIS LEU VAL GLU\n\t\t * SEQRES   2 B   30  ALA LEU TYR LEU VAL CYS GLY GLU ARG GLY PHE PHE TYR\n\t\t * SEQRES   3 B   30  THR PRO LYS ALA\n\t\t * SEQRES   1 C   21  GLY ILE VAL GLU GLN CYS CYS THR SER ILE CYS SER LEU\n\t\t * SEQRES   2 C   21  TYR GLN LEU GLU ASN TYR CYS ASN\n\t\t * SEQRES   1 D   30  PHE VAL ASN GLN HIS LEU CYS GLY SER HIS LEU VAL GLU\n\t\t * SEQRES   2 D   30  ALA LEU TYR LEU VAL CYS GLY GLU ARG GLY PHE PHE TYR\n\t\t * SEQRES   3 D   30  THR PRO LYS ALA\n\t\t */\n    String recordName = line.substring(0, 6).trim();\n    String chainID = line.substring(11, 12);\n    String newLength = line.substring(13, 17).trim();\n    String subSequence = line.substring(18);\n    if (lengthCheck == -1) {\n        lengthCheck = Integer.parseInt(newLength);\n    }\n    StringTokenizer subSequenceResidues = new StringTokenizer(subSequence);\n    Character aminoCode1 = null;\n    if (!recordName.equals(AminoAcid.SEQRESRECORD)) {\n        // should not have been called\n        return;\n    }\n    currentChain = isKnownChain(chainID, seqResChains);\n    if (currentChain == null) {\n        currentChain = new ChainImpl();\n        currentChain.setId(chainID);\n        currentChain.setName(chainID);\n    }\n    while (subSequenceResidues.hasMoreTokens()) {\n        String threeLetter = subSequenceResidues.nextToken();\n        aminoCode1 = StructureTools.get1LetterCode(threeLetter);\n        //if (aminoCode1 == null) {\n        // could be a nucleotide...\n        // but getNewGroup takes care of that and converts ATOM records with aminoCode1 == nnull to nucleotide...\n        //}\n        currentGroup = getNewGroup(\"ATOM\", aminoCode1, threeLetter);\n        currentGroup.setPDBName(threeLetter);\n        if (currentGroup instanceof AminoAcid) {\n            AminoAcid aa = (AminoAcid) currentGroup;\n            aa.setRecordType(AminoAcid.SEQRESRECORD);\n        }\n        // add the current resNum to the new chain.\n        currentChain.addGroup(currentGroup);\n    }\n    Chain test = isKnownChain(chainID, seqResChains);\n    if (test == null)\n        seqResChains.add(currentChain);\n    if (currentGroup != null)\n        currentGroup.trimToSize();\n    currentGroup = null;\n    currentChain = null;\n    //\t\t the current chain is finished!\n    //if ( current_chain.getLength() != lengthCheck ){\n    //\tSystem.err.println(\"the length of chain \" + current_chain.getName() + \"(\" +\n    //\t\t\tcurrent_chain.getLength() + \") does not match the expected \" + lengthCheck);\n    //}\n    lengthCheck = Integer.parseInt(newLength);\n}", "repo_id": "9", "comment": "/**\n * Handler for\n * SEQRES record format\n * SEQRES records contain the amino acid or nucleic acid sequence of residues in each chain of the macromolecule that was studied.\n * <p>\n * Record Format:\n * <p>\n * <pre>\n * COLUMNS        DATA TYPE       FIELD         DEFINITION\n * ---------------------------------------------------------------------------------\n * 1 -  6        Record name     \"SEQRES\"\n * 9 - 10        Integer         serNum        Serial number of the SEQRES record\n * for the current chain.  Starts at 1\n * and increments by one each line.\n * Reset to 1 for each chain.\n * 12             Character       chainID       Chain identifier.  This may be any\n * single legal character, including a\n * blank which is used if there is\n * only one chain.\n * 14 - 17        Integer         numRes        Number of residues in the chain.\n * This value is repeated on every\n * record.\n * 20 - 22        Residue name    resName       Residue name.\n * 24 - 26        Residue name    resName       Residue name.\n * 28 - 30        Residue name    resName       Residue name.\n * 32 - 34        Residue name    resName       Residue name.\n * 36 - 38        Residue name    resName       Residue name.\n * 40 - 42        Residue name    resName       Residue name.\n * 44 - 46        Residue name    resName       Residue name.\n * 48 - 50        Residue name    resName       Residue name.\n * 52 - 54        Residue name    resName       Residue name.\n * 56 - 58        Residue name    resName       Residue name.\n * 60 - 62        Residue name    resName       Residue name.\n * 64 - 66        Residue name    resName       Residue name.\n * 68 - 70        Residue name    resName       Residue name.\n * </pre>\n * @author Jules Jacobsen\n */\n", "repo_name": "biojava-master/", "id": 1168, "method_signature": "void pdb_SEQRES_Handler(String)"}, "3776": {"callee_method_names": [], "method_name": "WorkSheet.getMetaDataColumnsHashMap", "method_implementation": "{\n    return metaDataColumnsHashMap;\n}", "repo_id": "9", "comment": "/**\n * @return the metaDataColumnsHashMap\n */\n", "repo_name": "biojava-master/", "id": 3776, "method_signature": "LinkedHashMap<String,String> getMetaDataColumnsHashMap()"}, "3022": {"callee_method_names": ["List<Location>.size", "List<Location>.get"], "method_name": "InsdcParser.parse", "method_implementation": "{\n    featureGlobalStart = Integer.MAX_VALUE;\n    featureGlobalEnd = 1;\n    Location l;\n    List<Location> ll = parseLocationString(locationString, 1);\n    if (ll.size() == 1) {\n        l = ll.get(0);\n    } else {\n        l = new SimpleLocation(new SimplePoint(featureGlobalStart), new SimplePoint(featureGlobalEnd), Strand.UNDEFINED, isSequenceCircular, ll);\n    }\n    return l;\n}", "repo_id": "9", "comment": "/**\n * Main method for parsing a location from a String instance\n *\n * @param locationString Represents a logical location\n * @return The parsed location\n * @throws ParserException thrown in the event of any error during parsing\n */\n", "repo_name": "biojava-master/", "id": 3022, "method_signature": "Location parse(String)"}, "1221": {"callee_method_names": ["ChemCompConsumer.prepare", "CifFile.as", "MmCifFile.getBlocks", "ChemCompConsumer.consumeChemComp", "MmCifBlock.getChemComp", "ChemCompConsumer.consumeChemCompAtom", "MmCifBlock.getChemCompAtom", "ChemCompConsumer.consumeChemCompBond", "MmCifBlock.getChemCompBond", "ChemCompConsumer.finish", "ChemCompConsumer.getContainer"], "method_name": "ChemCompConverter.fromCifFile", "method_implementation": "{\n    // initialize consumer\n    ChemCompConsumer consumer = new ChemCompConsumerImpl();\n    // init structure\n    consumer.prepare();\n    // feed individual categories to consumer\n    MmCifFile mmCifFile = cifFile.as(StandardSchemata.MMCIF);\n    for (MmCifBlock cifBlock : mmCifFile.getBlocks()) {\n        consumer.consumeChemComp(cifBlock.getChemComp());\n        consumer.consumeChemCompAtom(cifBlock.getChemCompAtom());\n        consumer.consumeChemCompBond(cifBlock.getChemCompBond());\n    }\n    // prepare structure to be retrieved\n    consumer.finish();\n    return consumer.getContainer();\n}", "repo_id": "9", "comment": "/**\n * Convert CifFile to chem comp dictionary.\n * @param cifFile the source\n * @return the target\n */\n", "repo_name": "biojava-master/", "id": 1221, "method_signature": "ChemicalComponentDictionary fromCifFile(CifFile)"}, "3035": {"callee_method_names": [], "method_name": "Tools.location", "method_implementation": "{\n    int min = Math.min(start, end);\n    //if this is true then we have a coord on the +ve strand even though Strand could be negative\n    boolean isReverse = (min != start);\n    if (isReverse) {\n        return new SimpleLocation(new SimplePoint(start).reverse(length), new SimplePoint(end).reverse(length), strand);\n    }\n    return new SimpleLocation(start, end, strand);\n}", "repo_id": "9", "comment": "/**\n * Returns a location object which unlike the location constructors\n * allows you to input reverse coordinates and will convert\n * these into the right location on the positive strand.\n */\n", "repo_name": "biojava-master/", "id": 3035, "method_signature": "Location location(int, int, Strand, int)"}, "3323": {"callee_method_names": [], "method_name": "WrapLayout.preferredLayoutSize", "method_implementation": "{\n    return layoutSize(target, true);\n}", "repo_id": "9", "comment": "/**\n * Returns the preferred dimensions for this layout given the\n * <i>visible</i> components in the specified target container.\n * @param target the component which needs to be laid out\n * @return the preferred dimensions to lay out the\n * subcomponents of the specified container\n */\n", "repo_name": "biojava-master/", "id": 3323, "method_signature": "Dimension preferredLayoutSize(Container)"}, "3187": {"callee_method_names": [], "method_name": "WindowedSequence.getCompounds", "method_implementation": "{\n    return get(index).getAsList();\n}", "repo_id": "9", "comment": "/**\n * For a given position into the windowed view this will return those\n * compounds we can see in the window. i.e. in the sequence AGGCCT requesting\n * index 1 returns AGG and requesting index 2 return CCT.\n *\n * @param index Windowed index position\n * @return The List of compounds\n */\n", "repo_name": "biojava-master/", "id": 3187, "method_signature": "List<C> getCompounds(int)"}, "2": {"callee_method_names": [], "method_name": "SimpleGapPenalty.getExtensionPenalty", "method_implementation": "{\n    return gep;\n}", "repo_id": "9", "comment": "/**\n * <strong>Returns the negative of the extension penalty passed to the constructor.</strong>\n */\n", "repo_name": "biojava-master/", "id": 2, "method_signature": "int getExtensionPenalty()"}, "2197": {"callee_method_ids": [944], "callee_method_names": ["InterfaceFinder.getAllInterfaces", "StructureInterfaceList.size", "Structure.getPolyChains"], "method_name": "TestInterfaceFinder.testGetAllInterfacesNoAtomsPoly", "method_implementation": "{\n    Structure s = mockStructure(true);\n    InterfaceFinder finder = new InterfaceFinder(s);\n    StructureInterfaceList list = finder.getAllInterfaces();\n    assertEquals(1, list.size());\n    // make sure we did not alter the original poly chains\n    assertEquals(3, s.getPolyChains().size());\n}", "repo_id": "9", "comment": "/**\n * Check that interfaces can be calculated if one polymer chain has no atoms at all\n */\n", "repo_name": "biojava-master/", "id": 2197, "method_signature": "void testGetAllInterfacesNoAtomsPoly()"}, "1799": {"callee_method_names": ["Map<String, SoftReference<EcodDatabase>>.entrySet", "Iterator<Entry<String, SoftReference<EcodDatabase>>>.hasNext", "Iterator<Entry<String, SoftReference<EcodDatabase>>>.next", "Entry<String, SoftReference<EcodDatabase>>.getValue", "SoftReference<EcodDatabase>.get", "Logger.debug", "Entry<String, SoftReference<EcodDatabase>>.getKey", "Iterator<Entry<String, SoftReference<EcodDatabase>>>.remove"], "method_name": "EcodFactory.releaseReferences", "method_implementation": "{\n    synchronized (versionedEcodDBs) {\n        Iterator<Entry<String, SoftReference<EcodDatabase>>> it = versionedEcodDBs.entrySet().iterator();\n        while (it.hasNext()) {\n            Entry<String, SoftReference<EcodDatabase>> entry = it.next();\n            SoftReference<EcodDatabase> ref = entry.getValue();\n            if (ref.get() == null) {\n                logger.debug(\"Removed version {} from EcodFactory to save memory.\", entry.getKey());\n                it.remove();\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * removes SoftReferences which have already been garbage collected\n */\n", "repo_name": "biojava-master/", "id": 1799, "method_signature": "void releaseReferences()"}, "1941": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setMaxRmsd", "method_implementation": "{\n    this.maxRmsd = maxRmsd;\n}", "repo_id": "9", "comment": "/**\n * @param maxRmsd the maxRmsd to set\n */\n", "repo_name": "biojava-master/", "id": 1941, "method_signature": "void setMaxRmsd(double)"}, "1293": {"callee_method_names": ["Structure.clone", "Structure.setChains", "Chain.setName", "Group.getChain", "Chain.setId", "Group.getChain", "Chain.getId", "Chain.getId", "Structure.addChain", "Chain.setEntityInfo", "Group.getChain", "Chain.setStructure", "Chain.setId", "Group.getChain", "Chain.setName", "Group.getChain", "Chain.addGroup"], "method_name": "StructureSequenceMatcher.getSubstructureMatchingProteinSequence", "method_implementation": "{\n    ResidueNumber[] rns = matchSequenceToStructure(sequence, wholeStructure);\n    Structure structure = wholeStructure.clone();\n    structure.setChains(new ArrayList<>());\n    //\t\tstructure.getHetGroups().clear();\n    Chain currentChain = null;\n    for (ResidueNumber rn : rns) {\n        if (rn == null)\n            continue;\n        // note that we don't clone\n        Group group;\n        try {\n            group = StructureTools.getGroupByPDBResidueNumber(wholeStructure, rn);\n        } catch (StructureException e) {\n            throw new IllegalArgumentException(\"Could not find residue \" + rn + \" in structure\", e);\n        }\n        Chain chain = new ChainImpl();\n        chain.setName(group.getChain().getName());\n        chain.setId(group.getChain().getId());\n        if (currentChain == null || !currentChain.getId().equals(chain.getId())) {\n            structure.addChain(chain);\n            chain.setEntityInfo(group.getChain().getEntityInfo());\n            chain.setStructure(structure);\n            chain.setId(group.getChain().getId());\n            chain.setName(group.getChain().getName());\n            currentChain = chain;\n        }\n        currentChain.addGroup(group);\n    }\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * Get a substructure of {@code wholeStructure} containing only the {@link Group Groups} that are included in\n * {@code sequence}. The resulting structure will contain only {@code ATOM} residues; the SEQ-RES will be empty.\n * The {@link Chain Chains} of the Structure will be new instances (cloned), but the {@link Group Groups} will not.\n * @param sequence The input protein sequence\n * @param wholeStructure The structure from which to take a substructure\n * @return The resulting structure\n * @throws StructureException\n * @see {@link #matchSequenceToStructure(ProteinSequence, Structure)}\n */\n", "repo_name": "biojava-master/", "id": 1293, "method_signature": "Structure getSubstructureMatchingProteinSequence(ProteinSequence, Structure)"}, "771": {"callee_method_names": [], "method_name": "StartupParameters.isOutputPDB", "method_implementation": "{\n    return printPDB;\n}", "repo_id": "9", "comment": "/**\n * When writing the results to a file, don;t write as XML but write aligned PDB file\n *\n * @return flag\n */\n", "repo_name": "biojava-master/", "id": 771, "method_signature": "boolean isOutputPDB()"}, "3410": {"callee_method_names": ["StringBuilder.append", "StringBuilder.insert", "StringBuilder.length", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorH.getOrientationWithZoom", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    s.append(getOrientation(index));\n    s.insert(s.length() - 1, getZoom());\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script that sets a specific orientation and zoom\n * to draw either axes or polyhedron\n * @param index orientation index\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3410, "method_signature": "String getOrientationWithZoom(int)"}, "1018": {"callee_method_names": ["Structure.nrModels", "Structure.getModel", "List<Atom>.toArray"], "method_name": "StructureTools.getAtomArrayAllModels", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>();\n    for (int i = 0; i < s.nrModels(); i++) {\n        List<Chain> chains = s.getModel(i);\n        extractAtoms(atomNames, chains, atoms);\n    }\n    return atoms.toArray(new Atom[0]);\n}", "repo_id": "9", "comment": "/**\n * Returns an array of the requested Atoms from the Structure object. In\n * contrast to {@link #getAtomArray(Structure, String[])} this method\n * iterates over all chains. Iterates over all chains and groups and checks\n * if the requested atoms are in this group, no matter if this is a\n * {@link AminoAcid} or {@link HetatomImpl} group. If the group does not\n * contain all requested atoms then no atoms are added for that group. For\n * structures with more than one model, only model 0 will be used.\n *\n * @param s\n *            the structure to get the atoms from\n *\n * @param atomNames\n *            contains the atom names to be used.\n * @return an Atom[] array\n */\n", "repo_name": "biojava-master/", "id": 1018, "method_signature": "Atom[] getAtomArrayAllModels(Structure, String[])"}, "720": {"callee_method_names": ["Atom.getGroup"], "method_name": "CECalculator.calc_rmsd", "method_implementation": "{\n    Atom[] cod1 = getAtoms(pro1, strLen, false);\n    Atom[] cod2 = getAtoms(pro2, strLen, true);\n    Matrix4d trans = SuperPositions.superpose(Calc.atomsToPoints(cod1), Calc.atomsToPoints(cod2));\n    Matrix matrix = Matrices.getRotationJAMA(trans);\n    Atom shift = Calc.getTranslationVector(trans);\n    if (storeTransform) {\n        r = matrix;\n        t = shift;\n    }\n    for (Atom a : cod2) Calc.transform(a.getGroup(), trans);\n    return Calc.rmsd(cod1, cod2);\n}", "repo_id": "9", "comment": "/**\n * superimpose and get rmsd\n *\n * @param pro1\n * @param pro2\n * @param strLen Number of atoms from pro1 and pro2 to use\n * @param storeTransform Store rotation and shift matrices locally\n * @return RMSD\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 720, "method_signature": "double calc_rmsd(Atom[], Atom[], int, boolean)"}, "82": {"callee_method_names": [], "method_name": "AlignerHelper.setScorePoint", "method_implementation": "{\n    int d = scores[x - 1][y][0] + gep;\n    int i = scores[x][y - 1][0] + gep;\n    int s = scores[x - 1][y - 1][0] + sub;\n    if (d >= s && d >= i) {\n        scores[x][y][0] = d;\n        return Last.DELETION;\n    } else if (s >= i) {\n        scores[x][y][0] = s;\n        return Last.SUBSTITUTION;\n    } else {\n        scores[x][y][0] = i;\n        return Last.INSERTION;\n    }\n}", "repo_id": "9", "comment": "/**\n * Calculates the optimal alignment score for the given sequence positions and a linear gap penalty\n * @param x position in query\n * @param y position in target\n * @param gep gap extension penalty\n * @param sub compound match score\n * @param scores dynamic programming score matrix to fill at the given position\n * @return traceback directions for substitution, deletion and insertion respectively\n */\n", "repo_name": "biojava-master/", "id": 82, "method_signature": "Last setScorePoint(int, int, int, int, int[][][])"}, "3574": {"callee_method_names": [], "method_name": "Matrix.diag", "method_implementation": "{\n    double[][] d = new double[A.length][A.length];\n    for (int i = 0; i < d.length; i++) {\n        d[i][i] = A[i];\n    }\n    return d;\n}", "repo_id": "9", "comment": "/**\n * @param A\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3574, "method_signature": "double[][] diag(double[])"}, "2708": {"callee_method_names": ["String.trim", "String.length", "ArrayList<String>.add", "String.split", "ArrayList<String>.isEmpty", "ArrayList<String>.remove", "ArrayList<String>.isEmpty", "String.length", "ArrayList<String>.get", "ArrayList<String>.remove", "String.trim", "ArrayList<String>.add", "ArrayList<String>.isEmpty"], "method_name": "GenericInsdcHeaderFormat._split_multi_line", "method_implementation": "{\n    // TODO Auto-generated method stub\n    ArrayList<String> output = new ArrayList<String>();\n    text = text.trim();\n    if (text.length() <= max_len) {\n        output.add(text);\n        return output;\n    }\n    ArrayList<String> words = new ArrayList<String>();\n    Collections.addAll(words, text.split(\"\\\\s+\"));\n    while (!words.isEmpty()) {\n        text = words.remove(0);\n        while (!words.isEmpty() && (text.length() + 1 + words.get(0).length()) <= max_len) {\n            text += \" \" + words.remove(0);\n            text = text.trim();\n        }\n        output.add(text);\n    }\n    assert words.isEmpty();\n    return output;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of strings.\n *\n *   Any single words which are too long get returned as a whole line\n *   (e.g. URLs) without an exception or warning.\n * @param text\n * @param max_len\n */\n", "repo_name": "biojava-master/", "id": 2708, "method_signature": "ArrayList<String> _split_multi_line(String, int)"}, "3364": {"callee_method_names": [], "method_name": "DefaultMatrixMapper.getColor", "method_implementation": "{\n    float hue = 1.0f;\n    hue = (float) (1 - (value / scalevalue));\n    if (hue < 0)\n        hue = 0;\n    return Color.getHSBColor(hue, saturation, hue);\n}", "repo_id": "9", "comment": "/**\n * @param value\n * @return\n * @see org.biojava.nbio.structure.gui.util.color.ContinuousColorMapper#getColor(double)\n */\n", "repo_name": "biojava-master/", "id": 3364, "method_signature": "Color getColor(double)"}, "1291": {"callee_method_names": [], "method_name": "BondMaker.formDisulfideBonds", "method_implementation": "{\n    for (SSBondImpl disulfideBond : disulfideBonds) {\n        formDisulfideBond(disulfideBond);\n    }\n}", "repo_id": "9", "comment": "/**\n * Creates disulfide bond objects and references in the corresponding Atoms objects, given\n * a list of {@link SSBondImpl}s parsed from a PDB file.\n * @param disulfideBonds\n */\n", "repo_name": "biojava-master/", "id": 1291, "method_signature": "void formDisulfideBonds(List)"}, "347": {"callee_method_names": ["Atom.setX", "Atom.getX", "Atom.getX", "Atom.setY", "Atom.getY", "Atom.getY", "Atom.setZ", "Atom.getZ", "Atom.getZ"], "method_name": "Calc.subtract", "method_implementation": "{\n    Atom c = new AtomImpl();\n    c.setX(a.getX() - b.getX());\n    c.setY(a.getY() - b.getY());\n    c.setZ(a.getZ() - b.getZ());\n    return c;\n}", "repo_id": "9", "comment": "/**\n * subtract two atoms ( a - b).\n *\n * @param a\n *            an Atom object\n * @param b\n *            an Atom object\n * @return n new Atom object representing the difference\n */\n", "repo_name": "biojava-master/", "id": 347, "method_signature": "Atom subtract(Atom, Atom)"}, "326": {"callee_method_names": ["Dataset.getLocalDir", "File.exists", "File.mkdir", "File.getAbsolutePath", "String.lastIndexOf", "String.substring"], "method_name": "TestAcetylation.getLocalFileName", "method_implementation": "{\n    Dataset ds = new Dataset();\n    File localDir = ds.getLocalDir();\n    if (!localDir.exists()) {\n        boolean success = localDir.mkdir();\n        if (!success)\n            fail(\"Could not create directory \" + localDir.getAbsolutePath());\n    }\n    int slashIndex = phosphoSiteFileLocation.lastIndexOf(\"/\");\n    String fileName = phosphoSiteFileLocation.substring(slashIndex);\n    return new File(localDir + \"/\" + fileName);\n}", "repo_id": "9", "comment": "/**\n * Returns the local file name where the Acetylation file will get cached locally.\n *\n * @param phosphoSiteFileLocation location of file at PhosphoSitePlus.\n * @return a File pointing to the location of the locally cached file.\n */\n", "repo_name": "biojava-master/", "id": 326, "method_signature": "File getLocalFileName(String)"}, "203": {"callee_method_names": [], "method_name": "FastaSequence.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * Gets the value of id\n *\n * @return the value of id\n */\n", "repo_name": "biojava-master/", "id": 203, "method_signature": "String getId()"}, "1503": {"callee_method_names": [], "method_name": "SuperPositionQCP.set", "method_implementation": "{\n    this.x = x;\n    this.y = y;\n    this.weight = weight;\n    rmsdCalculated = false;\n    transformationCalculated = false;\n}", "repo_id": "9", "comment": "/**\n * Sets the two input coordinate arrays and weight array. All input arrays\n * must be of equal length. Input coordinates are not modified.\n *\n * @param x\n *            3d points of reference coordinate set\n * @param y\n *            3d points of coordinate set for superposition\n * @param weight\n *            a weight in the inclusive range [0,1] for each point\n */\n", "repo_name": "biojava-master/", "id": 1503, "method_signature": "void set(Point3d[], Point3d[], double[])"}, "1350": {"callee_method_names": [], "method_name": "EntityInfo.setChains", "method_implementation": "{\n    this.chains = chains;\n}", "repo_id": "9", "comment": "/**\n * Set the chains for this EntityInfo\n * @param chains\n */\n", "repo_name": "biojava-master/", "id": 1350, "method_signature": "void setChains(List)"}, "3334": {"callee_method_names": [], "method_name": "AlignmentCalc.interrupt", "method_implementation": "{\n    interrupted = true;\n}", "repo_id": "9", "comment": "/**\n * stops what is currently happening and does not continue\n */\n", "repo_name": "biojava-master/", "id": 3334, "method_signature": "void interrupt()"}, "2993": {"callee_method_names": ["String.charAt"], "method_name": "BitSequenceReader.populate", "method_implementation": "{\n    for (int index = 0; index < getLength(); index++) {\n        setCompoundAt(sequence.charAt(index), index + 1);\n    }\n}", "repo_id": "9", "comment": "/**\n * Loops through the chars in a String and passes them onto\n * {@link #setCompoundAt(char, int)}\n */\n", "repo_name": "biojava-master/", "id": 2993, "method_signature": "void populate(String)"}, "3065": {"callee_method_names": [], "method_name": "GeneSequence.getTranscripts", "method_implementation": "{\n    return transcriptSequenceHashMap;\n}", "repo_id": "9", "comment": "/**\n * Get the collection of transcription sequences assigned to this gene\n * @return transcripts\n */\n", "repo_name": "biojava-master/", "id": 3065, "method_signature": "LinkedHashMap<String,TranscriptSequence> getTranscripts()"}, "153": {"callee_method_ids": [490, 489, 487], "callee_method_names": ["AFPChain.getOptLen", "AFPChain.getOptAln", "AFPChain.getBlockNum"], "method_name": "OptimalCECPMainTest.printOptAln", "method_implementation": "{\n    int[] optLen = cpAlignment.getOptLen();\n    int[][][] optAln = cpAlignment.getOptAln();\n    for (int block = 0; block < cpAlignment.getBlockNum(); block++) {\n        for (int pos = 0; pos < optLen[block]; pos++) {\n            System.out.format(\"%s\\t%s\\n\", optAln[block][0][pos], optAln[block][1][pos]);\n        }\n        System.out.println();\n    }\n}", "repo_id": "9", "comment": "/**\n * Print an AFPChain manually for debugging\n * @param cpAlignment\n */\n", "repo_name": "biojava-master/", "id": 153, "method_signature": "void printOptAln(AFPChain)"}, "3733": {"callee_method_names": ["ArrayList<String>.add"], "method_name": "WorkSheet.addRow", "method_implementation": "{\n    ArrayList<String> rows = new ArrayList<String>();\n    rows.add(row);\n    addRows(rows, defaultValue);\n}", "repo_id": "9", "comment": "/**\n * @param row\n * @param defaultValue\n */\n", "repo_name": "biojava-master/", "id": 3733, "method_signature": "void addRow(String, String)"}, "1670": {"callee_method_names": [], "method_name": "Subunit.size", "method_implementation": "{\n    return reprAtoms.length;\n}", "repo_id": "9", "comment": "/**\n * The size of a Subunit is the number of residues it contains.\n *\n * @return the size of the Subunit\n */\n", "repo_name": "biojava-master/", "id": 1670, "method_signature": "int size()"}, "1962": {"callee_method_names": [], "method_name": "HelixAxisAligner.getReverseTransformation", "method_implementation": "{\n    run();\n    return reverseTransformationMatrix;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getReverseTransformation()\n\t */\n", "repo_name": "biojava-master/", "id": 1962, "method_signature": "Matrix4d getReverseTransformation()"}, "3763": {"callee_method_ids": [3752, 3752, 3708, 3708, 3706, 3706, 3752, 3756, 3756, 3741, 3736, 3741, 3736, 3717, 3716], "callee_method_names": ["WorkSheet.getColumns", "WorkSheet.getColumns", "WorkSheet.getDataColumns", "WorkSheet.getDataColumns", "WorkSheet.getMetaDataColumns", "WorkSheet.getMetaDataColumns", "WorkSheet.getColumns", "ArrayList<String>.add", "ArrayList<String>.addAll", "ArrayList<String>.addAll", "ArrayList<String>.contains", "ArrayList<String>.size", "ArrayList<String>.size", "ArrayList<String>.add", "ArrayList<String>.contains", "ArrayList<String>.add", "ArrayList<String>.contains", "ArrayList<String>.add", "WorkSheet.getRows", "WorkSheet.getRows", "HashSet<String>.contains", "ArrayList<String>.add", "WorkSheet.getCell", "WorkSheet.addCell", "WorkSheet.getCell", "WorkSheet.addCell", "WorkSheet.setMetaDataColumnsAfterColumn", "WorkSheet.setMetaDataRowsAfterRow"], "method_name": "WorkSheet.unionWorkSheetsRowJoin", "method_implementation": "{\n    ArrayList<String> w1Columns = w1.getColumns();\n    ArrayList<String> w2Columns = w2.getColumns();\n    ArrayList<String> w1DataColumns = w1.getDataColumns();\n    ArrayList<String> w2DataColumns = w2.getDataColumns();\n    ArrayList<String> w1MetaDataColumns = w1.getMetaDataColumns();\n    ArrayList<String> w2MetaDataColumns = w2.getMetaDataColumns();\n    if (secondSheetMetaData) {\n        if (!w1.getColumns().contains(\"META_DATA\")) {\n            w1DataColumns.add(\"META_DATA\");\n        }\n    }\n    ArrayList<String> joinedColumns = new ArrayList<String>();\n    joinedColumns.addAll(w1DataColumns);\n    joinedColumns.addAll(w2DataColumns);\n    if (!joinedColumns.contains(\"META_DATA\") && (w1MetaDataColumns.size() > 0 || w2MetaDataColumns.size() > 0)) {\n        joinedColumns.add(\"META_DATA\");\n    }\n    for (String column : w1MetaDataColumns) {\n        if (!joinedColumns.contains(column)) {\n            joinedColumns.add(column);\n        }\n    }\n    for (String column : w2MetaDataColumns) {\n        if (!joinedColumns.contains(column)) {\n            joinedColumns.add(column);\n        }\n    }\n    ArrayList<String> w1Rows = w1.getRows();\n    ArrayList<String> w2Rows = w2.getRows();\n    ArrayList<String> rows = new ArrayList<String>();\n    HashSet<String> w1Key = new HashSet<String>(w1Rows);\n    for (String key : w2Rows) {\n        if (w1Key.contains(key)) {\n            rows.add(key);\n        }\n    }\n    WorkSheet worksheet = new WorkSheet(rows, joinedColumns);\n    for (String row : rows) {\n        for (String column : w1Columns) {\n            if (\"META_DATA\".equals(column)) {\n                continue;\n            }\n            String value = w1.getCell(row, column);\n            worksheet.addCell(row, column, value);\n        }\n    }\n    for (String row : rows) {\n        for (String column : w2Columns) {\n            if (\"META_DATA\".equals(column)) {\n                continue;\n            }\n            String value = w2.getCell(row, column);\n            worksheet.addCell(row, column, value);\n        }\n    }\n    worksheet.setMetaDataColumnsAfterColumn();\n    worksheet.setMetaDataRowsAfterRow();\n    return worksheet;\n}", "repo_id": "9", "comment": "/**\n * * Combine two work sheets where you join based on rows. Rows that are\n * found in one but not the other are removed. If the second sheet is meta\n * data then a meta data column will be added between the two joined columns\n *\n * @param w1\n * @param w2\n * @param secondSheetMetaData\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3763, "method_signature": "WorkSheet unionWorkSheetsRowJoin(WorkSheet, WorkSheet, boolean)"}, "1749": {"callee_method_names": [], "method_name": "TertiaryBasePairParameters.getMaxPropeller", "method_implementation": "{\n    return maxPropeller;\n}", "repo_id": "9", "comment": "/**\n * This method returns the maximum propeller twist between bases used as criteria for the characterization of two bases as being paired.\n * @return the maximum propeller (\"propeller-twist\", in degrees) allowed.\n */\n", "repo_name": "biojava-master/", "id": 1749, "method_signature": "double getMaxPropeller()"}, "2881": {"callee_method_names": ["Sequence<C>.getLength", "Map<C, Integer>.entrySet", "Map.Entry<String, ProteinSequence>.getValue", "Map<C, Double>.put", "Map.Entry<String, ProteinSequence>.getKey"], "method_name": "SequenceMixin.getDistribution", "method_implementation": "{\n    Map<C, Double> results = new HashMap<C, Double>();\n    Map<C, Integer> composition = getComposition(sequence);\n    double length = sequence.getLength();\n    for (Map.Entry<C, Integer> entry : composition.entrySet()) {\n        double dist = entry.getValue().doubleValue() / length;\n        results.put(entry.getKey(), dist);\n    }\n    return results;\n}", "repo_id": "9", "comment": "/**\n * Analogous to {@link #getComposition(Sequence)} but returns the\n * distribution of that {@link Compound} over the given sequence.\n *\n * @param <C> The type of compound to look for\n * @param sequence The type of sequence to look over\n * @return Returns the decimal fraction of the compounds in the given\n * sequence. Any compound not in the Map will return a fraction of 0.\n */\n", "repo_name": "biojava-master/", "id": 2881, "method_signature": "Map<C,Double> getDistribution(Sequence)"}, "1435": {"callee_method_names": [], "method_name": "CrystalBuilder.hasNcsOps", "method_implementation": "{\n    return chainNcsOps != null;\n}", "repo_id": "9", "comment": "/**\n * @return true if this CrystalBuilder is NCS-aware.\n * @since 5.0.0\n */\n", "repo_name": "biojava-master/", "id": 1435, "method_signature": "boolean hasNcsOps()"}, "489": {"callee_method_names": [], "method_name": "AFPChain.getOptAln", "method_implementation": "{\n    return optAln;\n}", "repo_id": "9", "comment": "/**\n * Tracks the Atom positions in the optimal alignment. Note: only considers the equivalent positions, gaps are ignored...\n * first dimension is the block nr\n * second dimension is 0 or 1 (the alignment chain index)\n * third is the position\n * @return int array\n */\n", "repo_name": "biojava-master/", "id": 489, "method_signature": "int[][][] getOptAln()"}, "2538": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getAminoAcidSubstitutionMatrix", "method_implementation": "{\n    SubstitutionMatrix<AminoAcidCompound> matrix = getMatrixFromAAINDEX(name);\n    if (matrix != null)\n        return matrix;\n    return getAminoAcidMatrix(name);\n}", "repo_id": "9", "comment": "/**\n * Returns a substitution matrix for {@link AminoAcidCompound amino acids} given by the name {@code name}.\n * Searches first in the default AAINDEX file (see @link {@link #getMatrixFromAAINDEX(String)}), then in the classpath\n * in src/main/resources/matrices.\n * Example names:\n * <ul>\n * <li>blosum62</li>\n * <li>JOND920103</li>\n * <li>pam250</li>\n * <li>gonnet250</li>\n * </ul>\n * @param name Either a common name or an AAINDEX name\n * @return a {@code} SubstitutionMatrix {@code} or {@code}null{@code} if no matrix is found\n */\n", "repo_name": "biojava-master/", "id": 2538, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getAminoAcidSubstitutionMatrix(String)"}, "3102": {"callee_method_names": ["List<Number>.get"], "method_name": "QualityFeature.getQualityAt", "method_implementation": "{\n    return qualities.get(bioindex - 1);\n}", "repo_id": "9", "comment": "/**\n * @param bioindex the biological index (starts with 1)\n * @return the quality value at the given biological index (starts with 1)\n */\n", "repo_name": "biojava-master/", "id": 3102, "method_signature": "Number getQualityAt(int)"}, "1193": {"callee_method_ids": [1789], "callee_method_names": ["String.substring", "String.length", "StringBuilder.length", "StringBuilder.indexOf", "StringBuilder.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString", "String.split", "String.length", "Logger.debug", "Structure.getIdentifier", "ArrayList<String>.add", "PDBHeader.setKeywords"], "method_name": "PDBFileParser.handlePDBKeywords", "method_implementation": "{\n    StringBuilder fullList = new StringBuilder();\n    for (String line : lines) {\n        String kwList = line.substring(10).trim();\n        if (kwList.length() > 0) {\n            if (fullList.length() > 0 && fullList.indexOf(\"-\", fullList.length() - 1) < 0) {\n                fullList.append(' ');\n            }\n            fullList.append(kwList);\n        }\n    }\n    String fulllengthList = fullList.toString();\n    keywords = fulllengthList.split(\"( )*,( )*\");\n    ArrayList<String> lst = new ArrayList<String>(keywords.length);\n    for (String keyword : keywords) {\n        if (keyword.length() == 0) {\n            logger.debug(\"Keyword empty in structure {}\", structure.getIdentifier().toString());\n            continue;\n        }\n        lst.add(keyword);\n    }\n    pdbHeader.setKeywords(lst);\n}", "repo_id": "9", "comment": "/**\n * Parse KEYWODS record of the PDB file.<br>\n *  A keyword may be split over two lines. whether a keyword ends by the end\n *  of a line or it is aplit over two lines, a <code>space</code> is added\n *  between the 2 lines's contents, unless the first line ends in\n *  a '-' character.\n *  <pre>\n *  Record Format\n *  COLUMNS       DATA  TYPE     FIELD         DEFINITION\n * \t---------------------------------------------------------------------------------\n * \t 1 -  6       Record name    \"KEYWDS\"\n * \t 9 - 10       Continuation   continuation  Allows concatenation of records if necessary.\n * \t11 - 79       List           keywds        Comma-separated list of keywords relevant\n * \t                                           to the entry.\n *  Example\n *  \t         1         2         3         4         5         6         7         8\n * \t12345678901234567890123456789012345678901234567890123456789012345678901234567890\n * \tKEYWDS    LYASE,  TRICARBOXYLIC ACID CYCLE, MITOCHONDRION, OXIDATIVE\n * \tKEYWDS   2 METABOLISM\n *  </pre>\n *  @param lines The KEWODS record lines.\n *  @author Amr ALHOSSARY\n */\n", "repo_name": "biojava-master/", "id": 1193, "method_signature": "void handlePDBKeywords(List)"}, "1069": {"callee_method_names": ["Map<String, String>.containsKey", "Map<String, String>.get", "Map<String, String>.containsKey", "Map<String, String>.get", "Map<String, String>.containsKey", "Map<String, String>.get", "Logger.error", "URL.getPath", "String.substring", "String.lastIndexOf"], "method_name": "URLIdentifier.toCanonical", "method_implementation": "{\n    String pdbId = null;\n    List<ResidueRange> ranges = Collections.emptyList();\n    try {\n        Map<String, String> params = parseQuery(url);\n        if (params.containsKey(PDBID_PARAM)) {\n            pdbId = params.get(PDBID_PARAM);\n        }\n        if (params.containsKey(RESIDUES_PARAM)) {\n            ranges = ResidueRange.parseMultiple(params.get(RESIDUES_PARAM));\n        } else if (params.containsKey(CHAINID_PARAM)) {\n            ranges = Collections.singletonList(new ResidueRange(params.get(CHAINID_PARAM), (ResidueNumber) null, (ResidueNumber) null));\n        }\n    } catch (UnsupportedEncodingException e) {\n        logger.error(\"Unable to decode URL {}\", url, e);\n    }\n    if (pdbId == null) {\n        String path = url.getPath();\n        pdbId = guessPDBID(path.substring(path.lastIndexOf(\"/\") + 1));\n    }\n    return new SubstructureIdentifier((pdbId == null ? (PdbId) null : new PdbId(pdbId)), ranges);\n}", "repo_id": "9", "comment": "/**\n * @return A SubstructureIdentifier without ranges (e.g. including all residues)\n */\n", "repo_name": "biojava-master/", "id": 1069, "method_signature": "SubstructureIdentifier toCanonical()"}, "1903": {"callee_method_names": ["List<Integer>.size", "HashMap.containsKey", "HashMap.get", "HashMap.put"], "method_name": "RotationSolver.isValidPermutation", "method_implementation": "{\n    if (permutation.size() == 0) {\n        return null;\n    }\n    // cached value\n    if (evaluatedPermutations.containsKey(permutation)) {\n        return evaluatedPermutations.get(permutation);\n    }\n    // check if permutation is allowed\n    if (!isAllowedPermutation(permutation)) {\n        evaluatedPermutations.put(permutation, null);\n        return null;\n    }\n    // check if superimposes\n    Rotation rot = superimposePermutation(permutation);\n    return rot;\n}", "repo_id": "9", "comment": "/**\n * Checks if a particular permutation is allowed and superimposes well.\n * Caches results.\n * @param permutation\n * @return null if invalid, or a rotation if valid\n */\n", "repo_name": "biojava-master/", "id": 1903, "method_signature": "Rotation isValidPermutation(List)"}, "3846": {"callee_method_names": [], "method_name": "Convert2SecondaryStructure.convert", "method_implementation": "{\n    switch(c) {\n        case 'E':\n        case 'A':\n        case 'L':\n        case 'M':\n        case 'Q':\n        case 'K':\n        case 'R':\n        case 'H':\n            //Helix\n            return group1;\n        case 'V':\n        case 'I':\n        case 'Y':\n        case 'C':\n        case 'W':\n        case 'F':\n        case 'T':\n            //Strand\n            return group2;\n        case 'G':\n        case 'N':\n        case 'P':\n        case 'S':\n        case 'D':\n            //Coil\n            return group3;\n        default:\n            //Non-standard AA\n            return unknownGroup;\n    }\n}", "repo_id": "9", "comment": "/**\n * Class for the conversion of protein sequence into secondary structure\n */\n", "repo_name": "biojava-master/", "id": 3846, "method_signature": "char convert(char)"}, "103": {"callee_method_names": ["MultipleSequenceAlignment<C,D>.getAlignedSequences", "String.getAccession", "FastaWriter<C, D>.process", "OutputStream.toString"], "method_name": "ForesterWrapper.convert", "method_implementation": "{\n    // Convert the biojava MSA to a FASTA String\n    OutputStream os = new ByteArrayOutputStream();\n    FastaWriter<C, D> fastaW = new FastaWriter<C, D>(os, msa.getAlignedSequences(), new FastaHeaderFormatInterface<C, D>() {\n\n        @Override\n        public String getHeader(C sequence) {\n            return sequence.getAccession().toString();\n        }\n    });\n    fastaW.process();\n    String fastaMSA = os.toString();\n    // Parse the FASTA file in forester\n    return FastaParser.parseMsa(fastaMSA);\n}", "repo_id": "9", "comment": "/**\n * Convert a BioJava {@link MultipleSequenceAlignment} to a forester\n * {@link Msa}. The easiest way to convert them is writting the msa as a\n * FASTA file and then parsing it with the forester {@link FastaParser}.\n *\n * @param msa\n *            BioJava MultipleSequenceAlignment\n * @return forester Msa object\n * @throws IOException\n *             if the conversion was not possible\n */\n", "repo_name": "biojava-master/", "id": 103, "method_signature": "Msa convert(MultipleSequenceAlignment)"}, "1004": {"callee_method_names": ["HashMap<ResidueNumber, Integer>.get"], "method_name": "AtomPositionMap.getPosition", "method_implementation": "{\n    return hashMap.get(residueNumber);\n}", "repo_id": "9", "comment": "/**\n * Gets the 0-based index of residueNumber to the matched atoms\n * @param residueNumber\n * @return The position of the ATOM record in the PDB file corresponding to\n * the {@code residueNumber}, or null if the residueNumber was not found\n */\n", "repo_name": "biojava-master/", "id": 1004, "method_signature": "Integer getPosition(ResidueNumber)"}, "218": {"callee_method_names": [], "method_name": "NonstandardProteinCompoundTest.getUniprot", "method_implementation": "{\n    AminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    UniprotProxySequenceReader<AminoAcidCompound> uniprotSequence = new UniprotProxySequenceReader<AminoAcidCompound>(uniProtID, set);\n    ProteinSequence seq = new ProteinSequence(uniprotSequence);\n    return seq;\n}", "repo_id": "9", "comment": "/**\n * Fetch a protein sequence from the UniProt web site\n *\n * @param uniProtID\n * @return a Protein Sequence\n * @throws IOException\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 218, "method_signature": "ProteinSequence getUniprot(String)"}, "2293": {"callee_method_names": [], "method_name": "TestStructureCrossReferences.testCrossReferencesRawFile", "method_implementation": "{\n    // TODO implement\n}", "repo_id": "9", "comment": "//@Test\n", "repo_name": "biojava-master/", "id": 2293, "method_signature": "void testCrossReferencesRawFile()"}, "3531": {"callee_method_names": [], "method_name": "CoxCoefficient.getCoeff", "method_implementation": "{\n    return coeff;\n}", "repo_id": "9", "comment": "/**\n * @return the coeff\n */\n", "repo_name": "biojava-master/", "id": 3531, "method_signature": "double getCoeff()"}, "1475": {"callee_method_names": ["Matrix3d.invert"], "method_name": "CrystalCell.getM", "method_implementation": "{\n    if (M != null) {\n        return M;\n    }\n    M = new Matrix3d();\n    M.invert(getMInv());\n    return M;\n}", "repo_id": "9", "comment": "/**\n * Returns the change of basis (orthonormal to crystal) transform matrix, that is\n * M in the notation of Giacovazzo.\n * Using the PDB convention (NCODE=1).\n * The matrix is only calculated upon first call of this method, thereafter it is cached.\n * See \"Fundamentals of Crystallography\" C. Giacovazzo, section 2.5\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1475, "method_signature": "Matrix3d getM()"}, "3700": {"callee_method_names": [], "method_name": "HeaderInfo.isHide", "method_implementation": "{\n    return hide;\n}", "repo_id": "9", "comment": "/**\n * @return the hide\n */\n", "repo_name": "biojava-master/", "id": 3700, "method_signature": "boolean isHide()"}, "2835": {"callee_method_names": [], "method_name": "GenericGenbankHeaderParser.setName", "method_implementation": "{\n    if (name == null)\n        throw new ParserException(\"Name cannot be null\");\n    if (this.name != null)\n        throw new ParserException(\"Current BioEntry already has a name\");\n    this.name = name;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2835, "method_signature": "void setName(String)"}, "1775": {"callee_method_names": [], "method_name": "PDBHeader.setModDate", "method_implementation": "{\n    this.modDate = modDate;\n}", "repo_id": "9", "comment": "/**\n * The latest modification date of the structure.\n *\n * @param modDate the latest modification date\n */\n", "repo_name": "biojava-master/", "id": 1775, "method_signature": "void setModDate(Date)"}, "3284": {"callee_method_names": ["AFPChain.getAlnseq1", "AFPChain.getAlnseq2", "AFPChain.getAlnsymb", "AFPChain.getAlgorithmName", "List<Integer>.add"], "method_name": "DisplayAFP.getEQRAlignmentPos", "method_implementation": "{\n    List<Integer> lst = new ArrayList<Integer>();\n    char[] s1 = afpChain.getAlnseq1();\n    char[] s2 = afpChain.getAlnseq2();\n    char[] symb = afpChain.getAlnsymb();\n    boolean isFatCat = afpChain.getAlgorithmName().startsWith(\"jFatCat\");\n    for (int i = 0; i < s1.length; i++) {\n        char c1 = s1[i];\n        char c2 = s2[i];\n        if (isAlignedPosition(i, c1, c2, isFatCat, symb)) {\n            lst.add(i);\n        }\n    }\n    return lst;\n}", "repo_id": "9", "comment": "//TODO: same as getEqrPos??? !!!\n", "repo_name": "biojava-master/", "id": 3284, "method_signature": "List<Integer> getEQRAlignmentPos(AFPChain)"}, "2326": {"callee_method_ids": [1342, 1348], "callee_method_names": ["Structure.getEntityInfos", "List<EntityInfo>.size", "List<EntityInfo>.get", "EntityInfo.getDescription", "EntityInfo.getChainIds", "EntityInfo.getChains"], "method_name": "PdbFileFormat30Test.testIsLegacyFormat_pdb_COMPND_handler", "method_implementation": "{\n    Structure s = getStructure(\"/3mk3.pdb\");\n    List<EntityInfo> compounds = s.getEntityInfos();\n    // we are doing heuristics to find missing compounds not specified in header\n    // thus here we have the one specified in header plus a SO4 nonpolymer entity\n    assertEquals(2, compounds.size());\n    EntityInfo mol = compounds.get(0);\n    assertTrue(mol.getDescription().equals(\"6,7-DIMETHYL-8-RIBITYLLUMAZINE SYNTHASE\"));\n    assertEquals(60, mol.getChainIds().size());\n    assertEquals(60, mol.getChains().size());\n    assertTrue(isChainNameInEntity(mol, \"S\"));\n    assertTrue(isChainNameInEntity(mol, \"T\"));\n    assertTrue(isChainNameInEntity(mol, \"U\"));\n    assertTrue(isChainNameInEntity(mol, \"g\"));\n    assertTrue(isChainNameInEntity(mol, \"h\"));\n    assertTrue(isChainNameInEntity(mol, \"i\"));\n}", "repo_id": "9", "comment": "/**\n * Checks that the legacy file check is working and that that non-legacy\n * files have the correct number of chains when the line length is over\n * 72 characters.\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2326, "method_signature": "void testIsLegacyFormat_pdb_COMPND_handler()"}, "778": {"callee_method_names": [], "method_name": "CeCPMain.filterDuplicateAFPs", "method_implementation": "{\n    return filterDuplicateAFPs(afpChain, ceCalc, ca1, ca2duplicated, null);\n}", "repo_id": "9", "comment": "/**\n * Takes as input an AFPChain where ca2 has been artificially duplicated.\n * This raises the possibility that some residues of ca2 will appear in\n * multiple AFPs. This method filters out duplicates and makes sure that\n * all AFPs are numbered relative to the original ca2.\n *\n * <p>The current version chooses a CP site such that the length of the\n * alignment is maximized.\n *\n * <p>This method does <i>not</i> update scores to reflect the filtered alignment.\n * It <i>does</i> update the RMSD and superposition.\n *\n * @param afpChain The alignment between ca1 and ca2-ca2. Blindly assumes\n *  that ca2 has been duplicated.\n * @return A new AFPChain consisting of ca1 to ca2, with each residue in\n *  at most 1 AFP.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 778, "method_signature": "AFPChain filterDuplicateAFPs(AFPChain, CECalculator, Atom[], Atom[])"}, "3577": {"callee_method_names": [], "method_name": "Matrix.random", "method_implementation": "{\n    double[][] C = new double[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            C[i][j] = Math.random();\n        }\n    }\n    return C;\n}", "repo_id": "9", "comment": "/**\n * @param m\n * @param n\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3577, "method_signature": "double[][] random(int, int)"}, "3082": {"callee_method_names": [], "method_name": "AbstractFeature.setType", "method_implementation": "{\n    this.type = type;\n}", "repo_id": "9", "comment": "/**\n * Set the feature type\n * @param type\n */\n", "repo_name": "biojava-master/", "id": 3082, "method_signature": "void setType(String)"}, "3346": {"callee_method_names": ["Color.getColorComponents"], "method_name": "HSVColorSpace.toRGB", "method_implementation": "{\n    int rgb = Color.HSBtoRGB(hsv[0], hsv[1], hsv[2]);\n    Color rgbColor = new Color(rgb);\n    return rgbColor.getColorComponents(null);\n}", "repo_id": "9", "comment": "/**\n * @param hsv 3-component array specifying hue, saturation, value\n * @return equivalent red,green,blue components\n * @see java.awt.color.ColorSpace#toRGB(float[])\n */\n", "repo_name": "biojava-master/", "id": 3346, "method_signature": "float[] toRGB(float[])"}, "2979": {"callee_method_names": [], "method_name": "JoiningSequenceReader.getSequenceIndex", "method_implementation": "{\n    if (BINARY_SEARCH) {\n        return binarySearch(position);\n    } else {\n        return linearSearch(position);\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns which Sequence holds the position queried for\n */\n", "repo_name": "biojava-master/", "id": 2979, "method_signature": "int getSequenceIndex(int)"}, "864": {"callee_method_names": ["TreeMap<Key, Value>.containsKey", "TreeMap<Key, Value>.headMap", "SortedMap<Key, Value>.isEmpty", "SortedMap<Key, Value>.lastKey"], "method_name": "SymbolTable.floor", "method_implementation": "{\n    if (st.containsKey(k))\n        return k;\n    // does not include key if present (!)\n    SortedMap<Key, Value> head = st.headMap(k);\n    if (head.isEmpty())\n        return null;\n    else\n        return head.lastKey();\n}", "repo_id": "9", "comment": "/**\n * Return the largest key in the table <= k.\n */\n", "repo_name": "biojava-master/", "id": 864, "method_signature": "Key floor(Key)"}, "1874": {"callee_method_names": [], "method_name": "Helix.getTransformation", "method_implementation": "{\n    return transformation;\n}", "repo_id": "9", "comment": "/**\n * @return the transformation\n */\n", "repo_name": "biojava-master/", "id": 1874, "method_signature": "Matrix4d getTransformation()"}, "2075": {"callee_method_names": ["List<Integer>.addAll", "List<Integer>.addAll", "List<List<Integer>>.get", "List<List<Integer>>.add", "List<Integer>.addAll", "List<Integer>.addAll", "List<List<Integer>>.get", "List<List<Integer>>.add", "Random.nextDouble", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Random.nextDouble", "List<List<Integer>>.get", "Logger.debug", "List<Integer>.addAll", "List<Integer>.addAll", "List<List<Integer>>.get", "List<List<Integer>>.add", "List<Long>.add", "List<Integer>.add", "List<Double>.add", "MultipleAlignment.getScore", "List<Double>.add", "MultipleAlignment.getScore", "List<Double>.add", "MultipleAlignment.putScore", "Logger.warn", "MultipleAlignmentEnsemble.getMessage"], "method_name": "SymmOptimizer.optimize", "method_implementation": "{\n    initialize();\n    // Save the optimal alignment\n    List<List<Integer>> optBlock = new ArrayList<List<Integer>>();\n    List<Integer> optFreePool = new ArrayList<Integer>();\n    optFreePool.addAll(freePool);\n    for (int k = 0; k < order; k++) {\n        List<Integer> b = new ArrayList<Integer>();\n        b.addAll(block.get(k));\n        optBlock.add(b);\n    }\n    double optScore = mcScore;\n    // Number of steps without an alignment improvement\n    int conv = 0;\n    int i = 1;\n    int stepsToConverge = Math.max(maxIter / 50, 1000);\n    long initialTime = System.nanoTime() / 1000000;\n    while (i < maxIter && conv < stepsToConverge) {\n        // Save the state of the system\n        List<List<Integer>> lastBlock = new ArrayList<List<Integer>>();\n        List<Integer> lastFreePool = new ArrayList<Integer>();\n        lastFreePool.addAll(freePool);\n        for (int k = 0; k < order; k++) {\n            List<Integer> b = new ArrayList<Integer>();\n            b.addAll(block.get(k));\n            lastBlock.add(b);\n        }\n        double lastScore = mcScore;\n        int lastRepeatCore = repeatCore;\n        boolean moved = false;\n        while (!moved) {\n            // Randomly select one of the steps to modify the alignment.\n            // Because of biased moves, the probabilities are not the same\n            double move = rnd.nextDouble();\n            if (move < 0.4) {\n                moved = shiftRow();\n                logger.debug(\"did shift\");\n            } else if (move < 0.7) {\n                moved = expandBlock();\n                logger.debug(\"did expand\");\n            } else if (move < 0.85) {\n                moved = shrinkBlock();\n                logger.debug(\"did shrink\");\n            } else {\n                moved = insertGap();\n                logger.debug(\"did insert gap\");\n            }\n        }\n        // Get the properties of the new alignment\n        updateMultipleAlignment();\n        mcScore = MultipleAlignmentScorer.getMCScore(msa, Gopen, Gextend, dCutoff);\n        // Calculate change in the optimization Score\n        double AS = mcScore - lastScore;\n        double prob = 1.0;\n        if (AS < 0) {\n            // Probability of accepting bad move\n            prob = probabilityFunction(AS, i, maxIter);\n            double p = rnd.nextDouble();\n            // Reject the move\n            if (p > prob) {\n                block = lastBlock;\n                freePool = lastFreePool;\n                length = block.get(0).size();\n                repeatCore = lastRepeatCore;\n                mcScore = lastScore;\n                // no change in score if rejected\n                conv++;\n            } else\n                // if accepted\n                conv = 0;\n        } else\n            // if positive change\n            conv = 0;\n        logger.debug(i + \": --prob: \" + prob + \", --score: \" + AS + \", --conv: \" + conv);\n        // Store as the optimal alignment if better\n        if (mcScore > optScore) {\n            optBlock = new ArrayList<List<Integer>>();\n            optFreePool = new ArrayList<Integer>();\n            optFreePool.addAll(freePool);\n            for (int k = 0; k < order; k++) {\n                List<Integer> b = new ArrayList<Integer>();\n                b.addAll(block.get(k));\n                optBlock.add(b);\n            }\n            optScore = mcScore;\n        }\n        if (history) {\n            if (i % saveStep == 1) {\n                // Get the correct superposition again\n                updateMultipleAlignment();\n                timeHistory.add(System.nanoTime() / 1000000 - initialTime);\n                lengthHistory.add(length);\n                rmsdHistory.add(msa.getScore(MultipleAlignmentScorer.RMSD));\n                tmScoreHistory.add(msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE));\n                mcScoreHistory.add(mcScore);\n            }\n        }\n        i++;\n    }\n    // Use the optimal alignment of the trajectory\n    block = optBlock;\n    freePool = optFreePool;\n    mcScore = optScore;\n    // Superimpose and calculate final scores\n    updateMultipleAlignment();\n    msa.putScore(MultipleAlignmentScorer.MC_SCORE, mcScore);\n    // Save the history to the results folder of the symmetry project\n    if (history) {\n        try {\n            saveHistory(pathToHistory);\n        } catch (Exception e) {\n            logger.warn(\"Could not save history file: \" + e.getMessage());\n        }\n    }\n    return msa;\n}", "repo_id": "9", "comment": "/**\n * Optimization method based in a Monte-Carlo approach. Starting from the\n * refined alignment uses 4 types of moves:\n * <p>\n * <li>1- Shift Row: if there are enough freePool residues available.\n * <li>2- Expand Block: add another alignment column.\n * <li>3- Shrink Block: move a block column to the freePool.\n * <li>4- Insert gap: insert a gap in a position of the alignment.\n *\n * @throws StructureException\n * @throws RefinerFailedException\n *             if the alignment is not symmetric or too short.\n */\n", "repo_name": "biojava-master/", "id": 2075, "method_signature": "MultipleAlignment optimize()"}, "2507": {"callee_method_names": [], "method_name": "SimpleSequencePair.getPercentageOfIdentity", "method_implementation": "{\n    double seqid = getNumIdenticals();\n    double length = getLength();\n    if (!countGaps) {\n        length = length - getAlignedSequence(1).getNumGapPositions() - getAlignedSequence(2).getNumGapPositions();\n    }\n    return seqid / length;\n}", "repo_id": "9", "comment": "/**\n * Returns the percentage of identity between the two sequences in the alignment as a fraction between 0 and 1.\n *\n * @param countGaps\n * \t\tIf true, gap positions are counted as mismatches, i.e., the percentage is normalized by the alignment length.\n * \t\tIf false, gap positions are not counted, i.e. the percentage is normalized by the number of aligned residue pairs.\n *      See May (2004). \"Percent sequence identity: the need to be explicit.\"\n * @return the percentage of sequence identity as a fraction in [0,1]\n */\n", "repo_name": "biojava-master/", "id": 2507, "method_signature": "double getPercentageOfIdentity(boolean)"}, "2841": {"callee_method_names": ["S.getAccession", "String.length", "S.getCompoundSet", "S.getCompoundSet", "S.getCompoundSet", "String.length", "Formatter.format", "S.getLength", "Formatter.toString", "Formatter.close"], "method_name": "GenericGenbankHeaderFormat._write_the_first_line", "method_implementation": "{\n    /*\n\t\t * locus = record.name if not locus or locus == \"<unknown name>\": locus\n\t\t * = record.id if not locus or locus == \"<unknown id>\": locus =\n\t\t * self._get_annotation_str(record, \"accession\", just_first=True)\\\n\t\t */\n    String locus;\n    try {\n        locus = sequence.getAccession().getID();\n    } catch (Exception e) {\n        locus = \"\";\n    }\n    if (locus.length() > 16) {\n        throw new RuntimeException(\"Locus identifier \" + locus + \" is too long\");\n    }\n    String units = \"\";\n    String mol_type = \"\";\n    if (sequence.getCompoundSet() instanceof DNACompoundSet) {\n        units = \"bp\";\n        mol_type = \"DNA\";\n    } else if (sequence.getCompoundSet() instanceof RNACompoundSet) {\n        units = \"bp\";\n        mol_type = \"RNA\";\n    } else if (sequence.getCompoundSet() instanceof AminoAcidCompoundSet) {\n        units = \"aa\";\n        mol_type = \"\";\n    } else {\n        throw new RuntimeException(\"Need a DNACompoundSet, RNACompoundSet, or an AminoAcidCompoundSet\");\n    }\n    String division = _get_data_division(sequence);\n    if (seqType != null) {\n        division = seqType;\n    }\n    assert units.length() == 2;\n    // the next line does not seem right.. seqType == linear\n    // uncommenting for now\n    //assert division.length() == 3;\n    StringBuilder sb = new StringBuilder();\n    Formatter formatter = new Formatter(sb, Locale.US);\n    formatter.format(\"LOCUS       %s %s %s    %s           %s %s\" + lineSep, StringManipulationHelper.padRight(locus, 16), StringManipulationHelper.padLeft(Integer.toString(sequence.getLength()), 11), units, StringManipulationHelper.padRight(mol_type, 6), division, _get_date(sequence));\n    String output = formatter.toString();\n    formatter.close();\n    return output;\n    /*\n\t\t * assert len(line) == 79+1, repr(line) #plus one for new line\n\t\t *\n\t\t * assert line[12:28].rstrip() == locus, \\ 'LOCUS line does not contain\n\t\t * the locus at the expected position:\\n' + line assert line[28:29] ==\n\t\t * \" \" assert line[29:40].lstrip() == str(len(record)), \\ 'LOCUS line\n\t\t * does not contain the length at the expected position:\\n' + line\n\t\t *\n\t\t * #Tests copied from Bio.GenBank.Scanner assert line[40:44] in [' bp ',\n\t\t * ' aa '] , \\ 'LOCUS line does not contain size units at expected\n\t\t * position:\\n' + line assert line[44:47] in [' ', 'ss-', 'ds-', 'ms-'],\n\t\t * \\ 'LOCUS line does not have valid strand type (Single stranded,\n\t\t * ...):\\n' + line assert line[47:54].strip() == \"\" \\ or\n\t\t * line[47:54].strip().find('DNA') != -1 \\ or\n\t\t * line[47:54].strip().find('RNA') != -1, \\ 'LOCUS line does not contain\n\t\t * valid sequence type (DNA, RNA, ...):\\n' + line assert line[54:55] ==\n\t\t * ' ', \\ 'LOCUS line does not contain space at position 55:\\n' + line\n\t\t * assert line[55:63].strip() in ['', 'linear', 'circular'], \\ 'LOCUS\n\t\t * line does not contain valid entry (linear, circular, ...):\\n' + line\n\t\t * assert line[63:64] == ' ', \\ 'LOCUS line does not contain space at\n\t\t * position 64:\\n' + line assert line[67:68] == ' ', \\ 'LOCUS line does\n\t\t * not contain space at position 68:\\n' + line assert line[70:71] ==\n\t\t * '-', \\ 'LOCUS line does not contain - at position 71 in date:\\n' +\n\t\t * line assert line[74:75] == '-', \\ 'LOCUS line does not contain - at\n\t\t * position 75 in date:\\n' + line\n\t\t */\n}", "repo_id": "9", "comment": "/**\n * Write the LOCUS line.\n *\n * @param sequence\n */\n", "repo_name": "biojava-master/", "id": 2841, "method_signature": "String _write_the_first_line(S)"}, "1367": {"callee_method_names": [], "method_name": "DBRef.setParent", "method_implementation": "{\n    parent = s;\n}", "repo_id": "9", "comment": "/**\n * Set the structure object that this DBRef relates to.\n *\n * @param s a structure object\n * @see #getParent()\n */\n", "repo_name": "biojava-master/", "id": 1367, "method_signature": "void setParent(Structure)"}, "2766": {"callee_method_names": [], "method_name": "GenbankWriterHelper.writeSequence", "method_implementation": "{\n    writeSequences(outputStream, singleSeqToCollection(sequence));\n}", "repo_id": "9", "comment": "/**\n * Write a sequence to OutputStream\n *\n * @param outputStream\n * @param sequence\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2766, "method_signature": "void writeSequence(OutputStream, Sequence)"}, "3539": {"callee_method_names": [], "method_name": "CoxCoefficient.getMean", "method_implementation": "{\n    return mean;\n}", "repo_id": "9", "comment": "/**\n * @return the mean\n */\n", "repo_name": "biojava-master/", "id": 3539, "method_signature": "double getMean()"}, "1533": {"callee_method_names": [], "method_name": "JournalArticle.setRefn", "method_implementation": "{\n    this.refn = refn;\n}", "repo_id": "9", "comment": "/**\n * Set the value of the refn\n *\n * @param refn new value of refn\n */\n", "repo_name": "biojava-master/", "id": 1533, "method_signature": "void setRefn(String)"}, "2315": {"callee_method_ids": [628, 628, 1588, 628, 628], "callee_method_names": ["AtomCache.getStructure", "AtomCache.getStructure", "Structure.addModel", "Structure.getChains", "SecStrucCalc.calculate", "AtomCache.getStructure", "List<SecStrucState>.addAll", "AtomCache.getStructure", "List<SecStrucState>.size", "List<SecStrucState>.size", "List<SecStrucState>.size", "List<SecStrucState>.get", "List<SecStrucState>.get"], "method_name": "TestSecStrucCalc.testMultiModelPred", "method_implementation": "{\n    String pdbId = \"5pti\";\n    String pdbIdTwo = \"4hhb\";\n    SecStrucCalc sec = new SecStrucCalc();\n    // Combine these into one structure with two models\n    AtomCache cache = new AtomCache();\n    Structure structure = cache.getStructure(pdbId);\n    Structure structureTwo = cache.getStructure(pdbIdTwo);\n    // Join them together\n    structure.addModel(structureTwo.getChains());\n    List<SecStrucState> biojava = sec.calculate(structure, true);\n    // Download the original DSSP implementation output\n    List<SecStrucState> dssp = DSSPParser.parseInputStream(new GZIPInputStream(this.getClass().getResourceAsStream(\"/org/biojava/nbio/structure/secstruc/\" + pdbId + \".dssp.gz\")), cache.getStructure(pdbId), false);\n    dssp.addAll(DSSPParser.parseInputStream(new GZIPInputStream(this.getClass().getResourceAsStream(\"/org/biojava/nbio/structure/secstruc/\" + pdbIdTwo + \".dssp.gz\")), cache.getStructure(pdbIdTwo), false));\n    assertEquals(\"SS assignment lengths do not match\", biojava.size(), dssp.size());\n    for (int i = 0; i < dssp.size(); i++) {\n        assertEquals(\"SS assignment position \" + (i + 1) + \" does not match\", biojava.get(i), dssp.get(i));\n    }\n}", "repo_id": "9", "comment": "/**\n * Test that calculating the secondary structure for multi-model systems works.\n * Combine two PDBs into one multi-model system\n * Calculate the secondary structure\n * Combine with the combined list fetching from the server\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2315, "method_signature": "void testMultiModelPred()"}, "1516": {"callee_method_names": [], "method_name": "UnitQuaternions.orientationAngle", "method_implementation": "{\n    if (!centered) {\n        fixed = CalcPoint.clonePoint3dArray(fixed);\n        moved = CalcPoint.clonePoint3dArray(moved);\n        CalcPoint.center(fixed);\n        CalcPoint.center(moved);\n    }\n    return orientationAngle(fixed, moved);\n}", "repo_id": "9", "comment": "/**\n * The angle of the relative orientation of the two sets of points in 3D.\n * Equivalent to {@link #angle(Quat4d)} of the unit quaternion obtained by\n * {@link #relativeOrientation(Point3d[], Point3d[])}.\n *\n * @param fixed\n *            array of Point3d. Original coordinates will not be modified.\n * @param moved\n *            array of Point3d. Original coordinates will not be modified.\n * @param centered\n *            true if the points are already centered at the origin\n * @return the angle in radians of the relative orientation of the points,\n *         angle to rotate moved to bring it to the same orientation as\n *         fixed.\n */\n", "repo_name": "biojava-master/", "id": 1516, "method_signature": "double orientationAngle(Point3d[], Point3d[], boolean)"}, "187": {"callee_method_ids": [1633, 1635, 1631, 1929], "callee_method_names": ["SubunitClustererParameters.setClustererMethod", "SubunitClustererParameters.setInternalSymmetry", "SubunitClustererParameters.setStructureCoverageThreshold", "QuatSymmetryResults.getSymmetry", "QuatSymmetryResults.getStoichiometry"], "method_name": "TestQuatSymmetryDetectorExamples.testInternalSymmetry", "method_implementation": "{\n    Structure pdb = StructureIO.getStructure(\"BIO:4e3e:1\");\n    // Internal symmetry analysis, use structural clustering\n    SubunitClustererParameters cp = new SubunitClustererParameters();\n    cp.setClustererMethod(SubunitClustererMethod.SEQUENCE_STRUCTURE);\n    cp.setInternalSymmetry(true);\n    // Lower coverage for internal symm\n    cp.setStructureCoverageThreshold(0.75);\n    QuatSymmetryParameters symmParams = new QuatSymmetryParameters();\n    QuatSymmetryResults symmetry = QuatSymmetryDetector.calcGlobalSymmetry(pdb, symmParams, cp);\n    // D2 combined internal and quaternary symmetry\n    assertEquals(\"D3\", symmetry.getSymmetry());\n    assertEquals(\"A6\", symmetry.getStoichiometry().toString());\n}", "repo_id": "9", "comment": "/**\n * A structure with combined internal and quaternary symmetry: 4E3E\n *\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 187, "method_signature": "void testInternalSymmetry()"}, "2296": {"callee_method_names": [], "method_name": "TestBond.testHydrogenToProteinBondMissing", "method_implementation": "{\n    assertEquals(0, countAtomsWithoutBonds(\"4txr\"));\n    assertEquals(0, countAtomsWithoutBonds(\"3nvd\"));\n}", "repo_id": "9", "comment": "/**\n * Test whether these partial occupancy hydrogens are bonded to the residue.\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2296, "method_signature": "void testHydrogenToProteinBondMissing()"}, "1432": {"callee_method_names": ["Matrix4d.getElement", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Matrix4d.getElement", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Matrix4d.getElement", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Matrix4d.getElement", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "CrystalTransform.toXYZString", "method_implementation": "{\n    StringBuilder str = new StringBuilder();\n    for (int i = 0; i < 3; i++) {\n        //for each row\n        boolean emptyRow = true;\n        // TODO work with rational numbers\n        double coef;\n        // X\n        coef = matTransform.getElement(i, 0);\n        // Three cases for coef: zero, one, non-one\n        if (abs(coef) > 1e-6) {\n            // Non-zero\n            if (abs(abs(coef) - 1) < 1e-6) {\n                // +/- 1\n                if (coef < 0) {\n                    str.append(\"-\");\n                }\n            } else {\n                str.append(formatCoef(coef));\n                str.append(\"*\");\n            }\n            str.append(\"x\");\n            emptyRow = false;\n        }\n        // Y\n        coef = matTransform.getElement(i, 1);\n        if (abs(coef) > 1e-6) {\n            // Non-zero\n            if (abs(abs(coef) - 1) < 1e-6) {\n                // +/- 1\n                if (coef < 0) {\n                    str.append(\"-\");\n                } else if (!emptyRow) {\n                    str.append(\"+\");\n                }\n            } else {\n                if (!emptyRow && coef > 0) {\n                    str.append(\"+\");\n                }\n                str.append(formatCoef(coef));\n                str.append(\"*\");\n            }\n            str.append(\"y\");\n            emptyRow = false;\n        }\n        // Z\n        coef = matTransform.getElement(i, 2);\n        if (abs(coef) > 1e-6) {\n            // Non-zero\n            if (abs(abs(coef) - 1) < 1e-6) {\n                // +/- 1\n                if (coef < 0) {\n                    str.append(\"-\");\n                } else if (!emptyRow) {\n                    str.append(\"+\");\n                }\n            } else {\n                if (!emptyRow && coef > 0) {\n                    str.append(\"+\");\n                }\n                str.append(formatCoef(coef));\n                str.append(\"*\");\n            }\n            str.append(\"z\");\n            emptyRow = false;\n        }\n        // Intercept\n        coef = matTransform.getElement(i, 3);\n        if (abs(coef) > 1e-6) {\n            // Non-zero\n            if (!emptyRow && coef > 0) {\n                str.append(\"+\");\n            }\n            str.append(formatCoef(coef));\n        }\n        if (i < 2) {\n            str.append(\",\");\n        }\n    }\n    return str.toString();\n}", "repo_id": "9", "comment": "/**\n * Expresses this transformation in terms of x,y,z fractional coordinates.\n *\n * Examples:\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1432, "method_signature": "String toXYZString()"}, "3830": {"callee_method_names": ["Set<String>.contains", "Set<String>.contains"], "method_name": "AminoAcidProperties.isCharged", "method_implementation": "{\n    if (negChargedAAs.contains(String.valueOf(aa))) {\n        return true;\n    } else if (posChargedAAs.contains(String.valueOf(aa))) {\n        return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * At pH=7, two are negative charged: aspartic acid (Asp, D) and glutamic acid (Glu, E) (acidic side chains),\n * and three are positive charged: lysine (Lys, K), arginine (Arg, R) and histidine (His, H) (basic side chains).\n *\n * @param aa The one-letter amino acid code\n * @return true if amino acid is charged\n */\n", "repo_name": "biojava-master/", "id": 3830, "method_signature": "boolean isCharged(char)"}, "1625": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setSequenceCoverageThreshold", "method_implementation": "{\n    this.sequenceCoverageThreshold = sequenceCoverageThreshold;\n}", "repo_id": "9", "comment": "/**\n * The minimum coverage of the sequence alignment between two subunits to be\n * clustered together.\n *\n * @param sequenceCoverageThreshold\n */\n", "repo_name": "biojava-master/", "id": 1625, "method_signature": "void setSequenceCoverageThreshold(double)"}, "2157": {"callee_method_names": [], "method_name": "StructureImpl.setJournalArticle", "method_implementation": "{\n    this.pdbHeader.setJournalArticle(journalArticle);\n}", "repo_id": "9", "comment": "/**\n * set the associated publication as defined by the JRNL records in a PDB\n * file.\n * @param journalArticle the article\n */\n", "repo_name": "biojava-master/", "id": 2157, "method_signature": "void setJournalArticle(JournalArticle)"}, "3694": {"callee_method_names": [], "method_name": "SurvFitInfo.setStrataInfoHashMap", "method_implementation": "{\n    this.strataInfoHashMap = strataInfoHashMap;\n}", "repo_id": "9", "comment": "/**\n * @param strataInfoHashMap the strataInfoHashMap to set\n */\n", "repo_name": "biojava-master/", "id": 3694, "method_signature": "void setStrataInfoHashMap(LinkedHashMap)"}, "1381": {"callee_method_names": [], "method_name": "DBRef.setDbIdCode", "method_implementation": "{\n    this.dbIdCode = dbIdCode;\n}", "repo_id": "9", "comment": "/**\n * Sequence database          identification code.\n *\n * @param dbIdCode identification code\n * @see #getDbIdCode()\n */\n", "repo_name": "biojava-master/", "id": 1381, "method_signature": "void setDbIdCode(String)"}, "494": {"callee_method_names": [], "method_name": "AFPChain.getAlnbeg2", "method_implementation": "{\n    return alnbeg2;\n}", "repo_id": "9", "comment": "/**\n * @return The index of the first aligned residue in protein 2\n */\n", "repo_name": "biojava-master/", "id": 494, "method_signature": "int getAlnbeg2()"}, "3168": {"callee_method_names": [], "method_name": "TranscriptSequence.getCDSSequences", "method_implementation": "{\n    return cdsSequenceHashMap;\n}", "repo_id": "9", "comment": "/**\n * Get the CDS sequences that have been added to the TranscriptSequences\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3168, "method_signature": "LinkedHashMap<String,CDSSequence> getCDSSequences()"}, "2356": {"callee_method_names": ["String.length", "String.charAt", "FastqVariant.qualityScore", "FastqVariant.minimumQualityScore", "FastqVariant.maximumQualityScore", "FastqVariant.minimumQualityScore", "FastqVariant.maximumQualityScore"], "method_name": "StreamingFastqParser.validateQuality", "method_implementation": "{\n    for (int i = 0, size = quality.length(); i < size; i++) {\n        char c = quality.charAt(i);\n        int qualityScore = variant.qualityScore(c);\n        if (qualityScore < variant.minimumQualityScore() || qualityScore > variant.maximumQualityScore()) {\n            throw new IOException(\"quality score must be between \" + variant.minimumQualityScore() + \" and \" + variant.maximumQualityScore() + \", was \" + qualityScore + \" for ASCII char '\" + c + \"'\");\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Validate the specified quality line.\n *\n * @param quality quality line to validate\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "biojava-master/", "id": 2356, "method_signature": "void validateQuality(String)"}, "2986": {"callee_method_names": [], "method_name": "BitSequenceReader.getAsList", "method_implementation": "{\n    return SequenceMixin.toList(this);\n}", "repo_id": "9", "comment": "/**\n * Returns this Sequence store as a List\n */\n", "repo_name": "biojava-master/", "id": 2986, "method_signature": "List<C> getAsList()"}, "2332": {"callee_method_ids": [640, 640, 640, 640, 640, 640], "callee_method_names": ["AtomCache.getFiletype", "AtomCache.getFiletype", "AtomCache.getFiletype", "AtomCache.getFiletype", "AtomCache.getFiletype", "AtomCache.getFiletype"], "method_name": "TestAtomCache.testFlags", "method_implementation": "{\n    assertEquals(\"flag for parsing mmtf is set to \" + cache.getFiletype() + \" but should be \" + useMmTf, cache.getFiletype() == StructureFiletype.MMTF, useMmTf);\n    assertEquals(\"flag for parsing mmcif is set to \" + cache.getFiletype() + \" but should be set to \" + useMmCif, cache.getFiletype() == StructureFiletype.CIF, useMmCif);\n    assertEquals(\"flag for parsing bcif is set to \" + cache.getFiletype() + \" but should be set to \" + useBcif, cache.getFiletype() == StructureFiletype.BCIF, useBcif);\n}", "repo_id": "9", "comment": "/**\n * test the flags for parsing in the atom cache\n *\n * @param cache\n * @param useMmTf\n * @param useMmCif\n */\n", "repo_name": "biojava-master/", "id": 2332, "method_signature": "void testFlags(AtomCache, boolean, boolean, boolean)"}, "66": {"callee_method_names": [], "method_name": "AbstractMatrixAligner.setStoringScoreMatrix", "method_implementation": "{\n    this.storingScoreMatrix = storingScoreMatrix;\n    if (!storingScoreMatrix) {\n        scores = null;\n    }\n}", "repo_id": "9", "comment": "/**\n * Sets choice to cache the score matrix or to save memory by deleting score matrix after alignment.\n *\n * @param storingScoreMatrix choice to cache the score matrix\n */\n", "repo_name": "biojava-master/", "id": 66, "method_signature": "void setStoringScoreMatrix(boolean)"}, "3665": {"callee_method_names": [], "method_name": "SurvivalInfo.getResidual", "method_implementation": "{\n    return residual;\n}", "repo_id": "9", "comment": "/**\n * @return the residual\n */\n", "repo_name": "biojava-master/", "id": 3665, "method_signature": "double getResidual()"}, "2520": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum30", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum30\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 30 matrix by Henikoff & Henikoff\n * @return Blosum 30 matrix\n */\n", "repo_name": "biojava-master/", "id": 2520, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum30()"}, "3867": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getIsoelectricPoint"], "method_name": "PeptideProperties.getIsoelectricPoint", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getIsoelectricPoint(pSequence, useExpasyValues);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the isoelectric point of sequence. The sequence argument must be\n * a protein sequence consisting of only non-ambiguous characters.\n * The isoelectric point is the pH at which the protein carries no net\n * electrical charge. The isoelectric point will be computed based on\n * approach stated in\n * <a href=\"http://www.innovagen.se/custom-peptide-synthesis/peptide-property-calculator/peptide-property-calculator-notes.asp#PI\">here</a>\n *\n * pKa values used will be either\n * those used by Expasy which referenced \"Electrophoresis 1994, 15, 529-539\"\n * OR\n * A.Lehninger, Principles of Biochemistry, 4th Edition (2005), Chapter 3, page78, Table 3-1.\n *\n * @param sequence\n * \t\ta protein sequence consisting of non-ambiguous characters only\n * @param useExpasyValues\n * \t\twhether to use Expasy values (Default) or Innovagen values\n * @return the isoelectric point of sequence\n */\n", "repo_name": "biojava-master/", "id": 3867, "method_signature": "double getIsoelectricPoint(String, boolean)"}, "664": {"callee_method_names": ["MultipleAlignment.getAtomArrays", "MultipleAlignment.size", "MultipleAlignment.getStructureIdentifier", "Map<String, Integer>.containsKey", "Map<String, Integer>.put", "Map<String, Integer>.get", "Map<String, Integer>.get", "Map<String, Integer>.put", "List<String>.get", "ProteinSequence.setAccession", "MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound>.addAlignedSequence"], "method_name": "MultipleAlignmentTools.toProteinMSA", "method_implementation": "{\n    // Check that the alignment is of protein structures\n    Group g = msta.getAtomArrays().get(0)[0].getGroup();\n    if (!(g instanceof AminoAcid)) {\n        throw new IllegalArgumentException(\"Cannot convert to multiple sequence alignment: \" + \"the structures aligned are not proteins\");\n    }\n    MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msa = new MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound>();\n    Map<String, Integer> uniqueID = new HashMap<String, Integer>();\n    List<String> seqs = getSequenceAlignment(msta);\n    for (int i = 0; i < msta.size(); i++) {\n        // Make sure the identifiers are unique (required by AccessionID)\n        String id = msta.getStructureIdentifier(i).toString();\n        if (uniqueID.containsKey(id)) {\n            uniqueID.put(id, uniqueID.get(id) + 1);\n            id += \"_\" + uniqueID.get(id);\n        } else\n            uniqueID.put(id, 1);\n        AccessionID acc = new AccessionID(id);\n        ProteinSequence pseq = new ProteinSequence(seqs.get(i));\n        pseq.setAccession(acc);\n        msa.addAlignedSequence(pseq);\n    }\n    return msa;\n}", "repo_id": "9", "comment": "/**\n * Convert a MultipleAlignment into a MultipleSequenceAlignment of AminoAcid\n * residues. This method is only valid for protein structure alignments.\n *\n * @param msta\n *            Multiple Structure Alignment\n * @return MultipleSequenceAlignment of protein sequences\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 664, "method_signature": "MultipleSequenceAlignment<ProteinSequence,AminoAcidCompound> toProteinMSA(MultipleAlignment)"}, "1667": {"callee_method_names": ["MultipleAlignment.setEnsemble", "MultipleAlignment.getEnsemble", "ArrayList.stream", "Structure.getRepresentativeAtoms", "Block.setAlignRes"], "method_name": "SubunitCluster.getMultipleAlignment", "method_implementation": "{\n    // Create a multiple alignment with the atom arrays of the Subunits\n    MultipleAlignment msa = new MultipleAlignmentImpl();\n    msa.setEnsemble(new MultipleAlignmentEnsembleImpl());\n    msa.getEnsemble().setAtomArrays(subunits.stream().map(s -> s.getRepresentativeAtoms()).collect(Collectors.toList()));\n    // Fill in the alignment information\n    BlockSet bs = new BlockSetImpl(msa);\n    Block b = new BlockImpl(bs);\n    b.setAlignRes(subunitEQR);\n    // Fill in the transformation matrices\n    new ReferenceSuperimposer(representative).superimpose(msa);\n    // Calculate some scores\n    MultipleAlignmentScorer.calculateScores(msa);\n    return msa;\n}", "repo_id": "9", "comment": "/**\n * The multiple alignment is calculated from the equivalent residues in the\n * SubunitCluster. The alignment is recalculated every time the method is\n * called (no caching).\n *\n * @return MultipleAlignment representation of the aligned residues in this\n *         Subunit Cluster\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 1667, "method_signature": "MultipleAlignment getMultipleAlignment()"}, "1911": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.getLocalTimeLimit", "method_implementation": "{\n    return localTimeLimit;\n}", "repo_id": "9", "comment": "/**\n * @return the localTimeLimit\n */\n", "repo_name": "biojava-master/", "id": 1911, "method_signature": "double getLocalTimeLimit()"}, "532": {"callee_method_names": ["Atom[].clone"], "method_name": "AlignUtils.getFragment", "method_implementation": "{\n    if (pos + fragmentLength > caall.length)\n        return null;\n    Atom[] tmp = new Atom[fragmentLength];\n    for (int i = 0; i < fragmentLength; i++) {\n        tmp[i] = (Atom) caall[i + pos].clone();\n    }\n    return tmp;\n}", "repo_id": "9", "comment": "/**\n * Get a continue subset of Atoms based by the starting position and the length\n *\n * @param caall\n * @param pos the start position\n * @param fragmentLength the length of the subset to extract.\n * @return an Atom[] array\n */\n", "repo_name": "biojava-master/", "id": 532, "method_signature": "Atom[] getFragment(Atom[], int, int)"}, "1570": {"callee_method_names": [], "method_name": "Site.getSiteID", "method_implementation": "{\n    return siteID;\n}", "repo_id": "9", "comment": "/**\n * @return the siteID\n * e.g. CAT, AC1, AC2...\n */\n", "repo_name": "biojava-master/", "id": 1570, "method_signature": "String getSiteID()"}, "283": {"callee_method_names": ["Group.getAtoms", "List<Atom>.size", "List<String>.add", "List<Atom>.get"], "method_name": "StructureUtil.getAtomNames", "method_implementation": "{\n    List<Atom> atoms = group.getAtoms();\n    if (atoms == null) {\n        return Collections.emptyList();\n    }\n    int n = atoms.size();\n    List<String> ret = new ArrayList<String>(n);\n    for (int i = 0; i < n; i++) {\n        ret.add(atoms.get(i).getName());\n    }\n    return ret;\n}", "repo_id": "9", "comment": "/**\n * @param group a {@link Group}.\n * @return all atom names of the group.\n */\n", "repo_name": "biojava-master/", "id": 283, "method_signature": "List<String> getAtomNames(Group)"}, "821": {"callee_method_names": [], "method_name": "AlternativeAlignment.getAltAligNumber", "method_implementation": "{\n    return fromia;\n}", "repo_id": "9", "comment": "/**\n * returns the sequential number of this alternative alignment\n *\n * @return the sequential number of this alternative alignment\n */\n", "repo_name": "biojava-master/", "id": 821, "method_signature": "int getAltAligNumber()"}, "2917": {"callee_method_names": [], "method_name": "AbstractSequence.getNotesList", "method_implementation": "{\n    return notesList;\n}", "repo_id": "9", "comment": "/**\n * @return the notesList\n */\n", "repo_name": "biojava-master/", "id": 2917, "method_signature": "ArrayList<String> getNotesList()"}, "2305": {"callee_method_names": ["Matrix4d.set", "Matrix4d.setTranslation", "Random.nextInt", "Random.nextInt", "Random.nextInt", "Random.nextDouble", "Random.nextDouble", "Random.nextDouble", "List<Point3d[]>.add", "List<Point3d[]>.add", "Logger.debug", "Logger.debug"], "method_name": "TestSuperPosition.setUp", "method_implementation": "{\n    cloud1 = new ArrayList<Point3d[]>(5);\n    cloud2 = new ArrayList<Point3d[]>(5);\n    Random rnd = new Random(0);\n    transform = new Matrix4d();\n    transform.set(rotAxis);\n    transform.setTranslation(translation);\n    List<Integer> sizes = Arrays.asList(5, 50, 500, 5000, 50000, 500000);\n    for (Integer size : sizes) {\n        Point3d[] c1 = new Point3d[size];\n        Point3d[] c2 = new Point3d[size];\n        for (int p = 0; p < size; p++) {\n            Point3d a = new Point3d(rnd.nextInt(100), rnd.nextInt(50), rnd.nextInt(150));\n            c1[p] = a;\n            // Add some noise\n            Point3d b = new Point3d(a.x + rnd.nextDouble(), a.y + rnd.nextDouble(), a.z + rnd.nextDouble());\n            c2[p] = b;\n        }\n        CalcPoint.center(c1);\n        CalcPoint.center(c2);\n        CalcPoint.transform(transform, c1);\n        cloud1.add(c1);\n        cloud2.add(c2);\n        Point3d centroid1 = CalcPoint.centroid(c1);\n        Point3d centroid2 = CalcPoint.centroid(c2);\n        LOGGER.debug(\"Centroid c1 (size %d): (%.2f, %.2f, %.2f)\\n\", size, centroid1.x, centroid1.y, centroid1.z);\n        LOGGER.debug(\"Centroid c2 (size %d): (%.2f, %.2f, %.2f)\\n\", size, centroid2.x, centroid2.y, centroid2.z);\n    }\n}", "repo_id": "9", "comment": "/**\n * Generate two clouds of random points of different sizes to test\n * correctness and performance of superposition algorithms.\n *\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2305, "method_signature": "void setUp()"}, "3685": {"callee_method_ids": [3671, 3654, 3673, 3675, 3657, 3659], "callee_method_names": ["ArrayList<SurvivalInfo>.get", "PrintStream.print", "PrintStream.print", "PrintStream.print", "PrintStream.println", "PrintStream.print", "SurvivalInfo.getOrder", "SurvivalInfo.getVariable", "PrintStream.print", "PrintStream.print", "SurvivalInfo.getTime", "SurvivalInfo.getStatus", "SurvivalInfo.getWeight", "SurvivalInfo.getStrata", "PrintStream.println"], "method_name": "SurvivalInfoHelper.dump", "method_implementation": "{\n    ArrayList<String> variables = DataT.get(0).getDataVariables();\n    ps.print(\"Seq\" + delimiter);\n    for (String variable : variables) {\n        ps.print(variable + delimiter);\n    }\n    ps.print(\"TIME\" + delimiter + \"STATUS\" + delimiter + \"WEIGHT\" + delimiter + \"STRATA\");\n    ps.println();\n    for (SurvivalInfo si : DataT) {\n        ps.print(si.getOrder() + delimiter);\n        for (String variable : variables) {\n            Double value = si.getVariable(variable);\n            ps.print(value + delimiter);\n        }\n        ps.print(si.getTime() + delimiter + si.getStatus() + delimiter + si.getWeight() + delimiter + si.getStrata());\n        ps.println();\n    }\n}", "repo_id": "9", "comment": "/**\n * For each analysis this allows outputing of the data used in the calculations to a printstream/file. This then\n * allows the file to be loaded into R and calculations can be verified.\n * @param DataT\n * @param ps\n * @param delimiter\n */\n", "repo_name": "biojava-master/", "id": 3685, "method_signature": "void dump(ArrayList, PrintStream, String)"}, "853": {"callee_method_ids": [846, 847, 846, 847, 847], "callee_method_names": ["SparseVector.put", "SparseVector.get", "SparseVector.put", "SparseVector.get", "SparseVector.get"], "method_name": "SparseVector.plus", "method_implementation": "{\n    SparseVector a = this;\n    if (a.N != b.N)\n        throw new IllegalArgumentException(\"Vector lengths disagree : \" + a.N + \" != \" + b.N);\n    SparseVector c = new SparseVector(N);\n    // c = a\n    for (int i : a.symbolTable) c.put(i, a.get(i));\n    // c = c + b\n    for (int i : b.symbolTable) c.put(i, b.get(i) + c.get(i));\n    return c;\n}", "repo_id": "9", "comment": "/**\n * Calcualtes return a + b\n *\n * @param b\n * @return\n */\n", "repo_name": "biojava-master/", "id": 853, "method_signature": "SparseVector plus(SparseVector)"}, "490": {"callee_method_names": [], "method_name": "AFPChain.getOptLen", "method_implementation": "{\n    return optLen;\n}", "repo_id": "9", "comment": "/**\n * The length of each block\n * @return lengths\n */\n", "repo_name": "biojava-master/", "id": 490, "method_signature": "int[] getOptLen()"}, "588": {"callee_method_names": [], "method_name": "AlignmentTools.entrySet", "method_implementation": "{\n    return Collections.emptySet();\n}", "repo_id": "9", "comment": "/**\n * Always returns the empty set\n */\n", "repo_name": "biojava-master/", "id": 588, "method_signature": "Set<java.util.Map.Entry<K,K>> entrySet()"}, "1411": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.setCrystalCell", "method_implementation": "{\n    this.cell = cell;\n}", "repo_id": "9", "comment": "/**\n * Set the crystal cell\n * @param cell\n */\n", "repo_name": "biojava-master/", "id": 1411, "method_signature": "void setCrystalCell(CrystalCell)"}, "3488": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.setBlastExpect", "method_implementation": "{\n    setAlignmentOption(EXPECT, Double.toString(expect));\n}", "repo_id": "9", "comment": "/**\n * Sets the EXPECT parameter to be use with blastall\n * <p>\n * Example: if you want a EXPECT of 1e-10, pass {@code Double.parseDouble(\"1e-10\")} as a parameter\n * <p>\n * Blastall equivalent: -e\n *\n * @param expect: a double value of EXPECT parameter\n */\n", "repo_name": "biojava-master/", "id": 3488, "method_signature": "void setBlastExpect(double)"}, "3588": {"callee_method_names": [], "method_name": "Matrix.main", "method_implementation": "{\n    System.out.println(\"D\");\n    System.out.println(\"--------------------\");\n    double[][] d = { { 1, 2, 3 }, { 4, 5, 6 }, { 9, 1, 3 } };\n    StdArrayIO.print(d);\n    System.out.println();\n    System.out.println(\"I\");\n    System.out.println(\"--------------------\");\n    double[][] c = Matrix.identity(5);\n    StdArrayIO.print(c);\n    System.out.println();\n    System.out.println(\"A\");\n    System.out.println(\"--------------------\");\n    double[][] a = Matrix.random(5, 5);\n    StdArrayIO.print(a);\n    System.out.println();\n    System.out.println(\"A^T\");\n    System.out.println(\"--------------------\");\n    double[][] b = Matrix.transpose(a);\n    StdArrayIO.print(b);\n    System.out.println();\n    System.out.println(\"A + A^T\");\n    System.out.println(\"--------------------\");\n    double[][] e = Matrix.add(a, b);\n    StdArrayIO.print(e);\n    System.out.println();\n    System.out.println(\"A * A^T\");\n    System.out.println(\"--------------------\");\n    double[][] f = Matrix.multiply(a, b);\n    StdArrayIO.print(f);\n    System.out.println();\n}", "repo_id": "9", "comment": "/**\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 3588, "method_signature": "void main(String[])"}, "1281": {"callee_method_names": [], "method_name": "MmtfSummaryDataBean.getNumBonds", "method_implementation": "{\n    return numBonds;\n}", "repo_id": "9", "comment": "/**\n * @return the number of covalent bonds in the structure\n */\n", "repo_name": "biojava-master/", "id": 1281, "method_signature": "int getNumBonds()"}, "436": {"callee_method_ids": [433, 483], "callee_method_names": ["FatCatParameters.setMaxTra", "AFPChain.setMaxTra"], "method_name": "FatCatAligner.rChainAfp", "method_implementation": "{\n    params.setMaxTra(0);\n    afpChain.setMaxTra(0);\n    return chainAfp(params, afpChain, ca1, ca2);\n}", "repo_id": "9", "comment": "/**\n * runs rigid chaining process\n */\n", "repo_name": "biojava-master/", "id": 436, "method_signature": "Group[] rChainAfp(FatCatParameters, AFPChain, Atom[], Atom[])"}, "1090": {"callee_method_names": ["Logger.debug", "Logger.error", "int.getMessage", "AtomicBoolean.set", "AtomicBoolean.set"], "method_name": "AllChemCompProvider.run", "method_implementation": "{\n    long timeS = System.currentTimeMillis();\n    initPath();\n    ensureFileExists();\n    try {\n        loadAllChemComps();\n        long timeE = System.currentTimeMillis();\n        logger.debug(\"Time to init chem comp dictionary: {} sec.\", (timeE - timeS) / 1000);\n    } catch (IOException e) {\n        logger.error(\"Could not load chemical components definition file {}. Error: {}\", getLocalFileName(), e.getMessage());\n    } finally {\n        loading.set(false);\n        isInitialized.set(true);\n    }\n}", "repo_id": "9", "comment": "/**\n * Do the actual loading of the dictionary in a thread.\n */\n", "repo_name": "biojava-master/", "id": 1090, "method_signature": "void run()"}, "2400": {"callee_method_names": [], "method_name": "Location.end", "method_implementation": "{\n    return mEnd;\n}", "repo_id": "9", "comment": "/**\n * Get the ending index.\n *\n * @return The index of last symbol + 1 (remember Java half-open coordinates).\n */\n", "repo_name": "biojava-master/", "id": 2400, "method_signature": "int end()"}, "855": {"callee_method_names": ["TreeMap<Key, Value>.get"], "method_name": "SymbolTable.get", "method_implementation": "{\n    return st.get(key);\n}", "repo_id": "9", "comment": "/**\n * Return the value paired with given key; null if key is not in table.\n */\n", "repo_name": "biojava-master/", "id": 855, "method_signature": "Value get(Key)"}, "533": {"callee_method_names": [], "method_name": "AlignUtils.getFragmentNoClone", "method_implementation": "{\n    if (pos + fragmentLength > caall.length)\n        return null;\n    Atom[] tmp = new Atom[fragmentLength];\n    for (int i = 0; i < fragmentLength; i++) {\n        tmp[i] = caall[i + pos];\n    }\n    return tmp;\n}", "repo_id": "9", "comment": "/**\n * Get a continue subset of Atoms based by the starting position and the length\n * does not clone the original atoms.\n *\n * @param caall\n * @param pos the start position\n * @param fragmentLength the length of the subset to extract.\n * @return an Atom[] array\n */\n", "repo_name": "biojava-master/", "id": 533, "method_signature": "Atom[] getFragmentNoClone(Atom[], int, int)"}, "3386": {"callee_method_names": ["StringBuilder.append", "StringBuilder.insert", "StringBuilder.length", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getOrientationWithZoom", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    s.append(getOrientation(index));\n    s.insert(s.length() - 1, getZoom());\n    return s.toString();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#getOrientationWithZoom(int)\n\t */\n", "repo_name": "biojava-master/", "id": 3386, "method_signature": "String getOrientationWithZoom(int)"}, "1344": {"callee_method_names": [], "method_name": "EntityInfo.getRefChainId", "method_implementation": "{\n    return refChainId;\n}", "repo_id": "9", "comment": "/**\n * Return the ref chain id value.\n * @return the RefChainID\n * @see #setRefChainId(String)\n */\n", "repo_name": "biojava-master/", "id": 1344, "method_signature": "String getRefChainId()"}, "1555": {"callee_method_names": [], "method_name": "ScopMirror.getRootURL", "method_implementation": "{\n    return rootURL;\n}", "repo_id": "9", "comment": "/**\n * Get the URL for the root download directory, or null if none is set.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1555, "method_signature": "String getRootURL()"}, "104": {"callee_method_names": ["PhylogenyWriter.toNewHampshire", "StringBuffer.toString"], "method_name": "ForesterWrapper.getNewickString", "method_implementation": "{\n    PhylogenyWriter w = new PhylogenyWriter();\n    StringBuffer newickString = w.toNewHampshire(phylo, writeDistances);\n    return newickString.toString();\n}", "repo_id": "9", "comment": "/**\n * Convert a Phylogenetic tree to its Newick representation, so that it can\n * be exported to an external application.\n *\n * @param phylo\n *            Phylogeny phylogenetic tree\n * @param writeDistances\n *            write the branch lengths if true\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 104, "method_signature": "String getNewickString(Phylogeny, boolean)"}, "3442": {"callee_method_names": ["StructureViewer.getColor"], "method_name": "StructureViewerTest.testGetColor", "method_implementation": "{\n    if (java.awt.GraphicsEnvironment.isHeadless())\n        return;\n    StructureViewer instance = new StructureViewerImpl();\n    Color expResult = null;\n    Color result = instance.getColor();\n    Assert.assertEquals(expResult, result);\n    // TODO review the generated test code and remove the default call to fail.\n    // fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of getColor method, of class StructureViewer.\n */\n", "repo_name": "biojava-master/", "id": 3442, "method_signature": "void testGetColor()"}, "940": {"callee_method_names": [], "method_name": "Grid.hasAnyContact", "method_implementation": "{\n    return hasAnyContact(Arrays.asList(atoms));\n}", "repo_id": "9", "comment": "/**\n * Fast determination of whether any atoms from a given set fall within\n * the cutoff of iAtoms. If {@link #addAtoms(Atom[], Atom[])} was called\n * with two sets of atoms, contacts to either set are considered.\n * @param atoms\n * @return\n */\n", "repo_name": "biojava-master/", "id": 940, "method_signature": "boolean hasAnyContact(Point3d[])"}, "2003": {"callee_method_names": [], "method_name": "Octahedron.setInscribedRadius", "method_implementation": "{\n    double side = getSideLengthFromInscribedRadius(radius);\n    this.cirumscribedRadius = getCircumscribedRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Sets the radius of an inscribed sphere, that is tangent to each\n * of the octahedron's faces\n * @param inscribedRadius the inscribedRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2003, "method_signature": "void setInscribedRadius(double)"}, "501": {"callee_method_names": [], "method_name": "AFPChain.getSimilarity", "method_implementation": "{\n    if (similarity < 0)\n        calcSimilarity();\n    return similarity;\n}", "repo_id": "9", "comment": "/**\n * Returns the similarity score for the alignment. This gives the percent of\n * sequence similar residues in the alignment.\n *\n * @return a double between 0 and 1\n */\n", "repo_name": "biojava-master/", "id": 501, "method_signature": "double getSimilarity()"}, "3199": {"callee_method_names": ["URL.getFile"], "method_name": "SearchIOTest.testConstructorWithFactoryGuess", "method_implementation": "{\n    String resource = \"/org/biojava/nbio/core/search/io/blast/test.two-query.blasttxt\";\n    URL resourceURL = getClass().getResource(resource);\n    File file = new File(resourceURL.getFile());\n    final SearchIO instance;\n    try {\n        instance = new SearchIO(file);\n    } catch (Exception e) {\n        fail(\"test failed:\\n\" + e.getMessage());\n    }\n}", "repo_id": "9", "comment": "/**\n * Constructor test with GuessFactory\n */\n", "repo_name": "biojava-master/", "id": 3199, "method_signature": "void testConstructorWithFactoryGuess()"}, "1174": {"callee_method_names": ["String.trim", "ArrayList.get", "Logger.info", "Element.getMessage", "EntityInfo.setSynthetic", "EntityInfo.setFragment", "EntityInfo.setOrganismScientific", "EntityInfo.setOrganismTaxId", "EntityInfo.setOrganismCommon", "EntityInfo.setStrain", "EntityInfo.setVariant", "EntityInfo.setCellLine", "EntityInfo.setAtcc", "EntityInfo.setOrgan", "EntityInfo.setTissue", "EntityInfo.setCell", "EntityInfo.setOrganelle", "EntityInfo.setSecretion", "EntityInfo.setGene", "EntityInfo.setCellularLocation", "EntityInfo.setExpressionSystem", "EntityInfo.setExpressionSystemTaxId", "EntityInfo.setExpressionSystemStrain", "EntityInfo.setExpressionSystemVariant", "EntityInfo.setExpressionSystemCellLine", "EntityInfo.setExpressionSystemAtccNumber", "EntityInfo.setExpressionSystemOrgan", "EntityInfo.setExpressionSystemTissue", "EntityInfo.setExpressionSystemCell", "EntityInfo.setExpressionSystemOrganelle", "EntityInfo.setExpressionSystemCellularLocation", "EntityInfo.setExpressionSystemVectorType", "EntityInfo.setExpressionSystemVector", "EntityInfo.setExpressionSystemPlasmid", "EntityInfo.setExpressionSystemGene", "EntityInfo.setExpressionSystemOtherDetails"], "method_name": "PDBFileParser.sourceValueSetter", "method_implementation": "{\n    value = value.trim().replace(\";\", \"\");\n    //\t\tSystem.out.println(\"[sourceValueSetter] \" + field);\n    if (\"MOL_ID:\".equals(field)) {\n        try {\n            current_compound = entities.get(Integer.valueOf(value) - 1);\n        } catch (NumberFormatException e) {\n            logger.info(\"could not process SOURCE MOL_ID record correctly:\" + e.getMessage());\n            return;\n        }\n        //\t\t\tSystem.out.println(\"[sourceValueSetter] Fetching compound \" + value + \" \" + current_compound.getMolId());\n    }\n    if (\"SYNTHETIC:\".equals(field)) {\n        current_compound.setSynthetic(value);\n    } else if (\"FRAGMENT:\".equals(field)) {\n        current_compound.setFragment(value);\n    } else if (\"ORGANISM_SCIENTIFIC:\".equals(field)) {\n        current_compound.setOrganismScientific(value);\n    } else if (\"ORGANISM_TAXID:\".equals(field)) {\n        current_compound.setOrganismTaxId(value);\n    } else if (\"ORGANISM_COMMON:\".equals(field)) {\n        current_compound.setOrganismCommon(value);\n    } else if (\"STRAIN:\".equals(field)) {\n        current_compound.setStrain(value);\n    } else if (\"VARIANT:\".equals(field)) {\n        current_compound.setVariant(value);\n    } else if (\"CELL_LINE:\".equals(field)) {\n        current_compound.setCellLine(value);\n    } else if (\"ATCC:\".equals(field)) {\n        current_compound.setAtcc(value);\n    } else if (\"ORGAN:\".equals(field)) {\n        current_compound.setOrgan(value);\n    } else if (\"TISSUE:\".equals(field)) {\n        current_compound.setTissue(value);\n    } else if (\"CELL:\".equals(field)) {\n        current_compound.setCell(value);\n    } else if (\"ORGANELLE:\".equals(field)) {\n        current_compound.setOrganelle(value);\n    } else if (\"SECRETION:\".equals(field)) {\n        current_compound.setSecretion(value);\n    } else if (\"GENE:\".equals(field)) {\n        current_compound.setGene(value);\n    } else if (\"CELLULAR_LOCATION:\".equals(field)) {\n        current_compound.setCellularLocation(value);\n    } else if (\"EXPRESSION_SYSTEM:\".equals(field)) {\n        current_compound.setExpressionSystem(value);\n    } else if (\"EXPRESSION_SYSTEM_TAXID:\".equals(field)) {\n        current_compound.setExpressionSystemTaxId(value);\n    } else if (\"EXPRESSION_SYSTEM_STRAIN:\".equals(field)) {\n        current_compound.setExpressionSystemStrain(value);\n    } else if (\"EXPRESSION_SYSTEM_VARIANT:\".equals(field)) {\n        current_compound.setExpressionSystemVariant(value);\n    } else if (\"EXPRESSION_SYSTEM_CELL_LINE:\".equals(field)) {\n        current_compound.setExpressionSystemCellLine(value);\n    } else if (\"EXPRESSION_SYSTEM_ATCC_NUMBER:\".equals(field)) {\n        current_compound.setExpressionSystemAtccNumber(value);\n    } else if (\"EXPRESSION_SYSTEM_ORGAN:\".equals(field)) {\n        current_compound.setExpressionSystemOrgan(value);\n    } else if (\"EXPRESSION_SYSTEM_TISSUE:\".equals(field)) {\n        current_compound.setExpressionSystemTissue(value);\n    } else if (\"EXPRESSION_SYSTEM_CELL:\".equals(field)) {\n        current_compound.setExpressionSystemCell(value);\n    } else if (\"EXPRESSION_SYSTEM_ORGANELLE:\".equals(field)) {\n        current_compound.setExpressionSystemOrganelle(value);\n    } else if (\"EXPRESSION_SYSTEM_CELLULAR_LOCATION:\".equals(field)) {\n        current_compound.setExpressionSystemCellularLocation(value);\n    } else if (\"EXPRESSION_SYSTEM_VECTOR_TYPE:\".equals(field)) {\n        current_compound.setExpressionSystemVectorType(value);\n    } else if (\"EXPRESSION_SYSTEM_VECTOR:\".equals(field)) {\n        current_compound.setExpressionSystemVector(value);\n    } else if (\"EXPRESSION_SYSTEM_PLASMID:\".equals(field)) {\n        current_compound.setExpressionSystemPlasmid(value);\n    } else if (\"EXPRESSION_SYSTEM_GENE:\".equals(field)) {\n        current_compound.setExpressionSystemGene(value);\n    } else if (\"OTHER_DETAILS:\".equals(field)) {\n        current_compound.setExpressionSystemOtherDetails(value);\n    }\n}", "repo_id": "9", "comment": "/**\n * Set the value in the current molId object\n *\n * @param field\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 1174, "method_signature": "void sourceValueSetter(String, String)"}, "2831": {"callee_method_names": [], "method_name": "GenericGenbankHeaderParser.setVersion", "method_implementation": "{\n    if (this.versionSeen)\n        throw new ParserException(\"Current BioEntry already has a version\");\n    else {\n        try {\n            this.version = version;\n            this.versionSeen = true;\n        } catch (NumberFormatException e) {\n            throw new ParserException(\"Could not parse version as an integer\");\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n * The last accession passed to this routine will always be the one used.\n */\n", "repo_name": "biojava-master/", "id": 2831, "method_signature": "void setVersion(int)"}, "1886": {"callee_method_names": ["Matrix4d.setTranslation", "Matrix4d.mul"], "method_name": "SystematicSolver.combineWithTranslation", "method_implementation": "{\n    rotation.setTranslation(centroid);\n    rotation.mul(rotation, centroidInverse);\n}", "repo_id": "9", "comment": "/**\n * Adds translational component to rotation matrix\n * @param rotTrans\n * @param rotation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1886, "method_signature": "void combineWithTranslation(Matrix4d)"}, "2556": {"callee_method_names": ["ResultFactory.setFile", "ResultFactory.createObjects"], "method_name": "SearchIO.readResults", "method_implementation": "{\n    factory.setFile(file);\n    results = factory.createObjects(evalueThreshold);\n}", "repo_id": "9", "comment": "/**\n * This method is declared private because it is the default action of constructor\n * when file exists\n *\n * @throws java.io.IOException for file access related issues\n * @throws java.text.ParseException for file format related issues\n */\n", "repo_name": "biojava-master/", "id": 2556, "method_signature": "void readResults()"}, "3756": {"callee_method_ids": [3700], "callee_method_names": ["LinkedHashMap.keySet", "LinkedHashMap.get", "HeaderInfo.isHide", "ArrayList<String>.add"], "method_name": "WorkSheet.getRows", "method_implementation": "{\n    ArrayList<String> rows = new ArrayList<String>();\n    for (String row : rowLookup.keySet()) {\n        HeaderInfo hi = rowLookup.get(row);\n        if (!hi.isHide()) {\n            rows.add(row);\n        }\n    }\n    return rows;\n}", "repo_id": "9", "comment": "/**\n * Get the list of row names. Will exclude hidden values\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3756, "method_signature": "ArrayList<String> getRows()"}, "624": {"callee_method_ids": [970], "callee_method_names": ["Structure.getPDBHeader", "Structure.getPDBHeader", "Logger.info", "List<Structure>.add", "Structure.getPDBHeader", "Structure.getPDBHeader", "List<BiologicalAssemblyTransformation>.size", "Logger.info", "BiologicalAssemblyBuilder.rebuildQuaternaryStructure", "List<Structure>.add"], "method_name": "AtomCache.getBiologicalAssemblies", "method_implementation": "{\n    List<Structure> assemblies = new ArrayList<>();\n    boolean prevIsParseBioAssembly = getFileParsingParams().isParseBioAssembly();\n    if (!getFileParsingParams().isParseBioAssembly()) {\n        getFileParsingParams().setParseBioAssembly(true);\n    }\n    Structure asymUnit = getStructureForPdbId(pdbId);\n    getFileParsingParams().setParseBioAssembly(prevIsParseBioAssembly);\n    if (asymUnit.getPDBHeader() == null || asymUnit.getPDBHeader().getBioAssemblies() == null) {\n        logger.info(\"No bioassembly information found for {}, returning asymmetric unit as the only biological assembly\", pdbId);\n        assemblies.add(asymUnit);\n        return assemblies;\n    }\n    for (int bioAssemblyId : asymUnit.getPDBHeader().getBioAssemblies().keySet()) {\n        List<BiologicalAssemblyTransformation> transformations = asymUnit.getPDBHeader().getBioAssemblies().get(bioAssemblyId).getTransforms();\n        if (transformations == null || transformations.size() == 0) {\n            logger.info(\"Could not load transformations to recreate biological assembly id {} of {}. Assembly \" + \"id will be missing in biological assemblies.\", bioAssemblyId, pdbId);\n            continue;\n        }\n        BiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n        // if we use mmcif or mmtf, then we need to pass useAsymIds=true\n        boolean useAsymIds = false;\n        if (filetype == StructureFiletype.CIF || filetype == StructureFiletype.BCIF || filetype == StructureFiletype.MMTF) {\n            useAsymIds = true;\n        }\n        Structure s = builder.rebuildQuaternaryStructure(asymUnit, transformations, useAsymIds, multiModel);\n        assemblies.add(s);\n    }\n    return assemblies;\n}", "repo_id": "9", "comment": "/**\n * Returns all biological assemblies for given PDB id.\n * @param pdbId\n * @param multiModel if true the output Structure will be a multi-model one with one transformId per model,\n * if false the outputStructure will be as the original with added chains with renamed asymIds (in the form originalAsymId_transformId and originalAuthId_transformId).\n * @return\n * @throws StructureException\n * @throws IOException\n * @since 5.0\n */\n", "repo_name": "biojava-master/", "id": 624, "method_signature": "List<Structure> getBiologicalAssemblies(String, boolean)"}, "985": {"callee_method_names": ["Map<String, Atom>.get", "String.trim", "Atom.getName"], "method_name": "HetatomImpl.hasAtom", "method_implementation": "{\n    if (atomNameLookup != null) {\n        Atom a = atomNameLookup.get(fullName.trim());\n        return a != null;\n    } else {\n        // This is the performance penalty we pay for NOT using the atomnameLookup in PerformanceBehaviour.LESS_MEMORY_SLOWER_PERFORMANCE\n        for (Atom a : atoms) {\n            if (a.getName().equals(fullName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 985, "method_signature": "boolean hasAtom(String)"}, "698": {"callee_method_names": ["Random.nextInt", "Random.nextInt", "Random.nextInt", "MultipleAlignment.getBlock", "MultipleAlignment.getBlock", "Block.length", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.length", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.length", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.length", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes"], "method_name": "MultipleMcOptimizer.expandBlock", "method_implementation": "{\n    // Select expanding right (0) or left (1)\n    int rl = rnd.nextInt(2);\n    // Select randomly the Block\n    int bk = rnd.nextInt(blockNr);\n    int res = rnd.nextInt(msa.getBlock(bk).length());\n    Block block = msa.getBlock(bk);\n    // store the number of gaps in the expansion\n    int gaps = 0;\n    switch(rl) {\n        case 0:\n            int rightBound = res;\n            int[] previousPos = new int[size];\n            for (int str = 0; str < size; str++) previousPos[str] = -1;\n            // Search t the right for >Rmin non consecutive residues\n            while (block.length() - 1 > rightBound) {\n                int noncontinuous = 0;\n                for (int str = 0; str < size; str++) {\n                    if (block.getAlignRes().get(str).get(rightBound) == null) {\n                        continue;\n                    } else if (previousPos[str] == -1) {\n                        previousPos[str] = block.getAlignRes().get(str).get(rightBound);\n                    } else if (block.getAlignRes().get(str).get(rightBound) > previousPos[str] + 1) {\n                        noncontinuous++;\n                    }\n                }\n                if (noncontinuous < Rmin)\n                    rightBound++;\n                else\n                    break;\n            }\n            if (rightBound > 0)\n                rightBound--;\n            // Expand the block with the residues at the subunit boundaries\n            for (int str = 0; str < size; str++) {\n                Integer residueR = block.getAlignRes().get(str).get(rightBound);\n                if (residueR == null) {\n                    if (rightBound == block.length() - 1) {\n                        block.getAlignRes().get(str).add(null);\n                    } else\n                        block.getAlignRes().get(str).add(rightBound + 1, null);\n                    gaps++;\n                } else if (freePool.get(str).contains(residueR + 1)) {\n                    Integer residueAdd = residueR + 1;\n                    if (rightBound == block.length() - 1) {\n                        block.getAlignRes().get(str).add(residueAdd);\n                    } else {\n                        block.getAlignRes().get(str).add(rightBound + 1, residueAdd);\n                    }\n                    freePool.get(str).remove(residueAdd);\n                } else {\n                    if (rightBound == block.length() - 1)\n                        block.getAlignRes().get(str).add(null);\n                    else\n                        block.getAlignRes().get(str).add(rightBound + 1, null);\n                    gaps++;\n                }\n            }\n            break;\n        case 1:\n            int leftBoundary = res;\n            int[] nextPos = new int[size];\n            for (int str = 0; str < size; str++) nextPos[str] = -1;\n            // Search position to the right with >Rmin non consecutive residues\n            while (leftBoundary > 0) {\n                int noncontinuous = 0;\n                for (int str = 0; str < size; str++) {\n                    if (block.getAlignRes().get(str).get(leftBoundary) == null)\n                        continue;\n                    else if (nextPos[str] == -1) {\n                        nextPos[str] = block.getAlignRes().get(str).get(leftBoundary);\n                    } else if (block.getAlignRes().get(str).get(leftBoundary) < nextPos[str] - 1) {\n                        noncontinuous++;\n                    }\n                }\n                if (noncontinuous < Rmin)\n                    leftBoundary--;\n                else\n                    break;\n            }\n            // Expand the block with the residues at the subunit boundaries\n            for (int str = 0; str < size; str++) {\n                Integer residueL = block.getAlignRes().get(str).get(leftBoundary);\n                if (residueL == null) {\n                    block.getAlignRes().get(str).add(leftBoundary, null);\n                    gaps++;\n                } else if (freePool.get(str).contains(residueL - 1)) {\n                    Integer residueAdd = residueL - 1;\n                    block.getAlignRes().get(str).add(leftBoundary, residueAdd);\n                    freePool.get(str).remove(residueAdd);\n                } else {\n                    block.getAlignRes().get(str).add(leftBoundary, null);\n                    gaps++;\n                }\n            }\n            break;\n    }\n    if (size - gaps >= Rmin)\n        return true;\n    else\n        checkGaps();\n    return false;\n}", "repo_id": "9", "comment": "/**\n * It extends the alignment one position to the right or to the left of a\n * randomly selected position by moving the consecutive residues of each\n * subunit (if enough) from the freePool to the block.\n * <p>\n * If there are not enough residues in the freePool it introduces gaps.\n */\n", "repo_name": "biojava-master/", "id": 698, "method_signature": "boolean expandBlock()"}, "3280": {"callee_method_names": [], "method_name": "JmolTools.getPdbInfo", "method_implementation": "{\n    return getPdbInfo(a, true);\n}", "repo_id": "9", "comment": "/**\n * get jmol style info:\n *  jmol style: [MET]508:A.CA/1 #3918\n *  insertion code: [ASP]1^A:A.CA/1 #2\n * @param a .. the Atom\n *\n * @return a String representation in Jmol style of the PDB information of this atom\n */\n", "repo_name": "biojava-master/", "id": 3280, "method_signature": "String getPdbInfo(Atom)"}, "55": {"callee_method_names": [], "method_name": "AbstractPairwiseSequenceAligner.setQuery", "method_implementation": "{\n    this.query = query;\n    reset();\n}", "repo_id": "9", "comment": "/**\n * Sets the query {@link Sequence}.\n *\n * @param query the first {@link Sequence} of the pair to align\n */\n", "repo_name": "biojava-master/", "id": 55, "method_signature": "void setQuery(S)"}, "1056": {"callee_method_names": ["Group.isPolymeric", "Group.isWater", "List<Group>.add"], "method_name": "StructureTools.filterLigands", "method_implementation": "{\n    List<Group> groups = new ArrayList<>();\n    for (Group g : allGroups) {\n        if (g.isPolymeric())\n            continue;\n        if (!g.isWater()) {\n            groups.add(g);\n        }\n    }\n    return groups;\n}", "repo_id": "9", "comment": "/**\n * Removes all polymeric and solvent groups from a list of groups\n */\n", "repo_name": "biojava-master/", "id": 1056, "method_signature": "List<Group> filterLigands(List)"}, "2664": {"callee_method_names": [], "method_name": "Builder.getDnaCompounds", "method_implementation": "{\n    if (dnaCompounds != null) {\n        return dnaCompounds;\n    }\n    return AmbiguityDNACompoundSet.getDNACompoundSet();\n}", "repo_id": "9", "comment": "// ------ INTERNAL BUILDERS with defaults if exists\n", "repo_name": "biojava-master/", "id": 2664, "method_signature": "CompoundSet<NucleotideCompound> getDnaCompounds()"}, "3833": {"callee_method_names": ["Set<String>.contains"], "method_name": "AminoAcidProperties.getPolarityOfAminoAcid", "method_implementation": "{\n    if (polarAAs.contains(String.valueOf(aa))) {\n        return 1;\n    }\n    return 0;\n}", "repo_id": "9", "comment": "/**\n * There are 10 amino acids: D, E, H, K, R, N, Q, S, T, Y, that are polar.\n *\n * @param aa The one-letter amino acid code\n * @return the polarity of amino acid (1 if polar, 0 if not polar)\n */\n", "repo_name": "biojava-master/", "id": 3833, "method_signature": "int getPolarityOfAminoAcid(char)"}, "427": {"callee_method_names": ["Atom[].clone"], "method_name": "AFPCalculator.getFragment", "method_implementation": "{\n    if (pos + fragmentLength > caall.length)\n        return null;\n    Atom[] tmp = new Atom[fragmentLength];\n    for (int i = 0; i < fragmentLength; i++) {\n        if (clone) {\n            tmp[i] = (Atom) caall[i + pos].clone();\n        } else {\n            tmp[i] = caall[i + pos];\n        }\n    }\n    return tmp;\n}", "repo_id": "9", "comment": "/**\n * get a continue subset of Atoms based by the starting position and the length\n *\n * @param caall\n * @param pos ... the start position\n * @param fragmentLength .. the length of the subset to extract.\n * @param clone: returns a copy of the atom (in case the coordinate get manipulated...)\n * @return an Atom[] array\n */\n", "repo_name": "biojava-master/", "id": 427, "method_signature": "Atom[] getFragment(Atom[], int, int, boolean)"}, "371": {"callee_method_names": ["Structure.nrModels", "Structure.getChains"], "method_name": "Calc.translate", "method_implementation": "{\n    for (int n = 0; n < structure.nrModels(); n++) {\n        for (Chain c : structure.getChains(n)) {\n            translate(c, v);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Translates a Structure object, given a Vector3d (i.e. the vecmath library\n * double-precision 3-d vector)\n *\n * @param structure\n * @param v\n */\n", "repo_name": "biojava-master/", "id": 371, "method_signature": "void translate(Structure, Vector3d)"}, "481": {"callee_method_names": [], "method_name": "AFPChain.getPdbAln", "method_implementation": "{\n    return pdbAln;\n}", "repo_id": "9", "comment": "/**\n * used temporarily during XML serialization to track the PDB positions of the alignmnet\n *\n * @return String array\n */\n", "repo_name": "biojava-master/", "id": 481, "method_signature": "String[][][] getPdbAln()"}, "128": {"callee_method_names": ["PairwiseSequenceAligner<DNASequence, NucleotideCompound>.getPair"], "method_name": "TestDNAAlignment.testLinearAlignmentLocal", "method_implementation": "{\n    DNASequence query = new DNASequence(\"TGTTACGG\", DNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"GGTTGACTA\", DNACompoundSet.getDNACompoundSet());\n    SubstitutionMatrix<NucleotideCompound> matrix = SubstitutionMatrixHelper.getNuc4_4();\n    SimpleGapPenalty gapP = new SimpleGapPenalty((short) 0, (short) 8);\n    PairwiseSequenceAligner<DNASequence, NucleotideCompound> aligner = Alignments.getPairwiseAligner(query, target, PairwiseSequenceAlignerType.LOCAL, gapP, matrix);\n    Assert.assertEquals(String.format(\"GTT-AC%nGTTGAC%n\"), aligner.getPair().toString());\n    ;\n}", "repo_id": "9", "comment": "/**\n * @author aegugup\n */\n", "repo_name": "biojava-master/", "id": 128, "method_signature": "void testLinearAlignmentLocal()"}, "1031": {"callee_method_names": ["Chain.getAtomGroups", "Group.isWater", "Group.getAtoms", "Atom.getElement", "Group.getType", "List<Point3d>.add", "Atom.getCoordsAsPoint3d", "List<Point3d>.toArray"], "method_name": "StructureTools.getAllNonHCoordsArray", "method_implementation": "{\n    List<Point3d> atoms = new ArrayList<>();\n    for (Group g : c.getAtomGroups()) {\n        if (g.isWater())\n            continue;\n        for (Atom a : g.getAtoms()) {\n            if (a.getElement() == Element.H)\n                continue;\n            if (!hetAtoms && g.getType().equals(GroupType.HETATM))\n                continue;\n            atoms.add(a.getCoordsAsPoint3d());\n        }\n    }\n    return atoms.toArray(new Point3d[0]);\n}", "repo_id": "9", "comment": "/**\n * Returns and array of all non-Hydrogen atoms coordinates in the given Chain,\n * optionally including HET atoms or not Waters are not included.\n *\n * @param c\n * @param hetAtoms\n *            if true HET atoms are included in array, if false they are not\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1031, "method_signature": "Point3d[] getAllNonHCoordsArray(Chain, boolean)"}, "1704": {"callee_method_names": [], "method_name": "AtomImpl.setBonds", "method_implementation": "{\n    this.bonds = bonds;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1704, "method_signature": "void setBonds(List)"}, "1815": {"callee_method_names": [], "method_name": "EcodInstallation.getDomainFile", "method_implementation": "{\n    return new File(getCacheLocation(), getDomainFilename());\n}", "repo_id": "9", "comment": "/**\n * Local location for the domain file\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1815, "method_signature": "File getDomainFile()"}, "3145": {"callee_method_names": ["Document.getDocumentElement", "ArrayList<String>.add", "Element.getTextContent", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "UniprotProxySequenceReader.getKeyWords", "method_implementation": "{\n    ArrayList<String> keyWordsList = new ArrayList<String>();\n    if (uniprotDoc == null) {\n        return keyWordsList;\n    }\n    try {\n        Element uniprotElement = uniprotDoc.getDocumentElement();\n        Element entryElement = XMLHelper.selectSingleElement(uniprotElement, \"entry\");\n        ArrayList<Element> keyWordElementList = XMLHelper.selectElements(entryElement, \"keyword\");\n        for (Element element : keyWordElementList) {\n            keyWordsList.add(element.getTextContent());\n        }\n    } catch (XPathExpressionException e) {\n        logger.error(\"Problems while parsing keywords in UniProt XML: {}. No keywords will be available.\", e.getMessage());\n        return new ArrayList<String>();\n    }\n    return keyWordsList;\n}", "repo_id": "9", "comment": "/**\n * Pull UniProt key words which is a mixed bag of words associated with this sequence\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3145, "method_signature": "ArrayList<String> getKeyWords()"}, "2238": {"callee_method_names": ["String.getBytes", "Structure.getPolyChain", "Structure.getPolyChainByPDB"], "method_name": "CifFileConsumerImplTest.testAtomSiteWithMissingAuthFields", "method_implementation": "{\n    // taken from MGYP000911143359.cif\n    String mmcifStr = \"data_\\n\" + \"loop_\\n\" + \"_atom_site.group_PDB\\n\" + \"_atom_site.id\\n\" + \"_atom_site.type_symbol\\n\" + \"_atom_site.label_atom_id\\n\" + \"_atom_site.label_comp_id\\n\" + \"_atom_site.label_asym_id\\n\" + \"_atom_site.label_entity_id\\n\" + \"_atom_site.label_seq_id\\n\" + \"_atom_site.Cartn_x\\n\" + \"_atom_site.Cartn_y\\n\" + \"_atom_site.Cartn_z\\n\" + \"_atom_site.occupancy\\n\" + \"_atom_site.B_iso_or_equiv\\n\" + \"_atom_site.pdbx_PDB_model_num\\n\" + \"\\n\" + \"ATOM 1 N N MET A 1 1 -26.091 68.903 7.841 1.00 90.0 1\\n\" + \"ATOM 2 C CA MET A 1 1 -26.275 67.677 7.069 1.00 91.0 1\\n\" + \"ATOM 3 C C MET A 1 1 -24.933 67.025 6.755 1.00 90.0 1\\n\" + \"ATOM 4 C CB MET A 1 1 -27.033 67.967 5.773 1.00 89.0 1\\n\" + \"ATOM 5 O O MET A 1 1 -24.314 67.331 5.734 1.00 90.0 1\\n\" + \"ATOM 6 C CG MET A 1 1 -28.544 67.973 5.934 1.00 86.0 1\\n\" + \"ATOM 7 S SD MET A 1 1 -29.390 68.904 4.598 1.00 86.0 1\\n\" + \"ATOM 8 C CE MET A 1 1 -29.202 67.734 3.224 1.00 83.0 1\\n\" + \"ATOM 9 N N ASN A 1 2 -24.267 66.233 7.730 1.00 90.0 1\\n\" + \"ATOM 10 C CA ASN A 1 2 -22.897 65.827 8.029 1.00 91.0 1\\n\" + \"ATOM 11 C C ASN A 1 2 -22.600 64.427 7.500 1.00 90.0 1\\n\" + \"ATOM 12 C CB ASN A 1 2 -22.634 65.893 9.535 1.00 88.0 1\\n\" + \"ATOM 13 O O ASN A 1 2 -23.092 63.436 8.044 1.00 89.0 1\\n\" + \"ATOM 14 C CG ASN A 1 2 -22.191 67.269 9.990 1.00 86.0 1\\n\" + \"ATOM 15 N ND2 ASN A 1 2 -22.255 67.511 11.294 1.00 87.0 1\\n\" + \"ATOM 16 O OD1 ASN A 1 2 -21.795 68.108 9.177 1.00 87.0 1\\n\";\n    MmCifFile cifFile = CifIO.readFromInputStream(new ByteArrayInputStream(mmcifStr.getBytes())).as(StandardSchemata.MMCIF);\n    Structure s = CifStructureConverter.fromCifFile(cifFile);\n    assertNotNull(s);\n    assertEquals(2, s.getPolyChain(\"A\").getAtomGroups().size());\n    assertEquals(2, s.getPolyChainByPDB(\"A\").getAtomGroups().size());\n}", "repo_id": "9", "comment": "/**\n * Testing files with atom_site that doesn't have author fields. E.g. cif files from Meta's ESM Atlas (<a href=\"https://esmatlas.com\">...</a>)\n */\n", "repo_name": "biojava-master/", "id": 2238, "method_signature": "void testAtomSiteWithMissingAuthFields()"}, "693": {"callee_method_names": ["MultipleAlignment.getBlockSets", "String.length", "String.getAlignRes", "List<Integer>.add", "List<List<Integer>>.add", "List<SortedSet<Integer>>.add", "List<Atom[]>.get", "List<List<Integer>>.get", "List<SortedSet<Integer>>.get", "MultipleAlignment.clear", "MultipleSuperimposer.superimpose"], "method_name": "MultipleMcOptimizer.initialize", "method_implementation": "{\n    // Initialize alignment variables\n    freePool = new ArrayList<SortedSet<Integer>>();\n    List<List<Integer>> aligned = new ArrayList<List<Integer>>();\n    // Generate freePool residues from the ones not aligned\n    for (int i = 0; i < size; i++) {\n        List<Integer> residues = new ArrayList<Integer>();\n        for (BlockSet bs : msa.getBlockSets()) {\n            for (Block b : bs.getBlocks()) {\n                for (int l = 0; l < b.length(); l++) {\n                    Integer residue = b.getAlignRes().get(i).get(l);\n                    if (residue != null)\n                        residues.add(residue);\n                }\n            }\n        }\n        aligned.add(residues);\n        freePool.add(new TreeSet<Integer>());\n    }\n    // Add any residue not aligned to the free pool for every structure\n    for (int i = 0; i < size; i++) {\n        for (int k = 0; k < atomArrays.get(i).length; k++) {\n            if (!aligned.get(i).contains(k))\n                freePool.get(i).add(k);\n        }\n    }\n    // Set the superposition and score for the seed aligment\n    checkGaps();\n    msa.clear();\n    imposer.superimpose(msa);\n    mcScore = MultipleAlignmentScorer.getMCScore(msa, Gopen, Gextend, dCutoff);\n    // Initialize the history variables\n    if (history) {\n        lengthHistory = new ArrayList<Integer>();\n        rmsdHistory = new ArrayList<Double>();\n        scoreHistory = new ArrayList<Double>();\n    }\n}", "repo_id": "9", "comment": "/**\n * Initialize the freePool and all the variables needed for the\n * optimization.\n *\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 693, "method_signature": "void initialize()"}, "1852": {"callee_method_names": [], "method_name": "Rotation.setSubunitRmsd", "method_implementation": "{\n    this.subunitRmsd = subunitRmsd;\n}", "repo_id": "9", "comment": "/**\n * @param subunitRmsd the subunitRmsd to set\n */\n", "repo_name": "biojava-master/", "id": 1852, "method_signature": "void setSubunitRmsd(double)"}, "3616": {"callee_method_names": ["LinkedHashMap.put"], "method_name": "CoxInfo.setCoefficient", "method_implementation": "{\n    coefficientsList.put(name, coefficient);\n}", "repo_id": "9", "comment": "/**\n * @param name\n * @param coefficient\n */\n", "repo_name": "biojava-master/", "id": 3616, "method_signature": "void setCoefficient(String, CoxCoefficient)"}, "1347": {"callee_method_names": [], "method_name": "EntityInfo.setMolId", "method_implementation": "{\n    this.molId = molId;\n}", "repo_id": "9", "comment": "/**\n * Set the molecule identifier, called entity_id in mmCIF dictionary.\n * @param molId the molecule id\n * @see #getMolId()\n */\n", "repo_name": "biojava-master/", "id": 1347, "method_signature": "void setMolId(int)"}, "1731": {"callee_method_names": [], "method_name": "BasePairParameters.getRoll", "method_implementation": "{\n    if (bp < 0 || bp >= getStepParameters().length)\n        throw new IllegalArgumentException(\"Base pair number is out of range.\");\n    return stepParameters[bp][1];\n}", "repo_id": "9", "comment": "/**\n * This method returns the roll for the given base pair, relative to the one before it.\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in degrees)\n */\n", "repo_name": "biojava-master/", "id": 1731, "method_signature": "Double getRoll(int)"}, "833": {"callee_method_names": [], "method_name": "AsaCalculator.setUseSpatialHashingForNeighbors", "method_implementation": "{\n    this.useSpatialHashingForNeighbors = useSpatialHashingForNeighbors;\n}", "repo_id": "9", "comment": "/**\n * Set the useSpatialHashingForNeighbors flag to use spatial hashing to calculate neighbors (true) or all-to-all\n * distance calculation (false). Default is {@value DEFAULT_USE_SPATIAL_HASHING}.\n * Use for testing performance only.\n * @param useSpatialHashingForNeighbors the flag\n */\n", "repo_name": "biojava-master/", "id": 833, "method_signature": "void setUseSpatialHashingForNeighbors(boolean)"}, "156": {"callee_method_ids": [641], "callee_method_names": ["AtomCache.setFiletype", "Structure.nrModels", "Structure.getPolyChains", "Structure.getPolyChains", "Structure.getPolyChains"], "method_name": "TestBioassemblies.test1M4X", "method_implementation": "{\n    AtomCache prevAtomCache = StructureIO.getAtomCache();\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    StructureIO.setAtomCache(cache);\n    Structure flattenedBioAssembly5 = StructureIO.getBiologicalAssembly(\"1M4X\", 5);\n    // checking that we have 1 model only\n    assertEquals(1, flattenedBioAssembly5.nrModels());\n    // bioassembly 5 expands to 90 chains (3 chains x 5 operators x 6 operators), the expression is '(1-5)(61-88)'\n    assertEquals(90, flattenedBioAssembly5.getPolyChains().size());\n    // the operator ids are composed for this case, e.g. A_5x61\n    assertTrue(flattenedBioAssembly5.getPolyChains().get(0).getId().contains(\"x\"));\n    assertEquals(2, flattenedBioAssembly5.getPolyChains().get(0).getId().split(\"_\").length);\n    StructureIO.setAtomCache(prevAtomCache);\n}", "repo_id": "9", "comment": "/**\n * A test for an entry with cartesian product in assembly operators\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 156, "method_signature": "void test1M4X()"}, "2252": {"callee_method_ids": [956, 958], "callee_method_names": ["BiologicalAssemblyTransformation.setChainId", "BiologicalAssemblyTransformation.setTransformationMatrix", "List<BiologicalAssemblyTransformation>.add", "BioAssemblyInfo.setTransforms", "Map<String, Integer>.put", "Map<double[], int[]>.keySet", "Map<double[], int[]>.values"], "method_name": "TestMmtfUtils.testMakePrimitiveBioasembly", "method_implementation": "{\n    double[] testData = new double[] { 0.0, 0.1, 0.2, 0.3, 1.0, 1.1, 1.2, 1.3, 2.0, 2.1, 2.2, 2.3, 3.0, 3.1, 3.2, 3.3 };\n    BioAssemblyInfo bioAssemblyInfo = new BioAssemblyInfo();\n    List<BiologicalAssemblyTransformation> transforms = new ArrayList<>();\n    BiologicalAssemblyTransformation biologicalAssemblyTransformation = new BiologicalAssemblyTransformation();\n    biologicalAssemblyTransformation.setChainId(\"C\");\n    biologicalAssemblyTransformation.setTransformationMatrix(new Matrix4d(testData));\n    transforms.add(biologicalAssemblyTransformation);\n    bioAssemblyInfo.setTransforms(transforms);\n    // Map the chain to the second index\n    Map<String, Integer> chainIdToIndexMap = new HashMap<>();\n    chainIdToIndexMap.put(\"C\", 2);\n    // Now do the conversion and test they are the same\n    Map<double[], int[]> transMap = MmtfUtils.getTransformMap(bioAssemblyInfo, chainIdToIndexMap);\n    assertArrayEquals(testData, (double[]) transMap.keySet().toArray()[0], 0.0);\n    assertArrayEquals(new int[] { 2 }, (int[]) transMap.values().toArray()[0]);\n}", "repo_id": "9", "comment": "/**\n * Test to check the conversion of BioassemblyInfo to a primitive map.\n */\n", "repo_name": "biojava-master/", "id": 2252, "method_signature": "void testMakePrimitiveBioasembly()"}, "3620": {"callee_method_ids": [3531, 3539], "callee_method_names": ["LinkedHashMap.values", "CoxCoefficient.getCoeff", "LinkedHashMap.values", "CoxCoefficient.getMean"], "method_name": "CoxInfo.dump", "method_implementation": "{\n    //need an ordered list for comparing to R dumps\n    //        ArrayList<SurvivalInfo> orderedSurvivalInfoList = new ArrayList<SurvivalInfo>(survivalInfoList);\n    //        SurvivalInfoComparator sicSort = new SurvivalInfoComparator();\n    //       Collections.sort(orderedSurvivalInfoList,sicSort);\n    System.out.println();\n    System.out.println(\"$coef\");\n    for (CoxCoefficient coe : coefficientsList.values()) {\n        System.out.print(coe.getCoeff() + \" \");\n    }\n    System.out.println();\n    System.out.println(\"$means\");\n    for (CoxCoefficient coe : coefficientsList.values()) {\n        System.out.print(coe.getMean() + \" \");\n    }\n    System.out.println();\n    System.out.println(\"$u\");\n    for (double d : u) {\n        System.out.print(d + \" \");\n    }\n    System.out.println();\n    System.out.println(\"$imat\");\n    for (int i = 0; i < imat.length; i++) {\n        for (int j = 0; j < imat[0].length; j++) {\n            System.out.print(imat[i][j] + \" \");\n        }\n        System.out.println();\n    }\n    if (this.naive_imat != null) {\n        System.out.println(\"$naive_imat\");\n        for (int i = 0; i < naive_imat.length; i++) {\n            for (int j = 0; j < naive_imat[0].length; j++) {\n                System.out.print(naive_imat[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n    System.out.println();\n    System.out.println(\"$loglik\");\n    System.out.println(loglikInit + \" \" + loglikFinal);\n    System.out.println();\n    System.out.println(\"$sctest\");\n    System.out.println(this.scoreLogrankTest);\n    System.out.println(\"$iter\");\n    System.out.println(this.iterations);\n    System.out.println(\"$flag\");\n    System.out.println(flag);\n    System.out.println();\n    //        if (false) {\n    //            System.out.println(\"ID      LP       Score      Residuals\");\n    //            for (SurvivalInfo si : orderedSurvivalInfoList) {\n    //                System.out.println(si.getOrder() + \" \" + si.getLinearPredictor() + \" \" + si.getScore() + \" \" + si.getResidual());\n    //\n    //            }\n    //            System.out.println();\n    //            ArrayList<String> variables = new ArrayList<String>(coefficientsList.keySet());\n    //            System.out.print(\"Sample\");\n    //            for (String v : variables) {\n    //                System.out.print(\"    \" + v);\n    //            }\n    //            System.out.println(\"rr\");\n    //            for (SurvivalInfo si : orderedSurvivalInfoList) {\n    //                System.out.print(si.getOrder());\n    //                for (String v : variables) {\n    //                    System.out.print(\"   \" + si.getResidualVariable(v));\n    //                }\n    //                System.out.println();\n    //            }\n    //        }\n}", "repo_id": "9", "comment": "/**\n */\n", "repo_name": "biojava-master/", "id": 3620, "method_signature": "void dump()"}, "1037": {"callee_method_names": ["Atom.getGroup", "Group.getChain", "Chain.getName", "Chain.getName", "Chain.setName", "Chain.getName", "List<Chain>.add", "Group.clone", "Chain.addGroup"], "method_name": "StructureTools.cloneGroups", "method_implementation": "{\n    Group[] newGroup = new Group[ca.length];\n    List<Chain> model = new ArrayList<Chain>();\n    int apos = -1;\n    for (Atom a : ca) {\n        apos++;\n        Group parentG = a.getGroup();\n        Chain parentC = parentG.getChain();\n        Chain newChain = null;\n        for (Chain c : model) {\n            if (c.getName().equals(parentC.getName())) {\n                newChain = c;\n                break;\n            }\n        }\n        if (newChain == null) {\n            newChain = new ChainImpl();\n            newChain.setName(parentC.getName());\n            model.add(newChain);\n        }\n        Group ng = (Group) parentG.clone();\n        newGroup[apos] = ng;\n        newChain.addGroup(ng);\n    }\n    return newGroup;\n}", "repo_id": "9", "comment": "/**\n * Clone a set of representative Atoms, but returns the parent groups\n *\n * @param ca\n *            Atom array\n * @return Group array\n */\n", "repo_name": "biojava-master/", "id": 1037, "method_signature": "Group[] cloneGroups(Atom[])"}, "1668": {"callee_method_names": [], "method_name": "SubunitCluster.isPseudoStoichiometric", "method_implementation": "{\n    return pseudoStoichiometric;\n}", "repo_id": "9", "comment": "/**\n * @return true if this cluster is considered pseudo-stoichiometric (i.e.,\n * \t\t   was either clustered by structure, or by sequence with low scores),\n *         false otherwise.\n */\n", "repo_name": "biojava-master/", "id": 1668, "method_signature": "boolean isPseudoStoichiometric()"}, "516": {"callee_method_ids": [491, 720, 498, 486, 725, 502], "callee_method_names": ["AFPChain.setAlignScore", "PairwiseSequenceAligner<ProteinSequence,AminoAcidCompound>.getScore", "AFPChain.setCa1Length", "AFPChain.setCa2Length", "SequencePair<ProteinSequence,AminoAcidCompound>.getLength", "SequencePair<ProteinSequence,AminoAcidCompound>.getCompoundAt", "SequencePair<ProteinSequence,AminoAcidCompound>.getCompoundAt", "SequencePair<ProteinSequence,AminoAcidCompound>.getIndexInQueryAt", "SequencePair<ProteinSequence,AminoAcidCompound>.getIndexInTargetAt", "Compound.equals", "Compound.equals", "Atom[].getGroup", "Atom[].getGroup", "Compound.equals", "Atom[].getGroup", "Compound.equals", "Atom[].getGroup", "AFPChain.setAlnbeg1", "SequencePair<ProteinSequence,AminoAcidCompound>.getIndexInQueryAt", "AFPChain.setAlnbeg2", "SequencePair<ProteinSequence,AminoAcidCompound>.getIndexInTargetAt", "AFPChain.setGapLen", "AFPChain.setAlnseq1", "AFPChain.setAlnseq2", "AFPChain.setAlnsymb", "AFPChain.setIdentity", "AFPChain.setSimilarity", "AFPChain.setAlnLength", "AFPChain.setOptLength", "AFPChain.setOptLen", "CECalculator.calc_rmsd", "AFPChain.setBlockRmsd", "AFPChain.setOptRmsd", "AFPChain.setTotalRmsdOpt", "AFPChain.setChainRmsd", "CECalculator.setnAtom", "CECalculator.setAlign_se1", "CECalculator.setAlign_se2", "CECalculator.setLcmp", "CECalculator.convertAfpChain", "AFPChain.setAlgorithmName", "AFPChain.setVersion"], "method_name": "SmithWaterman3Daligner.convert", "method_implementation": "{\n    AFPChain afpChain = new AFPChain(algorithmName);\n    int ca1Length = ca1.length;\n    int ca2Length = ca2.length;\n    afpChain.setAlignScore(smithWaterman.getScore());\n    afpChain.setCa1Length(ca1Length);\n    afpChain.setCa2Length(ca2Length);\n    int nrCols = pair.getLength();\n    int nAtom = 0;\n    int nGaps = 0;\n    Atom[] strBuf1 = new Atom[nrCols];\n    Atom[] strBuf2 = new Atom[nrCols];\n    char[] alnseq1 = new char[ca1Length + ca2Length + 1];\n    char[] alnseq2 = new char[ca1Length + ca2Length + 1];\n    char[] alnsymb = new char[ca1Length + ca2Length + 1];\n    Compound gapSymbol = AminoAcidCompoundSet.getAminoAcidCompoundSet().getCompoundForString(\"-\");\n    // aligned positions\n    int pos = 0;\n    int nrIdent = 0;\n    int nrSim = 0;\n    int[] align_se1 = new int[nrCols + 1];\n    int[] align_se2 = new int[nrCols + 1];\n    for (int i = 1; i <= nrCols; i++) {\n        int myI = i - 1;\n        Compound s1 = pair.getCompoundAt(1, i);\n        Compound s2 = pair.getCompoundAt(2, i);\n        // alignment is using internal index start at 1...\n        int pos1 = pair.getIndexInQueryAt(i) - 1;\n        int pos2 = pair.getIndexInTargetAt(i) - 1;\n        if ((!s1.equals(gapSymbol)) && (!s2.equals(gapSymbol))) {\n            strBuf1[nAtom] = ca1[pos1];\n            strBuf2[nAtom] = ca2[pos2];\n            //\n            char l1 = getOneLetter(ca1[pos1].getGroup());\n            char l2 = getOneLetter(ca2[pos2].getGroup());\n            //\n            alnseq1[myI] = Character.toUpperCase(l1);\n            alnseq2[myI] = Character.toUpperCase(l2);\n            alnsymb[myI] = ' ';\n            //\n            if (l1 == l2) {\n                nrIdent++;\n                nrSim++;\n                alnsymb[myI] = '|';\n            } else if (AFPAlignmentDisplay.aaScore(l1, l2) > 0) {\n                nrSim++;\n                alnsymb[myI] = ':';\n            }\n            //\n            align_se1[myI] = pos1;\n            align_se2[myI] = pos2;\n            //\n            pos++;\n            nAtom++;\n        } else {\n            // there is a gap at this position\n            nGaps++;\n            alnsymb[myI] = ' ';\n            align_se1[myI] = -1;\n            align_se2[myI] = -1;\n            if (s1.equals(gapSymbol)) {\n                alnseq1[myI] = '-';\n            } else {\n                char l1 = getOneLetter(ca1[pos1].getGroup());\n                alnseq1[myI] = Character.toUpperCase(l1);\n                align_se1[myI] = pos1;\n            }\n            if (s2.equals(gapSymbol)) {\n                alnseq2[myI] = '-';\n            } else {\n                char l2 = getOneLetter(ca2[pos2].getGroup());\n                alnseq2[myI] = Character.toUpperCase(l2);\n                align_se2[myI] = pos2;\n            }\n        }\n    }\n    afpChain.setAlnbeg1(pair.getIndexInQueryAt(1) - 1);\n    afpChain.setAlnbeg2(pair.getIndexInTargetAt(1) - 1);\n    afpChain.setGapLen(nGaps);\n    afpChain.setAlnseq1(alnseq1);\n    afpChain.setAlnseq2(alnseq2);\n    afpChain.setAlnsymb(alnsymb);\n    // CE uses the aligned pairs as reference not the whole alignment including gaps...\n    afpChain.setIdentity(nrIdent * 1.0 / pos);\n    afpChain.setSimilarity(nrSim * 1.0 / pos);\n    afpChain.setAlnLength(nrCols);\n    afpChain.setOptLength(nAtom);\n    int[] optLen = new int[] { nAtom };\n    afpChain.setOptLen(optLen);\n    if (nAtom < 4)\n        return afpChain;\n    CeParameters params = new CeParameters();\n    CECalculator cecalc = new CECalculator(params);\n    // here we don't store the rotation matrix for the user!\n    double rmsd = cecalc.calc_rmsd(strBuf1, strBuf2, nAtom, true);\n    afpChain.setBlockRmsd(new double[] { rmsd });\n    afpChain.setOptRmsd(new double[] { rmsd });\n    afpChain.setTotalRmsdOpt(rmsd);\n    afpChain.setChainRmsd(rmsd);\n    // let's hijack the CE implementation\n    // and use some utilities from there to\n    // build up the afpChain object\n    cecalc.setnAtom(nAtom);\n    cecalc.setAlign_se1(align_se1);\n    cecalc.setAlign_se2(align_se2);\n    cecalc.setLcmp(nrCols);\n    cecalc.convertAfpChain(afpChain, ca1, ca2);\n    afpChain.setAlgorithmName(algorithmName);\n    afpChain.setVersion(version);\n    return afpChain;\n}", "repo_id": "9", "comment": "/**\n * Converts a sequence alignment into a structural alignment\n * @param smithWaterman The sequence aligner\n * @param ca1 CA atoms from the query sequence\n * @param ca2 CA atoms from the target sequence\n * @param smithWaterman pairwise Sequence aligner\n * @param pair The sequence alignment calculated by aligner\n * @return an AFPChain encapsulating the alignment in aligPair\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 516, "method_signature": "AFPChain convert(Atom[], Atom[], SequencePair, PairwiseSequenceAligner)"}, "3724": {"callee_method_names": ["LinkedHashMap.clear", "LinkedHashMap.put"], "method_name": "WorkSheet.setMetaDataRows", "method_implementation": "{\n    metaDataRowsHashMap.clear();\n    for (String row : metaDataRows) {\n        metaDataRowsHashMap.put(row, row);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param metaDataRows\n */\n", "repo_name": "biojava-master/", "id": 3724, "method_signature": "void setMetaDataRows(ArrayList)"}, "972": {"callee_method_names": ["Structure.getChains", "Chain.getId", "List<String>.add"], "method_name": "BiologicalAssemblyBuilder.getChainIds", "method_implementation": "{\n    List<String> chainIds = new ArrayList<String>();\n    for (Chain c : asymUnit.getChains()) {\n        String intChainID = c.getId();\n        chainIds.add(intChainID);\n    }\n    return chainIds;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of chain ids in the order they are specified in the ATOM\n * records in the asymmetric unit\n * @param asymUnit\n * @return\n */\n", "repo_name": "biojava-master/", "id": 972, "method_signature": "List<String> getChainIds(Structure)"}, "394": {"callee_method_names": ["Collection<Atom>.size", "ArrayList<Point3d>.add", "Atom.getCoordsAsPoint3d"], "method_name": "Calc.atomsToPoints", "method_implementation": "{\n    ArrayList<Point3d> points = new ArrayList<>(atoms.size());\n    for (Atom atom : atoms) {\n        points.add(atom.getCoordsAsPoint3d());\n    }\n    return points;\n}", "repo_id": "9", "comment": "/**\n * Convert an array of atoms into an array of vecmath points\n *\n * @param atoms\n *            list of atoms\n * @return list of Point3ds storing the x,y,z coordinates of each atom\n */\n", "repo_name": "biojava-master/", "id": 394, "method_signature": "List<Point3d> atomsToPoints(Collection)"}, "2868": {"callee_method_names": [], "method_name": "ABITrace.getMaximum", "method_implementation": "{\n    int max = 0;\n    for (int x = 0; x <= T.length - 1; x++) {\n        if (T[x] > max)\n            max = T[x];\n        if (A[x] > max)\n            max = A[x];\n        if (C[x] > max)\n            max = C[x];\n        if (G[x] > max)\n            max = G[x];\n    }\n    return max;\n}", "repo_id": "9", "comment": "/**\n * Get the maximum height of any of the traces. The data is persisted for performance\n * in the event of multiple calls, but it initialized lazily.\n *\n * @return - maximum height of any of the traces\n */\n", "repo_name": "biojava-master/", "id": 2868, "method_signature": "int getMaximum()"}, "2597": {"callee_method_names": [], "method_name": "UncompressInputStream.markSupported", "method_implementation": "{\n    return false;\n}", "repo_id": "9", "comment": "/**\n * This stream does not support mark/reset on the stream.\n *\n * @return false\n */\n", "repo_name": "biojava-master/", "id": 2597, "method_signature": "boolean markSupported()"}, "959": {"callee_method_names": [], "method_name": "BiologicalAssemblyTransformation.getTransformationMatrix", "method_implementation": "{\n    return transformation;\n}", "repo_id": "9", "comment": "/**\n * Return the transformation (both rotational and translational component) as a 4x4 transformation matrix.\n * The transformation is in orthonormal (cartesian coordinates). If required to be converted to\n * crystal coordinates then use {@link CrystalCell#transfToCrystal(Matrix4d)}\n * Note that this is a reference to the variable, thus it remains linked to this object's transformation field.\n * The user must deep copy it if need changing it.\n * @return 4x4 transformation matrix\n */\n", "repo_name": "biojava-master/", "id": 959, "method_signature": "Matrix4d getTransformationMatrix()"}, "1568": {"callee_method_names": ["StringBuffer.toString"], "method_name": "Site.remark800toPDB", "method_implementation": "{\n    StringBuffer stringBuffer = new StringBuffer();\n    remark800toPDB(stringBuffer);\n    return stringBuffer.toString();\n}", "repo_id": "9", "comment": "/**\n * Provides REMARK 800 section pertaining to the site as a string.\n *\n * For example in pdb 1a4w:\n * REMARK 800 SITE_IDENTIFIER: CAT\n * REMARK 800 EVIDENCE_CODE: UNKNOWN\n * REMARK 800 SITE_DESCRIPTION: ACTIVE SITE\n */\n", "repo_name": "biojava-master/", "id": 1568, "method_signature": "String remark800toPDB()"}, "1115": {"callee_method_names": ["Element.getAttribute", "SiftsResidue.setNaturalPos", "Element.getAttribute", "SiftsResidue.setSeqResName", "List<String>.contains", "SiftsResidue.setNotObserved", "Element.getElementsByTagName", "NodeList.getLength", "NodeList.getLength", "NodeList.item", "Element.getAttribute", "Element.getAttribute", "Element.getAttribute", "Element.getAttribute", "Element.getAttribute", "Element.getAttribute", "SiftsResidue.setPdbResNum", "SiftsResidue.setPdbResName", "SiftsResidue.setChainId", "SiftsResidue.setPdbId", "SiftsResidue.setUniProtPos", "SiftsResidue.setUniProtResName", "SiftsResidue.setUniProtAccessionId"], "method_name": "SiftsXMLParser.getResidue", "method_implementation": "{\n    SiftsResidue res = new SiftsResidue();\n    String dbResNumS = residue.getAttribute(\"dbResNum\");\n    res.setNaturalPos(Integer.parseInt(dbResNumS));\n    String seqResName = residue.getAttribute(\"dbResName\");\n    res.setSeqResName(seqResName);\n    boolean observed = true;\n    List<String> details = getTextValues(residue, \"residueDetail\");\n    if (details != null && details.contains(\"Not_Observed\")) {\n        observed = false;\n    }\n    res.setNotObserved(!observed);\n    //else if ( detail != null && detail.trim().equalsIgnoreCase(\"Conflict\")){\n    //\n    //}\n    NodeList nl = residue.getElementsByTagName(\"crossRefDb\");\n    if (nl != null && nl.getLength() > 0) {\n        for (int i = 0; i < nl.getLength(); i++) {\n            //get the entity element\n            Element crossRefEl = (Element) nl.item(i);\n            String dbSource = crossRefEl.getAttribute(\"dbSource\");\n            String dbCoordSys = crossRefEl.getAttribute(\"dbCoordSys\");\n            String dbAccessionId = crossRefEl.getAttribute(\"dbAccessionId\");\n            String dbResNum = crossRefEl.getAttribute(\"dbResNum\");\n            String dbResName = crossRefEl.getAttribute(\"dbResName\");\n            String dbChainId = crossRefEl.getAttribute(\"dbChainId\");\n            //\tSystem.out.println(dbSource + \" \" + dbCoordSys + \" \" + dbAccessionId + \" \" + dbResNum + \" \" + dbResName + \" \" + dbChainId);\n            if (\"PDB\".equals(dbSource) && \"PDBresnum\".equals(dbCoordSys)) {\n                res.setPdbResNum(dbResNum);\n                res.setPdbResName(dbResName);\n                res.setChainId(dbChainId);\n                res.setPdbId(dbAccessionId);\n            } else if (\"UniProt\".equals(dbSource)) {\n                res.setUniProtPos(Integer.parseInt(dbResNum));\n                res.setUniProtResName(dbResName);\n                res.setUniProtAccessionId(dbAccessionId);\n            }\n        }\n    }\n    return res;\n}", "repo_id": "9", "comment": "/**\n *   <residue dbResNum=\"1\" dbResName=\"THR\">\n * \t\t\t\t\t<crossRefDb dbSource=\"PDB\" dbVersion=\"20101103\"\n * \t\t\t\t\tdbCoordSys=\"PDBresnum\" dbAccessionId=\"1a4w\" dbResNum=\"1H\"\n * \t\t\t\t\tdbResName=\"THR\" dbChainId=\"L\"></crossRefDb>\n * \t\t\t\t\t<crossRefDb dbSource=\"UniProt\" dbVersion=\"157-2\"\n * \t\t\t\t\tdbCoordSys=\"UniProt\" dbAccessionId=\"P00734\"\n * \t\t\t\t\tdbResNum=\"328\" dbResName=\"T\"></crossRefDb>\n * \t\t\t\t\t<crossRefDb dbSource=\"SCOP\" dbVersion=\"1.75\"\n * \t\t\t\t\tdbCoordSys=\"PDBresnum\" dbAccessionId=\"26083\"\n * \t\t\t\t\tdbResNum=\"1H\" dbResName=\"THR\" dbChainId=\"L\"></crossRefDb>\n * \t\t\t\t\t<residueDetail dbSource=\"MSD\" property=\"Annotation\">\n * \t\t\t\t\tNot_Observed</residueDetail>\n * \t\t\t\t</residue>\n */\n", "repo_name": "biojava-master/", "id": 1115, "method_signature": "SiftsResidue getResidue(Element)"}, "1612": {"callee_method_names": ["Structure.setPdbId", "Structure.getPdbId", "Structure.setPDBHeader", "Structure.getPDBHeader", "Structure.setName", "Structure.setDBRefs", "Structure.getDBRefs", "Structure.setBiologicalAssembly", "Structure.isBiologicalAssembly", "Structure.getPDBHeader", "Structure.getPdbId", "Structure.getPDBHeader", "Structure.setEntityInfos", "Structure.setSSBonds", "Structure.getSSBonds", "Structure.setSites", "Structure.getSites", "Structure.setStructureIdentifier", "Structure.nrModels", "Structure.addModel", "Structure.setEntityInfos", "Structure.getEntityInfos", "Structure.setSSBonds", "Structure.getSSBonds", "Structure.setSites", "Structure.getSites", "Structure.setModel", "Structure.getModel", "ResidueRangeAndLength.getChainName", "ResidueRangeAndLength.getStart", "ResidueRangeAndLength.getEnd", "Structure.getPolyChains", "Chain.getName", "ResidueNumber.setChainName", "ResidueNumber.setChainName", "Structure.getPolyChains", "Logger.warn", "Structure.getPolyChainByPDB", "Structure.getChainByIndex", "Chain.getName", "ResidueNumber.setChainName", "ResidueNumber.setChainName", "Logger.warn", "Chain.getId", "Chain.getAtomGroups", "Structure.getNonPolyChainsByPDB", "Chain.getAtomGroups", "Structure.getWaterChainByPDB", "Chain.getAtomGroups", "Chain.getGroupsByPDB"], "method_name": "SubstructureIdentifier.reduce", "method_implementation": "{\n    // Follows StructureImpl.clone()\n    if (s == null)\n        throw new StructureException(\"NullPointerException Possibly due to malformed PIBId format.\");\n    // Create new structure & copy basic properties\n    Structure newS = new StructureImpl();\n    newS.setPdbId(s.getPdbId());\n    newS.setPDBHeader(s.getPDBHeader());\n    newS.setName(this.toString());\n    newS.setDBRefs(s.getDBRefs());\n    newS.setBiologicalAssembly(s.isBiologicalAssembly());\n    newS.getPDBHeader().setDescription(\"sub-range \" + ranges + \" of \" + newS.getPdbId() + \" \" + s.getPDBHeader().getDescription());\n    newS.setEntityInfos(new ArrayList<>());\n    // TODO The following should be only copied for atoms which are present in the range.\n    newS.setSSBonds(s.getSSBonds());\n    newS.setSites(s.getSites());\n    newS.setStructureIdentifier(this);\n    for (int modelNr = 0; modelNr < s.nrModels(); modelNr++) {\n        // Construct new model\n        newS.addModel(new ArrayList<Chain>());\n        if (getResidueRanges().isEmpty()) {\n            // Include all residues\n            newS.setEntityInfos(s.getEntityInfos());\n            newS.setSSBonds(s.getSSBonds());\n            newS.setSites(s.getSites());\n            newS.setModel(modelNr, s.getModel(modelNr));\n        } else {\n            // Restrict residues\n            for (ResidueRange range : getResidueRanges()) {\n                String chainName = range.getChainName();\n                ResidueNumber pdbresnum1 = range.getStart();\n                ResidueNumber pdbresnum2 = range.getEnd();\n                //\t\t\t\t\tStructureTools.addGroupsToStructure(newS, groups, modelNr, false);\n                //polymer\n                Chain polyChain;\n                if (\"_\".equals(chainName)) {\n                    // Handle special case of \"_\" chain for single-chain proteins\n                    polyChain = s.getPolyChains(modelNr).get(0);\n                    chainName = polyChain.getName();\n                    if (pdbresnum1 != null)\n                        pdbresnum1.setChainName(chainName);\n                    if (pdbresnum2 != null)\n                        pdbresnum2.setChainName(chainName);\n                    if (s.getPolyChains().size() != 1) {\n                        // SCOP 1.71 uses this for some proteins with multiple chains\n                        // Print a warning in this ambiguous case\n                        logger.warn(\"Multiple possible chains match '_'. Using chain {}\", chainName);\n                    }\n                } else {\n                    // Explicit chain\n                    polyChain = s.getPolyChainByPDB(chainName, modelNr);\n                    if (polyChain == null) {\n                        // Chain not found\n                        // Maybe it was a chain index, masquerading as a chainName?\n                        try {\n                            int chainNum = Integer.parseInt(chainName);\n                            polyChain = s.getChainByIndex(modelNr, chainNum);\n                            chainName = polyChain.getName();\n                            if (pdbresnum1 != null)\n                                pdbresnum1.setChainName(chainName);\n                            if (pdbresnum2 != null)\n                                pdbresnum2.setChainName(chainName);\n                            logger.warn(\"No chain found for {}. Interpretting it as an index, using chain {} instead\", chainName, polyChain.getId());\n                        } catch (NumberFormatException e3) {\n                            // Not an index. Throw the original exception\n                            throw new StructureException(String.format(\"Unrecognized chain %s in %s\", chainName, getIdentifier()));\n                        }\n                    }\n                }\n                if (pdbresnum1 == null && pdbresnum2 == null) {\n                    // Include all atoms with matching chainName\n                    StructureTools.addGroupsToStructure(newS, polyChain.getAtomGroups(), modelNr, false);\n                    for (Chain chain : s.getNonPolyChainsByPDB(chainName, modelNr)) {\n                        StructureTools.addGroupsToStructure(newS, chain.getAtomGroups(), modelNr, false);\n                    }\n                    Chain waters = s.getWaterChainByPDB(chainName, modelNr);\n                    if (waters != null) {\n                        StructureTools.addGroupsToStructure(newS, waters.getAtomGroups(), modelNr, false);\n                    }\n                    // TODO do we need to prune SeqRes down to the atoms present? -SB 2016-10-7\n                } else {\n                    // Include polymer range and any proximal ligands\n                    List<Group> polygroups = Arrays.asList(polyChain.getGroupsByPDB(pdbresnum1, pdbresnum2));\n                    StructureTools.addGroupsToStructure(newS, polygroups, modelNr, false);\n                    copyLigandsByProximity(s, newS, StructureTools.DEFAULT_LIGAND_PROXIMITY_CUTOFF, modelNr, modelNr);\n                }\n            }\n            // end range\n        }\n    }\n    // end modelNr\n    return newS;\n}", "repo_id": "9", "comment": "/**\n * Takes a complete structure as input and reduces it to residues present in\n * the specified ranges\n *\n * <p>The returned structure will be a shallow copy of the input, with shared\n * Chains, Residues, etc.\n *\n * <p>Ligands are handled in a special way. If a full chain is selected\n * (e.g. '1ABC.A') then any waters and ligands with matching chain name are\n * included. If a residue range is present ('1ABC.A:1-100') then any\n * ligands (technically non-water non-polymer atoms) within\n * {@link StructureTools#DEFAULT_LIGAND_PROXIMITY_CUTOFF} of the selected\n * range are included, regardless of chain.\n * @param s A full structure, e.g. as loaded from the PDB. The structure\n * ID should match that returned by getPdbId().\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 1612, "method_signature": "Structure reduce(Structure)"}, "2473": {"callee_method_ids": [2440, 2459, 2431], "callee_method_names": ["FeatureList.selectByAttribute", "Feature.getAttribute", "LinkedHashMap<String, FeatureList>.get", "LinkedHashMap<String, FeatureList>.put", "FeatureList.add"], "method_name": "FeatureHelper.buildFeatureAtrributeIndex", "method_implementation": "{\n    LinkedHashMap<String, FeatureList> featureHashMap = new LinkedHashMap<String, FeatureList>();\n    FeatureList featureList = list.selectByAttribute(attribute);\n    for (FeatureI feature : featureList) {\n        String value = feature.getAttribute(attribute);\n        FeatureList features = featureHashMap.get(value);\n        if (features == null) {\n            features = new FeatureList();\n            featureHashMap.put(value, features);\n        }\n        features.add(feature);\n    }\n    return featureHashMap;\n}", "repo_id": "9", "comment": "/**\n * Build a list of individual features to allow easy indexing and to avoid iterating through large genome gff3 files\n * The index for the returned HashMap is the value of the attribute used to build the index\n * @param attribute\n * @param list\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2473, "method_signature": "LinkedHashMap<String,FeatureList> buildFeatureAtrributeIndex(String, FeatureList)"}, "2257": {"callee_method_names": [], "method_name": "TestMmtfUtils.testGetSetSecStructType", "method_implementation": "{\n    Group group = new AminoAcidImpl();\n    MmtfUtils.setSecStructType(group, 0);\n    assertEquals(MmtfUtils.getSecStructType(group), 0);\n    MmtfUtils.setSecStructType(group, 1);\n    assertEquals(MmtfUtils.getSecStructType(group), 1);\n    MmtfUtils.setSecStructType(group, 2);\n    assertEquals(MmtfUtils.getSecStructType(group), 2);\n    MmtfUtils.setSecStructType(group, 3);\n    assertEquals(MmtfUtils.getSecStructType(group), 3);\n    MmtfUtils.setSecStructType(group, 4);\n    assertEquals(MmtfUtils.getSecStructType(group), 4);\n    MmtfUtils.setSecStructType(group, 5);\n    assertEquals(MmtfUtils.getSecStructType(group), 5);\n    MmtfUtils.setSecStructType(group, 6);\n    assertEquals(MmtfUtils.getSecStructType(group), 6);\n    MmtfUtils.setSecStructType(group, 7);\n    assertEquals(MmtfUtils.getSecStructType(group), 7);\n    // Now test two null possibilities\n    Group newGroup = new AminoAcidImpl();\n    MmtfUtils.setSecStructType(newGroup, -1);\n    assertEquals(MmtfUtils.getSecStructType(newGroup), -1);\n    // Now test two null possibilities\n    Group newerGroup = new AminoAcidImpl();\n    MmtfUtils.setSecStructType(newerGroup, 10);\n    assertEquals(MmtfUtils.getSecStructType(newerGroup), -1);\n}", "repo_id": "9", "comment": "/**\n * Test that getting the secondary structure type works.\n */\n", "repo_name": "biojava-master/", "id": 2257, "method_signature": "void testGetSetSecStructType()"}, "517": {"callee_method_names": ["StructureAlignment.getAlgorithmName", "ArrayList.add"], "method_name": "StructureAlignmentFactory.addAlgorithm", "method_implementation": "{\n    //ensure uniqueness\n    try {\n        getAlgorithm(alg.getAlgorithmName());\n        // algorithm was found. Do nothing.\n    } catch (StructureException e) {\n        // no algorithm found, so it's new\n        algorithms.add(alg);\n    }\n}", "repo_id": "9", "comment": "/**\n * Adds a new StructureAlignment algorithm to the list.\n *\n * Only one instance is stored for each algorithmName, so it is possible\n * that a different instance may be returned by getAlgorithm(alg.getAlgorithmName())\n *\n * @param alg the alignment algorithm\n */\n", "repo_name": "biojava-master/", "id": 517, "method_signature": "void addAlgorithm(StructureAlignment)"}, "1888": {"callee_method_names": ["String.length", "String.substring", "ArrayList.size", "String.length", "String.length", "String.length", "String.substring", "String.substring", "String.substring", "String.length", "String.substring", "String.length", "String.substring"], "method_name": "Stoichiometry.generateAlpha", "method_implementation": "{\n    String key;\n    int alphabetInd;\n    switch(strategy) {\n        case CYCLE:\n            alphabetInd = clusterInd % alphabet.length();\n            key = alphabet.substring(alphabetInd, alphabetInd + 1);\n            break;\n        case DOUBLE:\n            if (orderedClusters.size() > alphabet.length()) {\n                int alphabetInd1 = clusterInd / alphabet.length();\n                int alphabetInd2 = clusterInd % alphabet.length();\n                key = alphabet.substring(alphabetInd1, alphabetInd1 + 1);\n                key += alphabet.substring(alphabetInd2, alphabetInd2 + 1);\n            } else {\n                key = alphabet.substring(clusterInd, clusterInd + 1);\n            }\n            break;\n        case QUESTIONMARK:\n            key = \"?\";\n            if (clusterInd < alphabet.length()) {\n                key = alphabet.substring(clusterInd, clusterInd + 1);\n            }\n            break;\n        case CUSTOM:\n            throw new IllegalStateException(\"Alphas should be handled by the custom generator function.\");\n        default:\n            key = \"?\";\n            if (clusterInd < alphabet.length()) {\n                key = alphabet.substring(clusterInd, clusterInd + 1);\n            }\n            break;\n    }\n    return key;\n}", "repo_id": "9", "comment": "/**\n * Produce a string (\"alpha\") that describes each component depending on the current strategy.\n * @param clusterInd\n *          component index\n * @return alphanumeric string.\n */\n", "repo_name": "biojava-master/", "id": 1888, "method_signature": "String generateAlpha(int)"}, "1277": {"callee_method_names": [], "method_name": "MmtfSummaryDataBean.getAllChains", "method_implementation": "{\n    return allChains;\n}", "repo_id": "9", "comment": "/**\n * @return the list of chains (in all models) in the structure\n */\n", "repo_name": "biojava-master/", "id": 1277, "method_signature": "List<Chain> getAllChains()"}, "2017": {"callee_method_names": [], "method_name": "Prism.setHeight", "method_implementation": "{\n    this.height = height;\n}", "repo_id": "9", "comment": "/**\n * @param height the height to set\n */\n", "repo_name": "biojava-master/", "id": 2017, "method_signature": "void setHeight(double)"}, "409": {"callee_method_names": [], "method_name": "FCAlignHelper.ins", "method_implementation": "{\n    //if(last > 0)    last = sapp[-1] += k;\n    //else            last = *sapp++ = (k);\n    if (last > 0)\n        last = sapp[sappPos - 1] += k;\n    else\n        last = sapp[(sappPos++)] = (k);\n}", "repo_id": "9", "comment": "//-----------------------------------------------------------------------------\n", "repo_name": "biojava-master/", "id": 409, "method_signature": "void ins(int)"}, "1970": {"callee_method_names": ["QuatSymmetrySubunits.getCentroid"], "method_name": "HelixAxisAligner.getCentroid", "method_implementation": "{\n    return new Point3d(subunits.getCentroid());\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getCentroid()\n\t */\n", "repo_name": "biojava-master/", "id": 1970, "method_signature": "Point3d getCentroid()"}, "3655": {"callee_method_names": [], "method_name": "SurvivalInfo.getOffset", "method_implementation": "{\n    return offset;\n}", "repo_id": "9", "comment": "/**\n * @return the offset\n */\n", "repo_name": "biojava-master/", "id": 3655, "method_signature": "double getOffset()"}, "3660": {"callee_method_names": [], "method_name": "SurvivalInfo.setStrata", "method_implementation": "{\n    this.strata = strata;\n}", "repo_id": "9", "comment": "/**\n * @param strata the strata to set\n */\n", "repo_name": "biojava-master/", "id": 3660, "method_signature": "void setStrata(int)"}, "234": {"callee_method_names": [], "method_name": "Builder.setResidId", "method_implementation": "{\n    this.residId = residId;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the RESID ID.\n * @param residId RESID ID.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 234, "method_signature": "Builder setResidId(String)"}, "2938": {"callee_method_names": [], "method_name": "AbstractSequence.getTaxonomy", "method_implementation": "{\n    return taxonomy;\n}", "repo_id": "9", "comment": "/**\n * @return the species\n */\n", "repo_name": "biojava-master/", "id": 2938, "method_signature": "TaxonomyID getTaxonomy()"}, "1345": {"callee_method_names": [], "method_name": "EntityInfo.setRefChainId", "method_implementation": "{\n    this.refChainId = refChainId;\n}", "repo_id": "9", "comment": "/**\n * Return the ref chain id value.\n * @param refChainId the RefChainID\n * @see #getRefChainId()\n */\n", "repo_name": "biojava-master/", "id": 1345, "method_signature": "void setRefChainId(String)"}, "3085": {"callee_method_names": [], "method_name": "AbstractFeature.getParentFeature", "method_implementation": "{\n    return parentFeature;\n}", "repo_id": "9", "comment": "/**\n * Get the parent Feature\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3085, "method_signature": "FeatureInterface<S,C> getParentFeature()"}, "446": {"callee_method_names": [], "method_name": "QsAlignResult.getSubunits2", "method_implementation": "{\n    return Collections.unmodifiableList(subunits2);\n}", "repo_id": "9", "comment": "/**\n * Original Subunits of the second group.\n *\n * @return an unmodifiable view of the original List\n */\n", "repo_name": "biojava-master/", "id": 446, "method_signature": "List<Subunit> getSubunits2()"}, "1945": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setMinTm", "method_implementation": "{\n    this.minTm = minTm;\n}", "repo_id": "9", "comment": "/**\n * @param minTm the minTm to set\n */\n", "repo_name": "biojava-master/", "id": 1945, "method_signature": "void setMinTm(double)"}, "3771": {"callee_method_names": ["OutputStream.write", "String.getBytes", "OutputStream.write", "OutputStream.write", "OutputStream.write", "String.getBytes", "OutputStream.write", "OutputStream.write", "OutputStream.write", "OutputStream.write", "CompactCharSequence[].getBytes", "OutputStream.write", "OutputStream.write", "String.length", "String.length", "OutputStream.write", "String.getBytes", "OutputStream.write"], "method_name": "WorkSheet.save", "method_implementation": "{\n    outputStream.write(rowHeader.getBytes());\n    //String quote = \"\\\"\";\n    for (String col : getColumns()) {\n        outputStream.write(delimitter);\n        if (quoteit) {\n            outputStream.write('\"');\n        }\n        outputStream.write(col.getBytes());\n        if (quoteit) {\n            outputStream.write('\"');\n        }\n    }\n    outputStream.write(\"\\r\\n\".getBytes());\n    for (String row : getRows()) {\n        if (quoteit) {\n            outputStream.write('\"');\n        }\n        outputStream.write(row.getBytes());\n        if (quoteit) {\n            outputStream.write('\"');\n        }\n        for (String col : getColumns()) {\n            // try{\n            String value = getCell(row, col);\n            outputStream.write(delimitter);\n            if (!this.isMetaDataColumn(col) && !this.isMetaDataRow(row)) {\n                if (value == null || value.length() == 0 || \"null\".equalsIgnoreCase(value)) {\n                    value = \"NaN\";\n                }\n            } else {\n                if (value == null || value.length() == 0 || \"null\".equalsIgnoreCase(value)) {\n                    value = \"\";\n                }\n            }\n            outputStream.write(value.getBytes());\n            //  }catch(Exception e){\n            //      System.out.println(row + \" \" + col);\n            //  }\n        }\n        outputStream.write(\"\\r\\n\".getBytes());\n    }\n}", "repo_id": "9", "comment": "/**\n * @param outputStream\n * @param delimitter\n * @param quoteit\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3771, "method_signature": "void save(OutputStream, char, boolean)"}, "2339": {"callee_method_names": [], "method_name": "AbstractFastqReader.getResult", "method_implementation": "{\n    return Iterables.unmodifiableIterable(result);\n}", "repo_id": "9", "comment": "/**\n * Return an unmodifiable iterable over the FASTQ formatted sequences collected by this stream listener.\n *\n * @return an unmodifiable iterable over the FASTQ formatted sequences collected by this stream listener\n */\n", "repo_name": "biojava-master/", "id": 2339, "method_signature": "Iterable<Fastq> getResult()"}, "732": {"callee_method_ids": [746, 496, 752, 485, 491], "callee_method_names": ["CeParameters.getWinSize", "Atom[].getX", "Atom[].getX", "AFPChain.setTotalRmsdIni", "AFPChain.setTotalLenIni", "CeParameters.isShowAFPRanges", "AFP.setFragLen", "AFP.setP1", "AFP.setP2", "List<AFP>.add", "AFPChain.setAfpSet", "AFPChain.setCalculationTime", "AFPChain.setGapLen", "AFPChain.setOptLen", "AFPChain.setOptLength", "AFPChain.setAlnLength", "AFPChain.setProbability"], "method_name": "CeCalculatorEnhanced.checkBestTraces", "method_implementation": "{\n    z = 0.0;\n    int nGaps;\n    int winSize = params.getWinSize();\n    int nse1 = ca1.length;\n    int nse2 = ca2.length;\n    int traceMaxSize = nse1 < nse2 ? nse1 : nse2;\n    int idir;\n    align_se1 = new int[nse1 + nse2];\n    align_se2 = new int[nse1 + nse2];\n    alignmentPositionOrLength = 0;\n    // we now support alignment using any particular atoms..\n    Atom[] strBuf1 = new Atom[traceMaxSize];\n    Atom[] strBuf2 = new Atom[traceMaxSize];\n    double rmsdNew;\n    // removing some loops that are run in orig CE\n    // and which did not do anything\n    if (debug) {\n        checkPrintRmsdNew(traceMaxSize, winSize, ca1, ca2);\n    }\n    double rmsd = 100.0;\n    int iBestTrace = 0;\n    for (int ir = 0; ir < nBestTraces; ir++) {\n        if (bestTracesN[ir] != nBestTrace)\n            continue;\n        rmsdNew = getRMSDForBestTrace(ir, strBuf1, strBuf2, bestTracesN, bestTraces1, bestTrace2, winSize, ca1, ca2);\n        if (isPrint)\n            System.out.println(String.format(\"%d %d %d %.2f\", ir, bestTracesN[ir], nBestTrace, rmsdNew));\n        if (rmsd > rmsdNew) {\n            iBestTrace = ir;\n            rmsd = rmsdNew;\n            //System.out.println(\" iBestTrace:\" + iBestTrace + \" new rmsd = \" + rmsd);\n        }\n    }\n    for (int it = 0; it < bestTracesN[iBestTrace]; it++) {\n        bestTrace1[it] = bestTraces1[iBestTrace][it];\n        bestTrace2[it] = bestTraces2[iBestTrace][it];\n    }\n    //System.out.println(\"iBestTrace: \"+iBestTrace+\" = bestTracesScores \" + bestTracesScores[iBestTrace]);\n    nBestTrace = bestTracesN[iBestTrace];\n    bestTraceScore = bestTracesScores[iBestTrace];\n    //printf(\"\\nOptimizing gaps...\\n\");\n    int[] traceLen = new int[traceMaxSize];\n    bestTraceLen = new int[traceMaxSize];\n    int strLen = 0;\n    int jt;\n    strLen = 0;\n    nGaps = 0;\n    nTrace = nBestTrace;\n    for (jt = 0; jt < nBestTrace; jt++) {\n        trace1[jt] = bestTrace1[jt];\n        trace2[jt] = bestTrace2[jt];\n        traceLen[jt] = winSize;\n        if (jt < nBestTrace - 1) {\n            nGaps += bestTrace1[jt + 1] - bestTrace1[jt] - winSize + bestTrace2[jt + 1] - bestTrace2[jt] - winSize;\n        }\n    }\n    nBestTrace = 0;\n    for (int it = 0; it < nTrace; ) {\n        int cSize = traceLen[it];\n        for (jt = it + 1; jt < nTrace; jt++) {\n            if (trace1[jt] - trace1[jt - 1] - traceLen[jt - 1] != 0 || trace2[jt] - trace2[jt - 1] - traceLen[jt - 1] != 0)\n                break;\n            cSize += traceLen[jt];\n        }\n        bestTrace1[nBestTrace] = trace1[it];\n        bestTrace2[nBestTrace] = trace2[it];\n        bestTraceLen[nBestTrace] = cSize;\n        nBestTrace++;\n        strLen += cSize;\n        it = jt;\n    }\n    int is = 0;\n    for (jt = 0; jt < nBestTrace; jt++) {\n        for (int i = 0; i < bestTraceLen[jt]; i++) {\n            setStrBuf(strBuf1, is + i, ca1, bestTrace1[jt] + i);\n            setStrBuf(strBuf2, is + i, ca2, bestTrace2[jt] + i);\n        }\n        is += bestTraceLen[jt];\n    }\n    //sup_str(strBuf1, strBuf2, strLen, d_);\n    rmsd = calc_rmsd(strBuf1, strBuf2, strLen, true, showAlignmentSteps);\n    if (isPrint)\n        System.out.println(\"got first rmsd: \" + rmsd);\n    boolean isCopied = false;\n    outer_loop: for (int it = 1; it < nBestTrace; it++) {\n        /* not needed...\n\t\t\tint igap;\n\t\t\tif(bestTrace1[it]-bestTrace1[it-1]-bestTraceLen[it-1]>0) igap=0;\n\t\t\tif(bestTrace2[it]-bestTrace2[it-1]-bestTraceLen[it-1]>0) igap=1;\n\t\t\t\t */\n        boolean wasBest = false;\n        main_loop: for (idir = -1; idir <= 1; idir += 2) {\n            if (wasBest)\n                break;\n            inner_loop: for (int idep = 1; idep <= winSize / 2; idep++) {\n                if (!isCopied)\n                    for (jt = 0; jt < nBestTrace; jt++) {\n                        trace1[jt] = bestTrace1[jt];\n                        trace2[jt] = bestTrace2[jt];\n                        traceLen[jt] = bestTraceLen[jt];\n                    }\n                isCopied = false;\n                traceLen[it - 1] += idir;\n                traceLen[it] -= idir;\n                trace1[it] += idir;\n                trace2[it] += idir;\n                is = 0;\n                for (jt = 0; jt < nBestTrace; jt++) {\n                    for (int i = 0; i < traceLen[jt]; i++) {\n                        if (ca1[trace1[jt] + i].getX() > 1e10 || ca2[trace2[jt] + i].getX() > 1e10)\n                            continue main_loop;\n                        strBuf1[is + i] = ca1[trace1[jt] + i];\n                        strBuf2[is + i] = ca2[trace2[jt] + i];\n                    }\n                    is += traceLen[jt];\n                }\n                //sup_str(strBuf1, strBuf2, strLen, d_);\n                rmsdNew = calc_rmsd(strBuf1, strBuf2, strLen, true, false);\n                //System.out.println(String.format(\"step %d %d %d %.2f old: %.2f\", it, idir, idep, rmsdNew, rmsd));\n                if (rmsdNew < rmsd) {\n                    for (jt = 0; jt < nBestTrace; jt++) {\n                        bestTrace1[jt] = trace1[jt];\n                        bestTrace2[jt] = trace2[jt];\n                        bestTraceLen[jt] = traceLen[jt];\n                    }\n                    isCopied = true;\n                    wasBest = true;\n                    rmsd = rmsdNew;\n                    continue inner_loop;\n                }\n                // AP\n                //bad_ca: break;\n                continue main_loop;\n            }\n        }\n    }\n    //if ( showAlignmentSteps)\n    rmsdNew = calc_rmsd(strBuf1, strBuf2, strLen, true, showAlignmentSteps);\n    if (isPrint)\n        System.out.println(\"rmsdNew: \" + rmsdNew + \" rmsd \" + rmsd);\n    afpChain.setTotalRmsdIni(rmsdNew);\n    afpChain.setTotalLenIni(strBuf1.length);\n    nAtom = strLen;\n    System.out.println(\"zStrAlign: \" + winSize + \" strLen \" + strLen + \" s/w \" + (strLen / winSize) + \" \" + bestTraceScore + \" \" + nGaps);\n    z = zStrAlign(winSize, strLen / winSize, bestTraceScore, nGaps);\n    if (params.isShowAFPRanges()) {\n        System.out.println(\"win size: \" + winSize + \" strLen/winSize: \" + strLen / winSize + \" best trace score: \" + String.format(\"%.2f\", bestTraceScore) + \" nr gaps: \" + nGaps + \" nr residues: \" + nAtom);\n        System.out.println(String.format(\"size=%d rmsd=%.2f z=%.1f gaps=%d(%.1f%%) comb=%d\", nAtom, rmsd, z, nGaps, nGaps * 100.0 / nAtom, nTraces));\n        System.out.println(\"Best Trace, before optimization\");\n        for (int k = 0; k < nBestTrace; k++) System.out.println(String.format(\"(%d,%d,%d) \", bestTrace1[k] + 1, bestTrace2[k] + 1, bestTraceLen[k]));\n    }\n    // start to convert CE internal datastructure to generic AFPChain one...\n    List<AFP> afpSet = new ArrayList<AFP>();\n    for (int afp = 0; afp < nBestTrace; afp++) {\n        // fill in data from nBestTrace into AFP\n        AFP afpI = new AFP();\n        afpI.setFragLen(bestTraceLen[afp]);\n        afpI.setP1(bestTrace1[afp] + 1);\n        afpI.setP2(bestTrace2[afp] + 1);\n        afpSet.add(afpI);\n    }\n    afpChain.setAfpSet(afpSet);\n    //System.out.println(\"z:\"+z + \" zThr\" + zThr+ \" bestTraceScore \" + bestTraceScore + \" \" + nGaps );\n    if (z >= zThr) {\n        nGaps = optimizeSuperposition(afpChain, nse1, nse2, strLen, rmsd, ca1, ca2, nGaps, strBuf1, strBuf2);\n        //\t      if(isPrint) {\n        //\t\t/*\n        //\t\tFILE *f=fopen(\"homologies\", \"a\");\n        //\t\tfprintf(f, \"%s(%d) %s(%d) %3d %4.1f %4.1f %d(%d) \",\n        //\t\t\tname1, nse1, name2, nse2, nAtom, rmsd, z,\n        //\t\t\tnGaps, nGaps*100/nAtom);\n        //\t\tfor(int k=0; k<nBestTrace; k++)\n        //\t\t  fprintf(f, \"(%d,%d,%d) \", bestTrace1[k]+1, bestTrace2[k]+1,\n        //\t\t\t  bestTraceLen[k]);\n        //\t\tfprintf(f, \"\\n\");\n        //\t\tfclose(f);\n        //\t\t*/\n        //\t      }\n    } else {\n        int lali_x_ = 0;\n        for (int k = 0; k < nBestTrace; k++) {\n            for (int l = 0; l < bestTraceLen[k]; l++) {\n                align_se1[alignmentPositionOrLength + l] = bestTrace1[k] + l;\n                align_se2[alignmentPositionOrLength + l] = bestTrace2[k] + l;\n            }\n            lali_x_ += bestTraceLen[k];\n            if (k < nBestTrace - 1) {\n                if (bestTrace1[k] + bestTraceLen[k] != bestTrace1[k + 1])\n                    for (int l = bestTrace1[k] + bestTraceLen[k]; l < bestTrace1[k + 1]; l++) {\n                        align_se1[alignmentPositionOrLength] = l;\n                        align_se2[alignmentPositionOrLength] = -1;\n                        alignmentPositionOrLength++;\n                    }\n                if (bestTrace2[k] + bestTraceLen[k] != bestTrace2[k + 1])\n                    for (int l = bestTrace2[k] + bestTraceLen[k]; l < bestTrace2[k + 1]; l++) {\n                        align_se1[alignmentPositionOrLength] = -1;\n                        align_se2[alignmentPositionOrLength] = l;\n                        alignmentPositionOrLength++;\n                    }\n            }\n        }\n        nAtom = lali_x_;\n    }\n    timeEnd = System.currentTimeMillis();\n    long time_q = (timeEnd - timeStart);\n    double gapsP = (nGaps * 100.0 / nAtom);\n    if (isPrint) {\n        String msg = String.format(\"Alignment length = %d Rmsd = %.2fA Z-Score = %.1f Gaps = %d(%.1f%%)\", nAtom, rmsd, z, nGaps, gapsP);\n        System.out.println(msg + \" CPU = \" + time_q);\n    }\n    //      if ( params.isShowAFPRanges()){\n    // this is actually the final alignment...\n    System.out.println(\"Best Trace: (index1,index2,len)\");\n    for (int k = 0; k < nBestTrace; k++) System.out.println(String.format(\"(%d,%d,%d) \", bestTrace1[k] + 1, bestTrace2[k] + 1, bestTraceLen[k]));\n    //      }\n    afpChain.setCalculationTime(time_q);\n    afpChain.setGapLen(nGaps);\n    int[] optLen = new int[] { nAtom };\n    afpChain.setOptLen(optLen);\n    afpChain.setOptLength(nAtom);\n    afpChain.setAlnLength(alignmentPositionOrLength);\n    afpChain.setProbability(z);\n}", "repo_id": "9", "comment": "// this part is modified from the original CeCalculator\n", "repo_name": "biojava-master/", "id": 732, "method_signature": "void checkBestTraces(AFPChain, Atom[], Atom[])"}, "663": {"callee_method_names": ["Integer.compareTo"], "method_name": "MultipleAlignmentTools.sortBlocks", "method_implementation": "{\n    Collections.sort(blocks, new Comparator<Block>() {\n\n        @Override\n        public int compare(Block o1, Block o2) {\n            // Compare the first non-null residue of each block\n            List<Integer> alignres1 = o1.getAlignRes().get(sortedIndex);\n            List<Integer> alignres2 = o2.getAlignRes().get(sortedIndex);\n            Integer res1 = null;\n            Integer res2 = null;\n            for (Integer r : alignres1) {\n                if (r != null) {\n                    res1 = r;\n                    break;\n                }\n            }\n            for (Integer r : alignres2) {\n                if (r != null) {\n                    res2 = r;\n                    break;\n                }\n            }\n            return res1.compareTo(res2);\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Sort blocks so that the specified row is in sequential order. The sort\n * happens in place.\n *\n * @param blocks\n *            List of blocks\n * @param sortedIndex\n *            Index of the row to be sorted\n */\n", "repo_name": "biojava-master/", "id": 663, "method_signature": "void sortBlocks(List, int)"}, "1843": {"callee_method_names": ["List<Chain>.size", "List<Chain>.size", "List<Chain>.size"], "method_name": "Model.size", "method_implementation": "{\n    return polyChains.size() + nonPolyChains.size() + waterChains.size();\n}", "repo_id": "9", "comment": "/**\n * Returns the total number of chains in this model: polymeric, non-polymeric and water\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1843, "method_signature": "int size()"}, "2052": {"callee_method_names": ["Set<T>.isEmpty", "Set<Set<T>>.add", "List<T>.get", "List<T>.subList", "List<T>.size", "Set<T>.add", "Set<T>.addAll", "Set<Set<T>>.add", "Set<Set<T>>.add"], "method_name": "PowerSet.powerSet", "method_implementation": "{\n    Set<Set<T>> sets = new LinkedHashSet<Set<T>>();\n    if (originalSet.isEmpty()) {\n        sets.add(new LinkedHashSet<T>());\n        return sets;\n    }\n    List<T> list = new ArrayList<T>(originalSet);\n    T head = list.get(0);\n    Set<T> rest = new LinkedHashSet<T>(list.subList(1, list.size()));\n    for (Set<T> set : powerSet(rest)) {\n        Set<T> newSet = new LinkedHashSet<T>();\n        newSet.add(head);\n        newSet.addAll(set);\n        sets.add(newSet);\n        sets.add(set);\n    }\n    return sets;\n}", "repo_id": "9", "comment": "/**\n * @return the set of power Sets of the original Set\n */\n", "repo_name": "biojava-master/", "id": 2052, "method_signature": "Set<Set<T>> powerSet(Set)"}, "2275": {"callee_method_ids": [641, 1318, 641], "callee_method_names": ["AtomCache.setFiletype", "FileParsingParameters.setHeaderOnly", "AtomCache.setFileParsingParams", "AtomCache.setFiletype"], "method_name": "TestHeaderOnly.testHeaderOnly", "method_implementation": "{\n    // Get either PDB or mmCIF with a headerOnly = true.\n    // Test 1: with PDB\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.PDB);\n    FileParsingParameters params = new FileParsingParameters();\n    params.setHeaderOnly(true);\n    // params.setAlignSeqRes(true);  // Now this is default.\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    Structure sPDB = StructureIO.getStructure(pdbID);\n    Assert.assertEquals(false, doSeqResHaveAtoms(sPDB));\n    // Test 2: with mmCIF\n    cache.setFiletype(StructureFiletype.CIF);\n    Structure sCIF = StructureIO.getStructure(pdbID);\n    Assert.assertEquals(false, doSeqResHaveAtoms(sCIF));\n}", "repo_id": "9", "comment": "/**\n * All groups are expected to be empty.\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2275, "method_signature": "void testHeaderOnly()"}, "735": {"callee_method_names": [], "method_name": "CeCalculatorEnhanced.checkPrintRmsdNew", "method_implementation": "{\n    int is = 0;\n    // calc initial RMSD for bestTrace1\n    Atom[] strBuf1 = new Atom[traceMaxSize];\n    Atom[] strBuf2 = new Atom[traceMaxSize];\n    for (int jt = 0; jt < nBestTrace; jt++) {\n        for (int i = 0; i < winSize; i++) {\n            setStrBuf(strBuf1, is + i, ca1, bestTrace1[jt] + i);\n            setStrBuf(strBuf2, is + i, ca2, bestTrace2[jt] + i);\n        }\n        is += winSize;\n    }\n    //sup_str(strBuf1, strBuf2, nBestTrace*winSize, d_);\n    double rmsdNew = calc_rmsd(strBuf1, strBuf2, nBestTrace * winSize, true, false);\n    //afpChain.setTotalRmsdIni(rmsdNew);\n    if (isPrint) {\n        System.out.println(\"rmsdNew after trace: \" + rmsdNew);\n        for (int k = 0; k < nBestTrace; k++) System.out.println(String.format(\"(%d,%d,%d) \", bestTrace1[k] + 1, bestTrace2[k] + 1, 8));\n    }\n    if (isPrint) {\n        System.out.println(\"best traces: \" + nBestTraces);\n    }\n}", "repo_id": "9", "comment": "/**\n * calc initial RMSD for bestTrace1 in debug only\n */\n", "repo_name": "biojava-master/", "id": 735, "method_signature": "void checkPrintRmsdNew(int, int, Atom[], Atom[])"}, "3674": {"callee_method_names": [], "method_name": "SurvivalInfo.setTime", "method_implementation": "{\n    this.time = time;\n}", "repo_id": "9", "comment": "/**\n * @param time the time to set\n */\n", "repo_name": "biojava-master/", "id": 3674, "method_signature": "void setTime(double)"}, "2383": {"callee_method_names": ["Logger.debug", "RandomAccessFile.getFilePointer"], "method_name": "TwoBitParser.read", "method_implementation": "{\n    if (cur_seq_name == null)\n        throw new IOException(\"Sequence is not set\");\n    if (cur_seq_pos == cur_dna_size) {\n        logger.debug(\"End of sequence (file position:{})\", raf.getFilePointer());\n        return -1;\n    }\n    int bit_num = (int) cur_seq_pos % 4;\n    if (bit_num == 0) {\n        loadBits();\n    } else if (bit_num == 3) {\n        file_pos++;\n    }\n    char ret = 'N';\n    if ((cur_nn_block_num >= 0) && (cur_nn_blocks[cur_nn_block_num][0] <= cur_seq_pos)) {\n        if (cur_bits[bit_num] != 0) {\n            throw new IOException(\"Wrong data in NN-block (\" + cur_bits[bit_num] + \") \" + \"at position \" + cur_seq_pos);\n        }\n        if (cur_nn_blocks[cur_nn_block_num][0] + cur_nn_blocks[cur_nn_block_num][1] == cur_seq_pos + 1) {\n            cur_nn_block_num++;\n            if (cur_nn_block_num >= cur_nn_blocks.length) {\n                cur_nn_block_num = -1;\n            }\n        }\n        ret = 'N';\n    } else {\n        ret = bit_chars[cur_bits[bit_num]];\n    }\n    if ((cur_mask_block_num >= 0) && (cur_mask_blocks[cur_mask_block_num][0] <= cur_seq_pos)) {\n        ret = Character.toLowerCase(ret);\n        if (cur_mask_blocks[cur_mask_block_num][0] + cur_mask_blocks[cur_mask_block_num][1] == cur_seq_pos + 1) {\n            cur_mask_block_num++;\n            if (cur_mask_block_num >= cur_mask_blocks.length) {\n                cur_mask_block_num = -1;\n            }\n        }\n    }\n    cur_seq_pos++;\n    return ret;\n}", "repo_id": "9", "comment": "/**\n * Method reads 1 nucleotide from sequence stream. You should set current sequence\n * before use it.\n */\n", "repo_name": "biojava-master/", "id": 2383, "method_signature": "int read()"}, "2997": {"callee_method_names": [], "method_name": "BitSequenceReader.processUnknownCompound", "method_implementation": "{\n    throw new IllegalStateException(\"Do not know how to translate the compound \" + compound + \" to a \" + bitsPerCompound() + \"bit representation\");\n}", "repo_id": "9", "comment": "/**\n * Since bit encoding only supports a finite number of bases\n * it is more than likely when processing sequence you will encounter a\n * compound which is not covered by the encoding e.g. N in a 2bit sequence.\n * You can override this to convert the unknown base into one you can\n * process or store locations of unknown bases for a level of post processing\n * in your subclass.\n *\n * @param compound Compound process\n * @return Byte representation of the compound\n * @throws IllegalStateException Done whenever this method is invoked\n */\n", "repo_name": "biojava-master/", "id": 2997, "method_signature": "byte processUnknownCompound(C, int)"}, "1070": {"callee_method_ids": [626, 637, 636], "callee_method_names": ["Map<String, String>.containsKey", "Map<String, String>.get", "Logger.error", "URL.getPath", "AtomCache.getFileParsingParams", "URL.openStream", "AtomCache.getPath", "PDBFileReader.setFetchBehavior", "AtomCache.getFetchBehavior", "PDBFileReader.setObsoleteBehavior", "AtomCache.getObsoleteBehavior", "PDBFileReader.setFileParsingParameters", "AtomCache.getFileParsingParams", "PDBFileReader.getStructure"], "method_name": "URLIdentifier.loadStructure", "method_implementation": "{\n    StructureFiletype format = StructureFiletype.UNKNOWN;\n    // Use user-specified format\n    try {\n        Map<String, String> params = parseQuery(url);\n        if (params.containsKey(FORMAT_PARAM)) {\n            String formatStr = params.get(FORMAT_PARAM);\n            format = StructureIO.guessFiletype(\".\" + formatStr);\n        }\n    } catch (UnsupportedEncodingException e) {\n        logger.error(\"Unable to decode URL {}\", url, e);\n    }\n    // Guess format from extension\n    if (format == StructureFiletype.UNKNOWN) {\n        format = StructureIO.guessFiletype(url.getPath());\n    }\n    switch(format) {\n        case CIF:\n        case BCIF:\n            return CifStructureConverter.fromURL(url, cache.getFileParsingParams());\n        case MMTF:\n            return MmtfActions.readFromInputStream(url.openStream());\n        default:\n        case PDB:\n            // pdb file based parsing\n            PDBFileReader reader = new PDBFileReader(cache.getPath());\n            reader.setFetchBehavior(cache.getFetchBehavior());\n            reader.setObsoleteBehavior(cache.getObsoleteBehavior());\n            reader.setFileParsingParameters(cache.getFileParsingParams());\n            return reader.getStructure(url);\n    }\n}", "repo_id": "9", "comment": "/**\n * Load the structure from the URL\n * @return null\n */\n", "repo_name": "biojava-master/", "id": 1070, "method_signature": "Structure loadStructure(AtomCache)"}, "3252": {"callee_method_ids": [3269], "callee_method_names": ["JMenu.setMnemonic", "JMenu.getAccessibleContext", "JMenuItem.addActionListener", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.add", "JMenuItem.addActionListener", "AbstractAlignmentJmol.getJmolPanel", "JMenu.add", "JMenu.addSeparator", "JMenu.add", "JMenu.add", "JMenuBar.add", "JMenu.setMnemonic", "JMenu.add", "JMenu.add", "JMenuBar.add", "JMenu.getAccessibleContext", "JMenu.setMnemonic", "JMenuItem.setMnemonic", "JMenuItem.setAccelerator", "JMenu.add", "JMenuItem.setMnemonic", "JMenu.add", "JMenuItem.setMnemonic", "JMenu.add", "JMenuItem.setMnemonic", "JMenu.add", "JMenuItem.setMnemonic", "JMenuItem.addActionListener", "JMenu.add", "JMenuItem.setMnemonic", "JMenuItem.addActionListener", "JMenu.add", "JMenuItem.setMnemonic", "JMenu.add", "JMenuBar.add", "JMenu.setMnemonic", "JMenu.add", "JMenu.add", "JMenuBar.add", "JMenuBar.add"], "method_name": "MenuCreator.initJmolMenu", "method_implementation": "{\n    JMenuBar menu = new JMenuBar();\n    /// FILE MENU\n    JMenu file = new JMenu(\"File\");\n    file.setMnemonic(KeyEvent.VK_F);\n    file.getAccessibleContext().setAccessibleDescription(\"File Menu\");\n    //Load\n    if (parent != null) {\n        JMenuItem loadF = getLoadMenuItem();\n        loadF.addActionListener(new MyAlignmentLoadListener());\n        file.add(loadF);\n    }\n    //Save\n    JMenuItem saveF = getSaveAlignmentMenuItem(afpChain, msa);\n    file.add(saveF);\n    //Open PDB\n    JMenuItem openPDB = getShowPDBMenuItem();\n    file.add(openPDB);\n    //Open Import\n    JMenuItem openI = getOpenPDBMenuItem();\n    file.add(openI);\n    //Export\n    if (parent != null) {\n        JMenuItem exportI = getExportPDBMenuItem(parent);\n        file.add(exportI);\n    }\n    //Print\n    if (parent != null) {\n        JMenuItem print = getPrintMenuItem();\n        print.addActionListener(parent.getJmolPanel());\n        file.add(print);\n    }\n    file.addSeparator();\n    //Close Frame\n    JMenuItem closeI = getCloseMenuItem(frame);\n    file.add(closeI);\n    //Exit\n    JMenuItem exitI = getExitMenuItem();\n    file.add(exitI);\n    menu.add(file);\n    /// ALIGN MENU\n    JMenu align = new JMenu(\"Align\");\n    align.setMnemonic(KeyEvent.VK_A);\n    //new Pairwise alignment\n    JMenuItem pairI = getPairwiseAlignmentMenuItem();\n    align.add(pairI);\n    //new Multiple alignment\n    JMenuItem multI = getMultipleAlignmentMenuItem();\n    align.add(multI);\n    menu.add(align);\n    /// VIEW MENU\n    JMenu view = new JMenu(\"View\");\n    view.getAccessibleContext().setAccessibleDescription(\"View Menu\");\n    view.setMnemonic(KeyEvent.VK_V);\n    if (parent != null) {\n        //Alignment Panel\n        JMenuItem apI = MenuCreator.getIcon(parent, ALIGNMENT_PANEL);\n        apI.setMnemonic(KeyEvent.VK_M);\n        apI.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M, keyMask));\n        view.add(apI);\n        //Text Format\n        JMenuItem textI = MenuCreator.getIcon(parent, TEXT_ONLY);\n        textI.setMnemonic(KeyEvent.VK_T);\n        view.add(textI);\n        //Alignment Pairs\n        JMenuItem pairsI = MenuCreator.getIcon(parent, PAIRS_ONLY);\n        pairsI.setMnemonic(KeyEvent.VK_P);\n        view.add(pairsI);\n        //FatCat Format\n        JMenuItem textF = MenuCreator.getIcon(parent, FATCAT_TEXT);\n        textF.setMnemonic(KeyEvent.VK_F);\n        view.add(textF);\n        //Distance Matrices\n        JMenuItem distMax = new JMenuItem(DIST_MATRICES);\n        distMax.setMnemonic(KeyEvent.VK_D);\n        distMax.addActionListener(new MyDistMaxListener(parent));\n        view.add(distMax);\n        //Dot Plot - only if the alignment was an afpChain\n        if (afpChain != null) {\n            JMenuItem dotplot = new JMenuItem(DOT_PLOT);\n            dotplot.setMnemonic(KeyEvent.VK_O);\n            dotplot.addActionListener(new DotPlotListener(afpChain));\n            view.add(dotplot);\n        }\n        //Phylogenetics - only if it is a MultipleAlignment\n        if (afpChain == null) {\n            JMenuItem tree = getIcon(parent, PHYLOGENETIC_TREE);\n            tree.setMnemonic(KeyEvent.VK_T);\n            view.add(tree);\n        }\n    }\n    menu.add(view);\n    /// HELP MENU\n    JMenu about = new JMenu(\"Help\");\n    about.setMnemonic(KeyEvent.VK_H);\n    JMenuItem helpM = getHelpMenuItem();\n    about.add(helpM);\n    JMenuItem aboutM = getAboutMenuItem();\n    about.add(aboutM);\n    menu.add(Box.createGlue());\n    menu.add(about);\n    return menu;\n}", "repo_id": "9", "comment": "/**\n * Provide a JMenuBar that can be added to a JFrame containing\n * a JmolPanel. The alignment has to be either an AFPChain or a\n * MultipleAlignment: set the other parameter to null.<p>\n * Menus included:\n * <ul><li>File: open, save, export, import, exit.\n * <li>Align: new pairwise alignment, new multiple alignment.\n * <li>View: aligment panel, aligned pairs, text format,\n * FatCat format, distance matrices, dot plot.\n * <li>Help\n * </ul>\n *\n * @return a JMenuBar\n */\n", "repo_name": "biojava-master/", "id": 3252, "method_signature": "JMenuBar initJmolMenu(JFrame, AbstractAlignmentJmol, AFPChain, MultipleAlignment)"}, "521": {"callee_method_names": ["String.contains"], "method_name": "AFPChainXMLParser.isErrorXML", "method_implementation": "{\n    if (xml.contains(\"error=\\\"\"))\n        return true;\n    return false;\n}", "repo_id": "9", "comment": "/**\n * returns true if the alignment XML contains an error message\n *\n * @param xml\n * @return flag if there was an Error while processing the alignment.\n */\n", "repo_name": "biojava-master/", "id": 521, "method_signature": "boolean isErrorXML(String)"}, "987": {"callee_method_names": [], "method_name": "HetatomImpl.hasAminoAtoms", "method_implementation": "{\n    // if this method call is performed too often, it should become a\n    // private method and provide a flag for Group object ...\n    return hasAtom(StructureTools.CA_ATOM_NAME) && hasAtom(StructureTools.C_ATOM_NAME) && hasAtom(StructureTools.N_ATOM_NAME) && hasAtom(StructureTools.O_ATOM_NAME);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 987, "method_signature": "boolean hasAminoAtoms()"}, "3662": {"callee_method_names": [], "method_name": "SurvivalInfo.setScore", "method_implementation": "{\n    this.score = score;\n}", "repo_id": "9", "comment": "/**\n * @param score the score to set\n */\n", "repo_name": "biojava-master/", "id": 3662, "method_signature": "void setScore(double)"}, "2760": {"callee_method_names": [], "method_name": "EmblReference.getReferenceTitle", "method_implementation": "{\n    return referenceTitle;\n}", "repo_id": "9", "comment": "/**\n * The RT (Reference Title) lines give the title of the paper (or other work) as\n * exactly as is possible given the limitations of computer character sets.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2760, "method_signature": "String getReferenceTitle()"}, "3437": {"callee_method_names": ["StructureViewer.setStructure"], "method_name": "StructureViewerTest.testSetStructure", "method_implementation": "{\n    if (java.awt.GraphicsEnvironment.isHeadless())\n        return;\n    Structure structure = null;\n    StructureViewer instance = new StructureViewerImpl();\n    instance.setStructure(structure);\n    // TODO review the generated test code and remove the default call to fail.\n    //fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of setStructure method, of class StructureViewer.\n */\n", "repo_name": "biojava-master/", "id": 3437, "method_signature": "void testSetStructure()"}, "1254": {"callee_method_names": ["Group.setProperty"], "method_name": "MmtfUtils.setSecStructType", "method_implementation": "{\n    SecStrucType secStrucType = getSecStructTypeFromDsspIndex(dsspIndex);\n    SecStrucState secStrucState = new SecStrucState(group, \"MMTF_ASSIGNED\", secStrucType);\n    if (secStrucType != null) {\n        group.setProperty(\"secstruc\", secStrucState);\n    }\n}", "repo_id": "9", "comment": "/**\n * Get the secondary structure as defined by DSSP.\n * @param group the input group to be calculated\n * @param dsspIndex integer index of the group type.\n */\n", "repo_name": "biojava-master/", "id": 1254, "method_signature": "void setSecStructType(Group, int)"}, "3059": {"callee_method_names": [], "method_name": "AccessionID.getIdentifier", "method_implementation": "{\n    return identifier;\n}", "repo_id": "9", "comment": "/**\n * In case if {@link #getID() } is not unique, keeps the alternative id, e.g. NCBI GI number.\n * This may be null.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3059, "method_signature": "String getIdentifier()"}, "3224": {"callee_method_names": ["Logger.info", "FastaReader<ProteinSequence, AminoAcidCompound>.process", "InputStream.close", "LinkedHashMap<String, ProteinSequence>.size", "LinkedHashMap<String, ProteinSequence>.keySet", "LinkedHashMap<String, ProteinSequence>.get", "ProteinSequence.getAccession", "ProteinSequence.getSequenceAsString", "ProteinSequence.getAccession", "ProteinSequence.getSequenceAsString", "ProteinSequence.getAccession", "ProteinSequence.getSequenceAsString"], "method_name": "FastaReaderTest.testProcess", "method_implementation": "{\n    logger.info(\"process\");\n    InputStream inStream = this.getClass().getResourceAsStream(\"/PF00104_small.fasta\");\n    Assert.assertNotNull(inStream);\n    FastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n    LinkedHashMap<String, ProteinSequence> proteinSequences = fastaReader.process();\n    inStream.close();\n    //Should have 282 sequences\n    //logger.debug(\"Expecting 283 got \" + proteinSequences.size());\n    Assert.assertEquals(proteinSequences.size(), 283);\n    int seqNum = 0;\n    for (String id : proteinSequences.keySet()) {\n        ProteinSequence proteinSequence = proteinSequences.get(id);\n        switch(seqNum) {\n            case 0:\n                Assert.assertEquals(proteinSequence.getAccession().getID(), \"A2D504_ATEGE/1-46\");\n                Assert.assertEquals(proteinSequence.getSequenceAsString(), \"-----------------FK-N----LP-LED----------------Q----ITL--IQY-----------SWM----------------------CL-SSFA------LSWRSYK---HTNSQFLYFAPDLVF-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\");\n                break;\n            case 281:\n                //logger.debug(\"Get Accession: {}\", proteinSequence.getAccession());\n                //logger.debug(\"Get Protein Sequence: {}\", proteinSequence.getSequenceAsString());\n                Assert.assertEquals(proteinSequence.getAccession().getID(), \"Q9PU76_CRONI/141-323\");\n                Assert.assertEquals(proteinSequence.getSequenceAsString(), \"VETVTELTEFAKSI-PGFS-N----LD-LND----------------Q----VTL--LKY-----------GVY----------------------EA-IFAM------LASVMNK---DGMPVAYGNGFITRE------------------------------------------------------------------------------------------------------------------------------------------------------------FLKSLRKPFCDIMEPKFDFA-MKF-NSL-E-LDDSDI--------------------SLFVA-AIIC-CGDRPG-------------------------------------------LVNV--GHIEKMQESIVHVLKL-H-----LQN---------NH---PD----------------------------DI------F--------LFP-KLLQKMAD-LRQLV-----------------TEH-AQLV--QIIKK---TESDAHLHPLL-------QEI---\");\n                break;\n            case 282:\n                Assert.assertEquals(proteinSequence.getAccession().getID(), \"Q98SJ1_CHICK/15-61\");\n                Assert.assertEquals(proteinSequence.getSequenceAsString(), \"---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Q-----------------NW------Q--------RFY-QLTKLLDS-MHDVV-----------------ENL-LSFC--FQTFLDKSM--SIEFPEML-------AEI---\");\n                break;\n        }\n        seqNum++;\n    }\n    Assert.assertEquals(seqNum, 283);\n}", "repo_id": "9", "comment": "/**\n * Test of process method, of class FastaReader.\n */\n", "repo_name": "biojava-master/", "id": 3224, "method_signature": "void testProcess()"}, "1267": {"callee_method_names": ["List<Atom>.get", "List<Atom>.get"], "method_name": "MmtfStructureReader.setGroupBond", "method_implementation": "{\n    // Get the atoms\n    Atom atomOne = atomsInGroup.get(indOne);\n    Atom atomTwo = atomsInGroup.get(indTwo);\n    // set the new bond\n    new BondImpl(atomOne, atomTwo, bondOrder);\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInter\n\t * face#setGroupBonds(int, int, int)\n\t */\n", "repo_name": "biojava-master/", "id": 1267, "method_signature": "void setGroupBond(int, int, int)"}, "1039": {"callee_method_names": ["Structure.getChains", "Chain.getAtomGroups", "Group.hasAtom", "Group.getAtom", "List<Atom>.add", "Group.getAtom", "List<Atom>.toArray", "List<Atom>.size"], "method_name": "StructureTools.getAtomCAArray", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<Atom>();\n    for (Chain c : s.getChains()) {\n        for (Group g : c.getAtomGroups()) {\n            if (g.hasAtom(CA_ATOM_NAME) && g.getAtom(CA_ATOM_NAME).getElement() == Element.C) {\n                atoms.add(g.getAtom(CA_ATOM_NAME));\n            }\n        }\n    }\n    return atoms.toArray(new Atom[atoms.size()]);\n}", "repo_id": "9", "comment": "/**\n * Return an Atom array of the C-alpha atoms. Any atom that is a carbon and\n * has CA name will be returned.\n *\n * @param s\n *            the structure object\n * @return an Atom[] array\n * @see #getRepresentativeAtomArray(Structure)\n */\n", "repo_name": "biojava-master/", "id": 1039, "method_signature": "Atom[] getAtomCAArray(Structure)"}, "1622": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getSequenceIdentityThreshold", "method_implementation": "{\n    return sequenceIdentityThreshold;\n}", "repo_id": "9", "comment": "/**\n * Sequence identity threshold to consider for the subunits clustering.\n * <p>\n * Two subunits with sequence identity equal or higher than the threshold\n * will be clustered together.\n *\n * @return sequenceIdentityThreshold\n */\n", "repo_name": "biojava-master/", "id": 1622, "method_signature": "double getSequenceIdentityThreshold()"}, "2413": {"callee_method_names": [], "method_name": "Location.overlaps", "method_implementation": "{\n    if (isSameStrand(other)) {\n        return !(mStart >= other.mEnd || mEnd <= other.mStart);\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Check if this location and other location overlap.\n *\n * @param other The location to compare.\n * @return True if they overlap.\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2413, "method_signature": "boolean overlaps(Location)"}, "1227": {"callee_method_names": ["String.split", "String[].substring", "Matrix.set", "Matrix.set", "Matrix.set"], "method_name": "PDBBioAssemblyParser.readMatrix", "method_implementation": "{\n    // split by one or more spaces\n    String[] items = line.split(\"[ ]+\");\n    // parse BIOMTx, where x is the position in the matrix\n    String pos = items[2].substring(5);\n    int row = Integer.parseInt(pos);\n    if (row == 1) {\n        currentMatrix = Matrix.identity(3, 3);\n        shift = new double[3];\n    }\n    currentMatrix.set((row - 1), 0, Float.parseFloat(items[4]));\n    currentMatrix.set((row - 1), 1, Float.parseFloat(items[5]));\n    currentMatrix.set((row - 1), 2, Float.parseFloat(items[6]));\n    shift[row - 1] = Float.parseFloat(items[7]);\n    // return true if 3rd row of matrix has been processed\n    return row == 3;\n}", "repo_id": "9", "comment": "/**\n * Parses a row of a BIOMT matrix in a REMARK 350 record.\n * Example: REMARK 350   BIOMT1   2  1.000000  0.000000  0.000000        0.00000\n * @param line\n * @return true if 3rd line of matrix has been parsed (matrix is complete)\n */\n", "repo_name": "biojava-master/", "id": 1227, "method_signature": "boolean readMatrix(String)"}, "1692": {"callee_method_names": ["Point3d.get"], "method_name": "AtomImpl.getCoords", "method_implementation": "{\n    double[] c = new double[3];\n    coords.get(c);\n    return c;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1692, "method_signature": "double[] getCoords()"}, "3519": {"callee_method_names": [], "method_name": "StrataInfo.getLower", "method_implementation": "{\n    return lower;\n}", "repo_id": "9", "comment": "/**\n * @return the lower\n */\n", "repo_name": "biojava-master/", "id": 3519, "method_signature": "ArrayList<Double> getLower()"}, "1720": {"callee_method_names": [], "method_name": "BasePairParameters.getStepParameters", "method_implementation": "{\n    return stepParameters;\n}", "repo_id": "9", "comment": "/**\n * This method reports all the base-pair step parameters, in the order of:\n * tilt, roll, twist (in degrees), shift, slide, rise (in \u00c5).\n * @return A double[][] with length equal to number of base pairs (the first row 0 has no step\n *  and therefore is six zeroes), and 6 columns.\n */\n", "repo_name": "biojava-master/", "id": 1720, "method_signature": "double[][] getStepParameters()"}, "2401": {"callee_method_names": [], "method_name": "Location.length", "method_implementation": "{\n    return mEnd - mStart;\n}", "repo_id": "9", "comment": "/**\n * Get length of range.\n *\n * @return The length of the range (end - start).\n */\n", "repo_name": "biojava-master/", "id": 2401, "method_signature": "int length()"}, "2557": {"callee_method_names": ["ResultFactory.setFile", "ResultFactory.createObjects"], "method_name": "SearchIO.writeResults", "method_implementation": "{\n    factory.setFile(file);\n    factory.createObjects(evalueThreshold);\n}", "repo_id": "9", "comment": "/**\n * used to write a search report using the guessed or specified factory\n *\n * @throws java.io.IOException for file access related issues\n * @throws java.text.ParseException for file format related issues\n */\n", "repo_name": "biojava-master/", "id": 2557, "method_signature": "void writeResults()"}, "3407": {"callee_method_names": ["Color4f.sub"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getPolyhedronColor", "method_implementation": "{\n    Color4f[] colors = getSymmetryColors(5);\n    Color4f strongestColor = colors[4];\n    Color4f complement = new Color4f(Color.WHITE);\n    complement.sub(strongestColor);\n    return complement;\n}", "repo_id": "9", "comment": "/**\n * Return a color that is complementary to the symmetry color\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3407, "method_signature": "Color4f getPolyhedronColor()"}, "725": {"callee_method_names": ["AFPChain.setBlockNum", "AFPChain.setBlockRotationMatrix", "AFPChain.setBlockShiftVector", "AFPChain.setDisTable1", "AFPChain.setDisTable1", "AFPChain.setDisTable2", "AFPChain.setDisTable2", "AFPChain.setOptAln", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "AFPChain.setAlnseq1", "AFPChain.setAlnseq2", "AFPChain.setAlnsymb", "AFPChain.setIdentity", "AFPChain.setSimilarity", "AFPChain.setIdentity", "AFPChain.setSimilarity"], "method_name": "CECalculator.convertAfpChain", "method_implementation": "{\n    afpChain.setBlockNum(1);\n    //afpChain.setAlignScore(z);\n    Matrix[] m;\n    if (r != null) {\n        m = new Matrix[1];\n        m[0] = r;\n    } else {\n        m = new Matrix[0];\n    }\n    Atom[] as;\n    if (t != null) {\n        as = new Atom[1];\n        as[0] = t;\n    } else {\n        as = new Atom[0];\n    }\n    afpChain.setBlockRotationMatrix(m);\n    afpChain.setBlockShiftVector(as);\n    int nse1 = ca1.length;\n    int nse2 = ca2.length;\n    //System.out.println(\"dist1 :\" + dist1.length + \" \" + dist2.length);\n    if (nse1 > 0 && dist1.length > 0)\n        afpChain.setDisTable1(new Matrix(dist1));\n    else\n        afpChain.setDisTable1(Matrix.identity(3, 3));\n    if (nse2 > 0 && dist2.length > 0)\n        afpChain.setDisTable2(new Matrix(dist2));\n    else\n        afpChain.setDisTable2(Matrix.identity(3, 3));\n    char[] alnseq1 = new char[nse1 + nse2 + 1];\n    char[] alnseq2 = new char[nse1 + nse2 + 1];\n    char[] alnsymb = new char[nse1 + nse2 + 1];\n    int[][][] optAln = new int[1][2][nAtom];\n    afpChain.setOptAln(optAln);\n    int pos = 0;\n    int nrIdent = 0;\n    int nrSim = 0;\n    for (int ia = 0; ia < lcmp; ia++) {\n        // no gap\n        if (align_se1[ia] != -1 && align_se2[ia] != -1) {\n            //System.out.println(\"ia \" + ia + \" pos \" + pos + \" \"  + align_se1[ia] + \" \" + align_se2[ia]);\n            optAln[0][0][pos] = align_se1[ia];\n            optAln[0][1][pos] = align_se2[ia];\n            char l1 = getOneLetter(ca1[align_se1[ia]].getGroup());\n            char l2 = getOneLetter(ca2[align_se2[ia]].getGroup());\n            alnseq1[ia] = Character.toUpperCase(l1);\n            alnseq2[ia] = Character.toUpperCase(l2);\n            alnsymb[ia] = ' ';\n            if (l1 == l2) {\n                nrIdent++;\n                nrSim++;\n                alnsymb[ia] = '|';\n            } else if (AFPAlignmentDisplay.aaScore(l1, l2) > 0) {\n                nrSim++;\n                alnsymb[ia] = ':';\n            }\n            pos++;\n        } else {\n            // there is a gap at this position\n            alnsymb[ia] = ' ';\n            if (align_se1[ia] == -1) {\n                alnseq1[ia] = '-';\n            } else {\n                char l1 = getOneLetter(ca1[align_se1[ia]].getGroup());\n                alnseq1[ia] = Character.toUpperCase(l1);\n            }\n            if (align_se2[ia] == -1) {\n                alnseq2[ia] = '-';\n            } else {\n                char l2 = getOneLetter(ca2[align_se2[ia]].getGroup());\n                alnseq2[ia] = Character.toUpperCase(l2);\n            }\n        }\n    }\n    afpChain.setAlnseq1(alnseq1);\n    afpChain.setAlnseq2(alnseq2);\n    afpChain.setAlnsymb(alnsymb);\n    // CE uses the aligned pairs as reference not the whole alignment including gaps...\n    if (pos > 0) {\n        afpChain.setIdentity(nrIdent * 1.0 / pos);\n        afpChain.setSimilarity(nrSim * 1.0 / pos);\n    } else {\n        afpChain.setIdentity(0);\n        afpChain.setSimilarity(0);\n    }\n    //AFPAlignmentDisplay.getAlign( afpChain,ca1,ca2);\n}", "repo_id": "9", "comment": "/**\n * copy data from this class into AFPChain container object.\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n */\n", "repo_name": "biojava-master/", "id": 725, "method_signature": "void convertAfpChain(AFPChain, Atom[], Atom[])"}, "71": {"callee_method_names": ["GapPenalty.getType"], "method_name": "AbstractMatrixAligner.reset", "method_implementation": "{\n    xyMax = new int[] { 0, 0 };\n    xyStart = new int[] { 0, 0 };\n    scores = null;\n    types = (gapPenalty == null || gapPenalty.getType() == GapPenalty.Type.LINEAR) ? new String[] { null } : new String[] { \"Substitution\", \"Deletion\", \"Insertion\" };\n    time = -1;\n    profile = null;\n}", "repo_id": "9", "comment": "/**\n * Resets output fields; should be overridden to set max and min\n */\n", "repo_name": "biojava-master/", "id": 71, "method_signature": "void reset()"}, "2763": {"callee_method_names": ["File.isDirectory", "BufferedReader.readLine", "String.length", "String.substring", "String.length", "String.substring", "EmblRecord.setEmblId", "String.contains", "EmblRecord.setCreatedDate", "String.contains", "EmblRecord.setLastUpdatedDate", "EmblRecord.setSequenceDescription", "LinkedList<String>.add", "EmblRecord.setOrganismSpecies", "EmblRecord.setOrganismClassification", "EmblRecord.setOrGanelle", "EmblRecord.setDatabaseCrossReference", "EmblRecord.setAssemblyHeader", "EmblRecord.setAssemblyInformation", "EmblRecord.setConstructedSequence", "EmblRecord.setFeatureHeader", "EmblRecord.setFeatureTable", "EmblRecord.setSequenceHeader", "EmblRecord.setKeyword", "EmblRecord.setEmblReference", "EmblRecord.setAccessionNumber", "EmblRecord.setSequence", "StringBuilder.toString"], "method_name": "EmblReader.process", "method_implementation": "{\n    EmblRecord emblRecord = new EmblRecord();\n    StringBuilder sequence = new StringBuilder(\"\");\n    LinkedList<EmblReference> emblReferences = new LinkedList<>();\n    EmblReference emblReference = new EmblReference();\n    LinkedList<String> accessionNumber = new LinkedList<>();\n    LinkedList<String> keyword = new LinkedList<>();\n    if (file == null)\n        throw new NullPointerException(\"file can't be null\");\n    if (file.isDirectory())\n        throw new IllegalArgumentException(\"the file can't be a directory\");\n    try (FileReader fileReader = new FileReader(file)) {\n        String line = \"\";\n        String lineIdentifier;\n        String lineInfo;\n        try (BufferedReader bufferedReader = new BufferedReader(fileReader)) {\n            while ((line = bufferedReader.readLine()) != null) {\n                if (line.length() > 1) {\n                    lineInfo = line.substring(2, line.length()).trim();\n                    lineIdentifier = line.substring(0, 2);\n                    if (\"ID\".equals(lineIdentifier))\n                        emblRecord.setEmblId(populateID(lineInfo));\n                    else if (\"AC\".equals(lineIdentifier))\n                        populateAccessionNumber(line, accessionNumber);\n                    else if (\"DT\".equals(lineIdentifier) && line.contains(\"Created\"))\n                        emblRecord.setCreatedDate(lineInfo);\n                    else if (\"DT\".equals(lineIdentifier) && line.contains(\"updated\"))\n                        emblRecord.setLastUpdatedDate(lineInfo);\n                    else if (\"DE\".equals(lineIdentifier))\n                        emblRecord.setSequenceDescription(lineInfo);\n                    else if (\"KW\".equals(lineIdentifier))\n                        keyword.add(lineInfo);\n                    else if (\"OS\".equals(lineIdentifier))\n                        emblRecord.setOrganismSpecies(lineInfo);\n                    else if (\"OC\".equals(lineIdentifier))\n                        emblRecord.setOrganismClassification(lineInfo);\n                    else if (\"OG\".equals(lineIdentifier))\n                        emblRecord.setOrGanelle(lineInfo);\n                    else if (\"RN\".equals(lineIdentifier) || \"RP\".equals(lineIdentifier) || \"RX\".equals(lineIdentifier) || \"RG\".equals(lineIdentifier) || \"RA\".equals(lineIdentifier) || \"RT\".equals(lineIdentifier) || \"RL\".equals(lineIdentifier))\n                        populateEmblReferences(lineIdentifier, lineInfo, emblReference, emblReferences);\n                    else if (\"DR\".equals(lineIdentifier))\n                        emblRecord.setDatabaseCrossReference(lineInfo);\n                    else if (\"AH\".equals(lineIdentifier))\n                        emblRecord.setAssemblyHeader(lineInfo);\n                    else if (\"AS\".equals(lineIdentifier))\n                        emblRecord.setAssemblyInformation(lineInfo);\n                    else if (\"CO\".equals(lineIdentifier))\n                        emblRecord.setConstructedSequence(lineInfo);\n                    else if (\"FH\".equals(lineIdentifier))\n                        emblRecord.setFeatureHeader(lineInfo);\n                    else if (\"FT\".equals(lineIdentifier))\n                        emblRecord.setFeatureTable(lineInfo);\n                    else if (\"SQ\".equals(lineIdentifier))\n                        emblRecord.setSequenceHeader(lineInfo);\n                    else if (\"  \".equals(lineIdentifier) && !\"//\".equals(lineIdentifier))\n                        populateSequence(line, sequence);\n                    else if (\"//\".equals(lineIdentifier)) {\n                        emblRecord.setKeyword(keyword);\n                        emblRecord.setEmblReference(emblReferences);\n                        emblRecord.setAccessionNumber(accessionNumber);\n                        emblRecord.setSequence(sequence.toString());\n                    }\n                }\n            }\n        }\n    }\n    return emblRecord;\n}", "repo_id": "9", "comment": "/**\n * The parsing is done in this method.<br>\n * This method tries to process all the Embl records\n * in the File , closes the underlying resource,\n * and return the results in object of EmblRecord.<br>\n *\n * @return EmblRecord containing all the parsed Embl records\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2763, "method_signature": "EmblRecord process(File)"}, "2033": {"callee_method_names": [], "method_name": "Icosahedron.getInscribedRadius", "method_implementation": "{\n    double side = getSideLengthFromCircumscribedRadius(circumscribedRadius);\n    return getInscribedRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of an inscribed sphere, that is tangent to each\n * of the icosahedron's faces\n * @return the inscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2033, "method_signature": "double getInscribedRadius()"}, "61": {"callee_method_names": [], "method_name": "AbstractMatrixAligner.getSubstitutionMatrix", "method_implementation": "{\n    return subMatrix;\n}", "repo_id": "9", "comment": "/**\n * Returns the substitution matrix.\n *\n * @return the set of substitution scores used during alignment\n */\n", "repo_name": "biojava-master/", "id": 61, "method_signature": "SubstitutionMatrix<C> getSubstitutionMatrix()"}, "1743": {"callee_method_names": [], "method_name": "BasePairParameters.removeComponent", "method_implementation": "{\n    double dot = 0;\n    double[] result = new double[4];\n    for (int i = 0; i < 3; i++) {\n        dot += a[i] * b[i];\n    }\n    for (int i = 0; i < 3; i++) {\n        result[i] = a[i] - dot * b[i];\n    }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * This method removes any component of vector a that is along vector b. (used internally)\n * @param a The array (vector) to remove component from\n * @param b The component array (vector) to remove from the first\n * @return The original array a with any component along b removed from it.\n */\n", "repo_name": "biojava-master/", "id": 1743, "method_signature": "double[] removeComponent(double[], double[])"}, "1774": {"callee_method_names": [], "method_name": "PDBHeader.getModDate", "method_implementation": "{\n    return modDate;\n}", "repo_id": "9", "comment": "/**\n * Return the latest modification date of the structure.\n *\n * @return the latest modification date\n */\n", "repo_name": "biojava-master/", "id": 1774, "method_signature": "Date getModDate()"}, "1904": {"callee_method_names": ["QuatSymmetrySubunits.getClusterIds", "List<Integer>.size", "List<Integer>.get", "List<Integer>.get", "List<Integer>.get", "List<Integer>.size"], "method_name": "RotationSolver.isAllowedPermutation", "method_implementation": "{\n    List<Integer> seqClusterId = subunits.getClusterIds();\n    int selfaligned = 0;\n    for (int i = 0; i < permutation.size(); i++) {\n        int j = permutation.get(i);\n        if (!Objects.equals(seqClusterId.get(i), seqClusterId.get(j))) {\n            return false;\n        }\n        if (i == j) {\n            selfaligned++;\n        }\n    }\n    // either identity (all self aligned) or all unique\n    return selfaligned == 0 || selfaligned == permutation.size();\n}", "repo_id": "9", "comment": "/**\n * The permutation must map all subunits onto an equivalent subunit\n * and no subunit onto itself\n * @param permutation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1904, "method_signature": "boolean isAllowedPermutation(List)"}, "1024": {"callee_method_ids": [1346, 1349], "callee_method_names": ["Group.getChainId", "String.isEmpty", "Chain.getId", "Structure.getChain", "Chain.setId", "Group.getChain", "Chain.setName", "Chain.getName", "Chain.getEntityInfo", "Structure.addEntityInfo", "Structure.getEntityById", "EntityInfo.getMolId", "Structure.addEntityInfo", "EntityInfo.addChain", "Chain.setEntityInfo", "Chain.setSeqResGroups", "Chain.getSeqResGroups", "Chain.setSeqMisMatches", "Chain.getSeqMisMatches", "Structure.addChain", "Group.clone", "Chain.addGroup"], "method_name": "StructureTools.addGroupToStructure", "method_implementation": "{\n    // Find or create the chain\n    String chainId = g.getChainId();\n    assert !chainId.isEmpty();\n    Chain chain;\n    if (chainGuess != null && chainGuess.getId().equals(chainId)) {\n        // previously guessed chain\n        chain = chainGuess;\n    } else {\n        // Try to guess\n        chain = s.getChain(chainId, model);\n        if (chain == null) {\n            // no chain found\n            chain = new ChainImpl();\n            chain.setId(chainId);\n            Chain oldChain = g.getChain();\n            chain.setName(oldChain.getName());\n            EntityInfo oldEntityInfo = oldChain.getEntityInfo();\n            EntityInfo newEntityInfo;\n            if (oldEntityInfo == null) {\n                newEntityInfo = new EntityInfo();\n                s.addEntityInfo(newEntityInfo);\n            } else {\n                newEntityInfo = s.getEntityById(oldEntityInfo.getMolId());\n                if (newEntityInfo == null) {\n                    newEntityInfo = new EntityInfo(oldEntityInfo);\n                    s.addEntityInfo(newEntityInfo);\n                }\n            }\n            newEntityInfo.addChain(chain);\n            chain.setEntityInfo(newEntityInfo);\n            // TODO Do the seqres need to be cloned too? -SB 2016-10-7\n            chain.setSeqResGroups(oldChain.getSeqResGroups());\n            chain.setSeqMisMatches(oldChain.getSeqMisMatches());\n            s.addChain(chain, model);\n        }\n    }\n    // Add cloned group\n    if (clone) {\n        g = (Group) g.clone();\n    }\n    chain.addGroup(g);\n    return chain;\n}", "repo_id": "9", "comment": "/**\n * Adds a particular group to a structure. A new chain will be created if necessary.\n *\n * <p>When adding multiple groups, pass the return value of one call as the\n * chainGuess parameter of the next call for efficiency.\n * <pre>\n * Chain guess = null;\n * for(Group g : groups) {\n *     guess = addGroupToStructure(s, g, guess );\n * }\n * </pre>\n * @param s structure to receive the group\n * @param g group to add\n * @param chainGuess (optional) If not null, should be a chain from s. Used\n *  to improve performance when adding many groups from the same chain\n * @param clone Indicates whether the input group should be cloned before\n *  being added to the new chain\n * @return the chain g was added to\n */\n", "repo_name": "biojava-master/", "id": 1024, "method_signature": "Chain addGroupToStructure(Structure, Group, int, Chain, boolean)"}, "2590": {"callee_method_names": ["String.indexOf", "Element.getChildNodes", "NodeList.getLength", "NodeList.item", "Element.getNodeType", "Element.getNodeName", "XPath.evaluate"], "method_name": "XMLHelper.selectSingleElement", "method_implementation": "{\n    if (element == null) {\n        return null;\n    }\n    if (xpathExpression.indexOf(\"/\") == -1) {\n        NodeList nodeList = element.getChildNodes();\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            Node node = nodeList.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(xpathExpression)) {\n                return (Element) node;\n            }\n        }\n        //  NodeList nodes = element.getElementsByTagName(xpathExpression);\n        //  if (nodes.getLength() > 0) {\n        //      return (Element) nodes.item(0);\n        //  } else {\n        return null;\n        //  }\n    } else {\n        XPath xpath = XPathFactory.newInstance().newXPath();\n        Element node = (Element) xpath.evaluate(xpathExpression, element, XPathConstants.NODE);\n        return node;\n    }\n}", "repo_id": "9", "comment": "/**\n * If {@code}xpathExpression{@code} is a plain string with no '/' characterr, this is\n * interpreted as a child element name to search for.\n * <b/>\n * If {@code}xpathExpression{@code} is an XPath expression, this is evaluated and is assumed\n * to identify a single element.\n * @param element\n * @param xpathExpression\n * @return A single element or null if no match or the 1st match if matches more than 1\n * @throws XPathExpressionException\n */\n", "repo_name": "biojava-master/", "id": 2590, "method_signature": "Element selectSingleElement(Element, String)"}, "3406": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.setPolyhedron", "method_implementation": "{\n    this.polyhedron = polyhedron;\n}", "repo_id": "9", "comment": "/**\n * @param polyhedron the polyhedron to set\n */\n", "repo_name": "biojava-master/", "id": 3406, "method_signature": "void setPolyhedron(Polyhedron)"}, "2509": {"callee_method_names": ["String.trim", "String[].endsWith", "List<AminoAcidCompound>.size"], "method_name": "AAIndexFileParser.processScores", "method_implementation": "{\n    String[] values = line.trim().split(\" +\");\n    // increment the current row we are talking about\n    currentRowPos++;\n    for (int i = 0; i < values.length; i++) {\n        if (values[i].endsWith(\".\")) {\n            values[i] = values[i] + \"0\";\n        }\n        // special case: MEHP950101\n        if (\"-\".equals(values[i])) {\n            values[i] = \"0\";\n        }\n        if (scale == -1) {\n            scale = determineScale(values[0]);\n        }\n        Float score = Float.parseFloat(values[i]);\n        score = scale * score;\n        Short s = (short) Math.round(score);\n        matrix[currentRowPos][i] = s;\n        if (values.length < cols.size() || (symmetricMatrix)) {\n            //System.out.println(values.length + \" \" + cols.size() + \" \" + currentRowPos + \" \" + i + \" \" +  line);\n            matrix[i][currentRowPos] = s;\n            symmetricMatrix = true;\n        }\n        if (score > max)\n            max = s;\n        if (score < min)\n            min = s;\n    }\n}", "repo_id": "9", "comment": "//  process a line such as >    -0.3     1.6     0.7     0.8    -2.6     3.0<\n", "repo_name": "biojava-master/", "id": 2509, "method_signature": "void processScores(String)"}, "2446": {"callee_method_names": ["HashMap.containsKey", "HashMap.get", "Map<String, List<FeatureI>>.containsKey", "FeatureI.hasAttribute"], "method_name": "FeatureList.hasAttribute", "method_implementation": "{\n    if (featindex.containsKey(key)) {\n        Map<String, List<FeatureI>> mappa = featindex.get(key);\n        if (mappa == null)\n            return false;\n        if (mappa.containsKey(value))\n            return true;\n        return false;\n    }\n    for (FeatureI f : this) {\n        if (f.hasAttribute(key, value)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Check if any feature in list has the specified attribute key/value pair.\n *\n * @param key The attribute key to consider.\n * @param value The attribute value to consider.\n * @return True if at least one feature has the key/value pair.\n */\n", "repo_name": "biojava-master/", "id": 2446, "method_signature": "boolean hasAttribute(String, String)"}, "2854": {"callee_method_names": ["FileInputStream.close"], "method_name": "FastaReaderHelper.readFastaDNASequence", "method_implementation": "{\n    FileInputStream inStream = new FileInputStream(file);\n    LinkedHashMap<String, DNASequence> dnaSequences = readFastaDNASequence(inStream);\n    inStream.close();\n    return dnaSequences;\n}", "repo_id": "9", "comment": "/**\n * @param file\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2854, "method_signature": "LinkedHashMap<String,DNASequence> readFastaDNASequence(File)"}, "1366": {"callee_method_names": [], "method_name": "DBRef.setId", "method_implementation": "{\n    this.id = id;\n}", "repo_id": "9", "comment": "/**\n * Set the ID used by Hibernate.\n *\n * @param id the id assigned by Hibernate\n * @see #getId()\n */\n", "repo_name": "biojava-master/", "id": 1366, "method_signature": "void setId(Long)"}, "3757": {"callee_method_ids": [3700], "callee_method_names": ["LinkedHashMap.keySet", "LinkedHashMap.get", "HeaderInfo.isHide", "ArrayList<String>.add"], "method_name": "WorkSheet.getDataRows", "method_implementation": "{\n    ArrayList<String> rows = new ArrayList<String>();\n    for (String row : rowLookup.keySet()) {\n        if (this.isMetaDataRow(row)) {\n            continue;\n        }\n        HeaderInfo hi = rowLookup.get(row);\n        if (!hi.isHide()) {\n            rows.add(row);\n        }\n    }\n    return rows;\n}", "repo_id": "9", "comment": "/**\n * Get the list of row names\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3757, "method_signature": "ArrayList<String> getDataRows()"}, "3129": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getAliases", "method_implementation": "{\n    return getProteinAliases();\n}", "repo_id": "9", "comment": "/**\n * Pull uniprot protein aliases associated with this sequence\n * Provided for backwards compatibility now that we support both\n * gene and protein aliases via separate methods.\n * @return\n * @throws XPathExpressionException\n */\n", "repo_name": "biojava-master/", "id": 3129, "method_signature": "ArrayList<String> getAliases()"}, "2761": {"callee_method_names": [], "method_name": "EmblReference.getReferenceLocation", "method_implementation": "{\n    return referenceLocation;\n}", "repo_id": "9", "comment": "/**\n * The RL (Reference Location) line contains the conventional citation\n * information for the reference.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2761, "method_signature": "String getReferenceLocation()"}, "2419": {"callee_method_names": [], "method_name": "Location.isAfter", "method_implementation": "{\n    if (isSameStrand(other)) {\n        return mStart >= other.mEnd;\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Check if this location is entirely after the other location (no overlap).\n *\n * @param other The location to compare.\n * @return True if this is after other.\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2419, "method_signature": "boolean isAfter(Location)"}, "216": {"callee_method_names": ["BufferedReader.readLine", "String.startsWith", "List<FastaSequence>.add", "String.substring", "Pattern.matcher", "BufferedReader.close"], "method_name": "SequenceUtil.readFasta", "method_implementation": "{\n    final List<FastaSequence> seqs = new ArrayList<FastaSequence>();\n    final BufferedReader infasta = new BufferedReader(new InputStreamReader(inStream, \"UTF8\"), 16000);\n    final Pattern pattern = Pattern.compile(\"//s+\");\n    String line;\n    String sname = \"\", seqstr = null;\n    do {\n        line = infasta.readLine();\n        if ((line == null) || line.startsWith(\">\")) {\n            if (seqstr != null) {\n                seqs.add(new FastaSequence(sname.substring(1), seqstr));\n            }\n            // remove >\n            sname = line;\n            seqstr = \"\";\n        } else {\n            final String subseq = pattern.matcher(line).replaceAll(\"\");\n            seqstr += subseq;\n        }\n    } while (line != null);\n    infasta.close();\n    return seqs;\n}", "repo_id": "9", "comment": "/**\n * Reads fasta sequences from inStream into the list of FastaSequence\n * objects\n *\n * @param inStream\n *            from\n * @return list of FastaSequence objects\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 216, "method_signature": "List<FastaSequence> readFasta(InputStream)"}, "3810": {"callee_method_ids": [3779], "callee_method_names": ["String.startsWith", "String.startsWith", "String.startsWith", "NumbersAtRiskPanel.setKaplanMeierFigure", "NumbersAtRiskPanel.setSize", "NumbersAtRiskPanel.getHeight", "BufferedImage.createGraphics", "NumbersAtRiskPanel.getWidth", "NumbersAtRiskPanel.getHeight", "BufferedImage.createGraphics", "NumbersAtRiskPanel.paint", "NumbersAtRiskPanel.getWidth", "NumbersAtRiskPanel.getHeight", "BufferedImage.createGraphics", "Graphics2D.drawImage", "Graphics2D.drawImage"], "method_name": "KaplanMeierFigure.savePNGKMNumRisk", "method_implementation": "{\n    if (fileName.startsWith(\"null\") || fileName.startsWith(\"Null\") || fileName.startsWith(\"NULL\")) {\n        return;\n    }\n    this.fileName = fileName;\n    NumbersAtRiskPanel numbersAtRiskPanel = new NumbersAtRiskPanel();\n    numbersAtRiskPanel.setKaplanMeierFigure(this);\n    numbersAtRiskPanel.setSize(this.getWidth(), numbersAtRiskPanel.getHeight());\n    BufferedImage imageKM = new BufferedImage(this.getWidth(), this.getHeight(), BufferedImage.TYPE_INT_RGB);\n    Graphics2D graphics2D = imageKM.createGraphics();\n    this.paint(graphics2D);\n    BufferedImage imageNumRisk = new BufferedImage(numbersAtRiskPanel.getWidth(), numbersAtRiskPanel.getHeight(), BufferedImage.TYPE_INT_RGB);\n    Graphics2D graphics2DNumRisk = imageNumRisk.createGraphics();\n    numbersAtRiskPanel.paint(graphics2DNumRisk);\n    BufferedImage image = new BufferedImage(numbersAtRiskPanel.getWidth(), numbersAtRiskPanel.getHeight() + this.getHeight(), BufferedImage.TYPE_INT_RGB);\n    Graphics2D g = image.createGraphics();\n    g.drawImage(imageKM, 0, 0, null);\n    g.drawImage(imageNumRisk, 0, this.getHeight(), null);\n    try {\n        ImageIO.write(image, \"png\", new File(fileName));\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * Combine the KM and Num risk into one image\n *\n * @param fileName\n */\n", "repo_name": "biojava-master/", "id": 3810, "method_signature": "void savePNGKMNumRisk(String)"}, "3311": {"callee_method_names": [], "method_name": "JMatrixPanel.setMatrix", "method_implementation": "{\n    this.matrix = matrix;\n    setPreferredSize();\n}", "repo_id": "9", "comment": "/**\n * sets the distance matrix to be displayed\n *\n * @param matrix\n */\n", "repo_name": "biojava-master/", "id": 3311, "method_signature": "void setMatrix(Matrix)"}, "1605": {"callee_method_names": ["SecStrucType.compareTo", "SecStrucState.getType", "SecStrucState.setType"], "method_name": "SecStrucCalc.setSecStrucType", "method_implementation": "{\n    SecStrucState ss = getSecStrucState(pos);\n    if (type.compareTo(ss.getType()) < 0)\n        ss.setType(type);\n}", "repo_id": "9", "comment": "/**\n * Set the new type only if it has more preference than the\n * current residue SS type.\n * @param pos\n * @param type\n */\n", "repo_name": "biojava-master/", "id": 1605, "method_signature": "void setSecStrucType(int, SecStrucType)"}, "1354": {"callee_method_names": [], "method_name": "AminoAcidImpl.getCA", "method_implementation": "{\n    // note CA can also be Calcium, but that can't happen in a standard aminoacid, so this should be safe\n    return getAtom(\"CA\");\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1354, "method_signature": "Atom getCA()"}, "3445": {"callee_method_names": ["StructureViewer.setZoom"], "method_name": "StructureViewerTest.testSetZoom", "method_implementation": "{\n    if (java.awt.GraphicsEnvironment.isHeadless())\n        return;\n    int i = 0;\n    StructureViewer instance = new StructureViewerImpl();\n    instance.setZoom(i);\n    // TODO review the generated test code and remove the default call to fail.\n    // fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of setZoom method, of class StructureViewer.\n */\n", "repo_name": "biojava-master/", "id": 3445, "method_signature": "void testSetZoom()"}, "1250": {"callee_method_names": ["Structure.nrModels", "Structure.getChains", "Chain.getAtomGroups"], "method_name": "MmtfUtils.getNumGroups", "method_implementation": "{\n    int count = 0;\n    for (int i = 0; i < structure.nrModels(); i++) {\n        for (Chain chain : structure.getChains(i)) {\n            count += chain.getAtomGroups().size();\n        }\n    }\n    return count;\n}", "repo_id": "9", "comment": "/**\n * Count the total number of groups in the structure\n * @param structure the input structure\n * @return the total number of groups\n */\n", "repo_name": "biojava-master/", "id": 1250, "method_signature": "int getNumGroups(Structure)"}, "1230": {"callee_method_ids": [977], "callee_method_names": ["HashMap.values", "BioAssemblyInfo.setMacromolecularSize", "BioAssemblyInfo.getTransforms"], "method_name": "PDBBioAssemblyParser.setMacromolecularSizes", "method_implementation": "{\n    for (BioAssemblyInfo bioAssembly : transformationMap.values()) {\n        bioAssembly.setMacromolecularSize(bioAssembly.getTransforms().size());\n    }\n}", "repo_id": "9", "comment": "/**\n * Set the macromolecularSize fields of the parsed bioassemblies.\n * This can only be called after the full PDB file has been read so that\n * all the info for all bioassemblies has been gathered.\n * Note that an explicit method to set the field is necessary here because\n * in PDB files the transformations contain only the author chain ids, corresponding\n * to polymeric chains, whilst in mmCIF files the transformations\n * contain all asym ids of both polymers and non-polymers.\n */\n", "repo_name": "biojava-master/", "id": 1230, "method_signature": "void setMacromolecularSizes()"}, "2435": {"callee_method_names": ["Set<String>.add", "FeatureI.group"], "method_name": "FeatureList.groupValues", "method_implementation": "{\n    Set<String> set = new HashSet<String>();\n    for (FeatureI f : this) {\n        //enter in a set -- removes duplicates\n        set.add(f.group());\n    }\n    return set;\n}", "repo_id": "9", "comment": "/**\n * Create a collection of all unique group ids in the list, as defined\n * by the group() method of the features. For example, if the\n * features are from a GFF1 file, then each group id identifies a particular gene,\n * and this method returns a collection of all gene ids.\n *\n * @return A collection (suitable for iteration using Java's \"for\" loop) of all the\n * group ids found in this list. The order of the values is undefined; it will not match\n * the order of features in the list.\n */\n", "repo_name": "biojava-master/", "id": 2435, "method_signature": "Collection<String> groupValues()"}, "2741": {"callee_method_names": [], "method_name": "EmblRecord.getFeatureHeader", "method_implementation": "{\n    return featureHeader;\n}", "repo_id": "9", "comment": "/**\n * The FH (Feature Header) lines are present only to improve readability of\n * an entry when it is printed or displayed on a terminal screen.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2741, "method_signature": "String getFeatureHeader()"}, "801": {"callee_method_names": ["CeUserArgumentProcessor.process"], "method_name": "CeMain.main", "method_implementation": "{\n    //Responsible for creating a CeMain instance\n    CeUserArgumentProcessor processor = new CeUserArgumentProcessor();\n    processor.process(args);\n}", "repo_id": "9", "comment": "/**\n * Example Parameters:\n *\n * -pdbFilePath /tmp -autoFetch -printCE -pdb1 1cnv -pdb2 3cna\n */\n", "repo_name": "biojava-master/", "id": 801, "method_signature": "void main(String[])"}, "1663": {"callee_method_names": ["ArrayList.get"], "method_name": "SubunitCluster.length", "method_implementation": "{\n    return subunitEQR.get(representative).size();\n}", "repo_id": "9", "comment": "/**\n * @return the number of aligned residues between Subunits of the cluster\n */\n", "repo_name": "biojava-master/", "id": 1663, "method_signature": "int length()"}, "1436": {"callee_method_names": [], "method_name": "CrystalBuilder.setNumCells", "method_implementation": "{\n    this.numCells = numCells;\n}", "repo_id": "9", "comment": "/**\n * Set the number of neighboring crystal cells that will be used in the search for contacts\n * @param numCells\n */\n", "repo_name": "biojava-master/", "id": 1436, "method_signature": "void setNumCells(int)"}, "3300": {"callee_method_names": [], "method_name": "AFPChainCoordManager.getLegendPosition", "method_implementation": "{\n    int x = DEFAULT_X_SPACE;\n    int y = lineNr * DEFAULT_Y_STEP + DEFAULT_Y_SPACE;\n    y += chainNr * DEFAULT_LINE_SEPARATION;\n    Point p = new Point(x, y);\n    return p;\n}", "repo_id": "9", "comment": "/**\n * provide the coordinates for where to draw the legend for line X and if it is chain 1 or 2\n *\n * @param lineNr which line is this for\n * @param chainNr is it chain 0 or 1\n * @return get the point where to draw the legend\n */\n", "repo_name": "biojava-master/", "id": 3300, "method_signature": "Point getLegendPosition(int, int)"}, "2977": {"callee_method_names": ["CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString"], "method_name": "TwoBitArrayWorker.generateCompoundsToIndex", "method_implementation": "{\n    final CompoundSet<C> cs = getCompoundSet();\n    return Map.of(cs.getCompoundForString(\"T\"), 0, cs.getCompoundForString(\"C\"), 1, cs.getCompoundForString(\"A\"), 2, cs.getCompoundForString(\"G\"), 3, cs.getCompoundForString(\"t\"), 0, cs.getCompoundForString(\"c\"), 1, cs.getCompoundForString(\"a\"), 2, cs.getCompoundForString(\"g\"), 3);\n}", "repo_id": "9", "comment": "/**\n * Returns a Map which encodes TCAG into positions 0,1,2,3.\n */\n", "repo_name": "biojava-master/", "id": 2977, "method_signature": "Map<C,Integer> generateCompoundsToIndex()"}, "3024": {"callee_method_names": [], "method_name": "AbstractLocation.reverseSequence", "method_implementation": "{\n    if (getStrand() != Strand.NEGATIVE) {\n        return sequence;\n    }\n    Sequence<C> reversed = new ReversedSequenceView<C>(sequence);\n    // \"safe\" operation as we have tried to check this\n    if (canComplement(sequence)) {\n        Sequence<ComplementCompound> casted = (Sequence<ComplementCompound>) reversed;\n        ComplementSequenceView<ComplementCompound> complement = new ComplementSequenceView<ComplementCompound>(casted);\n        return (Sequence<C>) complement;\n    }\n    return reversed;\n}", "repo_id": "9", "comment": "/**\n * Reverses and (if possible) complements the Sequence so as to represent\n * the reverse strand (if one exists). Also does checking to see if the\n * location we are on is on the reverse strand or not.\n */\n", "repo_name": "biojava-master/", "id": 3024, "method_signature": "Sequence<C> reverseSequence(Sequence)"}, "1340": {"callee_method_names": [], "method_name": "EntityInfo.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * get the ID used by Hibernate\n *\n * @return the ID used by Hibernate\n */\n", "repo_name": "biojava-master/", "id": 1340, "method_signature": "Long getId()"}, "36": {"callee_method_names": [], "method_name": "Alignments.getAllPairsAlignments", "method_implementation": "{\n    return runPairwiseAligners(getAllPairsAligners(sequences, type, gapPenalty, subMatrix));\n}", "repo_id": "9", "comment": "/**\n * Factory method which computes a sequence alignment for all {@link Sequence} pairs in the given {@link List}.\n * This method runs the alignments in parallel by submitting all of the alignments to the shared thread pool of the\n * {@link ConcurrencyTools} utility.\n *\n * @param <S> each {@link Sequence} of an alignment pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param sequences the {@link List} of {@link Sequence}s to align\n * @param type chosen type from list of pairwise sequence alignment routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return list of sequence alignment pairs\n */\n", "repo_name": "biojava-master/", "id": 36, "method_signature": "List<SequencePair<S,C>> getAllPairsAlignments(List, PairwiseSequenceAlignerType, GapPenalty, SubstitutionMatrix)"}, "2782": {"callee_method_names": [], "method_name": "IUPACTable.getCodonCompoundSet", "method_implementation": "{\n    if (compounds == null) {\n        compounds = new AbstractCompoundSet<Codon>() {\n\n            {\n                for (Codon c : getCodons(rnaCompounds, aminoAcidCompounds)) {\n                    addCompound(c);\n                }\n            }\n        };\n    }\n    return compounds;\n}", "repo_id": "9", "comment": "/**\n * Returns the compound set of codons\n */\n", "repo_name": "biojava-master/", "id": 2782, "method_signature": "CompoundSet<Codon> getCodonCompoundSet(CompoundSet, CompoundSet)"}, "3761": {"callee_method_names": ["BufferedReader.readLine", "String.split", "ArrayList<CompactCharSequence[]>.add", "BufferedReader.readLine", "BufferedReader.close", "ArrayList<CompactCharSequence[]>.size", "ArrayList<CompactCharSequence[]>.size", "ArrayList<CompactCharSequence[]>.get", "CompactCharSequence[].length", "CompactCharSequence[].charAt", "CompactCharSequence[].length", "CompactCharSequence[].subSequence", "CompactCharSequence[].length"], "method_name": "WorkSheet.getAllValuesCompactCharSequence", "method_implementation": "{\n    // FileReader reader = new FileReader(fileName);\n    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n    ArrayList<CompactCharSequence[]> rows = new ArrayList<CompactCharSequence[]>();\n    String line = br.readLine();\n    int numcolumns = -1;\n    while (line != null) {\n        String[] d = line.split(String.valueOf(delimiter));\n        if (numcolumns == -1) {\n            numcolumns = d.length;\n        }\n        CompactCharSequence[] ccs = new CompactCharSequence[d.length];\n        for (int i = 0; i < d.length; i++) {\n            ccs[i] = new CompactCharSequence(d[i]);\n        }\n        rows.add(ccs);\n        line = br.readLine();\n    }\n    br.close();\n    // reader.close();\n    CompactCharSequence[][] data = new CompactCharSequence[rows.size()][numcolumns];\n    for (int i = 0; i < rows.size(); i++) {\n        CompactCharSequence[] row = rows.get(i);\n        for (int j = 0; j < row.length; j++) {\n            //\n            if (row[j].length() > 1 && row[j].charAt(0) == '\"') {\n                // System.out.println(row[j]);\n                if (row[j].length() > 2) {\n                    row[j] = new CompactCharSequence(row[j].subSequence(1, row[j].length() - 1).toString());\n                } else {\n                    row[j] = new CompactCharSequence(\"\");\n                }\n            }\n            if (j < row.length && j < data[0].length) {\n                data[i][j] = row[j];\n            }\n        }\n    }\n    return data;\n}", "repo_id": "9", "comment": "/**\n * All support for loading from a jar file\n *\n * @param is\n * @param delimiter\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3761, "method_signature": "CompactCharSequence[][] getAllValuesCompactCharSequence(InputStream, char)"}, "1390": {"callee_method_names": [], "method_name": "DBRef.getInsertEnd", "method_implementation": "{\n    return insertEnd;\n}", "repo_id": "9", "comment": "/**\n * Ending insertion code of the PDB sequence segment.\n *\n * @return insertEnd insertion code\n * @see #setInsertEnd(char)\n */\n", "repo_name": "biojava-master/", "id": 1390, "method_signature": "char getInsertEnd()"}, "2237": {"callee_method_names": ["String.getBytes", "MmCifFile.getFirstBlock", "IntColumn.isDefined", "IntColumn.getRowCount", "IntColumn.valueKinds", "IntColumn.stringData"], "method_name": "CifFileConsumerImplTest.specialCases", "method_implementation": "{\n    // taken from 1s32\n    String mmcifStr = \"data_\\n\" + \"loop_\\n\" + \"_struct_ref_seq_dif.align_id\\n\" + \"_struct_ref_seq_dif.pdbx_pdb_id_code\\n\" + \"_struct_ref_seq_dif.mon_id\\n\" + \"_struct_ref_seq_dif.pdbx_pdb_strand_id\\n\" + // integer field that contains '.'\n    \"_struct_ref_seq_dif.seq_num\\n\" + \"_struct_ref_seq_dif.pdbx_seq_db_name\\n\" + \"_struct_ref_seq_dif.pdbx_seq_db_accession_code\\n\" + \"_struct_ref_seq_dif.db_mon_id\\n\" + \"_struct_ref_seq_dif.pdbx_seq_db_seq_num\\n\" + \"_struct_ref_seq_dif.details\\n\" + \"_struct_ref_seq_dif.pdbx_auth_seq_num\\n\" + \"_struct_ref_seq_dif.pdbx_pdb_ins_code\\n\" + \"_struct_ref_seq_dif.pdbx_ordinal\\n\" + \"1 1S32 . A . GB  30268544 MET 1 'INTIATING METHIONINE' ? ? 1\\n\" + \"2 1S32 . E . GB  30268544 MET 1 'INTIATING METHIONINE' ? ? 2\\n\" + \"3 1S32 . B . UNP P02304   MET 0 'INTIATING METHIONINE' ? ? 3\\n\" + \"4 1S32 . F . UNP P02304   MET 0 'INTIATING METHIONINE' ? ? 4\\n\" + \"5 1S32 . C . GB  30268540 MET 1 'INTIATING METHIONINE' ? ? 5\\n\" + \"6 1S32 . G . GB  30268540 MET 1 'INTIATING METHIONINE' ? ? 6\\n\" + \"7 1S32 . D . GB  30268542 MET 1 'INTIATING METHIONINE' ? ? 7\\n\" + \"8 1S32 . H . GB  30268542 MET 1 'INTIATING METHIONINE' ? ? 8\\n\" + \"#\";\n    MmCifFile cifFile = CifIO.readFromInputStream(new ByteArrayInputStream(mmcifStr.getBytes())).as(StandardSchemata.MMCIF);\n    IntColumn column = cifFile.getFirstBlock().getStructRefSeqDif().getSeqNum();\n    assertNotNull(column);\n    assertTrue(column.isDefined());\n    assertEquals(8, column.getRowCount());\n    column.valueKinds().forEach(vk -> assertEquals(ValueKind.NOT_PRESENT, vk));\n    column.stringData().forEach(sd -> assertTrue(sd.isEmpty()));\n}", "repo_id": "9", "comment": "/**\n * This tests for cases where dots appear in integer fields. Unusual but it happens in some PDB entries like 1s32.\n * See issue <a href=\"https://github.com/biojava/biojava/issues/368\">...</a>\n */\n", "repo_name": "biojava-master/", "id": 2237, "method_signature": "void specialCases()"}, "3184": {"callee_method_names": [], "method_name": "WindowedSequence.getBackingSequence", "method_implementation": "{\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Access the sequence which backs this window\n */\n", "repo_name": "biojava-master/", "id": 3184, "method_signature": "Sequence<C> getBackingSequence()"}, "979": {"callee_method_names": ["Atom.setGroup", "List<Atom>.add", "Atom.getCoordsAsPoint3d", "Map<String, Atom>.put", "Atom.getName", "Atom.getAltLoc", "Logger.warn", "Atom.getName", "Atom.getPDBserial"], "method_name": "HetatomImpl.addAtom", "method_implementation": "{\n    atom.setGroup(this);\n    atoms.add(atom);\n    // TODO this check is useless, coords are always !=null since they are initialized to 0,0,0 in AtomImpl constructor. We need to review this - JD 2016-09-14\n    if (atom.getCoordsAsPoint3d() != null) {\n        // we have got coordinates!\n        setPDBFlag(true);\n    }\n    if (atomNameLookup != null) {\n        Atom existingAtom = atomNameLookup.put(atom.getName(), atom);\n        // if an atom with same name is added to the group that has to be some kind of problem,\n        // we need to warn properly\n        if (existingAtom != null) {\n            String altLocStr = \"\";\n            char altLoc = atom.getAltLoc();\n            if (altLoc != ' ')\n                altLocStr = \"(alt loc '\" + altLoc + \"')\";\n            logger.warn(\"An atom with name \" + atom.getName() + \" \" + altLocStr + \" is already present in group: \" + this.toString() + \". The atom with serial \" + existingAtom.getPDBserial() + \" will be ignored in look-ups.\");\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 979, "method_signature": "void addAtom(Atom)"}, "1940": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getMaxRmsd", "method_implementation": "{\n    return maxRmsd;\n}", "repo_id": "9", "comment": "/**\n * @return the maxRmsd\n */\n", "repo_name": "biojava-master/", "id": 1940, "method_signature": "double getMaxRmsd()"}, "3405": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getPolyhedron", "method_implementation": "{\n    return polyhedron;\n}", "repo_id": "9", "comment": "/**\n * @return the polyhedron\n */\n", "repo_name": "biojava-master/", "id": 3405, "method_signature": "Polyhedron getPolyhedron()"}, "1840": {"callee_method_names": [], "method_name": "StructureIO.getBiologicalAssemblies", "method_implementation": "{\n    return getBiologicalAssemblies(pdbId, AtomCache.DEFAULT_BIOASSEMBLY_STYLE);\n}", "repo_id": "9", "comment": "/**\n * Returns all biological assemblies for the given PDB id,\n * using multiModel={@value AtomCache#DEFAULT_BIOASSEMBLY_STYLE}\n * <p>\n * If only one biological assembly is required use {@link #getBiologicalAssembly(String)} or {@link #getBiologicalAssembly(String, int)} instead.\n * @param pdbId\n * @return\n * @throws IOException\n * @throws StructureException\n * @since 5.0\n */\n", "repo_name": "biojava-master/", "id": 1840, "method_signature": "List<Structure> getBiologicalAssemblies(String)"}, "2788": {"callee_method_names": ["ArrayListProxySequenceReader<NucleotideCompound>.setCompoundSet", "ArrayListProxySequenceReader<NucleotideCompound>.setContents"], "method_name": "DNASequenceCreator.getSequence", "method_implementation": "{\n    ArrayListProxySequenceReader<NucleotideCompound> store = new ArrayListProxySequenceReader<NucleotideCompound>();\n    store.setCompoundSet(compoundSet);\n    store.setContents(list);\n    return new DNASequence(store);\n}", "repo_id": "9", "comment": "/**\n * @param list\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2788, "method_signature": "AbstractSequence<NucleotideCompound> getSequence(List)"}, "2036": {"callee_method_names": [], "method_name": "Icosahedron.setMidRadius", "method_implementation": "{\n    double side = getSideLengthFromMiddleRadius(radius);\n    this.circumscribedRadius = getCircumscribedRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Sets the radius of radius of a sphere, that is tangent to each\n * of the icosahedron's edges\n * @param midRadius the midRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2036, "method_signature": "void setMidRadius(double)"}, "2819": {"callee_method_names": [], "method_name": "IOUtils.getPDBCharacter", "method_implementation": "{\n    String s = String.valueOf(c);\n    return getPDBString(web, c1, c2, similar, s, s, s, s);\n}", "repo_id": "9", "comment": "/**\n * Creates formatted String for a single character of PDB output\n *\n * @param web true for HTML display\n * @param c1 character in first sequence\n * @param c2 character in second sequence\n * @param similar true if c1 and c2 are considered similar compounds\n * @param c character to display\n * @return formatted String\n */\n", "repo_name": "biojava-master/", "id": 2819, "method_signature": "String getPDBCharacter(boolean, char, char, boolean, char)"}, "3416": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorH.showAxes", "method_implementation": "{\n    return \"draw axes* on;\";\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script to show axes\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3416, "method_signature": "String showAxes()"}, "2780": {"callee_method_names": [], "method_name": "IUPACTable.isStart", "method_implementation": "{\n    if (this.codons.isEmpty()) {\n        throw new IllegalStateException(\"Codons are empty; please request getCodons() fist before asking this\");\n    }\n    for (Codon codon : codons) {\n        //Only check if the codon was a start codon and then ask if the compound was encoded by it\n        if (codon.isStart()) {\n            if (codon.getAminoAcid().equalsIgnoreCase(compound)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Returns true if the given compound was a start codon in this\n * codon table. This will report true if the compound could ever have\n * been a start codon.\n *\n * @throws IllegalStateException Thrown if\n * {@link #getCodons(CompoundSet, CompoundSet)} was not called first.\n */\n", "repo_name": "biojava-master/", "id": 2780, "method_signature": "boolean isStart(AminoAcidCompound)"}, "907": {"callee_method_names": [], "method_name": "StructureInterfaceList.setChainOrigNamesMap", "method_implementation": "{\n    this.chainOrigNamesMap = chainOrigNamesMap;\n}", "repo_id": "9", "comment": "/**\n * Sets a map with mapping from NCS chain names to original chain names.\n * Necessary when {@link #addNcsEquivalent(StructureInterface, StructureInterface)} is used and NCS equivalent\n * interfaces exist in this list and their names need mapping when setting ASAs.\n * @param chainOrigNamesMap a map of NCS chain name to original chain name\n */\n", "repo_name": "biojava-master/", "id": 907, "method_signature": "void setChainOrigNamesMap(Map)"}, "1473": {"callee_method_names": [], "method_name": "CrystalCell.getMInv", "method_implementation": "{\n    if (Minv != null) {\n        return Minv;\n    }\n    // see eq. 2.30 Giacovazzo\n    Minv = new Matrix3d(this.a, 0, 0, this.b * Math.cos(gammaRad), this.b * Math.sin(gammaRad), 0, this.c * Math.cos(betaRad), -this.c * Math.sin(betaRad) * getCosAlphaStar(), 1.0 / getCstar());\n    return Minv;\n}", "repo_id": "9", "comment": "/**\n * Returns the change of basis (crystal to orthonormal) transform matrix, that is\n * M inverse in the notation of Giacovazzo.\n * Using the PDB axes convention\n * (CCP4 uses NCODE identifiers to distinguish the different conventions, the PDB one is called NCODE=1)\n * The matrix is only calculated upon first call of this method, thereafter it is cached.\n * See \"Fundamentals of Crystallography\" C. Giacovazzo, section 2.5 (eq 2.30)\n *\n * The non-standard orthogonalisation codes (NCODE for ccp4) are flagged in REMARK 285 after 2011's remediation\n * with text: \"THE ENTRY COORDINATES ARE NOT PRESENTED IN THE STANDARD CRYSTAL FRAME\". There were only 148 PDB\n * entries with non-standard code in 2011. See:\n * http://www.wwpdb.org/documentation/2011remediation_overview-061711.pdf\n * The SCALE1,2,3 records contain the correct transformation matrix (what Giacovazzo calls M matrix).\n * In those cases if we calculate the M matrix following Giacovazzo's equations here, we get an entirely wrong one.\n * Examples of PDB with non-standard orthogonalisation are 1bab and 1bbb.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1473, "method_signature": "Matrix3d getMInv()"}, "1922": {"callee_method_names": [], "method_name": "HelixLayers.setSymmetryDeviation", "method_implementation": "{\n    this.symmetryDeviation = symmetryDeviation;\n}", "repo_id": "9", "comment": "/**\n * @param symmetryDeviation the symmetryDeviation to set\n */\n", "repo_name": "biojava-master/", "id": 1922, "method_signature": "void setSymmetryDeviation(double)"}, "785": {"callee_method_ids": [487, 504, 506, 505], "callee_method_names": ["AFPChain.getCa2Length", "AFPChain.getBlockNum", "AFPChain.setSequentialAlignment", "AFPChain.setDistanceMatrix", "AFPChain.getDistanceMatrix", "AFPChain.setDisTable2", "AFPChain.getDisTable2"], "method_name": "OptimalCECPMain.permuteAFPChain", "method_implementation": "{\n    int ca2len = afpChain.getCa2Length();\n    //fix up cp to be positive\n    if (cp == 0) {\n        return;\n    }\n    if (cp < 0) {\n        cp = ca2len + cp;\n    }\n    if (cp < 0 || cp >= ca2len) {\n        throw new ArrayIndexOutOfBoundsException(\"Permutation point (\" + cp + \") must be between -ca2.length and ca2.length-1\");\n    }\n    // Fix up optAln\n    permuteOptAln(afpChain, cp);\n    if (afpChain.getBlockNum() > 1)\n        afpChain.setSequentialAlignment(false);\n    // fix up matrices\n    // ca1 corresponds to row indices, while ca2 corresponds to column indices.\n    afpChain.setDistanceMatrix(permuteMatrix(afpChain.getDistanceMatrix(), 0, -cp));\n    // this is square, so permute both\n    afpChain.setDisTable2(permuteMatrix(afpChain.getDisTable2(), -cp, -cp));\n    //TODO fix up other AFP parameters?\n}", "repo_id": "9", "comment": "/**\n * Permute the second protein of afpChain by the specified number of residues.\n * @param afpChain Input alignment\n * @param cp Amount leftwards (or rightward, if negative) to shift the\n * @return A new alignment equivalent to afpChain after the permutations\n */\n", "repo_name": "biojava-master/", "id": 785, "method_signature": "void permuteAFPChain(AFPChain, int)"}, "2816": {"callee_method_names": ["List<S>.get", "StringBuilder.append", "S.getLength", "S.getCompoundSet", "S.getLength", "StringBuilder.append", "S.getAccession", "StringBuilder.append", "StringBuilder.toString"], "method_name": "IOUtils.getGCGHeader", "method_implementation": "{\n    StringBuilder header = new StringBuilder();\n    S s1 = sequences.get(0);\n    header.append(String.format(\"MSA from BioJava%n%n MSF: %d  Type: %s  Check: %d ..%n%n\", s1.getLength(), getGCGType(s1.getCompoundSet()), getGCGChecksum(sequences)));\n    String format = \" Name: \" + getIDFormat(sequences) + \" Len: \" + s1.getLength() + \"  Check: %4d  Weight: 1.0%n\";\n    for (S as : sequences) {\n        header.append(String.format(format, as.getAccession(), getGCGChecksum(as)));\n        // TODO show weights in MSF header\n    }\n    header.append(String.format(\"%n//%n%n\"));\n    // TODO? convert gap characters to '.'\n    return header.toString();\n}", "repo_id": "9", "comment": "/**\n * Assembles a GCG file header\n *\n * @param sequences list of sequences\n * @return GCG header\n */\n", "repo_name": "biojava-master/", "id": 2816, "method_signature": "String getGCGHeader(List)"}, "1961": {"callee_method_names": ["Matrix4d.getRotationScale"], "method_name": "HelixAxisAligner.getRotationMatrix", "method_implementation": "{\n    run();\n    Matrix3d m = new Matrix3d();\n    transformationMatrix.getRotationScale(m);\n    return m;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getRotationMatrix()\n\t */\n", "repo_name": "biojava-master/", "id": 1961, "method_signature": "Matrix3d getRotationMatrix()"}, "1967": {"callee_method_names": [], "method_name": "HelixAxisAligner.getRadius", "method_implementation": "{\n    run();\n    return xzRadiusMax;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getXYRadius()\n\t */\n", "repo_name": "biojava-master/", "id": 1967, "method_signature": "double getRadius()"}, "1307": {"callee_method_names": [], "method_name": "FastaAFPChainConverter.fastaStringToAfpChain", "method_implementation": "{\n    ProteinSequence seq1 = new ProteinSequence(sequence1);\n    ProteinSequence seq2 = new ProteinSequence(sequence2);\n    return fastaToAfpChain(seq1, seq2, structure1, structure2);\n}", "repo_id": "9", "comment": "/**\n * Returns an AFPChain corresponding to the alignment between {@code structure1} and {@code structure2}, which is given by the gapped protein sequences {@code sequence1} and {@code sequence2}. The\n * sequences need not correspond to the entire structures, since local alignment is performed to match the sequences to structures.\n * @throws StructureException\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 1307, "method_signature": "AFPChain fastaStringToAfpChain(String, String, Structure, Structure)"}, "1673": {"callee_method_names": [], "method_name": "Subunit.getName", "method_implementation": "{\n    return name;\n}", "repo_id": "9", "comment": "/**\n * The Name of a Subunit is a free-text field, user defined.\n *\n * @return the Subunit name\n */\n", "repo_name": "biojava-master/", "id": 1673, "method_signature": "String getName()"}, "3839": {"callee_method_names": [], "method_name": "Utils.roundToDecimals", "method_implementation": "{\n    if (c < 0)\n        return d;\n    double p = Math.pow(10, c);\n    d = d * p;\n    double tmp = Math.round(d);\n    return tmp / p;\n}", "repo_id": "9", "comment": "/**\n * Returns a value with the desired number of decimal places.\n *\n * @param d\n * \t\tvalue to round\n * @param c\n * \t\tnumber of decimal places desired.\n * \t\tMust be greater or equal to zero, otherwise, the given value d would be returned without any modification.\n * @return\n * \t\ta value with the given number of decimal places.\n */\n", "repo_name": "biojava-master/", "id": 3839, "method_signature": "double roundToDecimals(double, int)"}, "566": {"callee_method_names": ["Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Atom.setCoords"], "method_name": "RotationAxis.calculateRotationalAxis", "method_implementation": "{\n    // Calculate magnitude of rotationAxis components, but not signs\n    double sum = 0;\n    double[] rotAx = new double[3];\n    for (int i = 0; i < 3; i++) {\n        rotAx[i] = Math.sqrt(rotation.get(i, i) - c);\n        sum += rotAx[i] * rotAx[i];\n    }\n    for (int i = 0; i < 3; i++) {\n        rotAx[i] /= Math.sqrt(sum);\n    }\n    // Now determine signs\n    //=2u[0]*sin(theta)\n    double d0 = rotation.get(2, 1) - rotation.get(1, 2);\n    //=2u[1]*sin(theta)\n    double d1 = rotation.get(0, 2) - rotation.get(2, 0);\n    //=2u[2]*sin(theta)\n    double d2 = rotation.get(1, 0) - rotation.get(0, 1);\n    //=2*u[1]*u[2]*(1-cos(theta))\n    double s12 = rotation.get(2, 1) + rotation.get(1, 2);\n    //=2*u[0]*u[2]*(1-cos(theta))\n    double s02 = rotation.get(0, 2) + rotation.get(2, 0);\n    //=2*u[0]*u[1]*(1-cos(theta))\n    double s01 = rotation.get(1, 0) + rotation.get(0, 1);\n    //Only use biggest d for the sign directly, for numerical stability around 180deg\n    if (Math.abs(d0) < Math.abs(d1)) {\n        // not d0\n        if (Math.abs(d1) < Math.abs(d2)) {\n            //d2\n            if (d2 >= 0) {\n                //u[2] positive\n                if (s02 < 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 < 0)\n                    rotAx[1] = -rotAx[1];\n            } else {\n                //u[2] negative\n                rotAx[2] = -rotAx[2];\n                if (s02 >= 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 >= 0)\n                    rotAx[1] = -rotAx[1];\n            }\n        } else {\n            //d1\n            if (d1 >= 0) {\n                //u[1] positive\n                if (s01 < 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 < 0)\n                    rotAx[2] = -rotAx[2];\n            } else {\n                //u[1] negative\n                rotAx[1] = -rotAx[1];\n                if (s01 >= 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 >= 0)\n                    rotAx[2] = -rotAx[2];\n            }\n        }\n    } else {\n        // not d1\n        if (Math.abs(d0) < Math.abs(d2)) {\n            //d2\n            if (d2 >= 0) {\n                //u[2] positive\n                if (s02 < 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 < 0)\n                    rotAx[1] = -rotAx[1];\n            } else {\n                //u[2] negative\n                rotAx[2] = -rotAx[2];\n                if (s02 >= 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 >= 0)\n                    rotAx[1] = -rotAx[1];\n            }\n        } else {\n            //d0\n            if (d0 >= 0) {\n                //u[0] positive\n                if (s01 < 0)\n                    rotAx[1] = -rotAx[1];\n                if (s02 < 0)\n                    rotAx[2] = -rotAx[2];\n            } else {\n                //u[0] negative\n                rotAx[0] = -rotAx[0];\n                if (s01 >= 0)\n                    rotAx[1] = -rotAx[1];\n                if (s02 >= 0)\n                    rotAx[2] = -rotAx[2];\n            }\n        }\n    }\n    rotationAxis = new AtomImpl();\n    rotationAxis.setCoords(rotAx);\n    // Calculate screw = (rotationAxis dot translation)*u\n    double dotProduct = Calc.scalarProduct(rotationAxis, translation);\n    screwTranslation = Calc.scale(rotationAxis, dotProduct);\n    otherTranslation = Calc.subtract(translation, screwTranslation);\n    Atom hypot = Calc.vectorProduct(otherTranslation, rotationAxis);\n    Calc.scaleEquals(hypot, .5 / Math.tan(theta / 2.0));\n    // Calculate rotation axis position\n    rotationPos = Calc.scaleAdd(.5, otherTranslation, hypot);\n}", "repo_id": "9", "comment": "/**\n * Calculate the rotation axis for the normal case, where there is a\n * significant rotation angle\n * @param rotation\n * @param translation\n * @param c\n */\n", "repo_name": "biojava-master/", "id": 566, "method_signature": "void calculateRotationalAxis(Matrix, Atom, double)"}, "1474": {"callee_method_names": [], "method_name": "CrystalCell.getAstar", "method_implementation": "{\n    return (this.b * this.c * Math.sin(alphaRad)) / getVolume();\n}", "repo_id": "9", "comment": "// see Table 2.1 of chapter 2 of Giacovazzo\n", "repo_name": "biojava-master/", "id": 1474, "method_signature": "double getAstar()"}, "2718": {"callee_method_names": ["Reader.ready", "Reader.ready"], "method_name": "BufferedReaderBytesRead.ready", "method_implementation": "{\n    synchronized (lock) {\n        ensureOpen();\n        /*\n\t\t\t * If newline needs to be skipped and the next char to be read\n\t\t\t * is a newline character, then just skip it right away.\n\t\t\t */\n        if (skipLF) {\n            /* Note that in.ready() will return true if and only if the next\n\t\t\t\t * read on the stream will not block.\n\t\t\t\t */\n            if (nextChar >= nChars && in.ready()) {\n                fill();\n            }\n            if (nextChar < nChars) {\n                if (cb[nextChar] == '\\n') {\n                    nextChar++;\n                }\n                skipLF = false;\n            }\n        }\n        return (nextChar < nChars) || in.ready();\n    }\n}", "repo_id": "9", "comment": "/**\n * Tells whether this stream is ready to be read.  A buffered character\n * stream is ready if the buffer is not empty, or if the underlying\n * character stream is ready.\n *\n * @exception  IOException  If an I/O error occurs\n */\n", "repo_name": "biojava-master/", "id": 2718, "method_signature": "boolean ready()"}, "2660": {"callee_method_names": [], "method_name": "Builder.table", "method_implementation": "{\n    table = IUPACParser.getInstance().getTable(name);\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Uses the static instance of {@link IUPACParser} to find instances of\n * {@link IUPACTable}s by its String name\n */\n", "repo_name": "biojava-master/", "id": 2660, "method_signature": "Builder table(String)"}, "3320": {"callee_method_names": ["JList.getSelectionBackground", "JList.getSelectionForeground", "JList.getBackground", "JList.getForeground", "Map<String, ContinuousColorMapper>.get", "GradientPanel.setPreferredSize", "JPanel.removeAll", "JPanel.add", "JLabel.setText"], "method_name": "ScaleableMatrixPanel.getListCellRendererComponent", "method_implementation": "{\n    //Get the selected index. (The index param isn't\n    //always valid, so just use the value.)\n    String gradientLabel = (String) value;\n    if (isSelected) {\n        setBackground(list.getSelectionBackground());\n        setForeground(list.getSelectionForeground());\n    } else {\n        setBackground(list.getBackground());\n        setForeground(list.getForeground());\n    }\n    //Set the icon and text.  If icon was null, say so.\n    GradientPanel gradPanel = new GradientPanel(gradients.get(gradientLabel), min, max);\n    gradPanel.setPreferredSize(new Dimension(100, 20));\n    //gradPanel.setBorder(BorderFactory.createLineBorder(Color.cyan));\n    gradientContainer.removeAll();\n    gradientContainer.add(gradPanel, BorderLayout.CENTER);\n    title.setText(gradientLabel);\n    this.validate();\n    return this;\n}", "repo_id": "9", "comment": "/*\n\t\t * This method finds the image and text corresponding\n\t\t * to the selected value and returns the label, set up\n\t\t * to display the text and image.\n\t\t */\n", "repo_name": "biojava-master/", "id": 3320, "method_signature": "Component getListCellRendererComponent(JList, Object, int, boolean, boolean)"}, "2675": {"callee_method_names": [], "method_name": "MultipleSequenceAlignment.getLength", "method_implementation": "{\n    return length;\n}", "repo_id": "9", "comment": "/**\n * Get the length of the MSA where it is assumed that\n * all sequence position\n * @return length of MSA\n */\n", "repo_name": "biojava-master/", "id": 2675, "method_signature": "int getLength()"}, "3076": {"callee_method_ids": [3166], "callee_method_names": ["TranscriptSequence.getStrand"], "method_name": "CDSSequence.getStrand", "method_implementation": "{\n    return parentTranscriptSequence.getStrand();\n}", "repo_id": "9", "comment": "/**\n * @return get the strand\n */\n", "repo_name": "biojava-master/", "id": 3076, "method_signature": "Strand getStrand()"}, "3824": {"callee_method_names": [], "method_name": "MetaDataInfo.getDiscreteValues", "method_implementation": "{\n    return discreteValues;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3824, "method_signature": "ArrayList<String> getDiscreteValues()"}, "2045": {"callee_method_ids": [487], "callee_method_names": ["AFPChain.getAlgorithmName", "MultipleAlignmentEnsemble.setAtomArrays", "MultipleAlignmentEnsemble.getStructureIdentifiers", "MultipleAlignmentEnsemble.getStructureIdentifiers", "MultipleAlignmentEnsemble.getStructureIdentifiers", "Atom[].getGroup", "MultipleAlignmentEnsemble.setStructureIdentifiers", "Block.setAlignRes", "AFPChain.getBlockNum", "MultipleAlignmentEnsemble.getMultipleAlignment", "Block.getAlignRes", "MultipleAlignmentEnsemble.getStructureIdentifiers", "MultipleAlignmentEnsemble.getAtomArrays", "MultipleAlignmentEnsemble.getMultipleAlignments", "MultipleAlignment.setEnsemble", "CoreSuperimposer.superimpose"], "method_name": "SymmetryTools.fromAFP", "method_implementation": "{\n    if (!symm.getAlgorithmName().contains(\"symm\")) {\n        throw new IllegalArgumentException(\"The input alignment is not a symmetry alignment.\");\n    }\n    MultipleAlignmentEnsemble e = new MultipleAlignmentEnsembleImpl(symm, atoms, atoms, false);\n    e.setAtomArrays(new ArrayList<Atom[]>());\n    StructureIdentifier name = null;\n    if (e.getStructureIdentifiers() != null) {\n        if (!e.getStructureIdentifiers().isEmpty())\n            name = e.getStructureIdentifiers().get(0);\n    } else\n        name = atoms[0].getGroup().getChain().getStructure().getStructureIdentifier();\n    e.setStructureIdentifiers(new ArrayList<StructureIdentifier>());\n    MultipleAlignment result = new MultipleAlignmentImpl();\n    BlockSet bs = new BlockSetImpl(result);\n    Block b = new BlockImpl(bs);\n    b.setAlignRes(new ArrayList<List<Integer>>());\n    int order = symm.getBlockNum();\n    for (int su = 0; su < order; su++) {\n        List<Integer> residues = e.getMultipleAlignment(0).getBlock(su).getAlignRes().get(0);\n        b.getAlignRes().add(residues);\n        e.getStructureIdentifiers().add(name);\n        e.getAtomArrays().add(atoms);\n    }\n    e.getMultipleAlignments().set(0, result);\n    result.setEnsemble(e);\n    CoreSuperimposer imposer = new CoreSuperimposer();\n    imposer.superimpose(result);\n    updateSymmetryScores(result);\n    return result;\n}", "repo_id": "9", "comment": "/**\n * Converts a refined symmetry AFPChain alignment into the standard\n * representation of symmetry in a MultipleAlignment, that contains the\n * entire Atom array of the strcuture and the symmetric repeats are orgaized\n * in different rows in a single Block.\n *\n * @param symm\n *            AFPChain created with a symmetry algorithm and refined\n * @param atoms\n *            Atom array of the entire structure\n * @return MultipleAlignment format of the symmetry\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2045, "method_signature": "MultipleAlignment fromAFP(AFPChain, Atom[])"}, "3028": {"callee_method_names": ["List<Location>.add", "List<Location>.add", "List<Location>.add"], "method_name": "Location.circularLocation", "method_implementation": "{\n    int min = Math.min(start, end);\n    int max = Math.max(start, end);\n    //Tells us we're dealing with something that's not _right_\n    boolean isReverse = (min != start);\n    if (min > length) {\n        throw new IllegalArgumentException(\"Cannot process a \" + \"location whose lowest coordinate is less than \" + \"the given length \" + length);\n    }\n    //If max positon was less than length the return a normal location\n    if (max <= length) {\n        return location(start, end, strand, length);\n    }\n    //Fine for forward coords (i..e start < end)\n    int modStart = modulateCircularIndex(start, length);\n    int modEnd = modulateCircularIndex(end, length);\n    int numberOfPasses = completeCircularPasses(Math.max(start, end), length);\n    if (isReverse) {\n        int reversedModStart = new SimplePoint(modStart).reverse(length).getPosition();\n        int reversedModEnd = new SimplePoint(modEnd).reverse(length).getPosition();\n        modStart = reversedModStart;\n        modEnd = reversedModEnd;\n        start = reversedModStart;\n        //+1 to number of passes to skip the run encoded by the start\n        end = (length * (numberOfPasses + 1)) + modEnd;\n    }\n    List<Location> locations = new ArrayList<Location>();\n    locations.add(new SimpleLocation(modStart, length, strand));\n    for (int i = 0; i < numberOfPasses; i++) {\n        locations.add(new SimpleLocation(1, length, strand));\n    }\n    locations.add(new SimpleLocation(1, modEnd, strand));\n    return new SimpleLocation(new SimplePoint(start), new SimplePoint(end), strand, true, false, locations);\n}", "repo_id": "9", "comment": "/**\n * Converts a location which defines the outer bounds of a circular\n * location and splits it into the required portions. Unlike any\n * other location builder this allows you to express your input\n * location on the reverse strand\n *\n * @param location The location which currently expresses the outer\n * bounds of a circular location.\n * @param length The length of the circular genomic unit\n * @return The circular location; can optionally return a normal non\n * circular location if the one you give is within the bounds of\n * the length\n */\n", "repo_name": "biojava-master/", "id": 3028, "method_signature": "Location circularLocation(int, int, Strand, int)"}, "398": {"callee_method_names": [], "method_name": "GroupIterator.getStructure", "method_implementation": "{\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * needed to do a copy of iterator ...\n */\n", "repo_name": "biojava-master/", "id": 398, "method_signature": "Structure getStructure()"}, "881": {"callee_method_names": ["Pair<CrystalTransform>.getSecond"], "method_name": "StructureInterface.isInfinite", "method_implementation": "{\n    return ((isSymRelated() && transforms.getSecond().getTransformType().isInfinite()));\n}", "repo_id": "9", "comment": "/**\n * Returns true if the transformation applied to the second molecule of this interface\n * has an infinite character (pure translation or screw rotation)\n * and both molecules of the interface have the same asymmetric unit identifier (chain id): in such cases the\n * interface would lead to infinite fiber-like (linear or helical) assemblies\n * @return\n */\n", "repo_name": "biojava-master/", "id": 881, "method_signature": "boolean isInfinite()"}, "889": {"callee_method_ids": [840, 842, 840, 842], "callee_method_names": ["Map<ResidueNumber, GroupAsa>.values", "GroupAsa.getAsaU", "GroupAsa.getBsa", "List<Group>.add", "GroupAsa.getGroup", "Map<ResidueNumber, GroupAsa>.values", "GroupAsa.getAsaU", "GroupAsa.getBsa", "List<Group>.add", "GroupAsa.getGroup"], "method_name": "StructureInterface.getInterfacingResidues", "method_implementation": "{\n    List<Group> interf1 = new ArrayList<>();\n    List<Group> interf2 = new ArrayList<>();\n    for (GroupAsa groupAsa : groupAsas1.values()) {\n        if (groupAsa.getAsaU() > minAsaForSurface && groupAsa.getBsa() > 0) {\n            interf1.add(groupAsa.getGroup());\n        }\n    }\n    for (GroupAsa groupAsa : groupAsas2.values()) {\n        if (groupAsa.getAsaU() > minAsaForSurface && groupAsa.getBsa() > 0) {\n            interf2.add(groupAsa.getGroup());\n        }\n    }\n    return new Pair<>(interf1, interf2);\n}", "repo_id": "9", "comment": "/**\n * Returns the residues belonging to the interface, i.e. the residues\n * at the surface with BSA>0\n * @param minAsaForSurface the minimum ASA to consider a residue on the surface\n * @return\n */\n", "repo_name": "biojava-master/", "id": 889, "method_signature": "Pair<List<Group>> getInterfacingResidues(double)"}, "3297": {"callee_method_names": [], "method_name": "AFPChainCoordManager.getSeqPos", "method_implementation": "{\n    int x = p.x - DEFAULT_X_SPACE - DEFAULT_LEGEND_SIZE;\n    int y = p.y - DEFAULT_Y_SPACE;\n    y -= (DEFAULT_LINE_SEPARATION * aligSeq) - DEFAULT_CHAR_SIZE;\n    int lineNr = y / DEFAULT_Y_STEP;\n    //System.out.println(\"line : \" + lineNr);\n    int linePos = x / DEFAULT_CHAR_SIZE;\n    //System.out.println(\"line : \" + lineNr + \" pos in line: \" + linePos);\n    return lineNr * DEFAULT_LINE_LENGTH + linePos;\n}", "repo_id": "9", "comment": "/**\n * Convert from a X position in the JPanel to alignment position\n *\n * @param aligSeq sequence 0 or 1\n * @param p point on panel\n * @return the sequence position for a point on the Panel\n */\n", "repo_name": "biojava-master/", "id": 3297, "method_signature": "int getSeqPos(int, Point)"}, "3570": {"callee_method_names": [], "method_name": "Matrix.sqrt", "method_implementation": "{\n    double[] d = new double[A.length];\n    for (int i = 0; i < d.length; i++) {\n        d[i] = Math.sqrt(A[i]);\n    }\n    return d;\n}", "repo_id": "9", "comment": "/**\n * @param A\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3570, "method_signature": "double[] sqrt(double[])"}, "132": {"callee_method_names": ["ScaledSubstitutionMatrix.getScale", "AminoAcidCompoundSet.getCompoundForString", "AminoAcidCompoundSet.getCompoundForString", "AminoAcidCompoundSet.getCompoundForString", "AminoAcidCompoundSet.getCompoundForString", "SubstitutionMatrix<AminoAcidCompound>.getValue", "SubstitutionMatrix<AminoAcidCompound>.getValue", "SubstitutionMatrix<AminoAcidCompound>.getValue", "SubstitutionMatrix<AminoAcidCompound>.getValue", "SubstitutionMatrix<AminoAcidCompound>.getValue"], "method_name": "TestAAINDEXLoading.testSDMmatrix", "method_implementation": "{\n    String matrixName = \"PRLA000101\";\n    SubstitutionMatrix<AminoAcidCompound> sdm = SubstitutionMatrixHelper.getMatrixFromAAINDEX(matrixName);\n    int scale = 1;\n    if (sdm instanceof ScaledSubstitutionMatrix) {\n        ScaledSubstitutionMatrix scaledSDM = (ScaledSubstitutionMatrix) sdm;\n        scale = scaledSDM.getScale();\n        Assert.assertEquals(100, scale);\n    }\n    AminoAcidCompoundSet aas = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    AminoAcidCompound v = aas.getCompoundForString(\"V\");\n    AminoAcidCompound w = aas.getCompoundForString(\"W\");\n    AminoAcidCompound r = aas.getCompoundForString(\"R\");\n    AminoAcidCompound n = aas.getCompoundForString(\"N\");\n    short rn = sdm.getValue(r, n);\n    Assert.assertEquals(60, rn);\n    short nr = sdm.getValue(n, r);\n    Assert.assertEquals(rn, nr);\n    short vv = sdm.getValue(v, v);\n    Assert.assertEquals(205, vv);\n    short vw = sdm.getValue(v, w);\n    Assert.assertEquals(-109, vw);\n    short wv = sdm.getValue(w, v);\n    Assert.assertEquals(vw, wv);\n}", "repo_id": "9", "comment": "/**\n *  M rows = ARNDCQEGHILKMFPSTWYV, cols = ARNDCQEGHILKMFPSTWYV\n *\n *    A\t\tR\t\tN\t\tD\t\tC\t\tQ\t\tE\t\tG\t\tH\t\tI\t\tL\t\tK\t\tM\t\tF\t\tP\t\tS\t\tT\t\tW\t\tY\t\tV\n * A    2.09\n * R   -0.50    2.87\n * N   -0.57    0.60    3.60\n * D   -0.73    0.13    1.78    4.02\n * C    0.33   -1.30   -2.08   -2.51    6.99\n * Q   -0.75    0.13    0.33    0.34   -0.83    2.60\n * E   -0.12    0.99   -0.16    1.20   -1.97    1.23    2.97\n * G    0.27   -0.96    0.79   -1.20   -2.11   -0.12   -0.41    4.36\n * H   -1.42    0.54    0.76   -0.01   -1.50   -0.46   -0.62   -0.40    5.89\n * I   -0.97   -1.40   -2.43   -2.77    0.13   -1.47   -1.81   -2.93   -1.76    2.76\n * L   -0.39   -1.19   -2.10   -2.65   -0.31   -1.49   -2.11   -1.98   -0.93    1.56    2.43\n * K   -0.38    1.42    0.83    0.66   -2.19    0.92    1.11   -0.71    0.31   -1.81   -1.96    2.91\n * M   -0.04   -0.63   -2.01   -2.58    1.04   -0.13   -1.86   -1.86   -1.04    0.99    1.61   -1.62    3.75\n * F   -0.76   -1.40   -2.25   -2.19    1.13   -2.31   -1.61   -2.67   -0.22    0.76    1.23   -2.41    0.80    3.28\n * P   -0.53    0.21   -1.10    0.72   -2.19    0.24   -0.26   -0.04   -1.44   -2.00   -1.56   -0.19   -1.09   -0.91    5.45\n * S    0.34   -0.06    0.40    0.71    0.31    1.04    0.31    0.29   -0.74   -1.75   -2.30   -0.06   -1.34   -1.11   -0.29    2.36\n * T    0.13   -0.15    0.30   -0.75   -0.59    0.60   -0.21   -0.81   -0.52   -0.96   -0.86   -0.10   -1.58   -0.69    0.93    1.20    2.04\n * W   -0.66   -0.04   -2.89   -1.91   -0.76   -0.81   -2.70   -1.21   -1.48    0.25   -0.14   -1.94    0.87    2.29   -5.34   -1.18   -0.57    6.96\n * Y   -1.25   -0.75   -0.36   -1.21    0.13   -0.61   -1.64   -1.62   -0.12    0.08    0.70   -1.72   -0.41    1.96   -1.98   -1.56   -0.41    2.15    3.95\n * V    0.02   -1.52   -2.17   -2.02    0.34   -1.38   -1.84   -1.96   -0.35    1.94    0.81   -1.27    0.61    0.51   -1.11   -1.11    0.05   -1.09    0.21    2.05\n */\n", "repo_name": "biojava-master/", "id": 132, "method_signature": "void testSDMmatrix()"}, "1007": {"callee_method_names": ["TreeMap<ResidueNumber, Integer>.firstKey"], "method_name": "AtomPositionMap.getFirst", "method_implementation": "{\n    return treeMap.firstKey();\n}", "repo_id": "9", "comment": "/**\n * @return The first {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n */\n", "repo_name": "biojava-master/", "id": 1007, "method_signature": "ResidueNumber getFirst()"}, "3117": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getIndexOf", "method_implementation": "{\n    return this.parsedCompounds.indexOf(compound) + 1;\n}", "repo_id": "9", "comment": "/**\n * @param compound\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3117, "method_signature": "int getIndexOf(C)"}, "2456": {"callee_method_names": [], "method_name": "Feature.frame", "method_implementation": "{\n    return mFrame;\n}", "repo_id": "9", "comment": "/**\n * Get frame (aka phase). (GFF field 8). Specifies the offset of the\n * first nucleotide of the first in-frame codon, assuming this feature\n * is a dna/rna sequence that codes\n * for a protein. If you\n * intend to use this field, you probably want to look it up on the web first.\n *\n * @return The frame (0, 1, 2).\n */\n", "repo_name": "biojava-master/", "id": 2456, "method_signature": "int frame()"}, "3296": {"callee_method_ids": [492], "callee_method_names": ["AFPChain.getAlnLength"], "method_name": "AFPChainCoordManager.getPreferredHeight", "method_implementation": "{\n    return 2 * DEFAULT_Y_SPACE + (afpChain.getAlnLength() / DEFAULT_LINE_LENGTH) * DEFAULT_Y_STEP + DEFAULT_LINE_SEPARATION;\n}", "repo_id": "9", "comment": "/**\n * Y coordinate size\n *\n * @return the preferred height\n */\n", "repo_name": "biojava-master/", "id": 3296, "method_signature": "int getPreferredHeight()"}, "3163": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.getInverse", "method_implementation": "{\n    return SequenceMixin.inverse(this);\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3163, "method_signature": "SequenceView<C> getInverse()"}, "459": {"callee_method_names": [], "method_name": "QsAlignParameters.setdCutoff", "method_implementation": "{\n    this.dCutoff = dCutoff;\n}", "repo_id": "9", "comment": "/**\n * The maximum allowed distance between the centroids of two equivalent\n * Subunits, in A.\n *\n * @param dCutoff\n */\n", "repo_name": "biojava-master/", "id": 459, "method_signature": "void setdCutoff(double)"}, "2066": {"callee_method_names": ["Map<Integer,Integer>.size", "Map<Integer,Double>.clear", "Map<Integer,Integer>.keySet", "Map<Integer,Integer>.keySet", "Map<Integer, Integer>.get", "Map<Integer,Double>.put"], "method_name": "SequenceFunctionRefiner.initializeScores", "method_implementation": "{\n    if (scores == null) {\n        scores = new HashMap<Integer, Double>(alignment.size());\n    } else {\n        scores.clear();\n    }\n    Map<Integer, Integer> alignK = AlignmentTools.applyAlignment(alignment, k);\n    // calculate input range\n    int maxPre = Integer.MIN_VALUE;\n    int minPre = Integer.MAX_VALUE;\n    for (Integer pre : alignment.keySet()) {\n        if (pre > maxPre)\n            maxPre = pre;\n        if (pre < minPre)\n            minPre = pre;\n    }\n    for (Integer pre : alignment.keySet()) {\n        Integer image = alignK.get(pre);\n        // Use the absolute error score, |x - f^k(x)|\n        double score = scoreAbsError(pre, image, minPre, maxPre);\n        scores.put(pre, score);\n    }\n    return scores;\n}", "repo_id": "9", "comment": "/**\n * Calculates all scores for an alignment\n * @param alignment\n * @param scores A mapping from residues to scores, which will be updated or\n * \tcreated if null\n * @return scores\n */\n", "repo_name": "biojava-master/", "id": 2066, "method_signature": "Map<Integer,Double> initializeScores(Map, Map, int)"}, "3183": {"callee_method_names": [], "method_name": "WindowedSequence.getWindowSize", "method_implementation": "{\n    return windowSize;\n}", "repo_id": "9", "comment": "/**\n * Access the current window size\n */\n", "repo_name": "biojava-master/", "id": 3183, "method_signature": "int getWindowSize()"}, "1289": {"callee_method_names": ["List<Atom>.isEmpty", "List<Atom>.isEmpty", "Atom.getAltLoc", "Atom.getAltLoc", "Atom.getAltLoc", "Atom.getAltLoc", "Atom.getAltLoc", "Atom.getAltLoc", "Logger.debug", "Atom.toString", "Atom.getAltLoc", "Atom.toString", "Atom.getAltLoc", "Logger.debug", "Atom.getPDBserial", "Atom.getName", "Atom.getPDBserial", "Atom.getName", "Logger.debug", "Atom.getPDBserial", "Atom.getName", "Atom.getPDBserial", "Atom.getName", "Logger.debug", "Atom.getPDBserial", "Atom.getName", "Atom.getPDBserial", "Atom.getName"], "method_name": "BondMaker.formBondAltlocAware", "method_implementation": "{\n    List<Atom> a1s = getAtoms(g1, name1);\n    List<Atom> a2s = getAtoms(g2, name2);\n    if (a1s.isEmpty() || a2s.isEmpty()) {\n        // some structures may be incomplete and not store info\n        // about all of their atoms\n        return;\n    }\n    for (Atom a1 : a1s) {\n        for (Atom a2 : a2s) {\n            if (a1.getAltLoc() != null && a2.getAltLoc() != null && !a1.getAltLoc().equals(' ') && !a2.getAltLoc().equals(' ') && !a1.getAltLoc().equals(a2.getAltLoc())) {\n                logger.debug(\"Skipping bond between atoms with differently named alt locs {} (altLoc '{}') -- {} (altLoc '{}')\", a1.toString(), a1.getAltLoc(), a2.toString(), a2.getAltLoc());\n                continue;\n            }\n            if (maxAllowedLength < 0) {\n                // negative maxAllowedLength means we don't check distance and always add bond\n                logger.debug(\"Forming bond between atoms {}-{} and {}-{} with bond order {}\", a1.getPDBserial(), a1.getName(), a2.getPDBserial(), a2.getName(), bondOrder);\n                new BondImpl(a1, a2, bondOrder);\n            } else {\n                if (Calc.getDistance(a1, a2) < maxAllowedLength) {\n                    logger.debug(\"Forming bond between atoms {}-{} and {}-{} with bond order {}. Distance is below {}\", a1.getPDBserial(), a1.getName(), a2.getPDBserial(), a2.getName(), bondOrder, maxAllowedLength);\n                    new BondImpl(a1, a2, bondOrder);\n                } else {\n                    logger.debug(\"Not forming bond between atoms {}-{} and {}-{} with bond order {}, because distance is above {}\", a1.getPDBserial(), a1.getName(), a2.getPDBserial(), a2.getName(), bondOrder, maxAllowedLength);\n                }\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Form bond between atoms of the given names and groups, respecting alt loc rules to form bonds:\n * no bonds between differently named alt locs (that are not the default alt loc '.')\n * and multiple bonds for default alt loc to named alt loc.\n * @param g1 first group\n * @param name1 name of atom in first group\n * @param g2 second group\n * @param name2 name of atom in second group\n * @param maxAllowedLength max length, if atoms distance above this length no bond will be added. If negative no check on distance is performed.\n * @param bondOrder the bond order to be set in the created bond(s)\n */\n", "repo_name": "biojava-master/", "id": 1289, "method_signature": "void formBondAltlocAware(Group, String, Group, String, double, int)"}, "835": {"callee_method_names": ["Point3d[].distance", "List<IndexAndDistance>.add", "List<IndexAndDistance>.toArray"], "method_name": "AsaCalculator.findNeighborIndices", "method_implementation": "{\n    // looking at a typical protein case, number of neighbours are from ~10 to ~50, with an average of ~30\n    int initialCapacity = 60;\n    IndexAndDistance[][] nbsIndices = new IndexAndDistance[atomCoords.length][];\n    for (int k = 0; k < atomCoords.length; k++) {\n        double radius = radii[k] + probe + probe;\n        List<IndexAndDistance> thisNbIndices = new ArrayList<>(initialCapacity);\n        for (int i = 0; i < atomCoords.length; i++) {\n            if (i == k)\n                continue;\n            double dist = atomCoords[i].distance(atomCoords[k]);\n            if (dist < radius + radii[i]) {\n                thisNbIndices.add(new IndexAndDistance(i, dist));\n            }\n        }\n        IndexAndDistance[] indicesArray = thisNbIndices.toArray(new IndexAndDistance[0]);\n        nbsIndices[k] = indicesArray;\n    }\n    return nbsIndices;\n}", "repo_id": "9", "comment": "/**\n * Returns the 2-dimensional array with neighbor indices for every atom.\n * @return 2-dimensional array of size: n_atoms x n_neighbors_per_atom\n */\n", "repo_name": "biojava-master/", "id": 835, "method_signature": "IndexAndDistance[][] findNeighborIndices()"}, "1283": {"callee_method_names": [], "method_name": "MmtfSummaryDataBean.getChainIdToIndexMap", "method_implementation": "{\n    return chainIdToIndexMap;\n}", "repo_id": "9", "comment": "/**\n * @return the map of chain ids (strings asymId) to the index of that chain in the allChains list.\n * This only applies for the first model in the structure.\n */\n", "repo_name": "biojava-master/", "id": 1283, "method_signature": "Map<String,Integer> getChainIdToIndexMap()"}, "3564": {"callee_method_ids": [3607, 3637, 3655, 3654, 3664, 3662, 3666, 3608, 3607, 3663, 3661, 3664, 3662, 3664, 3662, 3663, 3661, 3664, 3662, 3664, 3662, 3606, 3628, 3679], "callee_method_names": ["CoxInfo.getVariance", "CoxInfo.getCoefficientsList", "ArrayList<CoxCoefficient>.get", "SurvivalInfo.getOffset", "SurvivalInfo.getVariable", "SurvivalInfo.setLinearPredictor", "SurvivalInfo.setScore", "CoxInfo.size", "CoxInfo.get", "SurvivalInfo.setResidual", "CoxInfo.setNaiveVariance", "CoxInfo.getVariance", "CoxInfo.size", "CoxInfo.size", "SurvivalInfo.getLinearPredictor", "SurvivalInfo.getScore", "SurvivalInfo.setLinearPredictor", "SurvivalInfo.setScore", "SurvivalInfo.setLinearPredictor", "SurvivalInfo.setScore", "CoxInfo.size", "CoxInfo.size", "SurvivalInfo.getLinearPredictor", "SurvivalInfo.getScore", "SurvivalInfo.setLinearPredictor", "SurvivalInfo.setScore", "SurvivalInfo.setLinearPredictor", "SurvivalInfo.setScore", "CoxInfo.setVariance", "CoxInfo.setRscore", "WaldTestInfo.getTest"], "method_name": "CoxR.coxphfitSCleanup", "method_implementation": "{\n    //Do cleanup found after coxfit6 is called in coxph.fit.S\n    //infs <- abs(coxfit$u %*% var)\n    //[ a1 b1] * [a1 b1]\n    //           [a2 b2]\n    double[][] du = new double[1][ci.u.length];\n    du[0] = ci.u;\n    double[] infs = Matrix.abs(Matrix.multiply(ci.u, ci.getVariance()));\n    //        StdArrayIO.print(infs);\n    ArrayList<CoxCoefficient> coxCoefficients = new ArrayList<CoxCoefficient>(ci.getCoefficientsList().values());\n    for (int i = 0; i < infs.length; i++) {\n        double inf = infs[i];\n        double coe = coxCoefficients.get(i).getCoeff();\n        if (inf > ci.eps && inf > (ci.toler * Math.abs(coe))) {\n            ci.message = \"Loglik converged before variable \";\n        }\n    }\n    //sum(coef*coxfit$means)\n    double sumcoefmeans = 0;\n    for (CoxCoefficient cc : coxCoefficients) {\n        sumcoefmeans = sumcoefmeans + cc.getCoeff() * cc.getMean();\n    }\n    // coxph.fit.S line 107\n    //lp <- c(x %*% coef) + offset - sum(coef*coxfit$means)\n    for (SurvivalInfo si : ci.survivalInfoList) {\n        double offset = si.getOffset();\n        double lp = 0;\n        for (CoxCoefficient cc : coxCoefficients) {\n            String name = cc.getName();\n            double coef = cc.getCoeff();\n            double value = si.getVariable(name);\n            lp = lp + value * coef;\n        }\n        lp = lp + offset - sumcoefmeans;\n        si.setLinearPredictor(lp);\n        si.setScore(Math.exp(lp));\n        //           System.out.println(\"lp score \" + si.order + \" \" + si.time + \" \" + si.getWeight() + \" \" + si.getClusterValue() + \" \" + lp + \" \" + Math.exp(lp));\n    }\n    //       ci.dump();\n    //begin code after call to coxfit6 in coxph.fit.S\n    //Compute the martingale residual for a Cox model\n    // appears to be C syntax error for = - vs -=\n    //(if (nullmodel) in coxph.fit\n    double[] res = CoxMart.process(ci.method, ci.survivalInfoList, false);\n    for (int i = 0; i < ci.survivalInfoList.size(); i++) {\n        SurvivalInfo si = ci.survivalInfoList.get(i);\n        si.setResidual(res[i]);\n    }\n    //this represents the end of coxph.fit.S code and we pickup\n    //after call to fit <- fitter(X, Y, strats ....) in coxph.R\n    if (robust) {\n        ci.setNaiveVariance(ci.getVariance());\n        double[][] temp;\n        double[][] temp0;\n        if (cluster != null) {\n            temp = ResidualsCoxph.process(ci, ResidualsCoxph.Type.dfbeta, useWeighted, cluster);\n            //# get score for null model\n            //    if (is.null(init))\n            //          fit2$linear.predictors <- 0*fit$linear.predictors\n            //    else\n            //          fit2$linear.predictors <- c(X %*% init)\n            //Set score to 1\n            double[] templp = new double[ci.survivalInfoList.size()];\n            double[] tempscore = new double[ci.survivalInfoList.size()];\n            int i = 0;\n            for (SurvivalInfo si : ci.survivalInfoList) {\n                templp[i] = si.getLinearPredictor();\n                tempscore[i] = si.getScore();\n                si.setLinearPredictor(0);\n                //this erases stored value which isn't how the R code does it\n                si.setScore(1.0);\n                i++;\n            }\n            temp0 = ResidualsCoxph.process(ci, ResidualsCoxph.Type.score, useWeighted, cluster);\n            i = 0;\n            for (SurvivalInfo si : ci.survivalInfoList) {\n                si.setLinearPredictor(templp[i]);\n                //this erases stored value which isn't how the R code does it\n                si.setScore(tempscore[i]);\n                i++;\n            }\n        } else {\n            temp = ResidualsCoxph.process(ci, ResidualsCoxph.Type.dfbeta, useWeighted, null);\n            //     fit2$linear.predictors <- 0*fit$linear.predictors\n            double[] templp = new double[ci.survivalInfoList.size()];\n            double[] tempscore = new double[ci.survivalInfoList.size()];\n            int i = 0;\n            for (SurvivalInfo si : ci.survivalInfoList) {\n                templp[i] = si.getLinearPredictor();\n                tempscore[i] = si.getScore();\n                si.setLinearPredictor(0);\n                si.setScore(1.0);\n            }\n            temp0 = ResidualsCoxph.process(ci, ResidualsCoxph.Type.score, useWeighted, null);\n            i = 0;\n            for (SurvivalInfo si : ci.survivalInfoList) {\n                si.setLinearPredictor(templp[i]);\n                //this erases stored value which isn't how the R code does it\n                si.setScore(tempscore[i]);\n                i++;\n            }\n        }\n        //fit$var<- t(temp) % * % temp\n        double[][] ttemp = Matrix.transpose(temp);\n        double[][] var = Matrix.multiply(ttemp, temp);\n        ci.setVariance(var);\n        //u<- apply(as.matrix(temp0), 2, sum)\n        double[] u = new double[temp0[0].length];\n        for (int i = 0; i < temp0[0].length; i++) {\n            for (int j = 0; j < temp0.length; j++) {\n                u[i] = u[i] + temp0[j][i];\n            }\n        }\n        //fit$rscore <- coxph.wtest(t(temp0)%*%temp0, u, control$toler.chol)$test\n        double[][] wtemp = Matrix.multiply(Matrix.transpose(temp0), temp0);\n        double toler_chol = 1.818989e-12;\n        //  toler_chol = ci.toler;\n        WaldTestInfo wti = WaldTest.process(wtemp, u, toler_chol);\n        //not giving the correct value\n        ci.setRscore(wti.getTest());\n    }\n    calculateWaldTestInfo(ci);\n}", "repo_id": "9", "comment": "/**\n * @param ci\n * @param useWeighted\n * @param robust\n * @param cluster\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3564, "method_signature": "void coxphfitSCleanup(CoxInfo, boolean, boolean, ArrayList)"}, "1116": {"callee_method_names": ["Element.getElementsByTagName", "NodeList.getLength", "NodeList.item", "Element.getFirstChild"], "method_name": "SiftsXMLParser.getTextValue", "method_implementation": "{\n    String textVal = null;\n    NodeList nl = ele.getElementsByTagName(tagName);\n    if (nl != null && nl.getLength() > 0) {\n        Element el = (Element) nl.item(0);\n        textVal = el.getFirstChild().getNodeValue();\n    }\n    return textVal;\n}", "repo_id": "9", "comment": "/**\n * I take a xml element and the tag name, look for the tag and get\n * the text content\n * i.e for <employee><name>John</name></employee> xml snippet if\n * the Element points to employee node and tagName is 'name' I will return John\n */\n", "repo_name": "biojava-master/", "id": 1116, "method_signature": "String getTextValue(Element, String)"}, "3167": {"callee_method_names": ["CDSSequence.getAccession", "ArrayList.remove", "LinkedHashMap.remove"], "method_name": "TranscriptSequence.removeCDS", "method_implementation": "{\n    for (CDSSequence cdsSequence : cdsSequenceList) {\n        if (cdsSequence.getAccession().getID().equals(accession)) {\n            cdsSequenceList.remove(cdsSequence);\n            cdsSequenceHashMap.remove(accession);\n            return cdsSequence;\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Remove a CDS or coding sequence from the transcript sequence\n * @param accession\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3167, "method_signature": "CDSSequence removeCDS(String)"}, "1582": {"callee_method_names": [], "method_name": "SecStrucElement.getIndex", "method_implementation": "{\n    return index;\n}", "repo_id": "9", "comment": "/**\n * Returns the index of the SSE for its type. This is, the sequential\n * position of this SSE relative to the other SSE of the same type.\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1582, "method_signature": "int getIndex()"}, "3777": {"callee_method_names": [], "method_name": "WorkSheet.getMetaDataRowsHashMap", "method_implementation": "{\n    return metaDataRowsHashMap;\n}", "repo_id": "9", "comment": "/**\n * @return the metaDataRowsHashMap\n */\n", "repo_name": "biojava-master/", "id": 3777, "method_signature": "LinkedHashMap<String,String> getMetaDataRowsHashMap()"}, "1198": {"callee_method_names": ["String.length", "String.charAt", "String.length", "String.getChars", "String.length", "String.getChars"], "method_name": "PDBFileParser.getNextAsymId", "method_implementation": "{\n    if (asymId.length() == 1) {\n        if (!\"Z\".equals(asymId)) {\n            return Character.toString(getNextChar(asymId.charAt(0)));\n        } else {\n            return \"AA\";\n        }\n    } else if (asymId.length() == 2) {\n        if (\"ZZ\".equals(asymId)) {\n            return \"AAA\";\n        }\n        char[] c = new char[2];\n        asymId.getChars(0, 2, c, 0);\n        c[0] = getNextChar(c[0]);\n        if (c[0] == 'A') {\n            c[1] = getNextChar(c[1]);\n        }\n        return String.valueOf(c);\n    } else if (asymId.length() == 3) {\n        char[] c = new char[3];\n        asymId.getChars(0, 3, c, 0);\n        c[0] = getNextChar(c[0]);\n        if (c[0] == 'A') {\n            c[1] = getNextChar(c[1]);\n            if (c[1] == 'A') {\n                c[2] = getNextChar(c[2]);\n            }\n        }\n        return String.valueOf(c);\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Gets the next asym id given an asymId, according to the convention followed by\n * mmCIF files produced by the PDB\n * i.e.: A,B,...,Z,AA,BA,CA,...,ZA,AB,BB,CB,...,ZB,.......,ZZ,AAA,BAA,CAA,...\n * @param asymId\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1198, "method_signature": "String getNextAsymId(String)"}, "3223": {"callee_method_ids": [3106, 3106, 3108, 3108], "callee_method_names": ["ByteArrayOutputStream.close", "ByteArrayOutputStream.toByteArray", "DNASequence.getOriginalHeader", "DNASequence.getOriginalHeader", "DNASequence.getLength", "DNASequence.getLength", "DNASequence.getAccession", "DNASequence.getAccession", "DNASequence.getAccession", "DNASequence.getAccession", "DNASequence.getDescription", "DNASequence.getDescription", "DNASequence.getFeatures", "DNASequence.getFeatures", "List<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>>.size", "List<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>>.get", "FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>.getLocations", "Location.getSubLocations", "FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>.getQualifiers", "List<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>>.get", "FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>.getLocations", "Location.getSubLocations", "FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>.getQualifiers", "FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>.getType", "FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>.getType", "Location.getStart", "Location.getStart", "Location.getEnd", "Location.getEnd", "Location.getStrand", "Location.getStrand", "List<Location>.size", "List<Location>.size", "List<Location>.size", "List<Location>.get", "List<Location>.get", "List<Location>.get", "List<Location>.get", "List<Location>.get", "List<Location>.get", "Map<String, List<Qualifier>>.size", "Map<String, List<Qualifier>>.size", "Map<String, List<Qualifier>>.keySet", "Map<String, List<Qualifier>>.get", "Map<String, List<Qualifier>>.get", "List<Qualifier>.size", "List<Qualifier>.size", "List<Qualifier>.size", "List<Qualifier>.get", "List<Qualifier>.get", "List<Qualifier>.get", "DBReferenceInfo.getDatabase", "DBReferenceInfo.getDatabase", "DBReferenceInfo.getId", "DBReferenceInfo.getId", "List<Qualifier>.get", "List<Qualifier>.get", "DNASequence.getSequenceAsString", "DNASequence.getSequenceAsString"], "method_name": "GenbankWriterTest.testGithub942", "method_implementation": "{\n    // Important information is lost when reading and writing a\n    // GenBank file through GenbankReaderHelper & GenbankWriterHelper\n    // First read the sample GenBank file from\n    // https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html using the\n    // GenbankReaderHelper\n    InputStream inStream = GenbankWriterTest.class.getResourceAsStream(\"/NM_000266.gb\");\n    DNASequence sequence = GenbankReaderHelper.readGenbankDNASequence(inStream).values().iterator().next();\n    // Then write sequence back to a file using the GenbankWriterHelper\n    ByteArrayOutputStream fragwriter = new ByteArrayOutputStream();\n    GenbankWriterHelper.writeNucleotideSequenceOriginal(fragwriter, Arrays.asList(sequence));\n    fragwriter.close();\n    // Test no important information is lost\n    InputStream readerInputStream = new ByteArrayInputStream(fragwriter.toByteArray());\n    DNASequence newSequence = GenbankReaderHelper.readGenbankDNASequence(readerInputStream).values().iterator().next();\n    //System.out.println(fragwriter.toString().replaceAll(\"\\r\\n\", \"\\n\"));\n    assertEquals(\"getOriginalHeader()\", sequence.getOriginalHeader(), newSequence.getOriginalHeader());\n    assertEquals(\"getLength()\", sequence.getLength(), newSequence.getLength());\n    assertEquals(\"getAccession().getID()\", sequence.getAccession().getID(), newSequence.getAccession().getID());\n    assertEquals(\"getAccession().getVersion()\", sequence.getAccession().getVersion(), newSequence.getAccession().getVersion());\n    assertEquals(\"getDescription()\", sequence.getDescription(), newSequence.getDescription());\n    //assertEquals(\"getSource()\", sequence.getSource(), newSequence.getSource());\n    //assertEquals(\"getDNAType()\", sequence.getDNAType(), newSequence.getDNAType());\n    //assertEquals(\"getTaxonomy()\", sequence.getTaxonomy(), newSequence.getTaxonomy());\n    //assertEquals(\"getReferences()\", sequence.getReferences(), newSequence.getReferences());\n    //assertEquals(\"getComments()\", sequence.getComments(), newSequence.getComments());\n    //assertEquals(\"getNotesList()\", sequence.getNotesList(), newSequence.getNotesList());\n    //Assuming the features will be in the same order\n    List<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> features = sequence.getFeatures();\n    List<FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound>> newFeatures = newSequence.getFeatures();\n    //feature locations and qualifiers\n    for (int i = 0; i < features.size(); i++) {\n        FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> feature = features.get(i);\n        Location location = feature.getLocations();\n        List<Location> subLocations = location.getSubLocations();\n        Map<String, List<Qualifier>> qualifiers = feature.getQualifiers();\n        FeatureInterface<AbstractSequence<NucleotideCompound>, NucleotideCompound> newFeature = newFeatures.get(i);\n        Location newLocation = newFeature.getLocations();\n        List<Location> newSubLocations = newLocation.getSubLocations();\n        Map<String, List<Qualifier>> newQualifiers = newFeature.getQualifiers();\n        assertEquals(\"feature, getType()\", feature.getType(), newFeature.getType());\n        assertEquals(\"feature, Location start\", location.getStart(), newLocation.getStart());\n        assertEquals(\"feature, Location end\", location.getEnd(), newLocation.getEnd());\n        assertEquals(\"feature, Location strand\", location.getStrand(), newLocation.getStrand());\n        assertEquals(\"feature, sublocations\", subLocations.size(), newSubLocations.size());\n        for (int j = 0; j < subLocations.size(); j++) {\n            assertEquals(\"SubLocations, start\", subLocations.get(j).getStart(), newSubLocations.get(j).getStart());\n            assertEquals(\"SubLocations, end\", subLocations.get(j).getEnd(), newSubLocations.get(j).getEnd());\n            assertEquals(\"SubLocations, strand\", subLocations.get(j).getStrand(), newSubLocations.get(j).getStrand());\n        }\n        assertEquals(\"getQualifiers()\", qualifiers.size(), newQualifiers.size());\n        for (String qualifierType : qualifiers.keySet()) {\n            List<Qualifier> qualifier = new ArrayList<Qualifier>(qualifiers.get(qualifierType));\n            List<Qualifier> newQualifier = new ArrayList<Qualifier>(newQualifiers.get(qualifierType));\n            assertEquals(\"getQualifiers()\", qualifier.size(), newQualifier.size());\n            for (int k = 0; k < qualifier.size(); k++) {\n                if (qualifier.get(k) instanceof DBReferenceInfo) {\n                    DBReferenceInfo dbxref = (DBReferenceInfo) qualifier.get(k);\n                    DBReferenceInfo newDbxref = (DBReferenceInfo) newQualifier.get(k);\n                    assertEquals(\"getQualifiers() DBReferenceInfo\", dbxref.getDatabase(), newDbxref.getDatabase());\n                    assertEquals(\"getQualifiers() DBReferenceInfo\", dbxref.getId(), newDbxref.getId());\n                } else {\n                    assertEquals(\"getQualifiers()\", qualifier.get(k).getValue(), newQualifier.get(k).getValue());\n                }\n            }\n        }\n    }\n    assertEquals(\"getSequenceAsString()\", sequence.getSequenceAsString(), newSequence.getSequenceAsString());\n}", "repo_id": "9", "comment": "/**\n * Going from GenBank file -> DNASequence object -> GenBank file looses information\n * https://github.com/biojava/biojava/issues/942\n */\n", "repo_name": "biojava-master/", "id": 3223, "method_signature": "void testGithub942()"}, "1002": {"callee_method_names": ["ResidueNumber.getChainName", "ResidueNumber.getChainName", "ResidueNumber.getChainName"], "method_name": "AtomPositionMap.getLength", "method_implementation": "{\n    if (!start.getChainName().equals(end.getChainName())) {\n        throw new IllegalArgumentException(String.format(\"Chains differ between %s and %s. Unable to calculate length.\", start, end));\n    }\n    Integer startPos = getPosition(start);\n    Integer endPos = getPosition(end);\n    if (startPos == null) {\n        throw new IllegalArgumentException(\"Residue \" + start + \" was not found.\");\n    }\n    if (endPos == null) {\n        throw new IllegalArgumentException(\"Residue \" + start + \" was not found.\");\n    }\n    return getLength(startPos, endPos, start.getChainName());\n}", "repo_id": "9", "comment": "/**\n * Calculates the number of atoms between two ResidueNumbers, inclusive. Both residues\n * must belong to the same chain.\n * @param start First residue\n * @param end Last residue\n * @return The number of atoms from A to B inclusive\n * @throws IllegalArgumentException if start and end are on different chains,\n *  or if either of the residues doesn't exist\n */\n", "repo_name": "biojava-master/", "id": 1002, "method_signature": "int getLength(ResidueNumber, ResidueNumber)"}, "2614": {"callee_method_names": ["ThreadPoolExecutor.shutdown"], "method_name": "ConcurrencyTools.shutdown", "method_implementation": "{\n    if (pool != null) {\n        pool.shutdown();\n    }\n}", "repo_id": "9", "comment": "/**\n * Disables new tasks from being submitted and closes the thread pool cleanly.\n */\n", "repo_name": "biojava-master/", "id": 2614, "method_signature": "void shutdown()"}, "3658": {"callee_method_names": [], "method_name": "SurvivalInfo.setWeight", "method_implementation": "{\n    this.weight = weight;\n}", "repo_id": "9", "comment": "/**\n * @param weight the weight to set\n */\n", "repo_name": "biojava-master/", "id": 3658, "method_signature": "void setWeight(double)"}, "493": {"callee_method_names": [], "method_name": "AFPChain.getAlnbeg1", "method_implementation": "{\n    return alnbeg1;\n}", "repo_id": "9", "comment": "/**\n * @return The index of the first aligned residue in protein 1\n */\n", "repo_name": "biojava-master/", "id": 493, "method_signature": "int getAlnbeg1()"}, "1795": {"callee_method_names": [], "method_name": "EcodDomain.toString", "method_implementation": "{\n    return \"EcodDomain [uid=\" + uid + \", domainId=\" + domainId + \", manual=\" + manual + \", xGroup=\" + xGroup + \", hGroup=\" + hGroup + \", tGroup=\" + tGroup + \", fGroup=\" + fGroup + \", pdbId=\" + pdbId + \", chainName=\" + chainId + \", range=\" + range + \", architectureName=\" + architectureName + \", xGroupName=\" + xGroupName + \", hGroupName=\" + hGroupName + \", tGroupName=\" + tGroupName + \", fGroupName=\" + fGroupName + \", assemblyId=\" + assemblyId + \", ligands=\" + ligands + \"]\";\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#toString()\n\t */\n", "repo_name": "biojava-master/", "id": 1795, "method_signature": "String toString()"}, "1640": {"callee_method_names": [], "method_name": "SubunitClustererParameters.isUseRMSD", "method_implementation": "{\n    return useRMSD;\n}", "repo_id": "9", "comment": "/**\n * Use RMSD for evaluating structure similarity\n *\n * @return useRMSD\n */\n", "repo_name": "biojava-master/", "id": 1640, "method_signature": "boolean isUseRMSD()"}, "3829": {"callee_method_names": [], "method_name": "CommandPrompt.main", "method_implementation": "{\n    run(args);\n}", "repo_id": "9", "comment": "/**\n * The main method\n * @param args\n * \tSee showHelp for a list of available arguments\n * @throws Exception\n *  To handle exception thrown by reading of XML files\n */\n", "repo_name": "biojava-master/", "id": 3829, "method_signature": "void main(String[])"}, "3666": {"callee_method_names": [], "method_name": "SurvivalInfo.setResidual", "method_implementation": "{\n    this.residual = residual;\n}", "repo_id": "9", "comment": "/**\n * @param residual the residual to set\n */\n", "repo_name": "biojava-master/", "id": 3666, "method_signature": "void setResidual(double)"}, "2159": {"callee_method_names": [], "method_name": "StructureImpl.isBiologicalAssembly", "method_implementation": "{\n    return biologicalAssembly;\n}", "repo_id": "9", "comment": "/**\n * Gets flag that indicates if this structure is a biological assembly\n * @return the sites contained in this structure\n * @since 3.2\n */\n", "repo_name": "biojava-master/", "id": 2159, "method_signature": "boolean isBiologicalAssembly()"}, "3195": {"callee_method_names": [], "method_name": "TestFASTAReader.testProcess2WithBlankLines", "method_implementation": "{\n    testProcess2(\"org/biojava/nbio/core/fasta/TwoSequences_blank_lines.fasta\");\n}", "repo_id": "9", "comment": "/**\n * Sane as {@link #testProcess2()} but input file contain blank lines\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3195, "method_signature": "void testProcess2WithBlankLines()"}, "2399": {"callee_method_names": [], "method_name": "Location.start", "method_implementation": "{\n    return mStart;\n}", "repo_id": "9", "comment": "/**\n * Get starting index (origin 0).\n *\n * @return The start index.\n */\n", "repo_name": "biojava-master/", "id": 2399, "method_signature": "int start()"}, "2562": {"callee_method_names": ["SoftHashMap.get"], "method_name": "FlatFileCache.getInputStream", "method_implementation": "{\n    //logger.debug(\"returning \" + key + \" from file cache (cache size: \" + cache.size() + \")\");\n    byte[] bytes = cache.get(key);\n    if (bytes == null)\n        return null;\n    return new ByteArrayInputStream(bytes);\n}", "repo_id": "9", "comment": "/**\n * Gets the cached file as an InputStream.\n * Clients should check for null as the item might have expired in the  cache.\n * @param key\n * @return An {@code InputStream} or null.\n */\n", "repo_name": "biojava-master/", "id": 2562, "method_signature": "InputStream getInputStream(String)"}, "2384": {"callee_method_names": ["RandomAccessFile.seek"], "method_name": "TwoBitParser.skip", "method_implementation": "{\n    if (cur_seq_name == null)\n        throw new IOException(\"Sequence is not set\");\n    if (n < 4) {\n        int ret = 0;\n        while ((ret < n) && (read() >= 0)) ret++;\n        return ret;\n    }\n    if (n > cur_dna_size - cur_seq_pos) {\n        n = cur_dna_size - cur_seq_pos;\n    }\n    cur_seq_pos += n;\n    file_pos = start_file_pos + (cur_seq_pos / 4);\n    raf.seek(file_pos);\n    if ((cur_seq_pos % 4) != 0) {\n        loadBits();\n    }\n    while ((cur_nn_block_num >= 0) && (cur_nn_blocks[cur_nn_block_num][0] + cur_nn_blocks[cur_nn_block_num][1] <= cur_seq_pos)) {\n        cur_nn_block_num++;\n        if (cur_nn_block_num >= cur_nn_blocks.length)\n            cur_nn_block_num = -1;\n    }\n    while ((cur_mask_block_num >= 0) && (cur_mask_blocks[cur_mask_block_num][0] + cur_mask_blocks[cur_mask_block_num][1] <= cur_seq_pos)) {\n        cur_mask_block_num++;\n        if (cur_mask_block_num >= cur_mask_blocks.length)\n            cur_mask_block_num = -1;\n    }\n    return n;\n}", "repo_id": "9", "comment": "/**\n * Method skips n nucleotides in sequence stream. You should set current sequence\n * before use it.\n */\n", "repo_name": "biojava-master/", "id": 2384, "method_signature": "long skip(long)"}, "2122": {"callee_method_names": ["Chain.setStructure", "List<Model>.isEmpty", "List<Chain>.add", "Model.setChains", "List<Model>.add", "List<Model>.get", "Model.addChain"], "method_name": "StructureImpl.addChain", "method_implementation": "{\n    // if model has not been initialized, init it!\n    chain.setStructure(this);\n    if (models.isEmpty()) {\n        Model model = new Model();\n        List<Chain> modelChains = new ArrayList<>();\n        modelChains.add(chain);\n        model.setChains(modelChains);\n        models.add(model);\n    } else {\n        Model model = models.get(modelnr);\n        model.addChain(chain);\n    }\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2122, "method_signature": "void addChain(Chain, int)"}, "2955": {"callee_method_names": ["C.isAmbiguous", "Set<NucleotideCompound>.containsAll", "Map<NucleotideCompound, List<NucleotideCompound>>.keySet", "Map<NucleotideCompound, List<NucleotideCompound>>.get"], "method_name": "AbstractNucleotideCompoundSet.calculateIndirectAmbiguities", "method_implementation": "{\n    Map<NucleotideCompound, List<NucleotideCompound>> equivalentsMap = new HashMap<NucleotideCompound, List<NucleotideCompound>>();\n    List<NucleotideCompound> ambiguousCompounds = getAllCompounds().stream().filter(compound -> compound.isAmbiguous()).collect(Collectors.toCollection(ArrayList::new));\n    for (NucleotideCompound sourceCompound : ambiguousCompounds) {\n        Set<NucleotideCompound> compoundConstituents = sourceCompound.getConstituents();\n        for (NucleotideCompound targetCompound : ambiguousCompounds) {\n            Set<NucleotideCompound> targetConstituents = targetCompound.getConstituents();\n            if (targetConstituents.containsAll(compoundConstituents)) {\n                NucleotideCompound lcSourceCompound = toLowerCase(sourceCompound);\n                NucleotideCompound lcTargetCompound = toLowerCase(targetCompound);\n                //equivalentsMap.put(sourceCompound, targetCompound);\n                //      equivalentsMap.put(sourceCompound, lcTargetCompound);\n                checkAdd(equivalentsMap, sourceCompound, targetCompound);\n                checkAdd(equivalentsMap, sourceCompound, lcTargetCompound);\n                checkAdd(equivalentsMap, targetCompound, sourceCompound);\n                checkAdd(equivalentsMap, lcTargetCompound, sourceCompound);\n                checkAdd(equivalentsMap, lcSourceCompound, targetCompound);\n                checkAdd(equivalentsMap, lcSourceCompound, lcTargetCompound);\n            }\n        }\n    }\n    //And once it's all done start adding them to the equivalents map\n    for (NucleotideCompound key : equivalentsMap.keySet()) {\n        List<NucleotideCompound> vals = equivalentsMap.get(key);\n        for (NucleotideCompound value : vals) {\n            addEquivalent((C) key, (C) value);\n            addEquivalent((C) value, (C) key);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Loops through all known nucleotides and attempts to find which are\n * equivalent to each other. Also takes into account lower casing\n * nucleotides as well as upper-cased ones.\n */\n", "repo_name": "biojava-master/", "id": 2955, "method_signature": "void calculateIndirectAmbiguities()"}, "2427": {"callee_method_names": [], "method_name": "Location.isHealthy", "method_implementation": "{\n    return (mStart <= mEnd) && ((mStart <= 0 && mEnd <= 0) || (mStart >= 0 && mEnd >= 0));\n}", "repo_id": "9", "comment": "/**\n */\n", "repo_name": "biojava-master/", "id": 2427, "method_signature": "boolean isHealthy()"}, "3874": {"callee_method_names": ["Map<AminoAcidCompound, Double>.keySet", "Map<Character, Double>.put", "Map<AminoAcidCompound, Double>.get"], "method_name": "PeptideProperties.getAACompositionChar", "method_implementation": "{\n    Map<AminoAcidCompound, Double> aa2Composition = getAAComposition(sequence);\n    Map<Character, Double> aaChar2Composition = new HashMap<Character, Double>();\n    for (AminoAcidCompound aaCompound : aa2Composition.keySet()) {\n        aaChar2Composition.put(aaCompound.getShortName().charAt(0), aa2Composition.get(aaCompound));\n    }\n    return aaChar2Composition;\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the composition of the 20 standard amino acid in the sequence.\n * The sequence argument must be a protein sequence consisting of only\n * non-ambiguous characters.\n * The composition of an amino acid is the total number of its occurrence,\n * divided by the total length of the sequence.\n *\n * @param sequence\n * \t\ta protein sequence consisting of non-ambiguous characters only\n * @return the composition of the 20 standard amino acid in the sequence\n */\n", "repo_name": "biojava-master/", "id": 3874, "method_signature": "Map<Character,Double> getAACompositionChar(String)"}, "11": {"callee_method_names": [], "method_name": "GuideTree.getSequences", "method_implementation": "{\n    return sequences;\n}", "repo_id": "9", "comment": "/**\n * Returns the {@link Sequence}s which make up the leaves of this tree.\n *\n * @return the sequences which make up the leaves of this tree\n */\n", "repo_name": "biojava-master/", "id": 11, "method_signature": "List<S> getSequences()"}, "3274": {"callee_method_names": ["JFrame.setTitle", "JFrame.repaint"], "method_name": "AbstractAlignmentJmol.setTitle", "method_implementation": "{\n    frame.setTitle(title);\n    frame.repaint();\n}", "repo_id": "9", "comment": "/**\n * Set the title of the AlignmentJmol window.\n * @param label\n */\n", "repo_name": "biojava-master/", "id": 3274, "method_signature": "void setTitle(String)"}, "1380": {"callee_method_names": [], "method_name": "DBRef.getDbIdCode", "method_implementation": "{\n    return dbIdCode;\n}", "repo_id": "9", "comment": "/**\n * Sequence database          identification code.\n *\n * @return the dbIdCode\n * @see #setDbIdCode(String)\n */\n", "repo_name": "biojava-master/", "id": 1380, "method_signature": "String getDbIdCode()"}, "311": {"callee_method_names": [], "method_name": "Component.getPdbccIds", "method_implementation": "{\n    return pdbccIds;\n}", "repo_id": "9", "comment": "/**\n * @return Protein Data Bank ID.\n */\n", "repo_name": "biojava-master/", "id": 311, "method_signature": "Set<String> getPdbccIds()"}, "405": {"callee_method_names": ["Structure.nrModels", "Structure.getModel", "List<Chain>.size", "List<Chain>.get", "Chain.getAtomLength", "Chain.getAtomGroup"], "method_name": "GroupIterator.getNextGroup", "method_implementation": "{\n    if (tmp_model >= structure.nrModels()) {\n        throw new NoSuchElementException(\"arrived at end of structure!\");\n    }\n    List<Chain> model = structure.getModel(tmp_model);\n    if (tmp_chain >= model.size()) {\n        if (fixed_model)\n            throw new NoSuchElementException(\"arrived at end of model!\");\n        return getNextGroup(tmp_model + 1, 0, 0);\n    }\n    Chain chain = model.get(tmp_chain);\n    if (tmp_group >= chain.getAtomLength()) {\n        // start search at beginning of next chain.\n        return getNextGroup(tmp_model, tmp_chain + 1, 0);\n    } else {\n        current_model_pos = tmp_model;\n        current_chain_pos = tmp_chain;\n        current_group_pos = tmp_group;\n        return chain.getAtomGroup(current_group_pos);\n    }\n}", "repo_id": "9", "comment": "/**\n * recursive method to retrieve the next group. Helper\n * method for gext().\n * @see #next\n */\n", "repo_name": "biojava-master/", "id": 405, "method_signature": "Group getNextGroup(int, int, int)"}, "289": {"callee_method_names": [], "method_name": "ProteinModificationIdentifier.getRecordAdditionalAttachments", "method_implementation": "{\n    return recordAdditionalAttachments;\n}", "repo_id": "9", "comment": "/**\n * @return true if choosing to record additional attachments\n *  that are not directly attached to a modified residue.\n * @see #setRecordAdditionalAttachments\n */\n", "repo_name": "biojava-master/", "id": 289, "method_signature": "boolean getRecordAdditionalAttachments()"}, "3493": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.getBlastGapCosts", "method_implementation": "{\n    return getAlignmentOption(GAPCOSTS);\n}", "repo_id": "9", "comment": "/**\n * Returns the actual string for the GAPCOSTS parameter which is used to build the URL\n *\n * @return the string representation of the GAPCOSTS parameter formatted for the URL\n */\n", "repo_name": "biojava-master/", "id": 3493, "method_signature": "String getBlastGapCosts()"}, "786": {"callee_method_names": ["Matrix.copy", "Matrix.getRowDimension", "Matrix.getRowDimension", "Matrix.getRowDimension", "Matrix.getColumnDimension", "Matrix.getColumnDimension", "Matrix.getColumnDimension", "Matrix.getRowDimension", "Matrix.getColumnDimension", "Matrix.getMatrix", "Matrix.getRowDimension", "Matrix.getRowDimension", "Matrix.getColumnDimension", "Matrix.getColumnDimension", "Matrix.get", "Matrix.get", "Matrix.getRowDimension", "Matrix.getColumnDimension"], "method_name": "OptimalCECPMain.permuteMatrix", "method_implementation": "{\n    //fix up cp to be positive\n    if (cpRows == 0 && cpCols == 0) {\n        return mat.copy();\n    }\n    if (cpRows < 0) {\n        cpRows = mat.getRowDimension() + cpRows;\n    }\n    if (cpRows < 0 || cpRows >= mat.getRowDimension()) {\n        throw new ArrayIndexOutOfBoundsException(String.format(\"Can't permute rows by %d: only %d rows.\", cpRows, mat.getRowDimension()));\n    }\n    if (cpCols < 0) {\n        cpCols = mat.getColumnDimension() + cpCols;\n    }\n    if (cpCols < 0 || cpCols >= mat.getColumnDimension()) {\n        throw new ArrayIndexOutOfBoundsException(String.format(\"Can't permute cols by %d: only %d rows.\", cpCols, mat.getColumnDimension()));\n    }\n    int[] rows = new int[mat.getRowDimension()];\n    for (int i = 0; i < rows.length; i++) {\n        rows[i] = (i + cpRows) % rows.length;\n    }\n    int[] cols = new int[mat.getColumnDimension()];\n    for (int i = 0; i < cols.length; i++) {\n        cols[i] = (i + cpCols) % cols.length;\n    }\n    Matrix newMat = mat.getMatrix(rows, cols);\n    assert (newMat.getRowDimension() == mat.getRowDimension());\n    assert (newMat.getColumnDimension() == mat.getColumnDimension());\n    assert (newMat.get(0, 0) == mat.get(cpRows % mat.getRowDimension(), cpCols % mat.getColumnDimension()));\n    return newMat;\n}", "repo_id": "9", "comment": "/**\n * Permutes <i>mat</i> by moving the rows of the matrix upwards by <i>cp</i>\n * rows.\n * @param mat The original matrix\n * @param cpRows Number of rows upward to move entries\n * @param cpCols Number of columns leftward to move entries\n * @return The permuted matrix\n */\n", "repo_name": "biojava-master/", "id": 786, "method_signature": "Matrix permuteMatrix(Matrix, int, int)"}, "1288": {"callee_method_names": ["Logger.debug"], "method_name": "BondMaker.makeBonds", "method_implementation": "{\n    logger.debug(\"Going to start making bonds\");\n    formPeptideBonds();\n    formNucleotideBonds();\n    formIntraResidueBonds();\n    trimBondLists();\n}", "repo_id": "9", "comment": "/**\n * Creates bond objects and corresponding references in Atom objects:\n * <li>\n * peptide bonds: inferred from sequence and distances\n * </li>\n * <li>\n * nucleotide bonds: inferred from sequence and distances\n * </li>\n * <li>\n * intra-group (residue) bonds: read from the chemical component dictionary, via {@link org.biojava.nbio.structure.chem.ChemCompProvider}\n * </li>\n */\n", "repo_name": "biojava-master/", "id": 1288, "method_signature": "void makeBonds()"}, "3063": {"callee_method_names": [], "method_name": "GeneSequence.setStrand", "method_implementation": "{\n    this.strand = strand;\n}", "repo_id": "9", "comment": "/**\n * @param strand the strand to set\n */\n", "repo_name": "biojava-master/", "id": 3063, "method_signature": "void setStrand(Strand)"}, "2138": {"callee_method_names": [], "method_name": "StructureImpl.getChain", "method_implementation": "{\n    return getChain(asymId, 0);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2138, "method_signature": "Chain getChain(String)"}, "2319": {"callee_method_ids": [1631, 1627, 1617, 1661, 1662, 1663, 1666, 1666], "callee_method_names": ["Structure.getChainByIndex", "SubunitClustererParameters.setStructureCoverageThreshold", "SubunitClustererParameters.setRMSDThreshold", "SubunitClustererParameters.setMinimumSequenceLength", "SubunitCluster.divideInternally", "SubunitCluster.size", "SubunitCluster.length", "SubunitCluster.getAlignedAtomsSubunit", "SubunitCluster.getAlignedAtomsSubunit"], "method_name": "TestSubunitCluster.testDivideInternally", "method_implementation": "{\n    Structure s = StructureIO.getStructure(\"4e3e\");\n    // Create a SubunitCluster for the chain\n    SubunitCluster sc1 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s));\n    SubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n    clustererParameters.setStructureCoverageThreshold(0.8);\n    clustererParameters.setRMSDThreshold(3.0);\n    clustererParameters.setMinimumSequenceLength(20);\n    // Clusters should be merged by identity\n    boolean divided = sc1.divideInternally(clustererParameters);\n    // Divided has to be true, and Subunit length shorter than half\n    assertTrue(divided);\n    assertEquals(2, sc1.size());\n    assertTrue(sc1.length() < 178);\n    assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length);\n}", "repo_id": "9", "comment": "/**\n * Test {@link SubunitCluster#divideInternally(SubunitClustererParameters)}\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2319, "method_signature": "void testDivideInternally()"}, "757": {"callee_method_names": [], "method_name": "CeParameters.getMaxNrIterationsForOptimization", "method_implementation": "{\n    return maxNrIterationsForOptimization;\n}", "repo_id": "9", "comment": "/**\n * Get the maximum nr of times the (slow) optimiziation of alignment should iterate. Default: unlimited\n *\n * @param maxNrIterationsForOptimization\n */\n", "repo_name": "biojava-master/", "id": 757, "method_signature": "int getMaxNrIterationsForOptimization()"}, "3640": {"callee_method_names": [], "method_name": "CoxInfo.getNaive_imat", "method_implementation": "{\n    return naive_imat;\n}", "repo_id": "9", "comment": "/**\n * @return the naive_imat\n */\n", "repo_name": "biojava-master/", "id": 3640, "method_signature": "double[][] getNaive_imat()"}, "3837": {"callee_method_names": ["Set<AminoAcidCompound>.add", "HashMap.get", "Set<AminoAcidCompound>.add", "HashMap.get", "Set<AminoAcidCompound>.add", "HashMap.get", "HashMap.put", "Set<AminoAcidCompound>.add", "Set<AminoAcidCompound>.add", "HashMap.put", "Set<AminoAcidCompound>.add", "Set<AminoAcidCompound>.add", "HashMap.put"], "method_name": "CaseFreeAminoAcidCompoundSet.addAmbiguousEquivalents", "method_implementation": "{\n    Set<AminoAcidCompound> equivalents;\n    AminoAcidCompound cOne, cTwo, cEither;\n    equivalents = new HashSet<AminoAcidCompound>();\n    equivalents.add(cOne = aminoAcidCompoundCache.get(one));\n    equivalents.add(cTwo = aminoAcidCompoundCache.get(two));\n    equivalents.add(cEither = aminoAcidCompoundCache.get(either));\n    equivalentsCache.put(cEither, equivalents);\n    equivalents = new HashSet<AminoAcidCompound>();\n    equivalents.add(cOne);\n    equivalents.add(cEither);\n    equivalentsCache.put(cOne, equivalents);\n    equivalents = new HashSet<AminoAcidCompound>();\n    equivalents.add(cTwo);\n    equivalents.add(cEither);\n    equivalentsCache.put(cTwo, equivalents);\n}", "repo_id": "9", "comment": "// helper method to initialize the equivalent sets for 2 amino acid compounds and their ambiguity compound\n", "repo_name": "biojava-master/", "id": 3837, "method_signature": "void addAmbiguousEquivalents(String, String, String)"}, "1472": {"callee_method_names": [], "method_name": "CrystalCell.transfToCrystal", "method_implementation": "{\n    getMTranspose().transform(v);\n}", "repo_id": "9", "comment": "/**\n * Transforms the given orthonormal basis coordinates into crystal coordinates.\n * See Giacovazzo eq 2.20 (or any linear algebra manual)\n * @param v\n */\n", "repo_name": "biojava-master/", "id": 1472, "method_signature": "void transfToCrystal(Tuple3d)"}, "281": {"callee_method_names": ["Atom[].getName", "Atom[].getName", "Atom[].getName", "Atom[].getName", "List<Atom[]>.add"], "method_name": "StructureUtil.findAtomLinkages", "method_implementation": "{\n    if (group1 == null || group2 == null) {\n        throw new IllegalArgumentException(\"Null group(s).\");\n    }\n    if (bondLengthTolerance < 0) {\n        throw new IllegalArgumentException(\"bondLengthTolerance cannot be negative.\");\n    }\n    List<Atom[]> ret = new ArrayList<Atom[]>();\n    if (potentialNamesOfAtomOnGroup1 == null) {\n        // if empty name, search for all atoms\n        potentialNamesOfAtomOnGroup1 = getAtomNames(group1);\n    }\n    if (potentialNamesOfAtomOnGroup2 == null) {\n        // if empty name, search for all atoms\n        potentialNamesOfAtomOnGroup2 = getAtomNames(group2);\n    }\n    for (String namesOfAtomOnGroup1 : potentialNamesOfAtomOnGroup1) {\n        for (String namesOfAtomOnGroup2 : potentialNamesOfAtomOnGroup2) {\n            Atom[] atoms = findLinkage(group1, group2, namesOfAtomOnGroup1, namesOfAtomOnGroup2, bondLengthTolerance);\n            if (atoms != null) {\n                if (ignoreNCLinkage && ((\"N\".equals(atoms[0].getName()) && \"C\".equals(atoms[1].getName())) || (\"C\".equals(atoms[0].getName()) && \"N\".equals(atoms[1].getName())))) {\n                    continue;\n                }\n                ret.add(atoms);\n            }\n        }\n    }\n    return ret;\n}", "repo_id": "9", "comment": "/**\n * Find linkages between two groups within tolerance of bond length,\n * from potential atoms.\n * @param group1 the first {@link Group}.\n * @param group2 the second {@link Group}.\n * @param potentialNamesOfAtomOnGroup1 potential names of the atom on the first group.\n * \t\t  If null, search all atoms on the first group.\n * @param potentialNamesOfAtomOnGroup2 potential names of the atom on the second group.\n * \t\t  If null, search all atoms on the second group.\n * @param ignoreNCLinkage true to ignore all N-C linkages\n * @param bondLengthTolerance bond length error tolerance.\n * @return a list, each element of which is an array of two Atoms that form bond\n * between each other.\n */\n", "repo_name": "biojava-master/", "id": 281, "method_signature": "List<Atom[]> findAtomLinkages(Group, Group, List, List, boolean, double)"}, "2329": {"callee_method_ids": [638, 635, 641, 628, 641, 628], "callee_method_names": ["AtomCache.setFetchBehavior", "AtomCache.setObsoleteBehavior", "AtomCache.setFiletype", "AtomCache.getStructure", "AtomCache.setFiletype", "AtomCache.getStructure"], "method_name": "TestAtomCache.testFetchCurrent1CMW", "method_implementation": "{\n    cache.setFetchBehavior(FetchBehavior.FETCH_FILES);\n    cache.setObsoleteBehavior(ObsoleteBehavior.FETCH_CURRENT);\n    // OBSOLETE PDB; should throw an exception\n    cache.setFiletype(StructureFiletype.PDB);\n    try {\n        cache.getStructure(\"1CMW\");\n        fail(\"Obsolete structure should throw exception\");\n    } catch (IOException e) {\n    }\n    cache.setFiletype(StructureFiletype.CIF);\n    try {\n        cache.getStructure(\"1CMW\");\n        fail(\"Obsolete structure should throw exception\");\n    } catch (IOException e) {\n    }\n}", "repo_id": "9", "comment": "// note: we expect an IOException because 1CMW is obsolete and hasn't got a replacement\n", "repo_name": "biojava-master/", "id": 2329, "method_signature": "void testFetchCurrent1CMW()"}, "148": {"callee_method_ids": [619, 619, 619, 784, 781, 802], "callee_method_names": ["AtomCache.getAtoms", "AtomCache.getAtoms", "AtomCache.getAtoms", "OptimalCECPMain.alignPermuted", "OptimalCECPMain.getParameters", "CeMain.align"], "method_name": "OptimalCECPMainTest.testUnpermuted", "method_implementation": "{\n    String name1, name2;\n    //small case\n    name1 = \"d1qdmA1\";\n    name2 = \"d1nklA_\";\n    Atom[] ca1 = cache.getAtoms(name1);\n    Atom[] ca2 = cache.getAtoms(name2);\n    // Calculate all alignments initially\n    OptimalCECPMain cecp = new OptimalCECPMain();\n    Atom[] ca2clone = cache.getAtoms(name2);\n    AFPChain cp0 = cecp.alignPermuted(ca1, ca2clone, cecp.getParameters(), 0);\n    CeMain ce = new CeMain();\n    AFPChain nocp = ce.align(ca1, ca2);\n    Assert.assertEquals(nocp, cp0);\n}", "repo_id": "9", "comment": "/**\n * Basic test that alignPermuted(..., 0) is equivalent to a normal CE alignment.\n *\n * Also checks that {@link AFPChain#equals(Object)} is working the way we expect.\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 148, "method_signature": "void testUnpermuted()"}, "3504": {"callee_method_ids": [3502], "callee_method_names": ["RemoteHmmerScan.scan", "SortedSet<HmmerResult>.size"], "method_name": "TestRemoteHmmerScan.testHmmerWs", "method_implementation": "{\n    ProteinSequence seq = new ProteinSequence(TEST_SEQ);\n    // now we submit this sequence to the Hmmer web site\n    RemoteHmmerScan hmmer = new RemoteHmmerScan();\n    SortedSet<HmmerResult> results = hmmer.scan(seq);\n    assertNotNull(results);\n    // 2 results (domains) for P30340 (PDB 1smt) as of Jan 2018\n    assertEquals(2, results.size());\n    boolean gotSh2Domain = false;\n    for (HmmerResult hmmerResult : results) {\n        if (hmmerResult.getName().equals(\"HTH_5\")) {\n            gotSh2Domain = true;\n        }\n    }\n    assertTrue(\"A HTH_5 domain should be present as one of the hmmer scan matches\", gotSh2Domain);\n}", "repo_id": "9", "comment": "// Ignoring not to depend on another external resource that goes down every so often. Can still be run manually\n", "repo_name": "biojava-master/", "id": 3504, "method_signature": "void testHmmerWs()"}, "519": {"callee_method_names": ["ArrayList.clear"], "method_name": "StructureAlignmentFactory.clearAlgorithms", "method_implementation": "{\n    algorithms.clear();\n}", "repo_id": "9", "comment": "/**\n * Removes all algorithms from the list\n */\n", "repo_name": "biojava-master/", "id": 519, "method_signature": "void clearAlgorithms()"}, "743": {"callee_method_names": [], "method_name": "CeCalculatorEnhanced.getMatMatrix", "method_implementation": "{\n    return mat;\n}", "repo_id": "9", "comment": "/**\n * Caution: this matrix is overwriten with very different data at several\n * points in the alignment algorithm. After\n * {@link #initSumOfDistances(int, int, int, int, Atom[], Atom[]) initSumOfDistances}\n * is run, this will hold the distance matrix between AFPs.\n * @return mat\n */\n", "repo_name": "biojava-master/", "id": 743, "method_signature": "double[][] getMatMatrix()"}, "1409": {"callee_method_names": ["CrystalCell.getGamma"], "method_name": "PDBCrystallographicInfo.getGamma", "method_implementation": "{\n    return (float) cell.getGamma();\n}", "repo_id": "9", "comment": "/**\n * @return the unit cell parameter gamma (degrees)\n */\n", "repo_name": "biojava-master/", "id": 1409, "method_signature": "float getGamma()"}, "578": {"callee_method_ids": [489, 490, 487], "callee_method_names": ["AFPChain.getOptAln", "AFPChain.getOptLen", "AFPChain.getBlockNum"], "method_name": "AlignmentTools.isSequentialAlignment", "method_implementation": "{\n    int[][][] optAln = afpChain.getOptAln();\n    int[] alnLen = afpChain.getOptLen();\n    int blocks = afpChain.getBlockNum();\n    //trivial case\n    if (blocks < 1)\n        return true;\n    if (alnLen[0] < 1)\n        return true;\n    // Check that blocks are sequential\n    if (checkWithinBlocks) {\n        for (int block = 0; block < blocks; block++) {\n            //skip empty blocks\n            if (alnLen[block] < 1)\n                continue;\n            int prevRes1 = optAln[block][0][0];\n            int prevRes2 = optAln[block][1][0];\n            for (int pos = 1; pos < alnLen[block]; pos++) {\n                int currRes1 = optAln[block][0][pos];\n                int currRes2 = optAln[block][1][pos];\n                if (currRes1 < prevRes1) {\n                    return false;\n                }\n                if (currRes2 < prevRes2) {\n                    return false;\n                }\n                prevRes1 = currRes1;\n                prevRes2 = currRes2;\n            }\n        }\n    }\n    // Check that blocks are sequential\n    int prevRes1 = optAln[0][0][alnLen[0] - 1];\n    int prevRes2 = optAln[0][1][alnLen[0] - 1];\n    for (int block = 1; block < blocks; block++) {\n        //skip empty blocks\n        if (alnLen[block] < 1)\n            continue;\n        if (optAln[block][0][0] < prevRes1) {\n            return false;\n        }\n        if (optAln[block][1][0] < prevRes2) {\n            return false;\n        }\n        prevRes1 = optAln[block][0][alnLen[block] - 1];\n        prevRes2 = optAln[block][1][alnLen[block] - 1];\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Checks that the alignment given by afpChain is sequential. This means\n * that the residue indices of both proteins increase monotonically as\n * a function of the alignment position (ie both proteins are sorted).\n *\n * This will return false for circularly permuted alignments or other\n * non-topological alignments. It will also return false for cases where\n * the alignment itself is sequential but it is not stored in the afpChain\n * in a sorted manner.\n *\n * Since algorithms which create non-sequential alignments split the\n * alignment into multiple blocks, some computational time can be saved\n * by only checking block boundaries for sequentiality. Setting\n * <tt>checkWithinBlocks</tt> to <tt>true</tt> makes this function slower,\n * but detects AFPChains with non-sequential blocks.\n *\n * Note that this method should give the same results as\n * {@link AFPChain#isSequentialAlignment()}. However, the AFPChain version\n * relies on the StructureAlignment algorithm correctly setting this\n * parameter, which is sadly not always the case.\n *\n * @param afpChain An alignment\n * @param checkWithinBlocks Indicates whether individual blocks should be\n * \tchecked for sequentiality\n * @return True if the alignment is sequential.\n */\n", "repo_name": "biojava-master/", "id": 578, "method_signature": "boolean isSequentialAlignment(AFPChain, boolean)"}, "1317": {"callee_method_names": [], "method_name": "FileParsingParameters.isHeaderOnly", "method_implementation": "{\n    return headerOnly;\n}", "repo_id": "9", "comment": "/**\n * Parse only the PDB file header out of the files\n *\n * @return flag\n */\n", "repo_name": "biojava-master/", "id": 1317, "method_signature": "boolean isHeaderOnly()"}, "1767": {"callee_method_names": [], "method_name": "PDBHeader.getPdbId", "method_implementation": "{\n    return pdbId;\n}", "repo_id": "9", "comment": "/**\n * Gets the PDB identifier for this protein structure.\n *\n * @return the {@link PdbId} PDB identifier\n * @see #setPdbId(PdbId)\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 1767, "method_signature": "PdbId getPdbId()"}, "3060": {"callee_method_names": [], "method_name": "GeneSequence.getParentChromosomeSequence", "method_implementation": "{\n    return chromosomeSequence;\n}", "repo_id": "9", "comment": "/**\n * The parent ChromosomeSequence which contains the actual DNA sequence data\n * @return Chromosome sequence\n */\n", "repo_name": "biojava-master/", "id": 3060, "method_signature": "ChromosomeSequence getParentChromosomeSequence()"}, "308": {"callee_method_names": [], "method_name": "ModificationConditionImpl.getLinkages", "method_implementation": "{\n    return linkages;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}}\n */\n", "repo_name": "biojava-master/", "id": 308, "method_signature": "List<ModificationLinkage> getLinkages()"}, "1046": {"callee_method_names": ["Structure.getPolyChainByPDB", "ResidueNumber.getChainName", "Chain.getGroupByPDB"], "method_name": "StructureTools.getGroupByPDBResidueNumber", "method_implementation": "{\n    if (struc == null || pdbResNum == null) {\n        throw new IllegalArgumentException(\"Null argument(s).\");\n    }\n    Chain chain = struc.getPolyChainByPDB(pdbResNum.getChainName());\n    return chain.getGroupByPDB(pdbResNum);\n}", "repo_id": "9", "comment": "/**\n * Get a group represented by a ResidueNumber.\n *\n * @param struc\n *            a {@link Structure}\n * @param pdbResNum\n *            a {@link ResidueNumber}\n * @return a group in the structure that is represented by the pdbResNum.\n * @throws StructureException\n *             if the group cannot be found.\n */\n", "repo_name": "biojava-master/", "id": 1046, "method_signature": "Group getGroupByPDBResidueNumber(Structure, ResidueNumber)"}, "3352": {"callee_method_names": ["NavigableMap<Double, Color>.entrySet"], "method_name": "GradientMapper.entrySet", "method_implementation": "{\n    return mapping.entrySet();\n}", "repo_id": "9", "comment": "/**\n * @return\n * @see java.util.Map#entrySet()\n */\n", "repo_name": "biojava-master/", "id": 3352, "method_signature": "Set<java.util.Map.Entry<Double,Color>> entrySet()"}, "1282": {"callee_method_names": [], "method_name": "MmtfSummaryDataBean.setNumBonds", "method_implementation": "{\n    this.numBonds = numBonds;\n}", "repo_id": "9", "comment": "/**\n * @param numBonds the number of covalent bonds in the structure\n */\n", "repo_name": "biojava-master/", "id": 1282, "method_signature": "void setNumBonds(int)"}, "99": {"callee_method_names": ["S.getAsList", "SubstitutionMatrix<C>.getRow"], "method_name": "SubstitutionMatrixScorer.getMinScore", "method_implementation": "{\n    // assume nothing about the matrix\n    double score = 0;\n    for (C queryC : query.getAsList()) {\n        short min = Short.MAX_VALUE;\n        for (Short value : matrix.getRow(queryC).values()) {\n            if (value < min)\n                min = value;\n        }\n        score += min;\n    }\n    return score;\n}", "repo_id": "9", "comment": "/**\n * @return The minimum score the query could be assigned when aligned against any target sequence.\n */\n", "repo_name": "biojava-master/", "id": 99, "method_signature": "double getMinScore()"}, "3315": {"callee_method_names": [], "method_name": "JMatrixPanel.getCellColor", "method_implementation": "{\n    return cellColor;\n}", "repo_id": "9", "comment": "/**\n * @return the color mapping of the JMatrixPanel\n */\n", "repo_name": "biojava-master/", "id": 3315, "method_signature": "ContinuousColorMapper getCellColor()"}, "2738": {"callee_method_names": [], "method_name": "EmblRecord.getProjectIdentifier", "method_implementation": "{\n    return projectIdentifier;\n}", "repo_id": "9", "comment": "/**\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2738, "method_signature": "String getProjectIdentifier()"}, "2208": {"callee_method_ids": [1335, 1335], "callee_method_names": ["ResidueNumber.toPDB", "ResidueNumber.toPDB"], "method_name": "ResidueNumberTest.testToPDB", "method_implementation": "{\n    ResidueNumber instance = new ResidueNumber(\"A\", 42, ' ');\n    ResidueNumber instance2 = new ResidueNumber(\"A\", 42, null);\n    String expResult = \"A  42  \";\n    String result1 = instance.toPDB();\n    Assert.assertEquals(expResult, result1);\n    String result2 = instance2.toPDB();\n    Assert.assertEquals(expResult, result2);\n}", "repo_id": "9", "comment": "/**\n * Test of toPDB method, of class ResidueNumber.\n */\n", "repo_name": "biojava-master/", "id": 2208, "method_signature": "void testToPDB()"}, "1125": {"callee_method_names": ["List<String>.clear"], "method_name": "LocalPDBDirectory.clearExtensions", "method_implementation": "{\n    extensions.clear();\n}", "repo_id": "9", "comment": "/**\n * clear the supported file extensions\n */\n", "repo_name": "biojava-master/", "id": 1125, "method_signature": "void clearExtensions()"}, "1438": {"callee_method_ids": [907], "callee_method_names": ["Logger.warn", "StructureInterfaceList.setChainOrigNamesMap"], "method_name": "CrystalBuilder.getUniqueInterfaces", "method_implementation": "{\n    StructureInterfaceList set = new StructureInterfaceList();\n    // certain structures in the PDB are not macromolecules (contain no polymeric chains at all), e.g. 1ao2\n    // with the current mmCIF parsing, those will be empty since purely non-polymeric chains are removed\n    // see commit e9562781f23da0ebf3547146a307d7edd5741090\n    if (numPolyChainsAu == 0) {\n        logger.warn(\"No chains present in the structure! No interfaces will be calculated\");\n        return set;\n    }\n    // pass the chainOrigNames map in NCS case so that StructureInterfaceList can deal with original to NCS chain names conversion\n    if (chainOrigNames != null) {\n        set.setChainOrigNamesMap(chainOrigNames);\n    }\n    // initialising the visited ArrayList for keeping track of symmetry redundancy\n    initialiseVisited();\n    // the isCrystallographic() condition covers 3 cases:\n    // a) entries with expMethod X-RAY/other diffraction and defined crystalCell (most usual case)\n    // b) entries with expMethod null but defined crystalCell (e.g. PDB file with CRYST1 record but no expMethod annotation)\n    // c) entries with expMethod not X-RAY (e.g. NMR) and defined crystalCell (NMR entries do have a dummy CRYST1 record \"1 1 1 90 90 90 P1\")\n    // d) isCrystallographic will be false if the structure is crystallographic but the space group was not recognized\n    calcInterfacesCrystal(set, cutoff);\n    return set;\n}", "repo_id": "9", "comment": "/**\n * Returns the list of unique interfaces that the given Structure has upon\n * generation of all crystal symmetry mates. An interface is defined as any pair of chains\n * that contact, i.e. for which there is at least a pair of atoms (one from each chain) within\n * the given cutoff distance.\n * @param cutoff the distance cutoff for 2 chains to be considered in contact\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1438, "method_signature": "StructureInterfaceList getUniqueInterfaces(double)"}, "1908": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.setRmsdThreshold", "method_implementation": "{\n    this.rmsdThreshold = rmsdThreshold;\n}", "repo_id": "9", "comment": "/**\n * @param rmsdThreshold\n *            the rmsdThreshold to set\n */\n", "repo_name": "biojava-master/", "id": 1908, "method_signature": "void setRmsdThreshold(double)"}, "166": {"callee_method_ids": [1330], "callee_method_names": ["FileParsingParameters.setCreateAtomBonds", "PDBFileReader.setFileParsingParameters", "PDBFileReader.getStructureById", "Structure.getPolyChain", "Group.getAtom", "Atom.getBonds", "Structure.getPolyChain", "Group.getAtom", "Atom.getBonds"], "method_name": "TestBondParsing.testIssue929", "method_implementation": "{\n    PDBFileReader reader = new PDBFileReader();\n    FileParsingParameters params = new FileParsingParameters();\n    params.setCreateAtomBonds(true);\n    reader.setFileParsingParameters(params);\n    Structure s = reader.getStructureById(\"1a4w\");\n    Group cysB = s.getPolyChain(\"B\").getAtomGroup(118);\n    Atom sgCysB = cysB.getAtom(\"SG\");\n    assertEquals(2, sgCysB.getBonds().size());\n    Group cysA = s.getPolyChain(\"A\").getAtomGroup(1);\n    Atom sgCysA = cysA.getAtom(\"SG\");\n    assertEquals(2, sgCysA.getBonds().size());\n}", "repo_id": "9", "comment": "/**\n * Integration test for SS bond parsing in PDB-format, where author chain ids and asym ids differ and can cause\n * problems. See https://github.com/biojava/biojava/issues/929\n */\n", "repo_name": "biojava-master/", "id": 166, "method_signature": "void testIssue929()"}, "1779": {"callee_method_names": [], "method_name": "PDBHeader.setDescription", "method_implementation": "{\n    this.description = description;\n}", "repo_id": "9", "comment": "/**\n * @deprecated will be removed later. Use {@link #getKeywords()} if you use\n *  <code>description</code> to keep the keywords.\n *  @param description\n */\n", "repo_name": "biojava-master/", "id": 1779, "method_signature": "void setDescription(String)"}, "975": {"callee_method_names": ["PdbxStructOperList.getRowCount", "PdbxStructOperList.getMatrix11", "PdbxStructOperList.getMatrix12", "PdbxStructOperList.getMatrix13", "PdbxStructOperList.getMatrix21", "PdbxStructOperList.getMatrix22", "PdbxStructOperList.getMatrix23", "PdbxStructOperList.getMatrix31", "PdbxStructOperList.getMatrix32", "PdbxStructOperList.getMatrix33", "PdbxStructOperList.getVector1", "PdbxStructOperList.getVector2", "PdbxStructOperList.getVector3", "Map<String, Matrix4d>.put", "PdbxStructOperList.getId", "Logger.warn", "PdbxStructOperList.getId", "int.getMessage", "PdbxStructAssembly.getId", "ArrayList<BiologicalAssemblyTransformation>.addAll", "ArrayList<BiologicalAssemblyTransformation>.trimToSize"], "method_name": "BiologicalAssemblyBuilder.getBioUnitTransformationList", "method_implementation": "{\n    init();\n    // first we populate the list of all operators from pdbx_struct_oper_list so that we can then\n    // get them from getBioUnitTransformationsListUnaryOperators() and getBioUnitTransformationsListBinaryOperators()\n    for (int i = 0; i < pdbxStructOperList.getRowCount(); i++) {\n        try {\n            Matrix4d m = new Matrix4d();\n            m.m00 = pdbxStructOperList.getMatrix11().get(i);\n            m.m01 = pdbxStructOperList.getMatrix12().get(i);\n            m.m02 = pdbxStructOperList.getMatrix13().get(i);\n            m.m10 = pdbxStructOperList.getMatrix21().get(i);\n            m.m11 = pdbxStructOperList.getMatrix22().get(i);\n            m.m12 = pdbxStructOperList.getMatrix23().get(i);\n            m.m20 = pdbxStructOperList.getMatrix31().get(i);\n            m.m21 = pdbxStructOperList.getMatrix32().get(i);\n            m.m22 = pdbxStructOperList.getMatrix33().get(i);\n            m.m03 = pdbxStructOperList.getVector1().get(i);\n            m.m13 = pdbxStructOperList.getVector2().get(i);\n            m.m23 = pdbxStructOperList.getVector3().get(i);\n            m.m30 = 0;\n            m.m31 = 0;\n            m.m32 = 0;\n            m.m33 = 1;\n            allTransformations.put(pdbxStructOperList.getId().get(i), m);\n        } catch (NumberFormatException e) {\n            logger.warn(\"Could not parse a matrix value from pdbx_struct_oper_list for id {}. The operator id will be ignored. Error: {}\", pdbxStructOperList.getId().get(i), e.getMessage());\n        }\n    }\n    String assemblyId = pdbxStructAssembly.getId().get(assemblyIndex);\n    ArrayList<BiologicalAssemblyTransformation> transformations = getBioUnitTransformationsListUnaryOperators(assemblyId, pdbxStructAssemblyGen);\n    transformations.addAll(getBioUnitTransformationsListBinaryOperators(assemblyId, pdbxStructAssemblyGen));\n    transformations.trimToSize();\n    return transformations;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of transformation matrices for the generation of a macromolecular\n * assembly for the specified assembly Id.\n *\n * @param pdbxStructAssembly\n * @param assemblyIndex\n * @param pdbxStructAssemblyGen\n * @param pdbxStructOperList\n * @return list of transformation matrices to generate macromolecular assembly\n */\n", "repo_name": "biojava-master/", "id": 975, "method_signature": "List<BiologicalAssemblyTransformation> getBioUnitTransformationList(PdbxStructAssembly, int, PdbxStructAssemblyGen, PdbxStructOperList)"}, "1256": {"callee_method_ids": [1280, 1278, 1284, 1282], "callee_method_names": ["MmtfSummaryDataBean.setAllAtoms", "MmtfSummaryDataBean.setAllChains", "MmtfSummaryDataBean.setChainIdToIndexMap", "Structure.nrModels", "Structure.getModel", "List<Chain>.addAll", "Chain.getId", "Map<String, Integer>.containsKey", "Map<String, Integer>.put", "Chain.getAtomGroups", "List<Atom>.add", "Atom.getBonds", "Atom.getBonds", "MmtfSummaryDataBean.setNumBonds"], "method_name": "MmtfUtils.getStructureInfo", "method_implementation": "{\n    MmtfSummaryDataBean mmtfSummaryDataBean = new MmtfSummaryDataBean();\n    // Get all the atoms\n    List<Atom> theseAtoms = new ArrayList<>();\n    List<Chain> allChains = new ArrayList<>();\n    Map<String, Integer> chainIdToIndexMap = new LinkedHashMap<>();\n    int chainCounter = 0;\n    int bondCount = 0;\n    mmtfSummaryDataBean.setAllAtoms(theseAtoms);\n    mmtfSummaryDataBean.setAllChains(allChains);\n    mmtfSummaryDataBean.setChainIdToIndexMap(chainIdToIndexMap);\n    for (int i = 0; i < structure.nrModels(); i++) {\n        List<Chain> chains = structure.getModel(i);\n        allChains.addAll(chains);\n        for (Chain chain : chains) {\n            String idOne = chain.getId();\n            if (!chainIdToIndexMap.containsKey(idOne)) {\n                chainIdToIndexMap.put(idOne, chainCounter);\n            }\n            chainCounter++;\n            for (Group g : chain.getAtomGroups()) {\n                for (Atom atom : getAtomsForGroup(g)) {\n                    theseAtoms.add(atom);\n                    // If both atoms are in the group\n                    if (atom.getBonds() != null) {\n                        bondCount += atom.getBonds().size();\n                    }\n                }\n            }\n        }\n    }\n    // Assumes all bonds are referenced twice\n    mmtfSummaryDataBean.setNumBonds(bondCount / 2);\n    return mmtfSummaryDataBean;\n}", "repo_id": "9", "comment": "/**\n * Get summary information for the structure.\n * @param structure the structure for which to get the information.\n */\n", "repo_name": "biojava-master/", "id": 1256, "method_signature": "MmtfSummaryDataBean getStructureInfo(Structure)"}, "1252": {"callee_method_names": ["Atom.getBonds", "Atom.getBonds", "int.getOther", "List<Atom>.indexOf", "List<Atom>.indexOf", "List<Atom>.indexOf"], "method_name": "MmtfUtils.getNumBondsInGroup", "method_implementation": "{\n    int bondCounter = 0;\n    for (Atom atom : atomsInGroup) {\n        if (atom.getBonds() == null) {\n            continue;\n        }\n        for (Bond bond : atom.getBonds()) {\n            // Now set the bonding information.\n            Atom other = bond.getOther(atom);\n            // If both atoms are in the group\n            if (atomsInGroup.indexOf(other) != -1) {\n                Integer firstBondIndex = atomsInGroup.indexOf(atom);\n                Integer secondBondIndex = atomsInGroup.indexOf(other);\n                // Don't add the same bond twice\n                if (firstBondIndex < secondBondIndex) {\n                    bondCounter++;\n                }\n            }\n        }\n    }\n    return bondCounter;\n}", "repo_id": "9", "comment": "/**\n * Find the number of bonds in a group\n * @param atomsInGroup the list of atoms in the group\n * @return the number of atoms in the group\n */\n", "repo_name": "biojava-master/", "id": 1252, "method_signature": "int getNumBondsInGroup(List)"}, "149": {"callee_method_ids": [619, 619, 773, 476], "callee_method_names": ["Method.setAccessible", "CeCPMain.getParameters", "CECPParameters.setDuplicationHint", "AtomCache.getAtoms", "AtomCache.getAtoms", "CeCPMain.align", "AFPChain.clone", "Method.invoke"], "method_name": "OptimalCECPMainTest.testPermuteOptAlnUnpermuted", "method_implementation": "{\n    //test private member using reflection\n    Method permuteOptAln = OptimalCECPMain.class.getDeclaredMethod(\"permuteOptAln\", AFPChain.class, int.class);\n    permuteOptAln.setAccessible(true);\n    String name1, name2;\n    name1 = \"d1qdmA1\";\n    name2 = \"d1nklA_\";\n    CeCPMain ce = (CeCPMain) StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n    CECPParameters param = (CECPParameters) ce.getParameters();\n    param.setDuplicationHint(DuplicationHint.RIGHT);\n    Atom[] ca1 = cache.getAtoms(name1);\n    Atom[] ca2 = cache.getAtoms(name2);\n    AFPChain afpChain = ce.align(ca1, ca2);\n    AFPChain afpChain2 = (AFPChain) afpChain.clone();\n    permuteOptAln.invoke(null, afpChain2, 0);\n    Assert.assertEquals(\"Permuting by 0 changed the alignment!\", afpChain, afpChain2);\n}", "repo_id": "9", "comment": "/**\n * Very basic test of {@link OptimalCECPMain#permuteOptAln(AFPChain, int)}\n *\n * It should do nothing on unpermuted alignments.\n * @throws NoSuchMethodException\n * @throws SecurityException\n * @throws StructureException\n * @throws IOException\n * @throws InvocationTargetException\n * @throws IllegalAccessException\n * @throws IllegalArgumentException\n */\n", "repo_name": "biojava-master/", "id": 149, "method_signature": "void testPermuteOptAlnUnpermuted()"}, "3378": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorDn.getOrientationName", "method_implementation": "{\n    if (index == 0 && \"D2\".equals(getAxisTransformation().getRotationGroup().getPointGroup())) {\n        return \"Front C2 axis\";\n    } else {\n        return getPolyhedron().getViewName(index);\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the name of a specific orientation\n * @param index orientation index\n * @return name of orientation\n */\n", "repo_name": "biojava-master/", "id": 3378, "method_signature": "String getOrientationName(int)"}, "348": {"callee_method_names": ["Atom.setX", "Atom.getY", "Atom.getZ", "Atom.getZ", "Atom.getY", "Atom.setY", "Atom.getZ", "Atom.getX", "Atom.getX", "Atom.getZ", "Atom.setZ", "Atom.getX", "Atom.getY", "Atom.getY", "Atom.getX"], "method_name": "Calc.vectorProduct", "method_implementation": "{\n    Atom c = new AtomImpl();\n    c.setX(a.getY() * b.getZ() - a.getZ() * b.getY());\n    c.setY(a.getZ() * b.getX() - a.getX() * b.getZ());\n    c.setZ(a.getX() * b.getY() - a.getY() * b.getX());\n    return c;\n}", "repo_id": "9", "comment": "/**\n * Vector product (cross product).\n *\n * @param a\n *            an Atom object\n * @param b\n *            an Atom object\n * @return an Atom object\n */\n", "repo_name": "biojava-master/", "id": 348, "method_signature": "Atom vectorProduct(Atom, Atom)"}, "3717": {"callee_method_names": ["Color[].equals"], "method_name": "WorkSheet.setMetaDataColumnsAfterColumn", "method_implementation": "{\n    ArrayList<String> cols = this.getColumns();\n    boolean metacolumns = false;\n    for (String col : cols) {\n        if (col.equals(column) && !metacolumns) {\n            metacolumns = true;\n        }\n        if (metacolumns) {\n            this.markMetaDataColumn(col);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @param column\n */\n", "repo_name": "biojava-master/", "id": 3717, "method_signature": "void setMetaDataColumnsAfterColumn(String)"}, "2910": {"callee_method_names": [], "method_name": "AbstractSequence.getOriginalHeader", "method_implementation": "{\n    return originalHeader;\n}", "repo_id": "9", "comment": "/**\n * @return the originalHeader\n */\n", "repo_name": "biojava-master/", "id": 2910, "method_signature": "String getOriginalHeader()"}, "2080": {"callee_method_names": ["Random.nextInt", "Random.nextInt", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.contains", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.remove", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.contains", "List<List<Integer>>.get", "List<Integer>.remove", "List<List<Integer>>.get"], "method_name": "SymmOptimizer.expandBlock", "method_implementation": "{\n    boolean moved = false;\n    // Select between right (0) or left (1)\n    int rl = rnd.nextInt(2);\n    // Residue as a pivot\n    int res = rnd.nextInt(length);\n    switch(rl) {\n        case 0:\n            int rightBoundary = res;\n            int[] previousPos = new int[order];\n            for (int su = 0; su < order; su++) previousPos[su] = -1;\n            // Search a position to the right that has at minimum Rmin\n            while (length - 1 > rightBoundary) {\n                int noncontinuous = 0;\n                for (int su = 0; su < order; su++) {\n                    if (block.get(su).get(rightBoundary) == null) {\n                        continue;\n                    } else if (previousPos[su] == -1) {\n                        previousPos[su] = block.get(su).get(rightBoundary);\n                    } else if (block.get(su).get(rightBoundary) > previousPos[su] + 1) {\n                        noncontinuous++;\n                    }\n                }\n                if (noncontinuous < Rmin)\n                    rightBoundary++;\n                else\n                    break;\n            }\n            if (rightBoundary > 0)\n                rightBoundary--;\n            // Expand the block with the residues at the repeat boundaries\n            for (int su = 0; su < order; su++) {\n                Integer residueR = block.get(su).get(rightBoundary);\n                if (residueR == null) {\n                    if (rightBoundary == length - 1)\n                        block.get(su).add(null);\n                    else\n                        block.get(su).add(rightBoundary + 1, null);\n                } else if (freePool.contains(residueR + 1)) {\n                    Integer residueAdd = residueR + 1;\n                    if (rightBoundary == length - 1) {\n                        block.get(su).add(residueAdd);\n                    } else\n                        block.get(su).add(rightBoundary + 1, residueAdd);\n                    freePool.remove(residueAdd);\n                } else {\n                    if (rightBoundary == length - 1)\n                        block.get(su).add(null);\n                    else\n                        block.get(su).add(rightBoundary + 1, null);\n                }\n            }\n            length++;\n            moved = true;\n            break;\n        case 1:\n            int leftBoundary = res;\n            int[] nextPos = new int[order];\n            for (int su = 0; su < order; su++) nextPos[su] = -1;\n            // Search a position to the right that has at minimum Rmin\n            while (leftBoundary > 0) {\n                int noncontinuous = 0;\n                for (int su = 0; su < order; su++) {\n                    if (block.get(su).get(leftBoundary) == null) {\n                        continue;\n                    } else if (nextPos[su] == -1) {\n                        nextPos[su] = block.get(su).get(leftBoundary);\n                    } else if (block.get(su).get(leftBoundary) < nextPos[su] - 1) {\n                        noncontinuous++;\n                    }\n                }\n                if (noncontinuous < Rmin)\n                    leftBoundary--;\n                else\n                    break;\n            }\n            // Expand the block with the residues at the repeat boundaries\n            for (int su = 0; su < order; su++) {\n                Integer residueL = block.get(su).get(leftBoundary);\n                if (residueL == null) {\n                    block.get(su).add(leftBoundary, null);\n                } else if (freePool.contains(residueL - 1)) {\n                    Integer residueAdd = residueL - 1;\n                    block.get(su).add(leftBoundary, residueAdd);\n                    freePool.remove(residueAdd);\n                } else {\n                    block.get(su).add(leftBoundary, null);\n                }\n            }\n            length++;\n            moved = true;\n            break;\n    }\n    if (moved)\n        return !checkGaps();\n    return moved;\n}", "repo_id": "9", "comment": "/**\n * It extends the alignment one position to the right or to the left of a\n * randomly selected position by moving the consecutive residues of each\n * repeat (if present) from the freePool to the block.\n * <p>\n * If there are not enough residues in the freePool it introduces gaps.\n */\n", "repo_name": "biojava-master/", "id": 2080, "method_signature": "boolean expandBlock()"}, "1811": {"callee_method_names": ["ReadWriteLock.readLock", "Logger.trace", "Logger.trace", "ReadWriteLock.readLock", "ReadWriteLock.writeLock", "Logger.trace", "Logger.trace", "ReadWriteLock.writeLock"], "method_name": "EcodInstallation.ensureDomainsFileInstalled", "method_implementation": "{\n    // Quick check for availability\n    domainsFileLock.readLock().lock();\n    logger.trace(\"LOCK readlock\");\n    try {\n        if (allDomains != null) {\n            return;\n        }\n    } finally {\n        logger.trace(\"UNLOCK readlock\");\n        domainsFileLock.readLock().unlock();\n    }\n    // Download domains\n    domainsFileLock.writeLock().lock();\n    logger.trace(\"LOCK writelock\");\n    try {\n        if (!domainsAvailable()) {\n            downloadDomains();\n        }\n        parseDomains();\n    } finally {\n        logger.trace(\"UNLOCK writelock\");\n        domainsFileLock.writeLock().unlock();\n    }\n}", "repo_id": "9", "comment": "// Populates allDomains\n", "repo_name": "biojava-master/", "id": 1811, "method_signature": "void ensureDomainsFileInstalled()"}, "3389": {"callee_method_names": ["Polyhedron.getLineLoops", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.drawPolyhedron", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    Point3d[] vertices = getPolyhedronVertices();\n    int index = 0;\n    double width = getMaxExtension() * 0.015;\n    for (int[] lineLoop : polyhedron.getLineLoops()) {\n        s.append(\"draw polyhedron\");\n        s.append(name);\n        s.append(index++);\n        s.append(\" line\");\n        for (int i : lineLoop) {\n            s.append(getJmolPoint(vertices[i]));\n        }\n        s.append(\"width \");\n        s.append(fDot2(width));\n        s.append(\" color\");\n        Color4f c = getPolyhedronColor();\n        s.append(getJmolColor(c));\n        s.append(\" off;\");\n    }\n    return s.toString();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#drawPolyhedron()\n\t */\n", "repo_name": "biojava-master/", "id": 3389, "method_signature": "String drawPolyhedron()"}, "25": {"callee_method_names": ["Map<String, StringBuffer>.get", "StringBuffer.append", "Map<String, StringBuffer>.put"], "method_name": "StockholmStructure.appendToSequence", "method_implementation": "{\n    StringBuffer seq = sequences.get(seqName);\n    if (seq != null) {\n        // add sequence without space\n        seq.append(seqText);\n    } else {\n        seq = new StringBuffer(seqText);\n        sequences.put(seqName, seq);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param seqName\n * @param seqText\n */\n", "repo_name": "biojava-master/", "id": 25, "method_signature": "void appendToSequence(String, String)"}, "399": {"callee_method_names": ["GroupIterator.setModelPos", "GroupIterator.setChainPos", "GroupIterator.setGroupPos"], "method_name": "GroupIterator.clone", "method_implementation": "{\n    GroupIterator gr = new GroupIterator(this.getStructure());\n    gr.setModelPos(this.getModelPos());\n    gr.setChainPos(this.getChainPos());\n    gr.setGroupPos(this.getGroupPos());\n    gr.fixed_model = this.fixed_model;\n    return gr;\n}", "repo_id": "9", "comment": "/**\n *  Creates and returns a copy of this object.\n */\n", "repo_name": "biojava-master/", "id": 399, "method_signature": "Object clone()"}, "1209": {"callee_method_names": [], "method_name": "CifStructureConverter.toTextFile", "method_implementation": "{\n    CifIO.writeText(toCifFile(structure), path);\n}", "repo_id": "9", "comment": "/**\n * Write a structure to a CIF file.\n * @param structure the source\n * @param path where to write to\n * @throws IOException thrown when writing fails\n */\n", "repo_name": "biojava-master/", "id": 1209, "method_signature": "void toTextFile(Structure, Path)"}, "528": {"callee_method_ids": [487], "callee_method_names": ["PrettyXMLWriter.openTag", "AFPChain.getBlockNum", "PrettyXMLWriter.openTag", "PrettyXMLWriter.closeTag", "PrettyXMLWriter.closeTag", "PrintWriter.close"], "method_name": "AFPChainXMLConverter.toXML", "method_implementation": "{\n    PrintWriter writer = new PrintWriter(swriter);\n    PrettyXMLWriter xml = new PrettyXMLWriter(writer);\n    xml.openTag(\"AFPChain\");\n    printXMLHeader(xml, afpChain);\n    // that is the initial alignment...\n    // we don't serialize that at the present.\n    //int[] blockResSize = afpChain.getBlockResSize();\n    //int[][][] blockResList = afpChain.getBlockResList();\n    // get the alignment blocks\n    int blockNum = afpChain.getBlockNum();\n    //int[] optLen       = afpChain.getOptLen();\n    //int[] blockSize    = afpChain.getBlockSize();\n    for (int bk = 0; bk < blockNum; bk++) {\n        xml.openTag(\"block\");\n        printXMLBlockHeader(xml, afpChain, bk);\n        if (ca1 == null || ca2 == null) {\n            try {\n                printXMLEQRKnownPositions(xml, afpChain, bk);\n            } catch (StructureException ex) {\n                throw new IOException(ex.getMessage());\n            }\n        } else\n            printXMLEQRInferPositions(xml, afpChain, bk, ca1, ca2);\n        printXMLMatrixShift(xml, afpChain, bk);\n        xml.closeTag(\"block\");\n    }\n    xml.closeTag(\"AFPChain\");\n    writer.close();\n}", "repo_id": "9", "comment": "/**\n * Write the XML representation to a StringWriter\n *\n * @param afpChain\n * @param swriter\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 528, "method_signature": "void toXML(AFPChain, StringWriter, Atom[], Atom[])"}, "3354": {"callee_method_names": ["NavigableMap<Double, Color>.size"], "method_name": "GradientMapper.isEmpty", "method_implementation": "{\n    return mapping.size() <= 2;\n}", "repo_id": "9", "comment": "/**\n * @return true if this gradient does not contain finite endpoints\n * @see java.util.Map#isEmpty()\n */\n", "repo_name": "biojava-master/", "id": 3354, "method_signature": "boolean isEmpty()"}, "2961": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.getAsList", "method_implementation": "{\n    return this.parsedCompounds;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2961, "method_signature": "List<C> getAsList()"}, "2242": {"callee_method_names": ["List<Atom>.sort", "List<Atom>.sort"], "method_name": "TestMmtfRoundTrip.sortAtoms", "method_implementation": "{\n    atomsOne.sort(new Comparator<Atom>() {\n\n        @Override\n        public int compare(Atom o1, Atom o2) {\n            //\n            if (o1.getPDBserial() < o2.getPDBserial()) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n    });\n    atomsTwo.sort(new Comparator<Atom>() {\n\n        @Override\n        public int compare(Atom o1, Atom o2) {\n            //\n            if (o1.getPDBserial() < o2.getPDBserial()) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Sort the atom based on PDB serial id\n *\n * @param atomsOne the first list\n * @param atomsTwo  the second list\n */\n", "repo_name": "biojava-master/", "id": 2242, "method_signature": "void sortAtoms(List, List)"}, "546": {"callee_method_names": [], "method_name": "StructurePairAligner.getDistMat", "method_implementation": "{\n    return distanceMatrix;\n}", "repo_id": "9", "comment": "/**\n * return the difference of distance matrix between the two structures\n *\n * @return a Matrix\n */\n", "repo_name": "biojava-master/", "id": 546, "method_signature": "Matrix getDistMat()"}, "112": {"callee_method_names": [], "method_name": "DistanceMatrixCalculator.pamMLdistance", "method_implementation": "{\n    // Need to import PAM1 matrix to biojava TODO\n    //SubstitutionMatrix<AminoAcidCompound> PAM1 = SubstitutionMatrixHelper.getPAM250();\n    throw new IllegalStateException(\"PAM ML distance calculation not implemented!\");\n}", "repo_id": "9", "comment": "/**\n * The PAM (Point Accepted Mutations) distance is a measure of evolutionary\n * distance in protein sequences. The PAM unit represents an average\n * substitution rate of 1% per site. The fractional dissimilarity (D) of two\n * aligned sequences is related with the PAM distance (d) by the equation:\n *\n * <pre>\n * D = sum(fi * (1 - M<sub>ii</sub><sup>d</sup>))\n * </pre>\n *\n * Where the sum is for all 20 AA, fi denotes the natural fraction of the\n * given AA and M is the substitution matrix (in this case the PAM1 matrix).\n * <p>\n * To calculate the PAM distance between two aligned sequences the maximum\n * likelihood (ML) approach is used, which consists in finding d that\n * maximazies the function:\n *\n * <pre>\n * L(d) = product(f<sub>ai</sub> * (1 - M<sub>ai,bi</sub><sup>d</sup>))\n * </pre>\n *\n * Where the product is for every position i in the alignment, and ai and bi\n * are the AA at position i in the first and second aligned sequences,\n * respectively.\n *\n * @param msa\n *            MultipleSequenceAlignment\n * @return\n */\n", "repo_name": "biojava-master/", "id": 112, "method_signature": "DistanceMatrix pamMLdistance(MultipleSequenceAlignment)"}, "3267": {"callee_method_names": ["Chain.setId", "Chain.addGroup", "Integer.getGroup", "Structure.addChain"], "method_name": "AbstractAlignmentJmol.setAtoms", "method_implementation": "{\n    Structure s = new StructureImpl();\n    Chain c = new ChainImpl();\n    c.setId(\"A\");\n    for (Atom a : atoms) {\n        c.addGroup(a.getGroup());\n    }\n    s.addChain(c);\n    setStructure(s);\n}", "repo_id": "9", "comment": "/**\n * Create and set a new structure from a given atom array.\n * @param atoms\n */\n", "repo_name": "biojava-master/", "id": 3267, "method_signature": "void setAtoms(Atom[])"}, "419": {"callee_method_names": [], "method_name": "AFPChainer.getRmsd", "method_implementation": "{\n    Matrix4d trans = SuperPositions.superpose(Calc.atomsToPoints(catmp1), Calc.atomsToPoints(catmp2));\n    Calc.transform(catmp2, trans);\n    //   if ( showAlig) {\n    //      StructureAlignmentJmol jmol = new StructureAlignmentJmol();\n    //      jmol.setTitle(\"AFPCHainer: getRmsd\" + rmsd);\n    //\n    //      Chain c1 = new ChainImpl();\n    //      c1.setName(\"A\");\n    //      for ( Atom a : catmp1){\n    //         c1.addGroup(a.getParent());\n    //      }\n    //\n    //      Chain c2 = new ChainImpl();\n    //      c2.setName(\"B\");\n    //      for ( Atom a : catmp2){\n    //         c2.addGroup(a.getParent());\n    //      }\n    //\n    //      Structure fake = new StructureImpl();\n    //      fake.setPDBCode(\"AFPCHainer: getRmsd\" + rmsd);\n    //      List<Chain> model1 = new ArrayList<Chain>();\n    //      model1.add(c1);\n    //      List<Chain> model2 = new ArrayList<Chain>();\n    //      model2.add(c2);\n    //      fake.addModel(model1);\n    //      fake.addModel(model2);\n    //      fake.setNmr(true);\n    //\n    //      jmol.setStructure(fake);\n    //      jmol.evalString(\"select *; backbone 0.4; wireframe off; spacefill off; \" +\n    //      \"select not protein and not solvent; spacefill on;\");\n    //      jmol.evalString(\"select */1 ; color red; model 1; \");\n    //\n    //      // now show both models again.\n    //      jmol.evalString(\"model 0;\");\n    //   }\n    return Calc.rmsd(catmp1, catmp2);\n}", "repo_id": "9", "comment": "/**\n * Calculate the RMSD for two sets of atoms. Rotates the 2nd atom set so make sure this does not cause problems later\n *\n * @param catmp1\n * @return\n */\n", "repo_name": "biojava-master/", "id": 419, "method_signature": "double getRmsd(Atom[], Atom[])"}, "2939": {"callee_method_names": [], "method_name": "AbstractSequence.setTaxonomy", "method_implementation": "{\n    this.taxonomy = taxonomy;\n}", "repo_id": "9", "comment": "/**\n * @param taxonomy the species to set\n */\n", "repo_name": "biojava-master/", "id": 2939, "method_signature": "void setTaxonomy(TaxonomyID)"}, "1529": {"callee_method_names": [], "method_name": "JournalArticle.setPmid", "method_implementation": "{\n    this.pmid = pmid;\n}", "repo_id": "9", "comment": "/**\n * Set the value of pmid\n *\n * @param pmid new value of pmid\n */\n", "repo_name": "biojava-master/", "id": 1529, "method_signature": "void setPmid(String)"}, "2479": {"callee_method_names": ["Logger.debug", "GeneChromosomePosition.getExonStarts", "GeneChromosomePosition.getExonEnds", "Logger.debug", "List<Integer>.size", "GeneChromosomePosition.getCdsStart", "GeneChromosomePosition.getCdsEnd", "GeneChromosomePosition.getOrientation", "Logger.debug", "GeneChromosomePosition.getGeneName"], "method_name": "ChromosomeMappingTools.getChromosomePosForCDScoordinate", "method_implementation": "{\n    logger.debug(\" ? Checking chromosome position for CDS position {}\", cdsNucleotidePosition);\n    List<Integer> exonStarts = chromPos.getExonStarts();\n    List<Integer> exonEnds = chromPos.getExonEnds();\n    logger.debug(\" Exons:{}\", exonStarts.size());\n    int cdsStart = chromPos.getCdsStart();\n    int cdsEnd = chromPos.getCdsEnd();\n    ChromPos chromosomePos = null;\n    if (chromPos.getOrientation().equals('+'))\n        chromosomePos = ChromosomeMappingTools.getChromPosForward(cdsNucleotidePosition, exonStarts, exonEnds, cdsStart, cdsEnd);\n    else\n        chromosomePos = ChromosomeMappingTools.getChromPosReverse(cdsNucleotidePosition, exonStarts, exonEnds, cdsStart, cdsEnd);\n    logger.debug(\"=> CDS pos \" + cdsNucleotidePosition + \" for \" + chromPos.getGeneName() + \" is on chromosome at  \" + chromosomePos);\n    return chromosomePos;\n}", "repo_id": "9", "comment": "/**\n * Maps the position of a CDS nucleotide back to the genome\n *\n * @param cdsNucleotidePosition\n * @return a ChromPos object\n */\n", "repo_name": "biojava-master/", "id": 2479, "method_signature": "ChromPos getChromosomePosForCDScoordinate(int, GeneChromosomePosition)"}, "3474": {"callee_method_names": [], "method_name": "NCBIQBlastService.setEmail", "method_implementation": "{\n    this.email = email;\n}", "repo_id": "9", "comment": "/**\n * Set the email for QBlast. Defaults to {@value #DEFAULT_EMAIL}\n *\n * @param email the new email\n */\n", "repo_name": "biojava-master/", "id": 3474, "method_signature": "void setEmail(String)"}, "1538": {"callee_method_names": [], "method_name": "Astral.getNames", "method_implementation": "{\n    return names;\n}", "repo_id": "9", "comment": "/**\n * @return The names of representatives in this ASTRAL set.\n */\n", "repo_name": "biojava-master/", "id": 1538, "method_signature": "Set<String> getNames()"}, "938": {"callee_method_names": [], "method_name": "Grid.getContacts", "method_implementation": "{\n    return getAtomContacts();\n}", "repo_id": "9", "comment": "/**\n * Returns all contacts, i.e. all atoms that are within the cutoff distance.\n * If both iAtoms and jAtoms are defined then contacts are between iAtoms and jAtoms,\n * if jAtoms is null, then contacts are within the iAtoms.\n * @return\n * @deprecated use {@link #getAtomContacts()} instead\n */\n", "repo_name": "biojava-master/", "id": 938, "method_signature": "AtomContactSet getContacts()"}, "2361": {"callee_method_names": ["QualityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound>.setQualities"], "method_name": "FastqTools.createQualityScores", "method_implementation": "{\n    if (fastq == null) {\n        throw new IllegalArgumentException(\"fastq must not be null\");\n    }\n    QualityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound> qualityScores = new QualityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound>(\"qualityScores\", \"sequencing\");\n    qualityScores.setQualities(toList(qualityScores(fastq)));\n    return qualityScores;\n}", "repo_id": "9", "comment": "/**\n * Create and return a new {@link QualityFeature} from the quality scores of the specified\n * FASTQ formatted sequence.  The quality scores feature has a type <code>\"qualityScores\"</code>\n * and will be the same length as the sequence.\n *\n * @param fastq FASTQ formatted sequence, must not be null\n * @return a new {@link QualityFeature} from the quality scores of the specified FASTQ\n *    formatted sequence\n */\n", "repo_name": "biojava-master/", "id": 2361, "method_signature": "QualityFeature<AbstractSequence<NucleotideCompound>,NucleotideCompound> createQualityScores(Fastq)"}, "2194": {"callee_method_ids": [491], "callee_method_names": ["AFPChain.setOptAln", "AFPChain.setOptLength", "AFPChain.setCa1Length", "AFPChain.setCa2Length", "AFPChain.setBlockNum", "AFPChain.setOptLen"], "method_name": "CeCPMainTest.makeDummyAFPChain", "method_implementation": "{\n    AFPChain afp = new AFPChain(AFPChain.UNKNOWN_ALGORITHM);\n    afp.setOptAln(dupAlign);\n    afp.setOptLength(dupAlign[0][1].length);\n    afp.setCa1Length(ca1.length);\n    afp.setCa2Length(ca2.length);\n    afp.setBlockNum(1);\n    afp.setOptLen(new int[] { dupAlign[0][1].length });\n    return afp;\n}", "repo_id": "9", "comment": "/**\n * Creates a minimal AFPChain from the specified alignment and proteins\n * @param dupAlign\n * @param ca1\n * @param ca2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2194, "method_signature": "AFPChain makeDummyAFPChain(int[][][], Atom[], Atom[])"}, "3215": {"callee_method_names": [], "method_name": "TestObject.large", "method_implementation": "{\n    return new TestObject(name, 100_000);\n}", "repo_id": "9", "comment": "/*\n        *Create a test object occupying significant memory(100kB)\n        */\n", "repo_name": "biojava-master/", "id": 3215, "method_signature": "TestObject large(String)"}, "3787": {"callee_method_ids": [3693, 3516, 3515], "callee_method_names": ["SurvFitInfo.getStrataInfoHashMap", "StrataInfo.getSurv", "ArrayList<Double>.size", "ArrayList<Double>.get", "ArrayList<Double>.size", "ArrayList<Double>.get", "StrataInfo.getTime"], "method_name": "KaplanMeierFigure.getSurvivalTimePercentile", "method_implementation": "{\n    StrataInfo si = sfi.getStrataInfoHashMap().get(group);\n    ArrayList<Double> percentage = si.getSurv();\n    Integer percentileIndex = null;\n    for (int i = 0; i < percentage.size(); i++) {\n        if (percentage.get(i) == percentile) {\n            if (i + 1 < percentage.size()) {\n                percentileIndex = i + 1;\n            }\n            break;\n        } else if (percentage.get(i) < percentile) {\n            percentileIndex = i;\n            break;\n        }\n    }\n    if (percentileIndex != null) {\n        return si.getTime().get(percentileIndex);\n    } else {\n        return null;\n    }\n}", "repo_id": "9", "comment": "/**\n * To get the median percentile for a particular group pass the value of\n * .50.\n *\n * @param group\n * @param percentile\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3787, "method_signature": "Double getSurvivalTimePercentile(String, double)"}, "577": {"callee_method_names": [], "method_name": "RotationAxis.getAngle", "method_implementation": "{\n    // Calculate angle\n    //=cos(theta)\n    double c = (transform.m00 + transform.m11 + transform.m22 - 1) / 2.0;\n    // c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n    if (-1 - 1e-8 < c && c < -1)\n        c = -1;\n    if (1 + 1e-8 > c && c > 1)\n        c = 1;\n    if (-1 > c || c > 1) {\n        throw new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n    }\n    return Math.acos(c);\n}", "repo_id": "9", "comment": "/**\n * Quickly compute the rotation angle from a rotation matrix.\n * @param transform 3D rotation matrix\n * @return Angle, from 0 to PI\n */\n", "repo_name": "biojava-master/", "id": 577, "method_signature": "double getAngle(Matrix3d)"}, "3404": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.setRotationGroup", "method_implementation": "{\n    this.rotationGroup = rotationGroup;\n}", "repo_id": "9", "comment": "/**\n * @param rotationGroup the rotationGroup to set\n */\n", "repo_name": "biojava-master/", "id": 3404, "method_signature": "void setRotationGroup(RotationGroup)"}, "2862": {"callee_method_names": [], "method_name": "ABITrace.getQcalls", "method_implementation": "{\n    return qCalls;\n}", "repo_id": "9", "comment": "/**\n * Returns an <code>int[]</code> array that represents the quality - each int in the\n * array corresponds to an quality value 90-255) in the graph at a base location).\n *\n * @return int[] qCalls\n */\n", "repo_name": "biojava-master/", "id": 2862, "method_signature": "int[] getQcalls()"}, "144": {"callee_method_ids": [498, 507, 497], "callee_method_names": ["BufferedReader.readLine", "StringBuilder.append", "BufferedReader.close", "StringBuilder.toString", "AFPChain.setTMScore", "AFPChain.setTotalRmsdOpt", "AFPChain.getTMScore", "AFPChain.getTotalRmsdOpt"], "method_name": "AlignmentToolsTest.testUpdateSuperposition", "method_implementation": "{\n    Structure s = StructureTools.getStructure(\"31BI\");\n    Atom[] ca1 = StructureTools.getRepresentativeAtomArray(s);\n    Atom[] ca2 = StructureTools.getRepresentativeAtomArray(s);\n    StringBuilder sb = new StringBuilder();\n    BufferedReader br = new BufferedReader(new FileReader(\"src/test/resources/align/31BI_symm_align.xml\"));\n    String line = \"\";\n    while ((line = br.readLine()) != null) {\n        sb.append(line);\n    }\n    br.close();\n    AFPChain afpChain = AFPChainXMLParser.fromXML(sb.toString(), ca1, ca2);\n    afpChain.setTMScore(-1);\n    afpChain.setTotalRmsdOpt(-1);\n    AlignmentTools.updateSuperposition(afpChain, ca1, ca2);\n    Assert.assertEquals(\"TM-score is wrong\", 0.62779, afpChain.getTMScore(), 0.001);\n    Assert.assertEquals(\"RMSD is wrong\", 2.50569, afpChain.getTotalRmsdOpt(), 0.001);\n}", "repo_id": "9", "comment": "/**\n * Tests that {@link AlignmentTools#updateSuperposition(AFPChain, Atom[], Atom[])} calculates the correct RMSD and TM-score for an AFPChain of 1 block.\n * TODO: Write a test with 2 blocks\n */\n", "repo_name": "biojava-master/", "id": 144, "method_signature": "void testUpdateSuperposition()"}, "445": {"callee_method_names": [], "method_name": "QsAlignResult.getSubunits1", "method_implementation": "{\n    return Collections.unmodifiableList(subunits1);\n}", "repo_id": "9", "comment": "/**\n * Original Subunits of the first group.\n *\n * @return an unmodifiable view of the original List\n */\n", "repo_name": "biojava-master/", "id": 445, "method_signature": "List<Subunit> getSubunits1()"}, "2459": {"callee_method_names": ["HashMap.get"], "method_name": "Feature.getAttribute", "method_implementation": "{\n    return attributeHashMap.get(key);\n}", "repo_id": "9", "comment": "/**\n * Get value of specified attribute key. Returns null if the attribute key has no value (does not exist).\n * Keys are case-sensitive. Assumes attributes are correctly formatted in GFF style.\n * Known bug: a semicolon within a quoted value will cause parse failure.\n *\n * @param key The key.\n * @return The corresponding value. Null if the key has no value defined.\n */\n", "repo_name": "biojava-master/", "id": 2459, "method_signature": "String getAttribute(String)"}, "97": {"callee_method_names": ["PairwiseSequenceAligner<S, C>.getPair", "PairwiseSequenceAligner<S, C>.getPair"], "method_name": "FractionalSimilarityScorer.align", "method_implementation": "{\n    max = aligner.getPair().getLength();\n    score = aligner.getPair().getNumSimilars();\n    aligner = null;\n}", "repo_id": "9", "comment": "// helper method for initialization from an aligner\n", "repo_name": "biojava-master/", "id": 97, "method_signature": "void align()"}, "2277": {"callee_method_ids": [1318], "callee_method_names": ["FileParsingParameters.setHeaderOnly", "CifFileReader.setFileParsingParameters", "CifFileReader.setFetchBehavior", "CifFileReader.getStructureById", "Chain.printStackTrace", "Logger.info", "Structure.getIdentifier"], "method_name": "TestHeaderOnly.testSpeed", "method_implementation": "{\n    // Force using a file reader.\n    CifFileReader fr = new CifFileReader();\n    FileParsingParameters par = new FileParsingParameters();\n    //par.setAlignSeqRes(true);\n    // par.setHeaderOnly(true);\n    par.setHeaderOnly(false);\n    fr.setFileParsingParameters(par);\n    fr.setFetchBehavior(FetchBehavior.FETCH_FILES);\n    Structure s = null;\n    long start = System.nanoTime();\n    try {\n        // Medium sized structure parsed in 0.549s (no header) vs .676s (header) ~ 20% faster\n        s = fr.getStructureById(new PdbId(\"4WZ6\"));\n        // A larger structure could be parsed ~ 4.991s (no header) vs 5.867s (header) ~ 16% faster\n        // s = fr.getStructureById(\"4V60\");\n    } catch (IOException e) {\n        e.printStackTrace();\n        System.exit(1);\n    }\n    long stop = System.nanoTime();\n    double diff = (stop - start) / 1000000000.0;\n    logger.info(String.format(\"[%s] Elapsed time: %.3f s\", s.getIdentifier(), diff));\n}", "repo_id": "9", "comment": "// @Test\n", "repo_name": "biojava-master/", "id": 2277, "method_signature": "void testSpeed()"}, "49": {"callee_method_names": [], "method_name": "Alignments.getProfileProfileAligner", "method_implementation": "{\n    switch(type) {\n        default:\n        case GLOBAL:\n            return new SimpleProfileProfileAligner<S, C>(profile1, profile2, gapPenalty, subMatrix);\n        case GLOBAL_LINEAR_SPACE:\n        case GLOBAL_CONSENSUS:\n        case LOCAL:\n        case LOCAL_LINEAR_SPACE:\n        case LOCAL_CONSENSUS:\n            // TODO other alignment options (Myers-Miller, consensus, local)\n            throw new UnsupportedOperationException(Alignments.class.getSimpleName() + \" does not yet support \" + type + \" alignment\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Factory method which constructs a profile-profile aligner.\n *\n * @param <S> each {@link Sequence} of an alignment profile is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param profile1 the first {@link Profile} to align\n * @param profile2 the second {@link Profile} to align\n * @param type chosen type from list of profile-profile alignment routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return profile-profile aligner\n */\n", "repo_name": "biojava-master/", "id": 49, "method_signature": "ProfileProfileAligner<S,C> getProfileProfileAligner(Future, Profile, ProfileProfileAlignerType, GapPenalty, SubstitutionMatrix)"}, "2667": {"callee_method_names": [], "method_name": "RNAToAminoAcidTranslator.postProcessCompoundLists", "method_implementation": "{\n    for (List<AminoAcidCompound> compounds : compoundLists) {\n        if (trimStops) {\n            trimStop(compounds);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Performs the trimming of stop codons and the conversion of a valid start\n * amino acid to M\n */\n", "repo_name": "biojava-master/", "id": 2667, "method_signature": "void postProcessCompoundLists(List)"}, "3768": {"callee_method_names": [], "method_name": "WorkSheet.setRowHeader", "method_implementation": "{\n    rowHeader = value;\n}", "repo_id": "9", "comment": "/**\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 3768, "method_signature": "void setRowHeader(String)"}, "2064": {"callee_method_names": ["Map<Integer,Integer>.keySet", "List<Integer>.iterator", "Iterator<Integer>.hasNext", "Iterator<Integer>.next", "Map<Integer, Integer>.containsKey", "Iterator<Integer>.remove", "Map<Integer, Integer>.get", "Iterator<Integer>.remove", "Map<Integer,Double>.get", "Iterator<Integer>.remove", "Map<Integer,Integer>.get", "NavigableSet<Integer>.add", "NavigableSet<Integer>.add", "Map<Integer,Double>.get", "Iterator<Integer>.remove", "List<Integer>.iterator", "Iterator<Integer>.hasNext", "Iterator<Integer>.next", "Map<Integer, Integer>.get", "NavigableSet<Integer>.floor", "NavigableSet<Integer>.higher", "Map<Integer,Integer>.get", "Iterator<Integer>.remove", "Map<Integer,Integer>.get", "Iterator<Integer>.remove"], "method_name": "SequenceFunctionRefiner.initializeEligible", "method_implementation": "{\n    // Eligible if:\n    // 1. score(x)>0\n    // 2. f^K-1(x) is defined\n    // 3. score(f^K-1(x))>0\n    // 4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n    // 5. Not in a loop of length less than k\n    // Assume all residues are eligible to start\n    if (eligible == null) {\n        eligible = new LinkedList<Integer>(alignment.keySet());\n    }\n    // Precalculate f^K-1(x)\n    // Map<Integer, Integer> alignK1 = AlignmentTools.applyAlignment(alignment, k-1);\n    Map<Integer, Integer> alignK1 = applyAlignmentAndCheckCycles(alignment, k - 1, eligible);\n    // Remove ineligible residues\n    Iterator<Integer> eligibleIt = eligible.iterator();\n    while (eligibleIt.hasNext()) {\n        Integer res = eligibleIt.next();\n        //  2. f^K-1(x) is defined\n        if (!alignK1.containsKey(res)) {\n            eligibleIt.remove();\n            continue;\n        }\n        Integer k1 = alignK1.get(res);\n        if (k1 == null) {\n            eligibleIt.remove();\n            continue;\n        }\n        //  1. score(x)>0\n        Double score = scores.get(res);\n        if (score == null || score <= 0.0) {\n            eligibleIt.remove();\n            // res is in a loop. Add it to the proper set\n            if (res <= alignment.get(res)) {\n                //forward\n                forwardLoops.add(res);\n            } else {\n                //backward\n                backwardLoops.add(res);\n            }\n            continue;\n        }\n        //\t3. score(f^K-1(x))>0\n        Double scoreK1 = scores.get(k1);\n        if (scoreK1 == null || scoreK1 <= 0.0) {\n            eligibleIt.remove();\n            continue;\n        }\n    }\n    // Now that loops are up-to-date, check for loop crossings\n    eligibleIt = eligible.iterator();\n    while (eligibleIt.hasNext()) {\n        Integer res = eligibleIt.next();\n        //4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n        //Test equivalent: All loop edges should be properly ordered wrt edge f^k-1(x) -> x\n        Integer src = alignK1.get(res);\n        if (src < res) {\n            //forward\n            // get interval [a,b) containing res\n            Integer a = forwardLoops.floor(src);\n            Integer b = forwardLoops.higher(src);\n            // Ineligible unless f(a) < res < f(b)\n            if (a != null && alignment.get(a) > res) {\n                eligibleIt.remove();\n                continue;\n            }\n            if (b != null && alignment.get(b) < res) {\n                eligibleIt.remove();\n                continue;\n            }\n        }\n    }\n    return eligible;\n}", "repo_id": "9", "comment": "/**\n * Helper method to initialize eligible residues.\n *\n * Eligible if:\n *  1. score(x)>0\n *  2. f^K-1(x) is defined\n *  3. score(f^K-1(x))>0\n *  4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n * @param alignment The alignment with respect to which to calculate eligibility\n * @param scores An up-to-date map from residues to their scores\n * @param eligible Starting list of eligible residues. If null will be generated.\n * @param k\n * @param backwardLoops\n * @param forwardLoops\n * @return eligible after modification\n */\n", "repo_name": "biojava-master/", "id": 2064, "method_signature": "List<Integer> initializeEligible(Map, Map, List, int, NavigableSet, NavigableSet)"}, "3455": {"callee_method_names": ["BlastOutputFormatEnum.name"], "method_name": "NCBIQBlastOutputProperties.setOutputFormat", "method_implementation": "{\n    setOutputOption(FORMAT_TYPE, formatType.name());\n    if (BlastOutputFormatEnum.HTML.equals(formatType)) {\n        // add default parameters associated with HTML\n        setOutputOption(NOHEADER, \"true\");\n        setOutputOption(SHOW_OVERVIEW, \"false\");\n        setOutputOption(SHOW_LINKOUT, \"false\");\n    } else {\n        // remove default parameters associated with HTML\n        removeOutputOption(NOHEADER);\n        removeOutputOption(SHOW_OVERVIEW);\n        removeOutputOption(SHOW_LINKOUT);\n    }\n}", "repo_id": "9", "comment": "/**\n * Sets the stream output format to get from the QBlast service\n * <p/>\n * If {@code HTML} format is selected, also adds the following parameters (which are removed if another output\n * format is chosen):\n *\n * <pre>\n * NOHEADER = true;\n * SHOW_OVERVIEW = false;\n * SHOW_LINKOUT = false;\n * </pre>\n *\n * @param formatType : one of the output format types defined in enum\n */\n", "repo_name": "biojava-master/", "id": 3455, "method_signature": "void setOutputFormat(BlastOutputFormatEnum)"}, "2899": {"callee_method_ids": [3106, 3108], "callee_method_names": ["Map<String, List<AbstractFeature<AbstractSequence<C>, C>>>.keySet", "Map<String, List<AbstractFeature<AbstractSequence<C>, C>>>.get", "Map<String, List<AbstractFeature<AbstractSequence<C>, C>>>.get", "ArrayList<DBReferenceInfo>.get", "DBReferenceInfo.getDatabase", "DBReferenceInfo.getId", "SequenceReader<C>.getAccession"], "method_name": "AbstractSequence.setProxySequenceReader", "method_implementation": "{\n    this.sequenceStorage = proxyLoader;\n    if (proxyLoader instanceof FeaturesKeyWordInterface) {\n        this.setFeaturesKeyWord((FeaturesKeyWordInterface) sequenceStorage);\n    }\n    if (proxyLoader instanceof DatabaseReferenceInterface) {\n        this.setDatabaseReferences((DatabaseReferenceInterface) sequenceStorage);\n    }\n    if (proxyLoader instanceof FeatureRetriever) {\n        this.setFeatureRetriever((FeatureRetriever) sequenceStorage);\n        Map<String, List<AbstractFeature<AbstractSequence<C>, C>>> ff = getFeatureRetriever().getFeatures();\n        for (String k : ff.keySet()) {\n            for (AbstractFeature f : ff.get(k)) {\n                this.addFeature(f);\n            }\n        }\n        // success of next statement guaranteed because source is a compulsory field\n        //DBReferenceInfo dbQualifier = (DBReferenceInfo)ff.get(\"source\").get(0).getQualifiers().get(\"db_xref\");\n        ArrayList<DBReferenceInfo> dbQualifiers = (ArrayList) ff.get(\"source\").get(0).getQualifiers().get(\"db_xref\");\n        DBReferenceInfo dbQualifier = dbQualifiers.get(0);\n        if (dbQualifier != null)\n            this.setTaxonomy(new TaxonomyID(dbQualifier.getDatabase() + \":\" + dbQualifier.getId(), DataSource.UNKNOWN));\n    }\n    if (getAccession() == null && proxyLoader instanceof UniprotProxySequenceReader) {\n        // we have lots of unsupported operations for this call so quick fix to allow this tow rork\n        this.setAccession(proxyLoader.getAccession());\n    }\n}", "repo_id": "9", "comment": "/**\n * Very important method that allows external mappings of sequence data and features. This method\n * will gain additional interface inspection that allows external data sources with knowledge\n * of features for a sequence to be supported.\n *\n * @param proxyLoader\n */\n", "repo_name": "biojava-master/", "id": 2899, "method_signature": "void setProxySequenceReader(SequenceReader)"}, "190": {"callee_method_ids": [1623, 1625, 1633, 1929, 1923], "callee_method_names": ["SubunitClustererParameters.setSequenceIdentityThreshold", "SubunitClustererParameters.setSequenceCoverageThreshold", "SubunitClustererParameters.setClustererMethod", "QuatSymmetryResults.getSymmetry", "QuatSymmetryResults.getStoichiometry", "QuatSymmetryResults.isPseudoStoichiometric", "QuatSymmetryResults.getSubunitClusters"], "method_name": "TestQuatSymmetryDetectorExamples.testPseudoIdentity95", "method_implementation": "{\n    Structure pdb = StructureIO.getStructure(\"BIO:4DZ8:1\");\n    SubunitClustererParameters cp = new SubunitClustererParameters();\n    cp.setSequenceIdentityThreshold(0.95);\n    cp.setSequenceCoverageThreshold(0.95);\n    cp.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n    QuatSymmetryParameters symmParams = new QuatSymmetryParameters();\n    QuatSymmetryResults symmetry = QuatSymmetryDetector.calcGlobalSymmetry(pdb, symmParams, cp);\n    assertEquals(\"C2\", symmetry.getSymmetry());\n    assertEquals(\"A2\", symmetry.getStoichiometry().toString());\n    assertFalse(symmetry.isPseudoStoichiometric());\n    assertEquals(SubunitClustererMethod.SEQUENCE, symmetry.getSubunitClusters().get(0).getClustererMethod());\n}", "repo_id": "9", "comment": "/**\n * A structure with very similar entities (clustering at 95% seq id): 4DZ8\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 190, "method_signature": "void testPseudoIdentity95()"}, "3387": {"callee_method_names": ["Polyhedron.getViewName"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getOrientationName", "method_implementation": "{\n    return polyhedron.getViewName(index);\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#getOrientationName(int)\n\t */\n", "repo_name": "biojava-master/", "id": 3387, "method_signature": "String getOrientationName(int)"}, "2936": {"callee_method_names": [], "method_name": "AbstractSequence.getAccession", "method_implementation": "{\n    return accession;\n}", "repo_id": "9", "comment": "/**\n * @return the accession\n */\n", "repo_name": "biojava-master/", "id": 2936, "method_signature": "AccessionID getAccession()"}, "1414": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.getTransformationsOrthonormal", "method_implementation": "{\n    Matrix4d[] transfs = new Matrix4d[this.getSpaceGroup().getNumOperators()];\n    // no need to transform the identity\n    transfs[0] = new Matrix4d(this.getSpaceGroup().getTransformation(0));\n    for (int i = 1; i < this.getSpaceGroup().getNumOperators(); i++) {\n        transfs[i] = this.cell.transfToOrthonormal(this.getSpaceGroup().getTransformation(i));\n    }\n    return transfs;\n}", "repo_id": "9", "comment": "/**\n * Gets all symmetry transformation operators corresponding to this structure's space group\n * (including the identity, at index 0) expressed in the orthonormal basis. Using PDB axes\n * convention (NCODE=1).\n * @return an array of size {@link SpaceGroup#getNumOperators()}\n */\n", "repo_name": "biojava-master/", "id": 1414, "method_signature": "Matrix4d[] getTransformationsOrthonormal()"}, "3811": {"callee_method_names": ["String.startsWith", "String.startsWith", "String.startsWith", "BufferedImage.createGraphics"], "method_name": "KaplanMeierFigure.savePNG", "method_implementation": "{\n    if (fileName.startsWith(\"null\") || fileName.startsWith(\"Null\") || fileName.startsWith(\"NULL\")) {\n        return;\n    }\n    this.fileName = fileName;\n    BufferedImage image = new BufferedImage(this.getWidth(), this.getHeight(), BufferedImage.TYPE_INT_RGB);\n    Graphics2D graphics2D = image.createGraphics();\n    this.paint(graphics2D);\n    try {\n        ImageIO.write(image, \"png\", new File(fileName));\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * @param fileName\n */\n", "repo_name": "biojava-master/", "id": 3811, "method_signature": "void savePNG(String)"}, "3737": {"callee_method_names": ["LinkedHashMap.get", "LinkedHashMap.keySet", "String.equalsIgnoreCase"], "method_name": "WorkSheet.isValidRow", "method_implementation": "{\n    HeaderInfo rowIndex = rowLookup.get(row);\n    if (rowIndex == null) {\n        for (String rowtable : rowLookup.keySet()) {\n            if (row.equalsIgnoreCase(rowtable)) {\n                return true;\n            }\n        }\n        return false;\n    } else {\n        return true;\n    }\n}", "repo_id": "9", "comment": "/**\n * @param row\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3737, "method_signature": "boolean isValidRow(String)"}, "1276": {"callee_method_ids": [1261], "callee_method_names": ["MmtfStructureReader.getStructure"], "method_name": "MmtfActions.readFromInputStream", "method_implementation": "{\n    // Get the reader - this is the bit that people need to implement.\n    MmtfStructureReader mmtfStructureReader = new MmtfStructureReader();\n    // Do the inflation\n    new StructureDataToAdapter(new GenericDecoder(ReaderUtils.getDataFromInputStream(inStream)), mmtfStructureReader);\n    // Get the structue\n    return mmtfStructureReader.getStructure();\n}", "repo_id": "9", "comment": "/**\n * Read a Biojava structure from an {@link InputStream}\n * @param inStream the {@link InputStream} to read from\n * @return the parsed {@link Structure}\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1276, "method_signature": "Structure readFromInputStream(InputStream)"}, "1476": {"callee_method_names": ["ArrayList<Double>.add", "Point3d.distance", "ArrayList<Double>.add", "Point3d.distance", "ArrayList<Double>.add", "Point3d.distance", "ArrayList<Double>.add", "Point3d.distance"], "method_name": "CrystalCell.getMaxDimension", "method_implementation": "{\n    if (maxDimension != 0) {\n        return maxDimension;\n    }\n    Point3d vert0 = new Point3d(0, 0, 0);\n    Point3d vert1 = new Point3d(1, 0, 0);\n    transfToOrthonormal(vert1);\n    Point3d vert2 = new Point3d(0, 1, 0);\n    transfToOrthonormal(vert2);\n    Point3d vert3 = new Point3d(0, 0, 1);\n    transfToOrthonormal(vert3);\n    Point3d vert4 = new Point3d(1, 1, 0);\n    transfToOrthonormal(vert4);\n    Point3d vert5 = new Point3d(1, 0, 1);\n    transfToOrthonormal(vert5);\n    Point3d vert6 = new Point3d(0, 1, 1);\n    transfToOrthonormal(vert6);\n    Point3d vert7 = new Point3d(1, 1, 1);\n    transfToOrthonormal(vert7);\n    ArrayList<Double> vertDists = new ArrayList<Double>();\n    vertDists.add(vert0.distance(vert7));\n    vertDists.add(vert3.distance(vert4));\n    vertDists.add(vert1.distance(vert6));\n    vertDists.add(vert2.distance(vert5));\n    maxDimension = Collections.max(vertDists);\n    return maxDimension;\n}", "repo_id": "9", "comment": "/**\n * Gets the maximum dimension of the unit cell.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1476, "method_signature": "double getMaxDimension()"}, "208": {"callee_method_names": [], "method_name": "FastaSequence.toString", "method_implementation": "{\n    return this.getOnelineFasta();\n}", "repo_id": "9", "comment": "/**\n * Same as oneLineFasta\n */\n", "repo_name": "biojava-master/", "id": 208, "method_signature": "String toString()"}, "565": {"callee_method_names": ["Matrix.getColumnDimension", "Matrix.getRowDimension", "Matrix.trace"], "method_name": "RotationAxis.init", "method_implementation": "{\n    if (rotation.getColumnDimension() != 3 || rotation.getRowDimension() != 3) {\n        throw new IllegalArgumentException(\"Expected 3x3 rotation matrix\");\n    }\n    // Calculate angle\n    //=cos(theta)\n    double c = (rotation.trace() - 1) / 2.0;\n    // c is sometimes slightly out of the [-1,1] range due to numerical instabilities\n    if (-1 - 1e-8 < c && c < -1)\n        c = -1;\n    if (1 + 1e-8 > c && c > 1)\n        c = 1;\n    if (-1 > c || c > 1) {\n        throw new IllegalArgumentException(\"Input matrix is not a valid rotation matrix.\");\n    }\n    this.theta = Math.acos(c);\n    if (theta < MIN_ANGLE) {\n        calculateTranslationalAxis(rotation, translation);\n    } else {\n        calculateRotationalAxis(rotation, translation, c);\n    }\n}", "repo_id": "9", "comment": "/**\n * Initialize variables\n *\n * @param rotation\n * @param translation\n */\n", "repo_name": "biojava-master/", "id": 565, "method_signature": "void init(Matrix, Atom)"}, "3303": {"callee_method_names": ["String.compareTo", "String.compareTo"], "method_name": "SystemInfo.quickSort", "method_implementation": "{\n    int i = startIndex;\n    int j = endIndex;\n    String pivot = vector[(i + j) / 2];\n    do {\n        while (i < endIndex && pivot.compareTo(vector[i]) > 0) {\n            ++i;\n        }\n        while (j > startIndex && pivot.compareTo(vector[j]) < 0) {\n            --j;\n        }\n        if (i < j) {\n            String temp = vector[i];\n            vector[i] = vector[j];\n            vector[j] = temp;\n        }\n        if (i <= j) {\n            ++i;\n            --j;\n        }\n    } while (i <= j);\n    if (startIndex < j) {\n        quickSort(vector, startIndex, j);\n    }\n    if (i < endIndex) {\n        quickSort(vector, i, endIndex);\n    }\n}", "repo_id": "9", "comment": "/**\n * Stripped-down QuickSort.\n * @param   vector      The vector of strings to sort\n * @param   startIndex  The first element to sort\n * @param   endIndex    The last element to sort\n *\n * example use:\n * <pre>\n *    JavaInfo.quickSort(vector, 0, vector.length - 1);\n *  </pre>\n */\n", "repo_name": "biojava-master/", "id": 3303, "method_signature": "void quickSort(String[], int, int)"}, "425": {"callee_method_names": [], "method_name": "SigEva.normScore", "method_implementation": "{\n    //double        score1 = modScore(score, r);\n    double score1 = score;\n    if (r > 0)\n        score1 /= Math.sqrt(r + 1);\n    //it is tested that flexible score is more linear relevant to 1/r2 than 1/r\n    if (rmsd < 0.5)\n        score1 *= Math.sqrt((optLen) / 0.5);\n    else\n        score1 *= Math.sqrt((optLen) / rmsd);\n    return score1;\n}", "repo_id": "9", "comment": "//the chaining score is normalized by rmsd, twist and optimal alignment length\n", "repo_name": "biojava-master/", "id": 425, "method_signature": "double normScore(double, double, int, int)"}, "3801": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getBottom", "method_implementation": "{\n    return bottom;\n}", "repo_id": "9", "comment": "/**\n * @return the bottom\n */\n", "repo_name": "biojava-master/", "id": 3801, "method_signature": "int getBottom()"}, "1413": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.setSpaceGroup", "method_implementation": "{\n    this.sg = spaceGroup;\n}", "repo_id": "9", "comment": "/**\n * Set the SpaceGroup\n * @param spaceGroup\n */\n", "repo_name": "biojava-master/", "id": 1413, "method_signature": "void setSpaceGroup(SpaceGroup)"}, "126": {"callee_method_names": ["PairwiseSequenceAligner<DNASequence, NucleotideCompound>.getPair"], "method_name": "TestDNAAlignment.testNoAlignedBases", "method_implementation": "{\n    DNASequence target = new DNASequence(\"A\", DNACompoundSet.getDNACompoundSet());\n    DNASequence query = new DNASequence(\"T\", DNACompoundSet.getDNACompoundSet());\n    SubstitutionMatrix<NucleotideCompound> matrix = SubstitutionMatrixHelper.getNuc4_4();\n    SimpleGapPenalty gapP = new SimpleGapPenalty((short) 0, (short) 1);\n    PairwiseSequenceAligner<DNASequence, NucleotideCompound> aligner = Alignments.getPairwiseAligner(query, target, PairwiseSequenceAlignerType.GLOBAL, gapP, matrix);\n    Assert.assertEquals(2, aligner.getPair().getLength());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 126, "method_signature": "void testNoAlignedBases()"}, "2886": {"callee_method_names": ["Sequence<C>.getLength", "List<C>.add"], "method_name": "SequenceMixin.toList", "method_implementation": "{\n    List<C> list = new ArrayList<C>(sequence.getLength());\n    for (C compound : sequence) {\n        list.add(compound);\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * For the given {@link Sequence} this will return a {@link List} filled with\n * the Compounds of that {@link Sequence}.\n */\n", "repo_name": "biojava-master/", "id": 2886, "method_signature": "List<C> toList(Sequence)"}, "826": {"callee_method_names": ["Atom.getGroup", "Atom.getGroup", "Group.getPDBName", "Group.getPDBName"], "method_name": "AlternativeAlignment.calcScores", "method_implementation": "{\n    eqr0 = idx1.length;\n    gaps0 = count_gaps(idx1, idx2);\n    percId = 0;\n    // calc the % id\n    for (int i = 0; i < idx1.length; i++) {\n        Atom a1 = ca1[idx1[i]];\n        Atom a2 = ca2[idx2[i]];\n        Group g1 = a1.getGroup();\n        Group g2 = a2.getGroup();\n        if (g1.getPDBName().equals(g2.getPDBName())) {\n            percId++;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * calculates  scores for this alignment ( %id )\n * @param ca1 set of Atoms for molecule 1\n * @param ca2 set of Atoms for molecule 2\n */\n", "repo_name": "biojava-master/", "id": 826, "method_signature": "void calcScores(Atom[], Atom[])"}, "433": {"callee_method_names": [], "method_name": "FatCatParameters.setMaxTra", "method_implementation": "{\n    this.maxTra = maxTra;\n}", "repo_id": "9", "comment": "/**\n * set the maximum number of Twists that are allowed...\n *\n * @param maxTra\n */\n", "repo_name": "biojava-master/", "id": 433, "method_signature": "void setMaxTra(Integer)"}, "2012": {"callee_method_names": [], "method_name": "Tetrahedron.setMidRadius", "method_implementation": "{\n    double side = getSideLengthFromMiddleRadius(radius);\n    this.circumscribedRadius = getCircumscribedRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Sets the radius of radius of a sphere, that is tangent to each\n * of the tetrahedron's edges\n * @param midRadius the midRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2012, "method_signature": "void setMidRadius(double)"}, "753": {"callee_method_names": [], "method_name": "CeParameters.setMaxOptRMSD", "method_implementation": "{\n    if (param == null)\n        param = 99d;\n    maxOptRMSD = param;\n}", "repo_id": "9", "comment": "/**\n * set the maximum RMSD cutoff to be applied during alignment optimization. (default: 99 = unlimited)\n *\n * @param param maxOptRMSD\n */\n", "repo_name": "biojava-master/", "id": 753, "method_signature": "void setMaxOptRMSD(Double)"}, "569": {"callee_method_names": ["Atom.clone", "Atom.clone"], "method_name": "RotationAxis.getAxisEnds", "method_implementation": "{\n    // Project each Atom onto the rotation axis to determine limits\n    double min, max;\n    min = max = Calc.scalarProduct(rotationAxis, atoms[0]);\n    for (int i = 1; i < atoms.length; i++) {\n        double prod = Calc.scalarProduct(rotationAxis, atoms[i]);\n        if (prod < min)\n            min = prod;\n        if (prod > max)\n            max = prod;\n    }\n    // Should be 1, but double check\n    double uLen = Calc.scalarProduct(rotationAxis, rotationAxis);\n    min /= uLen;\n    max /= uLen;\n    // Project the origin onto the axis. If the axis is undefined, use the center of mass\n    Atom axialPt;\n    if (rotationPos == null) {\n        Atom center = Calc.centerOfMass(atoms);\n        // Project center onto the axis\n        Atom centerOnAxis = Calc.scale(rotationAxis, Calc.scalarProduct(center, rotationAxis));\n        // Remainder is projection of origin onto axis\n        axialPt = Calc.subtract(center, centerOnAxis);\n    } else {\n        axialPt = rotationPos;\n    }\n    // Find end points of the rotation axis to display\n    Atom axisMin = (Atom) axialPt.clone();\n    Calc.scaleAdd(min, rotationAxis, axisMin);\n    Atom axisMax = (Atom) axialPt.clone();\n    Calc.scaleAdd(max, rotationAxis, axisMax);\n    return new Pair<>(axisMin, axisMax);\n}", "repo_id": "9", "comment": "/**\n * Find a segment of the axis that covers the specified set of atoms.\n * <p>\n * Projects the input atoms onto the rotation axis and returns the bounding\n * points.\n * <p>\n * In the case of a pure translational axis, the axis location is undefined\n * so the center of mass will be used instead.\n * @param atoms\n * @return two points defining the axis segment\n */\n", "repo_name": "biojava-master/", "id": 569, "method_signature": "Pair<Atom> getAxisEnds(Atom[])"}, "3847": {"callee_method_names": ["ProteinSequence.getSequenceAsString", "String.chars"], "method_name": "Convertor.convert", "method_implementation": "{\n    String uppercaseSequence = sequence.getSequenceAsString().toUpperCase();\n    String convertedSequence = uppercaseSequence.chars().mapToObj(upperCaseSeq -> String.valueOf(convert((char) (upperCaseSeq)))).collect(Collectors.joining());\n    return convertedSequence;\n}", "repo_id": "9", "comment": "/**\n * Returns the converted sequence.\n * The sequence argument must be a protein sequence consisting of preferably non-ambiguous characters only.\n * Standard amino acids will be converted to '1', '2' or '3' depending on its grouping\n * Non-standard amino acids are simply converted to '0'.\n *\n * @param sequence\n * \t\ta protein sequence consisting of preferably non-ambiguous characters only\n * @return the converted sequence\n */\n", "repo_name": "biojava-master/", "id": 3847, "method_signature": "String convert(ProteinSequence)"}, "813": {"callee_method_names": [], "method_name": "AlternativeAlignment.setRms", "method_implementation": "{\n    this.rms = rms;\n}", "repo_id": "9", "comment": "/**\n * the rms in the structurally equivalent regions\n *\n * @param rms\n */\n", "repo_name": "biojava-master/", "id": 813, "method_signature": "void setRms(double)"}, "559": {"callee_method_names": [], "method_name": "RotationAxis.getRotationPos", "method_implementation": "{\n    return rotationPos;\n}", "repo_id": "9", "comment": "/**\n * Get a position on the rotation axis.\n *\n * Specifically, project the origin onto the rotation axis\n * @return rotationPos\n */\n", "repo_name": "biojava-master/", "id": 559, "method_signature": "Atom getRotationPos()"}, "739": {"callee_method_names": [], "method_name": "CeCalculatorEnhanced.pToZ", "method_implementation": "{\n    int ind = (int) (-Math.log10(p) * 3.0);\n    if (ind < 0)\n        ind = 0;\n    if (ind > 149)\n        ind = 149;\n    return (tablePtoZ[ind]);\n}", "repo_id": "9", "comment": "///////////////////////////////////////////////////////////////////////////\n", "repo_name": "biojava-master/", "id": 739, "method_signature": "double pToZ(double)"}, "1011": {"callee_method_names": [], "method_name": "NucleotideImpl.getO3Prime", "method_implementation": "{\n    return getAtom(\"O3'\");\n}", "repo_id": "9", "comment": "/**\n * Returns the O3' atom if present, otherwise null\n * @return O3' atom or null\n */\n", "repo_name": "biojava-master/", "id": 1011, "method_signature": "Atom getO3Prime()"}, "2057": {"callee_method_names": [], "method_name": "CeSymmIterative.execute", "method_implementation": "{\n    // First iterate through all levels and then reconstruct all repeats\n    iterate(atoms);\n    return reconstructSymmResult(atoms);\n}", "repo_id": "9", "comment": "/**\n * This method uses iteratively CeSymm to calculate all symmetries in the\n * input array of atoms and organize them in a multiple alignment of the\n * repeats.\n *\n * @param atoms\n *            atoms\n * @return CeSymmResult\n *\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2057, "method_signature": "CeSymmResult execute(Atom[])"}, "1395": {"callee_method_names": [], "method_name": "DBRef.setSeqEnd", "method_implementation": "{\n    this.seqEnd = seqEnd;\n}", "repo_id": "9", "comment": "/**\n * Ending sequence number   of the PDB sequence segment.\n *\n *  @param seqEnd sequence end position\n *  @see #setSeqEnd(int)\n */\n", "repo_name": "biojava-master/", "id": 1395, "method_signature": "void setSeqEnd(int)"}, "291": {"callee_method_names": [], "method_name": "ProteinModificationIdentifier.getUnidentifiableAtomLinkages", "method_implementation": "{\n    if (!recordUnidentifiableModifiedCompounds) {\n        throw new UnsupportedOperationException(\"Recording unidentified atom linkages\" + \"is not supported. Please setRecordUnidentifiableCompounds(true) first.\");\n    }\n    if (identifiedModifiedCompounds == null) {\n        throw new IllegalStateException(\"No result available. Please call parse() first.\");\n    }\n    return unidentifiableAtomLinkages;\n}", "repo_id": "9", "comment": "/**\n * @return a set of atom linkages, which represent the\n *  atom bonds that were not covered by the identified\n *  {@link ModifiedCompound}s from the last parse result.\n *  Each element of the list is a array containing two atoms.\n * @see StructureAtomLinkage\n * @see #setRecordUnidentifiableCompounds\n */\n", "repo_name": "biojava-master/", "id": 291, "method_signature": "Set<StructureAtomLinkage> getUnidentifiableAtomLinkages()"}, "1642": {"callee_method_names": [], "method_name": "SubunitClustererParameters.isUseTMScore", "method_implementation": "{\n    return useTMScore;\n}", "repo_id": "9", "comment": "/**\n * Use TMScore for evaluating structure similarity\n *\n * @return useTMScore\n */\n", "repo_name": "biojava-master/", "id": 1642, "method_signature": "boolean isUseTMScore()"}, "3663": {"callee_method_names": [], "method_name": "SurvivalInfo.getLinearPredictor", "method_implementation": "{\n    return linearPredictor;\n}", "repo_id": "9", "comment": "/**\n * @return the linearPredictor\n */\n", "repo_name": "biojava-master/", "id": 3663, "method_signature": "double getLinearPredictor()"}, "1631": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setStructureCoverageThreshold", "method_implementation": "{\n    this.structureCoverageThreshold = structureCoverageThreshold;\n}", "repo_id": "9", "comment": "/**\n * The minimum coverage of the structure alignment between two subunits to be\n * clustered together.\n *\n * @param structureCoverageThreshold\n */\n", "repo_name": "biojava-master/", "id": 1631, "method_signature": "void setStructureCoverageThreshold(double)"}, "824": {"callee_method_names": [], "method_name": "AlternativeAlignment.getRotationMatrix", "method_implementation": "{\n    return currentRotMatrix;\n}", "repo_id": "9", "comment": "/**\n * returns the rotation matrix that needs to be applied to structure 2 to rotate on structure 1\n *\n * @return the rotation Matrix\n */\n", "repo_name": "biojava-master/", "id": 824, "method_signature": "Matrix getRotationMatrix()"}, "258": {"callee_method_names": ["Map<String, ProteinModification>.keySet"], "method_name": "ProteinModificationRegistry.allIds", "method_implementation": "{\n    lazyInit();\n    Set<String> ret = byId.keySet();\n    return Collections.unmodifiableSet(ret);\n}", "repo_id": "9", "comment": "/**\n * @return set of IDs of all registered ProteinModifications.\n */\n", "repo_name": "biojava-master/", "id": 258, "method_signature": "Set<String> allIds()"}, "1335": {"callee_method_names": [], "method_name": "ResidueNumber.toPDB", "method_implementation": "{\n    String insCodeS;\n    if (insCode != null)\n        insCodeS = insCode + \"\";\n    else\n        insCodeS = \" \";\n    return String.format(\"%s%4d%-2s\", chainName, seqNum, insCodeS);\n}", "repo_id": "9", "comment": "/**\n * @return The chain, number, and insertion code as a string, eg \"B  74A\" or \"A    1 \"\n */\n", "repo_name": "biojava-master/", "id": 1335, "method_signature": "String toPDB()"}, "3799": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getFileName", "method_implementation": "{\n    return fileName;\n}", "repo_id": "9", "comment": "/**\n * @return the fileName\n */\n", "repo_name": "biojava-master/", "id": 3799, "method_signature": "String getFileName()"}, "1641": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setUseRMSD", "method_implementation": "{\n    this.useRMSD = useRMSD;\n}", "repo_id": "9", "comment": "/**\n * Use RMSD for evaluating structure similarity\n *\n * @param useRMSD\n */\n", "repo_name": "biojava-master/", "id": 1641, "method_signature": "void setUseRMSD(boolean)"}, "2346": {"callee_method_names": ["String.length"], "method_name": "FastqBuilder.appendQuality", "method_implementation": "{\n    if (quality == null) {\n        throw new IllegalArgumentException(\"quality must not be null\");\n    }\n    if (this.quality == null) {\n        this.quality = new StringBuilder(quality.length());\n    }\n    this.quality.append(quality);\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Return this FASTQ formatted sequence builder configured with the specified quality scores\n * appended to its current quality scores.\n *\n * @param quality quality scores to append to the quality scores for this FASTQ formatted sequence\n *    builder, must not be null\n * @return this FASTQ formatted sequence builder configured with the specified quality scores\n *    appended to its current quality scores\n */\n", "repo_name": "biojava-master/", "id": 2346, "method_signature": "FastqBuilder appendQuality(String)"}, "2028": {"callee_method_names": [], "method_name": "RectangularPrism.getHeight", "method_implementation": "{\n    return height;\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a sphere, that is tangent to each\n * of the octahedron's edges\n *\n * @return the midRadius\n */\n", "repo_name": "biojava-master/", "id": 2028, "method_signature": "double getHeight()"}, "919": {"callee_method_names": ["HashMap<Pair<ResidueIdentifier>, GroupContact>.containsKey"], "method_name": "GroupContactSet.hasContact", "method_implementation": "{\n    return contacts.containsKey(new Pair<ResidueIdentifier>(resId1, resId2));\n}", "repo_id": "9", "comment": "/**\n * Tell whether the given pair is a contact in this GroupContactSet,\n * in a chain-identifier independent way: contacts happening between different copies of\n * the same Compound(Entity) will be considered equal as long as they have the same\n * residue numbers.\n * @param resId1\n * @param resId2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 919, "method_signature": "boolean hasContact(ResidueIdentifier, ResidueIdentifier)"}, "3828": {"callee_method_names": ["LinkedHashMap<String, String>.put", "LinkedHashMap<String, String>.put", "LinkedHashMap<String, String>.put", "LinkedHashMap<String, String>.put", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "ArrayList<MetaDataInfo>.add", "int.printStackTrace"], "method_name": "ClinicalMetaDataOutcome.main", "method_implementation": "{\n    try {\n        LinkedHashMap<String, String> censorMap = new LinkedHashMap<String, String>();\n        censorMap.put(\"a\", \"0\");\n        censorMap.put(\"d\", \"1\");\n        censorMap.put(\"d-d.s.\", \"1\");\n        censorMap.put(\"d-o.c.\", \"1\");\n        String timeColumn = \"TIME\";\n        // \"survstat3\";\n        String sensorMapColumn = \"last_follow_up_status\";\n        double timeScale = 1.0;\n        ArrayList<MetaDataInfo> metaDataInfoList = new ArrayList<MetaDataInfo>();\n        metaDataInfoList.add(new MetaDataInfo(\"age_at_diagnosis\", true, new MeanQuantizer()));\n        metaDataInfoList.add(new MetaDataInfo(\"size\", true, new MeanQuantizer()));\n        metaDataInfoList.add(new MetaDataInfo(\"lymph_nodes_positive\", true, new MeanQuantizer()));\n        metaDataInfoList.add(new MetaDataInfo(\"lymph_nodes_removed\", true, new MeanQuantizer()));\n        metaDataInfoList.add(new MetaDataInfo(\"NPI\", true, new MeanQuantizer()));\n        metaDataInfoList.add(new MetaDataInfo(\"menopausal_status_inferred\"));\n        metaDataInfoList.add(new MetaDataInfo(\"group\"));\n        metaDataInfoList.add(new MetaDataInfo(\"grade\"));\n        metaDataInfoList.add(new MetaDataInfo(\"stage\"));\n        metaDataInfoList.add(new MetaDataInfo(\"ER_IHC_status\"));\n        metaDataInfoList.add(new MetaDataInfo(\"HER2_IHC_status\"));\n        metaDataInfoList.add(new MetaDataInfo(\"HER2_SNP6_state\"));\n        metaDataInfoList.add(new MetaDataInfo(\"cellularity\"));\n        metaDataInfoList.add(new MetaDataInfo(\"P53_mutation_status\"));\n        metaDataInfoList.add(new MetaDataInfo(\"P53_mutation_type\"));\n        metaDataInfoList.add(new MetaDataInfo(\"Pam50Subtype\"));\n        metaDataInfoList.add(new MetaDataInfo(\"Genefu\"));\n        WorkSheet worksheet = WorkSheet.readCSV(\"/Users/Scooter/scripps/ngs/DataSets/METABRIC/EGAD00010000210/table_S2_revised.txt\", '\\t');\n        ClinicalMetaDataOutcome.process(worksheet, sensorMapColumn, censorMap, timeColumn, timeScale, metaDataInfoList);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 3828, "method_signature": "void main(String[])"}, "2504": {"callee_method_ids": [2626], "callee_method_names": ["Runtime.totalMemory", "Runtime.freeMemory", "Runtime.freeMemory", "Runtime.totalMemory", "Runtime.maxMemory", "File.exists", "InputStreamProvider.getInputStream", "FastaReader<ProteinSequence, AminoAcidCompound>.process", "LinkedHashMap<String, ProteinSequence>.keySet", "LinkedHashMap<String, ProteinSequence>.get"], "method_name": "ParseFastaFileDemo.main", "method_implementation": "{\n    int mb = 1024 * 1024;\n    //Getting the runtime reference from system\n    Runtime runtime = Runtime.getRuntime();\n    System.out.println(\"##### Heap utilization statistics [MB] #####\");\n    //Print used memory\n    System.out.println(\"Used Memory:\" + (runtime.totalMemory() - runtime.freeMemory()) / mb);\n    //Print free memory\n    System.out.println(\"Free Memory:\" + runtime.freeMemory() / mb);\n    //Print total available memory\n    System.out.println(\"Total Memory:\" + runtime.totalMemory() / mb);\n    //Print Maximum available memory\n    System.out.println(\"Max Memory:\" + runtime.maxMemory() / mb);\n    if (args.length < 1) {\n        System.err.println(\"First argument needs to be path to fasta file\");\n        return;\n    }\n    File f = new File(args[0]);\n    if (!f.exists()) {\n        System.err.println(\"File does not exist \" + args[0]);\n        return;\n    }\n    long timeS = System.currentTimeMillis();\n    // automatically uncompress files using InputStreamProvider\n    InputStreamProvider isp = new InputStreamProvider();\n    InputStream inStream = isp.getInputStream(f);\n    FastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(inStream, new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n    LinkedHashMap<String, ProteinSequence> b;\n    int nrSeq = 0;\n    while ((b = fastaReader.process(100)) != null) {\n        for (String key : b.keySet()) {\n            nrSeq++;\n            System.out.println(nrSeq + \" : \" + key + \" \" + b.get(key));\n            if (nrSeq % 100000 == 0)\n                System.out.println(nrSeq);\n        }\n    }\n    long timeE = System.currentTimeMillis();\n    System.out.println(\"parsed a total of \" + nrSeq + \" TREMBL sequences! in \" + (timeE - timeS));\n}", "repo_id": "9", "comment": "/**\n * e.g. download ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_trembl.fasta.gz\n * and pass in path to local location of file\n *\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 2504, "method_signature": "void main(String[])"}, "1856": {"callee_method_names": [], "method_name": "Rotation.getTraceTmScoreMin", "method_implementation": "{\n    return traceTmScoreMin;\n}", "repo_id": "9", "comment": "/**\n * @return the traceTmScoreMin\n */\n", "repo_name": "biojava-master/", "id": 1856, "method_signature": "double getTraceTmScoreMin()"}, "3850": {"callee_method_names": [], "method_name": "ProfeatProperties.getDistributionPosition", "method_implementation": "{\n    return new ProfeatPropertiesImpl().getDistributionPosition(sequence, attribute, group, distribution);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method which computes and return the position with respect to the sequence where the given distribution of the grouping can be found.<br/>\n * Example: \"1111122222\"<br/>\n * For the above example,<br/>\n * position of the GROUPING.GROUP1 && DISTRIBUTION.FIRST = 0/10 (because the first occurrence of '1' is at position 0)<br/>\n * position of the GROUPING.GROUP1 && DISTRIBUTION.ALL = 4/10 (because all occurrences of '1' happens on and before position 4)<br/>\n *\n * @param sequence\n * \ta protein sequence consisting of non-ambiguous characters only\n * @param attribute\n * \tone of the seven attributes (Hydrophobicity, Volume, Polarity, Polarizability, Charge, SecondaryStructure or SolventAccessibility)\n * @param group\n * \tone the three groups for the attribute\n * @param distribution\n * \tthe distribution of the grouping\n *\n * @return\n * \tthe position with respect to the length of sequence where the given distribution of the grouping can be found.<br/>\n * @throws Exception\n * \tthrows Exception if attribute or group are unknown\n */\n", "repo_name": "biojava-master/", "id": 3850, "method_signature": "double getDistributionPosition(ProteinSequence, ATTRIBUTE, GROUPING, DISTRIBUTION)"}, "1808": {"callee_method_names": [], "method_name": "EcodInstallation.setUrl", "method_implementation": "{\n    this.url = url;\n}", "repo_id": "9", "comment": "/**\n * Specify a different mirror for the ECOD server.\n * @param urlFormat the urlFormat to set\n */\n", "repo_name": "biojava-master/", "id": 1808, "method_signature": "void setUrl(String)"}, "3007": {"callee_method_names": [], "method_name": "BitArrayWorker.setCompoundAt", "method_implementation": "{\n    hashcode = null;\n    int arrayIndex = biologicalIndexToArrayIndex(position);\n    int currentInt = sequence[arrayIndex];\n    int shiftBy = shiftBy(position);\n    Integer integerValue = getCompoundsToIndexLookup().get(compound);\n    //If we got nothing then throw an error as it's wrong\n    if (integerValue == null) {\n        processUnknownCompound(compound, position);\n    }\n    int shiftedValue = integerValue << shiftBy;\n    sequence[arrayIndex] = currentInt | shiftedValue;\n}", "repo_id": "9", "comment": "/**\n * Sets the compound at the specified biological index\n */\n", "repo_name": "biojava-master/", "id": 3007, "method_signature": "void setCompoundAt(C, int)"}, "849": {"callee_method_names": [], "method_name": "SparseVector.size", "method_implementation": "{\n    return N;\n}", "repo_id": "9", "comment": "// return the size of the vector\n", "repo_name": "biojava-master/", "id": 849, "method_signature": "int size()"}, "3679": {"callee_method_names": [], "method_name": "WaldTestInfo.getTest", "method_implementation": "{\n    return bsum[0];\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3679, "method_signature": "double getTest()"}, "2424": {"callee_method_names": [], "method_name": "Location.toString", "method_implementation": "{\n    return \"[L=\" + (mEnd - mStart) + \"; S=\" + mStart + \"; E=\" + mEnd + \"]\";\n}", "repo_id": "9", "comment": "/**\n * Return a string representation of location.\n *\n * @return Text string.\n */\n", "repo_name": "biojava-master/", "id": 2424, "method_signature": "String toString()"}, "2333": {"callee_method_names": ["LinkedList.addFirst"], "method_name": "GlobalsHelper.pushState", "method_implementation": "{\n    PathInfo paths = new PathInfo();\n    stack.addFirst(paths);\n}", "repo_id": "9", "comment": "/**\n * Save current global state to the stack\n */\n", "repo_name": "biojava-master/", "id": 2333, "method_signature": "void pushState()"}, "754": {"callee_method_names": [], "method_name": "CeParameters.getMaxOptRMSD", "method_implementation": "{\n    return maxOptRMSD;\n}", "repo_id": "9", "comment": "/**\n * Returns the maximum RMSD cutoff to be applied during alignment optimization (default: 99 = unlimited)\n *\n * @return maxOptRMSD\n */\n", "repo_name": "biojava-master/", "id": 754, "method_signature": "Double getMaxOptRMSD()"}, "1336": {"callee_method_names": ["String.split", "ResidueNumber.setSeqNum", "ResidueNumber.setInsCode", "String.length", "ResidueNumber.setInsCode", "String.charAt"], "method_name": "ResidueNumber.fromString", "method_implementation": "{\n    if (pdb_code == null)\n        return null;\n    ResidueNumber residueNumber = new ResidueNumber();\n    Integer resNum = null;\n    String icode = null;\n    try {\n        resNum = Integer.parseInt(pdb_code);\n    } catch (NumberFormatException e) {\n        // there is an insertion code..\n        // Split at any position that's either:\n        // preceded by a digit and followed by a non-digit, or\n        // preceded by a non-digit and followed by a digit.\n        String[] spl = pdb_code.split(\"(?<=\\\\d)(?=\\\\D)|(?<=\\\\D)(?=\\\\d)\");\n        if (spl.length == 2) {\n            resNum = Integer.parseInt(spl[0]);\n            icode = spl[1];\n        }\n    }\n    residueNumber.setSeqNum(resNum);\n    if (icode == null)\n        residueNumber.setInsCode(null);\n    else if (icode.length() > 0)\n        residueNumber.setInsCode(icode.charAt(0));\n    return residueNumber;\n}", "repo_id": "9", "comment": "/**\n * Convert a string representation of a residue number to a residue number object.\n * The string representation can be a integer followed by a character.\n *\n * @param pdb_code\n * @return a ResidueNumber object, or null if the input was null\n */\n", "repo_name": "biojava-master/", "id": 1336, "method_signature": "ResidueNumber fromString(String)"}, "1412": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.getSpaceGroup", "method_implementation": "{\n    return sg;\n}", "repo_id": "9", "comment": "/**\n * Get the SpaceGroup\n * @return the spaceGroup\n */\n", "repo_name": "biojava-master/", "id": 1412, "method_signature": "SpaceGroup getSpaceGroup()"}, "2251": {"callee_method_names": [], "method_name": "TestMmtfUtils.testConvertToDoubleArray", "method_implementation": "{\n    Matrix4d matrix4d = new Matrix4d();\n    matrix4d.m00 = 0.0;\n    matrix4d.m01 = 0.1;\n    matrix4d.m02 = 0.2;\n    matrix4d.m03 = 0.3;\n    matrix4d.m10 = 1.0;\n    matrix4d.m11 = 1.1;\n    matrix4d.m12 = 1.2;\n    matrix4d.m13 = 1.3;\n    matrix4d.m20 = 2.0;\n    matrix4d.m21 = 2.1;\n    matrix4d.m22 = 2.2;\n    matrix4d.m23 = 2.3;\n    matrix4d.m30 = 3.0;\n    matrix4d.m31 = 3.1;\n    matrix4d.m32 = 3.2;\n    matrix4d.m33 = 3.3;\n    double[] testData = new double[] { 0.0, 0.1, 0.2, 0.3, 1.0, 1.1, 1.2, 1.3, 2.0, 2.1, 2.2, 2.3, 3.0, 3.1, 3.2, 3.3 };\n    assertArrayEquals(testData, MmtfUtils.convertToDoubleArray(matrix4d), 0.0);\n}", "repo_id": "9", "comment": "/**\n * Test the conversion of a matrix to an array of doubles.\n */\n", "repo_name": "biojava-master/", "id": 2251, "method_signature": "void testConvertToDoubleArray()"}, "2569": {"callee_method_names": ["URL.toString", "URLConnection.connect", "URLConnection.getInputStream", "FileOutputStream.getChannel", "ReadableByteChannel.close", "FileOutputStream.close", "Logger.debug", "File.toPath", "File.toPath", "File.delete"], "method_name": "FileDownloadUtils.downloadFile", "method_implementation": "{\n    int count = 0;\n    int maxTries = 10;\n    //60 sec\n    int timeout = 60000;\n    File tempFile = Files.createTempFile(getFilePrefix(destination), \".\" + getFileExtension(destination)).toFile();\n    // Took following recipe from stackoverflow:\n    // http://stackoverflow.com/questions/921262/how-to-download-and-save-a-file-from-internet-using-java\n    // It seems to be the most efficient way to transfer a file\n    // See: http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html\n    ReadableByteChannel rbc = null;\n    FileOutputStream fos = null;\n    while (true) {\n        try {\n            URLConnection connection = prepareURLConnection(url.toString(), timeout);\n            connection.connect();\n            InputStream inputStream = connection.getInputStream();\n            rbc = Channels.newChannel(inputStream);\n            fos = new FileOutputStream(tempFile);\n            fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n            break;\n        } catch (SocketTimeoutException e) {\n            if (++count == maxTries)\n                throw e;\n        } finally {\n            if (rbc != null) {\n                rbc.close();\n            }\n            if (fos != null) {\n                fos.close();\n            }\n        }\n    }\n    logger.debug(\"Copying temp file [{}] to final location [{}]\", tempFile, destination);\n    Files.copy(tempFile.toPath(), destination.toPath(), StandardCopyOption.REPLACE_EXISTING);\n    // delete the tmp file\n    tempFile.delete();\n}", "repo_id": "9", "comment": "/**\n * Download the content provided at URL url and store the result to a local\n * file, using a temp file to cache the content in case something goes wrong\n * in download. A timeout of 60 seconds is hard-coded and 10 retries are attempted.\n *\n * @param url\n * @param destination\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2569, "method_signature": "void downloadFile(URL, File)"}, "3373": {"callee_method_names": [], "method_name": "LogColorMapper.transform", "method_implementation": "{\n    double logValue = Math.log(value > 0 ? value : 0) / Math.log(base);\n    return logValue;\n}", "repo_id": "9", "comment": "/**\n * Apply log transform.\n * @param value\n * @return log_b(value)\n * @see org.biojava.nbio.structure.gui.util.color.ContinuousColorMapperTransform#transform(double)\n */\n", "repo_name": "biojava-master/", "id": 3373, "method_signature": "double transform(double)"}, "1312": {"callee_method_ids": [502, 477, 497], "callee_method_names": ["List<ResidueNumber>.add", "List<ResidueNumber>.add", "List<ResidueNumber>.toArray", "List<ResidueNumber>.size", "List<ResidueNumber>.toArray", "List<ResidueNumber>.size", "AFPChain.setAlgorithmName", "AFPChain.setBlockSize", "AFPChain.getNrEQR", "AFPChain.setBlockRmsd", "AFPChain.getTotalRmsdOpt", "AFPChain.setBlockGap", "AFPChain.getGapLen"], "method_name": "FastaAFPChainConverter.buildAlignment", "method_implementation": "{\n    // remove any gap\n    // this includes the ones introduced by the nullifying above\n    List<ResidueNumber> alignedResiduesList1 = new ArrayList<ResidueNumber>();\n    List<ResidueNumber> alignedResiduesList2 = new ArrayList<ResidueNumber>();\n    for (int i = 0; i < residues1.length; i++) {\n        if (residues1[i] != null && residues2[i] != null) {\n            alignedResiduesList1.add(residues1[i]);\n            alignedResiduesList2.add(residues2[i]);\n        }\n    }\n    ResidueNumber[] alignedResidues1 = alignedResiduesList1.toArray(new ResidueNumber[alignedResiduesList1.size()]);\n    ResidueNumber[] alignedResidues2 = alignedResiduesList2.toArray(new ResidueNumber[alignedResiduesList2.size()]);\n    AFPChain afpChain = AlignmentTools.createAFPChain(ca1, ca2, alignedResidues1, alignedResidues2);\n    afpChain.setAlgorithmName(\"unknown\");\n    AlignmentTools.updateSuperposition(afpChain, ca1, ca2);\n    afpChain.setBlockSize(new int[] { afpChain.getNrEQR() });\n    afpChain.setBlockRmsd(new double[] { afpChain.getTotalRmsdOpt() });\n    afpChain.setBlockGap(new int[] { afpChain.getGapLen() });\n    return afpChain;\n}", "repo_id": "9", "comment": "/**\n * Builds an {@link AFPChain} from already-matched arrays of atoms and residues.\n *\n * @param ca1\n *            An array of atoms in the first structure\n * @param ca2\n *            An array of atoms in the second structure\n * @param residues1\n *            An array of {@link ResidueNumber ResidueNumbers} in the first structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n * @param residues2\n *            An array of {@link ResidueNumber ResidueNumbers} in the second structure that are aligned. Only null ResidueNumbers are considered to be unaligned\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 1312, "method_signature": "AFPChain buildAlignment(Atom[], Atom[], ResidueNumber[], ResidueNumber[])"}, "711": {"callee_method_ids": [759, 746], "callee_method_names": ["AFPChain.setCa1Length", "AFPChain.setCa2Length", "CeParameters.getScoringStrategy", "CeParameters.getSeqWeight", "CeParameters.setSeqWeight", "CeParameters.getWinSize"], "method_name": "CECalculator.extractFragments", "method_implementation": "{\n    int nse1 = ca1.length;\n    int nse2 = ca2.length;\n    afpChain.setCa1Length(nse1);\n    afpChain.setCa2Length(nse2);\n    int traceMaxSize = nse1 < nse2 ? nse1 : nse2;\n    f1 = new int[nse1];\n    f2 = new int[nse2];\n    dist1 = initIntraDistmatrix(ca1, nse1);\n    dist2 = initIntraDistmatrix(ca2, nse2);\n    if (debug)\n        System.out.println(\"parameters: \" + params);\n    if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SEQUENCE_CONSERVATION) {\n        if (params.getSeqWeight() < 1)\n            params.setSeqWeight(2);\n    }\n    int winSize = params.getWinSize();\n    int winSizeComb1 = (winSize - 1) * (winSize - 2) / 2;\n    traceIndexContainer = new int[traceMaxSize];\n    // CE: unused code. distAll is always false and both loops do the same???\n    // CE v2.3 calls this Weight factors for trace extension\n    if (distAll) {\n        for (int i = 0; i < traceMaxSize; i++) traceIndexContainer[i] = (i + 1) * i * winSize * winSize / 2 + (i + 1) * winSizeComb1;\n    } else {\n        for (int i = 0; i < traceMaxSize; i++) {\n            traceIndexContainer[i] = (i + 1) * i * winSize / 2 + (i + 1) * winSizeComb1;\n        }\n    }\n    // verified: a[] is set correctly.\n    mat = initSumOfDistances(nse1, nse2, winSize, winSizeComb1, ca1, ca2);\n    //\t\ttry {\n    //\t\t\tMatrix m2 = new Matrix(mat).copy();\n    //\t\t\tJPanel panel = GuiWrapper.getScaleableMatrixPanel(m2);\n    //\t\t\tJFrame frame = new JFrame();\n    //\t\t\tframe.addWindowListener(new WindowAdapter(){\n    //\t\t\t\tpublic void windowClosing(WindowEvent e){\n    //\t\t\t\t\tJFrame f = (JFrame) e.getSource();\n    //\t\t\t\t\tf.setVisible(false);\n    //\t\t\t\t\tf.dispose();\n    //\t\t\t\t}\n    //\t\t\t});\n    //\n    //\n    //\t\t\tframe.getContentPane().add(panel);\n    //\n    //\t\t\tframe.pack();\n    //\t\t\tframe.setVisible(true);\n    //\t\t} catch (Exception e) {\n    //\t\t\te.printStackTrace();\n    //\t\t}\n    // Set the distance matrix\n    //afpChain.setDistanceMatrix(new Matrix(mat.clone()));\n    //\n    //\t\t\t   double rmsdThr = params.getRmsdThr();\n    //\t\t\t   StringBuffer buf = new StringBuffer(\"  \");\n    //\t\t\t   for(int i=0; i<nse2; i++)\n    //\t\t\t      buf.append(String.format(\"%c\", i%10==0?(i%100)/10+48:32));\n    //\t\t\t   buf.append(\"\\n\");\n    //\t\t\t   for(int i=0; i<nse1; i++) {\n    //\t\t\t      buf.append(String.format(\"%c \", i%10==0?(i%100)/10+48:32));\n    //\t\t\t      for(int j=0; j<nse2; j++)\n    //\t\t\t         buf.append(String.format(\"%c\", (mat[i][j])<rmsdThr?'+':'X'));\n    //\t\t\t      //printf(\"%c\", ((int)*(mat[i]+j)/40)>9?'*':((int)*(mat[i]+j)/40)+48);\n    //\t\t\t      buf.append(\"\\n\");\n    //\t\t\t   }\n    //\t\t\t   buf.append(\"\\n\");\n    //\n    //\t\t\t   System.out.println(buf.toString());\n    //\n    return afpChain;\n}", "repo_id": "9", "comment": "/**\n * @param afpChain A new AFPChain, which will be filled in by this function\n * @param ca1\n * @param ca2\n * @return afpChain\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 711, "method_signature": "AFPChain extractFragments(AFPChain, Atom[], Atom[])"}, "2340": {"callee_method_names": [], "method_name": "Collect.getResult", "method_implementation": "{\n    return Iterables.unmodifiableIterable(result);\n}", "repo_id": "9", "comment": "/**\n * Return an unmodifiable iterable over the FASTQ formatted sequences collected by this stream listener.\n *\n * @return an unmodifiable iterable over the FASTQ formatted sequences collected by this stream listener\n */\n", "repo_name": "biojava-master/", "id": 2340, "method_signature": "Iterable<Fastq> getResult()"}, "3318": {"callee_method_ids": [3315], "callee_method_names": ["JMatrixPanel.getCellColor"], "method_name": "ScaleableMatrixPanel.getCellColor", "method_implementation": "{\n    return mPanel.getCellColor();\n}", "repo_id": "9", "comment": "/**\n * @return the color mapping of the JMatrixPanel\n */\n", "repo_name": "biojava-master/", "id": 3318, "method_signature": "ContinuousColorMapper getCellColor()"}, "2297": {"callee_method_names": [], "method_name": "TestBond.testAltLocBondMissing", "method_implementation": "{\n    assertEquals(0, countAtomsWithoutBonds(\"4cup\"));\n}", "repo_id": "9", "comment": "/**\n * Test whether these partial occupancy hydrogens are bonded to the residue.\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2297, "method_signature": "void testAltLocBondMissing()"}, "961": {"callee_method_ids": [958], "callee_method_names": ["Matrix4d.mul", "BiologicalAssemblyTransformation.setTransformationMatrix"], "method_name": "BiologicalAssemblyTransformation.combine", "method_implementation": "{\n    Matrix4d transformation = new Matrix4d(matrix1.transformation);\n    transformation.mul(matrix2.transformation);\n    BiologicalAssemblyTransformation combined = new BiologicalAssemblyTransformation();\n    combined.setTransformationMatrix(transformation);\n    return combined;\n}", "repo_id": "9", "comment": "/**\n * Returns the combination (product) of two biological assembly transformations.\n * @param matrix1\n * @param matrix2\n * @return combined transformation\n */\n", "repo_name": "biojava-master/", "id": 961, "method_signature": "BiologicalAssemblyTransformation combine(BiologicalAssemblyTransformation, BiologicalAssemblyTransformation)"}, "3670": {"callee_method_names": [], "method_name": "SurvivalInfo.setId", "method_implementation": "{\n    this.id = id;\n}", "repo_id": "9", "comment": "/**\n * @param id the id to set\n */\n", "repo_name": "biojava-master/", "id": 3670, "method_signature": "void setId(String)"}, "2935": {"callee_method_names": [], "method_name": "AbstractSequence.setDatabaseReferences", "method_implementation": "{\n    this.databaseReferences = databaseReferences;\n}", "repo_id": "9", "comment": "/**\n * @param databaseReferences the databaseReferences to set\n */\n", "repo_name": "biojava-master/", "id": 2935, "method_signature": "void setDatabaseReferences(DatabaseReferenceInterface)"}, "3497": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.setBlastFromToPosition", "method_implementation": "{\n    if (start >= end) {\n        throw new IllegalArgumentException(\"Start index must be less than end index\");\n    }\n    setAlignmentOption(QUERY_FROM, String.valueOf(start));\n    setAlignmentOption(QUERY_TO, String.valueOf(end));\n}", "repo_id": "9", "comment": "/**\n * Sets the QUERY_FROM and QUERY_TO parameters to be use by blast. Do not use if you want to use the whole sequence.<br/>\n * Blastall equivalent: -L\n *\n * @param start QUERY_FROM parameter\n * @param end QUERY_TO parameter\n */\n", "repo_name": "biojava-master/", "id": 3497, "method_signature": "void setBlastFromToPosition(int, int)"}, "3611": {"callee_method_ids": [3657], "callee_method_names": ["ArrayList.size", "SurvivalInfo.getWeight"], "method_name": "CoxInfo.getWeighted", "method_implementation": "{\n    double[] weighted = new double[survivalInfoList.size()];\n    int p = 0;\n    for (SurvivalInfo si : this.survivalInfoList) {\n        weighted[p] = si.getWeight();\n        p++;\n    }\n    return weighted;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3611, "method_signature": "double[] getWeighted()"}, "1041": {"callee_method_names": ["Structure.getChains", "Chain.getAtomGroups", "Group.hasAminoAtoms", "Group.getType", "List<Atom>.toArray"], "method_name": "StructureTools.getBackboneAtomArray", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>();\n    for (Chain c : s.getChains()) {\n        for (Group g : c.getAtomGroups()) {\n            if (g.hasAminoAtoms()) {\n                if (g.getType() == GroupType.NUCLEOTIDE) {\n                    addNucleotideAndAminoAtoms(atoms, g, NUCLEOTIDE_BACKBONE_ATOMS);\n                } else {\n                    addNucleotideAndAminoAtoms(atoms, g, AMINOACID_BACKBONE_ATOMS);\n                }\n            }\n        }\n    }\n    return atoms.toArray(new Atom[0]);\n}", "repo_id": "9", "comment": "/**\n * Return an Atom array of the main chain atoms: CA, C, N, O Any group that\n * contains those atoms will be included, be it a standard aminoacid or not\n *\n * @param s\n *            the structure object\n * @return an Atom[] array\n */\n", "repo_name": "biojava-master/", "id": 1041, "method_signature": "Atom[] getBackboneAtomArray(Structure)"}, "449": {"callee_method_names": ["Map<Integer,Integer>.size"], "method_name": "QsAlignResult.length", "method_implementation": "{\n    if (subunitMap == null)\n        return 0;\n    return subunitMap.size();\n}", "repo_id": "9", "comment": "/**\n * The length of the alignment is the number of Subunit equivalencies it\n * contains. This is equivalent to the size of the Subunit Map.\n *\n * @return length of the alignment\n */\n", "repo_name": "biojava-master/", "id": 449, "method_signature": "int length()"}, "476": {"callee_method_names": [], "method_name": "AFPChain.clone", "method_implementation": "{\n    return new AFPChain(this);\n}", "repo_id": "9", "comment": "/**\n * Creates and returns a copy of this object.\n */\n", "repo_name": "biojava-master/", "id": 476, "method_signature": "Object clone()"}, "3227": {"callee_method_names": [], "method_name": "ABITracerTest.testURL", "method_implementation": "{\n    assertNotNull(tracer);\n}", "repo_id": "9", "comment": "/**\n * Test of URL method, of class ABITracer.\n */\n", "repo_name": "biojava-master/", "id": 3227, "method_signature": "void testURL()"}, "1664": {"callee_method_names": [], "method_name": "SubunitCluster.getClustererMethod", "method_implementation": "{\n    return method;\n}", "repo_id": "9", "comment": "/**\n * @return the {@link SubunitClustererMethod} used for clustering the\n *         Subunits\n */\n", "repo_name": "biojava-master/", "id": 1664, "method_signature": "SubunitClustererMethod getClustererMethod()"}, "254": {"callee_method_names": ["Map<Component, Set<ProteinModification>>.get", "Map<Component, Set<ProteinModification>>.get", "Set<ProteinModification>.retainAll"], "method_name": "ProteinModificationRegistry.getByComponent", "method_implementation": "{\n    lazyInit();\n    Set<ProteinModification> mods = byComponent.get(comp1);\n    if (mods == null) {\n        return Collections.emptySet();\n    }\n    if (comps.length == 0) {\n        return Collections.unmodifiableSet(mods);\n    } else {\n        Set<ProteinModification> ret = new HashSet<ProteinModification>(mods);\n        for (Component comp : comps) {\n            mods = byComponent.get(comp);\n            if (mods == null) {\n                return Collections.emptySet();\n            } else {\n                ret.retainAll(mods);\n            }\n        }\n        return ret;\n    }\n}", "repo_id": "9", "comment": "/**\n * Get ProteinModifications that involves one or more components.\n * @param comp1 a {@link Component}.\n * @param comps other {@link Component}s.\n * @return a set of ProteinModifications that involves all the components.\n */\n", "repo_name": "biojava-master/", "id": 254, "method_signature": "Set<ProteinModification> getByComponent(Component, Component[])"}, "3582": {"callee_method_names": [], "method_name": "Matrix.subtract", "method_implementation": "{\n    int m = A.length;\n    int n = A[0].length;\n    double[][] C = new double[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            C[i][j] = A[i][j] - B[i][j];\n        }\n    }\n    return C;\n}", "repo_id": "9", "comment": "/**\n * @param A\n * @param B\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3582, "method_signature": "double[][] subtract(double[][], double[][])"}, "1620": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getMinimumSequenceLengthFraction", "method_implementation": "{\n    return minimumSequenceLengthFraction;\n}", "repo_id": "9", "comment": "/**\n * If the shortest subunit sequence length is higher or equal the\n * minimumSequenceLengthFraction times the median subunit sequence length,\n * then the minimumSequenceLength is set to shortest subunit sequence\n * length, but not shorter than the absoluteMinimumSequenceLength.\n * <p>\n * This adaptive feature allows the consideration of structures mainly\n * constructed by very short chains, such as collagen (1A3I)\n *\n * @return the minimumSequenceLengthFraction\n */\n", "repo_name": "biojava-master/", "id": 1620, "method_signature": "double getMinimumSequenceLengthFraction()"}, "3218": {"callee_method_ids": [2658, 2649, 2649], "callee_method_names": ["Builder.initMet", "Builder.translateNCodons", "Builder.trimStop", "Builder.build", "TranscriptionEngine.translate", "Sequence<AminoAcidCompound>.toString", "TranscriptionEngine.translate", "Sequence<AminoAcidCompound>.toString", "Sequence<AminoAcidCompound>.toString"], "method_name": "TranslationTest.testHashCollision", "method_implementation": "{\n    Builder builder = new TranscriptionEngine.Builder();\n    builder.initMet(false);\n    builder.translateNCodons(true);\n    builder.trimStop(false);\n    TranscriptionEngine engine = builder.build();\n    Sequence<AminoAcidCompound> seq = engine.translate(new DNASequence(\"GTNTGTTAGTGT\"));\n    assertThat(\"XC*C\", is(seq.toString()));\n    Sequence<AminoAcidCompound> seq2 = engine.translate(new DNASequence(\"ANAANG\"));\n    assertEquals(\"XX\", seq2.toString());\n    assertNotSame(\"HR\", seq2.toString());\n}", "repo_id": "9", "comment": "/**\n * test for https://github.com/biojava/biojava/issues/53\n */\n", "repo_name": "biojava-master/", "id": 3218, "method_signature": "void testHashCollision()"}, "2703": {"callee_method_names": ["String.length", "String.replaceAll", "String.length", "String.length", "String.charAt", "String.charAt", "String.substring", "String.substring"], "method_name": "GenericInsdcHeaderFormat._write_feature_qualifier", "method_implementation": "{\n    String line = \"\";\n    if (null == value) {\n        line = QUALIFIER_INDENT_STR + \"/\" + key + lineSep;\n        return line;\n    }\n    if (quote) {\n        // quote should be true for numerics\n        line = QUALIFIER_INDENT_STR + \"/\" + key + \"=\\\"\" + value + \"\\\"\";\n    } else {\n        line = QUALIFIER_INDENT_STR + \"/\" + key + \"=\" + value;\n    }\n    if (line.length() <= MAX_WIDTH) {\n        return line + lineSep;\n    }\n    String goodlines = \"\";\n    while (!\"\".equals(line.replaceAll(\"^\\\\s+\", \"\"))) {\n        if (line.length() <= MAX_WIDTH) {\n            goodlines += line + lineSep;\n            break;\n        }\n        //Insert line break...\n        int index;\n        for (index = Math.min(line.length() - 1, MAX_WIDTH); index > QUALIFIER_INDENT; index--) {\n            if (' ' == line.charAt(index)) {\n                break;\n            }\n        }\n        if (' ' != line.charAt(index)) {\n            //no nice place to break...\n            index = MAX_WIDTH;\n        }\n        assert index <= MAX_WIDTH;\n        goodlines += line.substring(0, index) + lineSep;\n        line = QUALIFIER_INDENT_STR + line.substring(index).replaceAll(\"^\\\\s+\", \"\");\n    }\n    return goodlines;\n}", "repo_id": "9", "comment": "/**\n * Format a feature qualifier using the MAX_WIDTH (default 80)\n * @param key\n * @param value\n * @param quote\n */\n", "repo_name": "biojava-master/", "id": 2703, "method_signature": "String _write_feature_qualifier(String, String, boolean)"}, "2642": {"callee_method_names": [], "method_name": "DNASequence.getDNAType", "method_implementation": "{\n    return dnaType;\n}", "repo_id": "9", "comment": "/**\n * @return the dnaType\n */\n", "repo_name": "biojava-master/", "id": 2642, "method_signature": "DNAType getDNAType()"}, "2263": {"callee_method_names": [], "method_name": "TestMmtfUtils.testGetNcsMatrixHard", "method_implementation": "{\n    double[][] testData = new double[][] { { 1.0, 2.0, 3.0, 4.0, 11.0, 12.0, 13.0, 14.0, 21.0, 22.0, 23.0, 24.0, 31.0, 32.0, 33.0, 34.0 }, { 1.0, 2.0, 3.0, 4.0, 11.0, 12.0, 13.0, 14.0, 21.0, 22.0, 23.0, 24.0, 31.0, 32.0, 33.0, 34.0 } };\n    testInput(testData);\n}", "repo_id": "9", "comment": "/**\n * Test that the NCS data can be roundtripped - when two matrices are present.\n */\n", "repo_name": "biojava-master/", "id": 2263, "method_signature": "void testGetNcsMatrixHard()"}, "3194": {"callee_method_names": [], "method_name": "TestFASTAReader.testProcess2", "method_implementation": "{\n    testProcess2(\"org/biojava/nbio/core/fasta/TwoSequences.fasta\");\n}", "repo_id": "9", "comment": "/**\n * Test file contains two sequences. Read one sequence at a time by calling\n * {@link FastaReader#process(int)} and verify that the first and second\n * call get one sequence each and the third call get none.\n *\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3194, "method_signature": "void testProcess2()"}, "2645": {"callee_method_names": [], "method_name": "TaxonomyID.getDataSource", "method_implementation": "{\n    return dataSource;\n}", "repo_id": "9", "comment": "/**\n * @return the source\n */\n", "repo_name": "biojava-master/", "id": 2645, "method_signature": "DataSource getDataSource()"}, "3417": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorH.playOrientations", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    // draw footer\n    s.append(drawFooter(\"Symmetry Helical\", \"white\"));\n    // draw polygon\n    // draw invisibly\n    s.append(drawPolyhedron());\n    s.append(showPolyhedron());\n    // draw axes\n    s.append(drawAxes());\n    s.append(showAxes());\n    // loop over all orientations with 4 sec. delay\n    for (int i = 0; i < getOrientationCount(); i++) {\n        s.append(deleteHeader());\n        s.append(getOrientationWithZoom(i));\n        s.append(drawHeader(getOrientationName(i), \"white\"));\n        s.append(\"delay 4;\");\n    }\n    // go back to first orientation\n    s.append(deleteHeader());\n    s.append(getOrientationWithZoom(0));\n    s.append(drawHeader(getOrientationName(0), \"white\"));\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script that displays a symmetry polyhedron and symmetry axes\n * and then loop through different orientations\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3417, "method_signature": "String playOrientations()"}, "1833": {"callee_method_names": [], "method_name": "AtomIterator.remove", "method_implementation": "{\n}", "repo_id": "9", "comment": "/**\n * does nothing.\n */\n", "repo_name": "biojava-master/", "id": 1833, "method_signature": "void remove()"}, "866": {"callee_method_names": ["SparseVector[].get"], "method_name": "SparseSquareMatrix.get", "method_implementation": "{\n    if (i < 0 || i >= N)\n        throw new IllegalArgumentException(\"Illegal index \" + i + \" should be > 0 and < \" + N);\n    if (j < 0 || j >= N)\n        throw new IllegalArgumentException(\"Illegal index \" + j + \" should be > 0 and < \" + N);\n    return rows[i].get(j);\n}", "repo_id": "9", "comment": "/**\n * access a value at i,j\n *\n * @param i\n * @param j\n * @return return A[i][j]\n */\n", "repo_name": "biojava-master/", "id": 866, "method_signature": "double get(int, int)"}, "3637": {"callee_method_names": [], "method_name": "CoxInfo.getCoefficientsList", "method_implementation": "{\n    return coefficientsList;\n}", "repo_id": "9", "comment": "/**\n * @return the coefficientsList\n */\n", "repo_name": "biojava-master/", "id": 3637, "method_signature": "LinkedHashMap<String,CoxCoefficient> getCoefficientsList()"}, "1963": {"callee_method_names": [], "method_name": "HelixAxisAligner.getPrincipalRotationAxis", "method_implementation": "{\n    run();\n    return principalRotationVector;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getPrincipalRotationAxis()\n\t */\n", "repo_name": "biojava-master/", "id": 1963, "method_signature": "Vector3d getPrincipalRotationAxis()"}, "2050": {"callee_method_names": ["Structure.isNmr", "Structure.nrModels", "Structure.getModel", "List<Atom>.addAll", "List<Atom>.toArray"], "method_name": "SymmetryTools.getRepresentativeAtoms", "method_implementation": "{\n    if (structure.isNmr())\n        return StructureTools.getRepresentativeAtomArray(structure);\n    else {\n        // Get Atoms of all models\n        List<Atom> atomList = new ArrayList<Atom>();\n        for (int m = 0; m < structure.nrModels(); m++) {\n            for (Chain c : structure.getModel(m)) atomList.addAll(Arrays.asList(StructureTools.getRepresentativeAtomArray(c)));\n        }\n        return atomList.toArray(new Atom[0]);\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the representative Atom Array of the first model, if the\n * structure is NMR, or the Array for each model, if it is a biological\n * assembly with multiple models.\n *\n * @param structure\n * @return representative Atom[]\n */\n", "repo_name": "biojava-master/", "id": 2050, "method_signature": "Atom[] getRepresentativeAtoms(Structure)"}, "1420": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.setNonStandardCoordFrameConvention", "method_implementation": "{\n    this.nonStandardCoordFrameConvention = nonStandardCoordFrameConvention;\n}", "repo_id": "9", "comment": "/**\n * Set the non-standard coordinate frame convention field\n * @param nonStandardCoordFrameConvention\n * @since 4.2.5\n */\n", "repo_name": "biojava-master/", "id": 1420, "method_signature": "void setNonStandardCoordFrameConvention(boolean)"}, "2705": {"callee_method_ids": [3106, 3108], "callee_method_names": ["FeatureInterface<AbstractSequence<C>,C>.getType", "Formatter.format", "Formatter.toString", "Formatter.close", "FeatureInterface<AbstractSequence<C>,C>.getQualifiers", "Quat4d.getName", "DBReferenceInfo.getDatabase", "DBReferenceInfo.getId", "DBReferenceInfo.needsQuotes", "Quat4d.getName", "Quat4d.getValue", "Quat4d.needsQuotes"], "method_name": "GenericInsdcHeaderFormat._write_feature", "method_implementation": "{\n    String location = _insdc_feature_location_string(feature, record_length);\n    String f_type = feature.getType().replace(\" \", \"_\");\n    StringBuilder sb = new StringBuilder();\n    Formatter formatter = new Formatter(sb, Locale.US);\n    formatter.format(QUALIFIER_INDENT_TMP, f_type);\n    String line = formatter.toString().substring(0, QUALIFIER_INDENT) + _wrap_location(location) + lineSep;\n    formatter.close();\n    //Now the qualifiers...\n    for (List<Qualifier> qualifiers : feature.getQualifiers().values()) {\n        for (Qualifier q : qualifiers) {\n            if (q instanceof DBReferenceInfo) {\n                DBReferenceInfo db = (DBReferenceInfo) q;\n                line += _write_feature_qualifier(q.getName().replaceAll(\"%\", \"%%\"), db.getDatabase().replaceAll(\"%\", \"%%\") + \":\" + db.getId().replaceAll(\"%\", \"%%\"), db.needsQuotes());\n            } else {\n                line += _write_feature_qualifier(q.getName().replaceAll(\"%\", \"%%\"), q.getValue().replaceAll(\"%\", \"%%\"), q.needsQuotes());\n            }\n        }\n    }\n    return line;\n    /*\n\t\tself.handle.write(line)\n\t\t#Now the qualifiers...\n\t\tfor key, values in feature.qualifiers.items():\n\t\t\tif isinstance(values, list) or isinstance(values, tuple):\n\t\t\t\tfor value in values:\n\t\t\t\t\tself._write_feature_qualifier(key, value)\n\t\t\telif values:\n\t\t\t\t#String, int, etc\n\t\t\t\tself._write_feature_qualifier(key, values)\n\t\t\telse:\n\t\t\t\t#e.g. a /psuedo entry\n\t\t\t\tself._write_feature_qualifier(key)\n\t\t */\n}", "repo_id": "9", "comment": "/**\n * Write a single SeqFeature object to features table.\n * @param feature\n * @param record_length\n */\n", "repo_name": "biojava-master/", "id": 2705, "method_signature": "String _write_feature(FeatureInterface, int)"}, "3524": {"callee_method_names": [], "method_name": "StrataInfo.getWeight", "method_implementation": "{\n    return weight;\n}", "repo_id": "9", "comment": "/**\n * @return the weight\n */\n", "repo_name": "biojava-master/", "id": 3524, "method_signature": "ArrayList<Double> getWeight()"}, "1873": {"callee_method_names": [], "method_name": "Helix.setPermutation", "method_implementation": "{\n    this.permutation = permutation;\n}", "repo_id": "9", "comment": "/**\n * @param permutation the permutation to set\n */\n", "repo_name": "biojava-master/", "id": 1873, "method_signature": "void setPermutation(List)"}, "3434": {"callee_method_ids": [3381], "callee_method_names": ["JmolSymmetryScriptGenerator.getInstantaneousOrientation", "JmolSymmetryScriptGenerator.drawPolyhedron", "JmolSymmetryScriptGenerator.drawAxes"], "method_name": "SymmetryDisplay.printSymmetryGroup", "method_implementation": "{\n    QuatSymmetryResults gSymmetry = SymmetryTools.getQuaternarySymmetry(symm);\n    AxisAligner axes = AxisAligner.getInstance(gSymmetry);\n    // Draw the axes as in the quaternary symmetry\n    JmolSymmetryScriptGenerator scriptGenerator = JmolSymmetryScriptGeneratorPointGroup.getInstance(axes, \"g\");\n    String script = \"save selection; set measurementUnits ANGSTROMS;\" + \"select all; set antialiasDisplay true; autobond=false; \";\n    script += scriptGenerator.getInstantaneousOrientation(0);\n    script += \"restore selection; \";\n    script += scriptGenerator.drawPolyhedron();\n    script += scriptGenerator.drawAxes();\n    script += \"draw axes* on; draw poly* on; \";\n    return script;\n}", "repo_id": "9", "comment": "/**\n * Given a symmetry alignment, it draws the symmetry group axes and the\n * polyhedron box around the structure. It uses the quaternary symmetry\n * detection code, but tries to factor out the alignment and detection\n * steps.\n *\n * @param symm\n *            CeSymmResult\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3434, "method_signature": "String printSymmetryGroup(CeSymmResult)"}, "3008": {"callee_method_names": [], "method_name": "BitArrayWorker.getCompoundAt", "method_implementation": "{\n    //Avoids asking for something which is not encoded by a bit-pair\n    if (position > getLength()) {\n        throw new IllegalArgumentException(position + \" is greater than length. Cannot access this position\");\n    }\n    //Just stops us from using 0 indexing\n    if (position < 1) {\n        throw new IllegalArgumentException(position + \" is less than 1; you must use biological indexing (indexing from 1)\");\n    }\n    int arrayIndex = biologicalIndexToArrayIndex(position);\n    int currentByte = sequence[arrayIndex];\n    int shiftBy = shiftBy(position);\n    int shifted = currentByte >>> shiftBy;\n    int masked = shifted & bitMask();\n    //If we could encode 4 compounds then our max masked value is 3\n    if (masked > (compoundsPerDatatype() - 1)) {\n        throw new IllegalStateException(\"Got a masked value of \" + masked + \"; do not understand values greater than \" + (compoundsPerDatatype() - 1));\n    }\n    return getIndexToCompoundsLookup().get(masked);\n}", "repo_id": "9", "comment": "/**\n * Returns the compound at the specified biological index\n */\n", "repo_name": "biojava-master/", "id": 3008, "method_signature": "C getCompoundAt(int)"}, "2038": {"callee_method_ids": [726], "callee_method_names": ["CECalculator.getMatMatrix", "Matrix.get", "Matrix.set", "Matrix.get", "Matrix.get", "Matrix.set", "Matrix.get"], "method_name": "SymmetryTools.grayOutCEOrig", "method_implementation": "{\n    if (origM == null) {\n        origM = new Matrix(calculator.getMatMatrix());\n    }\n    // symmetry hack, disable main diagonal\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int diff = Math.abs(i - j);\n            double resetVal = getResetVal(origM.get(i, j), diff, gradientPolyCoeff, gradientExpCoeff);\n            if (diff < blankWindowSize) {\n                origM.set(i, j, origM.get(i, j) + resetVal);\n            }\n            // other side\n            int diff2 = Math.abs(i - (j - ca2.length / 2));\n            double resetVal2 = getResetVal(origM.get(i, j), diff2, gradientPolyCoeff, gradientExpCoeff);\n            if (diff2 < blankWindowSize) {\n                origM.set(i, j, origM.get(i, j) + resetVal2);\n            }\n        }\n    }\n    return origM;\n}", "repo_id": "9", "comment": "/**\n * Grays out the main diagonal of a duplicated distance matrix.\n *\n * @param ca2\n * @param rows\n *            Number of rows\n * @param cols\n *            Number of original columns\n * @param calculator\n *            Used to get the matrix if origM is null\n * @param origM\n *            starting matrix. If null, uses\n *            {@link CECalculator#getMatMatrix()}\n * @param blankWindowSize\n *            Width of section to gray out\n * @param gradientPolyCoeff\n * @param gradientExpCoeff\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2038, "method_signature": "Matrix grayOutCEOrig(Atom[], int, int, CECalculator, Matrix, int, double[], double)"}, "929": {"callee_method_names": [], "method_name": "Grid.addAtoms", "method_implementation": "{\n    this.iAtoms = Calc.atomsToPoints(atoms);\n    this.iAtomObjects = atoms;\n    if (bounds != null) {\n        this.ibounds = bounds;\n    } else {\n        this.ibounds = new BoundingBox(iAtoms);\n    }\n    this.jAtoms = null;\n    this.jAtomObjects = null;\n    this.jbounds = null;\n    fillGrid();\n}", "repo_id": "9", "comment": "/**\n * Adds a set of atoms, subsequent call to {@link #getIndicesContacts()} or {@link #getAtomContacts()} will produce the interatomic contacts.\n * The bounds calculated elsewhere can be passed, or if null they are computed.\n * @param atoms\n * @param bounds\n */\n", "repo_name": "biojava-master/", "id": 929, "method_signature": "void addAtoms(Atom[], BoundingBox)"}, "237": {"callee_method_names": [], "method_name": "Builder.setPsimodName", "method_implementation": "{\n    this.psimodName = psimodName;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the PSI-MOD name.\n * @param psimodName PSI-MOD name.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 237, "method_signature": "Builder setPsimodName(String)"}, "1192": {"callee_method_names": ["List<String>.indexOf", "List<String>.size", "ArrayList.size", "ArrayList.get", "List<String>.indexOf", "List<String>.size"], "method_name": "PDBFileParser.makeCompounds", "method_implementation": "{\n    //\t\tSystem.out.println(\"[makeCompounds] making compounds from compoundLines\");\n    for (String line : compoundList) {\n        if (compoundList.indexOf(line) + 1 == compoundList.size()) {\n            //\t\t\t\tSystem.out.println(\"[makeCompounds] Final line in compoundLines.\");\n            isLastCompndLine = true;\n        }\n        pdb_COMPND_Handler(line);\n    }\n    //\t\tSystem.out.println(\"[makeCompounds] adding sources to compounds from sourceLines\");\n    // since we're starting again from the first compound, reset it here\n    if (entities.size() == 0) {\n        current_compound = new EntityInfo();\n    } else {\n        current_compound = entities.get(0);\n    }\n    for (String line : sourceList) {\n        if (sourceList.indexOf(line) + 1 == sourceList.size()) {\n            //\t\t\t\tSystem.out.println(\"[makeCompounds] Final line in sourceLines.\");\n            isLastSourceLine = true;\n        }\n        pdb_SOURCE_Handler(line);\n    }\n}", "repo_id": "9", "comment": "/**\n * This is the new method for building the COMPND and SOURCE records. Now each method is self-contained.\n * @author Jules Jacobsen\n * @param  compoundList\n * @param  sourceList\n */\n", "repo_name": "biojava-master/", "id": 1192, "method_signature": "void makeCompounds(List, List)"}, "3": {"callee_method_names": [], "method_name": "SimpleGapPenalty.getOpenPenalty", "method_implementation": "{\n    return gop;\n}", "repo_id": "9", "comment": "/**\n * <strong>Returns the negative of the opening penalty passed to the constructor.</strong>\n */\n", "repo_name": "biojava-master/", "id": 3, "method_signature": "int getOpenPenalty()"}, "3399": {"callee_method_names": ["RotationAxisAligner.getDimension"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getMaxExtension", "method_implementation": "{\n    Vector3d dimension = rotationAxisAligner.getDimension();\n    double maxExtension = Math.max(dimension.x, dimension.y);\n    maxExtension = Math.max(maxExtension, dimension.z);\n    return maxExtension;\n}", "repo_id": "9", "comment": "/**\n * Returns the maximum extension (length) of structure\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3399, "method_signature": "double getMaxExtension()"}, "2650": {"callee_method_names": ["Map<Frame, Sequence<AminoAcidCompound>>.put"], "method_name": "TranscriptionEngine.multipleFrameTranslation", "method_implementation": "{\n    Map<Frame, Sequence<AminoAcidCompound>> results = new EnumMap<Frame, Sequence<AminoAcidCompound>>(Frame.class);\n    for (Frame frame : frames) {\n        Sequence<NucleotideCompound> rna = getDnaRnaTranslator().createSequence(dna, frame);\n        Sequence<AminoAcidCompound> peptide = getRnaAminoAcidTranslator().createSequence(rna);\n        results.put(frame, peptide);\n    }\n    return results;\n}", "repo_id": "9", "comment": "/**\n * A way of translating DNA in a number of frames\n *\n * @param dna\n *            The CDS to translate\n * @param frames\n *            The Frames to translate in\n * @return All generated protein sequences in the given frames. Can have\n *         null entries\n */\n", "repo_name": "biojava-master/", "id": 2650, "method_signature": "Map<Frame,Sequence<AminoAcidCompound>> multipleFrameTranslation(Sequence, Frame[])"}, "2498": {"callee_method_names": ["File.getAbsolutePath"], "method_name": "GeneFeatureHelper.loadFastaAddGeneFeaturesFromGmodGFF3", "method_implementation": "{\n    LinkedHashMap<String, DNASequence> dnaSequenceList = FastaReaderHelper.readFastaDNASequence(fastaSequenceFile, lazyloadsequences);\n    LinkedHashMap<String, ChromosomeSequence> chromosomeSequenceList = GeneFeatureHelper.getChromosomeSequenceFromDNASequence(dnaSequenceList);\n    FeatureList listGenes = GFF3Reader.read(gffFile.getAbsolutePath());\n    addGmodGFF3GeneFeatures(chromosomeSequenceList, listGenes);\n    return chromosomeSequenceList;\n}", "repo_id": "9", "comment": "/**\n * Lots of variations in the ontology or descriptors that can be used in GFF3 which requires writing a custom parser to handle a GFF3 generated or used\n * by a specific application. Probably could be abstracted out but for now easier to handle with custom code to deal with gff3 elements that are not\n * included but can be extracted from other data elements.\n * @param fastaSequenceFile\n * @param gffFile\n * @param lazyloadsequences If set to true then the fasta file will be parsed for accession id but sequences will be read from disk when needed to save memory\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2498, "method_signature": "LinkedHashMap<String,ChromosomeSequence> loadFastaAddGeneFeaturesFromGmodGFF3(File, File, boolean)"}, "599": {"callee_method_names": [], "method_name": "AlignmentTools.calculateBlockGap", "method_implementation": "{\n    //Initialize the array to be returned\n    int[] blockGap = new int[optAln.length];\n    //Loop for every block and look in both chains for non-contiguous residues.\n    for (int i = 0; i < optAln.length; i++) {\n        //the number of gaps in that block\n        int gaps = 0;\n        //the last residue position in chain 1\n        int last1 = 0;\n        //the last residue position in chain 2\n        int last2 = 0;\n        //Loop for every position in the block\n        for (int j = 0; j < optAln[i][0].length; j++) {\n            //If the first position is evaluated initialize the last positions\n            if (j == 0) {\n                last1 = optAln[i][0][j];\n                last2 = optAln[i][1][j];\n            } else {\n                //If one of the positions or both are not contiguous increment the number of gaps\n                if (optAln[i][0][j] > last1 + 1 || optAln[i][1][j] > last2 + 1) {\n                    gaps++;\n                    last1 = optAln[i][0][j];\n                    last2 = optAln[i][1][j];\n                } else //Otherwise just set the last position to the current one\n                {\n                    last1 = optAln[i][0][j];\n                    last2 = optAln[i][1][j];\n                }\n            }\n        }\n        blockGap[i] = gaps;\n    }\n    return blockGap;\n}", "repo_id": "9", "comment": "/**\n * Method that calculates the number of gaps in each subunit block of an optimal AFP alignment.\n *\n * INPUT: an optimal alignment in the format int[][][].\n * OUTPUT: an int[] array of <order> length containing the gaps in each block as int[block].\n */\n", "repo_name": "biojava-master/", "id": 599, "method_signature": "int[] calculateBlockGap(int[][][])"}, "485": {"callee_method_names": [], "method_name": "AFPChain.setAfpSet", "method_implementation": "{\n    this.afpSet = afpSet;\n}", "repo_id": "9", "comment": "/**\n * Set the set of AFPs for this alignment.\n * An AFP is a local ungapped alignment between the two peptides.\n *\n * AFPs are set before the final optimization step. To get the final\n * alignment, look at the aligned pairs from {@link #getOptAln()}.\n */\n", "repo_name": "biojava-master/", "id": 485, "method_signature": "void setAfpSet(List)"}, "251": {"callee_method_names": ["Map<String, Set<ProteinModification>>.get"], "method_name": "ProteinModificationRegistry.getByPsimodId", "method_implementation": "{\n    lazyInit();\n    return byPsimodId.get(psimodId);\n}", "repo_id": "9", "comment": "/**\n * @param psimodId PSI-MOD ID.\n * @return a set of ProteinModifications that have the PSI-MOD ID.\n */\n", "repo_name": "biojava-master/", "id": 251, "method_signature": "Set<ProteinModification> getByPsimodId(String)"}, "1978": {"callee_method_names": ["QuatSymmetrySubunits.getSubunitCount", "List<List<Integer>>.add"], "method_name": "HelixAxisAligner.calcOrbits", "method_implementation": "{\n    int n = subunits.getSubunitCount();\n    List<List<Integer>> orbits = new ArrayList<List<Integer>>();\n    for (int i = 0; i < n; i++) {\n        orbits.add(Collections.singletonList(i));\n    }\n    return orbits;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of list of subunit ids that form an \"orbit\", i.e. they\n * are transformed into each other during a rotation around the principal symmetry axis (z-axis)\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1978, "method_signature": "List<List<Integer>> calcOrbits()"}, "491": {"callee_method_names": [], "method_name": "AFPChain.setOptLength", "method_implementation": "{\n    this.optLength = optLength;\n}", "repo_id": "9", "comment": "/**\n * The length of the optimal alignment. Set by AFPOptimizer.optimizeAln().\n * This should be the sum of the elements in optLen\n * @param optLength\n */\n", "repo_name": "biojava-master/", "id": 491, "method_signature": "void setOptLength(int)"}, "656": {"callee_method_names": [], "method_name": "MultipleAlignmentTools.getBlockSequenceAlignment", "method_implementation": "{\n    return getBlockSequenceAlignment(ma, new ArrayList<Integer>());\n}", "repo_id": "9", "comment": "/**\n * Calculate the sequence alignment Strings for the alignment Blocks in an\n * alignment. This method creates a sequence alignment where all residues\n * are in uppercase and a residue alone with gaps in all the other\n * structures represents unaligned residues. Because of this latter\n * constraint only the residues within the Blocks are represented, for a\n * more compact alignment. For a sequence alignment of the full protein use\n * {@link #getSequenceAlignment(MultipleAlignment)}.\n * <p>\n * Blocks are concatenated in the order returned by\n * {@link MultipleAlignment#getBlocks()}, so sequences may not be\n * sequential. Gaps between blocks are omitted, while gaps within blocks are\n * represented by '-'. Separation between different Blocks is indicated by a\n * gap in all positions, meaning that there is something unaligned\n * inbetween.\n *\n * @param alignment\n *            input MultipleAlignment\n * @return String for each row in the alignment, giving the 1-letter code\n *         for each aligned residue.\n */\n", "repo_name": "biojava-master/", "id": 656, "method_signature": "List<String> getBlockSequenceAlignment(MultipleAlignment)"}, "1038": {"callee_method_names": ["Atom.getGroup", "Atom.getGroup", "Chain.setId", "Chain.getId", "Chain.setName", "Chain.getName", "Atom.getGroup", "Chain.getId", "Chain.setId", "Chain.getId", "Chain.setName", "Chain.getName", "Chain.addGroup", "Group.getAtom", "Atom.getName", "Atom.getGroup", "Atom.getGroup", "Chain.setId", "Chain.getId", "Chain.setName", "Chain.getName", "Atom.getGroup", "Chain.getId", "Chain.setId", "Chain.getId", "Chain.setName", "Chain.getName", "Chain.addGroup", "Group.getAtom", "Atom.getName"], "method_name": "StructureTools.duplicateCA2", "method_implementation": "{\n    // we don't want to rotate input atoms, do we?\n    Atom[] ca2clone = new Atom[ca2.length * 2];\n    int pos = 0;\n    Chain c = null;\n    String prevChainId = \"\";\n    for (Atom a : ca2) {\n        // works because each group\n        Group g = (Group) a.getGroup().clone();\n        // has only a single atom\n        if (c == null) {\n            c = new ChainImpl();\n            Chain orig = a.getGroup().getChain();\n            c.setId(orig.getId());\n            c.setName(orig.getName());\n        } else {\n            Chain orig = a.getGroup().getChain();\n            if (!orig.getId().equals(prevChainId)) {\n                c = new ChainImpl();\n                c.setId(orig.getId());\n                c.setName(orig.getName());\n            }\n        }\n        c.addGroup(g);\n        ca2clone[pos] = g.getAtom(a.getName());\n        pos++;\n    }\n    // Duplicate ca2!\n    c = null;\n    prevChainId = \"\";\n    for (Atom a : ca2) {\n        Group g = (Group) a.getGroup().clone();\n        if (c == null) {\n            c = new ChainImpl();\n            Chain orig = a.getGroup().getChain();\n            c.setId(orig.getId());\n            c.setName(orig.getName());\n        } else {\n            Chain orig = a.getGroup().getChain();\n            if (!orig.getId().equals(prevChainId)) {\n                c = new ChainImpl();\n                c.setId(orig.getId());\n                c.setName(orig.getName());\n            }\n        }\n        c.addGroup(g);\n        ca2clone[pos] = g.getAtom(a.getName());\n        pos++;\n    }\n    return ca2clone;\n}", "repo_id": "9", "comment": "/**\n * Utility method for working with circular permutations. Creates a\n * duplicated and cloned set of Calpha atoms from the input array.\n *\n * @param ca2\n *            atom array\n * @return cloned and duplicated set of input array\n */\n", "repo_name": "biojava-master/", "id": 1038, "method_signature": "Atom[] duplicateCA2(Atom[])"}, "738": {"callee_method_names": ["Atom[].getGroup", "Group.getAtom", "Atom[].getName", "List<Atom>.add", "List<Atom>.toArray", "List<Atom>.size"], "method_name": "CeCalculatorEnhanced.getAtoms", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<Atom>();\n    for (int i = 0; i < length; i++) {\n        Atom a;\n        if (clone) {\n            Group g = (Group) ca[i].getGroup().clone();\n            a = g.getAtom(ca[i].getName());\n        } else {\n            a = ca[i];\n        }\n        atoms.add(a);\n    }\n    return atoms.toArray(new Atom[atoms.size()]);\n}", "repo_id": "9", "comment": "/**\n * Copies the first length atoms from the input array\n * @param ca The array to copy\n * @param length the number of atoms to copy\n * @param clone If true, preform a deep copy, cloning the underlying Groups\n * @return An array with the first length items of ca, possibly cloning the Atoms.\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 738, "method_signature": "Atom[] getAtoms(Atom[], int, boolean)"}, "2676": {"callee_method_names": ["ArrayList.size"], "method_name": "MultipleSequenceAlignment.getSize", "method_implementation": "{\n    return sequences.size();\n}", "repo_id": "9", "comment": "/**\n * Get the number of sequences in the MSA\n * @return nr of sequences\n */\n", "repo_name": "biojava-master/", "id": 2676, "method_signature": "int getSize()"}, "3341": {"callee_method_names": ["Color.getRed", "Color.getGreen", "Color.getBlue", "Color.getAlpha"], "method_name": "ColorUtils.darker", "method_implementation": "{\n    int red = (int) Math.round(color.getRed() * (1.0 - fraction));\n    int green = (int) Math.round(color.getGreen() * (1.0 - fraction));\n    int blue = (int) Math.round(color.getBlue() * (1.0 - fraction));\n    if (red < 0)\n        red = 0;\n    else if (red > 255)\n        red = 255;\n    if (green < 0)\n        green = 0;\n    else if (green > 255)\n        green = 255;\n    if (blue < 0)\n        blue = 0;\n    else if (blue > 255)\n        blue = 255;\n    int alpha = color.getAlpha();\n    return new Color(red, green, blue, alpha);\n}", "repo_id": "9", "comment": "/**\n * Make a color darker. (RGB color scheme)\n *\n * @param color     Color to make darker.\n * @param fraction  Darkness fraction.\n * @return          Darker color.\n */\n", "repo_name": "biojava-master/", "id": 3341, "method_signature": "Color darker(Color, double)"}, "3728": {"callee_method_ids": [3701], "callee_method_names": ["LinkedHashMap.get", "HeaderInfo.setHide"], "method_name": "WorkSheet.hideColumn", "method_implementation": "{\n    HeaderInfo colInfo = columnLookup.get(column);\n    colInfo.setHide(hide);\n}", "repo_id": "9", "comment": "/**\n * @param column\n * @param hide\n */\n", "repo_name": "biojava-master/", "id": 3728, "method_signature": "void hideColumn(String, boolean)"}, "1759": {"callee_method_names": [], "method_name": "MismatchedBasePairParameters.setMaxPropeller", "method_implementation": "{\n    this.maxPropeller = maxPropeller;\n}", "repo_id": "9", "comment": "/**\n * This method sets the maximum propeller allowed for a base pair, prior to analyze() call\n * @param maxPropeller The maximum propeller (\"propeller-twist\", in degrees) allowed to consider two bases paired\n */\n", "repo_name": "biojava-master/", "id": 1759, "method_signature": "void setMaxPropeller(double)"}, "2779": {"callee_method_names": [], "method_name": "IUPACParser.getCodonCompoundSet", "method_implementation": "{\n    if (compounds == null) {\n        compounds = new AbstractCompoundSet<Codon>() {\n\n            {\n                for (Codon c : getCodons(rnaCompounds, aminoAcidCompounds)) {\n                    addCompound(c);\n                }\n            }\n        };\n    }\n    return compounds;\n}", "repo_id": "9", "comment": "/**\n * Returns the compound set of codons\n */\n", "repo_name": "biojava-master/", "id": 2779, "method_signature": "CompoundSet<Codon> getCodonCompoundSet(CompoundSet, CompoundSet)"}, "1577": {"callee_method_names": ["Group.getChemComp", "Logger.warn", "StringBuilder.append", "ChemComp.getPolymerType", "ChemComp.getPolymerType", "String.isEmpty", "String.length", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ChainImpl.getSeqResOneLetterSeq", "method_implementation": "{\n    StringBuilder str = new StringBuilder();\n    for (Group g : seqResGroups) {\n        ChemComp cc = g.getChemComp();\n        if (cc == null) {\n            logger.warn(\"Could not load ChemComp for group: {}\", g);\n            str.append(StructureTools.UNKNOWN_GROUP_LABEL);\n        } else if (PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {\n            // an amino acid residue.. use for alignment\n            String oneLetter = ChemCompGroupFactory.getOneLetterCode(cc);\n            // AB oneLetter.length() should be one. e.g. in 1EMA it is 3 and this makes mapping residue to sequence impossible.\n            if (oneLetter == null || oneLetter.isEmpty() || \"?\".equals(oneLetter) || oneLetter.length() != 1) {\n                oneLetter = Character.toString(StructureTools.UNKNOWN_GROUP_LABEL);\n            }\n            str.append(oneLetter);\n        } else {\n            str.append(StructureTools.UNKNOWN_GROUP_LABEL);\n        }\n    }\n    return str.toString();\n}", "repo_id": "9", "comment": "/**\n * Get the one letter sequence so that Sequence is guaranteed to\n * be the same length as seqResGroups.\n * Method related to https://github.com/biojava/biojava/issues/457\n * @return a string of the sequence guaranteed to be the same length\n * as seqResGroups.\n */\n", "repo_name": "biojava-master/", "id": 1577, "method_signature": "String getSeqResOneLetterSeq()"}, "3845": {"callee_method_names": [], "method_name": "Convert2SolventAccessibility.convert", "method_implementation": "{\n    switch(c) {\n        case 'A':\n        case 'L':\n        case 'F':\n        case 'C':\n        case 'G':\n        case 'I':\n        case 'V':\n        case 'W':\n            //Buried\n            return group1;\n        case 'R':\n        case 'K':\n        case 'Q':\n        case 'E':\n        case 'N':\n        case 'D':\n            //Exposed\n            return group2;\n        case 'M':\n        case 'P':\n        case 'S':\n        case 'T':\n        case 'H':\n        case 'Y':\n            //Intermediate\n            return group3;\n        default:\n            //Non-standard AA\n            return unknownGroup;\n    }\n}", "repo_id": "9", "comment": "/**\n * Class for the conversion of protein sequence into solvent accessibility\n */\n", "repo_name": "biojava-master/", "id": 3845, "method_signature": "char convert(char)"}, "2337": {"callee_method_names": ["Map<Integer,Integer>.keySet", "Map<Integer,Integer>.get", "Map<Integer,Integer>.containsKey"], "method_name": "TestSingleRefiner.testAutomorphism", "method_implementation": "{\n    for (Integer pre : align.keySet()) {\n        Integer post = align.get(pre);\n        Assert.assertNotNull(\"Not automorphic: f(\" + pre + \") not defined\", post);\n        Assert.assertTrue(\"not automorphic: f(\" + pre + \") = \" + post + \" but f(\" + post + \") undefined\", align.containsKey(post));\n    }\n}", "repo_id": "9", "comment": "/**\n * Refined alignments should be automorphic (one-to-one)\n * @param align\n */\n", "repo_name": "biojava-master/", "id": 2337, "method_signature": "void testAutomorphism(Map)"}, "2367": {"callee_method_ids": [2373, 2370, 2371], "callee_method_names": ["Fastq.getVariant", "Fastq.getDescription", "Fastq.getSequence"], "method_name": "FastqTools.convert", "method_implementation": "{\n    if (fastq == null) {\n        throw new IllegalArgumentException(\"fastq must not be null\");\n    }\n    if (variant == null) {\n        throw new IllegalArgumentException(\"variant must not be null\");\n    }\n    if (fastq.getVariant().equals(variant)) {\n        return fastq;\n    }\n    return new Fastq(fastq.getDescription(), fastq.getSequence(), convertQualities(fastq, variant), variant);\n}", "repo_id": "9", "comment": "/**\n * Convert the specified FASTQ formatted sequence to the\n * specified FASTQ sequence format variant.\n *\n * @since 4.2\n * @param fastq FASTQ formatted sequence, must not be null\n * @param variant FASTQ sequence format variant, must not be null\n * @return the specified FASTQ formatted sequence converted to the\n *    specified FASTQ sequence format variant\n */\n", "repo_name": "biojava-master/", "id": 2367, "method_signature": "Fastq convert(Fastq, FastqVariant)"}, "0": {"callee_method_names": [], "method_name": "SimpleGapPenalty.setDefaultExtensionPenalty", "method_implementation": "{\n    dgep = gep;\n}", "repo_id": "9", "comment": "/**\n * Sets the default gap extension penalty.\n *\n * @param gep the default gap extension penalty\n */\n", "repo_name": "biojava-master/", "id": 0, "method_signature": "void setDefaultExtensionPenalty(int)"}, "1213": {"callee_method_names": [], "method_name": "CifStructureConverter.toText", "method_implementation": "{\n    try {\n        return new String(CifIO.writeText(toCifFile(chain)));\n    } catch (IOException e) {\n        throw new UncheckedIOException(e);\n    }\n}", "repo_id": "9", "comment": "/**\n * Convert a chain to mmCIF format.\n * @param chain the source\n * @return the mmCIF String representation of the chain\n */\n", "repo_name": "biojava-master/", "id": 1213, "method_signature": "String toText(Chain)"}, "636": {"callee_method_names": [], "method_name": "AtomCache.getObsoleteBehavior", "method_implementation": "{\n    return obsoleteBehavior;\n}", "repo_id": "9", "comment": "/**\n * Returns how this instance deals with obsolete entries. Note that this\n * setting may be ignored by some implementations or in some situations,\n * such as when {@link #isAutoFetch()} is false.\n *\n * <p>For most implementations, the default value is\n * {@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}.\n *\n * @return The ObsoleteBehavior\n * @since 4.0.0\n */\n", "repo_name": "biojava-master/", "id": 636, "method_signature": "ObsoleteBehavior getObsoleteBehavior()"}, "1084": {"callee_method_names": ["Logger.debug", "ChemCompProvider.getClass", "SoftHashMap.clear"], "method_name": "ChemCompGroupFactory.setChemCompProvider", "method_implementation": "{\n    logger.debug(\"Setting new chem comp provider to {}\", provider.getClass().getCanonicalName());\n    chemCompProvider = provider;\n    // clear cache\n    cache.clear();\n}", "repo_id": "9", "comment": "/**\n * The new ChemCompProvider will be set in the static variable,\n * so this provider will be used from now on until it is changed\n * again. Note that this change can have unexpected behavior of\n * code executed afterwards.\n * <p>\n * Changing the provider also resets the cache, so any groups\n * previously accessed will be reread or re-downloaded.\n *\n * @param provider\n */\n", "repo_name": "biojava-master/", "id": 1084, "method_signature": "void setChemCompProvider(ChemCompProvider)"}, "2539": {"callee_method_names": ["HashMap.containsKey", "HashMap.put", "HashMap.get"], "method_name": "SubstitutionMatrixHelper.getAminoAcidMatrix", "method_implementation": "{\n    if (!aminoAcidMatrices.containsKey(file)) {\n        InputStreamReader reader = getReader(file);\n        if (reader == null) {\n            return null;\n        }\n        aminoAcidMatrices.put(file, new SimpleSubstitutionMatrix<AminoAcidCompound>(AminoAcidCompoundSet.getAminoAcidCompoundSet(), reader, file));\n    }\n    return aminoAcidMatrices.get(file);\n}", "repo_id": "9", "comment": "// reads in an amino acid substitution matrix, if necessary\n", "repo_name": "biojava-master/", "id": 2539, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getAminoAcidMatrix(String)"}, "53": {"callee_method_names": ["List<PairwiseSequenceScorer<S,C>>.size", "List<Future<Double>>.add", "List<Double>.size", "List<Double>.get"], "method_name": "Alignments.runPairwiseScorers", "method_implementation": "{\n    int n = 1, all = scorers.size();\n    List<Future<Double>> futures = new ArrayList<Future<Double>>();\n    for (PairwiseSequenceScorer<S, C> scorer : scorers) {\n        futures.add(ConcurrencyTools.submit(new CallablePairwiseSequenceScorer<S, C>(scorer), String.format(\"Scoring pair %d of %d\", n++, all)));\n    }\n    List<Double> results = getListFromFutures(futures);\n    double[] scores = new double[results.size()];\n    for (int i = 0; i < scores.length; i++) {\n        scores[i] = results.get(i);\n    }\n    return scores;\n}", "repo_id": "9", "comment": "/**\n * Factory method to run a list of scorers concurrently.  This method runs the scorers in parallel by submitting\n * all of the scoring tasks to the shared thread pool of the {@link ConcurrencyTools} utility.\n *\n * @param <S> each {@link Sequence} of an alignment pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param scorers list of scorers to run\n * @return list of score results from running scorers\n */\n", "repo_name": "biojava-master/", "id": 53, "method_signature": "double[] runPairwiseScorers(List)"}, "1258": {"callee_method_names": [], "method_name": "MmtfUtils.getNcsAsArray", "method_implementation": "{\n    if (ncsOperators == null) {\n        return new double[0][0];\n    }\n    double[][] outList = new double[ncsOperators.length][16];\n    for (int i = 0; i < ncsOperators.length; i++) {\n        outList[i] = convertToDoubleArray(ncsOperators[i]);\n    }\n    return outList;\n}", "repo_id": "9", "comment": "/**\n * Get a list of length N*16 of a list of Matrix4d*N.\n * @param ncsOperators the {@link Matrix4d} list\n * @return the list of length N*16 of the list of matrices\n */\n", "repo_name": "biojava-master/", "id": 1258, "method_signature": "double[][] getNcsAsArray(Matrix4d[])"}, "799": {"callee_method_names": [], "method_name": "CeStartupParams.getMaxOptRMSD", "method_implementation": "{\n    return maxOptRMSD;\n}", "repo_id": "9", "comment": "/**\n * (jCE specific): maximum RMSD that shall be calculated for the alignment.\n *\n *  @return maxOptRMSD parameter\n */\n", "repo_name": "biojava-master/", "id": 799, "method_signature": "Double getMaxOptRMSD()"}, "2748": {"callee_method_names": [], "method_name": "EmblRecord.getDatabaseCrossReference", "method_implementation": "{\n    return databaseCrossReference;\n}", "repo_id": "9", "comment": "/**\n * The DR (Database Cross-reference) line cross-references other databases which\n * contain information related to the entry in which the DR line appears.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2748, "method_signature": "String getDatabaseCrossReference()"}, "2783": {"callee_method_names": ["String.getBytes"], "method_name": "FastaWriter.setLineSeparator", "method_implementation": "{\n    lineSep = lineSeparator.getBytes();\n}", "repo_id": "9", "comment": "/**\n * Allow an override of operating system line separator for programs that needs a specific CRLF or CR or LF option\n * @param lineSeparator\n */\n", "repo_name": "biojava-master/", "id": 2783, "method_signature": "void setLineSeparator(String)"}, "3667": {"callee_method_names": [], "method_name": "SurvivalInfo.getClusterValue", "method_implementation": "{\n    return clusterValue;\n}", "repo_id": "9", "comment": "/**\n * @return the clusterValue\n */\n", "repo_name": "biojava-master/", "id": 3667, "method_signature": "String getClusterValue()"}, "598": {"callee_method_names": ["Pattern.matcher", "Matcher.find", "Matcher.group", "Matcher.group", "Map<Integer, Integer>.put", "String.substring", "Matcher.end"], "method_name": "AlignmentTools.fromConciseAlignmentString", "method_implementation": "{\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n    boolean matches = true;\n    while (matches) {\n        Pattern pattern = Pattern.compile(\"(\\\\d+)>(\\\\d+)\");\n        Matcher matcher = pattern.matcher(string);\n        matches = matcher.find();\n        if (matches) {\n            Integer from = Integer.parseInt(matcher.group(1));\n            Integer to = Integer.parseInt(matcher.group(2));\n            map.put(from, to);\n            string = string.substring(matcher.end(1) + 1);\n        }\n    }\n    return map;\n}", "repo_id": "9", "comment": "/**\n * @see #toConciseAlignmentString(Map, Map)\n */\n", "repo_name": "biojava-master/", "id": 598, "method_signature": "Map<Integer,Integer> fromConciseAlignmentString(String)"}, "3096": {"callee_method_names": [], "method_name": "Qualifier.needsQuotes", "method_implementation": "{\n    return needsQuotes;\n}", "repo_id": "9", "comment": "/**\n * @return the needsQuotes\n */\n", "repo_name": "biojava-master/", "id": 3096, "method_signature": "boolean needsQuotes()"}, "1524": {"callee_method_names": [], "method_name": "JournalArticle.getEditorList", "method_implementation": "{\n    return editorList;\n}", "repo_id": "9", "comment": "/**\n * Get the list of editors of the JournalArticle\n *\n * @return the List of editors\n */\n", "repo_name": "biojava-master/", "id": 1524, "method_signature": "List<Author> getEditorList()"}, "1463": {"callee_method_names": [], "method_name": "CrystalCell.getVolume", "method_implementation": "{\n    if (volume != 0) {\n        return volume;\n    }\n    volume = a * b * c * Math.sqrt(1 - Math.cos(alphaRad) * Math.cos(alphaRad) - Math.cos(betaRad) * Math.cos(betaRad) - Math.cos(gammaRad) * Math.cos(gammaRad) + 2.0 * Math.cos(alphaRad) * Math.cos(betaRad) * Math.cos(gammaRad));\n    return volume;\n}", "repo_id": "9", "comment": "/**\n * Returns the volume of this unit cell.\n * See http://en.wikipedia.org/wiki/Parallelepiped\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1463, "method_signature": "double getVolume()"}, "2965": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.getLength", "method_implementation": "{\n    return this.parsedCompounds.size();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2965, "method_signature": "int getLength()"}, "2310": {"callee_method_names": ["Matrix4d.set", "Matrix4d.invert", "AxisAngle4d.set", "Matrix4d.set"], "method_name": "TestUnitQuaternions.testOrientation", "method_implementation": "{\n    // Get points from a structure. It is difficult to generate points\n    // with no bias in their distribution (too uniform, ie).\n    Structure pdb = StructureIO.getStructure(\"4hhb.A\");\n    Point3d[] cloud = Calc.atomsToPoints(StructureTools.getRepresentativeAtomArray(pdb));\n    // Center the cloud at the origin\n    CalcPoint.center(cloud);\n    // Orient its principal axes to the coordinate axis\n    Quat4d orientation = UnitQuaternions.orientation(cloud);\n    Matrix4d transform = new Matrix4d();\n    transform.set(orientation);\n    transform.invert();\n    CalcPoint.transform(transform, cloud);\n    // The orientation found now should be 0 (it has been re-oriented)\n    orientation = UnitQuaternions.orientation(cloud);\n    AxisAngle4d axis = new AxisAngle4d();\n    axis.set(orientation);\n    // No significant rotation\n    assertEquals(orientation.x, 0.0, 0.01);\n    assertEquals(orientation.y, 0.0, 0.01);\n    assertEquals(orientation.z, 0.0, 0.01);\n    assertEquals(axis.angle, 0.0, 0.01);\n    // Now try to recover an orientation\n    Quat4d quat = new Quat4d(0.418, 0.606, 0.303, 0.606);\n    Matrix4d mat = new Matrix4d();\n    mat.set(quat);\n    CalcPoint.transform(mat, cloud);\n    orientation = UnitQuaternions.orientation(cloud);\n    // Test recovering the quaternion (q and -q same rotation)\n    assertEquals(Math.abs(orientation.x), quat.x, 0.01);\n    assertEquals(Math.abs(orientation.y), quat.y, 0.01);\n    assertEquals(Math.abs(orientation.z), quat.z, 0.01);\n    assertEquals(Math.abs(orientation.w), quat.w, 0.01);\n}", "repo_id": "9", "comment": "/**\n * Test {@link UnitQuaternions#orientation(javax.vecmath.Point3d[])}.\n * <p>\n * Tests the identity orientation, orientation around one coordinate axis\n * and orientation around a non-coordinate axis.\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2310, "method_signature": "void testOrientation()"}, "868": {"callee_method_ids": [849, 849, 846], "callee_method_names": ["SparseVector.size", "SparseVector.size", "SparseVector.put"], "method_name": "SparseSquareMatrix.times", "method_implementation": "{\n    SparseSquareMatrix A = this;\n    if (N != x.size())\n        throw new IllegalArgumentException(\"Dimensions disagree. \" + N + \" != \" + x.size());\n    SparseVector b = new SparseVector(N);\n    for (int i = 0; i < N; i++) b.put(i, A.rows[i].dot(x));\n    return b;\n}", "repo_id": "9", "comment": "/**\n * @param x\n * @return  return the matrix-vector product b = Ax\n */\n", "repo_name": "biojava-master/", "id": 868, "method_signature": "SparseVector times(SparseVector)"}, "3422": {"callee_method_ids": [1966], "callee_method_names": ["HelixAxisAligner.getDimension"], "method_name": "JmolSymmetryScriptGeneratorH.getMaxExtension", "method_implementation": "{\n    Vector3d dimension = helixAxisAligner.getDimension();\n    double maxExtension = Math.max(dimension.x, dimension.y);\n    maxExtension = Math.max(maxExtension, dimension.z);\n    return maxExtension;\n}", "repo_id": "9", "comment": "/**\n * Returns the maximum extension (length) of structure\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3422, "method_signature": "double getMaxExtension()"}, "1895": {"callee_method_names": [], "method_name": "Stoichiometry.setCustomStringGenerator", "method_implementation": "{\n    this.strategy = StringOverflowStrategy.CUSTOM;\n    this.customStringGenerator = customStringGenerator;\n}", "repo_id": "9", "comment": "/**\n * Let a user-defined function handle the entire string representation of a stoichiometry.\n * @param customStringGenerator\n *          A function which accepts a list of subunit clusters and returns a string.\n */\n", "repo_name": "biojava-master/", "id": 1895, "method_signature": "void setCustomStringGenerator(Function)"}, "2743": {"callee_method_names": [], "method_name": "EmblRecord.getLastUpdatedDate", "method_implementation": "{\n    return lastUpdatedDate;\n}", "repo_id": "9", "comment": "/**\n * The DT (DaTe) line shows when an entry was last updated in the database.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2743, "method_signature": "String getLastUpdatedDate()"}, "309": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.deleteCharAt", "StringBuilder.length", "List<ModificationLinkage>.isEmpty", "StringBuilder.append", "StringBuilder.append", "StringBuilder.deleteCharAt", "StringBuilder.length", "StringBuilder.toString"], "method_name": "ModificationConditionImpl.toString", "method_implementation": "{\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Components:\");\n    for (Component comp : components) {\n        sb.append(comp).append(\";\");\n    }\n    sb.deleteCharAt(sb.length() - 1);\n    if (!linkages.isEmpty()) {\n        sb.append(\"\\nLinkages:\");\n        for (ModificationLinkage link : linkages) {\n            sb.append(link).append(\";\");\n        }\n        sb.deleteCharAt(sb.length() - 1);\n    }\n    return sb.toString();\n}", "repo_id": "9", "comment": "/**\n */\n", "repo_name": "biojava-master/", "id": 309, "method_signature": "String toString()"}, "2243": {"callee_method_names": [], "method_name": "TestMmtfRoundTrip.sortChains", "method_implementation": "{\n    Collections.sort(chainsOne, new Comparator<Chain>() {\n\n        @Override\n        public int compare(Chain o1, Chain o2) {\n            return o1.getId().compareTo(o2.getId());\n        }\n    });\n    Collections.sort(chainsTwo, new Comparator<Chain>() {\n\n        @Override\n        public int compare(Chain o1, Chain o2) {\n            return o1.getId().compareTo(o2.getId());\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Sort the chains based on chain id.\n *\n * @param chainsOne the first list of chains\n * @param chainsTwo the second list of chains\n */\n", "repo_name": "biojava-master/", "id": 2243, "method_signature": "void sortChains(List, List)"}, "2412": {"callee_method_names": [], "method_name": "Location.percentOverlap", "method_implementation": "{\n    if (length() > 0 && overlaps(other)) {\n        return 100.0 * (((double) intersection(other).length()) / (double) length());\n    } else {\n        return 0;\n    }\n}", "repo_id": "9", "comment": "/**\n * Return percent overlap of two locations.\n *\n * @param other The location to compare.\n * @return 100.0 * intersection(other).length() / this.length()\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2412, "method_signature": "double percentOverlap(Location)"}, "3189": {"callee_method_names": [], "method_name": "WindowedSequence.iterator", "method_implementation": "{\n    return new WindowedSequenceIterator<C>(this);\n}", "repo_id": "9", "comment": "/**\n * Returns an iterator which will return the windows in a sequence in\n * sequential order.\n */\n", "repo_name": "biojava-master/", "id": 3189, "method_signature": "Iterator<SequenceView<C>> iterator()"}, "260": {"callee_method_names": ["Map<String, Set<ProteinModification>>.keySet"], "method_name": "ProteinModificationRegistry.allResidIds", "method_implementation": "{\n    lazyInit();\n    Set<String> ret = byResidId.keySet();\n    return Collections.unmodifiableSet(ret);\n}", "repo_id": "9", "comment": "/**\n * @return set of RESID IDs of all registered ProteinModifications.\n */\n", "repo_name": "biojava-master/", "id": 260, "method_signature": "Set<String> allResidIds()"}, "3599": {"callee_method_ids": [3682], "callee_method_names": ["WaldTestInfo.setDf"], "method_name": "WaldTest.process", "method_implementation": "{\n    int i = 0;\n    //      if(ci.coefficientsList.size() == 1){\n    //          double b_ = b[0][i];\n    //          double t = (b_ * b_) / var[0][0];\n    //          return;\n    //      }\n    //  double toler_chol = ci.toler;\n    int ntest = 1;\n    int nvar = b[0].length;\n    double sum = 0;\n    double[][] solve = new double[ntest][nvar];\n    double[] bsum = new double[ntest];\n    Cholesky2.process(var, nvar, toler_chol);\n    int df = 0;\n    for (i = 0; i < nvar; i++) {\n        if (var[i][i] > 0) {\n            df++;\n            /* count up the df */\n        }\n    }\n    for (i = 0; i < ntest; i++) {\n        for (int j = 0; j < nvar; j++) {\n            solve[i][j] = b[i][j];\n        }\n        Chsolve2.process(var, nvar, solve, i);\n        /*solve now has b* var-inverse */\n        sum = 0;\n        for (int j = 0; j < nvar; j++) {\n            sum += b[i][j] * solve[i][j];\n        }\n        bsum[i] = sum;\n        /* save the result */\n        //b += nvar;    /*move to next column of b */\n        // solve += nvar;\n    }\n    //* nvar2 = df;\n    WaldTestInfo waldTestInfo = new WaldTestInfo();\n    waldTestInfo.setDf(df);\n    waldTestInfo.solve = solve;\n    waldTestInfo.bsum = bsum;\n    return waldTestInfo;\n}", "repo_id": "9", "comment": "/**\n * @param var\n * @param b\n * @param toler_chol\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3599, "method_signature": "WaldTestInfo process(double[][], double[][], double)"}, "257": {"callee_method_names": ["Map<ModificationOccurrenceType, Set<ProteinModification>>.get"], "method_name": "ProteinModificationRegistry.getByOccurrenceType", "method_implementation": "{\n    lazyInit();\n    Set<ProteinModification> ret = byOccurrenceType.get(occ);\n    return Collections.unmodifiableSet(ret);\n}", "repo_id": "9", "comment": "/**\n * @param occ {@link ModificationOccurrenceType}.\n * @return set of registered ProteinModifications of a particular occurrence type.\n */\n", "repo_name": "biojava-master/", "id": 257, "method_signature": "Set<ProteinModification> getByOccurrenceType(ModificationOccurrenceType)"}, "3595": {"callee_method_names": [], "method_name": "StdArrayIO.main", "method_implementation": "{\n}", "repo_id": "9", "comment": "/**\n * Test client.\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 3595, "method_signature": "void main(String[])"}, "3144": {"callee_method_names": ["Document.getDocumentElement", "Element.getTextContent", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "UniprotProxySequenceReader.getOrganismName", "method_implementation": "{\n    if (uniprotDoc == null) {\n        return \"\";\n    }\n    try {\n        Element uniprotElement = uniprotDoc.getDocumentElement();\n        Element entryElement = XMLHelper.selectSingleElement(uniprotElement, \"entry\");\n        Element organismElement = XMLHelper.selectSingleElement(entryElement, \"organism\");\n        if (organismElement == null) {\n            return \"\";\n        }\n        Element nameElement = XMLHelper.selectSingleElement(organismElement, \"name\");\n        if (nameElement == null) {\n            return \"\";\n        }\n        return nameElement.getTextContent();\n    } catch (XPathExpressionException e) {\n        logger.error(\"Problems while parsing organism name in UniProt XML: {}. Organism name will be blank.\", e.getMessage());\n        return \"\";\n    }\n}", "repo_id": "9", "comment": "/**\n * Get the organism name assigned to this sequence\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3144, "method_signature": "String getOrganismName()"}, "2861": {"callee_method_names": [], "method_name": "ABITrace.getBasecalls", "method_implementation": "{\n    return baseCalls;\n}", "repo_id": "9", "comment": "/**\n * Returns an <code>int[]</code> array that represents the basecalls - each int in the\n * array corresponds to an x-coordinate point in the graph that is a peak (a base location).\n *\n * @return int[] Basecalls\n */\n", "repo_name": "biojava-master/", "id": 2861, "method_signature": "int[] getBasecalls()"}, "2496": {"callee_method_names": ["File.getAbsolutePath"], "method_name": "GeneFeatureHelper.loadFastaAddGeneFeaturesFromGeneIDGFF2", "method_implementation": "{\n    LinkedHashMap<String, DNASequence> dnaSequenceList = FastaReaderHelper.readFastaDNASequence(fastaSequenceFile);\n    LinkedHashMap<String, ChromosomeSequence> chromosomeSequenceList = GeneFeatureHelper.getChromosomeSequenceFromDNASequence(dnaSequenceList);\n    FeatureList listGenes = GeneIDGFF2Reader.read(gffFile.getAbsolutePath());\n    addGeneIDGFF2GeneFeatures(chromosomeSequenceList, listGenes);\n    return chromosomeSequenceList;\n}", "repo_id": "9", "comment": "/**\n * Loads Fasta file and GFF2 feature file generated from the geneid prediction algorithm\n *\n * @param fastaSequenceFile\n * @param gffFile\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2496, "method_signature": "LinkedHashMap<String,ChromosomeSequence> loadFastaAddGeneFeaturesFromGeneIDGFF2(File, File)"}, "2897": {"callee_method_names": [], "method_name": "SequenceMixin.sequenceEquality", "method_implementation": "{\n    return baseSequenceEquality(source, target, false);\n}", "repo_id": "9", "comment": "/**\n * A case-sensitive manner of comparing two sequence objects together.\n * We will throw out any compounds which fail to match on their sequence\n * length & compound sets used. The code will also bail out the moment\n * we find something is wrong with a Sequence. Cost to run is linear to\n * the length of the Sequence.\n *\n * @param <C> The type of compound\n * @param source Source sequence to assess\n * @param target Target sequence to assess\n * @return Boolean indicating if the sequences matched\n */\n", "repo_name": "biojava-master/", "id": 2897, "method_signature": "boolean sequenceEquality(Sequence, Sequence)"}, "1170": {"callee_method_names": ["String.substring", "String.length", "String.length", "Logger.debug", "String.substring", "String.length", "ArrayList.add", "ArrayList.add"], "method_name": "PDBFileParser.pdb_JRNL_Handler", "method_implementation": "{\n    //add the strings to the journalLines\n    //the actual JournalArticle is then built when the whole entry is being\n    //finalized with triggerEndFileChecks()\n    //JRNL        TITL   NMR SOLUTION STRUCTURE OF RECOMBINANT TICK           1TAP  10\n    if (line.substring(line.length() - 8, line.length() - 4).equals(pdbId)) {\n        //trim off the trailing PDB id from legacy files.\n        //are we really trying to still cater for these museum pieces?\n        logger.debug(\"trimming legacy PDB id from end of JRNL section line\");\n        line = line.substring(0, line.length() - 8);\n        journalLines.add(line);\n    } else {\n        journalLines.add(line);\n    }\n}", "repo_id": "9", "comment": "/**\n * JRNL handler.\n * The JRNL record contains the primary literature citation that describes the experiment which resulted\n * in the deposited coordinate set. There is at most one JRNL reference per entry. If there is no primary\n * reference, then there is no JRNL reference. Other references are given in REMARK 1.\n *\n * Record Format\n * <pre>\n * COLUMNS       DATA TYPE     FIELD         DEFINITION\n * -----------------------------------------------------------------------\n * 1 -  6       Record name   \"JRNL  \"\n *\n * 13 - 70       LString        text         See Details below.\n * </pre>\n */\n", "repo_name": "biojava-master/", "id": 1170, "method_signature": "void pdb_JRNL_Handler(String)"}, "2578": {"callee_method_names": [], "method_name": "FileDownloadUtils.deleteDirectory", "method_implementation": "{\n    deleteDirectory(Paths.get(dir));\n}", "repo_id": "9", "comment": "/**\n * Recursively delete a folder & contents\n *\n * @param dir directory to delete\n */\n", "repo_name": "biojava-master/", "id": 2578, "method_signature": "void deleteDirectory(String)"}, "3401": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getAxisTransformation", "method_implementation": "{\n    return rotationAxisAligner;\n}", "repo_id": "9", "comment": "/**\n * @return the axisTransformation\n */\n", "repo_name": "biojava-master/", "id": 3401, "method_signature": "RotationAxisAligner getAxisTransformation()"}, "2982": {"callee_method_names": ["List<C>.size", "Strand.equals", "List<C>.get", "StringBuilder.append", "CompoundSet<C>.getStringForCompound", "List<C>.get", "StringBuilder.append", "CompoundSet<C>.getStringForCompound", "List<C>.size", "List<C>.get", "StringBuilder.append", "CompoundSet<C>.getStringForCompound", "List<C>.get", "StringBuilder.append", "CompoundSet<C>.getStringForCompound", "List<C>.size", "List<C>.get", "StringBuilder.append", "CompoundSet<C>.getStringForCompound", "List<C>.get", "StringBuilder.append", "CompoundSet<C>.getStringForCompound", "StringBuilder.toString"], "method_name": "SequenceAsStringHelper.getSequenceAsString", "method_implementation": "{\n    // TODO Optimise/cache.\n    if (parsedCompounds.size() == 0)\n        return \"\";\n    StringBuilder builder = new StringBuilder();\n    if (strand.equals(Strand.NEGATIVE)) {\n        //we expect bioBegin to be bigger but could have circular case\n        if (bioBegin <= bioEnd) {\n            for (int index = bioEnd - 1; index >= bioBegin - 1; index--) {\n                C compound = parsedCompounds.get(index);\n                builder.append(compoundSet.getStringForCompound(compound));\n            }\n        } else {\n            //go to 0 and the up\n            for (int index = bioBegin - 1; index >= 0; index--) {\n                C compound = parsedCompounds.get(index);\n                builder.append(compoundSet.getStringForCompound(compound));\n            }\n            for (int index = parsedCompounds.size() - 1; index >= bioEnd - 1; index--) {\n                C compound = parsedCompounds.get(index);\n                builder.append(compoundSet.getStringForCompound(compound));\n            }\n        }\n    } else {\n        if (bioBegin <= bioEnd) {\n            for (int index = bioBegin - 1; index <= bioEnd - 1; index++) {\n                C compound = parsedCompounds.get(index);\n                builder.append(compoundSet.getStringForCompound(compound));\n            }\n        } else {\n            //go to 0 and the up\n            for (int index = bioBegin - 1; index <= parsedCompounds.size() - 1; index++) {\n                C compound = parsedCompounds.get(index);\n                builder.append(compoundSet.getStringForCompound(compound));\n            }\n            for (int index = 0; index <= bioEnd - 1; index++) {\n                C compound = parsedCompounds.get(index);\n                builder.append(compoundSet.getStringForCompound(compound));\n            }\n        }\n    }\n    return builder.toString();\n}", "repo_id": "9", "comment": "/**\n * @param parsedCompounds\n * @param compoundSet\n * @param bioBegin\n * @param bioEnd\n * @param strand\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2982, "method_signature": "String getSequenceAsString(List, CompoundSet, Integer, Integer, Strand)"}, "1866": {"callee_method_names": [], "method_name": "Rotation.setDirection", "method_implementation": "{\n    this.direction = axis;\n}", "repo_id": "9", "comment": "/**\n * @param direction the direction to set\n */\n", "repo_name": "biojava-master/", "id": 1866, "method_signature": "void setDirection(int)"}, "2382": {"callee_method_names": [], "method_name": "TwoBitParser.getCurrentSequencePosition", "method_implementation": "{\n    if (cur_seq_name == null)\n        throw new RuntimeException(\"Sequence is not set\");\n    return cur_seq_pos;\n}", "repo_id": "9", "comment": "/**\n * @return number (starting from 0) of next readable nucleotide in sequence stream.\n */\n", "repo_name": "biojava-master/", "id": 2382, "method_signature": "long getCurrentSequencePosition()"}, "2086": {"callee_method_names": [], "method_name": "SymmetryAxes.getSymmType", "method_implementation": "{\n    return symmType;\n}", "repo_id": "9", "comment": "/**\n * @return the symmType (OPEN or CLOSED only)\n */\n", "repo_name": "biojava-master/", "id": 2086, "method_signature": "SymmetryType getSymmType()"}, "2091": {"callee_method_names": [], "method_name": "SymmetryAxes.setFirstRepeat", "method_implementation": "{\n    this.firstRepeat = firstRepeat;\n}", "repo_id": "9", "comment": "/**\n * @param firstRepeat the index of the first repeat used by this axis\n */\n", "repo_name": "biojava-master/", "id": 2091, "method_signature": "void setFirstRepeat(int)"}, "137": {"callee_method_ids": [449, 452, 451], "callee_method_names": ["QsAlignResult.length", "QsAlignResult.getRelation", "QsAlignResult.getRmsd"], "method_name": "TestQsAlignExamples.testIdentity", "method_implementation": "{\n    Structure s1 = StructureIO.getStructure(\"4hhb\");\n    Structure s2 = s1;\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n    QsAlignParameters alignParams = new QsAlignParameters();\n    QsAlignResult result = QsAlign.align(s1, s2, clusterParams, alignParams);\n    assertEquals(result.length(), 4);\n    assertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n    assertEquals(result.getRmsd(), 0.0, 0.01);\n}", "repo_id": "9", "comment": "/**\n * Identity: test hemoglobin (4HHB) against itself.\n */\n", "repo_name": "biojava-master/", "id": 137, "method_signature": "void testIdentity()"}, "2306": {"callee_method_names": ["List<Point3d[]>.size", "SuperPosition.superpose", "List<Point3d[]>.get", "List<Point3d[]>.get", "SuperPosition.superpose", "List<Point3d[]>.get", "List<Point3d[]>.get", "SuperPosition.superpose", "List<Point3d[]>.get", "List<Point3d[]>.get", "Logger.info", "List<Point3d[]>.get", "Matrix4d.epsilonEquals", "Matrix4d.epsilonEquals", "Matrix4d.epsilonEquals"], "method_name": "TestSuperPosition.testSuperposition", "method_implementation": "{\n    for (int c = 0; c < cloud1.size(); c++) {\n        // Use SVD superposition\n        SuperPosition svd = new SuperPositionSVD(false);\n        long svdStart = System.nanoTime();\n        Matrix4d svdTransform = svd.superpose(cloud1.get(c), cloud2.get(c));\n        long svdTime = (System.nanoTime() - svdStart) / 1000;\n        // Use quaternion superposition\n        SuperPosition quat = new SuperPositionQuat(false);\n        long quatStart = System.nanoTime();\n        Matrix4d quatTransform = quat.superpose(cloud1.get(c), cloud2.get(c));\n        long quatTime = (System.nanoTime() - quatStart) / 1000;\n        // Use QCP algorithm\n        SuperPosition qcp = new SuperPositionQCP(false);\n        long qcpStart = System.nanoTime();\n        Matrix4d qcpTransform = qcp.superpose(cloud1.get(c), cloud2.get(c));\n        long qcpTime = (System.nanoTime() - qcpStart) / 1000;\n        LOGGER.info(String.format(\"Transformation Matrix %d points: \" + \"SVD time %d us, SP time: %d us, QCP time: %d us\", cloud1.get(c).length, svdTime, quatTime, qcpTime));\n        // Check that the transformation matrix was recovered\n        assertTrue(transform.epsilonEquals(svdTransform, 0.05));\n        assertTrue(transform.epsilonEquals(quatTransform, 0.05));\n        assertTrue(transform.epsilonEquals(qcpTransform, 0.05));\n    }\n}", "repo_id": "9", "comment": "/**\n * Test method to obtain the transformation matrix from superpositions.\n */\n", "repo_name": "biojava-master/", "id": 2306, "method_signature": "void testSuperposition()"}, "1660": {"callee_method_ids": [1673, 1673, 1675, 1675, 1670, 1669, 1343], "callee_method_names": ["SubunitCluster.get", "Subunit.getName", "Subunit.getName", "Logger.info", "Subunit.getStructure", "Subunit.getStructure", "Structure.getChain", "Structure.getChain", "Chain.getEntityInfo", "Subunit.size", "Subunit.getRepresentativeAtoms", "EntityInfo.getAlignedResIndex", "Chain.getSeqResGroups", "Chain.getAtomGroups", "SubunitCluster.get", "List<Integer>.add", "List<Integer>.add", "List<Integer>.size", "List<Integer>.size", "Logger.warn"], "method_name": "SubunitCluster.mergeIdenticalByEntityId", "method_implementation": "{\n    if (!isIdenticalByEntityIdTo(other))\n        return false;\n    Subunit thisSub = this.subunits.get(this.representative);\n    Subunit otherSub = other.subunits.get(other.representative);\n    String thisName = thisSub.getName();\n    String otherName = otherSub.getName();\n    logger.info(\"SubunitClusters {}-{} belong to same entity. Assuming they are identical\", thisName, otherName);\n    List<Integer> thisAligned = new ArrayList<>();\n    List<Integer> otherAligned = new ArrayList<>();\n    // we've merged by entity id, we can assume structure, chain and entity are available (checked in isIdenticalByEntityIdTo())\n    Structure thisStruct = thisSub.getStructure();\n    Structure otherStruct = otherSub.getStructure();\n    Chain thisChain = thisStruct.getChain(thisName);\n    Chain otherChain = otherStruct.getChain(otherName);\n    EntityInfo entityInfo = thisChain.getEntityInfo();\n    // Extract the aligned residues of both Subunits\n    for (int thisIndex = 0; thisIndex < thisSub.size(); thisIndex++) {\n        Group g = thisSub.getRepresentativeAtoms()[thisIndex].getGroup();\n        int seqresIndex = entityInfo.getAlignedResIndex(g, thisChain);\n        if (seqresIndex == -1) {\n            // this might mean that FileParsingParameters.setAlignSeqRes() wasn't set to true during parsing\n            continue;\n        }\n        // note the seqresindex is 1-based\n        Group otherG = otherChain.getSeqResGroups().get(seqresIndex - 1);\n        int otherIndex = otherChain.getAtomGroups().indexOf(otherG);\n        if (otherIndex == -1) {\n            // skip residues that are unobserved in other sequence (\"gaps\" in the entity SEQRES alignment)\n            continue;\n        }\n        // Only consider residues that are part of the SubunitCluster\n        if (this.subunitEQR.get(this.representative).contains(thisIndex) && other.subunitEQR.get(other.representative).contains(otherIndex)) {\n            thisAligned.add(thisIndex);\n            otherAligned.add(otherIndex);\n        }\n    }\n    if (thisAligned.size() == 0 && otherAligned.size() == 0) {\n        logger.warn(\"No equivalent aligned atoms found between SubunitClusters {}-{} via entity SEQRES alignment. Is FileParsingParameters.setAlignSeqRes() set?\", thisName, otherName);\n    }\n    updateEquivResidues(other, thisAligned, otherAligned);\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Merges the other SubunitCluster into this one if it contains exactly the\n * same Subunit. This is checked by comparing the entity identifiers of the subunits\n * if one can be found.\n * Thus this only makes sense when the subunits are complete chains of a\n * deposited PDB entry.\n *\n * @param other\n *            SubunitCluster\n * @return true if the SubunitClusters were merged, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 1660, "method_signature": "boolean mergeIdenticalByEntityId(SubunitCluster)"}, "2268": {"callee_method_names": ["ClassLoader.getResource", "Structure.getPDBCode", "Structure.getPDBHeader", "Structure.getChains"], "method_name": "TestMmtfStructureReader.testRead", "method_implementation": "{\n    // Get the MMTF file from the resources folder\n    ClassLoader classLoader = getClass().getClassLoader();\n    String resource = \"org/biojava/nbio/structure/io/mmtf/4CUP.mmtf\";\n    // Load the structure into memory\n    Structure structure = MmtfActions.readFromFile(new File(classLoader.getResource(resource).getPath()).toPath());\n    // Check header properties of the structure\n    assertEquals(structure.getPDBCode(), \"4CUP\");\n    assertEquals(MmtfUtils.dateToIsoString(structure.getPDBHeader().getDepDate()), \"2014-03-21\");\n    assertEquals(structure.getChains().size(), 6);\n}", "repo_id": "9", "comment": "/**\n * Test reading an MMTF file into a BioJava structure.\n */\n", "repo_name": "biojava-master/", "id": 2268, "method_signature": "void testRead()"}, "714": {"callee_method_ids": [746, 496, 752, 485, 762, 498, 495, 491], "callee_method_names": ["CeParameters.getWinSize", "Atom[].getX", "Atom[].getX", "AFPChain.setTotalRmsdIni", "AFPChain.setTotalLenIni", "CeParameters.isShowAFPRanges", "AFP.setFragLen", "AFP.setP1", "AFP.setP2", "List<AFP>.add", "AFPChain.setAfpSet", "CeParameters.isOptimizeAlignment", "AFPChain.setTotalRmsdOpt", "AFPChain.getTotalRmsdIni", "AFPChain.setCalculationTime", "AFPChain.setGapLen", "AFPChain.setOptLen", "AFPChain.setOptLength", "AFPChain.setAlnLength", "AFPChain.setProbability"], "method_name": "CECalculator.checkBestTraces", "method_implementation": "{\n    z = 0.0;\n    int nGaps;\n    int winSize = params.getWinSize();\n    int nse1 = ca1.length;\n    int nse2 = ca2.length;\n    int traceMaxSize = nse1 < nse2 ? nse1 : nse2;\n    int idir;\n    align_se1 = new int[nse1 + nse2];\n    align_se2 = new int[nse1 + nse2];\n    lcmp = 0;\n    // we now support alignment using any particular atoms..\n    Atom[] strBuf1 = new Atom[traceMaxSize];\n    Atom[] strBuf2 = new Atom[traceMaxSize];\n    double rmsdNew;\n    // removing some loops that are run in orig CE\n    // and which did not do anything\n    if (debug) {\n        checkPrintRmsdNew(traceMaxSize, winSize, ca1, ca2);\n    }\n    double rmsd = 100.0;\n    int iBestTrace = 0;\n    for (int ir = 0; ir < nBestTraces; ir++) {\n        if (bestTracesN[ir] != nBestTrace)\n            continue;\n        rmsdNew = getRMSDForBestTrace(ir, strBuf1, strBuf2, bestTracesN, bestTraces1, bestTrace2, winSize, ca1, ca2);\n        if (isPrint)\n            System.out.println(String.format(\"%d %d %d %.2f\", ir, bestTracesN[ir], nBestTrace, rmsdNew));\n        if (rmsd > rmsdNew) {\n            iBestTrace = ir;\n            rmsd = rmsdNew;\n            //System.out.println(\" iBestTrace:\" + iBestTrace + \" new rmsd = \" + rmsd);\n        }\n    }\n    for (int it = 0; it < bestTracesN[iBestTrace]; it++) {\n        bestTrace1[it] = bestTraces1[iBestTrace][it];\n        bestTrace2[it] = bestTraces2[iBestTrace][it];\n    }\n    //System.out.println(\"iBestTrace: \"+iBestTrace+\" = bestTracesScores \" + bestTracesScores[iBestTrace]);\n    nBestTrace = bestTracesN[iBestTrace];\n    bestTraceScore = bestTracesScores[iBestTrace];\n    //printf(\"\\nOptimizing gaps...\\n\");\n    int[] traceLen = new int[traceMaxSize];\n    bestTraceLen = new int[traceMaxSize];\n    int strLen = 0;\n    int jt;\n    strLen = 0;\n    nGaps = 0;\n    nTrace = nBestTrace;\n    for (jt = 0; jt < nBestTrace; jt++) {\n        trace1[jt] = bestTrace1[jt];\n        trace2[jt] = bestTrace2[jt];\n        traceLen[jt] = winSize;\n        if (jt < nBestTrace - 1) {\n            nGaps += bestTrace1[jt + 1] - bestTrace1[jt] - winSize + bestTrace2[jt + 1] - bestTrace2[jt] - winSize;\n        }\n    }\n    nBestTrace = 0;\n    for (int it = 0; it < nTrace; ) {\n        int cSize = traceLen[it];\n        for (jt = it + 1; jt < nTrace; jt++) {\n            if (trace1[jt] - trace1[jt - 1] - traceLen[jt - 1] != 0 || trace2[jt] - trace2[jt - 1] - traceLen[jt - 1] != 0)\n                break;\n            cSize += traceLen[jt];\n        }\n        bestTrace1[nBestTrace] = trace1[it];\n        bestTrace2[nBestTrace] = trace2[it];\n        bestTraceLen[nBestTrace] = cSize;\n        nBestTrace++;\n        strLen += cSize;\n        it = jt;\n    }\n    int is = 0;\n    for (jt = 0; jt < nBestTrace; jt++) {\n        for (int i = 0; i < bestTraceLen[jt]; i++) {\n            setStrBuf(strBuf1, is + i, ca1, bestTrace1[jt] + i);\n            setStrBuf(strBuf2, is + i, ca2, bestTrace2[jt] + i);\n        }\n        is += bestTraceLen[jt];\n    }\n    //sup_str(strBuf1, strBuf2, strLen, d_);\n    rmsd = calc_rmsd(strBuf1, strBuf2, strLen, true);\n    if (isPrint)\n        System.out.println(\"got first rmsd: \" + rmsd);\n    boolean isCopied = false;\n    outer_loop: for (int it = 1; it < nBestTrace; it++) {\n        /* not needed...\n\t\t\tint igap;\n\t\t\tif(bestTrace1[it]-bestTrace1[it-1]-bestTraceLen[it-1]>0) igap=0;\n\t\t\tif(bestTrace2[it]-bestTrace2[it-1]-bestTraceLen[it-1]>0) igap=1;\n\t\t\t\t */\n        boolean wasBest = false;\n        main_loop: for (idir = -1; idir <= 1; idir += 2) {\n            if (wasBest)\n                break;\n            inner_loop: for (int idep = 1; idep <= winSize / 2; idep++) {\n                // isCopied indicates that bestTrace has changed and needs to be re-copied\n                if (!isCopied)\n                    for (jt = 0; jt < nBestTrace; jt++) {\n                        trace1[jt] = bestTrace1[jt];\n                        trace2[jt] = bestTrace2[jt];\n                        traceLen[jt] = bestTraceLen[jt];\n                    }\n                isCopied = false;\n                // Move an atom from the previous trace to the current on, or vice versa\n                traceLen[it - 1] += idir;\n                traceLen[it] -= idir;\n                trace1[it] += idir;\n                trace2[it] += idir;\n                // Copy atoms from the current trace into strBuf\n                is = 0;\n                for (jt = 0; jt < nBestTrace; jt++) {\n                    for (int i = 0; i < traceLen[jt]; i++) {\n                        if (ca1[trace1[jt] + i].getX() > 1e10 || ca2[trace2[jt] + i].getX() > 1e10)\n                            continue main_loop;\n                        strBuf1[is + i] = ca1[trace1[jt] + i];\n                        strBuf2[is + i] = ca2[trace2[jt] + i];\n                    }\n                    is += traceLen[jt];\n                }\n                // Check new RMSD\n                //sup_str(strBuf1, strBuf2, strLen, d_);\n                rmsdNew = calc_rmsd(strBuf1, strBuf2, strLen, true);\n                //System.out.println(String.format(\"step %d %d %d %.2f old: %.2f\", it, idir, idep, rmsdNew, rmsd));\n                // Update best trace if RMSD improved\n                if (rmsdNew < rmsd) {\n                    for (jt = 0; jt < nBestTrace; jt++) {\n                        bestTrace1[jt] = trace1[jt];\n                        bestTrace2[jt] = trace2[jt];\n                        bestTraceLen[jt] = traceLen[jt];\n                    }\n                    isCopied = true;\n                    wasBest = true;\n                    rmsd = rmsdNew;\n                    continue inner_loop;\n                }\n                // AP\n                //bad_ca: break;\n                continue main_loop;\n            }\n        }\n    }\n    rmsdNew = calc_rmsd(strBuf1, strBuf2, strLen, true);\n    if (isPrint)\n        System.out.println(\"rmsdNew: \" + rmsdNew + \" rmsd \" + rmsd);\n    afpChain.setTotalRmsdIni(rmsdNew);\n    afpChain.setTotalLenIni(strBuf1.length);\n    nAtom = strLen;\n    //System.out.println(\"zStrAlign: \" + winSize + \" strLen \" + strLen  + \" s/w \" + (strLen/winSize) + \" \" + bestTraceScore + \" \" + nGaps);\n    z = zStrAlign(winSize, strLen / winSize, bestTraceScore, nGaps);\n    if (params.isShowAFPRanges()) {\n        System.out.println(\"win size: \" + winSize + \" strLen/winSize: \" + strLen / winSize + \" best trace score: \" + String.format(\"%.2f\", bestTraceScore) + \" nr gaps: \" + nGaps + \" nr residues: \" + nAtom);\n        System.out.println(String.format(\"size=%d rmsd=%.2f z=%.1f gaps=%d(%.1f%%) comb=%d\", nAtom, rmsd, z, nGaps, nGaps * 100.0 / nAtom, nTraces));\n        System.out.println(\"Best Trace, before optimization\");\n        for (int k = 0; k < nBestTrace; k++) System.out.println(String.format(\"(%d,%d,%d) \", bestTrace1[k] + 1, bestTrace2[k] + 1, bestTraceLen[k]));\n    }\n    // start to convert CE internal datastructure to generic AFPChain one...\n    List<AFP> afpSet = new ArrayList<AFP>();\n    for (int afp = 0; afp < nBestTrace; afp++) {\n        // fill in data from nBestTrace into AFP\n        AFP afpI = new AFP();\n        afpI.setFragLen(bestTraceLen[afp]);\n        afpI.setP1(bestTrace1[afp] + 1);\n        afpI.setP2(bestTrace2[afp] + 1);\n        afpSet.add(afpI);\n    }\n    afpChain.setAfpSet(afpSet);\n    //System.out.println(\"z:\"+z + \" zThr\" + zThr+ \" bestTraceScore \" + bestTraceScore + \" \" + nGaps );\n    if (params.isOptimizeAlignment() && z >= zThr) {\n        nGaps = optimizeSuperposition(afpChain, nse1, nse2, strLen, rmsd, ca1, ca2, nGaps, strBuf1, strBuf2);\n        //\t      if(isPrint) {\n        //\t\t/*\n        //\t\tFILE *f=fopen(\"homologies\", \"a\");\n        //\t\tfprintf(f, \"%s(%d) %s(%d) %3d %4.1f %4.1f %d(%d) \",\n        //\t\t\tname1, nse1, name2, nse2, nAtom, rmsd, z,\n        //\t\t\tnGaps, nGaps*100/nAtom);\n        //\t\tfor(int k=0; k<nBestTrace; k++)\n        //\t\t  fprintf(f, \"(%d,%d,%d) \", bestTrace1[k]+1, bestTrace2[k]+1,\n        //\t\t\t  bestTraceLen[k]);\n        //\t\tfprintf(f, \"\\n\");\n        //\t\tfclose(f);\n        //\t\t*/\n        //\t      }\n    } else {\n        int lali_x_ = 0;\n        for (int k = 0; k < nBestTrace; k++) {\n            for (int l = 0; l < bestTraceLen[k]; l++) {\n                align_se1[lcmp + l] = bestTrace1[k] + l;\n                align_se2[lcmp + l] = bestTrace2[k] + l;\n            }\n            lali_x_ += bestTraceLen[k];\n            lcmp += bestTraceLen[k];\n            if (k < nBestTrace - 1) {\n                if (bestTrace1[k] + bestTraceLen[k] != bestTrace1[k + 1])\n                    for (int l = bestTrace1[k] + bestTraceLen[k]; l < bestTrace1[k + 1]; l++) {\n                        align_se1[lcmp] = l;\n                        align_se2[lcmp] = -1;\n                        lcmp++;\n                    }\n                if (bestTrace2[k] + bestTraceLen[k] != bestTrace2[k + 1])\n                    for (int l = bestTrace2[k] + bestTraceLen[k]; l < bestTrace2[k + 1]; l++) {\n                        align_se1[lcmp] = -1;\n                        align_se2[lcmp] = l;\n                        lcmp++;\n                    }\n            }\n        }\n        nAtom = lali_x_;\n        afpChain.setTotalRmsdOpt(afpChain.getTotalRmsdIni());\n    }\n    timeEnd = System.currentTimeMillis();\n    long time_q = (timeEnd - timeStart);\n    double gapsP = (nGaps * 100.0 / nAtom);\n    if (isPrint) {\n        String msg = String.format(\"Alignment length = %d Rmsd = %.2fA Z-Score = %.1f Gaps = %d(%.1f%%)\", nAtom, rmsd, z, nGaps, gapsP);\n        System.out.println(msg + \" CPU = \" + time_q);\n    }\n    //      if ( params.isShowAFPRanges()){\n    // this is actually the final alignment...\n    //         System.out.println(\"Best Trace: (index1,index2,len)\");\n    //         for(int k=0; k<nBestTrace; k++)\n    //            System.out.println(\n    //                  String.format(\"(%d,%d,%d) \", bestTrace1[k]+1, bestTrace2[k]+1, bestTraceLen[k]));\n    //\n    //\n    //\n    //      }\n    afpChain.setCalculationTime(time_q);\n    afpChain.setGapLen(nGaps);\n    int[] optLen = new int[] { nAtom };\n    afpChain.setOptLen(optLen);\n    afpChain.setOptLength(nAtom);\n    afpChain.setAlnLength(lcmp);\n    afpChain.setProbability(z);\n}", "repo_id": "9", "comment": "// this part is modified from the original CeCalculator\n", "repo_name": "biojava-master/", "id": 714, "method_signature": "void checkBestTraces(AFPChain, Atom[], Atom[])"}, "387": {"callee_method_names": ["Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get"], "method_name": "Calc.getXYZEuler", "method_implementation": "{\n    double heading, attitude, bank;\n    // Assuming the angles are in radians.\n    if (m.get(1, 0) > 0.998) {\n        // singularity at north pole\n        heading = Math.atan2(m.get(0, 2), m.get(2, 2));\n        attitude = Math.PI / 2;\n        bank = 0;\n    } else if (m.get(1, 0) < -0.998) {\n        // singularity at south pole\n        heading = Math.atan2(m.get(0, 2), m.get(2, 2));\n        attitude = -Math.PI / 2;\n        bank = 0;\n    } else {\n        heading = Math.atan2(-m.get(2, 0), m.get(0, 0));\n        bank = Math.atan2(-m.get(1, 2), m.get(1, 1));\n        attitude = Math.asin(m.get(1, 0));\n    }\n    return new double[] { heading, attitude, bank };\n}", "repo_id": "9", "comment": "/**\n * Convert a rotation Matrix to Euler angles. This conversion uses\n * conventions as described on page:\n *   http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm\n * Coordinate System: right hand Positive angle: right hand Order of euler\n * angles: heading first, then attitude, then bank\n *\n * @param m\n *            the rotation matrix\n * @return a array of three doubles containing the three euler angles in\n *         radians\n */\n", "repo_name": "biojava-master/", "id": 387, "method_signature": "double[] getXYZEuler(Matrix)"}, "3607": {"callee_method_names": [], "method_name": "CoxInfo.getVariance", "method_implementation": "{\n    double[][] var = new double[imat.length][imat[0].length];\n    for (int i = 0; i < var.length; i++) {\n        for (int j = 0; j < var[0].length; j++) {\n            var[i][j] = imat[i][j];\n        }\n    }\n    return var;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3607, "method_signature": "double[][] getVariance()"}, "2829": {"callee_method_names": ["S.setOriginalHeader", "S.setAccession", "S.setDescription", "S.setComments", "S.setReferences"], "method_name": "GenericGenbankHeaderParser.parseHeader", "method_implementation": "{\n    sequence.setOriginalHeader(header);\n    sequence.setAccession(new AccessionID(accession, DataSource.GENBANK, version, identifier));\n    sequence.setDescription(description);\n    sequence.setComments(comments);\n    sequence.setReferences(references);\n}", "repo_id": "9", "comment": "/**\n * Parse the header and set the values in the sequence\n * @param header\n * @param sequence\n */\n", "repo_name": "biojava-master/", "id": 2829, "method_signature": "void parseHeader(String, S)"}, "676": {"callee_method_names": ["MultipleAlignment.size", "MultipleAlignment.getAtomArrays", "List<Atom[]>.get", "List<Atom[]>.get", "MultipleAlignment.getBlockSet", "Logger.error", "MultipleAlignment.clone", "MultipleSuperimposer.superimpose", "MultipleAlignment.getBlockSet", "List<Atom[]>.get", "List<Group>.size", "Group.getAtom", "List<Matrix4d>.get", "List<Atom[]>.add"], "method_name": "MultipleAlignmentDisplay.getRotatedAtoms", "method_implementation": "{\n    int size = multAln.size();\n    List<Atom[]> atomArrays = multAln.getAtomArrays();\n    for (int i = 0; i < size; i++) {\n        if (atomArrays.get(i).length < 1)\n            throw new StructureException(\"Length of atoms arrays is too short! Size: \" + atomArrays.get(i).length);\n    }\n    List<Atom[]> rotatedAtoms = new ArrayList<Atom[]>();\n    // TODO implement independent BlockSet superposition of the structure\n    List<Matrix4d> transf = multAln.getBlockSet(0).getTransformations();\n    if (transf == null) {\n        logger.error(\"Alignment Transformations are not calculated. \" + \"Superimposing to first structure as reference.\");\n        multAln = multAln.clone();\n        MultipleSuperimposer imposer = new ReferenceSuperimposer();\n        imposer.superimpose(multAln);\n        transf = multAln.getBlockSet(0).getTransformations();\n        assert (transf != null);\n    }\n    // Rotate the atom coordinates of all the structures\n    for (int i = 0; i < size; i++) {\n        // TODO handle BlockSet-level transformations\n        // make sure this method has the same behavior as the other display.\n        // -SB 2015-06\n        // Assume all atoms are from the same structure\n        Structure displayS = atomArrays.get(i)[0].getGroup().getChain().getStructure().clone();\n        // Get all the atoms and include ligands and hetatoms\n        Atom[] rotCA = StructureTools.getRepresentativeAtomArray(displayS);\n        List<Group> hetatms = StructureTools.getUnalignedGroups(rotCA);\n        int index = rotCA.length;\n        rotCA = Arrays.copyOf(rotCA, rotCA.length + hetatms.size());\n        for (Group g : hetatms) {\n            rotCA[index] = g.getAtom(0);\n            index++;\n        }\n        // Transform the structure to ensure a full rotation in the display\n        Calc.transform(displayS, transf.get(i));\n        rotatedAtoms.add(rotCA);\n    }\n    return rotatedAtoms;\n}", "repo_id": "9", "comment": "/**\n * New structures are downloaded if they were not cached in the alignment\n * and they are entirely transformed here with the superposition information\n * in the Multiple Alignment.\n *\n * @param multAln\n * @return list of transformed AtomArrays\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 676, "method_signature": "List<Atom[]> getRotatedAtoms(MultipleAlignment)"}, "1657": {"callee_method_names": ["SubunitCluster.get", "String.equals"], "method_name": "SubunitCluster.isIdenticalTo", "method_implementation": "{\n    String thisSequence = this.subunits.get(this.representative).getProteinSequenceString();\n    String otherSequence = other.subunits.get(other.representative).getProteinSequenceString();\n    return thisSequence.equals(otherSequence);\n}", "repo_id": "9", "comment": "/**\n * Tells whether the other SubunitCluster contains exactly the same Subunit.\n * This is checked by String equality of their residue one-letter sequences.\n *\n * @param other\n *            SubunitCluster\n * @return true if the SubunitClusters are identical, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 1657, "method_signature": "boolean isIdenticalTo(SubunitCluster)"}, "3107": {"callee_method_names": [], "method_name": "DBReferenceInfo.setDatabase", "method_implementation": "{\n    this.database = database;\n}", "repo_id": "9", "comment": "/**\n * @param database the database to set\n */\n", "repo_name": "biojava-master/", "id": 3107, "method_signature": "void setDatabase(String)"}, "2223": {"callee_method_names": ["ClassLoader.getResource", "SimpleDateFormat.parse", "Structure.getPDBHeader", "SimpleDateFormat.parse", "Structure.getPDBHeader", "SimpleDateFormat.parse", "Structure.getPDBHeader"], "method_name": "TestParseMmcifHeader.testDatesV4", "method_implementation": "{\n    ClassLoader classLoader = this.getClass().getClassLoader();\n    String file4 = classLoader.getResource(\"org/biojava/nbio/structure/io/mmcif/1stp_v4.cif\").getPath();\n    Structure s = StructureIO.getStructure(file4);\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.US);\n    Date modDate = dateFormat.parse(\"2011-07-13\");\n    assertEquals(modDate, s.getPDBHeader().getModDate());\n    Date releaseDate = dateFormat.parse(\"1992-10-15\");\n    assertEquals(releaseDate, s.getPDBHeader().getRelDate());\n    Date depositionDate = dateFormat.parse(\"1992-03-12\");\n    assertEquals(depositionDate, s.getPDBHeader().getDepDate());\n}", "repo_id": "9", "comment": "/**\n * Test parsing dates from MMCIF file version 4.\n */\n", "repo_name": "biojava-master/", "id": 2223, "method_signature": "void testDatesV4()"}, "2467": {"callee_method_ids": [2408, 2407], "callee_method_names": ["Location.suffix", "Location.prefix"], "method_name": "LocIterator.remainder", "method_implementation": "{\n    Location remainder = null;\n    if (mPosition == 0) {\n        remainder = mBounds;\n    } else {\n        if (mIncrement > 0) {\n            remainder = mBounds.suffix(mPosition);\n        } else {\n            remainder = mBounds.prefix(mPosition);\n        }\n    }\n    return remainder;\n}", "repo_id": "9", "comment": "/**\n * Get portion of bounding location that has not yet been retrieved by next() method.\n *\n * @return The location not yet retrieved.\n */\n", "repo_name": "biojava-master/", "id": 2467, "method_signature": "Location remainder()"}, "2471": {"callee_method_names": [], "method_name": "LocIterator.remove", "method_implementation": "{\n    throw new UnsupportedOperationException();\n}", "repo_id": "9", "comment": "/**\n * Unsupported.\n *\n * @throws UnsupportedOperationException\n */\n", "repo_name": "biojava-master/", "id": 2471, "method_signature": "void remove()"}, "999": {"callee_method_ids": [997], "callee_method_names": ["GetDistanceMatrix.getDistanceMatrix", "Atom[].getGroup", "Domain.setId", "Chain.getStructure", "Chain.getId", "Domain.setSize", "Domain.setNseg", "Domain.getSegmentAtPos", "Domain.getSegmentAtPos", "CutDomain.cutDomain", "CutDomain.getDomains"], "method_name": "LocalProteinDomainParser.suggestDomains", "method_implementation": "{\n    GetDistanceMatrix distMaxCalculator = new GetDistanceMatrix();\n    PDPDistanceMatrix pdpMatrix = distMaxCalculator.getDistanceMatrix(ca);\n    Domain dom = new Domain();\n    Chain c = ca[0].getGroup().getChain();\n    dom.setId(\"D\" + c.getStructure().getPDBCode() + c.getId() + \"1\");\n    dom.setSize(ca.length);\n    dom.setNseg(1);\n    dom.getSegmentAtPos(0).setFrom(0);\n    dom.getSegmentAtPos(0).setTo(ca.length - 1);\n    CutSites cutSites = new CutSites();\n    // Do the initial splitting\n    CutDomain cutDomain = new CutDomain(ca, pdpMatrix);\n    cutDomain.cutDomain(dom, cutSites, pdpMatrix);\n    List<Domain> domains = cutDomain.getDomains();\n    //\n    domains = ClusterDomains.cluster(domains, pdpMatrix);\n    ShortSegmentRemover.cleanup(domains);\n    return domains;\n}", "repo_id": "9", "comment": "/**\n * Suggest domains for a set of Calpha atoms\n *\n * @param ca an array of Calpha atoms\n * @return a list of possible domains\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 999, "method_signature": "List<Domain> suggestDomains(Atom[])"}, "809": {"callee_method_names": ["StrucAligParameters.getGapOpen", "StrucAligParameters.getGapExtension", "Matrix.getRowDimension", "Matrix.getColumnDimension", "Alignable.setGapExtCol", "Alignable.setGapExtRow", "Alignable.setGapOpenCol", "Alignable.setGapOpenRow", "Alignable.getAligMat", "Matrix.get", "AligMatEl.setValue"], "method_name": "AligNPE.align_NPE", "method_implementation": "{\n    //System.out.println(\"align_NPE\");\n    float gapOpen = params.getGapOpen();\n    float gapExtension = params.getGapExtension();\n    int rows = sim.getRowDimension();\n    int cols = sim.getColumnDimension();\n    Alignable al = new StrCompAlignment(rows, cols);\n    al.setGapExtCol(gapExtension);\n    al.setGapExtRow(gapExtension);\n    al.setGapOpenCol(gapOpen);\n    al.setGapOpenRow(gapOpen);\n    //System.out.println(\"size of aligmat: \" + rows+1 + \" \" + cols+1);\n    //AligMatEl[][] aligmat = new AligMatEl[rows+1][cols+1];\n    AligMatEl[][] aligmat = al.getAligMat();\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int e = 0;\n            //if ( ( i < rows) &&\n            //        ( j < cols)) {\n            //TODO: the ALIGFACTOR calc should be hidden in Gotoh!!\n            e = (int) Math.round(Gotoh.ALIGFACTOR * sim.get(i, j));\n            //}\n            //System.out.println(e);\n            AligMatEl am = new AligMatEl();\n            am.setValue(e);\n            //am.setTrack(new IndexPair((short)-99,(short)-99));\n            aligmat[i + 1][j + 1] = am;\n        }\n    }\n    //al.setAligMat(aligmat);\n    new Gotoh(al);\n    return al;\n}", "repo_id": "9", "comment": "/**\n * Align without penalizing end-gaps. Return alignment and score\n *\n * @param sim the similarity matrix\n * @param params the structure alignment parameters to be used\n * @return an Alignable\n */\n", "repo_name": "biojava-master/", "id": 809, "method_signature": "Alignable align_NPE(Matrix, StrucAligParameters)"}, "3036": {"callee_method_names": ["List<Location>.add", "List<Location>.add", "List<Location>.add"], "method_name": "Tools.circularLocation", "method_implementation": "{\n    int min = Math.min(start, end);\n    int max = Math.max(start, end);\n    //Tells us we're dealing with something that's not _right_\n    boolean isReverse = (min != start);\n    if (min > length) {\n        throw new IllegalArgumentException(\"Cannot process a \" + \"location whose lowest coordinate is less than \" + \"the given length \" + length);\n    }\n    //If max positon was less than length the return a normal location\n    if (max <= length) {\n        return location(start, end, strand, length);\n    }\n    //Fine for forward coords (i..e start < end)\n    int modStart = modulateCircularIndex(start, length);\n    int modEnd = modulateCircularIndex(end, length);\n    int numberOfPasses = completeCircularPasses(Math.max(start, end), length);\n    if (isReverse) {\n        int reversedModStart = new SimplePoint(modStart).reverse(length).getPosition();\n        int reversedModEnd = new SimplePoint(modEnd).reverse(length).getPosition();\n        modStart = reversedModStart;\n        modEnd = reversedModEnd;\n        start = reversedModStart;\n        //+1 to number of passes to skip the run encoded by the start\n        end = (length * (numberOfPasses + 1)) + modEnd;\n    }\n    List<Location> locations = new ArrayList<Location>();\n    locations.add(new SimpleLocation(modStart, length, strand));\n    for (int i = 0; i < numberOfPasses; i++) {\n        locations.add(new SimpleLocation(1, length, strand));\n    }\n    locations.add(new SimpleLocation(1, modEnd, strand));\n    return new SimpleLocation(new SimplePoint(start), new SimplePoint(end), strand, true, false, locations);\n}", "repo_id": "9", "comment": "/**\n * Converts a location which defines the outer bounds of a circular\n * location and splits it into the required portions. Unlike any\n * other location builder this allows you to express your input\n * location on the reverse strand\n *\n * @param location The location which currently expresses the outer\n * bounds of a circular location.\n * @param length The length of the circular genomic unit\n * @return The circular location; can optionally return a normal non\n * circular location if the one you give is within the bounds of\n * the length\n */\n", "repo_name": "biojava-master/", "id": 3036, "method_signature": "Location circularLocation(int, int, Strand, int)"}, "2206": {"callee_method_names": ["ResidueNumber.hashCode"], "method_name": "ResidueNumberTest.testHashCode", "method_implementation": "{\n    //        System.out.println(\"hashCode\");\n    ResidueNumber instance = new ResidueNumber(\"A\", 42, ' ');\n    int expResult = 93290;\n    int result = instance.hashCode();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of hashCode method, of class ResidueNumber.\n */\n", "repo_name": "biojava-master/", "id": 2206, "method_signature": "void testHashCode()"}, "1164": {"callee_method_ids": [1317], "callee_method_names": ["FileParsingParameters.isHeaderOnly", "String.length", "Logger.info", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "List<Map<String, String>>.add"], "method_name": "PDBFileParser.pdb_HELIX_Handler", "method_implementation": "{\n    if (params.isHeaderOnly())\n        return;\n    if (line.length() < 38) {\n        logger.info(\"HELIX line has length under 38. Ignoring it.\");\n        return;\n    }\n    String initResName = line.substring(15, 18).trim();\n    String initChainId = line.substring(19, 20);\n    String initSeqNum = line.substring(21, 25).trim();\n    String initICode = line.substring(25, 26);\n    String endResName = line.substring(27, 30).trim();\n    String endChainId = line.substring(31, 32);\n    String endSeqNum = line.substring(33, 37).trim();\n    String endICode = line.substring(37, 38);\n    //System.out.println(initResName + \" \" + initChainId + \" \" + initSeqNum + \" \" + initICode + \" \" +\n    //        endResName + \" \" + endChainId + \" \" + endSeqNum + \" \" + endICode);\n    Map<String, String> m = new HashMap<String, String>();\n    m.put(\"initResName\", initResName);\n    m.put(\"initChainId\", initChainId);\n    m.put(\"initSeqNum\", initSeqNum);\n    m.put(\"initICode\", initICode);\n    m.put(\"endResName\", endResName);\n    m.put(\"endChainId\", endChainId);\n    m.put(\"endSeqNum\", endSeqNum);\n    m.put(\"endICode\", endICode);\n    helixList.add(m);\n}", "repo_id": "9", "comment": "/**\n * Parses the following record:\n *\n * <pre>\n * COLUMNS       DATA TYPE        FIELD        DEFINITION\n * --------------------------------------------------------------------\n *  1 -  6       Record name      \"HELIX \"\n *  8 - 10       Integer          serNum       Serial number of the helix.\n *                                             This starts at 1 and increases\n *                                             incrementally.\n * 12 - 14       LString(3)       helixID      Helix identifier. In addition\n *                                             to a serial number, each helix is\n *                                             given an alphanumeric character\n *                                             helix identifier.\n * 16 - 18       Residue name     initResName  Name of the initial residue.\n * 20            Character        initChainID  Chain identifier for the chain\n *                                             containing this helix.\n * 22 - 25       Integer          initSeqNum   Sequence number of the initial\n *                                             residue.\n * 26            AChar            initICode    Insertion code of the initial\n *                                             residue.\n * 28 - 30       Residue name     endResName   Name of the terminal residue of\n *                                             the helix.\n * 32            Character        endChainID   Chain identifier for the chain\n *                                             containing this helix.\n * 34 - 37       Integer          endSeqNum    Sequence number of the terminal\n *                                             residue.\n * 38            AChar            endICode     Insertion code of the terminal\n *                                             residue.\n * 39 - 40       Integer          helixClass   Helix class (see below).\n * 41 - 70       String           comment      Comment about this helix.\n * 72 - 76       Integer          length       Length of this helix.\n * </pre>\n */\n", "repo_name": "biojava-master/", "id": 1164, "method_signature": "void pdb_HELIX_Handler(String)"}, "250": {"callee_method_names": ["Map<String, Set<ProteinModification>>.get"], "method_name": "ProteinModificationRegistry.getByResidId", "method_implementation": "{\n    lazyInit();\n    return byResidId.get(residId);\n}", "repo_id": "9", "comment": "/**\n * @param residId RESID ID.\n * @return a set of ProteinModifications that have the RESID ID.\n */\n", "repo_name": "biojava-master/", "id": 250, "method_signature": "Set<ProteinModification> getByResidId(String)"}, "1636": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getSuperpositionAlgorithm", "method_implementation": "{\n    return superpositionAlgorithm;\n}", "repo_id": "9", "comment": "/**\n * Method to superpose subunits (i.e., structural aligner).\n *\n * @return superpositionAlgorithm\n */\n", "repo_name": "biojava-master/", "id": 1636, "method_signature": "String getSuperpositionAlgorithm()"}, "2644": {"callee_method_names": [], "method_name": "TaxonomyID.getID", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * @return the id\n */\n", "repo_name": "biojava-master/", "id": 2644, "method_signature": "String getID()"}, "2039": {"callee_method_names": ["AFPChain.getBlockRotationMatrix", "Matrix.trace"], "method_name": "SymmetryTools.getAngle", "method_implementation": "{\n    Matrix rotation = afpChain.getBlockRotationMatrix()[0];\n    return Math.acos(rotation.trace() - 1) * 180 / Math.PI;\n}", "repo_id": "9", "comment": "/**\n * Returns the <em>magnitude</em> of the angle between the first and second\n * blocks of {@code afpChain}, measured in degrees. This is always a\n * positive value (unsigned).\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2039, "method_signature": "double getAngle(AFPChain, Atom[], Atom[])"}, "1111": {"callee_method_names": ["BufferedReader.readLine", "String.isEmpty", "String.startsWith", "String.startsWith", "String.split", "SiftsChainToUniprotMapping.put", "SiftsChainToUniprotMapping.put", "BufferedReader.close"], "method_name": "SiftsChainToUniprotMapping.build", "method_implementation": "{\n    SiftsChainToUniprotMapping sifts = new SiftsChainToUniprotMapping();\n    BufferedReader br = new BufferedReader(new FileReader(DEFAULT_FILE));\n    String line = \"\";\n    while ((line = br.readLine()) != null) {\n        if (line.isEmpty() || line.startsWith(\"#\") || line.startsWith(\"PDB\"))\n            continue;\n        String[] parts = line.split(\"\\t\");\n        String pdbId = parts[0];\n        String chainId = parts[1];\n        String uniProtId = parts[2];\n        String seqresStart = parts[3];\n        String seqresEnd = parts[4];\n        String pdbStart = parts[5];\n        String pdbEnd = parts[6];\n        String uniprotStart = parts[7];\n        String uniprotEnd = parts[8];\n        SiftsChainEntry entry = new SiftsChainEntry(pdbId, chainId, uniProtId, seqresStart, seqresEnd, pdbStart, pdbEnd, uniprotStart, uniprotEnd);\n        sifts.byChainId.put(pdbId + \".\" + chainId, entry);\n        sifts.byUniProtId.put(uniProtId, entry);\n    }\n    br.close();\n    return sifts;\n}", "repo_id": "9", "comment": "/**\n * Builds the mapping by reading SIFTS the tsv file set in {@link #DEFAULT_FILE} variable.\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1111, "method_signature": "SiftsChainToUniprotMapping build()"}, "278": {"callee_method_names": [], "method_name": "StructureUtil.getAtomDistance", "method_implementation": "{\n    double distance;\n    distance = Calc.getDistance(atom1, atom2);\n    return distance;\n}", "repo_id": "9", "comment": "/**\n * @param atom1 the first {@link Atom} in structure.\n * @param atom2 the second {@link Atom} in structure.\n * @return the distance between the two atoms in Angstrom.\n */\n", "repo_name": "biojava-master/", "id": 278, "method_signature": "double getAtomDistance(Atom, Atom)"}, "1499": {"callee_method_names": ["SuperPositionQuat.setCentered", "SuperPositionQuat.superposeAndTransform"], "method_name": "SuperPositions.superposeAndTransformAtOrigin", "method_implementation": "{\n    superposer.setCentered(true);\n    return superposer.superposeAndTransform(fixed, moved);\n}", "repo_id": "9", "comment": "/**\n * Use the {@link SuperPosition#superposeAndTransform(Point3d[], Point3d[])}\n * method of the default static SuperPosition algorithm contained in this\n * Class, assuming that the point arrays are centered at the origin.\n */\n", "repo_name": "biojava-master/", "id": 1499, "method_signature": "Matrix4d superposeAndTransformAtOrigin(Point3d[], Point3d[])"}, "306": {"callee_method_names": ["ModifiedCompound.getModification", "Set<StructureGroup>.equals", "ModifiedCompound.getGroups"], "method_name": "ModifiedCompoundImpl.equals", "method_implementation": "{\n    if (!(obj instanceof ModifiedCompound)) {\n        return false;\n    }\n    ModifiedCompound mci = (ModifiedCompound) obj;\n    if (mci.getModification() != originalModification) {\n        return false;\n    }\n    if (!groups.equals(mci.getGroups())) {\n        return false;\n    }\n    return true;\n    // Do not need to consider linkage, since they can be determined by\n    // modification and groups.\n}", "repo_id": "9", "comment": "/**\n * @return true if same modification and same components; false, otherwise.\n */\n", "repo_name": "biojava-master/", "id": 306, "method_signature": "boolean equals(Object)"}, "3212": {"callee_method_names": [], "method_name": "SoftHashMapTest.large", "method_implementation": "{\n    return new TestObject(name, 100_000);\n}", "repo_id": "9", "comment": "/*\n        *Create a test object occupying significant memory(100kB)\n        */\n", "repo_name": "biojava-master/", "id": 3212, "method_signature": "TestObject large(String)"}, "3180": {"callee_method_names": ["LinkedHashMap.remove"], "method_name": "ChromosomeSequence.removeGeneSequence", "method_implementation": "{\n    return geneSequenceHashMap.remove(accession);\n}", "repo_id": "9", "comment": "/**\n * @param accession\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3180, "method_signature": "GeneSequence removeGeneSequence(String)"}, "2432": {"callee_method_names": [], "method_name": "FeatureList.bounds", "method_implementation": "{\n    return mLocation;\n}", "repo_id": "9", "comment": "/**\n * The union of all locations of all features in this list, mapped to the positive strand.\n * If an added feature is on the negative strand, its positive strand image is added\n * to the union.\n * The bounding location is not updated when a feature is removed from the list, so\n * it is not guaranteed to be the minimal bounding location.\n *\n * @return A location that is the union of all feature locations in the list.\n */\n", "repo_name": "biojava-master/", "id": 2432, "method_signature": "Location bounds()"}, "3242": {"callee_method_names": ["MultipleAlignment.getEnsemble", "MultipleAlignment.getEnsemble", "JFrame.setTitle", "JFrame.setDefaultCloseOperation", "AlignmentTextPanel.setText", "JFrame.setJMenuBar", "JScrollPane.getViewport", "JScrollPane.getViewport", "JFrame.getContentPane", "JFrame.pack", "JFrame.setVisible"], "method_name": "MultipleAlignmentJmolDisplay.showAlignmentImage", "method_implementation": "{\n    JFrame frame = new JFrame();\n    String title = multAln.getEnsemble().getAlgorithmName() + \" V.\" + multAln.getEnsemble().getVersion();\n    frame.setTitle(title);\n    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n    AlignmentTextPanel txtPanel = new AlignmentTextPanel();\n    txtPanel.setText(result);\n    JMenuBar menu = MenuCreator.getAlignmentTextMenu(frame, txtPanel, null, multAln);\n    frame.setJMenuBar(menu);\n    JScrollPane js = new JScrollPane();\n    js.getViewport().add(txtPanel);\n    js.getViewport().setBorder(null);\n    frame.getContentPane().add(js);\n    frame.pack();\n    frame.setVisible(true);\n}", "repo_id": "9", "comment": "/**\n * Creates a new Frame with the String output representation of the\n * {@link MultipleAlignment}.\n *\n * @param multAln\n * @param result String output\n */\n", "repo_name": "biojava-master/", "id": 3242, "method_signature": "void showAlignmentImage(MultipleAlignment, String)"}, "1537": {"callee_method_names": [], "method_name": "Astral.getRepresentatives", "method_implementation": "{\n    return getRepresentatives(AstralSet.parse(id));\n}", "repo_id": "9", "comment": "/**\n * Get a list of representatives' names for the specified ASTRAL cutoff.\n * @param id An ASTRAL Id, such as 1.75A_95.\n */\n", "repo_name": "biojava-master/", "id": 1537, "method_signature": "Set<String> getRepresentatives(String)"}, "2420": {"callee_method_names": [], "method_name": "Location.isBefore", "method_implementation": "{\n    if (isSameStrand(other)) {\n        return mEnd <= other.mStart;\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Check if this location is entirely before other location (no overlap).\n *\n * @param other The location to compare.\n * @return True if this is before other.\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2420, "method_signature": "boolean isBefore(Location)"}, "1462": {"callee_method_names": [], "method_name": "SpaceGroup.getTransfAlgebraic", "method_implementation": "{\n    return transfAlgebraic;\n}", "repo_id": "9", "comment": "//@XmlElement\n", "repo_name": "biojava-master/", "id": 1462, "method_signature": "List<String> getTransfAlgebraic()"}, "241": {"callee_method_names": [], "method_name": "Builder.setFormula", "method_implementation": "{\n    this.formula = formula;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the residue formula.\n * @param formula residue formula.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 241, "method_signature": "Builder setFormula(String)"}, "496": {"callee_method_names": [], "method_name": "AFPChain.setTotalRmsdIni", "method_implementation": "{\n    this.totalRmsdIni = totalRmsdIni;\n}", "repo_id": "9", "comment": "/**\n * this is the init-RMSD, not the final RMSD after refinement.\n *\n * @param totalRmsdIni\n */\n", "repo_name": "biojava-master/", "id": 496, "method_signature": "void setTotalRmsdIni(double)"}, "1082": {"callee_method_names": ["ChemComp.setOneLetterCode", "ChemComp.setThreeLetterCode", "ChemComp.setPolymerType", "ChemComp.setResidueType"], "method_name": "ChemComp.getEmptyChemComp", "method_implementation": "{\n    ChemComp comp = new ChemComp();\n    comp.setOneLetterCode(\"?\");\n    // Main signal for isEmpty()\n    comp.setThreeLetterCode(\"???\");\n    comp.setPolymerType(PolymerType.unknown);\n    comp.setResidueType(ResidueType.atomn);\n    return comp;\n}", "repo_id": "9", "comment": "/**\n * Creates a new instance of the dummy empty ChemComp.\n * @return a ChemComp\n */\n", "repo_name": "biojava-master/", "id": 1082, "method_signature": "ChemComp getEmptyChemComp()"}, "1083": {"callee_method_names": [], "method_name": "ChemComp.isEmpty", "method_implementation": "{\n    // Is this the best flag for it being empty?\n    return id == null || getThreeLetterCode() == null || \"???\".equals(getThreeLetterCode());\n}", "repo_id": "9", "comment": "/**\n * Indicates whether this compound was created with\n * @return a boolean\n */\n", "repo_name": "biojava-master/", "id": 1083, "method_signature": "boolean isEmpty()"}, "3681": {"callee_method_names": [], "method_name": "WaldTestInfo.getDf", "method_implementation": "{\n    return df;\n}", "repo_id": "9", "comment": "/**\n * @return the df\n */\n", "repo_name": "biojava-master/", "id": 3681, "method_signature": "int getDf()"}, "3344": {"callee_method_names": ["Color.getRed", "Color.getGreen", "Color.getBlue"], "method_name": "HSVColorSpace.fromRGB", "method_implementation": "{\n    assert (rgbvalue.length == 3);\n    Color rgbColor = new Color(rgbvalue[0], rgbvalue[1], rgbvalue[2]);\n    return Color.RGBtoHSB(rgbColor.getRed(), rgbColor.getGreen(), rgbColor.getBlue(), null);\n}", "repo_id": "9", "comment": "/**\n * @param rgbvalue\n * @return\n * @see java.awt.color.ColorSpace#fromRGB(float[])\n */\n", "repo_name": "biojava-master/", "id": 3344, "method_signature": "float[] fromRGB(float[])"}, "800": {"callee_method_names": [], "method_name": "CeStartupParams.setMaxOptRMSD", "method_implementation": "{\n    this.maxOptRMSD = maxOptRMSD;\n}", "repo_id": "9", "comment": "/**\n * (jCE specific): maximum RMSD that shall be calculated for the alignment.\n *\n * @param maxOptRMSD max RMSD to calculate\n */\n", "repo_name": "biojava-master/", "id": 800, "method_signature": "void setMaxOptRMSD(Double)"}, "2719": {"callee_method_names": [], "method_name": "BufferedReaderBytesRead.markSupported", "method_implementation": "{\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Tells whether this stream supports the mark() operation, which it does.\n */\n", "repo_name": "biojava-master/", "id": 2719, "method_signature": "boolean markSupported()"}, "982": {"callee_method_names": ["Map<String, Atom>.clear", "Atom.setGroup", "Map<String, Atom>.put", "Atom.getName", "List<Atom>.isEmpty"], "method_name": "HetatomImpl.setAtoms", "method_implementation": "{\n    // important we are resetting atoms to a new list, we need to reset the lookup too!\n    if (atomNameLookup != null)\n        atomNameLookup.clear();\n    for (Atom a : atoms) {\n        a.setGroup(this);\n        if (atomNameLookup != null)\n            atomNameLookup.put(a.getName(), a);\n    }\n    this.atoms = atoms;\n    if (!atoms.isEmpty()) {\n        pdb_flag = true;\n    }\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 982, "method_signature": "void setAtoms(List)"}, "2692": {"callee_method_names": [], "method_name": "Substitute.getEnd", "method_implementation": "{\n    if (getEnd() == -1) {\n        int start = getStart();\n        int length = getTargetSequence(sequence).getLength();\n        return (start + length) - 1;\n    }\n    return getEnd();\n}", "repo_id": "9", "comment": "/**\n * Must use this rather than the no-args getEnd as this can return\n * -1 and the length of a sub is dependent on the length of the\n * Sequence; we cannot assume 1:1 mapping between characters in a\n * String and the number of compounds we will have to insert.\n */\n", "repo_name": "biojava-master/", "id": 2692, "method_signature": "int getEnd(Sequence)"}, "3501": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.getBlastAdvancedOptions", "method_implementation": "{\n    return getAlignmentOption(OTHER_ADVANCED);\n}", "repo_id": "9", "comment": "/**\n * @return the String with the advanced options\n */\n", "repo_name": "biojava-master/", "id": 3501, "method_signature": "String getBlastAdvancedOptions()"}, "2875": {"callee_method_names": ["DataInputStream.readInt"], "method_name": "ABITrace.getIntAt", "method_implementation": "{\n    int out = 0;\n    byte[] temp = new byte[4];\n    getSubArray(temp, pointer);\n    try {\n        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(temp));\n        out = dis.readInt();\n    } catch (//This shouldn't happen. If it does something must be seriously wrong.\n    IOException e) {\n        throw new IllegalStateException(\"Unexpected IOException encountered while manipulating internal streams.\");\n    }\n    return out;\n}", "repo_id": "9", "comment": "/**\n * Utility method to return an int beginning at <code>pointer</code> in the TraceData array.\n *\n * @param pointer - beginning of trace array\n * @return - int beginning at pointer in trace array\n */\n", "repo_name": "biojava-master/", "id": 2875, "method_signature": "int getIntAt(int)"}, "1647": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setUseStructureCoverage", "method_implementation": "{\n    this.useStructureCoverage = useStructureCoverage;\n}", "repo_id": "9", "comment": "/**\n * Use structure coverage for evaluating sequence similarity\n *\n * @param useStructureCoverage\n */\n", "repo_name": "biojava-master/", "id": 1647, "method_signature": "void setUseStructureCoverage(boolean)"}, "3052": {"callee_method_names": ["Set<AccessionID>.add", "Path.getAccession", "Set<AccessionID>.size"], "method_name": "LocationHelper.consistentAccessions", "method_implementation": "{\n    Set<AccessionID> set = new HashSet<AccessionID>();\n    for (Location sub : subLocations) {\n        set.add(sub.getAccession());\n    }\n    return set.size() == 1;\n}", "repo_id": "9", "comment": "/**\n * Scans a list of locations and returns true if all the given locations\n * are linked to the same sequence. A list of null accessioned locations\n * is the same as a list where the accession is the same\n *\n * @param subLocations The locations to scan\n * @return Returns a boolean indicating if this is consistently accessioned\n */\n", "repo_name": "biojava-master/", "id": 3052, "method_signature": "boolean consistentAccessions(List)"}, "3462": {"callee_method_names": ["MouseEvent.getMessage"], "method_name": "NCBIQBlastService.init", "method_implementation": "{\n    try {\n        serviceUrl = new URL(svcUrl);\n    } catch (MalformedURLException e) {\n        throw new RuntimeException(\"It looks like the URL for remote NCBI BLAST service (\" + svcUrl + \") is wrong. Cause: \" + e.getMessage(), e);\n    }\n}", "repo_id": "9", "comment": "/**\n * Initialize the serviceUrl data member\n * @throws MalformedURLException on invalid URL\n */\n", "repo_name": "biojava-master/", "id": 3462, "method_signature": "void init(String)"}, "110": {"callee_method_names": ["Logger.info", "MultipleSequenceAlignment<C,D>.getSize", "MultipleSequenceAlignment<C,D>.getLength", "MultipleSequenceAlignment<C,D>.getAlignedSequence", "MultipleSequenceAlignment<C,D>.getAlignedSequences", "Logger.info", "String[].charAt", "String[].charAt", "SubstitutionMatrix<D>.getValue", "List<C>.get", "List<C>.get", "DistanceMatrix.setValue", "SubstitutionMatrix<D>.getMaxValue", "MultipleSequenceAlignment<C,D>.getLength", "SubstitutionMatrix<D>.getMaxValue", "SubstitutionMatrix<D>.getMinValue", "DistanceMatrix.setValue", "DistanceMatrix.setValue"], "method_name": "DistanceMatrixCalculator.fractionalDissimilarityScore", "method_implementation": "{\n    // Calculate the similarity scores using the alignment package\n    logger.info(\"{}:{}\", \"Determing Distances\", 0);\n    int n = msa.getSize();\n    DistanceMatrix DM = new BasicSymmetricalDistanceMatrix(n);\n    int totalloopcount = (n / 2) * (n + 1);\n    int end = msa.getLength();\n    String[] sequenceString = new String[n];\n    for (int i = 0; i < n; i++) {\n        sequenceString[i] = msa.getAlignedSequence(i + 1).getSequenceAsString();\n    }\n    List<C> seqs = msa.getAlignedSequences();\n    int loopcount = 0;\n    for (int i = 0; i < (n - 1); i++) {\n        logger.info(\"{}:{}\", \"Determining Distances\", (loopcount * 100) / totalloopcount);\n        // Obtain the similarity scores\n        for (int j = i; j < n; j++) {\n            double score = 0;\n            loopcount++;\n            for (int k = 0; k < end; k++) {\n                if (Comparison.isGap(sequenceString[i].charAt(k)) || Comparison.isGap(sequenceString[j].charAt(k)))\n                    continue;\n                score += M.getValue(seqs.get(i).getCompoundAt(k + 1), seqs.get(j).getCompoundAt(k + 1));\n            }\n            if (i == j)\n                DM.setValue(i, j, 0.0);\n            else {\n                double dS = (M.getMaxValue() - score / msa.getLength()) / (M.getMaxValue() - M.getMinValue());\n                DM.setValue(i, j, dS);\n                DM.setValue(j, i, dS);\n            }\n        }\n    }\n    return DM;\n}", "repo_id": "9", "comment": "/**\n * The fractional dissimilarity score (Ds) is a relative measure of the\n * dissimilarity between two aligned sequences. It is calculated as:\n *\n * <pre>\n * Ds = sum( max(M) - M<sub>ai,bi</sub> ) / (max(M)-min(M)) ) / L\n * </pre>\n *\n * Where the sum through i runs for all the alignment positions, ai and bi\n * are the AA at position i in the first and second aligned sequences,\n * respectively, and L is the total length of the alignment (normalization).\n * <p>\n * The fractional dissimilarity score (Ds) is in the interval [0, 1], where\n * 0 means that the sequences are identical and 1 that the sequences are\n * completely different.\n * <p>\n * Gaps do not have a contribution to the similarity score calculation (gap\n * penalty = 0)\n *\n * @param msa\n *            MultipleSequenceAlignment\n * @param M\n *            SubstitutionMatrix for similarity scoring\n * @return DistanceMatrix\n */\n", "repo_name": "biojava-master/", "id": 110, "method_signature": "DistanceMatrix fractionalDissimilarityScore(MultipleSequenceAlignment, SubstitutionMatrix)"}, "2663": {"callee_method_names": [], "method_name": "Builder.decorateRna", "method_implementation": "{\n    this.decorateRna = decorateRna;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Performs an optimisation where RNASequences are not translated into\n * their own objects but are views onto the base DNA sequence.\n */\n", "repo_name": "biojava-master/", "id": 2663, "method_signature": "Builder decorateRna(boolean)"}, "227": {"callee_method_names": [], "method_name": "ProteinModificationImpl.setSystematicName", "method_implementation": "{\n    this.sysName = sysName;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the systematic name.\n * @param sysName systematic name.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 227, "method_signature": "Builder setSystematicName(String)"}, "1063": {"callee_method_names": ["String.substring"], "method_name": "CathDomain.getThePdbId", "method_implementation": "{\n    return domainName.substring(0, 4);\n}", "repo_id": "9", "comment": "/**\n * Returns the PDB ID.\n */\n", "repo_name": "biojava-master/", "id": 1063, "method_signature": "String getThePdbId()"}, "662": {"callee_method_names": ["Block.length", "Block.size", "Block.getAlignRes", "List<Integer>.add"], "method_name": "MultipleAlignmentTools.getCorePositions", "method_implementation": "{\n    List<Integer> corePositions = new ArrayList<Integer>();\n    for (int col = 0; col < block.length(); col++) {\n        boolean core = true;\n        for (int str = 0; str < block.size(); str++) {\n            if (block.getAlignRes().get(str).get(col) == null) {\n                core = false;\n                break;\n            }\n        }\n        if (core)\n            corePositions.add(col);\n    }\n    return corePositions;\n}", "repo_id": "9", "comment": "/**\n * Calculate a List of alignment indicies that correspond to the core of a\n * Block, which means that all structures have a residue in that positon.\n *\n * @param block\n *            alignment Block\n * @return List of positions in the core of the alignment\n */\n", "repo_name": "biojava-master/", "id": 662, "method_signature": "List<Integer> getCorePositions(Block)"}, "846": {"callee_method_names": ["SymbolTable<Integer, Double>.delete", "SymbolTable<Integer, Double>.put"], "method_name": "SparseVector.put", "method_implementation": "{\n    if (i < 0 || i >= N)\n        throw new IllegalArgumentException(\"Illegal index \" + i + \" should be > 0 and < \" + N);\n    if (value == 0.0)\n        symbolTable.delete(i);\n    else\n        symbolTable.put(i, value);\n}", "repo_id": "9", "comment": "/**\n * Setter method (should it be renamed to set?)\n *\n * @param i set symbolTable[i]\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 846, "method_signature": "void put(int, double)"}, "2580": {"callee_method_names": ["Logger.debug"], "method_name": "SingleLinkageClusterer.clusterIt", "method_implementation": "{\n    dendrogram = new LinkedPair[numItems - 1];\n    logger.debug(\"Initial matrix: \\n{}\", matrixToString());\n    for (int m = 0; m < numItems - 1; m++) {\n        updateIndicesToCheck(m);\n        LinkedPair pair = getClosestPair();\n        merge(pair);\n        dendrogram[m] = pair;\n        //if (debug) {\n        //\tSystem.out.println(\"Matrix after iteration \"+m+\" (merged \"+pair.getFirst()+\",\"+pair.getSecond()+\")\");\n        //\tprintMatrix();\n        //}\n    }\n}", "repo_id": "9", "comment": "/**\n * Calculate the hierarchical clustering and store it in dendrogram array\n * This is the naive implementation (o(n3)) of single linkage clustering as outlined in wikipedia:\n * http://en.wikipedia.org/wiki/Single-linkage_clustering\n */\n", "repo_name": "biojava-master/", "id": 2580, "method_signature": "void clusterIt()"}, "176": {"callee_method_ids": [1633], "callee_method_names": ["SubunitClustererParameters.setClustererMethod", "List<SubunitCluster>.size", "List<SubunitCluster>.get"], "method_name": "TestSubunitClustererExamples.testPTMs", "method_implementation": "{\n    Structure s = StructureIO.getStructure(\"1hiv\");\n    SubunitClustererParameters params = new SubunitClustererParameters();\n    params.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n    List<SubunitCluster> clusters = SubunitClusterer.cluster(s, params).getClusters();\n    // We expect a single cluster with length 99\n    assertEquals(clusters.size(), 1);\n    assertEquals(clusters.get(0).length(), 99);\n}", "repo_id": "9", "comment": "/**\n * Test modified residues: 1HIV\n */\n", "repo_name": "biojava-master/", "id": 176, "method_signature": "void testPTMs()"}, "406": {"callee_method_names": [], "method_name": "GroupIterator.remove", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Cannot call remove() for GroupIterator\");\n}", "repo_id": "9", "comment": "/**\n * does nothing .\n */\n", "repo_name": "biojava-master/", "id": 406, "method_signature": "void remove()"}, "479": {"callee_method_names": [], "method_name": "AFPChain.getCoverage2", "method_implementation": "{\n    if (myResultsSimilarity2 < 0) {\n        int distance = ca1Length + ca2Length - 2 * getNrEQR();\n        int similarity = (ca1Length + ca2Length - distance) / 2;\n        myResultsSimilarity2 = Math.round(similarity / (float) ca2Length * 100);\n    }\n    return myResultsSimilarity2;\n}", "repo_id": "9", "comment": "/**\n * Get the coverage of protein 2 with the alignment\n *\n * @return percentage of coverage, between 0 and 100.\n */\n", "repo_name": "biojava-master/", "id": 479, "method_signature": "int getCoverage2()"}, "634": {"callee_method_names": [], "method_name": "AtomCache.setCachePath", "method_implementation": "{\n    this.cachePath = cachePath;\n}", "repo_id": "9", "comment": "/**\n * set the location at which utility data should be cached.\n *\n * @param cachePath\n */\n", "repo_name": "biojava-master/", "id": 634, "method_signature": "void setCachePath(String)"}, "3086": {"callee_method_names": [], "method_name": "AbstractFeature.getChildrenFeatures", "method_implementation": "{\n    return childrenFeatures;\n}", "repo_id": "9", "comment": "/**\n * Get the children features\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3086, "method_signature": "List<FeatureInterface<S,C>> getChildrenFeatures()"}, "2541": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getReader", "method_implementation": "{\n    String resourcePathPrefix = \"matrices/\";\n    InputStream is = SubstitutionMatrixHelper.class.getResourceAsStream(String.format(\"/%s.txt\", resourcePathPrefix + file));\n    if (is == null) {\n        return null;\n    }\n    return new InputStreamReader(is);\n}", "repo_id": "9", "comment": "// reads in a substitution matrix from a resource file\n", "repo_name": "biojava-master/", "id": 2541, "method_signature": "InputStreamReader getReader(String)"}, "1700": {"callee_method_names": [], "method_name": "AtomImpl.getElement", "method_implementation": "{\n    return element;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1700, "method_signature": "Element getElement()"}, "1564": {"callee_method_names": ["HashMap.get", "Logger.info", "BerkeleyScopInstallation.setScopVersion", "HashMap.put"], "method_name": "ScopFactory.getSCOP", "method_implementation": "{\n    if (version == null) {\n        version = defaultVersion;\n    }\n    ScopDatabase scop = versionedScopDBs.get(version);\n    if (scop == null) {\n        // Use a local installation\n        logger.info(\"Creating new {}, version {}\", BerkeleyScopInstallation.class.getSimpleName(), version);\n        BerkeleyScopInstallation berkeley = new BerkeleyScopInstallation();\n        berkeley.setScopVersion(version);\n        versionedScopDBs.put(version, berkeley);\n        return berkeley;\n    }\n    return scop;\n}", "repo_id": "9", "comment": "/**\n * Gets an instance of the specified scop version.\n *\n * <p>\n * The particular implementation returned is guaranteed to\n * implement {@link LocalScopDatabase} (generally a {@link BerkeleyScopInstallation}).\n *\n * @param version A version number, such as {@link #VERSION_1_75A}\n * @return an\n */\n", "repo_name": "biojava-master/", "id": 1564, "method_signature": "ScopDatabase getSCOP(String)"}, "2325": {"callee_method_names": ["Structure.getEntityInfos", "List<EntityInfo>.size", "List<EntityInfo>.get", "EntityInfo.getDescription"], "method_name": "PdbFileFormat30Test.testRead30File", "method_implementation": "{\n    Structure s = getStructure(\"/388d_v30.pdb\");\n    int nrNuc = getNrNucleotides(s);\n    // there are 4 nucleotides less in the new version\n    // some chemically modified nucleotides residues have been declared to be HETATOMS\n    int shouldNr = 20;\n    assertEquals(\"structure does not contain the right number of nucleotides \", shouldNr, nrNuc);\n    List<EntityInfo> compounds = s.getEntityInfos();\n    // from Biojava 5.0 on we are creating entities whenever an entity is found to be without an assigned compound\n    // in the file, for polymer entities, nonpolymer entities and water entities.\n    // For this file: 1 dna polymeric entity, 1 MG nonpolymeric entity, 1 water\n    // see issues https://github.com/biojava/biojava/issues/305 and https://github.com/biojava/biojava/pull/394\n    assertEquals(3, compounds.size());\n    EntityInfo mol = compounds.get(0);\n    assertTrue(mol.getDescription().startsWith(\"DNA\"));\n    Structure s2 = getStructure(\"/104D_v30.pdb\");\n    int nrNuc2 = getNrNucleotides(s2);\n    int shouldNr2 = 24;\n    assertEquals(\"structure does not contain the right number of nucleotides \", shouldNr2, nrNuc2);\n}", "repo_id": "9", "comment": "/**\n * There is a file format change in v3.0 of the PDB file format\n * this test makes sure that the atom name changes are being processed correctly\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2325, "method_signature": "void testRead30File()"}, "3521": {"callee_method_names": [], "method_name": "StrataInfo.getNevent", "method_implementation": "{\n    return nevent;\n}", "repo_id": "9", "comment": "/**\n * @return the nevent\n */\n", "repo_name": "biojava-master/", "id": 3521, "method_signature": "ArrayList<Double> getNevent()"}, "2008": {"callee_method_names": [], "method_name": "Tetrahedron.setCirumscribedRadius", "method_implementation": "{\n    this.circumscribedRadius = cirumscribedRadius;\n}", "repo_id": "9", "comment": "/**\n * Set the radius of a circumscribed sphere, that goes\n * through all vertices\n * @param cirumscribedRadius the cirumscribedRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2008, "method_signature": "void setCirumscribedRadius(double)"}, "27": {"callee_method_names": [], "method_name": "StockholmStructure.addGSdbReference", "method_implementation": "{\n    getSequenceAnnotation(seqName).addDBReference(text);\n}", "repo_id": "9", "comment": "/**\n * @param seqName\n * @param text\n */\n", "repo_name": "biojava-master/", "id": 27, "method_signature": "void addGSdbReference(String, String)"}, "3865": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getApliphaticIndex"], "method_name": "PeptideProperties.getApliphaticIndex", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getApliphaticIndex(pSequence);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the apliphatic index of sequence. The sequence argument must be a\n * protein sequence consisting of only non-ambiguous characters.\n * The aliphatic index of a protein is defined as the relative volume\n * occupied by aliphatic side chains (alanine, valine, isoleucine, and\n * leucine). It may be regarded as a positive factor for the increase of\n * thermostability of globular proteins. The computation of aliphatic index\n * follows the documentation in <a href=\"http://web.expasy.org/protparam/protparam-doc.html\">here</a>.\n * A protein whose instability index is smaller than 40 is predicted as stable, a value above 40 predicts that the protein may be unstable.\n *\n * @param sequence\n * \t\ta protein sequence consisting of non-ambiguous characters only\n * @return the aliphatic index of sequence\n */\n", "repo_name": "biojava-master/", "id": 3865, "method_signature": "double getApliphaticIndex(String)"}, "3597": {"callee_method_names": [], "method_name": "CoxCC.main", "method_implementation": "{\n    // TODO code application logic here\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3597, "method_signature": "void main(String[])"}, "3185": {"callee_method_names": [], "method_name": "WindowedSequence.toStartIndex", "method_implementation": "{\n    return ((index - 1) * getWindowSize()) + 1;\n}", "repo_id": "9", "comment": "/**\n * Calculates start index according to the equation start = ( (index-1) -\n * windowSize) +1\n */\n", "repo_name": "biojava-master/", "id": 3185, "method_signature": "int toStartIndex(int)"}, "1702": {"callee_method_names": [], "method_name": "AtomImpl.getBonds", "method_implementation": "{\n    return bonds;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1702, "method_signature": "List<Bond> getBonds()"}, "3747": {"callee_method_ids": [3698], "callee_method_names": ["LinkedHashMap.get", "HeaderInfo.getIndex"], "method_name": "WorkSheet.getColumnIndex", "method_implementation": "{\n    HeaderInfo headerInfo = columnLookup.get(column);\n    if (headerInfo == null) {\n        throw new Exception(\"Column \" + column + \" not found\");\n    }\n    return headerInfo.getIndex();\n}", "repo_id": "9", "comment": "/**\n * @param column\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3747, "method_signature": "Integer getColumnIndex(String)"}, "328": {"callee_method_ids": [330], "callee_method_names": ["OboParser.parseOBO", "Ontology.getTerms", "Set<Term>.iterator", "Iterator<Term>.hasNext", "Iterator<Term>.next", "Logger.info", "Term.getName", "Term.getDescription", "Logger.error"], "method_name": "ParseGO.main", "method_implementation": "{\n    OboParser parser = new OboParser();\n    try (InputStream inStream = OboParser.class.getResourceAsStream(\"/ontology/biosapiens.obo\");\n        BufferedReader oboFile = new BufferedReader(new InputStreamReader(inStream))) {\n        Ontology ontology = parser.parseOBO(oboFile, \"BioSapiens\", \"the BioSapiens ontology\");\n        Set<Term> keys = ontology.getTerms();\n        Iterator<Term> iter = keys.iterator();\n        while (iter.hasNext()) {\n            Term t = iter.next();\n            logger.info(\"{} [{}]\", t.getName(), t.getDescription());\n        }\n    } catch (Exception e) {\n        logger.error(\"Exception: \" + e);\n        System.exit(1);\n    }\n}", "repo_id": "9", "comment": "/**\n * Parses Biosapiens OBO file and logs name/description at INFO level\n *\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 328, "method_signature": "void main(String[])"}, "1770": {"callee_method_names": [], "method_name": "PDBHeader.setDepDate", "method_implementation": "{\n    this.depDate = depDate;\n}", "repo_id": "9", "comment": "/**\n * The deposition date of the structure in the PDB\n *\n * @param depDate the deposition date\n */\n", "repo_name": "biojava-master/", "id": 1770, "method_signature": "void setDepDate(Date)"}, "1890": {"callee_method_names": ["ArrayList.size"], "method_name": "Stoichiometry.numberOfComponents", "method_implementation": "{\n    return orderedClusters.size();\n}", "repo_id": "9", "comment": "/**\n * @return Number of distinct components in this stoichiometry.\n */\n", "repo_name": "biojava-master/", "id": 1890, "method_signature": "int numberOfComponents()"}, "1924": {"callee_method_names": [], "method_name": "QuatSymmetryResults.getSubunits", "method_implementation": "{\n    return Collections.unmodifiableList(subunits);\n}", "repo_id": "9", "comment": "/**\n * Returns the List of Subunits used to calculate symmetry.\n *\n * @return an unmodifiable view of the List\n */\n", "repo_name": "biojava-master/", "id": 1924, "method_signature": "List<Subunit> getSubunits()"}, "1407": {"callee_method_names": ["CrystalCell.getAlpha"], "method_name": "PDBCrystallographicInfo.getAlpha", "method_implementation": "{\n    return (float) cell.getAlpha();\n}", "repo_id": "9", "comment": "/**\n * @return the unit cell parameter alpha (degrees)\n */\n", "repo_name": "biojava-master/", "id": 1407, "method_signature": "float getAlpha()"}, "2888": {"callee_method_names": ["Sequence<C>.getLength"], "method_name": "SequenceMixin.lastIndexOf", "method_implementation": "{\n    int index = indexOf(new ReversedSequenceView<C>(sequence), compound);\n    return (sequence.getLength() - index) + 1;\n}", "repo_id": "9", "comment": "/**\n * Performs a reversed linear search of the given Sequence by wrapping\n * it in a {@link ReversedSequenceView} and passing it into\n * {@link #indexOf(Sequence, Compound)}. We then inverse the index coming\n * out of it.\n */\n", "repo_name": "biojava-master/", "id": 2888, "method_signature": "int lastIndexOf(Sequence, C)"}, "3001": {"callee_method_names": [], "method_name": "BitSequenceReader.shiftBy", "method_implementation": "{\n    return (byte) (((index - 1) % compoundsPerDatatype()) * bitsPerCompound());\n}", "repo_id": "9", "comment": "/**\n * Convert from bio to 0 index, remainder & then multiply by 2\n * <ul>\n * <li>Using 2bit encoding and working with position 19</li>\n * <li>19 is the 3rd position in the second int</li>\n * <li>Means a shift of 4 into that int to get the right data out</li>\n * <li>Also must convert into the non-bio index</li>\n * <li>19 - 1 = 18</li>\n * <li>18 % compoundsPerDatatype() (16) = 2</li>\n * <li>2 * bits per compound (2) = 4</li>\n * </ul>\n */\n", "repo_name": "biojava-master/", "id": 3001, "method_signature": "byte shiftBy(int)"}, "2013": {"callee_method_names": ["Matrix3d.rotX", "Vector3d.sub", "Matrix3d.transform"], "method_name": "Tetrahedron.getVertices", "method_implementation": "{\n    double x = getSideLengthFromCircumscribedRadius(circumscribedRadius) / 2;\n    double z = x / Math.sqrt(2);\n    Point3d[] tetrahedron = new Point3d[4];\n    tetrahedron[0] = new Point3d(-x, 0, -z);\n    tetrahedron[1] = new Point3d(x, 0, -z);\n    tetrahedron[2] = new Point3d(0, -x, z);\n    tetrahedron[3] = new Point3d(0, x, z);\n    Point3d centroid = CalcPoint.centroid(tetrahedron);\n    // rotate tetrahedron to align one vertex with the +z axis\n    Matrix3d m = new Matrix3d();\n    m.rotX(0.5 * TETRAHEDRAL_ANGLE);\n    for (Point3d p : tetrahedron) {\n        p.sub(centroid);\n        m.transform(p);\n    }\n    return tetrahedron;\n}", "repo_id": "9", "comment": "/**\n * Returns the vertices of an n-fold polygon of given radius and center\n * @param n\n * @param radius\n * @param center\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2013, "method_signature": "Point3d[] getVertices()"}, "1514": {"callee_method_names": ["AxisAngle4d.set"], "method_name": "UnitQuaternions.angle", "method_implementation": "{\n    AxisAngle4d axis = new AxisAngle4d();\n    axis.set(q);\n    return axis.angle;\n}", "repo_id": "9", "comment": "/**\n * Calculate the rotation angle component of the input unit quaternion.\n *\n * @param q\n *            unit quaternion Quat4d\n * @return the angle in radians of the input quaternion\n */\n", "repo_name": "biojava-master/", "id": 1514, "method_signature": "double angle(Quat4d)"}, "3509": {"callee_method_names": [], "method_name": "AgScore.main", "method_implementation": "{\n    // TODO code application logic here\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3509, "method_signature": "void main(String[])"}, "3073": {"callee_method_names": [], "method_name": "GeneSequence.getIntronSequences", "method_implementation": "{\n    return new ArrayList<>(intronSequenceList);\n}", "repo_id": "9", "comment": "/**\n * Get the introns as an ArrayList. Modifying this list will not modify the underlying collection\n * @return introns\n */\n", "repo_name": "biojava-master/", "id": 3073, "method_signature": "ArrayList<IntronSequence> getIntronSequences()"}, "180": {"callee_method_names": ["EcodDatabase.getVersion", "Matcher.matches", "Matcher.group", "List<Integer>.contains", "List<String>.add"], "method_name": "EcodInstallationTest.getKnownEcodVersions", "method_implementation": "{\n    // Parse version from latest.\n    int latestVersion = DEVELOP_LATEST_VERSION;\n    try {\n        EcodDatabase latest = EcodFactory.getEcodDatabase(EcodFactory.DEFAULT_VERSION);\n        String latestVersionStr;\n        latestVersionStr = latest.getVersion();\n        Matcher match = Pattern.compile(\"develop([0-9]+)\", Pattern.CASE_INSENSITIVE).matcher(latestVersionStr);\n        if (match.matches())\n            latestVersion = Integer.parseInt(match.group(1));\n        latest = null;\n    } catch (IOException e) {\n    }\n    latestVersion = Math.max(latestVersion, DEVELOP_LATEST_VERSION);\n    List<String> versions = new ArrayList<>(latestVersion - DEVELOP_FIRST_VERSION + 2);\n    for (int version = DEVELOP_FIRST_VERSION; version <= latestVersion; version++) {\n        if (!DEVELOP_VERSIONS_BLACKLIST.contains(version)) {\n            versions.add(\"develop\" + version);\n        }\n    }\n    return versions;\n}", "repo_id": "9", "comment": "/**\n * Get a list of all develop versions, generated based on the DEVELOP_*\n * static variables.\n * @return A list of all development versions: \"develop45\",\"develop46\",...\n */\n", "repo_name": "biojava-master/", "id": 180, "method_signature": "List<String> getKnownEcodVersions()"}, "3494": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.setBlastGapCosts", "method_implementation": "{\n    String gc = Integer.toString(gapCreation);\n    String ge = Integer.toString(gapExtension);\n    setAlignmentOption(GAPCOSTS, gc + \"+\" + ge);\n}", "repo_id": "9", "comment": "/**\n * Sets the GAPCOSTS parameter\n *\n * @param gapCreation integer to use as gap creation value\n * @param gapExtension integer to use as gap extension value\n */\n", "repo_name": "biojava-master/", "id": 3494, "method_signature": "void setBlastGapCosts(int, int)"}, "2815": {"callee_method_names": ["S.toString", "String.length", "String.charAt"], "method_name": "IOUtils.getGCGChecksum", "method_implementation": "{\n    String s = sequence.toString().toUpperCase();\n    int count = 0, check = 0;\n    for (int i = 0; i < s.length(); i++) {\n        count++;\n        check += count * s.charAt(i);\n        if (count == 57) {\n            count = 0;\n        }\n    }\n    return check % 10000;\n}", "repo_id": "9", "comment": "/**\n * Calculates GCG checksum for a given sequence\n *\n * @param sequence given sequence\n * @return GCG checksum\n */\n", "repo_name": "biojava-master/", "id": 2815, "method_signature": "int getGCGChecksum(S)"}, "2053": {"callee_method_ids": [507], "callee_method_names": ["AFPChain.getTMScore", "CESymmParameters.getUnrefinedScoreThreshold", "CESymmParameters.getRefineMethod", "MultipleAlignment.getCoreLength", "CESymmParameters.getMinCoreLength", "MultipleAlignment.getScore", "CESymmParameters.getRefinedScoreThreshold"], "method_name": "CeSymmResult.isSignificant", "method_implementation": "{\n    // In any case if the order is 1 it is asymmetric\n    if (numRepeats < 2)\n        return false;\n    // If the TM-Score before refinement is below the threshold\n    if (selfAlignment.getTMScore() < params.getUnrefinedScoreThreshold())\n        return false;\n    // If the refinement was attempted\n    if (params.getRefineMethod() != RefineMethod.NOT_REFINED) {\n        // Check for minimum length\n        if (multipleAlignment == null || multipleAlignment.getCoreLength() < params.getMinCoreLength())\n            return false;\n        // Allow 90% of original TM-Score theshold\n        if (multipleAlignment.getScore(MultipleAlignmentScorer.AVGTM_SCORE) < params.getRefinedScoreThreshold())\n            return false;\n        return true;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Conditions checked are: score above the threshold, number of repeats\n * higher than 1 and refinement succeeded.\n *\n * @return true if significant, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 2053, "method_signature": "boolean isSignificant()"}, "3273": {"callee_method_names": [], "method_name": "AbstractAlignmentJmol.getStructure", "method_implementation": "{\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * Return the current Structure in the AlignmentJmol instance.\n */\n", "repo_name": "biojava-master/", "id": 3273, "method_signature": "Structure getStructure()"}, "2338": {"callee_method_names": [], "method_name": "HelloWorld.print", "method_implementation": "{\n    System.out.println(\"Hello World!\");\n}", "repo_id": "9", "comment": "/**\n * Prints hello world on command line\n */\n", "repo_name": "biojava-master/", "id": 2338, "method_signature": "void print()"}, "1723": {"callee_method_names": [], "method_name": "BasePairParameters.checkArgument", "method_implementation": "{\n    if (bp < 0 || bp >= getPairingParameters().length)\n        throw new IllegalArgumentException(\"Base pair number is out of range.\");\n}", "repo_id": "9", "comment": "/**\n * This method is an internal test that the base pair specified is within a valid range.  If not, it throws an exception\n * with a message.\n * @param bp The index of the base pair or base-pair step to return.\n */\n", "repo_name": "biojava-master/", "id": 1723, "method_signature": "void checkArgument(int)"}, "3511": {"callee_method_names": [], "method_name": "Cholesky2.process", "method_implementation": "{\n    double temp;\n    int i, j, k;\n    double eps, pivot;\n    int rank;\n    int nonneg;\n    nonneg = 1;\n    eps = 0;\n    for (i = 0; i < n; i++) {\n        if (matrix[i][i] > eps) {\n            eps = matrix[i][i];\n        }\n        for (j = (i + 1); j < n; j++) {\n            matrix[j][i] = matrix[i][j];\n        }\n    }\n    eps *= toler;\n    rank = 0;\n    for (i = 0; i < n; i++) {\n        pivot = matrix[i][i];\n        if (pivot < eps) {\n            matrix[i][i] = 0;\n            if (pivot < -8 * eps) {\n                nonneg = -1;\n            }\n        } else {\n            rank++;\n            for (j = (i + 1); j < n; j++) {\n                temp = matrix[j][i] / pivot;\n                matrix[j][i] = temp;\n                matrix[j][j] -= temp * temp * pivot;\n                for (k = (j + 1); k < n; k++) {\n                    matrix[k][j] -= temp * matrix[k][i];\n                }\n            }\n        }\n    }\n    return (rank * nonneg);\n}", "repo_id": "9", "comment": "/**\n * @param matrix\n * @param n\n * @param toler\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3511, "method_signature": "int process(double[][], int, double)"}, "2785": {"callee_method_names": [], "method_name": "FastaWriter.setLineLength", "method_implementation": "{\n    this.lineLength = lineLength;\n}", "repo_id": "9", "comment": "/**\n * @param lineLength the lineLength to set\n */\n", "repo_name": "biojava-master/", "id": 2785, "method_signature": "void setLineLength(int)"}, "3134": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.countCompounds", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported yet.\");\n}", "repo_id": "9", "comment": "/**\n * @param compounds\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3134, "method_signature": "int countCompounds(C[])"}, "3634": {"callee_method_names": [], "method_name": "CoxInfo.setScoreLogrankTestpvalue", "method_implementation": "{\n    this.scoreLogrankTestpvalue = scoreLogrankTestpvalue;\n}", "repo_id": "9", "comment": "/**\n * @param scoreLogrankTestpvalue the scoreLogrankTestpvalue to set\n */\n", "repo_name": "biojava-master/", "id": 3634, "method_signature": "void setScoreLogrankTestpvalue(Double)"}, "3228": {"callee_method_ids": [2860, 2859, 2863, 2862, 2861, 2865], "callee_method_names": ["URL.toURI", "ABITrace.getTraceLength", "ABITrace.getSequenceLength", "String.equals", "ABITrace.getSequence", "ABITrace.getQcalls", "ABITrace.getBasecalls", "ABITrace.getImage"], "method_name": "ABITracerTest.testLocal", "method_implementation": "{\n    URL resource = this.getClass().getResource(\"/3730.ab1\");\n    File file = new File(resource.toURI());\n    assertNotNull(file);\n    ABITrace tracer = new ABITrace(file);\n    assertNotNull(tracer);\n    assertEquals(EXPECTED_TRACE_LENGTH, tracer.getTraceLength());\n    // Test length of sequence for file 3730.ab1\n    assertEquals(1165, tracer.getSequenceLength());\n    // Test sequence of tracer for file 3730.ab1\n    assertTrue(sequence.equals(tracer.getSequence().getSequenceAsString()));\n    // Test array that represents the quality of tracer for file 3730.ab1\n    assertArrayEquals(qual, tracer.getQcalls());\n    // Test array that represents the baseline of tracer for file 3730.ab1\n    assertArrayEquals(base, tracer.getBasecalls());\n    // Test image of tracer for file 3730.ab1\n    BufferedImage image = tracer.getImage(100, 100);\n    assertNotNull(image);\n}", "repo_id": "9", "comment": "/**\n * Test of Local file method, of class ABITracer.\n */\n", "repo_name": "biojava-master/", "id": 3228, "method_signature": "void testLocal()"}, "492": {"callee_method_names": [], "method_name": "AFPChain.getAlnLength", "method_implementation": "{\n    return alnLength;\n}", "repo_id": "9", "comment": "/**\n * @return The total length of the alignment, including gaps\n * @see #getOptLength(), the number of aligned residues in the final alignment.\n */\n", "repo_name": "biojava-master/", "id": 492, "method_signature": "int getAlnLength()"}, "1708": {"callee_method_names": [], "method_name": "BondImpl.getAtomB", "method_implementation": "{\n    return atomB;\n}", "repo_id": "9", "comment": "/**\n * Gets atom 'B' of this bond. There is no meaning to which atom is 'A' and\n * which is 'B'; the atoms are labeled 'A' or 'B' based on the order in\n * which they are passed to this class's constructor.\n *\n * @see #getAtomA()\n * @return one of the two atoms in this bond\n */\n", "repo_name": "biojava-master/", "id": 1708, "method_signature": "Atom getAtomB()"}, "495": {"callee_method_names": [], "method_name": "AFPChain.getTotalRmsdIni", "method_implementation": "{\n    return totalRmsdIni;\n}", "repo_id": "9", "comment": "/**\n * this is the init-RMSD, not the final RMSD after refinement.\n *\n * @return totalRmsdIni\n */\n", "repo_name": "biojava-master/", "id": 495, "method_signature": "double getTotalRmsdIni()"}, "1098": {"callee_method_names": ["ArrayList.contains", "File.exists", "Logger.info", "File.mkdir", "Logger.error", "File.toString"], "method_name": "DownloadChemCompProvider.getLocalFileName", "method_implementation": "{\n    if (protectedIDs.contains(recordName)) {\n        recordName = \"_\" + recordName;\n    }\n    File f = new File(getPath(), CHEM_COMP_CACHE_DIRECTORY);\n    if (!f.exists()) {\n        logger.info(\"Creating directory {}\", f);\n        boolean success = f.mkdir();\n        // we've checked in initPath that path is writable, so there's no need to check if it succeeds\n        // in the unlikely case that in the meantime it isn't writable at least we log an error\n        if (!success) {\n            logger.error(\"Directory {} could not be created\", f);\n        }\n    }\n    File theFile = new File(f, recordName + \".cif.gz\");\n    return theFile.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns the file name that contains the definition for this {@link ChemComp}\n *\n * @param recordName the ID of the {@link ChemComp}\n * @return full path to the file\n */\n", "repo_name": "biojava-master/", "id": 1098, "method_signature": "String getLocalFileName(String)"}, "1346": {"callee_method_names": [], "method_name": "EntityInfo.getMolId", "method_implementation": "{\n    return molId;\n}", "repo_id": "9", "comment": "/**\n * Return the molecule identifier, called entity_id in mmCIF dictionary.\n * @return the molecule id\n * @see #setMolId(int)\n */\n", "repo_name": "biojava-master/", "id": 1346, "method_signature": "int getMolId()"}, "941": {"callee_method_names": [], "method_name": "Grid.isNoOverlap", "method_implementation": "{\n    return noOverlap;\n}", "repo_id": "9", "comment": "/**\n * Tells whether (after having added atoms to grid) the i and j grids are not overlapping.\n * Overlap is defined as enclosing bounds of the 2 grids being no more than one cell size apart.\n * @return true if the 2 grids don't overlap, false if they do\n */\n", "repo_name": "biojava-master/", "id": 941, "method_signature": "boolean isNoOverlap()"}, "3785": {"callee_method_ids": [3784, 3795, 3789, 3811], "callee_method_names": ["SurvFitKM.process", "JFrame.setDefaultCloseOperation", "JFrame.add", "KaplanMeierFigure.setSize", "JFrame.setSize", "JFrame.setVisible", "ArrayList<String>.add", "ArrayList<String>.add", "KaplanMeierFigure.setSurvivalData", "KaplanMeierFigure.setFigureLineInfo", "KaplanMeierFigure.savePNG", "double[][].printStackTrace"], "method_name": "SurvFitKM.main", "method_implementation": "{\n    // TODO code application logic here\n    try {\n        String datafile = \"/Users/Scooter/scripps/ngs/BLJ/E2197/Predictive Signatures/V$HSF_Q6-E2197 TTR.txt\";\n        SurvFitKM survFitKM = new SurvFitKM();\n        SurvFitInfo si = survFitKM.process(datafile, \"TIME\", \"STATUS\", \"WEIGHT\", \"MEAN\", true);\n        if (true) {\n            KaplanMeierFigure kaplanMeierFigure = new KaplanMeierFigure();\n            JFrame application = new JFrame();\n            application.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            application.add(kaplanMeierFigure);\n            kaplanMeierFigure.setSize(500, 400);\n            // window is 500 pixels wide, 400 high\n            application.setSize(500, 400);\n            application.setVisible(true);\n            ArrayList<String> titles = new ArrayList<String>();\n            titles.add(\"Line 1\");\n            titles.add(\"line 2\");\n            kaplanMeierFigure.setSurvivalData(titles, si, null);\n            ArrayList<String> figureInfo = new ArrayList<String>();\n            //   figureInfo.add(\"HR=2.1 95% CI(1.8-2.5)\");\n            //   figureInfo.add(\"p-value=.001\");\n            kaplanMeierFigure.setFigureLineInfo(figureInfo);\n            kaplanMeierFigure.savePNG(\"/Users/Scooter/Downloads/test.png\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3785, "method_signature": "void main(String[])"}, "1095": {"callee_method_names": ["File.exists", "String.endsWith", "File.list", "Logger.error", "File.toString", "int.getMessage"], "method_name": "DownloadChemCompProvider.checkDoFirstInstall", "method_implementation": "{\n    if (!downloadAll) {\n        return;\n    }\n    // this makes sure there is a file separator between every component,\n    // if path has a trailing file separator or not, it will work for both cases\n    File dir = new File(getPath(), CHEM_COMP_CACHE_DIRECTORY);\n    File f = new File(dir, \"components.cif.gz\");\n    if (!f.exists()) {\n        downloadAllDefinitions();\n    } else {\n        // file exists.. did it get extracted?\n        FilenameFilter filter = (dir1, file) -> file.endsWith(\".cif.gz\");\n        String[] files = dir.list(filter);\n        if (files.length < 500) {\n            // not all did get unpacked\n            try {\n                split();\n            } catch (IOException e) {\n                logger.error(\"Could not split file {} into individual chemical component files. Error: {}\", f.toString(), e.getMessage());\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Checks if the chemical components already have been installed into the PDB directory.\n * If not, will download the chemical components definitions file and split it up into small\n * subfiles.\n */\n", "repo_name": "biojava-master/", "id": 1095, "method_signature": "void checkDoFirstInstall()"}, "2911": {"callee_method_names": [], "method_name": "AbstractSequence.setOriginalHeader", "method_implementation": "{\n    this.originalHeader = originalHeader;\n}", "repo_id": "9", "comment": "/**\n * @param originalHeader the originalHeader to set\n */\n", "repo_name": "biojava-master/", "id": 2911, "method_signature": "void setOriginalHeader(String)"}, "410": {"callee_method_names": [], "method_name": "FCAlignHelper.rep", "method_implementation": "{\n    // last = *sapp++ = 0;\n    last = sapp[(sappPos++)] = 0;\n}", "repo_id": "9", "comment": "//-----------------------------------------------------------------------------\n", "repo_name": "biojava-master/", "id": 410, "method_signature": "void rep()"}, "1361": {"callee_method_names": [], "method_name": "AminoAcidImpl.getRecordType", "method_implementation": "{\n    return recordType;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1361, "method_signature": "String getRecordType()"}, "1096": {"callee_method_names": ["PrintWriter.print", "PrintWriter.flush"], "method_name": "DownloadChemCompProvider.writeID", "method_implementation": "{\n    String localName = getLocalFileName(currentID);\n    try (PrintWriter pw = new PrintWriter(new GZIPOutputStream(new FileOutputStream(localName)))) {\n        pw.print(contents);\n        pw.flush();\n    }\n}", "repo_id": "9", "comment": "/**\n * Output chemical contents to a file\n * @param contents File contents\n * @param currentID Chemical ID, used to determine the filename\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1096, "method_signature": "void writeID(String, String)"}, "851": {"callee_method_ids": [850], "callee_method_names": ["SparseVector.dot"], "method_name": "SparseVector.norm", "method_implementation": "{\n    SparseVector a = this;\n    return Math.sqrt(a.dot(a));\n}", "repo_id": "9", "comment": "/**\n * Calculates the 2-norm\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 851, "method_signature": "double norm()"}, "2777": {"callee_method_names": [], "method_name": "IUPACParser.isStart", "method_implementation": "{\n    if (this.codons.isEmpty()) {\n        throw new IllegalStateException(\"Codons are empty; please request getCodons() fist before asking this\");\n    }\n    for (Codon codon : codons) {\n        //Only check if the codon was a start codon and then ask if the compound was encoded by it\n        if (codon.isStart()) {\n            if (codon.getAminoAcid().equalsIgnoreCase(compound)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Returns true if the given compound was a start codon in this\n * codon table. This will report true if the compound could ever have\n * been a start codon.\n *\n * @throws IllegalStateException Thrown if\n * {@link #getCodons(CompoundSet, CompoundSet)} was not called first.\n */\n", "repo_name": "biojava-master/", "id": 2777, "method_signature": "boolean isStart(AminoAcidCompound)"}, "2198": {"callee_method_ids": [1347, 1347, 1349, 1349, 1349], "callee_method_names": ["EntityInfo.setMolId", "EntityInfo.setMolId", "Structure.addEntityInfo", "Structure.addEntityInfo", "Chain.setId", "Chain.setName", "Chain.setId", "Chain.setName", "EntityInfo.addChain", "EntityInfo.addChain", "Chain.setId", "Chain.setName", "EntityInfo.addChain", "Structure.addChain", "Structure.addChain", "Structure.addChain", "Chain.setAtomGroups", "Chain.setSeqResGroups", "Chain.setEntityInfo", "Chain.setAtomGroups", "List<Group>.subList", "Chain.setSeqResGroups", "Chain.setEntityInfo", "Chain.setAtomGroups", "Chain.setSeqResGroups", "Chain.setEntityInfo"], "method_name": "TestInterfaceFinder.mockStructure", "method_implementation": "{\n    Structure structure = new StructureImpl();\n    EntityInfo entity1 = new EntityInfo();\n    entity1.setMolId(1);\n    EntityInfo entity2 = new EntityInfo();\n    entity2.setMolId(2);\n    structure.addEntityInfo(entity1);\n    structure.addEntityInfo(entity2);\n    Chain chainA = new ChainImpl();\n    chainA.setId(\"A\");\n    chainA.setName(\"A\");\n    Chain chainB = new ChainImpl();\n    chainB.setId(\"B\");\n    chainB.setName(\"B\");\n    entity1.addChain(chainA);\n    entity1.addChain(chainB);\n    Chain chainC = new ChainImpl();\n    chainC.setId(\"C\");\n    chainC.setName(\"C\");\n    entity2.addChain(chainC);\n    structure.addChain(chainA);\n    structure.addChain(chainB);\n    structure.addChain(chainC);\n    // entity 1: chain A 10 observed residues, chain B 9 observed residues (first unobserved)\n    List<Group> aGroups = getGroupList(10, \"ALA\", chainA, new Point3d(0, 0, 0));\n    chainA.setAtomGroups(new ArrayList<>(aGroups));\n    chainA.setSeqResGroups(aGroups);\n    chainA.setEntityInfo(entity1);\n    List<Group> bGroups = getGroupList(10, \"ALA\", chainB, new Point3d(4, 0, 0));\n    chainB.setAtomGroups(new ArrayList<>(bGroups.subList(1, 10)));\n    chainB.setSeqResGroups(bGroups);\n    chainB.setEntityInfo(entity1);\n    int size;\n    if (addNoAtomsPolyChain)\n        size = 0;\n    else\n        size = 20;\n    List<Group> cGroups = getGroupList(size, \"GLY\", chainC, new Point3d(0, 4, 0));\n    chainC.setAtomGroups(new ArrayList<>(cGroups));\n    chainC.setSeqResGroups(cGroups);\n    chainC.setEntityInfo(entity2);\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * Create a mock structure with 2 entities 1 (chains A, B) and 2 (chain C).\n * @return a structure\n */\n", "repo_name": "biojava-master/", "id": 2198, "method_signature": "Structure mockStructure(boolean)"}, "780": {"callee_method_names": ["AFPChain.toCE"], "method_name": "CeCPMain.displayAlignment", "method_implementation": "{\n    Atom[] ca1clone = StructureTools.cloneAtomArray(ca1);\n    Atom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n    if (!GuiWrapper.isGuiModuleInstalled()) {\n        System.err.println(\"The biojava-structure-gui and/or JmolApplet modules are not installed. Please install!\");\n        // display alignment in console\n        System.out.println(afpChain.toCE(ca1clone, ca2clone));\n    } else {\n        Object jmol = GuiWrapper.display(afpChain, ca1clone, ca2clone);\n        GuiWrapper.showAlignmentImage(afpChain, ca1clone, ca2clone, jmol);\n    }\n}", "repo_id": "9", "comment": "// TODO dmyersturnbull: This should probably be in structure-gui\n", "repo_name": "biojava-master/", "id": 780, "method_signature": "void displayAlignment(AFPChain, Atom[], Atom[])"}, "3069": {"callee_method_ids": [3056, 3056, 3056], "callee_method_names": ["LinkedHashMap.containsKey", "AccessionID.getID", "AccessionID.getID", "IntronSequence.setAccession", "ArrayList.add", "LinkedHashMap.put", "AccessionID.getID"], "method_name": "GeneSequence.addIntron", "method_implementation": "{\n    if (intronSequenceHashMap.containsKey(accession.getID())) {\n        throw new Exception(\"Duplicate accesion id \" + accession.getID());\n    }\n    intronAdded = true;\n    // working off the assumption that intron frame is always 0 or doesn't matter and same sense as parent\n    IntronSequence intronSequence = new IntronSequence(this, begin, end);\n    intronSequence.setAccession(accession);\n    intronSequenceList.add(intronSequence);\n    intronSequenceHashMap.put(accession.getID(), intronSequence);\n    return intronSequence;\n}", "repo_id": "9", "comment": "/**\n * Add an Intron Currently used to mark an IntronSequence as a feature\n * @param accession\n * @param begin\n * @param end\n * @return intron sequence\n */\n", "repo_name": "biojava-master/", "id": 3069, "method_signature": "IntronSequence addIntron(AccessionID, int, int)"}, "3532": {"callee_method_names": [], "method_name": "CoxCoefficient.getStdError", "method_implementation": "{\n    return stdError;\n}", "repo_id": "9", "comment": "/**\n * @return the stdError\n */\n", "repo_name": "biojava-master/", "id": 3532, "method_signature": "double getStdError()"}, "3786": {"callee_method_names": ["LinkedHashMap.keySet"], "method_name": "KaplanMeierFigure.getGroups", "method_implementation": "{\n    return new ArrayList<String>(survivalData.keySet());\n}", "repo_id": "9", "comment": "/**\n * Get the name of the groups that are being plotted in the figure\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3786, "method_signature": "ArrayList<String> getGroups()"}, "3304": {"callee_method_names": [], "method_name": "SystemInfo.isControlCharacter", "method_implementation": "{\n    return ((c >= '\\u0000' && c <= '\\u001f') || (c >= '\\u007f' && c <= '\\u009f'));\n}", "repo_id": "9", "comment": "/**\n * Replicate the Java 1.1 isISOControl method (for Java 1.0.2 compatibility)\n */\n", "repo_name": "biojava-master/", "id": 3304, "method_signature": "boolean isControlCharacter(char)"}, "2686": {"callee_method_names": ["TranscriptionEngine.getRnaAminoAcidTranslator"], "method_name": "RNASequence.getProteinSequence", "method_implementation": "{\n    return (ProteinSequence) engine.getRnaAminoAcidTranslator().createSequence(this);\n}", "repo_id": "9", "comment": "/**\n * Get the ProteinSequence from the RNA sequence with user-defined\n * transcription engine\n *\n * @param engine\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2686, "method_signature": "ProteinSequence getProteinSequence(TranscriptionEngine)"}, "1813": {"callee_method_names": ["ReadWriteLock.writeLock", "Logger.trace", "Logger.info", "Logger.error", "Logger.trace", "ReadWriteLock.writeLock"], "method_name": "EcodInstallation.downloadDomains", "method_implementation": "{\n    domainsFileLock.writeLock().lock();\n    logger.trace(\"LOCK writelock\");\n    try {\n        URL domainsURL = new URL(url + DOMAINS_PATH + getDomainFilename());\n        File localFile = getDomainFile();\n        logger.info(\"Downloading {} to: {}\", domainsURL, localFile);\n        FileDownloadUtils.createValidationFiles(domainsURL, localFile, null, FileDownloadUtils.Hash.UNKNOWN);\n        FileDownloadUtils.downloadFile(domainsURL, localFile);\n        if (!FileDownloadUtils.validateFile(localFile))\n            throw new IOException(\"Downloaded file invalid: \" + localFile);\n    } catch (MalformedURLException e) {\n        logger.error(\"Malformed url: \" + url + DOMAINS_PATH + getDomainFilename(), e);\n    } finally {\n        logger.trace(\"UNLOCK writelock\");\n        domainsFileLock.writeLock().unlock();\n    }\n}", "repo_id": "9", "comment": "/**\n * Downloads the domains file +/- its validation metadata, overwriting any existing file\n * @throws IOException in cases of file I/O, including failure to download a healthy (non-corrupted) file.\n */\n", "repo_name": "biojava-master/", "id": 1813, "method_signature": "void downloadDomains()"}, "1359": {"callee_method_names": [], "method_name": "AminoAcidImpl.setAminoType", "method_implementation": "{\n    amino_char = aa;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1359, "method_signature": "void setAminoType(Character)"}, "3266": {"callee_method_ids": [3278], "callee_method_names": ["Logger.debug", "JmolPanel.removeMouseListener", "JmolPanel.removeMouseMotionListener", "JmolPanel.destroy"], "method_name": "AbstractAlignmentJmol.destroy", "method_implementation": "{\n    logger.debug(\"cleaning up AlignmentJmol window\");\n    jmolPanel.removeMouseListener(this);\n    jmolPanel.removeMouseMotionListener(this);\n    jmolPanel.destroy();\n}", "repo_id": "9", "comment": "/**\n * Set all the member variables to null.\n */\n", "repo_name": "biojava-master/", "id": 3266, "method_signature": "void destroy()"}, "3162": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.countCompounds", "method_implementation": "{\n    return SequenceMixin.countCompounds(this, compounds);\n}", "repo_id": "9", "comment": "/**\n * @param compounds\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3162, "method_signature": "int countCompounds(C[])"}, "976": {"callee_method_names": [], "method_name": "BioAssemblyInfo.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * The identifier for this Biological Assembly, from 1 to n\n * @return\n */\n", "repo_name": "biojava-master/", "id": 976, "method_signature": "int getId()"}, "2895": {"callee_method_names": ["Sequence<C>.getCompoundSet"], "method_name": "SequenceMixin.inverse", "method_implementation": "{\n    SequenceView<C> reverse = new ReversedSequenceView<C>(sequence);\n    if (sequence.getCompoundSet().isComplementable()) {\n        return new ComplementSequenceView(reverse);\n    }\n    return reverse;\n}", "repo_id": "9", "comment": "/**\n * A method which attempts to do the right thing when is comes to a\n * reverse/reverse complement\n *\n * @param <C> The type of compound\n * @param sequence The input sequence\n * @return The inverted sequence which is optionally complemented\n */\n", "repo_name": "biojava-master/", "id": 2895, "method_signature": "SequenceView<C> inverse(Sequence)"}, "3661": {"callee_method_names": [], "method_name": "SurvivalInfo.getScore", "method_implementation": "{\n    return score;\n}", "repo_id": "9", "comment": "/**\n * @return the score\n */\n", "repo_name": "biojava-master/", "id": 3661, "method_signature": "double getScore()"}, "2901": {"callee_method_names": [], "method_name": "AbstractSequence.setBioBegin", "method_implementation": "{\n    this.bioBegin = bioBegin;\n}", "repo_id": "9", "comment": "/**\n * @param bioBegin the bioBegin to set\n */\n", "repo_name": "biojava-master/", "id": 2901, "method_signature": "void setBioBegin(Integer)"}, "530": {"callee_method_names": ["List<int[]>.iterator", "Iterator<int[]>.hasNext", "Iterator<int[]>.next", "List<int[]>.add"], "method_name": "JointFragments.setIdxlist", "method_implementation": "{\n    Iterator<int[]> iter = idxs.iterator();\n    while (iter.hasNext()) {\n        int[] e = iter.next();\n        idxlist.add(e);\n    }\n}", "repo_id": "9", "comment": "/**\n * Stores the alignment between the residues of several fragments.\n * Each int[] stores the residue numbers of several equivalent residues.\n */\n", "repo_name": "biojava-master/", "id": 530, "method_signature": "void setIdxlist(List)"}, "2533": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum90", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum90\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 90 matrix by Henikoff & Henikoff\n * @return Blosum 90 matrix\n */\n", "repo_name": "biojava-master/", "id": 2533, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum90()"}, "1826": {"callee_method_names": ["ObjectMapper.readValue", "URL.openStream", "JsonNode.isArray", "List<Status>.add", "List<Status>.size", "Logger.warn", "List<Status>.size", "List<Status>.toArray"], "method_name": "PDBStatus.getStatus", "method_implementation": "{\n    URL url = new URL(String.format(STATUS_LIST_ENDPOINT, DEFAULT_RCSB_DATA_API_SERVER, String.join(\",\", pdbIds)));\n    List<Status> statuses = new ArrayList<>();\n    ObjectMapper objectMapper = new ObjectMapper();\n    JsonNode node = objectMapper.readValue(url.openStream(), JsonNode.class);\n    if (node != null && node.isArray()) {\n        for (JsonNode record : node) {\n            Status status = parseStatusRecord(record);\n            statuses.add(status);\n        }\n    }\n    if (statuses.size() != pdbIds.length) {\n        logger.warn(\"RCSB status request was for {} ids, but {} were returned\", pdbIds.length, statuses.size());\n    }\n    return statuses.toArray(new Status[0]);\n}", "repo_id": "9", "comment": "/**\n * Get the status of a collection of PDB ids (in a single API query).\n *\n * @see #getStatus(String)\n * @param pdbIds the ids\n * @return The status array\n */\n", "repo_name": "biojava-master/", "id": 1826, "method_signature": "Status[] getStatus(String[])"}, "1817": {"callee_method_names": [], "method_name": "EcodInstallation.setUpdateFrequency", "method_implementation": "{\n    this.updateFrequency = updateFrequency;\n}", "repo_id": "9", "comment": "/**\n * The \"latest\" version will be re-downloaded if it is older than\n * {@link #getUpdateFrequency()} days. Setting this to null disables\n * re-downloading (delete $PDB_CACHE_DIR/ecod.latest.domains.txt manually\n * to force updating). Setting to 0 will force downloading for every\n * program execution.\n * @param updateFrequency the updateFrequency to set\n */\n", "repo_name": "biojava-master/", "id": 1817, "method_signature": "void setUpdateFrequency(Integer)"}, "147": {"callee_method_ids": [477], "callee_method_names": ["AFPChain.getNrEQR"], "method_name": "FlipAFPChainTest.getRMSD", "method_implementation": "{\n    Atom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n    rotateAtoms2(afpChain, ca2clone);\n    // get only the subset of Atoms that is on structurally equivalent positions\n    Atom[] catmp1 = AFPAlignmentDisplay.getAlignedAtoms1(afpChain, ca1);\n    Atom[] catmp2 = AFPAlignmentDisplay.getAlignedAtoms2(afpChain, ca2clone);\n    assertTrue(catmp1.length == catmp2.length);\n    assertTrue(catmp1.length == afpChain.getNrEQR());\n    return Calc.rmsd(catmp1, catmp2);\n}", "repo_id": "9", "comment": "/**\n * get the RMSD between the aligned positions\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 147, "method_signature": "double getRMSD(AFPChain, Atom[], Atom[])"}, "1944": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getMinTm", "method_implementation": "{\n    return minTm;\n}", "repo_id": "9", "comment": "/**\n * @return the minTm\n */\n", "repo_name": "biojava-master/", "id": 1944, "method_signature": "double getMinTm()"}, "1766": {"callee_method_names": [], "method_name": "PDBHeader.setIdCode", "method_implementation": "{\n    if (idCode == null) {\n        this.pdbId = null;\n    } else {\n        this.pdbId = new PdbId(idCode);\n    }\n}", "repo_id": "9", "comment": "/**\n * The PDB code for this protein structure.\n *\n * @param idCode the PDB identifier\n * @see #getIdCode()\n * @deprecated use {@link #setPdbId(PdbId)}\n */\n", "repo_name": "biojava-master/", "id": 1766, "method_signature": "void setIdCode(String)"}, "3516": {"callee_method_names": [], "method_name": "StrataInfo.getSurv", "method_implementation": "{\n    return surv;\n}", "repo_id": "9", "comment": "/**\n * @return the surv\n */\n", "repo_name": "biojava-master/", "id": 3516, "method_signature": "ArrayList<Double> getSurv()"}, "2286": {"callee_method_ids": [1568], "callee_method_names": ["Site.remark800toPDB"], "method_name": "SiteTest.testRemark800ToPDB_0args", "method_implementation": "{\n    //        System.out.println(\"remark800toPDB_0args\");\n    String expResult = \"REMARK 800 SITE_IDENTIFIER: CAT                                                 \" + newline + \"REMARK 800 EVIDENCE_CODE: UNKNOWN                                               \" + newline + \"REMARK 800 SITE_DESCRIPTION: ACTIVE SITE                                        \" + newline;\n    String result = catSite.remark800toPDB();\n    //        System.out.println(result);\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of toPDB method, of class Site.\n */\n", "repo_name": "biojava-master/", "id": 2286, "method_signature": "void testRemark800ToPDB_0args()"}, "2744": {"callee_method_names": [], "method_name": "EmblRecord.getSequenceDescription", "method_implementation": "{\n    return sequenceDescription;\n}", "repo_id": "9", "comment": "/**\n * The DE (Description) lines contain general descriptive information about the\n * sequence stored. This may include the designations of genes for which the\n * sequence codes, the region of the genome from which it is derived, or other\n * information which helps to identify the sequence.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2744, "method_signature": "String getSequenceDescription()"}, "150": {"callee_method_ids": [619, 619, 790, 781, 619, 784, 781], "callee_method_names": ["AtomCache.getAtoms", "AtomCache.getAtoms", "OptimalCECPMain.alignOptimal", "OptimalCECPMain.getParameters", "AtomCache.getAtoms", "OptimalCECPMain.alignPermuted", "OptimalCECPMain.getParameters"], "method_name": "OptimalCECPMainTest.testOptimalAlignmentConsistency", "method_implementation": "{\n    String name1, name2;\n    OptimalCECPMain ce;\n    AFPChain afpChain;\n    //CP points to check for consistency\n    int[] cps;\n    //small case\n    name1 = \"d1qdmA1\";\n    name2 = \"d1nklA_\";\n    cps = new int[] { 0, 1, 2, 41, 5, 38 };\n    Atom[] ca1 = cache.getAtoms(name1);\n    Atom[] ca2 = cache.getAtoms(name2);\n    // Calculate all alignments initially\n    ce = new OptimalCECPMain();\n    AFPChain[] alignments = new AFPChain[ca2.length];\n    ce.alignOptimal(ca1, ca2, ce.getParameters(), alignments);\n    for (int cp : cps) {\n        // fresh instance to avoid contamination\n        ce = new OptimalCECPMain();\n        // new copy of ca2, since alignPermuted has side effects\n        Atom[] ca2clone = cache.getAtoms(name2);\n        afpChain = ce.alignPermuted(ca1, ca2clone, ce.getParameters(), cp);\n        Assert.assertEquals(\"Alignment \" + cp + \" differs.\", afpChain, alignments[cp]);\n    }\n}", "repo_id": "9", "comment": "/**\n * Checks that individual alignments performed by alignOptimal are consistent\n * with the alignments returned by individual calls to alignPermuted.\n *\n * This addresses a bug involving multiple calls to align() on the same\n * CE instance.\n *\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 150, "method_signature": "void testOptimalAlignmentConsistency()"}, "407": {"callee_method_names": ["FatCatUserArgumentProcessor.process"], "method_name": "FatCat.main", "method_implementation": "{\n    FatCatUserArgumentProcessor processor = new FatCatUserArgumentProcessor();\n    processor.process(argv);\n}", "repo_id": "9", "comment": "/**\n * See demo/FatCatDemo.java for an example how to run.\n *\n * Launch FatCat from command line.\n *\n * Parameters are:\n *\n * @param argv\n */\n", "repo_name": "biojava-master/", "id": 407, "method_signature": "void main(String[])"}, "2444": {"callee_method_ids": [2423, 2422, 2431], "callee_method_names": ["FeatureI.seqname", "Location.isSameStrand", "FeatureI.location", "FeatureI.location", "FeatureI.location", "Location.opposite", "FeatureList.add"], "method_name": "FeatureList.omitOverlapping", "method_implementation": "{\n    FeatureList list = new FeatureList();\n    for (FeatureI feature : this) {\n        boolean overlaps = false;\n        if (feature.seqname().equals(seqname)) {\n            if (location.isSameStrand(feature.location())) {\n                overlaps = feature.location().overlaps(location);\n            } else if (useBothStrands) {\n                overlaps = feature.location().overlaps(location.opposite());\n            }\n        }\n        if (!overlaps) {\n            list.add(feature);\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Create a list of all features that do not overlap the specified location on the specified sequence.\n *\n * @param seqname The sequence name. Only features with this sequence name will be checked for overlap.\n * @param location The location to check.\n * @param useBothStrands If true, locations are mapped to their positive strand image\n * before being checked for overlap. If false, all features whose locations are\n * on the opposite strand from the specified location will be considered non-overlapping.\n * @return The new list of features that do not overlap the location.\n */\n", "repo_name": "biojava-master/", "id": 2444, "method_signature": "FeatureList omitOverlapping(String, Location, boolean)"}, "953": {"callee_method_names": [], "method_name": "OperatorResolver.getBinaryOperators", "method_implementation": "{\n    return binaryOperators;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of operators for this assembly. The operators\n * refer to the transformations that should be applied to\n * the asym ids to generate this macromolecular assembly.\n * Each ordered pair refers to the multiplication\n * of the two transformation matrices in the\n * pdbx_structure_oper_list category.\n * @return the binary operators for this assembly\n */\n", "repo_name": "biojava-master/", "id": 953, "method_signature": "List<OrderedPair<String>> getBinaryOperators()"}, "2168": {"callee_method_ids": [992, 994], "callee_method_names": ["Chain.setId", "HetatomImpl.setChain", "HetatomImpl.getChainId"], "method_name": "HetatomImplTest.testGetChainId", "method_implementation": "{\n    //        System.out.println(\"getChainName\");\n    Chain chain = new ChainImpl();\n    chain.setId(\"A\");\n    HetatomImpl instance = new HetatomImpl();\n    instance.setChain(chain);\n    String expResult = \"A\";\n    String result = instance.getChainId();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of getChainName method, of class HetatomImpl.\n */\n", "repo_name": "biojava-master/", "id": 2168, "method_signature": "void testGetChainId()"}, "1862": {"callee_method_names": [], "method_name": "Rotation.setFold", "method_implementation": "{\n    this.fold = fold;\n}", "repo_id": "9", "comment": "/**\n * @param fold the fold to set\n */\n", "repo_name": "biojava-master/", "id": 1862, "method_signature": "void setFold(int)"}, "2730": {"callee_method_names": [], "method_name": "EmblId.getPrimaryAccession", "method_implementation": "{\n    return primaryAccession;\n}", "repo_id": "9", "comment": "/**\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2730, "method_signature": "String getPrimaryAccession()"}, "3581": {"callee_method_names": [], "method_name": "Matrix.add", "method_implementation": "{\n    int m = A.length;\n    int n = A[0].length;\n    double[][] C = new double[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            C[i][j] = A[i][j] + B[i][j];\n        }\n    }\n    return C;\n}", "repo_id": "9", "comment": "/**\n * @param A\n * @param B\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3581, "method_signature": "double[][] add(double[][], double[][])"}, "708": {"callee_method_names": [], "method_name": "OptimalCECPParameters.setTryAllCPs", "method_implementation": "{\n    this.tryAllCPs = tryAllCPs;\n}", "repo_id": "9", "comment": "/**\n * @param tryAllCPs Set whether we should try all CP sites\n */\n", "repo_name": "biojava-master/", "id": 708, "method_signature": "void setTryAllCPs(Boolean)"}, "2784": {"callee_method_names": [], "method_name": "FastaWriter.getLineLength", "method_implementation": "{\n    return lineLength;\n}", "repo_id": "9", "comment": "/**\n * @return the lineLength\n */\n", "repo_name": "biojava-master/", "id": 2784, "method_signature": "int getLineLength()"}, "70": {"callee_method_names": ["Subproblem.getTargetEndIndex", "Subproblem.getTargetStartIndex", "Subproblem.getTargetEndIndex"], "method_name": "AbstractMatrixAligner.getSubstitutionScoreVector", "method_implementation": "{\n    int[] subs = new int[subproblem.getTargetEndIndex() + 1];\n    if (queryColumn > 0) {\n        for (int y = Math.max(1, subproblem.getTargetStartIndex()); y <= subproblem.getTargetEndIndex(); y++) {\n            subs[y] = getSubstitutionScore(queryColumn, y);\n        }\n    }\n    return subs;\n}", "repo_id": "9", "comment": "/**\n * Returns score for the alignment of the query column to all target columns\n * @param queryColumn\n * @param subproblem\n * @return\n */\n", "repo_name": "biojava-master/", "id": 70, "method_signature": "int[] getSubstitutionScoreVector(int, Subproblem)"}, "401": {"callee_method_names": ["Structure.nrModels", "Structure.getModel", "List<Chain>.size", "List<Chain>.get", "Chain.getAtomLength"], "method_name": "GroupIterator.hasSubGroup", "method_implementation": "{\n    if (tmp_model >= structure.nrModels()) {\n        return false;\n    }\n    List<Chain> model = structure.getModel(tmp_model);\n    if (tmp_chain >= model.size()) {\n        if (fixed_model)\n            return false;\n        return hasSubGroup(tmp_model + 1, 0, 0);\n    }\n    Chain chain = model.get(tmp_chain);\n    // start search at beginning of next chain.\n    return tmp_group < chain.getAtomLength() || hasSubGroup(tmp_model, tmp_chain + 1, 0);\n}", "repo_id": "9", "comment": "/**\n * recursive method to determine if there is a next group. Helper\n * method for hasNext().\n * @see #hasNext\n */\n", "repo_name": "biojava-master/", "id": 401, "method_signature": "boolean hasSubGroup(int, int, int)"}, "777": {"callee_method_ids": [493, 494, 481, 487, 489, 487, 505, 506, 3580, 487], "callee_method_names": ["AFPChain.getName1", "AFPChain.getName2", "AFPChain.setName1", "AFPChain.setName2", "AFPChain.getCa1Length", "AFPChain.setCa1Length", "AFPChain.getCa2Length", "AFPChain.setCa2Length", "AFPChain.getAlnbeg1", "AFPChain.setAlnbeg1", "AFPChain.getAlnbeg2", "AFPChain.setAlnbeg2", "AFPChain.getAlnseq1", "AFPChain.setAlnseq1", "AFPChain.getAlnseq2", "AFPChain.setAlnseq2", "AFPChain.getDisTable1", "AFPChain.setDisTable1", "AFPChain.getDisTable2", "AFPChain.setDisTable2", "AFPChain.getFocusRes1", "AFPChain.setFocusRes1", "AFPChain.getFocusRes2", "AFPChain.setFocusRes2", "AFPChain.getPdbAln", "AFPChain.getBlockNum", "AFPChain.getOptAln", "AFPChain.getBlockNum", "AFPChain.setOptAln", "AFPChain.getDistanceMatrix", "AFPChain.setDistanceMatrix", "Matrix.transpose", "AFPChain.getBlockRotationMatrix", "AFPChain.getBlockShiftVector", "AFPChain.getBlockNum", "Matrix[].inverse"], "method_name": "CeCPMain.invertAlignment", "method_implementation": "{\n    String name1 = a.getName1();\n    String name2 = a.getName2();\n    a.setName1(name2);\n    a.setName2(name1);\n    int len1 = a.getCa1Length();\n    a.setCa1Length(a.getCa2Length());\n    a.setCa2Length(len1);\n    int beg1 = a.getAlnbeg1();\n    a.setAlnbeg1(a.getAlnbeg2());\n    a.setAlnbeg2(beg1);\n    char[] alnseq1 = a.getAlnseq1();\n    a.setAlnseq1(a.getAlnseq2());\n    a.setAlnseq2(alnseq1);\n    Matrix distab1 = a.getDisTable1();\n    a.setDisTable1(a.getDisTable2());\n    a.setDisTable2(distab1);\n    int[] focusRes1 = a.getFocusRes1();\n    a.setFocusRes1(a.getFocusRes2());\n    a.setFocusRes2(focusRes1);\n    //What are aftIndex and befIndex used for? How are they indexed?\n    //a.getAfpAftIndex()\n    String[][][] pdbAln = a.getPdbAln();\n    if (pdbAln != null) {\n        for (int block = 0; block < a.getBlockNum(); block++) {\n            String[] paln1 = pdbAln[block][0];\n            pdbAln[block][0] = pdbAln[block][1];\n            pdbAln[block][1] = paln1;\n        }\n    }\n    int[][][] optAln = a.getOptAln();\n    if (optAln != null) {\n        for (int block = 0; block < a.getBlockNum(); block++) {\n            int[] aln1 = optAln[block][0];\n            optAln[block][0] = optAln[block][1];\n            optAln[block][1] = aln1;\n        }\n    }\n    // triggers invalidate()\n    a.setOptAln(optAln);\n    Matrix distmat = a.getDistanceMatrix();\n    if (distmat != null)\n        a.setDistanceMatrix(distmat.transpose());\n    // invert the rotation matrices\n    Matrix[] blockRotMat = a.getBlockRotationMatrix();\n    Atom[] shiftVec = a.getBlockShiftVector();\n    if (blockRotMat != null) {\n        for (int block = 0; block < a.getBlockNum(); block++) {\n            if (blockRotMat[block] != null) {\n                // if y=x*A+b, then x=y*inv(A)-b*inv(A)\n                blockRotMat[block] = blockRotMat[block].inverse();\n                Calc.rotate(shiftVec[block], blockRotMat[block]);\n                shiftVec[block] = Calc.invert(shiftVec[block]);\n            }\n        }\n    }\n    return a;\n}", "repo_id": "9", "comment": "/**\n * Swaps the order of structures in an AFPChain\n * @param a\n * @return\n */\n", "repo_name": "biojava-master/", "id": 777, "method_signature": "AFPChain invertAlignment(AFPChain)"}, "787": {"callee_method_ids": [489, 490, 487, 487], "callee_method_names": ["AFPChain.getCa2Length", "AFPChain.getName2", "AFPChain.getOptAln", "AFPChain.getOptLen", "AFPChain.getBlockNum", "AFPChain.getBlockNum", "List<List<Integer>>.add", "List<List<Integer>>.add", "List<List<List<Integer>>>.add", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<List<Integer>>.add", "List<List<Integer>>.add", "List<List<List<Integer>>>.add", "List<List<Integer>>.get", "List<List<Integer>>.get"], "method_name": "OptimalCECPMain.permuteOptAln", "method_implementation": "{\n    int ca2len = afpChain.getCa2Length();\n    if (ca2len <= 0) {\n        throw new IllegalArgumentException(\"No Ca2Length specified in \" + afpChain);\n    }\n    // Allow negative cp points for convenience.\n    if (cp == 0) {\n        return;\n    }\n    if (cp <= -ca2len || cp >= ca2len) {\n        // could just take cp%ca2len, but probably its a bug if abs(cp)>=ca2len\n        throw new ArrayIndexOutOfBoundsException(String.format(\"Permutation point %d must be between %d and %d for %s\", cp, 1 - ca2len, ca2len - 1, afpChain.getName2()));\n    }\n    if (cp < 0) {\n        cp = cp + ca2len;\n    }\n    // the unprocessed alignment\n    int[][][] optAln = afpChain.getOptAln();\n    int[] optLen = afpChain.getOptLen();\n    // the processed alignment\n    List<List<List<Integer>>> blocks = new ArrayList<List<List<Integer>>>(afpChain.getBlockNum() * 2);\n    //Update residue indices\n    // newi = (oldi-cp) % N\n    for (int block = 0; block < afpChain.getBlockNum(); block++) {\n        if (optLen[block] < 1)\n            continue;\n        // set up storage for the current block\n        List<List<Integer>> currBlock = new ArrayList<List<Integer>>(2);\n        currBlock.add(new ArrayList<Integer>());\n        currBlock.add(new ArrayList<Integer>());\n        blocks.add(currBlock);\n        // pos = 0 case\n        currBlock.get(0).add(optAln[block][0][0]);\n        currBlock.get(1).add((optAln[block][1][0] + cp) % ca2len);\n        for (int pos = 1; pos < optLen[block]; pos++) {\n            //check if we need to start a new block\n            //this happens when the new alignment crosses the protein terminus\n            if (optAln[block][1][pos - 1] + cp < ca2len && optAln[block][1][pos] + cp >= ca2len) {\n                currBlock = new ArrayList<List<Integer>>(2);\n                currBlock.add(new ArrayList<Integer>());\n                currBlock.add(new ArrayList<Integer>());\n                blocks.add(currBlock);\n            }\n            currBlock.get(0).add(optAln[block][0][pos]);\n            currBlock.get(1).add((optAln[block][1][pos] + cp) % ca2len);\n        }\n    }\n    // save permuted blocks to afpChain\n    assignOptAln(afpChain, blocks);\n}", "repo_id": "9", "comment": "/**\n * Modifies the {@link AFPChain#setOptAln(int[][][]) optAln} of an AFPChain\n * by permuting the second protein.\n *\n * Sets residue numbers in the second protein to <i>(i-cp)%len</i>\n *\n * @param afpChain\n * @param cp Amount leftwards (or rightward, if negative) to shift the\n */\n", "repo_name": "biojava-master/", "id": 787, "method_signature": "void permuteOptAln(AFPChain, int)"}, "723": {"callee_method_names": [], "method_name": "CECalculator.zByZ", "method_implementation": "{\n    double p1 = zToP(z1);\n    double p2 = zToP(z2);\n    return (pToZ(p1 * p2));\n}", "repo_id": "9", "comment": "///////////////////////////////////////////////////////////////////////////\n", "repo_name": "biojava-master/", "id": 723, "method_signature": "double zByZ(double, double)"}, "1228": {"callee_method_ids": [954, 956], "callee_method_names": ["BiologicalAssemblyTransformation.setRotationMatrix", "Matrix.getArray", "BiologicalAssemblyTransformation.setTranslation", "BiologicalAssemblyTransformation.setId", "BiologicalAssemblyTransformation.setChainId", "List<BiologicalAssemblyTransformation>.add", "HashMap.containsKey", "BioAssemblyInfo.setId", "BioAssemblyInfo.setTransforms", "HashMap.put"], "method_name": "PDBBioAssemblyParser.saveMatrix", "method_implementation": "{\n    for (String chainId : currentChainIDs) {\n        BiologicalAssemblyTransformation transformation = new BiologicalAssemblyTransformation();\n        transformation.setRotationMatrix(currentMatrix.getArray());\n        transformation.setTranslation(shift);\n        transformation.setId(String.valueOf(modelNumber));\n        transformation.setChainId(chainId);\n        transformations.add(transformation);\n    }\n    if (!transformationMap.containsKey(currentBioMolecule)) {\n        BioAssemblyInfo bioAssembly = new BioAssemblyInfo();\n        bioAssembly.setId(currentBioMolecule);\n        bioAssembly.setTransforms(transformations);\n        transformationMap.put(currentBioMolecule, bioAssembly);\n    }\n}", "repo_id": "9", "comment": "/**\n * Saves transformation matrix for the list of current chains\n */\n", "repo_name": "biojava-master/", "id": 1228, "method_signature": "void saveMatrix()"}, "3809": {"callee_method_names": ["FontMetrics.stringWidth", "DecimalFormat.format", "FontMetrics.stringWidth", "DecimalFormat.format"], "method_name": "KaplanMeierFigure.setFigureDimensions", "method_implementation": "{\n    fm = getFontMetrics(getFont());\n    //fm.getHeight();\n    titleHeight = kmfi.titleHeight;\n    xAxisLabelHeight = titleHeight;\n    labelWidth = Math.max(fm.stringWidth(df.format(minPercentage)), fm.stringWidth(df.format(maxPercentage))) + 5;\n    top = kmfi.padding + titleHeight;\n    bottom = this.getHeight() - kmfi.padding - xAxisLabelHeight;\n    left = kmfi.padding + labelWidth + yaxisLabel;\n    right = this.getWidth() - kmfi.padding;\n}", "repo_id": "9", "comment": "/**\n * Reset the various bounds used to draw graph\n */\n", "repo_name": "biojava-master/", "id": 3809, "method_signature": "void setFigureDimensions()"}, "1722": {"callee_method_names": [], "method_name": "BasePairParameters.getPairingNames", "method_implementation": "{\n    return pairingNames;\n}", "repo_id": "9", "comment": "/**\n * This method returns the names of the pairs in terms of A, G, T/U, and C for each base pair group in the\n * list.  The first character is the leading strand base and the second character is the complementary base\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1722, "method_signature": "List<String> getPairingNames()"}, "1984": {"callee_method_names": [], "method_name": "RotationAxisAligner.getRadius", "method_implementation": "{\n    run();\n    return xyRadiusMax;\n}", "repo_id": "9", "comment": "/**\n * Returns the radius for drawing the minor rotation axis in the xy-plane\n * @return double radius in xy-plane\n */\n", "repo_name": "biojava-master/", "id": 1984, "method_signature": "double getRadius()"}, "1646": {"callee_method_names": [], "method_name": "SubunitClustererParameters.isUseStructureCoverage", "method_implementation": "{\n    return useStructureCoverage;\n}", "repo_id": "9", "comment": "/**\n * Use structure coverage for evaluating sequence similarity\n *\n * @return useStructureCoverage\n */\n", "repo_name": "biojava-master/", "id": 1646, "method_signature": "boolean isUseStructureCoverage()"}, "411": {"callee_method_names": [], "method_name": "FCAlignHelper.getAlignPos", "method_implementation": "{\n    int i = B1;\n    int j = B2;\n    int s = 0;\n    int a = 0;\n    int op;\n    while (i <= E1 && j <= E2) {\n        op = sapp0[s++];\n        if (op == 0) {\n            //i - 1\n            alignList[0][a] = i - 1;\n            alignList[1][a] = j - 1;\n            a++;\n            i++;\n            j++;\n        } else if (op > 0) {\n            j += op;\n        } else {\n            i -= op;\n        }\n    }\n    return a;\n}", "repo_id": "9", "comment": "/**\n * record the aligned pairs in alignList[][0], alignList[][1];\n * return the number of aligned pairs\n * @param alignList\n * @return the number of aligned pairs\n */\n", "repo_name": "biojava-master/", "id": 411, "method_signature": "int getAlignPos(int[][])"}, "3403": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getRotationGroup", "method_implementation": "{\n    return rotationGroup;\n}", "repo_id": "9", "comment": "/**\n * @return the rotationGroup\n */\n", "repo_name": "biojava-master/", "id": 3403, "method_signature": "RotationGroup getRotationGroup()"}, "1518": {"callee_method_names": [], "method_name": "UnitQuaternions.dotProduct", "method_implementation": "{\n    return q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;\n}", "repo_id": "9", "comment": "/**\n * Compute the dot (inner) product of two quaternions.\n *\n * @param q1\n *            quaternion as Quat4d object\n * @param q2\n *            quaternion as Quat4d object\n * @return the value of the quaternion dot product\n */\n", "repo_name": "biojava-master/", "id": 1518, "method_signature": "double dotProduct(Quat4d, Quat4d)"}, "3331": {"callee_method_names": [], "method_name": "SequenceDisplay.getScaleForZoom", "method_implementation": "{\n    if (zoomFactor > 100)\n        zoomFactor = 100;\n    if (zoomFactor < 1)\n        zoomFactor = 1;\n    int DEFAULT_X_START = SequenceScalePanel.DEFAULT_X_START;\n    int DEFAULT_X_RIGHT_BORDER = SequenceScalePanel.DEFAULT_X_RIGHT_BORDER;\n    int seqLength = getMaxSequenceLength();\n    // the maximum width depends on the size of the parent Component\n    int width = getWidth();\n    float s = width / (float) (seqLength + DEFAULT_X_START + DEFAULT_X_RIGHT_BORDER);\n    //logger.info(\"scale for 100% \" + s + \" \" + seqLength + \" \" + zoomFactor);\n    s = (100) * s / (zoomFactor * 1.0f);\n    if (s > MAX_SCALE)\n        s = MAX_SCALE;\n    //logger.info(\"but changed to \" + s);\n    return s;\n}", "repo_id": "9", "comment": "/**\n * calculate the float that is used for display.\n * 1 * scale = size of 1 amino acid (in pixel).\n * maximum @see MAX_SCALE\n * @param zoomFactor\n * @return a float that is the display \"scale\" - an internal value required for paintin.\n * user should only interact with the zoomfactor ...\n */\n", "repo_name": "biojava-master/", "id": 3331, "method_signature": "float getScaleForZoom(int)"}, "1592": {"callee_method_names": ["BetaBridge.equals"], "method_name": "SecStrucCalc.shouldExtendLadder", "method_implementation": "{\n    //Only extend if they are of the same type\n    boolean sameType = b.type.equals(ladder.btype);\n    if (!sameType)\n        return false;\n    //Only extend if residue 1 is sequential to ladder strand\n    boolean sequential = (b.partner1 == ladder.to + 1);\n    if (!sequential)\n        return false;\n    switch(b.type) {\n        case parallel:\n            //Residue 2 should be sequential to second strand\n            if (b.partner2 == ladder.lto + 1)\n                return true;\n            break;\n        case antiparallel:\n            //Residue 2 should be previous to second strand\n            if (b.partner2 == ladder.lfrom - 1)\n                return true;\n            break;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Conditions to extend a ladder with a given beta Bridge:\n * <li>The bridge and ladder are of the same type.\n * <li>The smallest bridge residue is sequential to the first\n * \t\tstrand ladder.\n * <li>The second bridge residue is either sequential (parallel)\n * \t\tor previous (antiparallel) to the second strand of the ladder\n * </li>\n * @param ladder the ladder candidate to extend\n * @param b the beta bridge that would extend the ladder\n * @return true if the bridge b extends the ladder\n */\n", "repo_name": "biojava-master/", "id": 1592, "method_signature": "boolean shouldExtendLadder(Ladder, BetaBridge)"}, "2224": {"callee_method_names": ["ClassLoader.getResource", "SimpleDateFormat.parse", "Structure.getPDBHeader", "SimpleDateFormat.parse", "Structure.getPDBHeader", "SimpleDateFormat.parse", "Structure.getPDBHeader"], "method_name": "TestParseMmcifHeader.testDatesV5", "method_implementation": "{\n    ClassLoader classLoader = this.getClass().getClassLoader();\n    String file5 = classLoader.getResource(\"org/biojava/nbio/structure/io/mmcif/1stp_v5.cif\").getPath();\n    Structure s = StructureIO.getStructure(file5);\n    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\", Locale.US);\n    Date modDate = dateFormat.parse(\"2011-07-13\");\n    assertEquals(modDate, s.getPDBHeader().getModDate());\n    Date releaseDate = dateFormat.parse(\"1992-10-15\");\n    assertEquals(releaseDate, s.getPDBHeader().getRelDate());\n    Date depositionDate = dateFormat.parse(\"1992-03-12\");\n    assertEquals(depositionDate, s.getPDBHeader().getDepDate());\n}", "repo_id": "9", "comment": "/**\n * Test parsing dates from MMCIF file version 5.\n */\n", "repo_name": "biojava-master/", "id": 2224, "method_signature": "void testDatesV5()"}, "633": {"callee_method_names": ["ScopDatabase.getDomainByScopID"], "method_name": "AtomCache.getStructureForDomain", "method_implementation": "{\n    ScopDomain domain = scopDatabase.getDomainByScopID(scopId);\n    return getStructureForDomain(domain, scopDatabase);\n}", "repo_id": "9", "comment": "/**\n * Returns the representation of a {@link ScopDomain} as a BioJava {@link Structure} object.\n *\n * @param scopId\n *            a SCOP Id\n * @param scopDatabase\n *            A {@link ScopDatabase} to use\n * @return a Structure object\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 633, "method_signature": "Structure getStructureForDomain(String, ScopDatabase)"}, "2475": {"callee_method_names": ["Logger.info", "List<GeneName>.size", "Group.getApprovedSymbol", "Logger.info", "Logger.error"], "method_name": "GeneNamesParser.main", "method_implementation": "{\n    try {\n        List<GeneName> geneNames = getGeneNames();\n        logger.info(\"got {} gene names\", geneNames.size());\n        for (GeneName g : geneNames) {\n            if (\"FOLH1\".equals(g.getApprovedSymbol()))\n                logger.info(\"Gene Name: {}\", g);\n        }\n        // and returns a list of beans that contains key-value pairs for each gene name\n    } catch (Exception e) {\n        // TODO Auto-generated catch block\n        logger.error(\"Exception: \", e);\n    }\n}", "repo_id": "9", "comment": "/**\n * parses a file from the genenames website\n *\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 2475, "method_signature": "void main(String[])"}, "1171": {"callee_method_names": ["Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "String.substring", "String.substring", "String.length", "String.trim", "ArrayList.contains", "String.endsWith", "ArrayList.contains", "String.substring", "String.length", "Logger.info", "String.replace", "StringTokenizer.hasMoreTokens", "StringTokenizer.nextToken", "String.equals", "ArrayList.contains", "Logger.debug", "Logger.debug", "String.concat", "Logger.debug", "String.equals", "ArrayList.contains", "ArrayList.add"], "method_name": "PDBFileParser.pdb_COMPND_Handler", "method_implementation": "{\n    logger.debug(\"previousContinuationField  is {}\", previousContinuationField);\n    logger.debug(\"current continuationField  is {}\", continuationField);\n    logger.debug(\"current continuationString is {}\", continuationString);\n    logger.debug(\"current compound           is {}\", current_compound);\n    // In legacy PDB files the line ends with the PDB code and a serial number, chop those off!\n    //format version 3.0 onwards will have 80 characters in a line\n    //\t\tif (line.length() > 72) {\n    if (isLegacyFormat) {\n        //                    if (DEBUG) {\n        //                        System.out.println(\"We have a legacy file - truncating line length to 71 characters:\");\n        //                        System.out.println(line);\n        //                    }\n        line = line.substring(0, 72);\n    }\n    line = line.substring(10, line.length());\n    String[] fieldList = line.trim().split(\"\\\\s+\");\n    int fl = fieldList.length;\n    if (fl > 0) {\n        String field0 = fieldList[0];\n        if (compndFieldValues.contains(field0)) {\n            continuationField = field0;\n            if (\"\".equals(previousContinuationField)) {\n                previousContinuationField = continuationField;\n            }\n        } else if (field0.endsWith(\";\") && compndFieldValues.contains(field0.substring(0, field0.length() - 1))) {\n            // the ':' character indicates the end of a field name and should be invalid as part the first data token\n            // e.g. obsolete file 1hhb has a malformed COMPND line that can only be caught with this kind of check\n            // UPDATE: There is no harm of having a ':' in the first data token. e.g. 3fdj contains a ':'.\n            //   The intended case occurs only if the token is a key followed by a colon and a semicolon without spaces, e.g. \"COMPND   2 MOLECULE:;\"\n            logger.info(\"COMPND line does not follow the PDB 3.0 format. Note that COMPND parsing is not supported any longer in format 2.3 or earlier\");\n            return;\n        }\n    } else {\n        // the line will be added as data to the previous field\n    }\n    line = line.replace(continuationField, \"\").trim();\n    StringTokenizer compndTokens = new StringTokenizer(line);\n    //\t\tSystem.out.println(\"PDBFileParser.pdb_COMPND_Handler: Tokenizing '\" + line + \"'\");\n    while (compndTokens.hasMoreTokens()) {\n        String token = compndTokens.nextToken();\n        if (\"\".equals(previousContinuationField)) {\n            previousContinuationField = continuationField;\n        }\n        if (previousContinuationField.equals(continuationField) && compndFieldValues.contains(continuationField)) {\n            logger.debug(\"Still in field {}\", continuationField);\n            logger.debug(\"token = {}\", token);\n            continuationString = continuationString.concat(token + \" \");\n            logger.debug(\"continuationString = {}\", continuationString);\n        }\n        if (!continuationField.equals(previousContinuationField)) {\n            if (\"\".equals(continuationString)) {\n                continuationString = token;\n            } else {\n                compndValueSetter(previousContinuationField, continuationString);\n                previousContinuationField = continuationField;\n                continuationString = token + \" \";\n            }\n        } else if (ignoreCompndFieldValues.contains(token)) {\n            // this field shall be ignored\n            //continuationField = token;\n        }\n    }\n    if (isLastCompndLine) {\n        // final line in the section - finish off the compound\n        //\t\t\tSystem.out.println(\"[pdb_COMPND_Handler] Final COMPND line - Finishing off final MolID header.\");\n        compndValueSetter(continuationField, continuationString);\n        continuationString = \"\";\n        if (current_compound != null)\n            entities.add(current_compound);\n    }\n}", "repo_id": "9", "comment": "/**\n * This should not be accessed directly, other than by </code>makeCompounds</code>. It still deals with the same\n * lines in a similar manner but if not accessed from </code>makeCompounds</code> the last element will be\n * missing. Don't say I didn't warn you.\n *\n * @param line\n */\n", "repo_name": "biojava-master/", "id": 1171, "method_signature": "void pdb_COMPND_Handler(String)"}, "1845": {"callee_method_ids": [1831, 1832], "callee_method_names": ["AminoAcid.setResidueNumber", "AminoAcid.getResidueNumber", "AminoAcid.setPDBName", "AtomIterator.hasNext", "AtomIterator.next", "List<String>.contains", "Atom.getName", "AminoAcid.addAtom"], "method_name": "Mutator.mutateResidue", "method_implementation": "{\n    AminoAcid newgroup = new AminoAcidImpl();\n    newgroup.setResidueNumber(oldAmino.getResidueNumber());\n    newgroup.setPDBName(newType);\n    AtomIterator aiter = new AtomIterator(oldAmino);\n    while (aiter.hasNext()) {\n        Atom a = aiter.next();\n        if (supportedAtoms.contains(a.getName())) {\n            newgroup.addAtom(a);\n        }\n    }\n    return newgroup;\n}", "repo_id": "9", "comment": "/**\n * create a new residue which is of the new type.\n * Only the atoms N, Ca, C, O, Cb will be considered.\n * @param oldAmino\n * @param newType\n * @return a new, mutated, residue\n * @throws PDBParseException\n */\n", "repo_name": "biojava-master/", "id": 1845, "method_signature": "AminoAcid mutateResidue(AminoAcid, String)"}, "3668": {"callee_method_names": [], "method_name": "SurvivalInfo.setClusterValue", "method_implementation": "{\n    this.clusterValue = clusterValue;\n}", "repo_id": "9", "comment": "/**\n * @param clusterValue the clusterValue to set\n */\n", "repo_name": "biojava-master/", "id": 3668, "method_signature": "void setClusterValue(String)"}, "837": {"callee_method_names": ["Atom.getElement", "Atom.getElement", "Atom.getName", "AminoAcid.getAminoType", "Atom.getElement", "Atom.getElement", "Atom.getElement", "Atom.getElement", "Logger.info", "Logger.debug", "AminoAcid.getPDBName", "Atom.getElement"], "method_name": "AsaCalculator.getRadiusForAmino", "method_implementation": "{\n    if (atom.getElement().equals(Element.H))\n        return Element.H.getVDWRadius();\n    // some unusual entries (e.g. 1tes) contain Deuterium atoms in standard aminoacids\n    if (atom.getElement().equals(Element.D))\n        return Element.D.getVDWRadius();\n    String atomCode = atom.getName();\n    char aa = amino.getAminoType();\n    // here we use the values that Chothia gives in his paper (as NACCESS does)\n    if (atom.getElement() == Element.O) {\n        return OXIGEN_VDW;\n    } else if (atom.getElement() == Element.S) {\n        return SULFUR_VDW;\n    } else if (atom.getElement() == Element.N) {\n        // tetrahedral Nitrogen\n        if (\"NZ\".equals(atomCode))\n            return TETRAHEDRAL_NITROGEN_VDW;\n        // trigonal Nitrogen\n        return TRIGONAL_NITROGEN_VDW;\n    } else if (atom.getElement() == Element.C) {\n        // it must be a carbon\n        if (\"C\".equals(atomCode) || \"CE1\".equals(atomCode) || \"CE2\".equals(atomCode) || \"CE3\".equals(atomCode) || \"CH2\".equals(atomCode) || \"CZ\".equals(atomCode) || \"CZ2\".equals(atomCode) || \"CZ3\".equals(atomCode)) {\n            // trigonal Carbon\n            return TRIGONAL_CARBON_VDW;\n        } else if (\"CA\".equals(atomCode) || \"CB\".equals(atomCode) || \"CE\".equals(atomCode) || \"CG1\".equals(atomCode) || \"CG2\".equals(atomCode)) {\n            // tetrahedral Carbon\n            return TETRAHEDRAL_CARBON_VDW;\n        } else // the rest of the cases (CD, CD1, CD2, CG) depend on amino acid\n        {\n            switch(aa) {\n                case 'F':\n                case 'W':\n                case 'Y':\n                case 'H':\n                case 'D':\n                case 'N':\n                    return TRIGONAL_CARBON_VDW;\n                case 'P':\n                case 'K':\n                case 'R':\n                case 'M':\n                case 'I':\n                case 'L':\n                    return TETRAHEDRAL_CARBON_VDW;\n                case 'Q':\n                case 'E':\n                    if (\"CD\".equals(atomCode))\n                        return TRIGONAL_CARBON_VDW;\n                    else if (\"CG\".equals(atomCode))\n                        return TETRAHEDRAL_CARBON_VDW;\n                default:\n                    logger.info(\"Unexpected carbon atom {} for aminoacid {}, assigning its standard vdw radius\", atomCode, aa);\n                    return Element.C.getVDWRadius();\n            }\n        }\n        // not any of the expected atoms\n    } else {\n        // non standard aas, (e.g. MSE, LLP) will always have this problem,\n        logger.debug(\"Unexpected atom {} for aminoacid {} ({}), assigning its standard vdw radius\", atomCode, aa, amino.getPDBName());\n        return atom.getElement().getVDWRadius();\n    }\n}", "repo_id": "9", "comment": "/**\n * Gets the radius for given amino acid and atom\n * @param amino\n * @param atom\n * @return\n */\n", "repo_name": "biojava-master/", "id": 837, "method_signature": "double getRadiusForAmino(AminoAcid, Atom)"}, "3480": {"callee_method_names": ["HashMap.get"], "method_name": "NCBIQBlastAlignmentProperties.getAlignmentOption", "method_implementation": "{\n    return param.get(key);\n}", "repo_id": "9", "comment": "/**\n * Gets the value of specified parameter or {@code null} if it is not set.\n */\n", "repo_name": "biojava-master/", "id": 3480, "method_signature": "String getAlignmentOption(BlastAlignmentParameterEnum)"}, "1513": {"callee_method_ids": [1483], "callee_method_names": ["MomentsOfInertia.addPoint", "Quat4d.set", "MomentsOfInertia.getOrientationMatrix"], "method_name": "UnitQuaternions.orientation", "method_implementation": "{\n    MomentsOfInertia moi = new MomentsOfInertia();\n    for (Point3d p : points) moi.addPoint(p, 1.0);\n    // Convert rotation matrix to quaternion\n    Quat4d quat = new Quat4d();\n    quat.set(moi.getOrientationMatrix());\n    return quat;\n}", "repo_id": "9", "comment": "/**\n * The orientation represents the rotation of the principal axes with\n * respect to the axes of the coordinate system (unit vectors [1,0,0],\n * [0,1,0] and [0,0,1]).\n * <p>\n * The orientation can be expressed as a unit quaternion.\n *\n * @param points\n *            array of Point3d\n * @return the orientation of the point cloud as a unit quaternion\n */\n", "repo_name": "biojava-master/", "id": 1513, "method_signature": "Quat4d orientation(Point3d[])"}, "1994": {"callee_method_names": ["RotationGroup.getPointGroup", "RotationGroup.getPointGroup", "RotationGroup.getPointGroup", "RotationGroup.getPointGroup", "RotationGroup.getPointGroup", "RotationGroup.getPointGroup", "Logger.warn"], "method_name": "RotationAxisAligner.calcReferenceVector", "method_implementation": "{\n    referenceVector = null;\n    if (rotationGroup.getPointGroup().startsWith(\"C\")) {\n        referenceVector = getReferenceAxisCylic();\n    } else if (rotationGroup.getPointGroup().startsWith(\"D\")) {\n        referenceVector = getReferenceAxisDihedral();\n    } else if (\"T\".equals(rotationGroup.getPointGroup())) {\n        referenceVector = getReferenceAxisTetrahedral();\n    } else if (\"O\".equals(rotationGroup.getPointGroup())) {\n        referenceVector = getReferenceAxisOctahedral();\n    } else if (\"I\".equals(rotationGroup.getPointGroup())) {\n        referenceVector = getReferenceAxisIcosahedral();\n    } else if (\"Helical\".equals(rotationGroup.getPointGroup())) {\n        // TODO what should the reference vector be??\n        referenceVector = getReferenceAxisCylic();\n    }\n    if (referenceVector == null) {\n        logger.warn(\"no reference vector found. Using y-axis.\");\n        referenceVector = new Vector3d(Y_AXIS);\n    }\n    // make sure reference vector is perpendicular principal roation vector\n    referenceVector = orthogonalize(principalRotationVector, referenceVector);\n}", "repo_id": "9", "comment": "/**\n * Returns a vector perpendicular to the principal rotation vector\n * for the alignment of structures in the xy-plane\n * @return reference vector\n */\n", "repo_name": "biojava-master/", "id": 1994, "method_signature": "void calcReferenceVector()"}, "1690": {"callee_method_names": [], "method_name": "AtomImpl.getPDBserial", "method_implementation": "{\n    return pdbserial;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1690, "method_signature": "int getPDBserial()"}, "3549": {"callee_method_names": [], "method_name": "CoxCoefficient.setPvalue", "method_implementation": "{\n    this.pvalue = pvalue;\n}", "repo_id": "9", "comment": "/**\n * @param pvalue the pvalue to set\n */\n", "repo_name": "biojava-master/", "id": 3549, "method_signature": "void setPvalue(double)"}, "2095": {"callee_method_names": ["List<Matrix4d>.add", "Matrix4d.getOperator"], "method_name": "SymmetryAxes.getElementaryAxes", "method_implementation": "{\n    List<Matrix4d> ops = new ArrayList<Matrix4d>(getNumLevels());\n    for (Axis axis : axes) {\n        ops.add(axis.getOperator());\n    }\n    return ops;\n}", "repo_id": "9", "comment": "/**\n * Return the operator for all elementary axes of symmetry of the structure, that is,\n * the axes stored in the List as unique and from which all the symmetry\n * axes are constructed.\n *\n * @return axes elementary axes of symmetry.\n */\n", "repo_name": "biojava-master/", "id": 2095, "method_signature": "List<Matrix4d> getElementaryAxes()"}, "2041": {"callee_method_ids": [489, 489, 489, 489], "callee_method_names": ["AFPChain.getOptAln", "AFPChain.getOptAln", "AFPChain.getOptAln", "AFPChain.getOptAln", "Graph<Integer, DefaultEdge>.addVertex", "Graph<Integer, DefaultEdge>.addVertex", "Graph<Integer, DefaultEdge>.addEdge"], "method_name": "SymmetryTools.buildSymmetryGraph", "method_implementation": "{\n    Graph<Integer, DefaultEdge> graph = new SimpleGraph<Integer, DefaultEdge>(DefaultEdge.class);\n    for (int i = 0; i < selfAlignment.getOptAln().length; i++) {\n        for (int j = 0; j < selfAlignment.getOptAln()[i][0].length; j++) {\n            Integer res1 = selfAlignment.getOptAln()[i][0][j];\n            Integer res2 = selfAlignment.getOptAln()[i][1][j];\n            graph.addVertex(res1);\n            graph.addVertex(res2);\n            graph.addEdge(res1, res2);\n        }\n    }\n    return graph;\n}", "repo_id": "9", "comment": "/**\n * Converts a self alignment into a directed jGraphT of aligned residues,\n * where each vertex is a residue and each edge means the equivalence\n * between the two residues in the self-alignment.\n *\n * @param selfAlignment\n *            AFPChain\n *\n * @return alignment Graph\n */\n", "repo_name": "biojava-master/", "id": 2041, "method_signature": "Graph<Integer,DefaultEdge> buildSymmetryGraph(AFPChain)"}, "2328": {"callee_method_ids": [628, 628, 628, 628, 628, 628, 628, 628], "callee_method_names": ["AtomCache.getStructure", "Structure.getPolyChains", "AtomCache.getStructure", "Structure.getPolyChains", "Structure.getChains", "Structure.getPolyChainByPDB", "Chain.getName", "Chain.getAtomLength", "Structure.getChainByIndex", "Structure.getChainByIndex", "Structure.getChainByIndex", "AtomCache.getStructure", "AtomCache.getStructure", "Structure.getPolyChains", "Structure.getPolyChainByPDB", "Chain.getName", "AtomCache.getStructure", "Structure.getPolyChains", "Structure.getChains", "Structure.getPolyChainByPDB", "Chain.getAtomLength", "AtomCache.getStructure", "Structure.getPolyChains", "Structure.getChains", "Structure.getPolyChainByPDB", "Chain.getAtomLength", "AtomCache.getStructure", "AtomCache.getStructure", "Structure.getPolyChains", "Structure.getPolyChainByPDB", "Chain.getName"], "method_name": "TestAtomCache.testAtomCacheNameParsing", "method_implementation": "{\n    String name1 = \"4hhb\";\n    Structure s = cache.getStructure(name1);\n    assertNotNull(s);\n    assertEquals(4, s.getPolyChains().size());\n    String name2 = \"4hhb.C\";\n    String chainId2 = \"C\";\n    s = cache.getStructure(name2);\n    assertEquals(1, s.getPolyChains().size());\n    // Chain name 'C' corresponds to three IDs: C (141 res), I (1 HEM), and M (59 water)\n    assertEquals(3, s.getChains().size());\n    Chain c = s.getPolyChainByPDB(chainId2);\n    assertEquals(chainId2, c.getName());\n    // Number of groups: Polymer + water + ligand\n    assertEquals(141, c.getAtomLength());\n    assertEquals(141, s.getChainByIndex(0).getAtomLength());\n    assertEquals(1, s.getChainByIndex(1).getAtomLength());\n    assertEquals(59, s.getChainByIndex(2).getAtomLength());\n    // Colon separators removed in BioJava 4.1.0\n    String name2b = \"4hhb:A\";\n    try {\n        s = cache.getStructure(name2b);\n        fail(\"Invalid structure format\");\n    } catch (StructureException e) {\n    }\n    // Numeric chain IDs are allowed but deprecated.\n    String name3 = \"4hhb.1\";\n    String chainId3 = \"B\";\n    s = cache.getStructure(name3);\n    assertNotNull(s);\n    assertEquals(1, s.getPolyChains().size());\n    c = s.getPolyChainByPDB(chainId3);\n    assertEquals(chainId3, c.getName());\n    String name4 = \"4hhb.A:10-20,B:10-20,C:10-20\";\n    s = cache.getStructure(name4);\n    assertNotNull(s);\n    assertEquals(3, s.getPolyChains().size());\n    assertEquals(3, s.getChains().size());\n    c = s.getPolyChainByPDB(\"B\");\n    assertEquals(11, c.getAtomLength());\n    String name5 = \"4hhb.(A:10-20,A:30-40)\";\n    s = cache.getStructure(name5);\n    assertNotNull(s);\n    assertEquals(1, s.getPolyChains().size());\n    // two chains: A (22 res), and G (1 HEM)\n    assertEquals(2, s.getChains().size());\n    c = s.getPolyChainByPDB(\"A\");\n    assertEquals(22, c.getAtomLength());\n    try {\n        // This syntax used to work, since the first paren is treated as a separator\n        String name6 = \"4hhb(A:10-20,A:30-40)\";\n        s = cache.getStructure(name6);\n        fail(\"A chain separator is required after the ID since 4.2.0\");\n    } catch (StructureException e) {\n    }\n    // Works since we detect a separator\n    String name8 = \"4hhb.(C)\";\n    s = cache.getStructure(name8);\n    assertEquals(1, s.getPolyChains().size());\n    c = s.getPolyChainByPDB(chainId2);\n    assertEquals(chainId2, c.getName());\n}", "repo_id": "9", "comment": "// TODO dmyersturnbull: Which of these syntaxes do we support? We should re-enable after\n", "repo_name": "biojava-master/", "id": 2328, "method_signature": "void testAtomCacheNameParsing()"}, "1907": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.getRmsdThreshold", "method_implementation": "{\n    return rmsdThreshold;\n}", "repo_id": "9", "comment": "/**\n * @return the rmsdThreshold\n */\n", "repo_name": "biojava-master/", "id": 1907, "method_signature": "double getRmsdThreshold()"}, "1504": {"callee_method_names": [], "method_name": "SuperPositionQCP.getRmsd", "method_implementation": "{\n    if (!rmsdCalculated) {\n        calcRmsd(x, y);\n        rmsdCalculated = true;\n    }\n    return rmsd;\n}", "repo_id": "9", "comment": "/**\n * Return the RMSD of the superposition of input coordinate set y onto x.\n * Note, this is the fasted way to calculate an RMSD without actually\n * superposing the two sets. The calculation is performed \"lazy\", meaning\n * calculations are only performed if necessary.\n *\n * @return root mean square deviation for superposition of y onto x\n */\n", "repo_name": "biojava-master/", "id": 1504, "method_signature": "double getRmsd()"}, "3741": {"callee_method_ids": [3698, 3698], "callee_method_names": ["String.equals", "LinkedHashMap.get", "LinkedHashMap.get", "LinkedHashMap.keySet", "String.equalsIgnoreCase", "LinkedHashMap.get", "LinkedHashMap.keySet", "String.equalsIgnoreCase", "LinkedHashMap.get", "HeaderInfo.getIndex", "HeaderInfo.getIndex", "CompactCharSequence.toString"], "method_name": "WorkSheet.getCell", "method_implementation": "{\n    if (col.equals(this.getIndexColumnName())) {\n        return row;\n    }\n    HeaderInfo rowIndex = rowLookup.get(row);\n    HeaderInfo colIndex = columnLookup.get(col);\n    if (rowIndex == null) {\n        //allow for case insentive search\n        for (String rowtable : rowLookup.keySet()) {\n            if (row.equalsIgnoreCase(rowtable)) {\n                rowIndex = rowLookup.get(rowtable);\n                break;\n            }\n        }\n        if (rowIndex == null) {\n            throw new Exception(\"Row \" + row + \" not found in worksheet\");\n        }\n    }\n    if (colIndex == null) {\n        //allow for case insentive search\n        for (String coltable : columnLookup.keySet()) {\n            if (col.equalsIgnoreCase(coltable)) {\n                colIndex = columnLookup.get(coltable);\n                break;\n            }\n        }\n        if (colIndex == null) {\n            throw new Exception(\"Column \" + col + \" not found in worksheet\");\n        }\n    }\n    CompactCharSequence ccs = data[rowIndex.getIndex()][colIndex.getIndex()];\n    if (ccs != null) {\n        return ccs.toString();\n    } else {\n        return \"\";\n    }\n    // return .toString();\n}", "repo_id": "9", "comment": "/**\n * Get cell value\n *\n * @param row\n * @param col\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3741, "method_signature": "String getCell(String, String)"}, "1685": {"callee_method_names": [], "method_name": "AugmentedResidueRange.contains", "method_implementation": "{\n    return super.contains(residueNumber, map);\n}", "repo_id": "9", "comment": "/**\n * @return True if and only if {@code residueNumber} is within this ResidueRange\n */\n", "repo_name": "biojava-master/", "id": 1685, "method_signature": "boolean contains(ResidueNumber)"}, "1858": {"callee_method_names": [], "method_name": "Rotation.setPermutation", "method_implementation": "{\n    this.permutation = permutation;\n}", "repo_id": "9", "comment": "/**\n * @param permutation the permutation to set\n */\n", "repo_name": "biojava-master/", "id": 1858, "method_signature": "void setPermutation(List)"}, "1388": {"callee_method_names": [], "method_name": "DBRef.getIdbnsEnd", "method_implementation": "{\n    return idbnsEnd;\n}", "repo_id": "9", "comment": "/**\n *  Insertion code of the ending\n * \tresidue of the segment, if PDB is\n * \tthe reference.\n *  @return idbnsEnd insertion code\n *  @see #setIdbnsEnd(char)\n */\n", "repo_name": "biojava-master/", "id": 1388, "method_signature": "char getIdbnsEnd()"}, "899": {"callee_method_names": [], "method_name": "AtomContactSet.hasContactsWithinDistance", "method_implementation": "{\n    if (distance >= cutoff)\n        throw new IllegalArgumentException(\"Given distance \" + String.format(\"%.2f\", distance) + \" is larger than contacts' distance cutoff \" + String.format(\"%.2f\", cutoff));\n    for (AtomContact contact : this.contacts.values()) {\n        if (contact.getDistance() < distance) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Returns true if at least 1 contact from this set is within the given distance.\n * Note that if the distance given is larger than the distance cutoff used to\n * calculate the contacts then nothing will be found.\n * @param distance\n * @return\n * @throws IllegalArgumentException if given distance is larger than distance cutoff\n * used for calculation of contacts\n */\n", "repo_name": "biojava-master/", "id": 899, "method_signature": "boolean hasContactsWithinDistance(double)"}, "3150": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.getLength", "method_implementation": "{\n    return sequenceLength;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3150, "method_signature": "int getLength()"}, "367": {"callee_method_names": ["Chain.getAtomGroups"], "method_name": "Calc.transform", "method_implementation": "{\n    for (Group g : chain.getAtomGroups()) {\n        transform(g, m);\n    }\n}", "repo_id": "9", "comment": "/**\n * Transforms a chain object, given a Matrix4d (i.e. the vecmath library\n * double-precision 4x4 rotation+translation matrix). The transformation\n * Matrix must be a post-multiplication Matrix.\n *\n * @param chain\n * @param m\n */\n", "repo_name": "biojava-master/", "id": 367, "method_signature": "void transform(Chain, Matrix4d)"}, "3441": {"callee_method_names": ["StructureViewer.setColor"], "method_name": "StructureViewerTest.testSetColor", "method_implementation": "{\n    if (java.awt.GraphicsEnvironment.isHeadless())\n        return;\n    Color red = null;\n    StructureViewer instance = new StructureViewerImpl();\n    instance.setColor(red);\n    // TODO review the generated test code and remove the default call to fail.\n    //fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of setColor method, of class StructureViewer.\n */\n", "repo_name": "biojava-master/", "id": 3441, "method_signature": "void testSetColor()"}, "1744": {"callee_method_names": ["String.length", "String.length", "String.charAt", "String.charAt", "String.length", "String.length", "String.substring"], "method_name": "BasePairParameters.longestCommonSubstring", "method_implementation": "{\n    int start = 0;\n    int max = 0;\n    for (int i = 0; i < s1.length(); i++) {\n        for (int j = 0; j < s2.length(); j++) {\n            int x = 0;\n            while (s1.charAt(i + x) == s2.charAt(j + x)) {\n                x++;\n                if (((i + x) >= s1.length()) || ((j + x) >= s2.length()))\n                    break;\n            }\n            if (x > max) {\n                max = x;\n                start = i;\n            }\n        }\n    }\n    return s1.substring(start, (start + max));\n}", "repo_id": "9", "comment": "/**\n * This method finds the longest common substring between two strings. (used internally)\n * @param s1 The first string\n * @param s2 The second string\n * @return The substring itself\n */\n", "repo_name": "biojava-master/", "id": 1744, "method_signature": "String longestCommonSubstring(String, String)"}, "1360": {"callee_method_names": [], "method_name": "AminoAcidImpl.setRecordType", "method_implementation": "{\n    recordType = recordName;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1360, "method_signature": "void setRecordType(String)"}, "2497": {"callee_method_ids": [2436, 2440, 2436, 2440, 2438, 2438, 2438, 2438, 2431, 2431, 2431, 2431, 2448, 3181, 3067, 2459, 2454, 2454, 3169, 2456, 2455], "callee_method_names": ["FeatureList.attributeValues", "FeatureList.selectByAttribute", "FeatureList.get", "LinkedHashMap<String,ChromosomeSequence>.get", "FeatureI.seqname", "FeatureList.attributeValues", "FeatureList.selectByAttribute", "FeatureList.selectByType", "FeatureList.selectByType", "FeatureList.selectByType", "FeatureList.selectByType", "FeatureList.add", "FeatureList.add", "FeatureList.add", "FeatureList.add", "FeatureList.sortByStart", "FeatureList.get", "FeatureI.location", "FeatureList.get", "FeatureI.location", "FeatureI.location", "FeatureList.get", "FeatureList.size", "FeatureI.location", "FeatureI.location", "ChromosomeSequence.addGene", "GeneSequence.setSource", "GeneSequence.getBioBegin", "GeneSequence.setBioBegin", "GeneSequence.getBioBegin", "GeneSequence.setBioEnd", "GeneSequence.addTranscript", "Feature.getAttribute", "String.length", "Feature.location", "Feature.location", "TranscriptSequence.addCDS", "Feature.frame", "CDSSequence.setSequenceScore", "Feature.score"], "method_name": "GeneFeatureHelper.addGeneIDGFF2GeneFeatures", "method_implementation": "{\n    Collection<String> geneIds = listGenes.attributeValues(\"gene_id\");\n    for (String geneid : geneIds) {\n        FeatureList gene = listGenes.selectByAttribute(\"gene_id\", geneid);\n        FeatureI geneFeature = gene.get(0);\n        ChromosomeSequence seq = chromosomeSequenceList.get(geneFeature.seqname());\n        geneid = geneid.replaceAll(\"_\", \".G\");\n        AccessionID geneAccessionID = new AccessionID(geneid);\n        GeneSequence geneSequence = null;\n        Collection<String> transcriptids = gene.attributeValues(\"gene_id\");\n        for (String transcriptid : transcriptids) {\n            // get all the individual features (exons, CDS regions, etc.) of this gene\n            FeatureList transcriptFeature = listGenes.selectByAttribute(\"gene_id\", transcriptid);\n            transcriptid = transcriptid.replaceAll(\"_\", \".G\");\n            //      String seqName = feature.seqname();\n            //FeatureI startCodon = null;\n            //FeatureI stopCodon = null;\n            Integer startCodonBegin = null;\n            Integer stopCodonEnd = null;\n            //String startCodonName = \"\";\n            //String stopCodonName = \"\";\n            // now select only the coding regions of this gene\n            FeatureList firstFeatures = transcriptFeature.selectByType(\"First\");\n            FeatureList terminalFeatures = transcriptFeature.selectByType(\"Terminal\");\n            FeatureList internalFeatures = transcriptFeature.selectByType(\"Internal\");\n            FeatureList singleFeatures = transcriptFeature.selectByType(\"Single\");\n            FeatureList cdsFeatures = new FeatureList();\n            cdsFeatures.add(firstFeatures);\n            cdsFeatures.add(terminalFeatures);\n            cdsFeatures.add(internalFeatures);\n            cdsFeatures.add(singleFeatures);\n            // sort them\n            cdsFeatures = cdsFeatures.sortByStart();\n            Strand strand = Strand.POSITIVE;\n            FeatureI feature = cdsFeatures.get(0);\n            if (feature.location().isNegative()) {\n                strand = Strand.NEGATIVE;\n            }\n            if (startCodonBegin == null) {\n                FeatureI firstFeature = cdsFeatures.get(0);\n                if (strand == Strand.NEGATIVE) {\n                    startCodonBegin = firstFeature.location().bioEnd();\n                } else {\n                    startCodonBegin = firstFeature.location().bioStart();\n                }\n            }\n            if (stopCodonEnd == null) {\n                FeatureI lastFeature = cdsFeatures.get(cdsFeatures.size() - 1);\n                if (strand == Strand.NEGATIVE) {\n                    stopCodonEnd = lastFeature.location().bioStart();\n                } else {\n                    stopCodonEnd = lastFeature.location().bioEnd();\n                }\n            }\n            //for gtf ordering can be strand based so first is last and last is first\n            if (startCodonBegin > stopCodonEnd) {\n                int temp = startCodonBegin;\n                startCodonBegin = stopCodonEnd;\n                stopCodonEnd = temp;\n            }\n            AccessionID transcriptAccessionID = new AccessionID(transcriptid);\n            if (geneSequence == null) {\n                geneSequence = seq.addGene(geneAccessionID, startCodonBegin, stopCodonEnd, strand);\n                geneSequence.setSource(((Feature) feature).source());\n            } else {\n                //if multiple transcripts for one gene make sure the gene is defined as the min and max start/end\n                if (startCodonBegin < geneSequence.getBioBegin()) {\n                    geneSequence.setBioBegin(startCodonBegin);\n                }\n                if (stopCodonEnd > geneSequence.getBioBegin()) {\n                    geneSequence.setBioEnd(stopCodonEnd);\n                }\n            }\n            TranscriptSequence transcriptSequence = geneSequence.addTranscript(transcriptAccessionID, startCodonBegin, stopCodonEnd);\n            /*\n\t\t\t\tif (startCodon != null) {\n\t\t\t\t\tif (startCodonName == null || startCodonName.length() == 0) {\n\t\t\t\t\t\tstartCodonName = transcriptid + \"-start_codon-\" + startCodon.location().bioStart() + \"-\" + startCodon.location().bioEnd();\n\t\t\t\t\t}\n\t\t\t\t\ttranscriptSequence.addStartCodonSequence(new AccessionID(startCodonName), startCodon.location().bioStart(), startCodon.location().bioEnd());\n\t\t\t\t}\n\t\t\t\tif (stopCodon != null) {\n\t\t\t\t\tif (stopCodonName == null || stopCodonName.length() == 0) {\n\t\t\t\t\t\tstopCodonName = transcriptid + \"-stop_codon-\" + stopCodon.location().bioStart() + \"-\" + stopCodon.location().bioEnd();\n\t\t\t\t\t}\n\t\t\t\t\ttranscriptSequence.addStopCodonSequence(new AccessionID(stopCodonName), stopCodon.location().bioStart(), stopCodon.location().bioEnd());\n\t\t\t\t}\n\t\t\t\t*/\n            for (FeatureI cdsFeature : cdsFeatures) {\n                Feature cds = (Feature) cdsFeature;\n                String cdsName = cds.getAttribute(\"transcript_name\");\n                if (cdsName == null || cdsName.length() == 0) {\n                    cdsName = transcriptid + \"-cds-\" + cds.location().bioStart() + \"-\" + cds.location().bioEnd();\n                }\n                AccessionID cdsAccessionID = new AccessionID(cdsName);\n                //ExonSequence exonSequence = geneSequence.addExon(cdsAccessionID, cdsFeature.location().bioStart(), cdsFeature.location().bioEnd());\n                CDSSequence cdsSequence = transcriptSequence.addCDS(cdsAccessionID, cdsFeature.location().bioStart(), cdsFeature.location().bioEnd(), cds.frame());\n                cdsSequence.setSequenceScore(cds.score());\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Load GFF2 feature file generated from the geneid prediction algorithm and map features onto the chromosome sequences\n *\n * @param chromosomeSequenceList\n * @param listGenes\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2497, "method_signature": "void addGeneIDGFF2GeneFeatures(LinkedHashMap, FeatureList)"}, "3554": {"callee_method_names": ["LinkedHashMap.put"], "method_name": "CoxVariables.putCoxInfo", "method_implementation": "{\n    coxInfoHashMap.put(name, coxInfo);\n}", "repo_id": "9", "comment": "/**\n * @param name\n * @param coxInfo\n */\n", "repo_name": "biojava-master/", "id": 3554, "method_signature": "void putCoxInfo(String, CoxInfo)"}, "2076": {"callee_method_names": ["MultipleAlignment.clear", "MultipleAlignment.getBlock", "Block.setAlignRes", "Block.getCoreLength"], "method_name": "SymmOptimizer.updateMultipleAlignment", "method_implementation": "{\n    msa.clear();\n    // Override the alignment with the new information\n    Block b = msa.getBlock(0);\n    b.setAlignRes(block);\n    repeatCore = b.getCoreLength();\n    if (repeatCore < 1)\n        throw new RefinerFailedException(\"Optimization converged to length 0\");\n    SymmetryTools.updateSymmetryTransformation(axes, msa);\n}", "repo_id": "9", "comment": "/**\n * This method translates the internal data structures to a\n * MultipleAlignment of the repeats in order to use the methods to score\n * MultipleAlignments.\n *\n * @throws StructureException\n * @throws RefinerFailedException\n */\n", "repo_name": "biojava-master/", "id": 2076, "method_signature": "void updateMultipleAlignment()"}, "2620": {"callee_method_names": ["DocumentBuilderFactory.newDocumentBuilder", "DocumentBuilder.parse", "String.getBytes", "DocumentBuilder.parse", "String.getBytes", "Logger.error", "Logger.error", "Logger.error", "Document.getDoctype", "Document.getDoctype", "DocumentType.getNotations", "DocumentType.getNotations", "NamedNodeMap.getLength", "NamedNodeMap.getLength", "NamedNodeMap.getLength", "NamedNodeMap.item", "Node.isEqualNode"], "method_name": "StringManipulationHelper.equalsToXml", "method_implementation": "{\n    Document expectedDocument = null;\n    Document actualDocument = null;\n    try {\n        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        expectedDocument = documentBuilder.parse(new ByteArrayInputStream(expected.getBytes()));\n        actualDocument = documentBuilder.parse(new ByteArrayInputStream(actual.getBytes()));\n    } catch (ParserConfigurationException e) {\n        logger.error(\"Exception: \", e);\n        throw new RuntimeException(\"Couldn't Parse XML\", e);\n    } catch (SAXException e) {\n        logger.error(\"Exception: \", e);\n        throw new RuntimeException(\"Couldn't Parse XML\", e);\n    } catch (IOException e) {\n        logger.error(\"Exception: \", e);\n        throw new RuntimeException(\"Couldn't Parse XML\", e);\n    }\n    final DocumentType doctype1 = expectedDocument.getDoctype();\n    final DocumentType doctype2 = actualDocument.getDoctype();\n    if (doctype1 == null ^ doctype2 == null) {\n        return false;\n    } else if (doctype1 != null) /*&& doctype2 != null*/\n    {\n        NamedNodeMap expectedNotations = doctype1.getNotations();\n        NamedNodeMap actualNotations = doctype2.getNotations();\n        if (expectedNotations.getLength() == actualNotations.getLength()) {\n            for (int i = 0; i < expectedNotations.getLength(); i++) {\n                Node node = expectedNotations.item(i);\n                node.isEqualNode(null);\n            }\n        } else {\n            return false;\n        }\n    }\n    throw new UnsupportedOperationException(\"not yet implemented\");\n}", "repo_id": "9", "comment": "/**\n * This method is not implemented or used, never returns true\n * and should probably be removed.\n * @param expected\n * @param actual\n * @return\n * @throws UnsupportedOperationException in most cases\n */\n", "repo_name": "biojava-master/", "id": 2620, "method_signature": "boolean equalsToXml(String, String)"}, "3789": {"callee_method_names": [], "method_name": "KaplanMeierFigure.setFigureLineInfo", "method_implementation": "{\n    this.lineInfoList = lineInfoList;\n    this.repaint();\n}", "repo_id": "9", "comment": "/**\n * @param lineInfoList\n */\n", "repo_name": "biojava-master/", "id": 3789, "method_signature": "void setFigureLineInfo(ArrayList)"}, "671": {"callee_method_names": ["StringWriter.append", "MultipleAlignment.toString", "List<String>.get", "String.concat", "String.concat", "MultipleAlignment.size", "StringWriter.append", "List<String>.get", "StringWriter.append", "List<String>.get", "MultipleAlignment.size", "StringWriter.append", "StringWriter.toString"], "method_name": "MultipleAlignmentWriter.toFatCat", "method_implementation": "{\n    // Initialize the String and put the summary information\n    StringWriter fatcat = new StringWriter();\n    fatcat.append(alignment.toString() + \"\\n\\n\");\n    // Get the alignment sequences and the mapping\n    List<Integer> mapSeqToStruct = new ArrayList<Integer>();\n    List<String> alnSequences = MultipleAlignmentTools.getSequenceAlignment(alignment, mapSeqToStruct);\n    // Get the String of the Block Numbers for Position\n    String blockNumbers = \"\";\n    for (int pos = 0; pos < alnSequences.get(0).length(); pos++) {\n        int blockNr = MultipleAlignmentTools.getBlockForSequencePosition(alignment, mapSeqToStruct, pos);\n        if (blockNr != -1) {\n            blockNumbers = blockNumbers.concat(String.valueOf(blockNr + 1));\n        } else\n            blockNumbers = blockNumbers.concat(\" \");\n    }\n    // Write the Sequence Alignment\n    for (int str = 0; str < alignment.size(); str++) {\n        if (str < 9) {\n            fatcat.append(\"Chain 0\" + (str + 1) + \": \" + alnSequences.get(str) + \"\\n\");\n        } else {\n            fatcat.append(\"Chain \" + (str + 1) + \": \" + alnSequences.get(str) + \"\\n\");\n        }\n        if (str != alignment.size() - 1) {\n            fatcat.append(\"          \" + blockNumbers + \"\\n\");\n        }\n    }\n    return fatcat.toString();\n}", "repo_id": "9", "comment": "/**\n * Converts the {@link MultipleAlignment} into a FatCat String format.\n * Includes summary information about the alignment in the top and a\n * multiple sequence alignment at the bottom.\n *\n * @param alignment\n *            MultipleAlignment\n * @return String multiple sequence alignment in FASTA format\n * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n */\n", "repo_name": "biojava-master/", "id": 671, "method_signature": "String toFatCat(MultipleAlignment)"}, "1952": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getRmsdIntra", "method_implementation": "{\n    return rmsdIntra;\n}", "repo_id": "9", "comment": "/**\n * @return the rmsdIntra\n */\n", "repo_name": "biojava-master/", "id": 1952, "method_signature": "double getRmsdIntra()"}, "3691": {"callee_method_names": [], "method_name": "SurvFitInfo.getUnweightedStrataInfoHashMap", "method_implementation": "{\n    return unweightedStrataInfoHashMap;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3691, "method_signature": "LinkedHashMap<String,StrataInfo> getUnweightedStrataInfoHashMap()"}, "2104": {"callee_method_names": ["List<Axis>.subList", "Matrix4d.getOrder"], "method_name": "SymmetryAxes.getNumRepeats", "method_implementation": "{\n    int size = 1;\n    // Return 1 for illegally high level\n    if (level < getNumLevels()) {\n        for (Axis axis : axes.subList(level, getNumLevels())) {\n            size *= axis.getOrder();\n        }\n    }\n    return size;\n}", "repo_id": "9", "comment": "/**\n * Get the number of leaves from a node at the specified level. This is\n * equal to the product of all degrees at or below the level.\n * @param level level of the tree to cut at\n * @return Number of repeats (leaves of the tree).\n */\n", "repo_name": "biojava-master/", "id": 2104, "method_signature": "int getNumRepeats(int)"}, "3128": {"callee_method_names": ["Document.getDocumentElement", "Element.getTextContent", "ArrayList<AccessionID>.add"], "method_name": "UniprotProxySequenceReader.getAccessions", "method_implementation": "{\n    ArrayList<AccessionID> accessionList = new ArrayList<AccessionID>();\n    if (uniprotDoc == null) {\n        return accessionList;\n    }\n    Element uniprotElement = uniprotDoc.getDocumentElement();\n    Element entryElement = XMLHelper.selectSingleElement(uniprotElement, \"entry\");\n    ArrayList<Element> keyWordElementList = XMLHelper.selectElements(entryElement, \"accession\");\n    for (Element element : keyWordElementList) {\n        AccessionID accessionID = new AccessionID(element.getTextContent(), DataSource.UNIPROT);\n        accessionList.add(accessionID);\n    }\n    return accessionList;\n}", "repo_id": "9", "comment": "/**\n * Pull uniprot accessions associated with this sequence\n * @return\n * @throws XPathExpressionException\n */\n", "repo_name": "biojava-master/", "id": 3128, "method_signature": "ArrayList<AccessionID> getAccessions()"}, "1715": {"callee_method_names": ["String.split", "List<ResidueRangeAndLength>.add"], "method_name": "ResidueRangeAndLength.parseMultiple", "method_implementation": "{\n    String[] parts = s.split(\",\");\n    List<ResidueRangeAndLength> list = new ArrayList<ResidueRangeAndLength>(parts.length);\n    for (String part : parts) {\n        list.add(parse(part, map));\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * @param s\n *            A string of the form chain_start-end,chain_start-end, ... For example:\n *            <code>A.5-100,R_110-190,Z_200-250</code>.\n * @return The unique ResidueRange corresponding to {@code s}.\n */\n", "repo_name": "biojava-master/", "id": 1715, "method_signature": "List<ResidueRangeAndLength> parseMultiple(String, AtomPositionMap)"}, "1656": {"callee_method_names": [], "method_name": "SubunitCluster.getSubunits", "method_implementation": "{\n    return Collections.unmodifiableList(subunits);\n}", "repo_id": "9", "comment": "/**\n * Subunits contained in the SubunitCluster.\n *\n * @return an unmodifiable view of the original List\n */\n", "repo_name": "biojava-master/", "id": 1656, "method_signature": "List<Subunit> getSubunits()"}, "1165": {"callee_method_ids": [1317], "callee_method_names": ["FileParsingParameters.isHeaderOnly", "String.length", "Logger.info", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "List<Map<String, String>>.add"], "method_name": "PDBFileParser.pdb_SHEET_Handler", "method_implementation": "{\n    if (params.isHeaderOnly())\n        return;\n    if (line.length() < 38) {\n        logger.info(\"SHEET line has length under 38. Ignoring it.\");\n        return;\n    }\n    String initResName = line.substring(17, 20).trim();\n    String initChainId = line.substring(21, 22);\n    String initSeqNum = line.substring(22, 26).trim();\n    String initICode = line.substring(26, 27);\n    String endResName = line.substring(28, 31).trim();\n    String endChainId = line.substring(32, 33);\n    String endSeqNum = line.substring(33, 37).trim();\n    String endICode = line.substring(37, 38);\n    //System.out.println(initResName + \" \" + initChainId + \" \" + initSeqNum + \" \" + initICode + \" \" +\n    //        endResName + \" \" + endChainId + \" \" + endSeqNum + \" \" + endICode);\n    Map<String, String> m = new HashMap<String, String>();\n    m.put(\"initResName\", initResName);\n    m.put(\"initChainId\", initChainId);\n    m.put(\"initSeqNum\", initSeqNum);\n    m.put(\"initICode\", initICode);\n    m.put(\"endResName\", endResName);\n    m.put(\"endChainId\", endChainId);\n    m.put(\"endSeqNum\", endSeqNum);\n    m.put(\"endICode\", endICode);\n    strandList.add(m);\n}", "repo_id": "9", "comment": "/**\n * Handler for\n * <pre>\n *       COLUMNS     DATA TYPE        FIELD           DEFINITION\n * --------------------------------------------------------------\n *  1 -  6     Record name      \"SHEET \"\n *  8 - 10     Integer          strand       Strand number which starts at 1\n *                                           for each strand within a sheet\n *                                           and increases by one.\n * 12 - 14     LString(3)       sheetID      Sheet identifier.\n * 15 - 16     Integer          numStrands   Number of strands in sheet.\n * 18 - 20     Residue name     initResName  Residue name of initial residue.\n * 22          Character        initChainID  Chain identifier of initial\n *                                           residue in strand.\n * 23 - 26     Integer          initSeqNum   Sequence number of initial\n *                                           residue in strand.\n * 27          AChar            initICode    Insertion code of initial residue\n *                                           in strand.\n * 29 - 31     Residue name     endResName   Residue name of terminal residue.\n * 33          Character        endChainID   Chain identifier of terminal\n *                                           residue.\n * 34 - 37     Integer          endSeqNum    Sequence number of terminal\n *                                           residue.\n * 38          AChar            endICode     Insertion code of terminal\n *                                           residue.\n * 39 - 40     Integer          sense        Sense of strand with respect to\n *                                           previous strand in the sheet. 0\n *                                           if first strand, 1 if parallel,\n *                                           -1 if anti-parallel.\n * 42 - 45     Atom             curAtom      Registration. Atom name in\n *                                           current strand.\n * 46 - 48     Residue name     curResName   Registration. Residue name in\n *                                           current strand.\n * 50          Character        curChainId   Registration. Chain identifier in\n *                                           current strand.\n * 51 - 54     Integer          curResSeq    Registration. Residue sequence\n *                                           number in current strand.\n * 55          AChar            curICode     Registration. Insertion code in\n *                                           current strand.\n * 57 - 60     Atom             prevAtom     Registration. Atom name in\n *                                           previous strand.\n * 61 - 63     Residue name     prevResName  Registration. Residue name in\n *                                           previous strand.\n * 65          Character        prevChainId  Registration. Chain identifier in\n *                                           previous strand.\n * 66 - 69     Integer          prevResSeq   Registration. Residue sequence\n *                                           number in previous strand.\n * 70          AChar            prevICode    Registration. Insertion code in\n *                                               previous strand.\n * </pre>\n */\n", "repo_name": "biojava-master/", "id": 1165, "method_signature": "void pdb_SHEET_Handler(String)"}, "769": {"callee_method_names": [], "method_name": "StartupParameters.setPdb2", "method_implementation": "{\n    this.pdb2 = pdb2;\n}", "repo_id": "9", "comment": "/**\n * mandatory argument to set the second PDB (and optionally chain ID) to be aligned.\n *  @param pdb2\n */\n", "repo_name": "biojava-master/", "id": 769, "method_signature": "void setPdb2(String)"}, "3430": {"callee_method_ids": [2053, 3274, 3273, 3271, 3271, 3274, 3271, 3271, 570, 3271], "callee_method_names": ["CeSymmResult.isSignificant", "CeSymmResult.isRefined", "CeSymmResult.getMultipleAlignment", "MultipleAlignment.getAtomArrays", "List<Atom[]>.get", "List<Group>.size", "List<Group>.size", "List<Group>.size", "List<Group>.get", "MultipleAlignment.size", "List<Atom[]>.set", "AbstractAlignmentJmol.setTitle", "AbstractAlignmentJmol.getStructure", "AbstractAlignmentJmol.evalString", "AbstractAlignmentJmol.evalString", "AbstractAlignmentJmol.setTitle", "AbstractAlignmentJmol.evalString", "Logger.info", "CeSymmResult.getAtoms", "CeSymmResult.getSelfAlignment", "CeSymmResult.getAtoms", "CeSymmResult.getSelfAlignment", "AbstractAlignmentJmol.evalString", "RotationAxis.getJmolScript", "CeSymmResult.getAtoms", "AbstractAlignmentJmol.evalString"], "method_name": "SymmetryDisplay.display", "method_implementation": "{\n    if (symmResult.isSignificant() && symmResult.isRefined()) {\n        // Show the structure colored by repeat (do not rotate)\n        MultipleAlignment msa = symmResult.getMultipleAlignment();\n        List<Atom[]> atoms = msa.getAtomArrays();\n        // Add non polymer protein groups\n        Atom[] allAtoms = atoms.get(0);\n        List<Group> hetatms = StructureTools.getUnalignedGroups(allAtoms);\n        allAtoms = Arrays.copyOf(allAtoms, allAtoms.length + hetatms.size());\n        for (int h = 0; h < hetatms.size(); h++) {\n            int index = (allAtoms.length - hetatms.size()) + h;\n            allAtoms[index] = hetatms.get(h).getAtom(0);\n        }\n        for (int s = 0; s < msa.size(); s++) atoms.set(s, allAtoms);\n        MultipleAlignmentJmol jmol = new MultipleAlignmentJmol(msa, atoms);\n        jmol.setTitle(jmol.getStructure().getPDBHeader().getTitle());\n        addSymmetryMenu(jmol, symmResult);\n        jmol.evalString(printSymmetryGroup(symmResult));\n        jmol.evalString(printSymmetryAxes(symmResult));\n        jmol.setTitle(getSymmTitle(symmResult));\n        jmol.evalString(\"save STATE state_1\");\n        return jmol;\n    } else {\n        // Show the optimal self-alignment\n        logger.info(\"Showing optimal self-alignment\");\n        Atom[] cloned = StructureTools.cloneAtomArray(symmResult.getAtoms());\n        AbstractAlignmentJmol jmol = StructureAlignmentDisplay.display(symmResult.getSelfAlignment(), symmResult.getAtoms(), cloned);\n        RotationAxis axis = new RotationAxis(symmResult.getSelfAlignment());\n        jmol.evalString(axis.getJmolScript(symmResult.getAtoms()));\n        jmol.evalString(\"save STATE state_1\");\n        return jmol;\n    }\n}", "repo_id": "9", "comment": "/**\n * Displays a single structure in a cartoon representation with each\n * symmetric repeat colored differently.\n *\n * @param msa\n *            the symmetry multiple alignment obtained from CeSymm\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3430, "method_signature": "AbstractAlignmentJmol display(CeSymmResult)"}, "2434": {"callee_method_ids": [2415, 2399, 2400], "callee_method_names": ["FeatureI.location", "Location.startsAfter", "StringBuilder.append", "DNASequence.getSubSequence", "Location.start", "Location.end", "StringBuilder.toString"], "method_name": "FeatureList.splice", "method_implementation": "{\n    StringBuilder subData = new StringBuilder();\n    Location last = null;\n    for (FeatureI f : this) {\n        Location loc = f.location();\n        if (last == null || loc.startsAfter(last)) {\n            subData.append(sequence.getSubSequence(loc.start(), loc.end()).toString());\n            last = loc;\n        } else {\n            throw new IllegalStateException(\"Splice: Feature locations should not overlap.\");\n        }\n    }\n    return subData.toString();\n}", "repo_id": "9", "comment": "/**\n * Concatenate successive portions of the specified sequence\n * using the feature locations in the list. The list is assumed to be appropriately\n * ordered.\n *\n * @param sequence The source sequence from which portions should be selected.\n * @return The spliced data.\n * @throws IllegalStateException Out of order or overlapping FeatureI locations detected.\n */\n", "repo_name": "biojava-master/", "id": 2434, "method_signature": "String splice(DNASequence)"}, "1483": {"callee_method_names": [], "method_name": "MomentsOfInertia.getOrientationMatrix", "method_implementation": "{\n    if (modified) {\n        diagonalizeTensor();\n        modified = false;\n    }\n    return orientation;\n}", "repo_id": "9", "comment": "/**\n * The orientation Matrix is a 3x3 Matrix with a column for each principal\n * axis. It represents the orientation (rotation) of the principal axes with\n * respect to the axes of the coordinate system (unit vectors [1,0,0],\n * [0,1,0] and [0,0,1]).\n * <p>\n * The orientation matrix indicates the rotation to bring the coordinate\n * axes to the principal axes, in this direction.\n *\n * @return the orientation Matrix as a Matrix3d object\n */\n", "repo_name": "biojava-master/", "id": 1483, "method_signature": "Matrix3d getOrientationMatrix()"}, "3541": {"callee_method_names": [], "method_name": "CoxCoefficient.setName", "method_implementation": "{\n    this.name = name;\n}", "repo_id": "9", "comment": "/**\n * @param name the name to set\n */\n", "repo_name": "biojava-master/", "id": 3541, "method_signature": "void setName(String)"}, "2947": {"callee_method_names": [], "method_name": "AbstractSequence.getSubSequence", "method_implementation": "{\n    return new SequenceProxyView<C>(this, bioStart, bioEnd);\n}", "repo_id": "9", "comment": "/**\n * @param bioStart\n * @param bioEnd\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2947, "method_signature": "SequenceView<C> getSubSequence(Integer, Integer)"}, "1591": {"callee_method_names": ["Ladder.equals"], "method_name": "SecStrucCalc.hasBulge", "method_implementation": "{\n    boolean bulge = ((l1.btype.equals(l2.btype)) && (l2.from - l1.to < 6) && (l1.to < l2.from) && (l2.connectedTo == 0));\n    if (!bulge)\n        return bulge;\n    switch(l1.btype) {\n        case parallel:\n            bulge = ((l2.lfrom - l1.lto > 0) && (((l2.lfrom - l1.lto < 6) && (l2.from - l1.to < 3)) || (l2.lfrom - l1.lto < 3)));\n            break;\n        case antiparallel:\n            bulge = ((l1.lfrom - l2.lto > 0) && (((l1.lfrom - l2.lto < 6) && (l2.from - l1.to < 3)) || (l1.lfrom - l2.lto < 3)));\n            break;\n    }\n    return bulge;\n}", "repo_id": "9", "comment": "/**\n * For beta structures, we define explicitly: a bulge-linked\n * ladder consists of two (perfect) ladder or bridges of the\n * same type connected by at most one extra residue on one\n * strand and at most four extra residues on the other strand,\n * all residues in bulge-linked ladders are marked \"E,\"\n * including the extra residues.\n */\n", "repo_name": "biojava-master/", "id": 1591, "method_signature": "boolean hasBulge(Ladder, Ladder)"}, "2523": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum45", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum45\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 45 matrix by Henikoff & Henikoff\n * @return Blosum 45 matrix\n */\n", "repo_name": "biojava-master/", "id": 2523, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum45()"}, "1539": {"callee_method_names": [], "method_name": "Astral.getFailedLines", "method_implementation": "{\n    return failedLines;\n}", "repo_id": "9", "comment": "/**\n * Gets a map describing lines read in the file that weren't understood.\n * @return A LinkedHashMap mapping line numbers of failures to the lines themselves\n */\n", "repo_name": "biojava-master/", "id": 1539, "method_signature": "LinkedHashMap<Integer,String> getFailedLines()"}, "3542": {"callee_method_names": [], "method_name": "CoxCoefficient.setCoeff", "method_implementation": "{\n    this.coeff = coeff;\n}", "repo_id": "9", "comment": "/**\n * @param coeff the coeff to set\n */\n", "repo_name": "biojava-master/", "id": 3542, "method_signature": "void setCoeff(double)"}, "487": {"callee_method_names": [], "method_name": "AFPChain.getBlockNum", "method_implementation": "{\n    return blockNum;\n}", "repo_id": "9", "comment": "/**\n * The number of blocks in the alignment\n *\n * @return the nr of blocks in alignment\n */\n", "repo_name": "biojava-master/", "id": 487, "method_signature": "int getBlockNum()"}, "3823": {"callee_method_ids": [3753], "callee_method_names": ["WorkSheet.getDiscreteColumnValues"], "method_name": "MetaDataInfo.setDiscreteValues", "method_implementation": "{\n    discreteValues = worksheet.getDiscreteColumnValues(column);\n}", "repo_id": "9", "comment": "/**\n * @param worksheet\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3823, "method_signature": "void setDiscreteValues(WorkSheet)"}, "2160": {"callee_method_names": ["PDBHeader.getCrystallographicInfo"], "method_name": "StructureImpl.getCrystallographicInfo", "method_implementation": "{\n    return pdbHeader.getCrystallographicInfo();\n}", "repo_id": "9", "comment": "/**\n * Gets crystallographic information for this structure\n * @return PDBCrystallographicInfo crystallographic information\n * @since 3.2\n */\n", "repo_name": "biojava-master/", "id": 2160, "method_signature": "PDBCrystallographicInfo getCrystallographicInfo()"}, "1055": {"callee_method_names": ["Structure.nrModels", "Structure.setPdbId", "Structure.getPdbId", "Structure.setName", "Structure.getName", "Structure.setPDBHeader", "Structure.getPDBHeader", "Structure.setDBRefs", "Structure.getDBRefs", "Structure.setSites", "Structure.getSites", "Structure.setChains", "Structure.getModel"], "method_name": "StructureTools.removeModels", "method_implementation": "{\n    if (s.nrModels() == 1)\n        return s;\n    Structure n = new StructureImpl();\n    // go through whole substructure and clone ...\n    // copy structure data\n    n.setPdbId(s.getPdbId());\n    n.setName(s.getName());\n    // TODO: do deep copying of data!\n    n.setPDBHeader(s.getPDBHeader());\n    n.setDBRefs(s.getDBRefs());\n    n.setSites(s.getSites());\n    n.setChains(s.getModel(0));\n    return n;\n}", "repo_id": "9", "comment": "/**\n * Remove all models from a Structure and keep only the first\n *\n * @param s\n *            original Structure\n * @return a structure that contains only the first model\n * @since 3.0.5\n */\n", "repo_name": "biojava-master/", "id": 1055, "method_signature": "Structure removeModels(Structure)"}, "1426": {"callee_method_names": [], "method_name": "CrystalTransform.isIdentity", "method_implementation": "{\n    return (transformId == 0 && crystalTranslation.x == 0 && crystalTranslation.y == 0 && crystalTranslation.z == 0);\n}", "repo_id": "9", "comment": "/**\n * Tells whether this transformation is the identity: no rotation and no translation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1426, "method_signature": "boolean isIdentity()"}, "2505": {"callee_method_names": ["Logger.info", "Logger.info", "Logger.info"], "method_name": "UncompressFile.main", "method_implementation": "{\n    if (args.length != 1) {\n        logger.info(\"Usage: UncompressInputStream <file>\");\n        System.exit(1);\n    }\n    long beg = System.currentTimeMillis();\n    long tot;\n    try (InputStream in = new FileInputStream(args[0])) {\n        tot = UncompressInputStream.uncompress(in, System.out);\n    }\n    long end = System.currentTimeMillis();\n    logger.info(\"Decompressed {} bytes\", tot);\n    logger.info(\"Time: {} seconds\", (end - beg) / 1000);\n}", "repo_id": "9", "comment": "/**\n * Reads a file, uncompresses it, and sends the result to stdout.\n * Also writes trivial statistics to stderr.\n * @param args An array with one String element, the name of the file to read.\n * @throws IOException for any failure\n */\n", "repo_name": "biojava-master/", "id": 2505, "method_signature": "void main(String[])"}, "2244": {"callee_method_ids": [976, 976, 977, 977, 977, 977, 977, 957, 957, 959, 959], "callee_method_names": ["Structure.getPDBHeader", "Structure.getPDBHeader", "Map<Integer, BioAssemblyInfo>.size", "Map<Integer, BioAssemblyInfo>.size", "Map<Integer, BioAssemblyInfo>.keySet", "Map<Integer, BioAssemblyInfo>.keySet", "Map<Integer, BioAssemblyInfo>.values", "Map<Integer, BioAssemblyInfo>.values", "List<BioAssemblyInfo>.size", "List<BioAssemblyInfo>.get", "List<BioAssemblyInfo>.get", "BioAssemblyInfo.getId", "BioAssemblyInfo.getId", "BioAssemblyInfo.getTransforms", "BioAssemblyInfo.getTransforms", "BioAssemblyInfo.getTransforms", "BioAssemblyInfo.getTransforms", "BioAssemblyInfo.getTransforms", "BiologicalAssemblyTransformation.getChainId", "BiologicalAssemblyTransformation.getChainId", "BiologicalAssemblyTransformation.getTransformationMatrix", "BiologicalAssemblyTransformation.getTransformationMatrix"], "method_name": "TestMmtfRoundTrip.checkBioAssemblies1", "method_implementation": "{\n    Map<Integer, BioAssemblyInfo> expecteds = structOne.getPDBHeader().getBioAssemblies();\n    Map<Integer, BioAssemblyInfo> actuals = structTwo.getPDBHeader().getBioAssemblies();\n    assertEquals(expecteds.size(), actuals.size());\n    assertEquals(new ArrayList<>(expecteds.keySet()), new ArrayList<>(actuals.keySet()));\n    List<BioAssemblyInfo> assemblies1 = new ArrayList<>(expecteds.values());\n    List<BioAssemblyInfo> assemblies2 = new ArrayList<>(actuals.values());\n    for (int i = 0; i < assemblies1.size(); i++) {\n        BioAssemblyInfo info1 = assemblies1.get(i);\n        BioAssemblyInfo info2 = assemblies2.get(i);\n        assertEquals(info1.getId(), info2.getId());\n        assertEquals(info1.getTransforms().size(), info2.getTransforms().size());\n        for (int j = 0; j < info1.getTransforms().size(); j++) {\n            BiologicalAssemblyTransformation trans1 = info1.getTransforms().get(j);\n            BiologicalAssemblyTransformation trans2 = info2.getTransforms().get(j);\n            assertEquals(trans1.getChainId(), trans2.getChainId());\n            assertTrue(trans1.getTransformationMatrix().epsilonEquals(trans2.getTransformationMatrix(), 0.000001));\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Checks consistency of bioassemblies\n * @param structOne the first input structure\n * @param structTwo the second input structure\n */\n", "repo_name": "biojava-master/", "id": 2244, "method_signature": "void checkBioAssemblies1(Structure, Structure)"}, "2202": {"callee_method_names": ["ResidueNumber.getChainName"], "method_name": "ResidueNumberTest.testGetSetChainId", "method_implementation": "{\n    //        System.out.println(\"getChainName\");\n    ResidueNumber instance = new ResidueNumber(\"A\", 42, ' ');\n    String expResult = \"A\";\n    String result = instance.getChainName();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of getChainName method, of class ResidueNumber.\n */\n", "repo_name": "biojava-master/", "id": 2202, "method_signature": "void testGetSetChainId()"}, "1730": {"callee_method_names": [], "method_name": "BasePairParameters.getTilt", "method_implementation": "{\n    checkArgument(bp);\n    return stepParameters[bp][0];\n}", "repo_id": "9", "comment": "/**\n * This method returns the tilt for the given base pair, relative to the one before it.\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in degrees)\n */\n", "repo_name": "biojava-master/", "id": 1730, "method_signature": "Double getTilt(int)"}, "1758": {"callee_method_names": [], "method_name": "MismatchedBasePairParameters.getMaxPropeller", "method_implementation": "{\n    return maxPropeller;\n}", "repo_id": "9", "comment": "/**\n * This method returns the maximum propeller twist between bases used as criteria for the characterization of two bases as being paired.\n * @return the maximum propeller (\"propeller-twist\", in degrees) allowed.\n */\n", "repo_name": "biojava-master/", "id": 1758, "method_signature": "double getMaxPropeller()"}, "3832": {"callee_method_names": ["Set<String>.contains"], "method_name": "AminoAcidProperties.isPolar", "method_implementation": "{\n    if (polarAAs.contains(String.valueOf(aa))) {\n        return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * There are 10 amino acids: D, E, H, K, R, N, Q, S, T, Y, that are polar.\n *\n * @param aa The one-letter amino acid code\n * @return true if amino acid is polar\n */\n", "repo_name": "biojava-master/", "id": 3832, "method_signature": "boolean isPolar(char)"}, "2617": {"callee_method_names": [], "method_name": "ConcurrencyTools.submit", "method_implementation": "{\n    return submit(task, \"\");\n}", "repo_id": "9", "comment": "/**\n * Queues up a task and adds a default log entry.\n *\n * @param <T> type returned from the submitted task\n * @param task submitted task\n * @return future on which the desired value is retrieved by calling get()\n */\n", "repo_name": "biojava-master/", "id": 2617, "method_signature": "Future<T> submit(Callable)"}, "1320": {"callee_method_names": [], "method_name": "FileParsingParameters.setParseCAOnly", "method_implementation": "{\n    this.parseCAOnly = parseCAOnly;\n}", "repo_id": "9", "comment": "/**\n * Flag if only the C-alpha atoms of the structure should be parsed.\n *\n * @param parseCAOnly boolean flag to enable or disable C-alpha only parsing\n */\n", "repo_name": "biojava-master/", "id": 1320, "method_signature": "void setParseCAOnly(boolean)"}, "2896": {"callee_method_names": [], "method_name": "SequenceMixin.sequenceEqualityIgnoreCase", "method_implementation": "{\n    return baseSequenceEquality(source, target, true);\n}", "repo_id": "9", "comment": "/**\n * A case-insensitive manner of comparing two sequence objects together.\n * We will throw out any compounds which fail to match on their sequence\n * length & compound sets used. The code will also bail out the moment\n * we find something is wrong with a Sequence. Cost to run is linear to\n * the length of the Sequence.\n *\n * @param <C> The type of compound\n * @param source Source sequence to assess\n * @param target Target sequence to assess\n * @return Boolean indicating if the sequences matched ignoring case\n */\n", "repo_name": "biojava-master/", "id": 2896, "method_signature": "boolean sequenceEqualityIgnoreCase(Sequence, Sequence)"}, "1557": {"callee_method_names": ["ScopCategory.hashCode", "String.hashCode", "String.hashCode"], "method_name": "ScopDescription.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((category == null) ? 0 : category.hashCode());\n    result = prime * result + ((classificationId == null) ? 0 : classificationId.hashCode());\n    result = prime * result + ((name == null) ? 0 : name.hashCode());\n    result = prime * result + sunID;\n    return result;\n}", "repo_id": "9", "comment": "/**\n * @return\n * @see java.lang.Object#hashCode()\n */\n", "repo_name": "biojava-master/", "id": 1557, "method_signature": "int hashCode()"}, "2215": {"callee_method_ids": [1322, 1330, 641], "callee_method_names": ["FileParsingParameters.setAlignSeqRes", "FileParsingParameters.setCreateAtomBonds", "AtomCache.setFileParsingParams", "AtomCache.setFiletype", "Structure.getChains", "Chain.getAtomGroups", "Group.getAltLocs", "Block.getBonds", "Block.getBonds", "Group.getAtoms", "Block.getGroup", "Block.getGroup", "Block.getName", "List<Atom>.add", "Group.hasAtom", "List<Atom>.size"], "method_name": "TestAltLocs.test4CUPBonds", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    FileParsingParameters params = new FileParsingParameters();\n    params.setAlignSeqRes(true);\n    params.setCreateAtomBonds(true);\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    cache.setFiletype(StructureFiletype.PDB);\n    Structure structure = StructureIO.getStructure(\"4CUP\");\n    assertNotNull(structure);\n    Atom[] ca = StructureTools.getAtomCAArray(structure);\n    List<Atom> caList = new ArrayList<Atom>();\n    for (Chain c : structure.getChains()) {\n        for (Group g : c.getAtomGroups()) {\n            for (Group altLocGroup : g.getAltLocs()) {\n                ensureAllAtomsSameAltCode(altLocGroup, g);\n                for (Atom a : altLocGroup.getAtoms()) {\n                    // Check the atomsall have bonds\n                    assertNotEquals(a.getBonds(), null);\n                    assertNotEquals(a.getBonds().size(), 0);\n                }\n            }\n            List<Atom> atoms = g.getAtoms();\n            boolean caInMain = false;\n            for (Atom a : atoms) {\n                assertNotNull(a.getGroup());\n                assertNotNull(a.getGroup().getChain());\n                if (a.getName().equals(StructureTools.CA_ATOM_NAME)) {\n                    caList.add(a);\n                    caInMain = true;\n                    break;\n                }\n            }\n            if (!caInMain && g.hasAtom(StructureTools.CA_ATOM_NAME)) {\n                // g.hasAtom checks altLocs\n                fail(\"CA is not in main group, but in altLoc\");\n            }\n        }\n    }\n    assertEquals(ca.length, caList.size());\n}", "repo_id": "9", "comment": "/**\n * A test to see that alternate location bonds are being generated\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2215, "method_signature": "void test4CUPBonds()"}, "1253": {"callee_method_names": ["Group.getProperty", "SecStrucState.getType"], "method_name": "MmtfUtils.getSecStructType", "method_implementation": "{\n    SecStrucState props = (SecStrucState) group.getProperty(\"secstruc\");\n    if (props == null) {\n        return DsspType.NULL_ENTRY.getDsspIndex();\n    }\n    return DsspType.dsspTypeFromString(props.getType().name).getDsspIndex();\n}", "repo_id": "9", "comment": "/**\n * Get the secondary structure as defined by DSSP.\n * @param group the input group to be calculated\n * @return the integer index of the group type.\n */\n", "repo_name": "biojava-master/", "id": 1253, "method_signature": "int getSecStructType(Group)"}, "3827": {"callee_method_names": [], "method_name": "ClinicalMetaDataOutcome.process", "method_implementation": "{\n    for (MetaDataInfo metaDataInfo : metaDataInfoList) {\n        if (metaDataInfo.numeric) {\n            metaDataInfo.discreteQuantizer.process(worksheet, metaDataInfo.column);\n        }\n        metaDataInfo.setDiscreteValues(worksheet);\n    }\n    for (MetaDataInfo metaDataInfo : metaDataInfoList) {\n        int numberValues = metaDataInfo.getNumberDiscreteValues();\n        for (int i = 0; i < numberValues; i++) {\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @param worksheet\n * @param sensorMapColumn\n * @param censorMap\n * @param timeColumn\n * @param timeScale\n * @param metaDataInfoList\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3827, "method_signature": "void process(WorkSheet, String, LinkedHashMap, String, Double, ArrayList)"}, "2998": {"callee_method_names": [], "method_name": "BitSequenceReader.getIndexToCompoundsLookup", "method_implementation": "{\n    if (indexToCompoundsLookup == null) {\n        indexToCompoundsLookup = generateIndexToCompounds();\n    }\n    return indexToCompoundsLookup;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of compounds the index position of which is used\n * to translate from the byte representation into a compound.\n */\n", "repo_name": "biojava-master/", "id": 2998, "method_signature": "List<C> getIndexToCompoundsLookup()"}, "2759": {"callee_method_names": [], "method_name": "EmblReference.getReferenceAuthor", "method_implementation": "{\n    return referenceAuthor;\n}", "repo_id": "9", "comment": "/**\n * The RA (Reference Author) lines list the authors of the paper (or other\n * work) cited. All of the authors are included, and are listed in the order\n * given in the paper.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2759, "method_signature": "String getReferenceAuthor()"}, "320": {"callee_method_names": ["Set<ProteinModification>.isEmpty"], "method_name": "ProteinModificationRegistryTest.testRegisterCommonModification", "method_implementation": "{\n    Set<ProteinModification> mods = ProteinModificationRegistry.allModifications();\n    Assert.assertTrue(mods != null && !mods.isEmpty());\n    //\t\tlogger.info(\"There are totally \"+mods.size()\n    //\t\t\t\t+\" protein modifications registered.\");\n    //\n    //\t\tprintModifications(mods);\n}", "repo_id": "9", "comment": "/**\n * Test the initialization registry of common protein modifications.\n * Note: if you change this unit test, also change the cook book:\n * http://www.biojava.org/wiki/BioJava:CookBook3:SupportedProtMod\n */\n", "repo_name": "biojava-master/", "id": 320, "method_signature": "void testRegisterCommonModification()"}, "2100": {"callee_method_names": ["Matrix4d.setIdentity", "List<Axis>.get", "Matrix4d.mul", "List<Axis>.get", "Matrix4d.invert", "Matrix4d.mul"], "method_name": "SymmetryAxes.getRepeatTransform", "method_implementation": "{\n    Matrix4d transform = new Matrix4d();\n    transform.setIdentity();\n    int[] iCounts = getAxisCounts(x);\n    int[] jCounts = getAxisCounts(y);\n    int[] counts = new int[iCounts.length];\n    for (int k = 0; k < iCounts.length; k++) counts[k] = iCounts[k] - jCounts[k];\n    for (int t = counts.length - 1; t >= 0; t--) {\n        if (counts[t] == 0)\n            continue;\n        if (counts[t] > 0) {\n            Matrix4d axis = new Matrix4d(axes.get(t).getOperator());\n            for (int i = 0; i < counts[t]; i++) transform.mul(axis);\n        } else if (counts[t] < 0) {\n            Matrix4d axis = new Matrix4d(axes.get(t).getOperator());\n            axis.invert();\n            for (int i = 0; i < counts[t]; i++) transform.mul(axis);\n        }\n    }\n    return transform;\n}", "repo_id": "9", "comment": "/**\n * Return the transformation that needs to be applied to\n * repeat x in order to superimpose onto repeat y.\n *\n * @param x the first repeat index (transformed)\n * @param y the second repeat index (fixed)\n * @return transformation matrix for the repeat x\n */\n", "repo_name": "biojava-master/", "id": 2100, "method_signature": "Matrix4d getRepeatTransform(int, int)"}, "796": {"callee_method_names": [], "method_name": "CeUserArgumentProcessor.setMaxOptRMSD", "method_implementation": "{\n    this.maxOptRMSD = maxOptRMSD;\n}", "repo_id": "9", "comment": "/**\n * (jCE specific): maximum RMSD that shall be calculated for the alignment.\n *\n * @param maxOptRMSD max RMSD to calculate\n */\n", "repo_name": "biojava-master/", "id": 796, "method_signature": "void setMaxOptRMSD(Double)"}, "2885": {"callee_method_names": [], "method_name": "SequenceMixin.toString", "method_implementation": "{\n    return toStringBuilder(sequence).toString();\n}", "repo_id": "9", "comment": "/**\n * Shortcut to {@link #toStringBuilder(org.biojava.nbio.core.sequence.template.Sequence)}\n * which calls toString() on the resulting object.\n */\n", "repo_name": "biojava-master/", "id": 2885, "method_signature": "String toString(Sequence)"}, "191": {"callee_method_ids": [641, 1322, 970, 1652, 1633, 1929], "callee_method_names": ["AtomCache.setFiletype", "FileParsingParameters.setAlignSeqRes", "FileParsingParameters.setParseBioAssembly", "AtomCache.setFileParsingParams", "Structure.getPDBHeader", "BiologicalAssemblyBuilder.rebuildQuaternaryStructure", "SubunitClustererParameters.setUseEntityIdForSeqIdentityDetermination", "SubunitClustererParameters.setClustererMethod", "QuatSymmetryResults.getSymmetry", "QuatSymmetryResults.getStoichiometry"], "method_name": "TestQuatSymmetryDetectorExamples.testSymDetectionPerformanceLargeCapsid", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    FileParsingParameters params = new FileParsingParameters();\n    params.setAlignSeqRes(true);\n    params.setParseBioAssembly(true);\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    // making sure we remove all atoms but representative before we expand, otherwise memory requirements are huge\n    // 6Q1F is another good example\n    Structure au = StructureIO.getStructure(\"6NHJ\");\n    StructureTools.reduceToRepresentativeAtoms(au);\n    BiologicalAssemblyBuilder builder = new BiologicalAssemblyBuilder();\n    List<BiologicalAssemblyTransformation> transforms = au.getPDBHeader().getBioAssemblies().get(1).getTransforms();\n    Structure pdb = builder.rebuildQuaternaryStructure(au, transforms, true, false);\n    SubunitClustererParameters cp = new SubunitClustererParameters();\n    // This is the parameter that makes this fast, set it to false to see the difference.\n    // As of git commit ed322e387cd46344a7864a, the difference in runtime is not that huge:\n    // 2 minutes with true, 10 minutes with false. I observed a much larger difference before, but can't reproduce anymore - JD 2020-01-23\n    cp.setUseEntityIdForSeqIdentityDetermination(true);\n    cp.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n    QuatSymmetryParameters symmParams = new QuatSymmetryParameters();\n    QuatSymmetryResults symmetry = QuatSymmetryDetector.calcGlobalSymmetry(pdb, symmParams, cp);\n    assertEquals(\"I\", symmetry.getSymmetry());\n    assertEquals(\"A960B960C600D480E300\", symmetry.getStoichiometry().toString());\n}", "repo_id": "9", "comment": "/**\n * A performance test that demonstrates how the SubunitClustererParameters.setUseEntityIdForSeqIdentityDetermination()\n * has a dramatic effect in runtime versus doing alignments.\n */\n", "repo_name": "biojava-master/", "id": 191, "method_signature": "void testSymDetectionPerformanceLargeCapsid()"}, "3000": {"callee_method_names": [], "method_name": "BitSequenceReader.biologicalIndexToArrayIndex", "method_implementation": "{\n    return ((index - 1) / compoundsPerDatatype());\n}", "repo_id": "9", "comment": "/**\n * Converting a biological index to the int which is used to store that\n * position's data.\n *\n * <ul>\n * <li>Assuming 2bit encoding using the 17 base in a sequence</li>\n * <li>Convert into 0 index; 17 - 1 = 16</li>\n * <li>Divide by the number of compounds per int; 16 / 16</li>\n * <li>Floor the value; floor(1) = 1</li>\n * </ul>\n *\n * Running this for position 13\n *\n * <ul>\n * <li>13 - 1 = 12</li>\n * <li>12 / 16 = 0.75</li>\n * <li>floor(0.75) = 0</li>\n * </ul>\n */\n", "repo_name": "biojava-master/", "id": 3000, "method_signature": "int biologicalIndexToArrayIndex(int)"}, "2682": {"callee_method_names": [], "method_name": "RNASequence.getReverseComplement", "method_implementation": "{\n    return new ComplementSequenceView<>(getInverse());\n}", "repo_id": "9", "comment": "/**\n * Get reverse complement view of the sequence\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2682, "method_signature": "SequenceView<NucleotideCompound> getReverseComplement()"}, "3327": {"callee_method_names": [], "method_name": "SequenceDisplay.getIdx1", "method_implementation": "{\n    return idx1;\n}", "repo_id": "9", "comment": "/**\n * get the identical position in the alignment\n *\n * @return identical positions for structure1\n */\n", "repo_name": "biojava-master/", "id": 3327, "method_signature": "int[] getIdx1()"}, "2362": {"callee_method_names": ["QuantityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound>.setQuantities"], "method_name": "FastqTools.createErrorProbabilities", "method_implementation": "{\n    if (fastq == null) {\n        throw new IllegalArgumentException(\"fastq must not be null\");\n    }\n    QuantityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound> errorProbabilities = new QuantityFeature<AbstractSequence<NucleotideCompound>, NucleotideCompound>(\"errorProbabilities\", \"sequencing\");\n    errorProbabilities.setQuantities(toList(errorProbabilities(fastq)));\n    return errorProbabilities;\n}", "repo_id": "9", "comment": "/**\n * Create and return a new {@link QuantityFeature} from the error probabilities of the specified\n * FASTQ formatted sequence.  The error probabilities feature has a type <code>\"errorProbabilities\"</code>\n * and will be the same length as the sequence.\n *\n * @param fastq FASTQ formatted sequence, must not be null\n * @return a new {@link QualityFeature} from the error probabilities of the specified FASTQ\n *    formatted sequence\n */\n", "repo_name": "biojava-master/", "id": 2362, "method_signature": "QuantityFeature<AbstractSequence<NucleotideCompound>,NucleotideCompound> createErrorProbabilities(Fastq)"}, "3792": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getSurvivalFitInfo", "method_implementation": "{\n    return sfi;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3792, "method_signature": "SurvFitInfo getSurvivalFitInfo()"}, "3186": {"callee_method_names": [], "method_name": "WindowedSequence.getLength", "method_implementation": "{\n    return getBackingSequence().getLength() / getWindowSize();\n}", "repo_id": "9", "comment": "/**\n * Returns the size of the windowed sequence which is the length by the\n * window size. Trailing Compounds are omitted.\n */\n", "repo_name": "biojava-master/", "id": 3186, "method_signature": "int getLength()"}, "1211": {"callee_method_names": [], "method_name": "CifStructureConverter.toBinary", "method_implementation": "{\n    try {\n        return CifIO.writeText(toCifFile(structure));\n    } catch (IOException e) {\n        throw new UncheckedIOException(e);\n    }\n}", "repo_id": "9", "comment": "/**\n * Convert a structure to BCIF format.\n * @param structure the source\n * @return the binary representation of the structure\n */\n", "repo_name": "biojava-master/", "id": 1211, "method_signature": "byte[] toBinary(Structure)"}, "2665": {"callee_method_names": ["List<Sequence<NucleotideCompound>>.add"], "method_name": "DNAToRNATranslator.createSequences", "method_implementation": "{\n    if (shortCutTranslation) {\n        List<Sequence<NucleotideCompound>> result = new ArrayList<Sequence<NucleotideCompound>>(1);\n        result.add(wrapToRna(originalSequence));\n        return result;\n    } else {\n        return super.createSequences(originalSequence);\n    }\n}", "repo_id": "9", "comment": "/**\n * Overloaded local version which delegates to an optional translator\n * when told to (specified during construction).\n *\n * @param originalSequence The DNA sequence to translate\n * @return The translated single sequence\n */\n", "repo_name": "biojava-master/", "id": 2665, "method_signature": "List<Sequence<NucleotideCompound>> createSequences(Sequence)"}, "1365": {"callee_method_names": [], "method_name": "DBRef.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * Get the ID used by Hibernate.\n *\n * @return the ID used by Hibernate\n * @see #setId(Long)\n */\n", "repo_name": "biojava-master/", "id": 1365, "method_signature": "Long getId()"}, "2230": {"callee_method_ids": [1190], "callee_method_names": ["String.getBytes", "PDBFileParser.parsePDBFile", "Structure.getPDBHeader"], "method_name": "TestNonDepositedFiles.testCryst1Parsing", "method_implementation": "{\n    String cryst1Line = \"CRYST1   11.111   11.111  111.111  70.00  80.00  60.00 P 1\";\n    Structure s;\n    PDBFileParser pdbPars = new PDBFileParser();\n    try (InputStream is = new ByteArrayInputStream(cryst1Line.getBytes())) {\n        s = pdbPars.parsePDBFile(is);\n    }\n    assertEquals(\"P 1\", s.getPDBHeader().getCrystallographicInfo().getSpaceGroup().getShortSymbol());\n}", "repo_id": "9", "comment": "/**\n * Some PDB files coming from phenix or other software can have a CRYST1 line without z and not padded with white-spaces\n * for the space group column.\n * @throws IOException\n * @since 5.0.0\n */\n", "repo_name": "biojava-master/", "id": 2230, "method_signature": "void testCryst1Parsing()"}, "649": {"callee_method_ids": [477], "callee_method_names": ["AFPChain.getNrEQR", "Group.size", "Group.getAtom", "List<Atom>.add", "List<Atom>.toArray", "List<Atom>.size", "Atom[].getGroup", "Group.getChain", "Chain.getAtomGroups", "Chain.getAtomGroups", "Atom[].getGroup", "Group.getChain", "Chain.getAtomGroups", "Chain.getAtomGroups"], "method_name": "AFPAlignmentDisplay.createArtificalStructure", "method_implementation": "{\n    if (afpChain.getNrEQR() < 1) {\n        return GuiWrapper.getAlignedStructure(ca1, ca2);\n    }\n    Group[] twistedGroups = AlignmentTools.prepareGroupsForDisplay(afpChain, ca1, ca2);\n    List<Atom> twistedAs = new ArrayList<Atom>();\n    for (Group g : twistedGroups) {\n        if (g == null)\n            continue;\n        if (g.size() < 1)\n            continue;\n        Atom a = g.getAtom(0);\n        twistedAs.add(a);\n    }\n    Atom[] twistedAtoms = twistedAs.toArray(new Atom[twistedAs.size()]);\n    List<Group> hetatms = new ArrayList<Group>();\n    List<Group> nucs1 = new ArrayList<Group>();\n    Group g1 = ca1[0].getGroup();\n    Chain c1 = null;\n    if (g1 != null) {\n        c1 = g1.getChain();\n        if (c1 != null) {\n            hetatms = c1.getAtomGroups(GroupType.HETATM);\n            ;\n            nucs1 = c1.getAtomGroups(GroupType.NUCLEOTIDE);\n        }\n    }\n    List<Group> hetatms2 = new ArrayList<Group>();\n    List<Group> nucs2 = new ArrayList<Group>();\n    Group g2 = ca2[0].getGroup();\n    Chain c2 = null;\n    if (g2 != null) {\n        c2 = g2.getChain();\n        if (c2 != null) {\n            hetatms2 = c2.getAtomGroups(GroupType.HETATM);\n            nucs2 = c2.getAtomGroups(GroupType.NUCLEOTIDE);\n        }\n    }\n    Atom[] arr1 = GuiWrapper.getAtomArray(ca1, hetatms, nucs1);\n    Atom[] arr2 = GuiWrapper.getAtomArray(twistedAtoms, hetatms2, nucs2);\n    return GuiWrapper.getAlignedStructure(arr1, arr2);\n}", "repo_id": "9", "comment": "/**\n * @param afpChain\n * @param ca1\n * @param ca2\n * @return\n * @throws ClassNotFoundException If an error occurs when invoking jmol\n * @throws NoSuchMethodException If an error occurs when invoking jmol\n * @throws InvocationTargetException If an error occurs when invoking jmol\n * @throws IllegalAccessException If an error occurs when invoking jmol\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 649, "method_signature": "Structure createArtificalStructure(AFPChain, Atom[], Atom[])"}, "3866": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getAvgHydropathy"], "method_name": "PeptideProperties.getAvgHydropathy", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getAvgHydropathy(pSequence);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the average hydropathy value of sequence. The sequence argument\n * must be a protein sequence consisting of only non-ambiguous characters.\n * The average value for a sequence is calculated as the sum of hydropathy\n * values of all the amino acids, divided by the number of residues in the\n * sequence. Hydropathy values are based on (Kyte, J. and Doolittle, R.F.\n * (1982) A simple method for displaying the hydropathic character of a\n * protein. J. Mol. Biol. 157, 105-132).\n *\n * @param sequence\n * \t\ta protein sequence consisting of non-ambiguous characters only\n * @return the average hydropathy value of sequence\n */\n", "repo_name": "biojava-master/", "id": 3866, "method_signature": "double getAvgHydropathy(String)"}, "111": {"callee_method_names": ["Logger.info", "MultipleSequenceAlignment<C,D>.getSize", "MultipleSequenceAlignment<C,D>.getAlignedSequence", "MultipleSequenceAlignment<C,D>.getAlignedSequences", "MultipleSequenceAlignment<C,D>.getLength", "Logger.info", "String[].charAt", "String[].charAt", "SubstitutionMatrix<D>.getValue", "List<C>.get", "List<C>.get", "DistanceMatrix.setValue", "DistanceMatrix.setIdentifier", "MultipleSequenceAlignment<C,D>.getAlignedSequence", "DistanceMatrix.setValue", "DistanceMatrix.getValue", "DistanceMatrix.setValue", "DistanceMatrix.setValue", "Logger.info"], "method_name": "DistanceMatrixCalculator.dissimilarityScore", "method_implementation": "{\n    logger.info(\"{}:{}\", \"Determing Distances\", 0);\n    int n = msa.getSize();\n    String[] sequenceString = new String[n];\n    for (int i = 0; i < n; i++) {\n        sequenceString[i] = msa.getAlignedSequence(i + 1).getSequenceAsString();\n    }\n    List<C> seqs = msa.getAlignedSequences();\n    DistanceMatrix DM = new BasicSymmetricalDistanceMatrix(n);\n    int totalloopcount = (n / 2) * (n + 1);\n    double maxscore = 0;\n    int end = msa.getLength();\n    int loopcount = 0;\n    for (int i = 0; i < (n - 1); i++) {\n        logger.info(\"{}:{}\", \"Determining Distances\", (loopcount * 100) / totalloopcount);\n        // Obtain the similarity scores\n        for (int j = i; j < n; j++) {\n            double score = 0;\n            loopcount++;\n            for (int k = 0; k < end; k++) {\n                if (Comparison.isGap(sequenceString[i].charAt(k)) || Comparison.isGap(sequenceString[j].charAt(k)))\n                    continue;\n                score += M.getValue(seqs.get(i).getCompoundAt(k + 1), seqs.get(j).getCompoundAt(k + 1));\n            }\n            if (i != j) {\n                score = Math.max(score, 0.0);\n                DM.setValue(i, j, score);\n            }\n            if (score > maxscore)\n                maxscore = score;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        DM.setIdentifier(i, msa.getAlignedSequence(i + 1).getAccession().getID());\n        for (int j = i; j < n; j++) {\n            if (i == j)\n                DM.setValue(i, j, 0.0);\n            else {\n                double dS = Math.max(maxscore - DM.getValue(i, j), 0);\n                DM.setValue(i, j, dS);\n                DM.setValue(j, i, dS);\n            }\n        }\n    }\n    logger.info(\"{}:{}\", \"Determining Distances\", 100);\n    return DM;\n}", "repo_id": "9", "comment": "/**\n * The dissimilarity score is the additive inverse of the similarity score\n * (sum of scores) between two aligned sequences using a substitution model\n * (Substitution Matrix). The maximum dissimilarity score is taken to be the\n * maximum similarity score between self-alignments (each sequence against\n * itself). Calculation of the score is as follows:\n *\n * <pre>\n * Ds = maxScore - sum<sub>i</sub>(M<sub>ai,bi</sub>)\n * </pre>\n *\n * It is recommended to use the method\n * {@link #fractionalDissimilarityScore(MultipleSequenceAlignment, SubstitutionMatrix)}\n * , since the maximum similarity score is not relative to the data set, but\n * relative to the Substitution Matrix, and the score is normalized by the\n * alignment length (fractional).\n * <p>\n * Gaps do not have a contribution to the similarity score calculation (gap\n * penalty = 0).\n *\n * @param msa\n *            MultipleSequenceAlignment\n * @param M\n *            SubstitutionMatrix for similarity scoring\n * @return DistanceMatrix\n */\n", "repo_name": "biojava-master/", "id": 111, "method_signature": "DistanceMatrix dissimilarityScore(MultipleSequenceAlignment, SubstitutionMatrix)"}, "2448": {"callee_method_names": [], "method_name": "FeatureList.sortByStart", "method_implementation": "{\n    FeatureI[] array = toArray(new FeatureI[1]);\n    Arrays.sort(array, new FeatureComparator());\n    return new FeatureList(Arrays.asList(array));\n}", "repo_id": "9", "comment": "/**\n * Create a new list that is ordered by the starting index of the features' locations. All locations\n * must be on the same strand of the same sequence.\n *\n * @return An ordered list.\n * @throws IndexOutOfBoundsException Cannot compare/sort features whose locations are on opposite strands, or\n * whose seqnames differ.\n */\n", "repo_name": "biojava-master/", "id": 2448, "method_signature": "FeatureList sortByStart()"}, "3113": {"callee_method_names": ["String.getBytes", "Logger.error"], "method_name": "UniprotProxySequenceReader.parseUniprotXMLString", "method_implementation": "{\n    try {\n        Document document = XMLHelper.inputStreamToDocument(new ByteArrayInputStream(xml.getBytes()));\n        return new UniprotProxySequenceReader<C>(document, compoundSet);\n    } catch (Exception e) {\n        logger.error(\"Exception on xml parse of: {}\", xml);\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * The passed in xml is parsed as a DOM object so we know everything about the protein.\n *  If an error occurs throw an exception. We could have a bad uniprot id\n * @param xml\n * @param compoundSet\n * @return UniprotProxySequenceReader\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3113, "method_signature": "UniprotProxySequenceReader<C> parseUniprotXMLString(String, CompoundSet)"}, "313": {"callee_method_names": [], "method_name": "Component.isCTerminal", "method_implementation": "{\n    return isCTerminal;\n}", "repo_id": "9", "comment": "/**\n * @return true if occurring on C terminal; false, other wise.\n */\n", "repo_name": "biojava-master/", "id": 313, "method_signature": "boolean isCTerminal()"}, "815": {"callee_method_names": [], "method_name": "AlternativeAlignment.getGaps", "method_implementation": "{\n    return gaps0;\n}", "repo_id": "9", "comment": "/**\n * return the number of gaps in this alignment\n *\n * @return the number of Gaps\n */\n", "repo_name": "biojava-master/", "id": 815, "method_signature": "int getGaps()"}, "2721": {"callee_method_names": [], "method_name": "BufferedReaderBytesRead.reset", "method_implementation": "{\n    synchronized (lock) {\n        ensureOpen();\n        if (markedChar < 0) {\n            throw new IOException((markedChar == INVALIDATED) ? \"Mark invalid\" : \"Stream not marked\");\n        }\n        nextChar = markedChar;\n        skipLF = markedSkipLF;\n    }\n}", "repo_id": "9", "comment": "/**\n * Resets the stream to the most recent mark.\n *\n * @exception  IOException  If the stream has never been marked,\n *                          or if the mark has been invalidated\n */\n", "repo_name": "biojava-master/", "id": 2721, "method_signature": "void reset()"}, "3454": {"callee_method_names": [], "method_name": "NCBIQBlastOutputProperties.getOutputFormat", "method_implementation": "{\n    return getOutputOption(FORMAT_TYPE);\n}", "repo_id": "9", "comment": "/**\n * @return stream output format - a String with the value of key FORMAT_TYPE\n */\n", "repo_name": "biojava-master/", "id": 3454, "method_signature": "String getOutputFormat()"}, "2398": {"callee_method_names": [], "method_name": "Location.intersection", "method_implementation": "{\n    if (isSameStrand(other)) {\n        return intersect(mStart, mEnd, other.mStart, other.mEnd);\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Return the intersection, or null if no overlap.\n *\n * @param other\n *            The location to intersect.\n * @return The maximal location that is contained by both. Returns null if\n *         no overlap!\n * @throws IllegalArgumentException\n *             Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2398, "method_signature": "Location intersection(Location)"}, "351": {"callee_method_names": ["Atom.getCoordsAsPoint3d", "Atom.getCoordsAsPoint3d", "Vector3d.angle"], "method_name": "Calc.angle", "method_implementation": "{\n    Vector3d va = new Vector3d(a.getCoordsAsPoint3d());\n    Vector3d vb = new Vector3d(b.getCoordsAsPoint3d());\n    return Math.toDegrees(va.angle(vb));\n}", "repo_id": "9", "comment": "/**\n * Gets the angle between two vectors\n *\n * @param a\n *            an Atom object\n * @param b\n *            an Atom object\n * @return Angle between a and b in degrees, in range [0,180]. If either\n *         vector has length 0 then angle is not defined and NaN is returned\n */\n", "repo_name": "biojava-master/", "id": 351, "method_signature": "double angle(Atom, Atom)"}, "329": {"callee_method_names": ["BufferedReader.readLine", "BufferedReader.readLine", "String.trim", "String.length", "String.startsWith", "String.startsWith", "String.substring", "String.startsWith", "String.substring", "OntologyFactory.createOntology", "StringTokenizer.nextToken", "StringTokenizer.nextToken", "StringTokenizer.nextToken"], "method_name": "TabDelimParser.parse", "method_implementation": "{\n    String name = \"\";\n    String description = \"\";\n    Ontology onto = null;\n    for (String line = in.readLine(); line != null; line = in.readLine()) {\n        line = line.trim();\n        if (line.length() > 0) {\n            if (line.startsWith(\"#\")) {\n                // comment line - let's try to pull out name or description\n                if (line.startsWith(\"#name:\")) {\n                    name = line.substring(\"#name:\".length()).trim();\n                } else if (line.startsWith(\"#description:\")) {\n                    description = line.substring(\"#description:\".length()).trim();\n                }\n            } else {\n                try {\n                    // make sure we have an ontology\n                    if (onto == null) {\n                        onto = of.createOntology(name, description);\n                    }\n                    // build a tripple\n                    /*\n\n\t\t\t\t\t\tint t1 = line.indexOf(\"\\t\");\n\t\t\t\t\t\tint t2 = line.indexOf(\"\\t\", t1 + 1);\n\n\t\t\t\t\t\tString subject  = line.substring(0, t1);\n\t\t\t\t\t\tString predicate = line.substring(t1 + 1, t2);\n\t\t\t\t\t\tString object   = line.substring(t2 + 1);\n\n\t\t\t\t\t\t*/\n                    StringTokenizer toke = new StringTokenizer(line);\n                    String subject = toke.nextToken();\n                    String predicate = toke.nextToken();\n                    String object = toke.nextToken();\n                    Term subT = resolveTerm(subject, onto);\n                    Term objT = resolveTerm(object, onto);\n                    Term relT = resolveTerm(predicate, onto);\n                    Triple trip = resolveTriple(subT, objT, relT, onto);\n                    // prevent unused field error\n                    trip = trip == null ? null : trip;\n                } catch (StringIndexOutOfBoundsException e) {\n                    throw new IOException(\"Could not parse line: \" + line);\n                }\n            }\n        }\n    }\n    return onto;\n}", "repo_id": "9", "comment": "/**\n * Parse an ontology from a reader.\n * The reader will be emptied of text. It is the caller's responsibility to\n * close the reader.\n *\n * @param in  the BufferedReader to read from\n * @param of  an OntologyFactory used to create the Ontology instance\n * @return  a new Ontology\n * @throws IOException if there is some problem with the buffered reader\n * @throws OntologyException if it was not possible to instantiate a new\n *         ontology\n */\n", "repo_name": "biojava-master/", "id": 329, "method_signature": "Ontology parse(BufferedReader, OntologyFactory)"}, "2975": {"callee_method_names": ["CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString", "CompoundSet<C>.getCompoundForString"], "method_name": "TwoBitSequenceReader.generateCompoundsToIndex", "method_implementation": "{\n    final CompoundSet<C> cs = getCompoundSet();\n    return Map.of(cs.getCompoundForString(\"T\"), 0, cs.getCompoundForString(\"C\"), 1, cs.getCompoundForString(\"A\"), 2, cs.getCompoundForString(\"G\"), 3, cs.getCompoundForString(\"t\"), 0, cs.getCompoundForString(\"c\"), 1, cs.getCompoundForString(\"a\"), 2, cs.getCompoundForString(\"g\"), 3);\n}", "repo_id": "9", "comment": "/**\n * Returns a Map which encodes TCAG into positions 0,1,2,3.\n */\n", "repo_name": "biojava-master/", "id": 2975, "method_signature": "Map<C,Integer> generateCompoundsToIndex()"}, "1453": {"callee_method_names": ["List<Matrix4d>.add", "List<Matrix4d>.get"], "method_name": "SpaceGroup.getTransformations", "method_implementation": "{\n    List<Matrix4d> transfs = new ArrayList<Matrix4d>();\n    for (int i = 1; i < this.transformations.size(); i++) {\n        transfs.add(transformations.get(i));\n    }\n    return transfs;\n}", "repo_id": "9", "comment": "/**\n * Gets all transformations except for the identity in crystal axes basis.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1453, "method_signature": "List<Matrix4d> getTransformations()"}, "2132": {"callee_method_ids": [1771, 1771], "callee_method_names": ["PDBHeader.getExperimentalTechniques", "PDBHeader.getExperimentalTechniques", "PDBHeader.getCrystallographicInfo", "PDBHeader.getCrystallographicInfo", "PDBHeader.getCrystallographicInfo"], "method_name": "StructureImpl.isNmr", "method_implementation": "{\n    // old implementation was:\n    //return nmrflag;\n    if (pdbHeader.getExperimentalTechniques() != null) {\n        return ExperimentalTechnique.isNmr(pdbHeader.getExperimentalTechniques());\n    } else {\n        // no experimental technique known, we try to guess...\n        if (nrModels() > 1) {\n            if (pdbHeader.getCrystallographicInfo().getSpaceGroup() != null) {\n                // multimodel, sg defined, but missing cell: must be NMR\n                if (pdbHeader.getCrystallographicInfo().getCrystalCell() == null)\n                    return true;\n                // multi-model, sg defined and cell unreasonable: must be NMR\n                if (!pdbHeader.getCrystallographicInfo().getCrystalCell().isCellReasonable())\n                    return true;\n            } else {\n                // multi-model and missing space group: must be NMR\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Whether this Structure is a NMR structure or not.\n * It will first check the experimental technique and if not present it will try\n * to guess from the presence of more than 1 model and from b-factors being 0 in first chain of first model\n * @return true if NMR, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 2132, "method_signature": "boolean isNmr()"}, "3164": {"callee_method_names": [], "method_name": "GenbankProxySequenceReader.getGenbankDirectoryCache", "method_implementation": "{\n    return genbankDirectoryCache;\n}", "repo_id": "9", "comment": "/**\n * Local directory cache of Genbank that can be downloaded\n *\n * @return the uniprotDirectoryCache\n */\n", "repo_name": "biojava-master/", "id": 3164, "method_signature": "String getGenbankDirectoryCache()"}, "1341": {"callee_method_names": [], "method_name": "EntityInfo.setId", "method_implementation": "{\n    this.id = id;\n}", "repo_id": "9", "comment": "/**\n * set the ID used by Hibernate\n *\n * @param id\n */\n", "repo_name": "biojava-master/", "id": 1341, "method_signature": "void setId(Long)"}, "570": {"callee_method_names": ["Pair<Atom>.getFirst", "Pair<Atom>.getSecond", "StringWriter.append", "StringWriter.append", "Atom.getX", "Atom.getY", "Atom.getZ", "Atom.getX", "Atom.getY", "Atom.getZ", "Atom.getX", "Atom.getX", "StringWriter.append", "Atom.getX", "Atom.getY", "Atom.getZ", "Atom.getX", "Atom.getY", "Atom.getZ", "StringWriter.append", "Atom.getX", "Atom.getY", "Atom.getZ", "Atom.getX", "Atom.getY", "Atom.getZ", "StringWriter.append", "StringWriter.append", "Atom.getX", "Atom.getY", "Atom.getZ", "Atom.getX", "Atom.getY", "Atom.getZ", "StringWriter.toString"], "method_name": "RotationAxis.getJmolScript", "method_implementation": "{\n    // width of JMol object\n    final double width = .5;\n    //axis color\n    final String axisColor = \"yellow\";\n    //screw translation color\n    final String screwColor = \"orange\";\n    Pair<Atom> endPoints = getAxisEnds(atoms);\n    Atom axisMin = endPoints.getFirst();\n    Atom axisMax = endPoints.getSecond();\n    StringWriter result = new StringWriter();\n    // set arrow heads to a reasonable length\n    result.append(\"set defaultDrawArrowScale 2.0;\");\n    // draw axis of rotation\n    result.append(String.format(Locale.US, \"draw ID rot\" + axisID + \" CYLINDER {%f,%f,%f} {%f,%f,%f} WIDTH %f COLOR %s ;\", axisMin.getX(), axisMin.getY(), axisMin.getZ(), axisMax.getX(), axisMax.getY(), axisMax.getZ(), width, axisColor));\n    // draw screw component\n    boolean positiveScrew = Math.signum(rotationAxis.getX()) == Math.signum(screwTranslation.getX());\n    if (positiveScrew) {\n        // screw is in the same direction as the axis\n        result.append(String.format(Locale.US, \"draw ID screw\" + axisID + \" VECTOR {%f,%f,%f} {%f,%f,%f} WIDTH %f COLOR %s ;\", axisMax.getX(), axisMax.getY(), axisMax.getZ(), screwTranslation.getX(), screwTranslation.getY(), screwTranslation.getZ(), width, screwColor));\n    } else {\n        // screw is in the opposite direction as the axis\n        result.append(String.format(Locale.US, \"draw ID screw\" + axisID + \" VECTOR {%f,%f,%f} {%f,%f,%f} WIDTH %f COLOR %s ;\", axisMin.getX(), axisMin.getY(), axisMin.getZ(), screwTranslation.getX(), screwTranslation.getY(), screwTranslation.getZ(), width, screwColor));\n    }\n    // draw angle of rotation\n    if (rotationPos != null) {\n        result.append(System.getProperty(\"line.separator\"));\n        result.append(String.format(Locale.US, \"draw ID rotArc\" + axisID + \" ARC {%f,%f,%f} {%f,%f,%f} {0,0,0} {0,%f,%d} SCALE 500 DIAMETER %f COLOR %s;\", axisMin.getX(), axisMin.getY(), axisMin.getZ(), axisMax.getX(), axisMax.getY(), axisMax.getZ(), Math.toDegrees(theta), // draw at the opposite end from the screw arrow\n        positiveScrew ? 0 : 1, width, axisColor));\n    }\n    return result.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script which will display the axis of rotation. This\n * consists of a cyan arrow along the axis, plus an arc showing the angle\n * of rotation.\n * <p>\n * As the rotation angle gets smaller, the axis of rotation becomes poorly\n * defined and would need to get farther and farther away from the protein.\n * This is not particularly useful, so we arbitrarily draw it parallel to\n * the translation and omit the arc.\n * @param atoms Some atoms from the protein, used for determining the bounds\n *  \t  of the axis.\n * @param axisID in case of representing more than one axis in the same jmol\n * \t\t  panel, indicate the ID number.\n *\n * @return The Jmol script, suitable for calls to\n * {@link org.biojava.nbio.structure.align.gui.jmol.StructureAlignmentJmol#evalString() jmol.evalString()}\n */\n", "repo_name": "biojava-master/", "id": 570, "method_signature": "String getJmolScript(Atom[], int)"}, "802": {"callee_method_ids": [711, 502, 477, 746, 506, 504], "callee_method_names": ["int.getGroup", "Group.getAtom", "int.getName", "CECalculator.extractFragments", "CECalculator.traceFragmentMatrix", "CECalculator.nextStep", "AFPChain.setAlgorithmName", "AFPChain.setVersion", "Atom[].getGroup", "Atom[].getGroup", "AFPChain.setName1", "Atom[].getGroup", "Atom[].getGroup", "Atom[].getGroup", "AFPChain.setName2", "Atom[].getGroup", "AFPChain.getNrEQR", "CeParameters.getWinSize", "CECalculator.initSumOfDistances", "AFPChain.setDistanceMatrix", "AFPChain.setSequentialAlignment"], "method_name": "CeMain.align", "method_implementation": "{\n    if (!(param instanceof CeParameters))\n        throw new IllegalArgumentException(\"CE algorithm needs an object of call CeParameters as argument.\");\n    params = (CeParameters) param;\n    // we don't want to rotate input atoms, do we?\n    ca2clone = new Atom[ca2.length];\n    int pos = 0;\n    for (Atom a : ca2) {\n        // works because each group has only a CA atom\n        Group g = (Group) a.getGroup().clone();\n        ca2clone[pos] = g.getAtom(a.getName());\n        pos++;\n    }\n    calculator = new CECalculator(params);\n    //Build alignment ca1 to ca2-ca2\n    AFPChain afpChain = new AFPChain(algorithmName);\n    afpChain = calculator.extractFragments(afpChain, ca1, ca2clone);\n    calculator.traceFragmentMatrix(afpChain, ca1, ca2clone);\n    calculator.nextStep(afpChain, ca1, ca2clone);\n    afpChain.setAlgorithmName(getAlgorithmName());\n    afpChain.setVersion(version);\n    // Try to guess names\n    if (ca1.length != 0 && ca1[0].getGroup().getChain() != null && ca1[0].getGroup().getChain().getStructure() != null)\n        afpChain.setName1(ca1[0].getGroup().getChain().getStructure().getName());\n    if (ca2.length != 0 && ca2[0].getGroup().getChain() != null && ca2[0].getGroup().getChain().getStructure() != null)\n        afpChain.setName2(ca2[0].getGroup().getChain().getStructure().getName());\n    if (afpChain.getNrEQR() == 0)\n        return afpChain;\n    // Set the distance matrix\n    int winSize = params.getWinSize();\n    int winSizeComb1 = (winSize - 1) * (winSize - 2) / 2;\n    double[][] m = calculator.initSumOfDistances(ca1.length, ca2.length, winSize, winSizeComb1, ca1, ca2clone);\n    afpChain.setDistanceMatrix(new Matrix(m));\n    afpChain.setSequentialAlignment(true);\n    return afpChain;\n}", "repo_id": "9", "comment": "/**\n * Align ca2 onto ca1.\n */\n", "repo_name": "biojava-master/", "id": 802, "method_signature": "AFPChain align(Atom[], Atom[], Object)"}, "3214": {"callee_method_names": [], "method_name": "TestObject.small", "method_implementation": "{\n    return new TestObject(name, 100);\n}", "repo_id": "9", "comment": "/*\n        *Create an object occupying negligible memory\n        */\n", "repo_name": "biojava-master/", "id": 3214, "method_signature": "TestObject small(String)"}, "129": {"callee_method_names": ["GuanUberbacher<DNASequence, NucleotideCompound>.getPair"], "method_name": "GuanUberbacherTest.should_align_shorter_query", "method_implementation": "{\n    DNASequence query = new DNASequence(\"A\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"AT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    GuanUberbacher<DNASequence, NucleotideCompound> aligner = new GuanUberbacher<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 5, (short) 2), SubstitutionMatrixHelper.getNuc4_4());\n    assertEquals(String.format(\"A-%nAT%n\"), aligner.getPair().toString());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 129, "method_signature": "void should_align_shorter_query()"}, "1482": {"callee_method_names": [], "method_name": "MomentsOfInertia.getPrincipalAxes", "method_implementation": "{\n    if (modified) {\n        diagonalizeTensor();\n        modified = false;\n    }\n    return principalAxes;\n}", "repo_id": "9", "comment": "/**\n * The principal axes of intertia\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1482, "method_signature": "Vector3d[] getPrincipalAxes()"}, "1572": {"callee_method_names": [], "method_name": "Site.setGroups", "method_implementation": "{\n    this.groups = residues;\n}", "repo_id": "9", "comment": "/**\n * @param residues the groups to set\n */\n", "repo_name": "biojava-master/", "id": 1572, "method_signature": "void setGroups(List)"}, "1547": {"callee_method_names": ["Map<Integer, ScopDescription>.get"], "method_name": "ScopInstallation.getScopDescriptionBySunid", "method_implementation": "{\n    try {\n        ensureDesInstalled();\n    } catch (IOException e) {\n        throw new ScopIOException(e);\n    }\n    return sunidMap.get(sunid);\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopDescriptionBySunid(int)\n\t */\n", "repo_name": "biojava-master/", "id": 1547, "method_signature": "ScopDescription getScopDescriptionBySunid(int)"}, "1969": {"callee_method_names": ["Matrix4d.transform", "Point3d.add"], "method_name": "HelixAxisAligner.getGeometricCenter", "method_implementation": "{\n    run();\n    Point3d geometricCenter = new Point3d();\n    Vector3d translation = new Vector3d();\n    //\t\treverseTransformationMatrix.get(translation);\n    // TODO does this apply to the helic case?\n    // calculate adjustment around z-axis and transform adjustment to\n    //  original coordinate frame with the reverse transformation\n    //\t\tVector3d corr = new Vector3d(0,minBoundary.y+getDimension().y, 0);\n    //\t\treverseTransformationMatrix.transform(corr);\n    //\t\tgeometricCenter.set(corr);\n    reverseTransformationMatrix.transform(translation);\n    geometricCenter.add(translation);\n    return geometricCenter;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getGeometricCenter()\n\t */\n", "repo_name": "biojava-master/", "id": 1969, "method_signature": "Point3d getGeometricCenter()"}, "1158": {"callee_method_ids": [1774], "callee_method_names": ["Structure.getPDBHeader", "XMLWriter.openTag", "XMLWriter.attribute", "Structure.getPDBCode", "XMLWriter.attribute", "Structure.getPDBCode", "DateFormat.format", "PDBHeader.getModDate", "XMLWriter.attribute", "XMLWriter.attribute", "XMLWriter.attribute", "XMLWriter.attribute", "XMLWriter.attribute", "XMLWriter.closeTag", "Structure.nrModels", "Structure.size", "Structure.getChainByIndex", "XMLWriter.openTag", "XMLWriter.attribute", "Chain.getId", "Structure.nrModels", "XMLWriter.attribute", "Chain.getAtomLength", "Chain.getAtomGroup", "XMLWriter.openTag", "XMLWriter.attribute", "Group.getPDBName", "XMLWriter.attribute", "Group.getType", "XMLWriter.attribute", "Group.getResidueNumber", "Group.getAtoms", "List<Atom>.size", "List<Atom>.get", "XMLWriter.openTag", "XMLWriter.attribute", "Atom.getPDBserial", "XMLWriter.attribute", "XMLWriter.attribute", "Atom.getX", "XMLWriter.attribute", "Atom.getY", "XMLWriter.attribute", "Atom.getZ", "XMLWriter.closeTag", "XMLWriter.closeTag", "XMLWriter.closeTag"], "method_name": "FileConvert.toDASStructure", "method_implementation": "{\n    /*xmlns=\"http://www.sanger.ac.uk/xml/das/2004/06/17/dasalignment.xsd\" xmlns:align=\"http://www.sanger.ac.uk/xml/das/2004/06/17/alignment.xsd\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema-instance\" xsd:schemaLocation=\"http://www.sanger.ac.uk/xml/das/2004/06/17/dasalignment.xsd http://www.sanger.ac.uk/xml/das//2004/06/17/dasalignment.xsd\"*/\n    if (structure == null) {\n        System.err.println(\"can not convert structure null\");\n        return;\n    }\n    PDBHeader header = structure.getPDBHeader();\n    xw.openTag(\"object\");\n    xw.attribute(\"dbAccessionId\", structure.getPDBCode());\n    xw.attribute(\"intObjectId\", structure.getPDBCode());\n    // missing modification date\n    DateFormat dateFormat = new SimpleDateFormat(\"dd-MMM-yy\", Locale.US);\n    String modificationDate = dateFormat.format(header.getModDate());\n    xw.attribute(\"objectVersion\", modificationDate);\n    xw.attribute(\"type\", \"protein structure\");\n    xw.attribute(\"dbSource\", \"PDB\");\n    xw.attribute(\"dbVersion\", \"20070116\");\n    xw.attribute(\"dbCoordSys\", \"PDBresnum,Protein Structure\");\n    // do we need object details ???\n    xw.closeTag(\"object\");\n    // do for all models\n    for (int modelnr = 0; modelnr < structure.nrModels(); modelnr++) {\n        // do for all chains:\n        for (int chainnr = 0; chainnr < structure.size(modelnr); chainnr++) {\n            Chain chain = structure.getChainByIndex(modelnr, chainnr);\n            xw.openTag(\"chain\");\n            xw.attribute(\"id\", chain.getId());\n            if (structure.nrModels() > 1) {\n                xw.attribute(\"model\", Integer.toString(modelnr + 1));\n            }\n            //do for all groups:\n            for (int groupnr = 0; groupnr < chain.getAtomLength(); groupnr++) {\n                Group gr = chain.getAtomGroup(groupnr);\n                xw.openTag(\"group\");\n                xw.attribute(\"name\", gr.getPDBName());\n                xw.attribute(\"type\", gr.getType().toString());\n                xw.attribute(\"groupID\", gr.getResidueNumber().toString());\n                // do for all atoms:\n                //Atom[] atoms  = gr.getAtoms();\n                List<Atom> atoms = gr.getAtoms();\n                for (int atomnr = 0; atomnr < atoms.size(); atomnr++) {\n                    Atom atom = atoms.get(atomnr);\n                    xw.openTag(\"atom\");\n                    xw.attribute(\"atomID\", Integer.toString(atom.getPDBserial()));\n                    xw.attribute(\"atomName\", formatAtomName(atom));\n                    xw.attribute(\"x\", Double.toString(atom.getX()));\n                    xw.attribute(\"y\", Double.toString(atom.getY()));\n                    xw.attribute(\"z\", Double.toString(atom.getZ()));\n                    xw.closeTag(\"atom\");\n                }\n                xw.closeTag(\"group\");\n            }\n            xw.closeTag(\"chain\");\n        }\n    }\n    if (doPrintConnections()) {\n        // not supported anymore since 5.0\n    }\n}", "repo_id": "9", "comment": "/**\n * Convert a protein Structure to a DAS Structure XML response .\n * Since 5.0, bond (CONECT records) information is not supported anymore.\n * @param xw  a XMLWriter object\n * @throws IOException ...\n */\n", "repo_name": "biojava-master/", "id": 1158, "method_signature": "void toDASStructure(XMLWriter)"}, "2022": {"callee_method_names": ["Matrix3d.rotZ", "Matrix3d.transform", "Point3d[].sub", "Point3d[].add"], "method_name": "Prism.getVertices", "method_implementation": "{\n    Point3d[] polygon = new Point3d[2 * n];\n    Matrix3d m = new Matrix3d();\n    Point3d center = new Point3d(0, 0, height / 2);\n    for (int i = 0; i < n; i++) {\n        polygon[i] = new Point3d(0, circumscribedRadius, 0);\n        m.rotZ(i * 2 * Math.PI / n);\n        m.transform(polygon[i]);\n        polygon[n + i] = new Point3d(polygon[i]);\n        polygon[i].sub(center);\n        polygon[n + i].add(center);\n    }\n    return polygon;\n}", "repo_id": "9", "comment": "/**\n * Returns the vertices of an n-fold polygon of given radius and center\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2022, "method_signature": "Point3d[] getVertices()"}, "2689": {"callee_method_names": [], "method_name": "Edit.getEnd", "method_implementation": "{\n    if (getEnd() == -1) {\n        int start = getStart();\n        int length = getTargetSequence(sequence).getLength();\n        return (start + length) - 1;\n    }\n    return getEnd();\n}", "repo_id": "9", "comment": "/**\n * Must use this rather than the no-args getEnd as this can return\n * -1 and the length of a sub is dependent on the length of the\n * Sequence; we cannot assume 1:1 mapping between characters in a\n * String and the number of compounds we will have to insert.\n */\n", "repo_name": "biojava-master/", "id": 2689, "method_signature": "int getEnd(Sequence)"}, "1118": {"callee_method_names": [], "method_name": "SiftsChainEntry.getPdbStart", "method_implementation": "{\n    return pdbStart;\n}", "repo_id": "9", "comment": "/**\n * @return A residue number\n */\n", "repo_name": "biojava-master/", "id": 1118, "method_signature": "String getPdbStart()"}, "2860": {"callee_method_names": [], "method_name": "ABITrace.getTraceLength", "method_implementation": "{\n    return traceLength;\n}", "repo_id": "9", "comment": "/**\n * Returns the length of the trace (number of x-coordinate points in the graph).\n *\n * @return int traceLength\n */\n", "repo_name": "biojava-master/", "id": 2860, "method_signature": "int getTraceLength()"}, "2004": {"callee_method_names": [], "method_name": "Octahedron.getMidRadius", "method_implementation": "{\n    double side = getSideLengthFromCircumscribedRadius(cirumscribedRadius);\n    return getMiddleRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a sphere, that is tangent to each\n * of the octahedron's edges\n *\n * @return the midRadius\n */\n", "repo_name": "biojava-master/", "id": 2004, "method_signature": "double getMidRadius()"}, "3237": {"callee_method_names": ["BiojavaJmol.setStructure", "BiojavaJmol.evalString", "BiojavaJmol.evalString", "BiojavaJmol.evalString"], "method_name": "DemoStructureFromFasta.displayStructure", "method_implementation": "{\n    //Display each structure\n    BiojavaJmol jmol = new BiojavaJmol();\n    jmol.setStructure(structure);\n    //Highlight non-null atoms\n    jmol.evalString(\"select *; spacefill off; wireframe off; color chain; backbone 0.4;  \");\n    String selectionCmd = buildJmolSelection(residues);\n    jmol.evalString(selectionCmd);\n    jmol.evalString(\"backbone 1.0; select none;\");\n}", "repo_id": "9", "comment": "/**\n * Displays the given structure and highlights the given residues.\n *\n * @param structure The structure to display\n * @param residues A list of residues to highlight\n */\n", "repo_name": "biojava-master/", "id": 3237, "method_signature": "void displayStructure(Structure, ResidueNumber[])"}, "828": {"callee_method_names": ["Structure.toPDB"], "method_name": "AlternativeAlignment.toPDB", "method_implementation": "{\n    Structure newpdb = getAlignedStructure(s1, s2);\n    return newpdb.toPDB();\n}", "repo_id": "9", "comment": "/**\n * converts the alignment to a PDB file\n * each of the structures will be represented as a model.\n *\n * @param s1\n * @param s2\n * @return a PDB file as a String\n */\n", "repo_name": "biojava-master/", "id": 828, "method_signature": "String toPDB(Structure, Structure)"}, "795": {"callee_method_names": [], "method_name": "CeUserArgumentProcessor.getMaxOptRMSD", "method_implementation": "{\n    return maxOptRMSD;\n}", "repo_id": "9", "comment": "/**\n * (jCE specific): maximum RMSD that shall be calculated for the alignment.\n *\n *  @return maxOptRMSD parameter\n */\n", "repo_name": "biojava-master/", "id": 795, "method_signature": "Double getMaxOptRMSD()"}, "265": {"callee_method_names": [], "method_name": "ModificationLinkage.getIndexOfComponent2", "method_implementation": "{\n    return indexOfComponent2;\n}", "repo_id": "9", "comment": "/**\n * @return index of the second component.\n */\n", "repo_name": "biojava-master/", "id": 265, "method_signature": "int getIndexOfComponent2()"}, "3392": {"callee_method_names": ["RotationGroup.getPointGroup"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.drawAxes", "method_implementation": "{\n    if (\"C1\".equals(rotationGroup.getPointGroup())) {\n        return drawInertiaAxes();\n    } else {\n        return drawSymmetryAxes();\n    }\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#drawAxes()\n\t */\n", "repo_name": "biojava-master/", "id": 3392, "method_signature": "String drawAxes()"}, "2229": {"callee_method_ids": [1190], "callee_method_names": ["PDBFileParser.setFileParsingParameters", "PDBFileParser.parsePDBFile", "Structure.getNonPolyChainsByPDB", "Chain.getAtomGroups", "Structure.getNonPolyChainsByPDB", "Chain.getAtomGroups", "Structure.getChains", "Structure.getChains"], "method_name": "TestNonDepositedFiles.testNewLigandChain", "method_implementation": "{\n    // Test the file parsing speed when the files are already downloaded.\n    InputStream pdbStream = new GZIPInputStream(this.getClass().getResourceAsStream(\"/ligandTest.pdb.gz\"));\n    InputStream cifStream = new GZIPInputStream(this.getClass().getResourceAsStream(\"/ligandTest.cif.gz\"));\n    assertNotNull(cifStream);\n    assertNotNull(pdbStream);\n    FileParsingParameters params = new FileParsingParameters();\n    PDBFileParser pdbpars = new PDBFileParser();\n    pdbpars.setFileParsingParameters(params);\n    Structure s1 = pdbpars.parsePDBFile(pdbStream);\n    // The chain B should be present with 1 ligand HEM\n    Chain c1 = s1.getNonPolyChainsByPDB(\"B\").get(0);\n    assertNotNull(c1);\n    int expectedNumLigands = 1;\n    assertEquals(expectedNumLigands, c1.getAtomGroups().size());\n    Structure s2 = CifStructureConverter.fromInputStream(cifStream, params);\n    // The chain B should be present with 1 ligand HEM\n    Chain c2 = s2.getNonPolyChainsByPDB(\"B\").get(0);\n    assertNotNull(c2);\n    assertEquals(expectedNumLigands, c2.getAtomGroups().size());\n    // pdb and mmcif should have same number of chains\n    assertEquals(s1.getChains().size(), s2.getChains().size());\n}", "repo_id": "9", "comment": "/**\n * This test represents a common situation for a non-deposited structure.\n * When building with common crystallography software, the user often adds new\n * ligands (or solvent) molecules as new chains.  Only prior to deposition\n * then relabel them so that they belong to the same chain as the polymeric residues.\n *\n * In this case, the ligands represent valuable information and should not be discarded.\n */\n", "repo_name": "biojava-master/", "id": 2229, "method_signature": "void testNewLigandChain()"}, "3863": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getExtinctionCoefficient"], "method_name": "PeptideProperties.getExtinctionCoefficient", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getExtinctionCoefficient(pSequence, assumeCysReduced);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the extinction coefficient of sequence. The sequence argument\n * must be a protein sequence consisting of only non-ambiguous characters.\n * The extinction coefficient indicates how much light a protein absorbs at\n * a certain wavelength. It is useful to have an estimation of this\n * coefficient for following a protein which a spectrophotometer when\n * purifying it. The computation of extinction coefficient follows the\n * documentation in <a href=\"http://web.expasy.org/protparam/protparam-doc.html\">here</a>.\n *\n * @param sequence\n *            a protein sequence consisting of non-ambiguous characters only\n * @param assumeCysReduced\n *            true if Cys are assumed to be reduced and false if Cys are\n *            assumed to form cystines\n * @return the extinction coefficient of sequence\n */\n", "repo_name": "biojava-master/", "id": 3863, "method_signature": "double getExtinctionCoefficient(String, boolean)"}, "1934": {"callee_method_ids": [1939, 1941, 1945, 1947, 1949, 1943], "callee_method_names": ["QuatSymmetrySubunits.getTraces", "List<Point3d[]>.size", "List<Integer>.get", "List<Point3d[]>.get", "List<Point3d[]>.get", "List<Integer>.get", "Point3d.set", "Matrix4d.transform", "Point3d[].distanceSquared", "QuatSymmetryScores.setMinRmsd", "QuatSymmetryScores.setMaxRmsd", "QuatSymmetryScores.setMinTm", "QuatSymmetryScores.setMaxTm", "QuatSymmetryScores.setTm", "QuatSymmetryScores.setRmsd"], "method_name": "QuatSuperpositionScorer.calcScores", "method_implementation": "{\n    QuatSymmetryScores scores = new QuatSymmetryScores();\n    double minTm = Double.MAX_VALUE;\n    double maxTm = Double.MIN_VALUE;\n    double minRmsd = Double.MAX_VALUE;\n    double maxRmsd = Double.MIN_VALUE;\n    double totalSumTm = 0;\n    double totalSumDsq = 0;\n    double totalLength = 0;\n    Point3d t = new Point3d();\n    List<Point3d[]> traces = subunits.getTraces();\n    // loop over the Calpha atoms of all subunits\n    for (int i = 0; i < traces.size(); i++) {\n        // in helical systems not all permutations involve all subunit. -1 indicates subunits that should not be permuted.\n        if (permutation.get(i) == -1) {\n            continue;\n        }\n        // get original subunit\n        Point3d[] orig = traces.get(i);\n        totalLength += orig.length;\n        // get permuted subunit\n        Point3d[] perm = traces.get(permutation.get(i));\n        // calculate TM specific parameters\n        // don't let d0 get negative with short sequences\n        int tmLen = Math.max(orig.length, 17);\n        double d0 = 1.24 * Math.cbrt(tmLen - 15.0) - 1.8;\n        double d0Sq = d0 * d0;\n        double sumTm = 0;\n        double sumDsq = 0;\n        for (int j = 0; j < orig.length; j++) {\n            // transform coordinates of the permuted subunit\n            t.set(perm[j]);\n            transformation.transform(t);\n            double dSq = orig[j].distanceSquared(t);\n            sumTm += 1.0 / (1.0 + dSq / d0Sq);\n            sumDsq += dSq;\n        }\n        // scores for individual subunits\n        double sTm = sumTm / tmLen;\n        minTm = Math.min(minTm, sTm);\n        maxTm = Math.max(maxTm, sTm);\n        double sRmsd = Math.sqrt(sumDsq / orig.length);\n        minRmsd = Math.min(minRmsd, sRmsd);\n        maxRmsd = Math.max(maxRmsd, sRmsd);\n        totalSumTm += sumTm;\n        totalSumDsq += sumDsq;\n    }\n    // save scores for individual subunits\n    scores.setMinRmsd(minRmsd);\n    scores.setMaxRmsd(maxRmsd);\n    scores.setMinTm(minTm);\n    scores.setMaxTm(maxTm);\n    // save mean scores over all subunits\n    scores.setTm(totalSumTm / totalLength);\n    scores.setRmsd(Math.sqrt(totalSumDsq / totalLength));\n    // add intra subunit scores\n    calcIntrasubunitScores(subunits, transformation, permutation, scores);\n    return scores;\n}", "repo_id": "9", "comment": "/**\n * Returns minimum, mean, and maximum RMSD and TM-Score for two superimposed sets of subunits\n *\n * TM score: Yang Zhang and Jeffrey Skolnick, PROTEINS: Structure, Function, and Bioinformatics 57:702\u2013710 (2004)\n * @param subunits subunits to be scored\n * @param transformation transformation matrix\n * @param permutations permutation that determines which subunits are superposed\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1934, "method_signature": "QuatSymmetryScores calcScores(QuatSymmetrySubunits, Matrix4d, List)"}, "3566": {"callee_method_names": [], "method_name": "CoxR.chinv2", "method_implementation": "{\n    double temp;\n    int i, j, k;\n    /*\n\t\t ** invert the cholesky in the lower triangle\n\t\t **   take full advantage of the cholesky's diagonal of 1's\n\t\t */\n    for (i = 0; i < n; i++) {\n        if (matrix[i][i] > 0) {\n            matrix[i][i] = 1 / matrix[i][i];\n            /*this line inverts D */\n            for (j = (i + 1); j < n; j++) {\n                matrix[j][i] = -matrix[j][i];\n                for (k = 0; k < i; k++) /*sweep operator */\n                {\n                    matrix[j][k] += matrix[j][i] * matrix[i][k];\n                }\n            }\n        }\n    }\n    /*\n\t\t ** lower triangle now contains inverse of cholesky\n\t\t ** calculate F'DF (inverse of cholesky decomp process) to get inverse\n\t\t **   of original matrix\n\t\t */\n    for (i = 0; i < n; i++) {\n        if (matrix[i][i] == 0) {\n            /* singular row */\n            for (j = 0; j < i; j++) {\n                matrix[j][i] = 0;\n            }\n            for (j = i; j < n; j++) {\n                matrix[i][j] = 0;\n            }\n        } else {\n            for (j = (i + 1); j < n; j++) {\n                temp = matrix[j][i] * matrix[j][j];\n                if (j != i) {\n                    matrix[i][j] = temp;\n                }\n                for (k = i; k < j; k++) {\n                    matrix[i][k] += temp * matrix[j][k];\n                }\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/* $Id: chinv2.c 11357 2009-09-04 15:22:46Z therneau $\n\t **\n\t ** matrix inversion, given the FDF' cholesky decomposition\n\t **\n\t ** input  **matrix, which contains the chol decomp of an n by n\n\t **   matrix in its lower triangle.\n\t **\n\t ** returned: the upper triangle + diagonal contain (FDF')^{-1}\n\t **            below the diagonal will be F inverse\n\t **\n\t **  Terry Therneau\n\t */\n", "repo_name": "biojava-master/", "id": 3566, "method_signature": "void chinv2(double[][], int)"}, "3400": {"callee_method_names": ["RotationAxisAligner.getDimension"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getMeanExtension", "method_implementation": "{\n    Vector3d dimension = rotationAxisAligner.getDimension();\n    return (dimension.x + dimension.y + dimension.z) / 3;\n}", "repo_id": "9", "comment": "/**\n * Returns the mean extension (length) of structure\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3400, "method_signature": "double getMeanExtension()"}, "1490": {"callee_method_names": [], "method_name": "CalcPoint.formMatrix", "method_implementation": "{\n    double xx = 0.0, xy = 0.0, xz = 0.0;\n    double yx = 0.0, yy = 0.0, yz = 0.0;\n    double zx = 0.0, zy = 0.0, zz = 0.0;\n    for (int i = 0; i < a.length; i++) {\n        xx += a[i].x * b[i].x;\n        xy += a[i].x * b[i].y;\n        xz += a[i].x * b[i].z;\n        yx += a[i].y * b[i].x;\n        yy += a[i].y * b[i].y;\n        yz += a[i].y * b[i].z;\n        zx += a[i].z * b[i].x;\n        zy += a[i].z * b[i].y;\n        zz += a[i].z * b[i].z;\n    }\n    double[][] f = new double[4][4];\n    f[0][0] = xx + yy + zz;\n    f[0][1] = zy - yz;\n    f[1][0] = f[0][1];\n    f[1][1] = xx - yy - zz;\n    f[0][2] = xz - zx;\n    f[2][0] = f[0][2];\n    f[1][2] = xy + yx;\n    f[2][1] = f[1][2];\n    f[2][2] = yy - zz - xx;\n    f[0][3] = yx - xy;\n    f[3][0] = f[0][3];\n    f[1][3] = zx + xz;\n    f[3][1] = f[1][3];\n    f[2][3] = yz + zy;\n    f[3][2] = f[2][3];\n    f[3][3] = zz - xx - yy;\n    return new Matrix(f);\n}", "repo_id": "9", "comment": "/*\n\t * Peter can you document this method? TODO\n\t *\n\t * @param moved\n\t * @param fixed\n\t * @return\n\t */\n", "repo_name": "biojava-master/", "id": 1490, "method_signature": "Matrix formMatrix(Point3d[], Point3d[])"}, "2745": {"callee_method_names": [], "method_name": "EmblRecord.getKeyword", "method_implementation": "{\n    return keyword;\n}", "repo_id": "9", "comment": "/**\n * The KW (KeyWord) lines provide information which can be used to generate\n * cross-reference indexes of the sequence entries based on functional,\n * structural, or other categories deemed important.\n *\n * @return List<String>\n */\n", "repo_name": "biojava-master/", "id": 2745, "method_signature": "List<String> getKeyword()"}, "1554": {"callee_method_names": ["Map<String, List<ScopDomain>>.keySet", "Map<String, List<ScopDomain>>.get", "double[].getPx", "List<ScopDomain>.add", "double[].clone", "double[].getSpeciesId", "List<ScopDomain>.add", "double[].clone", "double[].getDomainId", "List<ScopDomain>.add", "double[].clone", "double[].getFamilyId", "List<ScopDomain>.add", "double[].clone", "double[].getSuperfamilyId", "List<ScopDomain>.add", "double[].clone", "double[].getFoldId", "List<ScopDomain>.add", "double[].clone", "double[].getClassId", "List<ScopDomain>.add", "double[].clone"], "method_name": "ScopInstallation.getScopDomainsBySunid", "method_implementation": "{\n    try {\n        ensureClaInstalled();\n    } catch (IOException e) {\n        throw new ScopIOException(e);\n    }\n    List<ScopDomain> domains = new ArrayList<ScopDomain>();\n    for (String pdbId : domainMap.keySet()) {\n        for (ScopDomain d : domainMap.get(pdbId)) {\n            try {\n                if (d.getPx() == sunid) {\n                    domains.add((ScopDomain) d.clone());\n                } else if (d.getSpeciesId() == sunid) {\n                    domains.add((ScopDomain) d.clone());\n                } else if (d.getDomainId() == sunid) {\n                    domains.add((ScopDomain) d.clone());\n                } else if (d.getFamilyId() == sunid) {\n                    domains.add((ScopDomain) d.clone());\n                } else if (d.getSuperfamilyId() == sunid) {\n                    domains.add((ScopDomain) d.clone());\n                } else if (d.getFoldId() == sunid) {\n                    domains.add((ScopDomain) d.clone());\n                } else if (d.getClassId() == sunid) {\n                    domains.add((ScopDomain) d.clone());\n                } else {\n                    // only possible if SCOP changes\n                    throw new RuntimeException(\"Type \" + d + \" not recognized\");\n                }\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(ScopDomain.class + \" subclass does not support clone()\", e);\n            }\n        }\n    }\n    return domains;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopDomainsBySunid(java.lang.Integer)\n\t */\n", "repo_name": "biojava-master/", "id": 1554, "method_signature": "List<ScopDomain> getScopDomainsBySunid(Integer)"}, "2149": {"callee_method_names": ["Vector3d.setParent"], "method_name": "StructureImpl.setDBRefs", "method_implementation": "{\n    if (dbrefs == null)\n        throw new IllegalArgumentException(\"trying to set dbrefs to null!\");\n    for (DBRef ref : dbrefs) {\n        ref.setParent(this);\n    }\n    this.dbrefs = dbrefs;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2149, "method_signature": "void setDBRefs(List)"}, "1735": {"callee_method_names": [], "method_name": "BasePairParameters.getRise", "method_implementation": "{\n    if (bp < 0 || bp >= getStepParameters().length)\n        throw new IllegalArgumentException(\"Base pair number is out of range.\");\n    return stepParameters[bp][5];\n}", "repo_id": "9", "comment": "/**\n * This method returns the rise for the given base pair, relative to the one before it.\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in \u00c5)\n */\n", "repo_name": "biojava-master/", "id": 1735, "method_signature": "Double getRise(int)"}, "3388": {"callee_method_names": ["RotationAxisAligner.getTransformation"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getTransformation", "method_implementation": "{\n    return rotationAxisAligner.getTransformation();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#getTransformation()\n\t */\n", "repo_name": "biojava-master/", "id": 3388, "method_signature": "Matrix4d getTransformation()"}, "188": {"callee_method_ids": [1929], "callee_method_names": ["QuatSymmetryResults.getSymmetry", "QuatSymmetryResults.getStoichiometry"], "method_name": "TestQuatSymmetryDetectorExamples.testHelical", "method_implementation": "{\n    Structure pdb = StructureIO.getStructure(\"BIO:1B47:1\");\n    SubunitClustererParameters cp = new SubunitClustererParameters();\n    QuatSymmetryParameters symmParams = new QuatSymmetryParameters();\n    QuatSymmetryResults symmetry = QuatSymmetryDetector.calcGlobalSymmetry(pdb, symmParams, cp);\n    // H symmetry A3 stoichiometry\n    assertEquals(\"H\", symmetry.getSymmetry());\n    assertEquals(\"A3\", symmetry.getStoichiometry().toString());\n}", "repo_id": "9", "comment": "/**\n * A structure with helical symmetry: 1B47\n *\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 188, "method_signature": "void testHelical()"}, "2638": {"callee_method_names": [], "method_name": "DNASequence.getGCCount", "method_implementation": "{\n    return SequenceMixin.countGC(this);\n}", "repo_id": "9", "comment": "/**\n * Get the GC count in the DNA Sequence\n * @return GC count\n */\n", "repo_name": "biojava-master/", "id": 2638, "method_signature": "int getGCCount()"}, "1123": {"callee_method_names": ["File.toString"], "method_name": "LocalPDBDirectory.getPath", "method_implementation": "{\n    return path.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns the path value.\n * @return a String representing the path value\n * @see #setPath\n */\n", "repo_name": "biojava-master/", "id": 1123, "method_signature": "String getPath()"}, "896": {"callee_method_names": ["String.equals", "String.charAt", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "StructureInterface.toPDB", "method_implementation": "{\n    String molecId1 = getMoleculeIds().getFirst();\n    String molecId2 = getMoleculeIds().getSecond();\n    if (molecId2.equals(molecId1)) {\n        // if both chains are named equally we want to still named them differently in the output pdb file\n        // so that molecular viewers can handle properly the 2 chains as separate entities\n        char letter = molecId1.charAt(0);\n        if (letter != 'Z' && letter != 'z') {\n            // i.e. next letter in alphabet\n            molecId2 = Character.toString((char) (letter + 1));\n        } else {\n            //i.e. 'A' or 'a'\n            molecId2 = Character.toString((char) (letter - 25));\n        }\n    }\n    StringBuilder sb = new StringBuilder();\n    for (Atom atom : this.molecules.getFirst()) {\n        sb.append(FileConvert.toPDB(atom, molecId1));\n    }\n    sb.append(\"TER\");\n    sb.append(System.getProperty(\"line.separator\"));\n    for (Atom atom : this.molecules.getSecond()) {\n        sb.append(FileConvert.toPDB(atom, molecId2));\n    }\n    sb.append(\"TER\");\n    sb.append(System.getProperty(\"line.separator\"));\n    sb.append(\"END\");\n    sb.append(System.getProperty(\"line.separator\"));\n    return sb.toString();\n}", "repo_id": "9", "comment": "/**\n * Return a String representing the 2 molecules of this interface in PDB format.\n * If the molecule ids (i.e. chain ids) are the same for both molecules, then the second\n * one will be replaced by the next letter in alphabet (or A for Z)\n * @return the PDB-formatted string\n */\n", "repo_name": "biojava-master/", "id": 896, "method_signature": "String toPDB()"}, "3270": {"callee_method_names": [], "method_name": "AbstractAlignmentJmol.setJmolPanel", "method_implementation": "{\n    this.jmolPanel = jmolPanel;\n}", "repo_id": "9", "comment": "/**\n * Set the jmolPanel of the AlignmentJmol instance.\n * @param jmolPanel\n */\n", "repo_name": "biojava-master/", "id": 3270, "method_signature": "void setJmolPanel(JmolPanel)"}, "3229": {"callee_method_names": [], "method_name": "SequenceTestUtils.anyGeneSequence", "method_implementation": "{\n    ChromosomeSequence chr = new ChromosomeSequence(ChromosomeSequenceTest.CHROMOSOME_SEQ);\n    return new GeneSequence(chr, new AccessionID(\"someGeneId\"), 10, 200, Strand.POSITIVE);\n}", "repo_id": "9", "comment": "/**\n * A gene sequence of 190 bp length on + strand\n *\n * @return\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 3229, "method_signature": "GeneSequence anyGeneSequence()"}, "65": {"callee_method_names": [], "method_name": "AbstractMatrixAligner.setSubstitutionMatrix", "method_implementation": "{\n    this.subMatrix = subMatrix;\n    reset();\n}", "repo_id": "9", "comment": "/**\n * Sets the substitution matrix.\n *\n * @param subMatrix the set of substitution scores used during alignment\n */\n", "repo_name": "biojava-master/", "id": 65, "method_signature": "void setSubstitutionMatrix(SubstitutionMatrix)"}, "477": {"callee_method_names": [], "method_name": "AFPChain.getNrEQR", "method_implementation": "{\n    if (myResultsEQR < 0) {\n        if (optLen == null) {\n            myResultsEQR = 0;\n            return 0;\n        }\n        int nrEqr = 0;\n        for (int bk = 0; bk < blockNum; bk++) {\n            for (int i = 0; i < optLen[bk]; i++) {\n                nrEqr++;\n            }\n        }\n        myResultsEQR = nrEqr;\n    }\n    return myResultsEQR;\n}", "repo_id": "9", "comment": "/**\n * Get the number of structurally equivalent residues\n *\n * @return nr of EQR\n */\n", "repo_name": "biojava-master/", "id": 477, "method_signature": "int getNrEQR()"}, "44": {"callee_method_names": [], "method_name": "Alignments.getPairwiseScore", "method_implementation": "{\n    return getPairwiseScorer(query, target, type, gapPenalty, subMatrix).getScore();\n}", "repo_id": "9", "comment": "/**\n * Factory method which computes a similarity score for the given {@link Sequence} pair.\n *\n * @param <S> each {@link Sequence} of the pair is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n * @param query the first {@link Sequence} to score\n * @param target the second {@link Sequence} to score\n * @param type chosen type from list of pairwise sequence scoring routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return sequence pair score\n */\n", "repo_name": "biojava-master/", "id": 44, "method_signature": "double getPairwiseScore(S, S, PairwiseSequenceScorerType, GapPenalty, SubstitutionMatrix)"}, "3271": {"callee_method_names": ["Logger.error", "JmolPanel.evalString"], "method_name": "AbstractAlignmentJmol.evalString", "method_implementation": "{\n    if (jmolPanel == null) {\n        logger.error(\"please install Jmol first\");\n        return;\n    }\n    jmolPanel.evalString(rasmolScript);\n}", "repo_id": "9", "comment": "/**\n * Execute a command String in the current Jmol panel.\n * @param rasmolScript\n */\n", "repo_name": "biojava-master/", "id": 3271, "method_signature": "void evalString(String)"}, "3126": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getCompoundSet", "method_implementation": "{\n    return compoundSet;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3126, "method_signature": "CompoundSet<C> getCompoundSet()"}, "119": {"callee_method_names": ["NeedlemanWunsch<DNASequence, NucleotideCompound>.addAnchor", "NeedlemanWunsch<DNASequence, NucleotideCompound>.addAnchor", "NeedlemanWunsch<DNASequence, NucleotideCompound>.addAnchor", "NeedlemanWunsch<DNASequence, NucleotideCompound>.addAnchor", "NeedlemanWunsch<DNASequence, NucleotideCompound>.getPair"], "method_name": "NeedlemanWunschTest.should_align_multiple_anchors", "method_implementation": "{\n    DNASequence query = new DNASequence(\"ACGT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"ATACGT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    NeedlemanWunsch<DNASequence, NucleotideCompound> aligner = new NeedlemanWunsch<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 0, (short) 10), SubstitutionMatrixHelper.getNuc4_4());\n    aligner.addAnchor(0, 0);\n    aligner.addAnchor(1, 1);\n    aligner.addAnchor(2, 2);\n    aligner.addAnchor(3, 5);\n    assertEquals(String.format(\"ACG--T%nATACGT%n\"), aligner.getPair().toString());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 119, "method_signature": "void should_align_multiple_anchors()"}, "307": {"callee_method_names": [], "method_name": "ModificationConditionImpl.getComponents", "method_implementation": "{\n    return components;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}}\n */\n", "repo_name": "biojava-master/", "id": 307, "method_signature": "List<Component> getComponents()"}, "2058": {"callee_method_ids": [2053], "callee_method_names": ["Logger.debug", "CESymmParameters.getWinSize", "CESymmParameters.getMinCoreLength", "List<CeSymmResult>.isEmpty", "Logger.debug", "CESymmParameters.getSymmLevels", "List<CeSymmResult>.size", "CESymmParameters.getSymmLevels", "CESymmParameters.getRefineMethod", "CeSymmResult.isSignificant", "List<CeSymmResult>.isEmpty", "List<CeSymmResult>.add", "CeSymmResult.getMultipleAlignment", "CeSymmResult.getMultipleAlignment", "CeSymmResult.getMultipleAlignment", "CESymmParameters.getSSEThreshold", "List<CeSymmResult>.isEmpty", "List<CeSymmResult>.add", "CeSymmResult.getMultipleAlignment", "Block.length", "Block.size", "Block.getAlignRes", "Block.getAlignRes", "Graph<Integer, DefaultEdge>.addVertex", "Graph<Integer, DefaultEdge>.addVertex", "Graph<Integer, DefaultEdge>.addEdge", "List<CeSymmResult>.add"], "method_name": "CeSymmIterative.iterate", "method_implementation": "{\n    logger.debug(\"Starting new iteration...\");\n    // Return if the Atom array is too short\n    if ((atoms.length <= params.getWinSize() || atoms.length <= params.getMinCoreLength()) && !levels.isEmpty()) {\n        logger.debug(\"Aborting iteration due to insufficient Atom array length: %d\", atoms.length);\n        return;\n    }\n    // Return if the maximum levels of symmetry have been reached\n    if (params.getSymmLevels() > 0) {\n        if (levels.size() == params.getSymmLevels())\n            return;\n    }\n    // Perform one level CeSymm alignment\n    CeSymmResult result = CeSymm.analyzeLevel(atoms, params);\n    if (params.getRefineMethod() == RefineMethod.NOT_REFINED || !result.isSignificant()) {\n        if (levels.isEmpty())\n            levels.add(result);\n        return;\n    }\n    // Generate the Atoms of one of the symmetric repeat\n    Integer start = null;\n    int it = 0;\n    while (start == null) {\n        start = result.getMultipleAlignment().getBlocks().get(0).getAlignRes().get(0).get(it);\n        it++;\n    }\n    Integer end = null;\n    it = result.getMultipleAlignment().getBlocks().get(0).getAlignRes().get(0).size() - 1;\n    while (end == null) {\n        end = result.getMultipleAlignment().getBlocks().get(0).getAlignRes().get(0).get(it);\n        it--;\n    }\n    Atom[] atomsR = Arrays.copyOfRange(atoms, start, end + 1);\n    // Check the SSE requirement\n    if (countHelixStrandSSE(atomsR) < params.getSSEThreshold()) {\n        if (levels.isEmpty())\n            levels.add(result);\n        return;\n    }\n    // If symmetric store the residue dependencies in alignment graph\n    Block b = result.getMultipleAlignment().getBlock(0);\n    for (int pos = 0; pos < b.length(); pos++) {\n        for (int su = 0; su < b.size() - 1; su++) {\n            Integer pos1 = b.getAlignRes().get(su).get(pos);\n            Integer pos2 = b.getAlignRes().get(su + 1).get(pos);\n            // Add edge from lower to higher positions\n            if (pos1 != null && pos2 != null) {\n                alignGraph.addVertex(pos1);\n                alignGraph.addVertex(pos2);\n                alignGraph.addEdge(pos1, pos2);\n            }\n        }\n    }\n    // Iterate further on those Atoms (of the first repeat only)\n    levels.add(result);\n    iterate(atomsR);\n}", "repo_id": "9", "comment": "/**\n * This method runs iteratively the analysis of one level of symmetry with\n * CeSymm on the input Atom array until no more symmetries exist.\n *\n * @param atoms\n *            representative Atom array of the Structure\n * @return true if any symmetry was found, false if asymmetric\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2058, "method_signature": "void iterate(Atom[])"}, "1306": {"callee_method_names": ["FastaReader<ProteinSequence, AminoAcidCompound>.process", "InputStream.close"], "method_name": "FastaAFPChainConverter.fastaFileToAfpChain", "method_implementation": "{\n    InputStream inStream = new FileInputStream(fastaFile);\n    SequenceCreatorInterface<AminoAcidCompound> creator = new CasePreservingProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet());\n    SequenceHeaderParserInterface<ProteinSequence, AminoAcidCompound> headerParser = new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>();\n    FastaReader<ProteinSequence, AminoAcidCompound> fastaReader = new FastaReader<ProteinSequence, AminoAcidCompound>(inStream, headerParser, creator);\n    LinkedHashMap<String, ProteinSequence> sequences = fastaReader.process();\n    inStream.close();\n    return fastaToAfpChain(sequences, structure1, structure2);\n}", "repo_id": "9", "comment": "/**\n * Reads the file {@code fastaFile}, expecting exactly two sequences which give a pairwise alignment. Uses this and two structures to create an AFPChain corresponding to the alignment. Uses a\n * {@link CasePreservingProteinSequenceCreator} and assumes that a residue is aligned if and only if it is given by an uppercase letter.\n *\n * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 1306, "method_signature": "AFPChain fastaFileToAfpChain(File, Structure, Structure)"}, "1763": {"callee_method_names": [], "method_name": "PDBHeader.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * Get the ID used by Hibernate.\n *\n * @return the ID used by Hibernate\n * @see #setId(Long)\n */\n", "repo_name": "biojava-master/", "id": 1763, "method_signature": "Long getId()"}, "2007": {"callee_method_names": [], "method_name": "Tetrahedron.getCirumscribedRadius", "method_implementation": "{\n    return circumscribedRadius;\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a circumscribed sphere, that goes\n * through all vertices\n * @return the cirumscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2007, "method_signature": "double getCirumscribedRadius()"}, "2572": {"callee_method_names": ["File.getParentFile", "File.getName", "File.exists", "Scanner.nextLong", "File.length", "Logger.warn", "Logger.warn", "File.getParentFile", "File.getName", "String.matches", "File.getName", "String.substring", "String.lastIndexOf"], "method_name": "FileDownloadUtils.validateFile", "method_implementation": "{\n    File sizeFile = new File(localFile.getParentFile(), localFile.getName() + SIZE_EXT);\n    if (sizeFile.exists()) {\n        try (Scanner scanner = new Scanner(sizeFile)) {\n            long expectedSize = scanner.nextLong();\n            long actualSize = localFile.length();\n            if (expectedSize != actualSize) {\n                logger.warn(\"File [{}] size ({}) does not match expected size ({}).\", localFile, actualSize, expectedSize);\n                return false;\n            }\n        } catch (FileNotFoundException e) {\n            logger.warn(\"could not validate size of file [{}] because no size metadata file exists.\", localFile);\n        }\n    }\n    File[] hashFiles = localFile.getParentFile().listFiles(new FilenameFilter() {\n\n        final String hashPattern = String.format(\"%s%s_(%s|%s|%s)\", localFile.getName(), HASH_EXT, Hash.MD5, Hash.SHA1, Hash.SHA256);\n\n        @Override\n        public boolean accept(File dir, String name) {\n            return name.matches(hashPattern);\n        }\n    });\n    if (hashFiles.length > 0) {\n        File hashFile = hashFiles[0];\n        String name = hashFile.getName();\n        String algo = name.substring(name.lastIndexOf('_') + 1);\n        switch(Hash.valueOf(algo)) {\n            case MD5:\n            case SHA1:\n            case SHA256:\n                throw new UnsupportedOperationException(\"Not yet implemented\");\n            case UNKNOWN:\n            default:\n                // No need. Already checked above\n                throw new IllegalArgumentException(\"Hashing algorithm not known: \" + algo);\n        }\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Validate a local file based on pre-existing metadata files for size and hash.<br>\n * If the passed in <code>localFile</code> parameter is a file named <code>file.ext</code>, the function searches in the same folder for:\n * <ul>\n * <li><code>file.ext.size</code>: If found, it compares the size stored in it to the length of <code>localFile</code> (in bytes).</li>\n * <li><code>file.ext.hash_XXXX (where XXXX is DM5, SHA1, or SHA256)</code>: If found, it compares the size stored in it to the hash code of <code>localFile</code>.</li>\n * </ul>\n * If any of these comparisons fail, the function returns <code>false</code>. otherwise it returns true.\n * <p>\n * <b>N.B.</b> None of the 3 common verification hashing algorithms are implement yet.\n * @param localFile The file to validate\n * @return <code>false</code> if any of the size or hash code metadata files exists but its contents does not match the expected value in the file, <code>true</code> otherwise.\n * @since 7.0.0\n */\n", "repo_name": "biojava-master/", "id": 2572, "method_signature": "boolean validateFile(File)"}, "3803": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getRight", "method_implementation": "{\n    return right;\n}", "repo_id": "9", "comment": "/**\n * @return the right\n */\n", "repo_name": "biojava-master/", "id": 3803, "method_signature": "int getRight()"}, "2294": {"callee_method_names": ["Structure.getChains", "ChemComp.getAtomGroups", "List<Group>.size", "Group.getAtoms", "Block.getName", "Block.getBonds", "List<Integer>.add", "List<Atom>.indexOf", "Chain.getOther", "List<Integer>.contains"], "method_name": "TestBond.testNucleotideBonds", "method_implementation": "{\n    Structure bio = StructureIO.getStructure(\"4y60\");\n    for (Chain c : bio.getChains()) {\n        int groupCounter = 0;\n        List<Group> currentGroups = c.getAtomGroups();\n        for (Group g : currentGroups) {\n            if (groupCounter != 0 && groupCounter < currentGroups.size()) {\n                List<Atom> atoms = g.getAtoms();\n                for (Atom a : atoms) {\n                    if (a.getName().equals(\"P\")) {\n                        // Check to see if one of the phosphate atoms has bonding to something\n                        // outside of the group.\n                        List<Integer> indexList = new ArrayList<>();\n                        for (Bond b : a.getBonds()) {\n                            indexList.add(atoms.indexOf(b.getOther(a)));\n                        }\n                        assertTrue(indexList.contains(-1));\n                    }\n                }\n            }\n            groupCounter++;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Test whether nucleotide bonds are being generated\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2294, "method_signature": "void testNucleotideBonds()"}, "3067": {"callee_method_ids": [3056, 3056, 3056], "callee_method_names": ["LinkedHashMap.containsKey", "AccessionID.getID", "AccessionID.getID", "TranscriptSequence.setAccession", "LinkedHashMap.put", "AccessionID.getID"], "method_name": "GeneSequence.addTranscript", "method_implementation": "{\n    if (transcriptSequenceHashMap.containsKey(accession.getID())) {\n        throw new Exception(\"Duplicate accesion id \" + accession.getID());\n    }\n    TranscriptSequence transcriptSequence = new TranscriptSequence(this, begin, end);\n    transcriptSequence.setAccession(accession);\n    transcriptSequenceHashMap.put(accession.getID(), transcriptSequence);\n    return transcriptSequence;\n}", "repo_id": "9", "comment": "/**\n * Add a transcription sequence to a gene which describes a ProteinSequence\n * @param accession\n * @param begin\n * @param end\n * @return transcript sequence\n * @throws Exception If the accession id is already used\n */\n", "repo_name": "biojava-master/", "id": 3067, "method_signature": "TranscriptSequence addTranscript(AccessionID, int, int)"}, "3156": {"callee_method_names": ["SequenceAsStringHelper<C>.getSequenceAsString"], "method_name": "SequenceFileProxyLoader.getSequenceAsString", "method_implementation": "{\n    SequenceAsStringHelper<C> sequenceAsStringHelper = new SequenceAsStringHelper<C>();\n    return sequenceAsStringHelper.getSequenceAsString(this.parsedCompounds, compoundSet, bioBegin, bioEnd, strand);\n}", "repo_id": "9", "comment": "/**\n * @param bioBegin\n * @param bioEnd\n * @param strand\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3156, "method_signature": "String getSequenceAsString(Integer, Integer, Strand)"}, "1135": {"callee_method_names": ["File.exists", "File.delete", "Logger.debug", "File.getAbsolutePath", "File.getParentFile", "File.delete", "Logger.debug", "File.getAbsolutePath"], "method_name": "LocalPDBDirectory.deleteStructure", "method_implementation": "{\n    boolean deleted = false;\n    // Force getLocalFile to check in obsolete locations\n    ObsoleteBehavior obsolete = getObsoleteBehavior();\n    setObsoleteBehavior(ObsoleteBehavior.FETCH_OBSOLETE);\n    try {\n        File existing = getLocalFile(pdbId);\n        while (existing != null) {\n            // should exist unless concurrency problems\n            assert (existing.exists());\n            if (getFetchBehavior() == FetchBehavior.LOCAL_ONLY) {\n                throw new RuntimeException(\"Refusing to delete from LOCAL_ONLY directory\");\n            }\n            // delete file\n            boolean success = existing.delete();\n            if (success) {\n                logger.debug(\"Deleting {}\", existing.getAbsolutePath());\n            }\n            deleted = deleted || success;\n            // delete parent if empty\n            File parent = existing.getParentFile();\n            if (parent != null) {\n                success = parent.delete();\n                if (success) {\n                    logger.debug(\"Deleting {}\", parent.getAbsolutePath());\n                }\n            }\n            existing = getLocalFile(pdbId);\n        }\n        return deleted;\n    } finally {\n        setObsoleteBehavior(obsolete);\n    }\n}", "repo_id": "9", "comment": "/**\n * Attempts to delete all versions of a structure from the local directory.\n * @param pdbId The PDB ID\n * @return True if one or more files were deleted\n * @throws IOException if the file cannot be deleted\n */\n", "repo_name": "biojava-master/", "id": 1135, "method_signature": "boolean deleteStructure(PdbId)"}, "3439": {"callee_method_names": ["StructureViewer.setSelection"], "method_name": "StructureViewerTest.testSetSelection", "method_implementation": "{\n    if (java.awt.GraphicsEnvironment.isHeadless())\n        return;\n    Selection selection = null;\n    StructureViewer instance = new StructureViewerImpl();\n    instance.setSelection(selection);\n    // TODO review the generated test code and remove the default call to fail.\n    // fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of setSelection method, of class StructureViewer.\n */\n", "repo_name": "biojava-master/", "id": 3439, "method_signature": "void testSetSelection()"}, "3157": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.getAsList", "method_implementation": "{\n    return this.parsedCompounds;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3157, "method_signature": "List<C> getAsList()"}, "2290": {"callee_method_ids": [1571], "callee_method_names": ["Site.getGroups", "List<Group>.get", "Group.getResidueNumber", "Group.getChainId", "Group.getResidueNumber", "Group.getResidueNumber", "Group.getChainId"], "method_name": "SiteTest.testGroup", "method_implementation": "{\n    List<Group> result = bindingSite.getGroups();\n    Group arg221 = result.get(0);\n    ResidueNumber testResNum = new ResidueNumber(\"H\", 221, 'A');\n    Assert.assertEquals(testResNum, arg221.getResidueNumber());\n    //test the chainId is also set\n    Assert.assertEquals(\"H\", arg221.getChainId());\n    Group hoh403 = null;\n    for (Group group : result) {\n        if (group.getResidueNumber().getSeqNum() == 403) {\n            hoh403 = group;\n        }\n    }\n    ResidueNumber testResNum2 = new ResidueNumber(\"H\", 403, ' ');\n    //        testResNum2.setChainId(\"H\");\n    //        testResNum2.setSeqNum(403);\n    //        testResNum2.setInsCode(\"\");\n    //        System.out.println(hoh403);\n    Assert.assertEquals(testResNum2, hoh403.getResidueNumber());\n    //test the chaiId is also set\n    Assert.assertEquals(\"H\", hoh403.getChainId());\n}", "repo_id": "9", "comment": "/**\n * Test to see how the groups have been set in the Groups list\n */\n", "repo_name": "biojava-master/", "id": 2290, "method_signature": "void testGroup()"}, "3056": {"callee_method_names": [], "method_name": "AccessionID.getID", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * @return the id\n */\n", "repo_name": "biojava-master/", "id": 3056, "method_signature": "String getID()"}, "475": {"callee_method_ids": [465], "callee_method_names": ["StructureName.getPdbId"], "method_name": "PdbPair.getPdbId2", "method_implementation": "{\n    return name2.getPdbId();\n}", "repo_id": "9", "comment": "/**\n * @since 6.0.0\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 475, "method_signature": "PdbId getPdbId2()"}, "1137": {"callee_method_ids": [1400], "callee_method_names": ["PdbId.getId", "String.endsWith", "String.endsWith", "String.endsWith", "String.substring", "String.length", "String.length", "File.lastModified", "Date.getTime", "Logger.warn", "Date.toString", "Logger.warn", "Logger.info", "Logger.info"], "method_name": "LocalPDBDirectory.downloadStructure", "method_implementation": "{\n    String id = pdbId.getId().toLowerCase();\n    File dir = getDir(id, obsolete);\n    File realFile = new File(dir, getFilename(id));\n    String ftp;\n    String filename = getFilename(id);\n    if (filename.endsWith(\".mmtf.gz\")) {\n        ftp = CodecUtils.getMmtfEntryUrl(id, true, false);\n    } else if (filename.endsWith(\".bcif\") || filename.endsWith(\".bcif.gz\")) {\n        // TODO this should be configurable\n        ftp = DEFAULT_BCIF_FILE_SERVER + filename;\n    } else {\n        ftp = String.format(\"%s%s/%s/%s\", serverName, pathOnServer, id.substring(id.length() - 3, id.length() - 1), getFilename(id));\n    }\n    URL url = new URL(ftp);\n    Date serverFileDate = null;\n    if (existingFile != null) {\n        serverFileDate = getLastModifiedTime(url);\n        if (serverFileDate != null) {\n            if (existingFile.lastModified() >= serverFileDate.getTime()) {\n                return existingFile;\n            } else {\n                // otherwise we go ahead and download, warning about it first\n                logger.warn(\"File {} is outdated, will download new one from PDB (updated on {})\", existingFile, serverFileDate.toString());\n            }\n        } else {\n            logger.warn(\"Could not determine if file {} is outdated (could not get timestamp from server). Will force redownload\", existingFile);\n        }\n    }\n    logger.info(\"Fetching \" + ftp);\n    logger.info(\"Writing to \" + realFile);\n    FileDownloadUtils.createValidationFiles(url, realFile, null, FileDownloadUtils.Hash.UNKNOWN);\n    FileDownloadUtils.downloadFile(url, realFile);\n    if (!FileDownloadUtils.validateFile(realFile))\n        throw new IOException(\"Downloaded file invalid: \" + realFile);\n    return realFile;\n}", "repo_id": "9", "comment": "/**\n * Download a file from the ftp server +/- its validation metadata, replacing any existing files if needed\n * @param pdbId PDB ID\n * @param pathOnServer Path on the FTP server, e.g. data/structures/divided/pdb\n * @param obsolete Whether or not file should be saved to the obsolete location locally\n * @param existingFile if not null and checkServerFileDate is true, the last modified date of the\n * server file and this file will be compared to decide whether to download or not\n * @return\n * @throws IOException in cases of file I/O, including failure to download a healthy (non-corrupted) file.\n */\n", "repo_name": "biojava-master/", "id": 1137, "method_signature": "File downloadStructure(PdbId, String, boolean, File)"}, "937": {"callee_method_names": ["AtomContactSet.add", "AtomContactSet.add"], "method_name": "Grid.getAtomContacts", "method_implementation": "{\n    AtomContactSet contacts = new AtomContactSet(cutoff);\n    List<Contact> list = getIndicesContacts();\n    if (jAtomObjects == null) {\n        for (Contact cont : list) {\n            contacts.add(new AtomContact(new Pair<Atom>(iAtomObjects[cont.getI()], iAtomObjects[cont.getJ()]), cont.getDistance()));\n        }\n    } else {\n        for (Contact cont : list) {\n            contacts.add(new AtomContact(new Pair<Atom>(iAtomObjects[cont.getI()], jAtomObjects[cont.getJ()]), cont.getDistance()));\n        }\n    }\n    return contacts;\n}", "repo_id": "9", "comment": "/**\n * Returns all contacts, i.e. all atoms that are within the cutoff distance.\n * If both iAtoms and jAtoms are defined then contacts are between iAtoms and jAtoms,\n * if jAtoms is null, then contacts are within the iAtoms.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 937, "method_signature": "AtomContactSet getAtomContacts()"}, "3160": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.getCompoundSet", "method_implementation": "{\n    return compoundSet;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3160, "method_signature": "CompoundSet<C> getCompoundSet()"}, "139": {"callee_method_ids": [449, 452, 451], "callee_method_names": ["QsAlignResult.length", "QsAlignResult.getRelation", "QsAlignResult.getRmsd"], "method_name": "TestQsAlignExamples.testHomoEquivalent", "method_implementation": "{\n    Structure s1 = StructureIO.getStructure(\"3ifv\");\n    Structure s2 = StructureIO.getStructure(\"BIO:3hi8:1\");\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n    QsAlignParameters alignParams = new QsAlignParameters();\n    QsAlignResult result = QsAlign.align(s1, s2, clusterParams, alignParams);\n    assertEquals(result.length(), 3);\n    assertEquals(result.getRelation(), QsRelation.EQUIVALENT);\n    assertTrue(result.getRmsd() < 10.0);\n}", "repo_id": "9", "comment": "/**\n * Proliferating cell nuclear antigens (3IFV, 3HI8) are structurally\n * equivalent C3 homotrimers.\n */\n", "repo_name": "biojava-master/", "id": 139, "method_signature": "void testHomoEquivalent()"}, "952": {"callee_method_names": [], "method_name": "OperatorResolver.getUnaryOperators", "method_implementation": "{\n    return unaryOperators;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of operators for this assembly. The operators\n * refer to the transformations that should be applied to\n * the asym ids to generate this macromolecular assembly.\n * @return the unary operators for this assembly\n */\n", "repo_name": "biojava-master/", "id": 952, "method_signature": "List<String> getUnaryOperators()"}, "3089": {"callee_method_names": [], "method_name": "AbstractFeature.setDescription", "method_implementation": "{\n    this.description = description;\n}", "repo_id": "9", "comment": "/**\n * @param description the description to set\n */\n", "repo_name": "biojava-master/", "id": 3089, "method_signature": "void setDescription(String)"}, "3427": {"callee_method_names": [], "method_name": "SymmetryGui.actionPerformed", "method_implementation": "{\n    // Perform action...\n    abortCalc();\n    dispose();\n    System.exit(0);\n}", "repo_id": "9", "comment": "// This method is called when the button is pressed\n", "repo_name": "biojava-master/", "id": 3427, "method_signature": "void actionPerformed(ActionEvent)"}, "421": {"callee_method_ids": [487, 484], "callee_method_names": ["AFPChain.setConn", "AFPChain.setDVar", "AFPChain.getBlockNum", "AFPChain.getBlockScore", "AFPChain.getBlockGap", "AFPChain.getBlockSize", "AFPChain.getAfpChainList", "AFPChain.getAfpSet", "AFPChain.getBlock2Afp", "FatCatParameters.getTorsionPenalty", "List<AFP>.get", "AFPChain.getConn", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "AFPChain.setBlockGap", "AFPChain.setAlignScoreUpdate", "AFPChain.setBlockScore", "AFPChain.setBlockSize", "AFPChain.setAfpChainList", "AFPChain.setBlock2Afp"], "method_name": "AFPOptimizer.updateScore", "method_implementation": "{\n    int i, j, bknow, bkold, g1, g2;\n    afpChain.setConn(0d);\n    afpChain.setDVar(0d);\n    int blockNum = afpChain.getBlockNum();\n    int alignScoreUpdate = 0;\n    double[] blockScore = afpChain.getBlockScore();\n    int[] blockGap = afpChain.getBlockGap();\n    int[] blockSize = afpChain.getBlockSize();\n    int[] afpChainList = afpChain.getAfpChainList();\n    List<AFP> afpSet = afpChain.getAfpSet();\n    int[] block2Afp = afpChain.getBlock2Afp();\n    double torsionPenalty = params.getTorsionPenalty();\n    bkold = 0;\n    for (i = 0; i < blockNum; i++) {\n        blockScore[i] = 0;\n        blockGap[i] = 0;\n        for (j = 0; j < blockSize[i]; j++) {\n            bknow = afpChainList[block2Afp[i] + j];\n            if (j == 0) {\n                blockScore[i] = afpSet.get(bknow).getScore();\n            } else {\n                //note: j, i\n                AFPChainer.afpPairConn(bkold, bknow, params, afpChain);\n                Double conn = afpChain.getConn();\n                blockScore[i] += afpSet.get(bknow).getScore() + conn;\n                g1 = afpSet.get(bknow).getP1() - afpSet.get(bkold).getP1() - afpSet.get(bkold).getFragLen();\n                g2 = afpSet.get(bknow).getP2() - afpSet.get(bkold).getP2() - afpSet.get(bkold).getFragLen();\n                blockGap[i] += (g1 > g2) ? g1 : g2;\n            }\n            bkold = bknow;\n        }\n        alignScoreUpdate += blockScore[i];\n    }\n    if (blockNum >= 2) {\n        alignScoreUpdate += (blockNum - 1) * torsionPenalty;\n    }\n    afpChain.setBlockGap(blockGap);\n    afpChain.setAlignScoreUpdate(alignScoreUpdate);\n    afpChain.setBlockScore(blockScore);\n    afpChain.setBlockSize(blockSize);\n    afpChain.setAfpChainList(afpChainList);\n    afpChain.setBlock2Afp(block2Afp);\n}", "repo_id": "9", "comment": "/**\n * to update the chaining score after block delete and merge processed\n * the blockScore value is important for significance evaluation\n */\n", "repo_name": "biojava-master/", "id": 421, "method_signature": "void updateScore(FatCatParameters, AFPChain)"}, "451": {"callee_method_names": ["MultipleAlignment.getScore", "MultipleAlignment.getScore"], "method_name": "QsAlignResult.getRmsd", "method_implementation": "{\n    if (alignment == null)\n        return -1.0;\n    if (alignment.getScore(MultipleAlignmentScorer.RMSD) == null)\n        return MultipleAlignmentScorer.getRMSD(alignment);\n    return alignment.getScore(MultipleAlignmentScorer.RMSD);\n}", "repo_id": "9", "comment": "/**\n * The RMSD between the equivalent residues of the equivalent Subunits after\n * superposition of the Subunit groups. This is equivalent to\n * multipleAlignment.getScore(MultipleAlignmentScorer.RMSD).\n *\n * @return rmsd\n */\n", "repo_name": "biojava-master/", "id": 451, "method_signature": "double getRmsd()"}, "2764": {"callee_method_names": ["BufferedOutputStream.close", "FileOutputStream.close"], "method_name": "GenbankWriterHelper.writeProteinSequence", "method_implementation": "{\n    FileOutputStream outputStream = new FileOutputStream(file);\n    BufferedOutputStream bo = new BufferedOutputStream(outputStream);\n    writeProteinSequence(bo, proteinSequences);\n    bo.close();\n    outputStream.close();\n}", "repo_id": "9", "comment": "/**\n * Write collection of protein sequences to a file\n *\n * @param file\n * @param proteinSequences\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2764, "method_signature": "void writeProteinSequence(File, Collection)"}, "1440": {"callee_method_ids": [874, 874, 875, 1410], "callee_method_names": ["StructureInterface.getMoleculeIds", "Map<String, String>.get", "StructureInterface.getMoleculeIds", "Map<String, String>.get", "StructureInterface.getTransforms", "PDBCrystallographicInfo.getCrystalCell", "Map<String, Matrix4d>.get", "Matrix4d.invert", "Map<String, Matrix4d>.get", "Matrix4d.mul", "Matrix4d.mul", "Matrix4d.invert", "Map<String, Map<Matrix4d, StructureInterface>>.computeIfAbsent", "double.getKey", "double.epsilonEquals", "Optional<Matrix4d>.orElse", "Map<String, Map<Matrix4d, StructureInterface>>.computeIfAbsent", "double.getKey", "double.epsilonEquals", "Optional<Matrix4d>.orElse", "Map<String, Map<Matrix4d, StructureInterface>>.get", "Map<String, Map<Matrix4d, StructureInterface>>.get"], "method_name": "CrystalBuilder.findNcsRef", "method_implementation": "{\n    if (!this.hasNcsOps()) {\n        return null;\n    }\n    String chainIName = interf.getMoleculeIds().getFirst();\n    String iOrigName = chainOrigNames.get(chainIName);\n    String chainJName = interf.getMoleculeIds().getSecond();\n    String jOrigName = chainOrigNames.get(chainJName);\n    Matrix4d mJCryst;\n    if (this.searchBeyondAU) {\n        mJCryst = interf.getTransforms().getSecond().getMatTransform();\n        mJCryst = crystallographicInfo.getCrystalCell().transfToOrthonormal(mJCryst);\n    } else {\n        mJCryst = IDENTITY;\n    }\n    // Let X1,...Xn be the original coords, before NCS transforms (M1...Mk)\n    // current chain i: M_i * X_i\n    // current chain j: Cn * M_j * X_j\n    // transformation to bring chain j near X_i: M_i^(-1) * Cn * M_j\n    // transformation to bring chain i near X_j: (Cn * M_j)^(-1) * M_i = (M_i^(-1) * Cn * M_j)^(-1)\n    Matrix4d mChainIInv = new Matrix4d(chainNcsOps.get(chainIName));\n    mChainIInv.invert();\n    Matrix4d mJNcs = new Matrix4d(chainNcsOps.get(chainJName));\n    Matrix4d j2iNcsOrigin = new Matrix4d(mChainIInv);\n    j2iNcsOrigin.mul(mJCryst);\n    //overall transformation to bring current chainj from its NCS origin to i's\n    j2iNcsOrigin.mul(mJNcs);\n    //overall transformation to bring current chaini from its NCS origin to j's\n    Matrix4d i2jNcsOrigin = new Matrix4d(j2iNcsOrigin);\n    i2jNcsOrigin.invert();\n    String matchChainIdsIJ = iOrigName + jOrigName;\n    String matchChainIdsJI = jOrigName + iOrigName;\n    // same original chain names\n    Optional<Matrix4d> matchDirect = visitedNcsChainPairs.computeIfAbsent(matchChainIdsIJ, k -> new HashMap<>()).entrySet().stream().map(r -> r.getKey()).filter(r -> r.epsilonEquals(j2iNcsOrigin, 0.01)).findFirst();\n    Matrix4d matchMatrix = matchDirect.orElse(null);\n    String matchChainIds = matchChainIdsIJ;\n    if (matchMatrix == null) {\n        // reversed original chain names with inverted transform\n        Optional<Matrix4d> matchInverse = visitedNcsChainPairs.computeIfAbsent(matchChainIdsJI, k -> new HashMap<>()).entrySet().stream().map(r -> r.getKey()).filter(r -> r.epsilonEquals(i2jNcsOrigin, 0.01)).findFirst();\n        matchMatrix = matchInverse.orElse(null);\n        matchChainIds = matchChainIdsJI;\n    }\n    StructureInterface matchInterface = null;\n    if (matchMatrix == null) {\n        visitedNcsChainPairs.get(matchChainIdsIJ).put(j2iNcsOrigin, interf);\n    } else {\n        matchInterface = visitedNcsChainPairs.get(matchChainIds).get(matchMatrix);\n    }\n    return matchInterface;\n}", "repo_id": "9", "comment": "/**\n * Checks whether given interface is NCS-redundant, i.e., an identical interface between NCS copies of\n * these molecules has already been seen, and returns this (reference) interface.\n *\n * @param interf\n *          StructureInterface\n * @return  already seen interface that is NCS-equivalent to interf,\n *          null if such interface is not found.\n */\n", "repo_name": "biojava-master/", "id": 1440, "method_signature": "StructureInterface findNcsRef(StructureInterface)"}, "3682": {"callee_method_names": [], "method_name": "WaldTestInfo.setDf", "method_implementation": "{\n    this.df = df;\n}", "repo_id": "9", "comment": "/**\n * @param df the df to set\n */\n", "repo_name": "biojava-master/", "id": 3682, "method_signature": "void setDf(int)"}, "223": {"callee_method_names": [], "method_name": "ProteinModificationImpl.setResidId", "method_implementation": "{\n    this.residId = residId;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the RESID ID.\n * @param residId RESID ID.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 223, "method_signature": "Builder setResidId(String)"}, "1215": {"callee_method_names": [], "method_name": "CifStructureConverter.toCifFile", "method_implementation": "{\n    return new CifChainSupplierImpl().get(chain);\n}", "repo_id": "9", "comment": "/**\n * Convert Chain to CifFile\n * @param chain the source\n * @return the target\n */\n", "repo_name": "biojava-master/", "id": 1215, "method_signature": "CifFile toCifFile(Chain)"}, "1936": {"callee_method_names": [], "method_name": "RotationGroup.setSymmetryDeviation", "method_implementation": "{\n    this.symmetryDeviation = symmetryDeviation;\n}", "repo_id": "9", "comment": "/**\n * @param symmetryDeviation the symmetryDeviation to set\n */\n", "repo_name": "biojava-master/", "id": 1936, "method_signature": "void setSymmetryDeviation(double)"}, "3045": {"callee_method_names": ["List<Location>.add", "List<Location>.add", "List<Location>.add"], "method_name": "LocationHelper.circularLocation", "method_implementation": "{\n    int min = Math.min(start, end);\n    int max = Math.max(start, end);\n    //Tells us we're dealing with something that's not _right_\n    boolean isReverse = (min != start);\n    if (min > length) {\n        throw new IllegalArgumentException(\"Cannot process a \" + \"location whose lowest coordinate is less than \" + \"the given length \" + length);\n    }\n    //If max positon was less than length the return a normal location\n    if (max <= length) {\n        return location(start, end, strand, length);\n    }\n    //Fine for forward coords (i..e start < end)\n    int modStart = modulateCircularIndex(start, length);\n    int modEnd = modulateCircularIndex(end, length);\n    int numberOfPasses = completeCircularPasses(Math.max(start, end), length);\n    if (isReverse) {\n        int reversedModStart = new SimplePoint(modStart).reverse(length).getPosition();\n        int reversedModEnd = new SimplePoint(modEnd).reverse(length).getPosition();\n        modStart = reversedModStart;\n        modEnd = reversedModEnd;\n        start = reversedModStart;\n        //+1 to number of passes to skip the run encoded by the start\n        end = (length * (numberOfPasses + 1)) + modEnd;\n    }\n    List<Location> locations = new ArrayList<Location>();\n    locations.add(new SimpleLocation(modStart, length, strand));\n    for (int i = 0; i < numberOfPasses; i++) {\n        locations.add(new SimpleLocation(1, length, strand));\n    }\n    locations.add(new SimpleLocation(1, modEnd, strand));\n    return new SimpleLocation(new SimplePoint(start), new SimplePoint(end), strand, true, false, locations);\n}", "repo_id": "9", "comment": "/**\n * Converts a location which defines the outer bounds of a circular\n * location and splits it into the required portions. Unlike any\n * other location builder this allows you to express your input\n * location on the reverse strand\n *\n * @param location The location which currently expresses the outer\n * bounds of a circular location.\n * @param length The length of the circular genomic unit\n * @return The circular location; can optionally return a normal non\n * circular location if the one you give is within the bounds of\n * the length\n */\n", "repo_name": "biojava-master/", "id": 3045, "method_signature": "Location circularLocation(int, int, Strand, int)"}, "2555": {"callee_method_names": [], "method_name": "BlastTabularParser.setParsingConsistency", "method_implementation": "{\n    this.parsingConsistency = parsingConsistency;\n}", "repo_id": "9", "comment": "/**\n * Tries to define a different level of consistency during parsing.\n * LITERAL is intended a strict parsing much tight to the report.\n * IMPROVED consistency tries to import data much tight to the data model\n * (I hope you got the idea, if not, have a look to the code.\n * I suggest to use improved unless you have reasons to do not)\n */\n", "repo_name": "biojava-master/", "id": 2555, "method_signature": "void setParsingConsistency(PARSING_CONSISTENCY)"}, "3871": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getEnrichment", "AminoAcidCompoundSet.getCompoundForString"], "method_name": "PeptideProperties.getEnrichment", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    AminoAcidCompoundSet aaSet = new AminoAcidCompoundSet();\n    return pp.getEnrichment(pSequence, aaSet.getCompoundForString(aminoAcidCode));\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the composition of specified amino acid in the sequence. The\n * sequence argument must be a protein sequence consisting of only\n * non-ambiguous characters. The aminoAcidCode must be a non-ambiguous\n * character.\n * The composition of an amino acid is the total number of its occurrence,\n * divided by the total length of the sequence.\n *\n * @param sequence\n *            a protein sequence consisting of non-ambiguous characters only\n * @param aminoAcidCode\n *            the code of the amino acid to compute\n * @return the composition of specified amino acid in the sequence\n */\n", "repo_name": "biojava-master/", "id": 3871, "method_signature": "double getEnrichment(String, String)"}, "2857": {"callee_method_names": ["BufferedReader.mark", "BufferedReader.readLine", "List<String[]>.isEmpty", "List<String[]>.get", "String.matches", "String.startsWith", "String.equals", "String.startsWith", "List<String[]>.add", "StringBuilder.toString", "BufferedReader.reset", "Pattern.matcher", "Matcher.matches", "List<String[]>.add", "StringBuilder.toString", "Matcher.group", "Matcher.group", "Matcher.group", "Matcher.group", "Matcher.group", "StringBuilder.append", "Matcher.group", "Matcher.group", "Matcher.group", "Matcher.group", "String.startsWith", "String.startsWith", "StringBuilder.append", "StringBuilder.append", "String.charAt", "String.substring", "String.substring", "Enumeration<JarEntry>.getMessage"], "method_name": "GenbankSequenceParser.readSection", "method_implementation": "{\n    List<String[]> section = new ArrayList<>();\n    String line;\n    String currKey = null;\n    StringBuilder currVal = new StringBuilder();\n    boolean done = false;\n    int linecount = 0;\n    try {\n        while (!done) {\n            bufferedReader.mark(320);\n            line = bufferedReader.readLine();\n            String firstSecKey = section.isEmpty() ? \"\" : section.get(0)[0];\n            if (line != null && line.matches(\"\\\\p{Space}*\")) {\n                // regular expression \\p{Space}* will match line\n                // having only white space characters\n                continue;\n            }\n            if (line == null || (!line.startsWith(\" \") && linecount++ > 0 && (!firstSecKey.equals(START_SEQUENCE_TAG) || line.startsWith(END_SEQUENCE_TAG)))) {\n                // dump out last part of section\n                section.add(new String[] { currKey, currVal.toString() });\n                bufferedReader.reset();\n                done = true;\n            } else {\n                Matcher m = sectp.matcher(line);\n                if (m.matches()) {\n                    // new key\n                    if (currKey != null) {\n                        section.add(new String[] { currKey, currVal.toString() });\n                    }\n                    // key = group(2) or group(4) or group(6) - whichever is\n                    // not null\n                    currKey = m.group(2) == null ? (m.group(4) == null ? m.group(6) : m.group(4)) : m.group(2);\n                    currVal = new StringBuilder();\n                    // val = group(3) if group(2) not null, group(5) if\n                    // group(4) not null, \"\" otherwise, trimmed\n                    currVal.append((m.group(2) == null ? (m.group(4) == null ? \"\" : m.group(5)) : m.group(3)).trim());\n                } else {\n                    // concatted line or SEQ START/END line?\n                    if (line.startsWith(START_SEQUENCE_TAG) || line.startsWith(END_SEQUENCE_TAG)) {\n                        currKey = line;\n                    } else {\n                        // newline in between lines -\n                        currVal.append(\"\\n\");\n                        // can be removed later\n                        currVal.append(currKey.charAt(0) == '/' ? line.substring(21) : line.substring(12));\n                    }\n                }\n            }\n        }\n    } catch (IOException | RuntimeException e) {\n        throw new ParserException(e.getMessage());\n    }\n    return section;\n}", "repo_id": "9", "comment": "// key->value tuples\n", "repo_name": "biojava-master/", "id": 2857, "method_signature": "List<String[]> readSection(BufferedReader)"}, "2106": {"callee_method_names": [], "method_name": "Axis.getOperator", "method_implementation": "{\n    return operator;\n}", "repo_id": "9", "comment": "/**\n * Get the transformation operator for this axis as an homogeneous matrix\n * @return the transformation operator\n */\n", "repo_name": "biojava-master/", "id": 2106, "method_signature": "Matrix4d getOperator()"}, "3193": {"callee_method_names": [], "method_name": "TestFASTAReader.testProcess1WithBlankLines", "method_implementation": "{\n    testProcess1(\"org/biojava/nbio/core/fasta/P02768_blank_lines.fasta\");\n}", "repo_id": "9", "comment": "/**\n * Same as {@link #testProcess1()}, but input contains blank lines.\n *\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3193, "method_signature": "void testProcess1WithBlankLines()"}, "2295": {"callee_method_names": [], "method_name": "TestBond.testHeavyAtomBondMissing", "method_implementation": "{\n    assertEquals(0, countAtomsWithoutBonds(\"3jtm\"));\n    assertEquals(0, countAtomsWithoutBonds(\"3jq8\"));\n    assertEquals(0, countAtomsWithoutBonds(\"3jq9\"));\n    assertEquals(0, countAtomsWithoutBonds(\"3i06\"));\n    assertEquals(0, countAtomsWithoutBonds(\"3nu3\"));\n    assertEquals(0, countAtomsWithoutBonds(\"3nu4\"));\n    assertEquals(0, countAtomsWithoutBonds(\"3nvd\"));\n}", "repo_id": "9", "comment": "/**\n * Test whether these partial occupancy hydrogens are bonded to the residue.\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2295, "method_signature": "void testHeavyAtomBondMissing()"}, "3021": {"callee_method_names": [], "method_name": "SequenceLocation.getSequence", "method_implementation": "{\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * @return the sequence\n */\n", "repo_name": "biojava-master/", "id": 3021, "method_signature": "S getSequence()"}, "1493": {"callee_method_names": ["Point3d[].distanceSquared"], "method_name": "CalcPoint.rmsd", "method_implementation": "{\n    if (x.length != y.length) {\n        throw new IllegalArgumentException(\"Point arrays are not of the same length.\");\n    }\n    double sum = 0.0;\n    for (int i = 0; i < x.length; i++) {\n        sum += x[i].distanceSquared(y[i]);\n    }\n    return Math.sqrt(sum / x.length);\n}", "repo_id": "9", "comment": "/**\n * Calculate the RMSD of two point arrays, already superposed.\n *\n * @param x\n *            array of points superposed to y\n * @param y\n *            array of points superposed to x\n * @return RMSD\n */\n", "repo_name": "biojava-master/", "id": 1493, "method_signature": "double rmsd(Point3d[], Point3d[])"}, "1379": {"callee_method_names": [], "method_name": "DBRef.setDbAccession", "method_implementation": "{\n    this.dbAccession = dbAccession;\n}", "repo_id": "9", "comment": "/**\n * Sequence database accession code.\n * @param dbAccession the dbAccession\n * @see #getDbAccession()\n */\n", "repo_name": "biojava-master/", "id": 1379, "method_signature": "void setDbAccession(String)"}, "344": {"callee_method_names": ["Atom.getX", "Atom.getX", "Atom.getY", "Atom.getY", "Atom.getZ", "Atom.getZ"], "method_name": "Calc.getDistance", "method_implementation": "{\n    double x = a.getX() - b.getX();\n    double y = a.getY() - b.getY();\n    double z = a.getZ() - b.getZ();\n    double s = x * x + y * y + z * z;\n    return Math.sqrt(s);\n}", "repo_id": "9", "comment": "/**\n * calculate distance between two atoms.\n *\n * @param a\n *            an Atom object\n * @param b\n *            an Atom object\n * @return a double\n */\n", "repo_name": "biojava-master/", "id": 344, "method_signature": "double getDistance(Atom, Atom)"}, "1578": {"callee_method_names": [], "method_name": "DSSPParser.parseInputStream", "method_implementation": "{\n    BufferedReader reader = new BufferedReader(new InputStreamReader(dsspIs));\n    return generalParse(reader, structure, assign);\n}", "repo_id": "9", "comment": "/**\n * Parse a DSSP output file and return the secondary structure\n * annotation as a List of {@link SecStrucState} objects.\n *\n * @param dsspIs an InputStream to a DSSP file\n * @param structure Structure object associated to the dssp\n * @param assign assigns the SS to the structure if true\n * @return a List of SS annotation objects\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1578, "method_signature": "List<SecStrucState> parseInputStream(InputStream, Structure, boolean)"}, "3402": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorPointGroup.setAxisTransformation", "method_implementation": "{\n    this.rotationAxisAligner = axisTransformation;\n}", "repo_id": "9", "comment": "/**\n * @param axisTransformation the axisTransformation to set\n */\n", "repo_name": "biojava-master/", "id": 3402, "method_signature": "void setAxisTransformation(RotationAxisAligner)"}, "192": {"callee_method_names": [], "method_name": "PredictDisorder.getUniprot", "method_implementation": "{\n    AminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    UniprotProxySequenceReader<AminoAcidCompound> uniprotSequence = new UniprotProxySequenceReader<AminoAcidCompound>(uniProtID, set);\n    ProteinSequence seq = new ProteinSequence(uniprotSequence);\n    return seq;\n}", "repo_id": "9", "comment": "/**\n * Fetch a protein sequence from the UniProt web site\n *\n * @param uniProtID\n * @return a Protein Sequence\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 192, "method_signature": "ProteinSequence getUniprot(String)"}, "3610": {"callee_method_ids": [3675], "callee_method_names": ["ArrayList<SurvivalInfo>.size", "SurvivalInfo.getStatus"], "method_name": "CoxInfo.setSurvivalInfoList", "method_implementation": "{\n    survivalInfoList = data;\n    numSamples = data.size();\n    for (SurvivalInfo si : data) {\n        if (si.getStatus() == 1) {\n            numEvents++;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @param data\n */\n", "repo_name": "biojava-master/", "id": 3610, "method_signature": "void setSurvivalInfoList(ArrayList)"}, "3860": {"callee_method_names": ["IPeptideProperties.obtainAminoAcidCompositionTable"], "method_name": "PeptideProperties.obtainAminoAcidCompositionTable", "method_implementation": "{\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.obtainAminoAcidCompositionTable(elementMassFile, aminoAcidCompositionFile);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method would initialize amino acid composition table based on the input xml files and stores the table for usage in future calls to\n * IPeptideProperties.getMolecularWeightBasedOnXML(ProteinSequence, AminoAcidCompositionTable).\n *\n * @param elementMassFile\n * \txml file that details the mass of each elements and isotopes\n * @param aminoAcidCompositionFile\n * \txml file that details the composition of amino acids\n * @return the initialized amino acid composition table\n * @throws JAXBException\n * \tthrown if unable to properly parse either elementMassFile or aminoAcidCompositionFile\n * @throws FileNotFoundException\n * \tthrown if either elementMassFile or aminoAcidCompositionFile are not found\n */\n", "repo_name": "biojava-master/", "id": 3860, "method_signature": "AminoAcidCompositionTable obtainAminoAcidCompositionTable(File, File)"}, "2945": {"callee_method_names": [], "method_name": "AbstractSequence.getLastIndexOf", "method_implementation": "{\n    return getSequenceStorage().getLastIndexOf(compound);\n}", "repo_id": "9", "comment": "/**\n * @param compound\n * @return The last index of compound in this sequence (1-based)\n */\n", "repo_name": "biojava-master/", "id": 2945, "method_signature": "int getLastIndexOf(C)"}, "992": {"callee_method_names": ["ResidueNumber.setChainName", "Chain.getName"], "method_name": "HetatomImpl.setChain", "method_implementation": "{\n    this.parent = chain;\n    //TODO: setChain(), getChainName() and ResidueNumber.set/getChainName() are\n    //duplicating functionality at present and could give different values.\n    if (residueNumber != null) {\n        residueNumber.setChainName(chain.getName());\n    }\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 992, "method_signature": "void setChain(Chain)"}, "1915": {"callee_method_names": ["Set<?>.size"], "method_name": "QuatSymmetryParameters.isLocalLimitsExceeded", "method_implementation": "{\n    if (combinations.size() > maximumLocalCombinations) {\n        return true;\n    }\n    return isLocalLimitsExceeded();\n}", "repo_id": "9", "comment": "/**\n * @param combinations\n *            a set of combinations considered fo far by the local\n *            symmetry search\n * @return true, if the number of combinations\n */\n", "repo_name": "biojava-master/", "id": 1915, "method_signature": "boolean isLocalLimitsExceeded(Set)"}, "2528": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum65", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum65\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 65 matrix by Henikoff & Henikoff\n * @return Blosum 65 matrix\n */\n", "repo_name": "biojava-master/", "id": 2528, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum65()"}, "1522": {"callee_method_names": ["Matrix.getColumnPackedCopy", "Matrix.getColumnPackedCopy"], "method_name": "Matrices.getTransformation", "method_implementation": "{\n    return new Matrix4d(new Matrix3d(rot.getColumnPackedCopy()), new Vector3d(trans.getColumnPackedCopy()), 1.0);\n}", "repo_id": "9", "comment": "/**\n * Convert JAMA rotation and translation to a Vecmath transformation matrix.\n * Because the JAMA matrix is a pre-multiplication matrix and the Vecmath\n * matrix is a post-multiplication one, the rotation matrix is transposed to\n * ensure that the transformation they produce is the same.\n *\n * @param rot\n *            3x3 Rotation matrix\n * @param trans\n *            3x1 Translation matrix\n * @return 4x4 transformation matrix\n */\n", "repo_name": "biojava-master/", "id": 1522, "method_signature": "Matrix4d getTransformation(Matrix, Matrix)"}, "1602": {"callee_method_names": ["SecStrucState.getDonor1", "SecStrucState.getDonor2", "SecStrucState.getAccept1", "SecStrucState.getAccept2", "SecStrucState.getDonor1", "SecStrucState.getDonor2", "SecStrucState.getAccept1", "SecStrucState.getAccept2", "Logger.debug"], "method_name": "SecStrucCalc.isBonded", "method_implementation": "{\n    SecStrucState one = getSecStrucState(i);\n    SecStrucState two = getSecStrucState(j);\n    double don1e = one.getDonor1().getEnergy();\n    double don2e = one.getDonor2().getEnergy();\n    double acc1e = two.getAccept1().getEnergy();\n    double acc2e = two.getAccept2().getEnergy();\n    int don1p = one.getDonor1().getPartner();\n    int don2p = one.getDonor2().getPartner();\n    int acc1p = two.getAccept1().getPartner();\n    int acc2p = two.getAccept2().getPartner();\n    //Either donor from i is j, or accept from j is i\n    boolean hbond = (don1p == j && don1e < HBONDHIGHENERGY) || (don2p == j && don2e < HBONDHIGHENERGY) || (acc1p == i && acc1e < HBONDHIGHENERGY) || (acc2p == i && acc2e < HBONDHIGHENERGY);\n    if (hbond) {\n        logger.debug(\"*** H-bond from CO of {} to NH of {}\", i, j);\n        return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Test if two groups are forming an H-Bond. The bond tested is\n * from the CO of group i to the NH of group j. Acceptor (i) and\n * donor (j). The donor of i has to be j, and the acceptor of j\n * has to be i.\n * DSSP defines H-Bonds if the energy < -500 cal/mol.\n *\n * @param i group one\n * @param j group two\n * @return flag if the two are forming an Hbond\n */\n", "repo_name": "biojava-master/", "id": 1602, "method_signature": "boolean isBonded(int, int)"}, "1494": {"callee_method_names": ["Point3d[].distanceSquared"], "method_name": "CalcPoint.rmsdMin", "method_implementation": "{\n    if (x.length != y.length) {\n        throw new IllegalArgumentException(\"Point arrays are not of the same length.\");\n    }\n    double sum = 0.0;\n    for (int i = 0; i < x.length; i++) {\n        double minDist = Double.MAX_VALUE;\n        for (int j = 0; j < y.length; j++) {\n            minDist = Math.min(minDist, x[i].distanceSquared(y[j]));\n        }\n        sum += minDist;\n    }\n    return Math.sqrt(sum / x.length);\n}", "repo_id": "9", "comment": "/*\n\t * Needs documentation!\n\t *\n\t * @param x\n\t *\n\t * @param y\n\t *\n\t * @return\n\t */\n", "repo_name": "biojava-master/", "id": 1494, "method_signature": "double rmsdMin(Point3d[], Point3d[])"}, "2269": {"callee_method_names": ["ClassLoader.getResource", "ClassLoader.getResource", "Structure.getPDBHeader", "Structure.getPDBHeader", "Structure.getPDBHeader", "Structure.getPDBHeader", "Structure.getChainByIndex", "Structure.getChainByIndex"], "method_name": "TestMmtfStructureReader.compareMmcif", "method_implementation": "{\n    // Get the MMTF and MMCIF files from the resources folder\n    ClassLoader classLoader = getClass().getClassLoader();\n    String resource = \"org/biojava/nbio/structure/io/mmtf/4CUP\";\n    // Load the structures into memory\n    Structure mmtf = MmtfActions.readFromFile(new File(classLoader.getResource(resource + \".mmtf\").getPath()).toPath());\n    Structure mmcif = StructureIO.getStructure(classLoader.getResource(resource + \".cif\").getPath());\n    // Compare the dates of the structure\n    assertEquals(mmcif.getPDBHeader().getDepDate(), mmtf.getPDBHeader().getDepDate());\n    // Compare the experimental method\n    assertEquals(mmcif.getPDBHeader().getExperimentalTechniques(), mmtf.getPDBHeader().getExperimentalTechniques());\n    // Compare the SEQRES, see issue https://github.com/biojava/biojava/issues/671\n    assertEquals(mmcif.getChainByIndex(0).getSeqResSequence(), mmtf.getChainByIndex(0).getSeqResSequence());\n}", "repo_id": "9", "comment": "/**\n * Compare structures loaded from MMCIF and MMTF files.\n */\n", "repo_name": "biojava-master/", "id": 2269, "method_signature": "void compareMmcif()"}, "1200": {"callee_method_ids": [1334, 1571], "callee_method_names": ["Logger.info", "Structure.getChains", "LinkedHashMap.values", "Logger.info", "LinkedHashMap.keySet", "LinkedHashMap.keySet", "Logger.info", "Logger.debug", "LinkedHashMap.keySet", "LinkedHashMap.keySet", "LinkedHashMap.keySet", "LinkedHashMap.get", "LinkedHashMap.get", "ResidueNumber.toString", "ResidueNumber.getChainName", "Structure.findGroup", "Logger.info", "Site.getGroups", "LinkedHashMap.values", "Structure.setSites"], "method_name": "PDBFileParser.linkSitesToGroups", "method_implementation": "{\n    //System.out.println(\"LINK SITES TO GROUPS:\" + siteToResidueMap.keySet().size());\n    //link the map of siteIds : <ResidueNumber> with the sites by using ResidueNumber to get the correct group back.\n    //the return list\n    if (siteMap == null || siteToResidueMap == null) {\n        logger.info(\"Sites can not be linked to residues!\");\n        return;\n    }\n    List<Site> sites = null;\n    //check that there are chains with which to associate the groups\n    if (structure.getChains().isEmpty()) {\n        sites = new ArrayList<Site>(siteMap.values());\n        logger.info(\"No chains to link Site Groups with - Sites will not be present in the Structure\");\n        return;\n    }\n    //check that the keys in the siteMap and SiteToResidueMap are equal\n    if (!siteMap.keySet().equals(siteToResidueMap.keySet())) {\n        logger.info(\"Not all sites have been properly described in the PDB \" + pdbId + \" header - some Sites will not be present in the Structure\");\n        logger.debug(siteMap.keySet() + \" | \" + siteToResidueMap.keySet());\n        //return;\n    }\n    //so we have chains - associate the siteResidues-related groups with the ones\n    //already in in the chains\n    for (String key : siteMap.keySet()) {\n        Site currentSite = siteMap.get(key);\n        List<ResidueNumber> linkedGroups = siteToResidueMap.get(key);\n        if (linkedGroups == null)\n            continue;\n        for (ResidueNumber residueNumber : linkedGroups) {\n            String pdbCode = residueNumber.toString();\n            String chain = residueNumber.getChainName();\n            //                    System.out.println(\"chain: '\" + chain + \"'\");\n            //                    String resNum = resNum.getSeqNum().toString();\n            //                    System.out.println(\"resNum: '\" + resNum + \"'\");\n            Group linkedGroup = null;\n            try {\n                //TODO: implement findGroup(ResidueNumber resNum)\n                linkedGroup = structure.findGroup(chain, pdbCode);\n            } catch (StructureException ex) {\n                logger.info(\"Can't find group \" + pdbCode + \" in chain \" + chain + \" in order to link up SITE records (PDB ID \" + pdbId + \")\");\n                continue;\n            }\n            //                    System.out.println(\"Adding group: \" + linkedGroup.getSeqNum() + \" to site \" + site.getSiteID());\n            currentSite.getGroups().add(linkedGroup);\n        }\n    }\n    //System.out.println(\"SITEMAP: \" + siteMap);\n    sites = new ArrayList<Site>(siteMap.values());\n    structure.setSites(sites);\n    //System.out.println(\"STRUCTURE SITES: \" + structure.getSites().size());\n    //            for (Site site : structure.getSites()) {\n    //                System.out.println(site);\n    //            }\n    //            System.out.println(\"Linked Site Groups with Chains\");\n}", "repo_id": "9", "comment": "/**\n * Links the Sites in the siteMap to the Groups in the Structure via the\n * siteToResidueMap ResidueNumber.\n * @author Jules Jacobsen\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1200, "method_signature": "void linkSitesToGroups()"}, "1871": {"callee_method_names": [], "method_name": "Helix.setScores", "method_implementation": "{\n    this.scores = scores;\n}", "repo_id": "9", "comment": "/**\n * @param scores the scores to set\n */\n", "repo_name": "biojava-master/", "id": 1871, "method_signature": "void setScores(QuatSymmetryScores)"}, "3604": {"callee_method_names": [], "method_name": "ResidualsCoxph.main", "method_implementation": "{\n    // TODO code application logic here\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3604, "method_signature": "void main(String[])"}, "890": {"callee_method_ids": [840, 840], "callee_method_names": ["Map<ResidueNumber, GroupAsa>.values", "GroupAsa.getAsaU", "List<Group>.add", "GroupAsa.getGroup", "Map<ResidueNumber, GroupAsa>.values", "GroupAsa.getAsaU", "List<Group>.add", "GroupAsa.getGroup"], "method_name": "StructureInterface.getSurfaceResidues", "method_implementation": "{\n    List<Group> surf1 = new ArrayList<>();\n    List<Group> surf2 = new ArrayList<>();\n    for (GroupAsa groupAsa : groupAsas1.values()) {\n        if (groupAsa.getAsaU() > minAsaForSurface) {\n            surf1.add(groupAsa.getGroup());\n        }\n    }\n    for (GroupAsa groupAsa : groupAsas2.values()) {\n        if (groupAsa.getAsaU() > minAsaForSurface) {\n            surf2.add(groupAsa.getGroup());\n        }\n    }\n    return new Pair<>(surf1, surf2);\n}", "repo_id": "9", "comment": "/**\n * Returns the residues belonging to the surface\n * @param minAsaForSurface the minimum ASA to consider a residue on the surface\n * @return\n */\n", "repo_name": "biojava-master/", "id": 890, "method_signature": "Pair<List<Group>> getSurfaceResidues(double)"}, "1676": {"callee_method_names": [], "method_name": "Subunit.getIdentifier", "method_implementation": "{\n    return identifier;\n}", "repo_id": "9", "comment": "/**\n * The standard identifier of the Subunit.\n *\n * @return StructureIdentifier object\n */\n", "repo_name": "biojava-master/", "id": 1676, "method_signature": "StructureIdentifier getIdentifier()"}, "483": {"callee_method_names": [], "method_name": "AFPChain.setMaxTra", "method_implementation": "{\n    this.maxTra = maxTra;\n}", "repo_id": "9", "comment": "/**\n * Set the maximum number of Twists that are allowed...\n * @param maxTra\n */\n", "repo_name": "biojava-master/", "id": 483, "method_signature": "void setMaxTra(int)"}, "2342": {"callee_method_names": [], "method_name": "FastqBuilder.withDescription", "method_implementation": "{\n    if (description == null) {\n        throw new IllegalArgumentException(\"description must not be null\");\n    }\n    this.description = description;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Return this FASTQ formatted sequence builder configured with the specified description.\n *\n * @param description description for this FASTQ formatted sequence builder, must not be null\n * @return this FASTQ formatted sequence builder configured with the specified description\n */\n", "repo_name": "biojava-master/", "id": 2342, "method_signature": "FastqBuilder withDescription(String)"}, "512": {"callee_method_ids": [487, 495, 497, 492, 484, 501, 500, 501, 500, 499, 493, 494], "callee_method_names": ["AFPChain.getName1", "AFPChain.getName2", "AFPChain.getCa1Length", "AFPChain.getCa2Length", "AFPChain.getBlockNum", "AFPChain.getTotalLenIni", "AFPChain.getTotalRmsdIni", "AFPChain.getOptLength", "AFPChain.getTotalRmsdOpt", "AFPChain.getChainRmsd", "AFPChain.getAlignScore", "AFPChain.getAlnLength", "AFPChain.getGapLen", "AFPChain.getAfpSet", "AFPChain.getSimilarity", "AFPChain.getIdentity", "AFPChain.calcSimilarity", "AFPChain.getSimilarity", "AFPChain.getIdentity", "AFPChain.getAlgorithmName", "AFPChain.getProbability", "List<AFP>.size", "AFPChain.getBlockGap", "AFPChain.getBlockScore", "AFPChain.getBlockRmsd", "AFPChain.getBlockSize", "AFPChain.getAlnbeg1", "AFPChain.getAlnbeg2", "AFPChain.getAlnseq1", "AFPChain.getAlnseq2", "AFPChain.getAlnsymb", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "AFPChain.isShortAlign", "StringBuffer.append", "StringBuffer.toString", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "Atom[].getGroup", "Atom[].getGroup", "String.length", "String.charAt", "String.charAt", "String.charAt", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "String.charAt", "String.charAt", "StringBuffer.append", "String.equalsIgnoreCase", "String.equalsIgnoreCase", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.toString"], "method_name": "AfpChainWriter.toFatCatCore", "method_implementation": "{\n    //TODO The sequence numbers are inaccurate if a !afpChain.isSequential()\n    String name1 = afpChain.getName1();\n    String name2 = afpChain.getName2();\n    int ca1Length = afpChain.getCa1Length();\n    int ca2Length = afpChain.getCa2Length();\n    int blockNum = afpChain.getBlockNum();\n    int totalLenIni = afpChain.getTotalLenIni();\n    double totalRmsdIni = afpChain.getTotalRmsdIni();\n    int optLength = afpChain.getOptLength();\n    double totalRmsdOpt = afpChain.getTotalRmsdOpt();\n    double chainRmsd = afpChain.getChainRmsd();\n    double alignScore = afpChain.getAlignScore();\n    int alnLength = afpChain.getAlnLength();\n    int gapLen = afpChain.getGapLen();\n    List<AFP> afpSet = afpChain.getAfpSet();\n    double similarity = afpChain.getSimilarity();\n    double identity = afpChain.getIdentity();\n    if (similarity < 0 || identity < 0) {\n        afpChain.calcSimilarity();\n        similarity = afpChain.getSimilarity();\n        identity = afpChain.getIdentity();\n    }\n    String algorithmName = afpChain.getAlgorithmName();\n    //String version = afpChain.getVersion();\n    double probability = afpChain.getProbability();\n    int afpNum = afpSet.size();\n    int[] blockGap = afpChain.getBlockGap();\n    double[] blockScore = afpChain.getBlockScore();\n    double[] blockRmsd = afpChain.getBlockRmsd();\n    int[] blockSize = afpChain.getBlockSize();\n    int alnbeg1 = afpChain.getAlnbeg1();\n    int alnbeg2 = afpChain.getAlnbeg2();\n    char[] alnseq1 = afpChain.getAlnseq1();\n    char[] alnseq2 = afpChain.getAlnseq2();\n    char[] alnsymb = afpChain.getAlnsymb();\n    // == end of extractation of data values from afpChain\n    ////////////////////////////////\n    StringBuffer txt = new StringBuffer();\n    if (longHeader) {\n        txt.append(String.format(\"Align %s.pdb %d with %s.pdb %d\", name1, ca1Length, name2, ca2Length));\n    } else {\n        txt.append(String.format(\"Align %s.pdb Length1: %d with %s.pdb Length2: %d\", name1, ca1Length, name2, ca2Length));\n    }\n    txt.append(newline);\n    if (afpChain.isShortAlign()) {\n        txt.append(\"Short match\");\n        return txt.toString();\n    }\n    //txt.append(String.format(Locale.US, \"raw-score: %.2f norm.-score: %.2f \", alignScore, normAlignScore));\n    if (longHeader) {\n        txt.append(String.format(Locale.US, \"Twists %d ini-len %d ini-rmsd %.2f opt-equ %d opt-rmsd %.2f chain-rmsd %.2f Score %.2f align-len %d gaps %d (%.2f%%)\", blockNum - 1, totalLenIni, totalRmsdIni, optLength, totalRmsdOpt, chainRmsd, alignScore, alnLength, gapLen, (100.0 * gapLen / alnLength)));\n        txt.append(newline);\n    } else {\n        if (!longHeader)\n            printScore(txt, algorithmName, probability, longHeader);\n        printScoresInLines(afpChain, blockNum, optLength, totalRmsdOpt, alignScore, alnLength, gapLen, identity, similarity, txt);\n    }\n    //txt.append(String.format(Locale.US, \"P-value %.2e Afp-num %d Identity %.2f%% Similarity %.2f%% norm.-score: %.2f\"+newline, probability, afpNum, identity * 100, similarity * 100, normAlignScore));\n    if (longHeader) {\n        printScore(txt, algorithmName, probability, longHeader);\n        txt.append(String.format(Locale.US, \"Afp-num %d Identity %.2f%% Similarity %.2f%%\", afpNum, identity * 100, similarity * 100));\n        txt.append(newline);\n    }\n    int i;\n    double gap;\n    if (longHeader) {\n        // FatCatParameters.DEFAULT_FRAGLEN;\n        int fragLen = 8;\n        for (i = 0; i < blockNum; i++) {\n            gap = blockGap[i] / ((double) blockGap[i] + fragLen * blockSize[i]);\n            txt.append(String.format(Locale.US, \"Block %2d afp %2d score %5.2f rmsd %5.2f gap %d (%.2f%%)\", i, blockSize[i], blockScore[i], blockRmsd[i], blockGap[i], gap));\n            txt.append(newline);\n        }\n    }\n    int linelen = 70;\n    String a;\n    String b;\n    String c;\n    int t = 0;\n    int ap = alnbeg1;\n    int bp = alnbeg2;\n    int k, len;\n    //System.out.println(alnseq1.length + \" \" + alnseq1.toString());\n    while ((alnLength - t) > 0) {\n        if (alnLength - t > linelen)\n            len = linelen;\n        else\n            len = alnLength - t;\n        if (ap >= ca1.length)\n            break;\n        if (bp >= ca2.length)\n            break;\n        String pdb1 = ca1[ap].getGroup().getResidueNumber().toString();\n        String pdb2 = ca2[bp].getGroup().getResidueNumber().toString();\n        //System.err.println(\"t,len:\"+t+\":\"+len);\n        String lseq1 = String.valueOf(alnseq1).substring(t, t + len);\n        String lseq2 = String.valueOf(alnseq2).substring(t, t + len);\n        String lsymb = String.valueOf(alnsymb).substring(t, t + len);\n        //System.err.println(\"B:\" + b);\n        // check conservation and color accordingly, if requested by user.\n        if (showHTML) {\n            a = \"\";\n            b = \"\";\n            c = \"\";\n            //\t<span class=\\\"m\\\">|</span> ... Structurally equivalent and identical residues\n            //  <span class=\\\"sm\\\">:</span> ... Structurally equivalent and similar residues\n            //  <span class=\\\"qg\\\">.</span> ... Structurally equivalent, but not similar residues.\n            for (int pos = 0; pos < lseq1.length(); pos++) {\n                char c1 = lseq1.charAt(pos);\n                char c2 = lseq2.charAt(pos);\n                char cl = lsymb.charAt(pos);\n                int block = -1;\n                if (cl != ' ') {\n                    try {\n                        block = Integer.parseInt(String.valueOf(cl));\n                    } catch (Exception e) {\n                        //\n                    }\n                }\n                if (cl != ' ') {\n                    if (showAlignmentBlock && block > -1) {\n                        a += \"<span class=\\\"alignmentBlock1\" + block + \"\\\">\" + c1 + \"</span>\";\n                        b += \"<span class=\\\"alignmentBlock2\" + block + \"\\\">\" + c2 + \"</span>\";\n                        c += \"<span class=\\\"m\\\">\" + cl + \"</span>\";\n                    } else {\n                        a += getPrefix(c1, c2, 0, block, false).toString() + c1 + \"</span>\";\n                        b += getPrefix(c1, c2, 1, block, false).toString() + c2 + \"</span>\";\n                        c += \"<span class=\\\"m\\\">\" + cl + \"</span>\";\n                    }\n                } else if (c1 != '-' && c2 != '-') {\n                    a += \"<span class=\\\"sm\\\">\" + c1 + \"</span>\";\n                    b += \"<span class=\\\"sm\\\">\" + c2 + \"</span>\";\n                    c += \"<span class=\\\"sm\\\">\" + cl + \"</span>\";\n                } else {\n                    a += \"<span class=\\\"qg\\\">\" + c1 + \"</span>\";\n                    b += \"<span class=\\\"qg\\\">\" + c2 + \"</span>\";\n                    c += \"<span class=\\\"qg\\\">\" + cl + \"</span>\";\n                }\n                if (c1 != '-')\n                    ap++;\n                if (c2 != '-')\n                    bp++;\n            }\n        } else {\n            a = lseq1;\n            b = lseq2;\n            c = lsymb;\n        }\n        txt.append(newline);\n        if (longHeader)\n            txt.append(String.format(\"%14s\", \" \"));\n        else\n            txt.append(String.format(\"%14s\", \" \"));\n        if (longHeader) {\n            for (k = 10; k <= len; k += 10) txt.append(\"    .    :\");\n            if (k <= len + 5)\n                txt.append(\"    .\");\n        } else {\n            for (k = 10; k <= len; k += 10) txt.append(\"----+----|\");\n            if (k <= len + 5)\n                txt.append(\"----+\");\n        }\n        txt.append(newline);\n        txt.append(String.format(\"Chain 1:%5s %s\" + newline + \"%14s%s\" + newline + \"Chain 2:%5s %s\", pdb1, a, \" \", c, pdb2, b));\n        txt.append(newline);\n        if (!showHTML) {\n            for (k = 0; k < len; k++) {\n                if (a.charAt(k) != '-')\n                    ap++;\n                if (b.charAt(k) != '-')\n                    bp++;\n            }\n        }\n        t += len;\n    }\n    txt.append(newline);\n    if (printLegend) {\n        if (algorithmName.equalsIgnoreCase(CeMain.algorithmName) || algorithmName.equalsIgnoreCase(SmithWaterman3Daligner.algorithmName)) {\n            txt.append(\"Note: positions are from PDB; | means alignment of identical amino acids, : of similar amino acids \");\n        } else {\n            txt.append(\"Note: positions are from PDB; the numbers between alignments are block index\");\n        }\n        txt.append(newline);\n    }\n    return txt.toString();\n}", "repo_id": "9", "comment": "/**\n * Output in FatCatCore format\n *\n * <p>Note that if a circular permutation has occured the residue numbers may\n * be innaccurate.\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @param printLegend\n * @param longHeader\n * @param showHTML\n * @param showAlignmentBlock\n * @return\n */\n", "repo_name": "biojava-master/", "id": 512, "method_signature": "String toFatCatCore(AFPChain, Atom[], Atom[], boolean, boolean, boolean, boolean)"}, "713": {"callee_method_names": [], "method_name": "CECalculator.initIntraDistmatrix", "method_implementation": "{\n    double[][] intraDist = new double[nse][nse];\n    //\n    for (int ise1 = 0; ise1 < nse; ise1++) {\n        for (int ise2 = 0; ise2 < nse; ise2++) {\n            intraDist[ise1][ise2] = getDistanceWithSidechain(ca[ise1], ca[ise2]);\n        }\n    }\n    return intraDist;\n}", "repo_id": "9", "comment": "/**\n * build up intramolecular distance matrix dist1 & dist2\n *\n * @param ca\n * @param nse\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 713, "method_signature": "double[][] initIntraDistmatrix(Atom[], int)"}, "3421": {"callee_method_ids": [1960, 1971], "callee_method_names": ["HelixAxisAligner.getTransformation", "HelixAxisAligner.getSubunits", "List<List<Integer>>.size", "List<List<Integer>>.get", "List<Integer>.get", "List<Point3d>.get", "Matrix4d.transform", "List<Integer>.get", "List<Integer>.size", "List<Point3d>.get", "Matrix4d.transform"], "method_name": "JmolSymmetryScriptGeneratorH.orientLayerLines", "method_implementation": "{\n    Matrix4d transformation = helixAxisAligner.getTransformation();\n    List<Point3d> centers = helixAxisAligner.getSubunits().getOriginalCenters();\n    for (int i = 0; i < layerLines.size(); i++) {\n        List<Integer> layerLine = layerLines.get(i);\n        // get center of first subunit in layerline and transform to standard orientation (helix axis aligned with y-axis)\n        int first = layerLine.get(0);\n        Point3d firstSubunit = new Point3d(centers.get(first));\n        transformation.transform(firstSubunit);\n        // get center of last subunit in layerline and transform to standard orientation (helix axis aligned with y-axis)\n        int last = layerLine.get(layerLine.size() - 1);\n        Point3d lastSubunit = new Point3d(centers.get(last));\n        transformation.transform(lastSubunit);\n        // a layerline should start at the lowest y-value, so all layerlines have a consistent direction from -y value to +y value\n        if (firstSubunit.y > lastSubunit.y) {\n            //\t\t\t\tSystem.out.println(\"reorienting layer line: \" + layerLine);\n            Collections.reverse(layerLine);\n        }\n    }\n    return layerLines;\n}", "repo_id": "9", "comment": "/**\n * Orients layer lines from lowest y-axis value to largest y-axis value\n */\n", "repo_name": "biojava-master/", "id": 3421, "method_signature": "List<List<Integer>> orientLayerLines(List)"}, "3800": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getTop", "method_implementation": "{\n    return top;\n}", "repo_id": "9", "comment": "/**\n * @return the top\n */\n", "repo_name": "biojava-master/", "id": 3800, "method_signature": "int getTop()"}, "2575": {"callee_method_names": ["HttpURLConnection.setRequestMethod", "HttpURLConnection.getResponseCode"], "method_name": "FileDownloadUtils.ping", "method_implementation": "{\n    //url = url.replaceFirst(\"https\", \"http\"); // Otherwise an exception may be thrown on invalid SSL certificates.\n    try {\n        HttpURLConnection connection = (HttpURLConnection) prepareURLConnection(url, timeout);\n        connection.setRequestMethod(\"HEAD\");\n        int responseCode = connection.getResponseCode();\n        return (200 <= responseCode && responseCode <= 399);\n    } catch (IOException exception) {\n        return false;\n    }\n}", "repo_id": "9", "comment": "/**\n * Pings a HTTP URL. This effectively sends a HEAD request and returns\n * <code>true</code> if the response code is in the 200-399 range.\n *\n * @param url The HTTP URL to be pinged.\n * @param timeout The timeout in millis for both the connection timeout and\n * the response read timeout. Note that the total timeout is effectively two\n * times the given timeout.\n * @return <code>true</code> if the given HTTP URL has returned response\n * code 200-399 on a HEAD request within the given timeout, otherwise\n * <code>false</code>.\n * @author BalusC,\n * http://stackoverflow.com/questions/3584210/preferred-java-way-to-ping-a-http-url-for-availability\n */\n", "repo_name": "biojava-master/", "id": 2575, "method_signature": "boolean ping(String, int)"}, "783": {"callee_method_names": ["List<T>.add", "List<T>.get"], "method_name": "OptimalCECPMain.permuteArray", "method_implementation": "{\n    // Allow negative cp points for convenience.\n    if (cp == 0) {\n        return;\n    }\n    if (cp < 0) {\n        cp = arr.length + cp;\n    }\n    if (cp < 0 || cp >= arr.length) {\n        throw new ArrayIndexOutOfBoundsException(\"Permutation point (\" + cp + \") must be between -ca2.length and ca2.length-1\");\n    }\n    List<T> temp = new ArrayList<T>(cp);\n    // shift residues left\n    for (int i = 0; i < cp; i++) {\n        temp.add(arr[i]);\n    }\n    for (int j = cp; j < arr.length; j++) {\n        arr[j - cp] = arr[j];\n    }\n    for (int i = 0; i < cp; i++) {\n        arr[arr.length - cp + i] = temp.get(i);\n    }\n}", "repo_id": "9", "comment": "/**\n * Circularly permutes arr in place.\n *\n * <p>Similar to {@link Collections#rotate(List, int)} but with reversed\n * direction. Perhaps it would be more efficient to use the Collections version?\n * @param <T>\n * @param arr The array to be permuted\n * @param cp The number of residues to shift leftward, or equivalently, the index of\n *  the first element after the permutation point.\n */\n", "repo_name": "biojava-master/", "id": 783, "method_signature": "void permuteArray(T[], int)"}, "2619": {"callee_method_names": ["Scanner.hasNextLine", "Scanner.nextLine", "Scanner.hasNextLine", "Scanner.nextLine", "String.equals", "Scanner.hasNextLine"], "method_name": "StringManipulationHelper.equalsToIgnoreEndline", "method_implementation": "{\n    if (expected == null && actual == null) {\n        return true;\n    }\n    if (expected != null ^ actual != null) {\n        return false;\n    }\n    Scanner scanner1 = new Scanner(expected);\n    Scanner scanner2 = new Scanner(actual);\n    String line1, line2;\n    while (scanner1.hasNextLine()) {\n        line1 = scanner1.nextLine();\n        if (scanner2.hasNextLine()) {\n            line2 = scanner2.nextLine();\n            if (!line1.equals(line2)) {\n                closeScanners(scanner1, scanner2);\n                return false;\n            }\n        } else {\n            closeScanners(scanner1, scanner2);\n            return false;\n        }\n    }\n    if (scanner2.hasNextLine()) {\n        closeScanners(scanner1, scanner2);\n        return false;\n    }\n    closeScanners(scanner1, scanner2);\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Compares two strings in a case-sensitive manner for equality, line by line, ignoring any difference\n * of end line delimiters contained within the 2 Strings.\n * <br/>\n * This method should\n * be used if and only if two Strings are considered identical when all nodes\n * are identical including their relative order. Generally useful when\n * asserting identity of <b>automatically regenerated</b> XML or PDB.\n *\n * @param expected\n * @param actual\n */\n", "repo_name": "biojava-master/", "id": 2619, "method_signature": "boolean equalsToIgnoreEndline(String, String)"}, "1246": {"callee_method_names": ["Set<ExperimentalTechnique>.size"], "method_name": "MmtfUtils.techniquesToStringArray", "method_implementation": "{\n    if (experimentalTechniques == null) {\n        return new String[0];\n    }\n    String[] outArray = new String[experimentalTechniques.size()];\n    int index = 0;\n    for (ExperimentalTechnique experimentalTechnique : experimentalTechniques) {\n        outArray[index] = experimentalTechnique.getName();\n        index++;\n    }\n    return outArray;\n}", "repo_id": "9", "comment": "/**\n * Converts the set of experimental techniques to an array of strings.\n * @param experimentalTechniques the input set of experimental techniques\n * @return the array of strings describing the methods used.\n */\n", "repo_name": "biojava-master/", "id": 1246, "method_signature": "String[] techniquesToStringArray(Set)"}, "3123": {"callee_method_names": ["SequenceAsStringHelper<C>.getSequenceAsString"], "method_name": "UniprotProxySequenceReader.getSequenceAsString", "method_implementation": "{\n    SequenceAsStringHelper<C> sequenceAsStringHelper = new SequenceAsStringHelper<C>();\n    return sequenceAsStringHelper.getSequenceAsString(this.parsedCompounds, compoundSet, bioBegin, bioEnd, strand);\n}", "repo_id": "9", "comment": "/**\n * @param bioBegin\n * @param bioEnd\n * @param strand\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3123, "method_signature": "String getSequenceAsString(Integer, Integer, Strand)"}, "500": {"callee_method_names": [], "method_name": "AFPChain.getIdentity", "method_implementation": "{\n    if (identity <= 0) {\n        calcSimilarity();\n    }\n    return identity;\n}", "repo_id": "9", "comment": "/**\n * The percent of residues that are sequence-identical in the alignment.\n *\n * @return a value between 0 and 1\n */\n", "repo_name": "biojava-master/", "id": 500, "method_signature": "double getIdentity()"}, "3535": {"callee_method_names": [], "method_name": "CoxCoefficient.getHazardRatio", "method_implementation": "{\n    return hazardRatio;\n}", "repo_id": "9", "comment": "/**\n * @return the hazardRatio\n */\n", "repo_name": "biojava-master/", "id": 3535, "method_signature": "double getHazardRatio()"}, "2380": {"callee_method_names": ["HashMap.get", "HashMap.get", "RandomAccessFile.seek", "Logger.debug", "Logger.debug", "Logger.debug", "RandomAccessFile.getFilePointer"], "method_name": "TwoBitParser.setCurrentSequence", "method_implementation": "{\n    if (cur_seq_name != null) {\n        throw new Exception(\"Sequence [\" + cur_seq_name + \"] was not closed\");\n    }\n    if (seq2pos.get(seq_name) == null) {\n        throw new Exception(\"Sequence [\" + seq_name + \"] was not found in 2bit file\");\n    }\n    cur_seq_name = seq_name;\n    long pos = seq2pos.get(seq_name);\n    raf.seek(pos);\n    long dna_size = readFourBytes();\n    logger.debug(\"2bit: Sequence name=[{}], dna_size={}\", cur_seq_name, dna_size);\n    cur_dna_size = dna_size;\n    int nn_block_qnt = (int) readFourBytes();\n    cur_nn_blocks = new long[nn_block_qnt][2];\n    for (int i = 0; i < nn_block_qnt; i++) {\n        cur_nn_blocks[i][0] = readFourBytes();\n    }\n    for (int i = 0; i < nn_block_qnt; i++) {\n        cur_nn_blocks[i][1] = readFourBytes();\n    }\n    for (int i = 0; i < nn_block_qnt; i++) {\n        logger.debug(\"NN-block: [{},{}] \", cur_nn_blocks[i][0], cur_nn_blocks[i][1]);\n    }\n    int mask_block_qnt = (int) readFourBytes();\n    cur_mask_blocks = new long[mask_block_qnt][2];\n    for (int i = 0; i < mask_block_qnt; i++) {\n        cur_mask_blocks[i][0] = readFourBytes();\n    }\n    for (int i = 0; i < mask_block_qnt; i++) {\n        cur_mask_blocks[i][1] = readFourBytes();\n    }\n    for (int i = 0; i < mask_block_qnt; i++) {\n        logger.debug(\"[{},{}] \", cur_mask_blocks[i][0], cur_mask_blocks[i][1]);\n    }\n    readFourBytes();\n    start_file_pos = raf.getFilePointer();\n    reset();\n}", "repo_id": "9", "comment": "/**\n * Method open nucleotide stream for sequence with given name.\n * @param seq_name name of sequence (one of returned by getSequenceNames()).\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2380, "method_signature": "void setCurrentSequence(String)"}, "1671": {"callee_method_names": ["ProteinSequence.toString", "StringBuilder.append", "SecStrucGroup.getGroup", "StringBuilder.toString"], "method_name": "Subunit.getProteinSequenceString", "method_implementation": "{\n    if (sequence != null)\n        return sequence.toString();\n    StringBuilder builder = new StringBuilder();\n    for (Atom a : reprAtoms) // This method preferred over getChemComp.getOneLetterCode because\n    // it returns always X for Unknown residues\n    builder.append(StructureTools.get1LetterCode(a.getGroup().getPDBName()));\n    return builder.toString();\n}", "repo_id": "9", "comment": "/**\n * Get the protein sequence of the Subunit as String.\n *\n * @return protein sequence String\n */\n", "repo_name": "biojava-master/", "id": 1671, "method_signature": "String getProteinSequenceString()"}, "2192": {"callee_method_ids": [628], "callee_method_names": ["StructureIOFile.getStructure", "AtomCache.getStructure", "List<Atom[]>.add", "MultipleAlignment.getEnsemble", "MultipleAlignmentEnsemble.setAtomArrays", "MultipleAlignmentEnsemble.setAlgorithmName", "MultipleAlignmentEnsemble.setVersion", "MultipleAlignmentEnsemble.setCalculationTime", "MultipleAlignmentEnsemble.setStructureIdentifiers", "List<Integer>.add", "List<Integer>.add", "List<List<Integer>>.add", "Block.setAlignRes", "MultipleSuperimposer.superimpose"], "method_name": "TestSampleGenerator.testAlignment1", "method_implementation": "{\n    //Obtain the structure atoms from resources\n    StructureIOFile reader = new PDBFileReader();\n    File f = new File(\"src/test/resources/2gox.pdb\");\n    Structure structure = null;\n    try {\n        structure = reader.getStructure(f);\n    } catch (IOException e) {\n        AtomCache cache = new AtomCache();\n        structure = cache.getStructure(\"2gox\");\n    }\n    List<Atom[]> atomArrays = new ArrayList<Atom[]>(3);\n    for (int str = 0; str < 3; str++) {\n        Atom[] atoms = StructureTools.getRepresentativeAtomArray(structure);\n        atomArrays.add(StructureTools.cloneAtomArray(atoms));\n    }\n    //Set the ensemble properties\n    MultipleAlignment msa = new MultipleAlignmentImpl();\n    MultipleAlignmentEnsemble ensemble = msa.getEnsemble();\n    ensemble.setAtomArrays(atomArrays);\n    ensemble.setAlgorithmName(\"testAlignment\");\n    ensemble.setVersion(\"1.0\");\n    ensemble.setCalculationTime((long) 1000000000);\n    ensemble.setStructureIdentifiers(Arrays.<StructureIdentifier>asList(new StructureName(\"2gox\"), new StructureName(\"2gox\"), new StructureName(\"2gox\")));\n    //Generate the MultipleAlignment - 2 blocks with 2 blocksets each\n    int[] nextResidue = new int[3];\n    for (int bs = 0; bs < 2; bs++) {\n        BlockSet blockSet = new BlockSetImpl(msa);\n        for (int b = 0; b < 2; b++) {\n            List<List<Integer>> alnRes = new ArrayList<List<Integer>>(3);\n            for (int str = 0; str < 3; str++) {\n                List<Integer> chain = new ArrayList<Integer>(50);\n                for (int res = 0; res < 10; res++) {\n                    //Introduce gaps and discontinuities\n                    if (nextResidue[str] % (2 + str) == str)\n                        chain.add(null);\n                    else\n                        chain.add(nextResidue[str]);\n                    if (nextResidue[str] % (10) == str)\n                        nextResidue[str]++;\n                    nextResidue[str]++;\n                }\n                alnRes.add(chain);\n                //Spacing between Blocks\n                nextResidue[str] += str;\n            }\n            Block block = new BlockImpl(blockSet);\n            block.setAlignRes(alnRes);\n        }\n    }\n    //Superposition and scores\n    MultipleSuperimposer imposer = new ReferenceSuperimposer();\n    imposer.superimpose(msa);\n    MultipleAlignmentScorer.calculateScores(msa);\n    return msa;\n}", "repo_id": "9", "comment": "/**\n * Generate a MultipleAlignment of 3 identical structures slightly\n * missaligned by a repetitive pattern. The resulting alignment contains\n * 2 BlockSets with 2 Blocks each. Gaps and discontinuities are also\n * included.<p>\n * Fields left unfilled (null): distanceMatrices and ioTime.<p>\n * Atoms are not downladed, but the structure (2gox) is obtained from the\n * test/resources folder.\n *\n * @return\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2192, "method_signature": "MultipleAlignment testAlignment1()"}, "2373": {"callee_method_names": [], "method_name": "Fastq.getVariant", "method_implementation": "{\n    return variant;\n}", "repo_id": "9", "comment": "/**\n * Return the FASTQ sequence format variant for this FASTQ formatted sequence.\n * The FASTQ sequence format variant will not be null.\n *\n * @return the FASTQ sequence format variant for this FASTQ formatted sequence\n */\n", "repo_name": "biojava-master/", "id": 2373, "method_signature": "FastqVariant getVariant()"}, "3732": {"callee_method_names": ["ArrayList<String>.size", "ArrayList<String>.size", "ArrayList<String>.size", "ArrayList<String>.get", "LinkedHashMap.put"], "method_name": "WorkSheet.addColumns", "method_implementation": "{\n    CompactCharSequence dv = new CompactCharSequence(defaultValue);\n    for (int i = 0; i < data.length; i++) {\n        CompactCharSequence[] row = data[i];\n        int oldrowlength = data[i].length;\n        data[i] = (CompactCharSequence[]) resizeArray(row, oldrowlength + columns.size());\n        for (int c = 0; c < columns.size(); c++) {\n            data[i][oldrowlength + c] = dv;\n        }\n        if (i == 0) {\n            for (int c = 0; c < columns.size(); c++) {\n                String column = columns.get(c);\n                data[0][oldrowlength + c] = new CompactCharSequence(column);\n                columnLookup.put(column, new HeaderInfo(oldrowlength + c));\n            }\n        }\n    }\n    //   columnLookup.get(\"ZNF30\");\n    //     int startIndex = columnLookup.size() + 1;\n    //     for (String column : columns) {\n    //        if(column.equals(\"ttr\")){\n    //            int dummy = 1;\n    //        }\n    //        columnLookup.put(column, new HeaderInfo(startIndex));\n    //        startIndex++;\n    //    }\n}", "repo_id": "9", "comment": "/**\n * Add columns to worksheet and set default value\n *\n * @param columns\n * @param defaultValue\n */\n", "repo_name": "biojava-master/", "id": 3732, "method_signature": "void addColumns(ArrayList, String)"}, "3744": {"callee_method_names": ["LinkedHashMap.get", "LinkedHashMap.remove", "LinkedHashMap.put", "LinkedHashMap.remove", "LinkedHashMap.put"], "method_name": "WorkSheet.changeRowHeader", "method_implementation": "{\n    HeaderInfo value = rowLookup.get(row);\n    if (value == null) {\n        throw new Exception(\"Row not found \" + row);\n    }\n    rowLookup.remove(row);\n    rowLookup.put(newRow, value);\n    if (this.isMetaDataRow(row)) {\n        metaDataRowsHashMap.remove(row);\n        metaDataRowsHashMap.put(newRow, newRow);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param row\n * @param newRow\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3744, "method_signature": "void changeRowHeader(String, String)"}, "3852": {"callee_method_names": ["HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put", "HashMap.put"], "method_name": "Constraints.initHydropathicity", "method_implementation": "{\n    //\t\tAla(A):  1.800\n    aa2Hydrophathicity.put(A, 1.800);\n    //\t\tArg(R): -4.500\n    aa2Hydrophathicity.put(R, -4.500);\n    //\t\tAsn(N): -3.500\n    aa2Hydrophathicity.put(N, -3.500);\n    //\t\tAsp(D): -3.500\n    aa2Hydrophathicity.put(D, -3.500);\n    //\t\tCys(C):  2.500\n    aa2Hydrophathicity.put(C, 2.500);\n    //\t\tGln(E): -3.500\n    aa2Hydrophathicity.put(E, -3.500);\n    //\t\tGlu(Q): -3.500\n    aa2Hydrophathicity.put(Q, -3.500);\n    //\t\tGly(G): -0.400\n    aa2Hydrophathicity.put(G, -0.400);\n    //\t\tHis(H): -3.200\n    aa2Hydrophathicity.put(H, -3.200);\n    //\t\tIle(I):  4.500\n    aa2Hydrophathicity.put(I, 4.500);\n    //\t\tLeu(L):  3.800\n    aa2Hydrophathicity.put(L, 3.800);\n    //\t\tLys(K): -3.900\n    aa2Hydrophathicity.put(K, -3.900);\n    //\t\tMet(M):  1.900\n    aa2Hydrophathicity.put(M, 1.900);\n    //\t\tPhe(F):  2.800\n    aa2Hydrophathicity.put(F, 2.800);\n    //\t\tPro(P): -1.600\n    aa2Hydrophathicity.put(P, -1.600);\n    //\t\tSer(S): -0.800\n    aa2Hydrophathicity.put(S, -0.800);\n    //\t\tThr(T): -0.700\n    aa2Hydrophathicity.put(T, -0.700);\n    //\t\tTrp(W): -0.900\n    aa2Hydrophathicity.put(W, -0.900);\n    //\t\tTyr(Y): -1.300\n    aa2Hydrophathicity.put(Y, -1.300);\n    //\t\tVal(V):  4.200\n    aa2Hydrophathicity.put(V, 4.200);\n}", "repo_id": "9", "comment": "/**\n * Does the initialization of hydropathicity based on http://web.expasy.org/protscale/pscale/Hphob.Doolittle.html\n */\n", "repo_name": "biojava-master/", "id": 3852, "method_signature": "void initHydropathicity()"}, "172": {"callee_method_names": ["Structure.getPolyChainByPDB", "Chain.clone"], "method_name": "StructureToolsTest.testGetRepresentativeAtomsDna", "method_implementation": "{\n    Structure s = StructureIO.getStructure(\"2pvi\");\n    Chain c = s.getPolyChainByPDB(\"C\");\n    // chain C (1st nucleotide chain)\n    Atom[] atoms = StructureTools.getRepresentativeAtomArray(c);\n    // actually it should be 13, but at the moment one of the nucleotides is not caught correctly because it's non-standard\n    assertEquals(12, atoms.length);\n    Chain clonedChain = (Chain) c.clone();\n    // chain C (1st nucleotide chain)\n    atoms = StructureTools.getRepresentativeAtomArray(clonedChain);\n    assertEquals(12, atoms.length);\n}", "repo_id": "9", "comment": "/**\n * See https://github.com/biojava/biojava/issues/631\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 172, "method_signature": "void testGetRepresentativeAtomsDna()"}, "63": {"callee_method_names": [], "method_name": "AbstractMatrixAligner.isStoringScoreMatrix", "method_implementation": "{\n    return storingScoreMatrix;\n}", "repo_id": "9", "comment": "/**\n * Returns choice to cache the score matrix or to save memory by deleting score matrix after alignment.\n *\n * @return choice to cache the score matrix\n */\n", "repo_name": "biojava-master/", "id": 63, "method_signature": "boolean isStoringScoreMatrix()"}, "2002": {"callee_method_names": [], "method_name": "Octahedron.getInscribedRadius", "method_implementation": "{\n    double side = getSideLengthFromCircumscribedRadius(cirumscribedRadius);\n    return getInscribedRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of an inscribed sphere, that is tangent to each\n * of the octahedron's faces\n * @return the inscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2002, "method_signature": "double getInscribedRadius()"}, "847": {"callee_method_names": ["SymbolTable<Integer, Double>.contains", "SymbolTable<Integer, Double>.get"], "method_name": "SparseVector.get", "method_implementation": "{\n    if (i < 0 || i >= N)\n        throw new IllegalArgumentException(\"Illegal index \" + i + \" should be > 0 and < \" + N);\n    if (symbolTable.contains(i))\n        return symbolTable.get(i);\n    else\n        return 0.0;\n}", "repo_id": "9", "comment": "/**\n * get a value\n *\n * @param i\n * @return  return symbolTable[i]\n */\n", "repo_name": "biojava-master/", "id": 847, "method_signature": "double get(int)"}, "1397": {"callee_method_names": ["Pattern.matcher"], "method_name": "PdbId.isValidExtendedPdbId", "method_implementation": "{\n    return PATTERN_EXTENDED_PDBID.matcher(id).matches();\n}", "repo_id": "9", "comment": "/**\n * Check whether <code>id</code> represents a valid PDB ID in the <em>extended</em> format.\n * @param id Prospect ID\n * @return <code>true</code> if <code>id</code> is a valid extended PDB ID, <code>false</code> otherwise.\n * @throws NullPointerException if <code>id</code> is <code>null</code>.\n * @see #isValidShortPdbId(String)\n */\n", "repo_name": "biojava-master/", "id": 1397, "method_signature": "boolean isValidExtendedPdbId(String)"}, "2117": {"callee_method_names": [], "method_name": "StructureImpl.setName", "method_implementation": "{\n    name = nam;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2117, "method_signature": "void setName(String)"}, "1376": {"callee_method_names": [], "method_name": "DBRef.getDatabase", "method_implementation": "{\n    return database;\n}", "repo_id": "9", "comment": "/**\n *  The database of the db-ref.\n *  uses the abbreviation as provided in the PDB files:\n *\n * <pre>   Database name                         database\n * \t\t\t\t\t\t\t\t\t (code in columns 27 - 32)\n * \t----------------------------------------------------------\n * \tGenBank                               GB\n * \tProtein Data Bank                     PDB\n * \tProtein Identification Resource       PIR\n * \tSWISS-PROT                            SWS\n * \tTREMBL                                TREMBL\n * \tUNIPROT                               UNP\n * \t</pre>\n *  @return name of database of this DBRef\n *  @see #setDatabase(String)\n */\n", "repo_name": "biojava-master/", "id": 1376, "method_signature": "String getDatabase()"}, "2707": {"callee_method_names": ["Formatter.format", "Point.getPosition", "Formatter.toString", "Formatter.close"], "method_name": "GenericInsdcHeaderFormat._insdc_feature_position_string", "method_implementation": "{\n    StringBuilder sb = new StringBuilder();\n    Formatter formatter = new Formatter(sb, Locale.US);\n    formatter.format(\"%s\", location.getPosition() + increment);\n    String output = formatter.toString();\n    formatter.close();\n    return output;\n    /*\n\tif isinstance(pos, SeqFeature.ExactPosition):\n\t\treturn \"%i\" % (pos.position+offset)\n\telif isinstance(pos, SeqFeature.WithinPosition):\n\t\treturn \"(%i.%i)\" % (pos.position + offset,\n\t\t\t\t\t\t\tpos.position + pos.extension + offset)\n\telif isinstance(pos, SeqFeature.BetweenPosition):\n\t\treturn \"(%i^%i)\" % (pos.position + offset,\n\t\t\t\t\t\t\tpos.position + pos.extension + offset)\n\telif isinstance(pos, SeqFeature.BeforePosition):\n\t\treturn \"<%i\" % (pos.position + offset)\n\telif isinstance(pos, SeqFeature.AfterPosition):\n\t\treturn \">%i\" % (pos.position + offset)\n\telif isinstance(pos, SeqFeature.OneOfPosition):\n\t\treturn \"one-of(%s)\" \\\n\t\t\t   % \",\".join([_insdc_feature_position_string(p,offset) \\\n\t\t\t\t\t\t   for p in pos.position_choices])\n\telif isinstance(pos, SeqFeature.AbstractPosition):\n\t\traise NotImplementedError(\"Please report this as a bug in Biopython.\")\n\telse:\n\t\traise ValueError(\"Expected a SeqFeature position object.\")\n\t\t */\n}", "repo_id": "9", "comment": "/**\n * Build a GenBank/EMBL position string (PRIVATE).\n * @param location\n * @param increment\n */\n", "repo_name": "biojava-master/", "id": 2707, "method_signature": "String _insdc_feature_position_string(Point, int)"}, "2369": {"callee_method_names": [], "method_name": "FastqTools.toList", "method_implementation": "{\n    if (iterable instanceof List) {\n        return (List<T>) iterable;\n    }\n    return ImmutableList.copyOf(iterable);\n}", "repo_id": "9", "comment": "/**\n * Return the specified iterable as a list.\n *\n * @paam <T> element type\n * @param iterable iterable\n * @return the specified iterable as a list\n */\n", "repo_name": "biojava-master/", "id": 2369, "method_signature": "List<T> toList(Iterable)"}, "2358": {"callee_method_names": ["DNASequence.addFeature", "DNASequence.getLength"], "method_name": "FastqTools.createDNASequenceWithQualityScores", "method_implementation": "{\n    DNASequence sequence = createDNASequence(fastq);\n    sequence.addFeature(1, sequence.getLength(), createQualityScores(fastq));\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Create and return a new {@link DNASequence} with quality scores from the specified\n * FASTQ formatted sequence.  The quality scores are stored in a {@link QualityFeature}\n * with a type <code>\"qualityScores\"</code> the same length as the sequence.\n *\n * @param fastq FASTQ formatted sequence, must not be null\n * @return a new {@link DNASequence} with quality scores from the specified FASTQ formatted sequence\n * @throws CompoundNotFoundException if DNA sequence in fastq contains unrecognised compounds\n */\n", "repo_name": "biojava-master/", "id": 2358, "method_signature": "DNASequence createDNASequenceWithQualityScores(Fastq)"}, "3071": {"callee_method_ids": [3056, 3056, 3056], "callee_method_names": ["LinkedHashMap.containsKey", "AccessionID.getID", "AccessionID.getID", "ExonSequence.setAccession", "ArrayList.add", "LinkedHashMap.put", "AccessionID.getID"], "method_name": "GeneSequence.addExon", "method_implementation": "{\n    if (exonSequenceHashMap.containsKey(accession.getID())) {\n        throw new IllegalArgumentException(\"Duplicate accession id: \" + accession.getID());\n    }\n    //sense should be the same as parent\n    ExonSequence exonSequence = new ExonSequence(this, begin, end);\n    exonSequence.setAccession(accession);\n    exonSequenceList.add(exonSequence);\n    exonSequenceHashMap.put(accession.getID(), exonSequence);\n    return exonSequence;\n}", "repo_id": "9", "comment": "/**\n * Add an ExonSequence mainly used to mark as a feature\n * @param accession\n * @param begin\n * @param end\n * @return exon sequence\n * @throws IllegalArgumentException if accessionID is already added.\n */\n", "repo_name": "biojava-master/", "id": 3071, "method_signature": "ExonSequence addExon(AccessionID, int, int)"}, "1012": {"callee_method_names": [], "method_name": "NucleotideImpl.getO5Prime", "method_implementation": "{\n    return getAtom(\"O5'\");\n}", "repo_id": "9", "comment": "/**\n * Returns the O5' atom if present, otherwise null\n * @return O5' atom or null\n */\n", "repo_name": "biojava-master/", "id": 1012, "method_signature": "Atom getO5Prime()"}, "1943": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setRmsd", "method_implementation": "{\n    this.rmsd = rmsd;\n}", "repo_id": "9", "comment": "/**\n * @param rmsd the rmsd to set\n */\n", "repo_name": "biojava-master/", "id": 1943, "method_signature": "void setRmsd(double)"}, "945": {"callee_method_names": [], "method_name": "PassthroughIdentifier.toCanonical", "method_implementation": "{\n    return new SubstructureIdentifier((PdbId) null, new ArrayList<ResidueRange>());\n}", "repo_id": "9", "comment": "/**\n * @return A SubstructureIdentifier without ranges (e.g. including all residues)\n */\n", "repo_name": "biojava-master/", "id": 945, "method_signature": "SubstructureIdentifier toCanonical()"}, "3721": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "WorkSheet.isMetaDataColumn", "method_implementation": "{\n    if (metaDataColumnsHashMap.get(column) == null) {\n        return false;\n    } else {\n        return true;\n    }\n}", "repo_id": "9", "comment": "/**\n * @param column\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3721, "method_signature": "boolean isMetaDataColumn(String)"}, "1946": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getMaxTm", "method_implementation": "{\n    return maxTm;\n}", "repo_id": "9", "comment": "/**\n * @return the maxTm\n */\n", "repo_name": "biojava-master/", "id": 1946, "method_signature": "double getMaxTm()"}, "2622": {"callee_method_names": [], "method_name": "StringManipulationHelper.padRight", "method_implementation": "{\n    validatePadding(n);\n    return String.format(\"%1$-\" + n + \"s\", s);\n}", "repo_id": "9", "comment": "/**\n * Adds padding to right of supplied string\n * @param s The String to pad\n * @param n an integer >= 1\n * @return The right-padded string.\n * @throws IllegalArgumentException if n <= 0\n */\n", "repo_name": "biojava-master/", "id": 2622, "method_signature": "String padRight(String, int)"}, "1166": {"callee_method_ids": [1317], "callee_method_names": ["FileParsingParameters.isHeaderOnly", "String.length", "Logger.info", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "String.substring", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "List<Map<String, String>>.add"], "method_name": "PDBFileParser.pdb_TURN_Handler", "method_implementation": "{\n    if (params.isHeaderOnly())\n        return;\n    if (line.length() < 36) {\n        logger.info(\"TURN line has length under 36. Ignoring it.\");\n        return;\n    }\n    String initResName = line.substring(15, 18).trim();\n    String initChainId = line.substring(19, 20);\n    String initSeqNum = line.substring(20, 24).trim();\n    String initICode = line.substring(24, 25);\n    String endResName = line.substring(26, 29).trim();\n    String endChainId = line.substring(30, 31);\n    String endSeqNum = line.substring(31, 35).trim();\n    String endICode = line.substring(35, 36);\n    //System.out.println(initResName + \" \" + initChainId + \" \" + initSeqNum + \" \" + initICode + \" \" +\n    //        endResName + \" \" + endChainId + \" \" + endSeqNum + \" \" + endICode);\n    Map<String, String> m = new HashMap<String, String>();\n    m.put(\"initResName\", initResName);\n    m.put(\"initChainId\", initChainId);\n    m.put(\"initSeqNum\", initSeqNum);\n    m.put(\"initICode\", initICode);\n    m.put(\"endResName\", endResName);\n    m.put(\"endChainId\", endChainId);\n    m.put(\"endSeqNum\", endSeqNum);\n    m.put(\"endICode\", endICode);\n    turnList.add(m);\n}", "repo_id": "9", "comment": "/**\n * Handler for TURN lines\n * <pre>\n * COLUMNS      DATA TYPE        FIELD         DEFINITION\n * --------------------------------------------------------------------\n *  1 -  6      Record name      \"TURN \"\n *  8 - 10      Integer          seq           Turn number; starts with 1 and\n *                                             increments by one.\n * 12 - 14      LString(3)       turnId        Turn identifier\n * 16 - 18      Residue name     initResName   Residue name of initial residue in\n *                                             turn.\n * 20           Character        initChainId   Chain identifier for the chain\n *                                             containing this turn.\n * 21 - 24      Integer          initSeqNum    Sequence number of initial residue\n *                                             in turn.\n * 25           AChar            initICode     Insertion code of initial residue\n *                                             in turn.\n * 27 - 29      Residue name     endResName    Residue name of terminal residue\n *                                             of turn.\n * 31           Character        endChainId    Chain identifier for the chain\n *                                             containing this turn.\n * 32 - 35      Integer          endSeqNum     Sequence number of terminal\n *                                             residue of turn.\n * 36           AChar            endICode      Insertion code of terminal residue\n *                                             of turn.\n * 41 - 70      String           comment       Associated comment.\n * </pre>\n * @param line\n */\n", "repo_name": "biojava-master/", "id": 1166, "method_signature": "void pdb_TURN_Handler(String)"}, "1979": {"callee_method_ids": [1919], "callee_method_names": ["HelixLayers.getByLargestContacts"], "method_name": "HelixAxisAligner.calcPrincipalRotationVector", "method_implementation": "{\n    //\t\tAxisAngle4d axisAngle = helixLayers.getByLowestAngle().getAxisAngle();\n    AxisAngle4d axisAngle = helixLayers.getByLargestContacts().getAxisAngle();\n    principalRotationVector = new Vector3d(axisAngle.x, axisAngle.y, axisAngle.z);\n}", "repo_id": "9", "comment": "/**\n * Returns a vector along the principal rotation axis for the\n * alignment of structures along the z-axis\n * @return principal rotation vector\n */\n", "repo_name": "biojava-master/", "id": 1979, "method_signature": "void calcPrincipalRotationVector()"}, "2914": {"callee_method_names": ["AbstractSequence<?>.getSource"], "method_name": "AbstractSequence.getSource", "method_implementation": "{\n    if (source != null) {\n        return source;\n    }\n    if (parentSequence != null) {\n        return parentSequence.getSource();\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Added support for the source of this sequence for GFF3 export\n * If a sub sequence doesn't have  source then check for parent source\n * @return the source\n */\n", "repo_name": "biojava-master/", "id": 2914, "method_signature": "String getSource()"}, "2324": {"callee_method_names": ["List<Subunit>.size", "List<Subunit>.get", "List<Subunit>.get", "List<Subunit>.get", "List<Subunit>.get"], "method_name": "TestSubunitExtractor.testBioAssembly", "method_implementation": "{\n    Structure s = StructureIO.getStructure(\"BIO:4E3E:1\");\n    List<Subunit> subunits = SubunitExtractor.extractSubunits(s, 5, 0.75, 20);\n    // We expect all 3 equal double hot-dog subunits to be returned\n    assertEquals(subunits.size(), 3);\n    assertEquals(subunits.get(0).size(), subunits.get(1).size());\n    assertEquals(subunits.get(0).size(), subunits.get(2).size());\n}", "repo_id": "9", "comment": "/**\n * Test that all chains from biological assemblies are extracted.\n */\n", "repo_name": "biojava-master/", "id": 2324, "method_signature": "void testBioAssembly()"}, "1059": {"callee_method_names": ["Structure.nrModels", "Structure.getModel", "Chain.getAtomGroups", "Group.getAltLocs", "Group.getAtoms", "Group.getPDBName"], "method_name": "StructureTools.cleanUpAltLocs", "method_implementation": "{\n    for (int i = 0; i < structure.nrModels(); i++) {\n        for (Chain chain : structure.getModel(i)) {\n            for (Group group : chain.getAtomGroups()) {\n                for (Group altLocGroup : group.getAltLocs()) {\n                    for (Atom groupAtom : group.getAtoms()) {\n                        // If this alt loc doesn't have this atom\n                        if (!altLocGroup.hasAtom(groupAtom.getName())) {\n                            // Fix for microheterogenity\n                            if (altLocGroup.getPDBName().equals(group.getPDBName())) {\n                                // If it's a Hydrogen then we check for it's Deuterated brother\n                                if (!hasDeuteratedEquiv(groupAtom, altLocGroup)) {\n                                    altLocGroup.addAtom(groupAtom);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Cleans up the structure's alternate location (altloc) groups. All alternate location groups should have all atoms (except\n * in the case of microheterogenity) or when a deuterium exists.\n * Ensure that all the alt loc groups have all the atoms in the main group.\n * @param structure The Structure to be cleaned up\n */\n", "repo_name": "biojava-master/", "id": 1059, "method_signature": "void cleanUpAltLocs(Structure)"}, "438": {"callee_method_names": [], "method_name": "StructureAlignmentOptimizer.runOptimization", "method_implementation": "{\n    superimposeBySet();\n    if (debug)\n        System.err.println(\"   initial rmsd \" + rmsd);\n    //      if (showAlig)\n    //         showCurrentAlignment(equLen, equSet, \"after initial superimposeBySet Len:\" +equLen + \" rmsd:\" +rmsd);\n    maxKeepStep = 4;\n    keepStep = 0;\n    optimize(maxi);\n}", "repo_id": "9", "comment": "/**\n * run the optimization\n *\n * @param maxi maximum nr. of iterations\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 438, "method_signature": "void runOptimization(int)"}, "3639": {"callee_method_names": [], "method_name": "CoxInfo.getImat", "method_implementation": "{\n    return imat;\n}", "repo_id": "9", "comment": "/**\n * @return the imat\n */\n", "repo_name": "biojava-master/", "id": 3639, "method_signature": "double[][] getImat()"}, "2196": {"callee_method_ids": [628, 489, 489], "callee_method_names": ["AtomCache.getStructure", "List<Chain>.size", "List<Chain>.size", "List<Chain>.get", "List<Chain>.get", "StructureAlignment.align", "AFPChain.getOptAln", "AFPChain.getOptAln"], "method_name": "TestAlignmentConsistency.testDuplicateIndices", "method_implementation": "{\n    String[] algorithmIDs = { CeMain.algorithmName, FatCatRigid.algorithmName };\n    AtomCache cache = new AtomCache();\n    // 3j47 is a bunch of a-helices, so there are many valid ways to align chains\n    // structurally between each other.\n    List<Chain> chains = cache.getStructure(\"3j47\").getChains();\n    for (String algorithmID : algorithmIDs) {\n        StructureAlignment algorithm = StructureAlignmentFactory.getAlgorithm(algorithmID);\n        System.out.println(\"Testing \" + algorithmID);\n        for (int c1 = 0; c1 < chains.size() - 1; c1++) {\n            for (int c2 = chains.size() - 1; c2 > c1; c2--) {\n                Atom[] ca1 = StructureTools.getAtomCAArray(chains.get(c1));\n                Atom[] ca2 = StructureTools.getAtomCAArray(chains.get(c2));\n                AFPChain afpChain_fc = algorithm.align(ca1, ca2);\n                assertEquals(1, afpChain_fc.getOptAln().length);\n                int[][] optAln = afpChain_fc.getOptAln()[0];\n                // two chains aligned\n                assertEquals(2, optAln.length);\n                //same number of aligned residues between the chains\n                assertEquals(optAln[0].length, optAln[1].length);\n                // no indices duplicated in the alignments\n                for (int[] optAlnSeq : optAln) {\n                    long count_unique = Arrays.stream(optAlnSeq).distinct().count();\n                    long count_all = optAlnSeq.length;\n                    assertEquals(count_unique, count_all);\n                }\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "// Check that indices of the aligned residues are unique\n", "repo_name": "biojava-master/", "id": 2196, "method_signature": "void testDuplicateIndices()"}, "3739": {"callee_method_names": [], "method_name": "WorkSheet.setCacheDoubleValues", "method_implementation": "{\n    cacheDoubleValues = value;\n}", "repo_id": "9", "comment": "/**\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 3739, "method_signature": "void setCacheDoubleValues(boolean)"}, "1176": {"callee_method_ids": [1772], "callee_method_names": ["String.length", "String.substring", "String.substring", "String.split", "PDBHeader.setExperimentalTechnique"], "method_name": "PDBFileParser.pdb_EXPDTA_Handler", "method_implementation": "{\n    String technique;\n    if (line.length() > 69)\n        technique = line.substring(10, 70).trim();\n    else\n        technique = line.substring(10).trim();\n    for (String singleTechnique : technique.split(\";\\\\s+\")) {\n        pdbHeader.setExperimentalTechnique(singleTechnique);\n    }\n}", "repo_id": "9", "comment": "/**\n *  Handler for\n *  EXPDTA Record Format\n * \t<pre>\n * \t COLUMNS       DATA TYPE      FIELD         DEFINITION\n * \t -------------------------------------------------------------------------------\n * \t 1 -  6       Record name    \"EXPDTA\"\n * \t 9 - 10       Continuation   continuation  Allows concatenation of multiple\n * \t records.\n * \t 11 - 70       SList          technique     The experimental technique(s) with\n * \t optional comment describing the\n * \t sample or experiment.\n *\n * \t allowed techniques are:\n * \t ELECTRON DIFFRACTION\n * \t FIBER DIFFRACTION\n * \t FLUORESCENCE TRANSFER\n * \t NEUTRON DIFFRACTION\n * \t NMR\n * \t THEORETICAL MODEL\n * \t X-RAY DIFFRACTION\n * \t</pre>\n */\n", "repo_name": "biojava-master/", "id": 1176, "method_signature": "void pdb_EXPDTA_Handler(String)"}, "2903": {"callee_method_names": [], "method_name": "AbstractSequence.setBioEnd", "method_implementation": "{\n    this.bioEnd = bioEnd;\n}", "repo_id": "9", "comment": "/**\n * @param bioEnd the bioEnd to set\n */\n", "repo_name": "biojava-master/", "id": 2903, "method_signature": "void setBioEnd(Integer)"}, "1270": {"callee_method_ids": [1413, 1411, 1416], "callee_method_names": ["PDBCrystallographicInfo.setSpaceGroup", "PDBCrystallographicInfo.setCrystalCell", "Structure.setCrystallographicInfo", "PDBCrystallographicInfo.setNcsOperators"], "method_name": "MmtfStructureReader.setXtalInfo", "method_implementation": "{\n    // Now set the xtalographic information\n    PDBCrystallographicInfo pci = new PDBCrystallographicInfo();\n    SpaceGroup spaceGroup = SpaceGroup.parseSpaceGroup(spaceGroupString);\n    pci.setSpaceGroup(spaceGroup);\n    if (unitCell.length > 0) {\n        CrystalCell cell = new CrystalCell(unitCell[0], unitCell[1], unitCell[2], unitCell[3], unitCell[4], unitCell[5]);\n        pci.setCrystalCell(cell);\n        structure.setCrystallographicInfo(pci);\n    }\n    pci.setNcsOperators(MmtfUtils.getNcsAsMatrix4d(ncsOperMatrixList));\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface#\n\t * setXtalInfo(java.lang.String, java.util.List)\n\t */\n", "repo_name": "biojava-master/", "id": 1270, "method_signature": "void setXtalInfo(String, float[], double[][])"}, "701": {"callee_method_names": ["FileWriter.append", "List<Integer>.size", "FileWriter.append", "FileWriter.append", "List<Integer>.get", "FileWriter.append", "List<Double>.get", "FileWriter.append", "List<Double>.get", "FileWriter.flush", "FileWriter.close"], "method_name": "MultipleMcOptimizer.saveHistory", "method_implementation": "{\n    FileWriter writer = new FileWriter(filePath);\n    writer.append(\"Step,Length,RMSD,Score\\n\");\n    for (int i = 0; i < lengthHistory.size(); i++) {\n        writer.append(String.valueOf(i * 100));\n        writer.append(\",\" + lengthHistory.get(i));\n        writer.append(\",\" + rmsdHistory.get(i));\n        writer.append(\",\" + scoreHistory.get(i) + \"\\n\");\n    }\n    writer.flush();\n    writer.close();\n}", "repo_id": "9", "comment": "/**\n * Save the evolution of the optimization process as a csv file.\n */\n", "repo_name": "biojava-master/", "id": 701, "method_signature": "void saveHistory(String)"}, "269": {"callee_method_names": [], "method_name": "ModificationLinkage.getPDBNameOfPotentialAtomsOnComponent2", "method_implementation": "{\n    return pdbNameOfPotentialAtomsOnComponent2;\n}", "repo_id": "9", "comment": "/**\n * @return a list of PDB names of potential atoms on the second component.\n */\n", "repo_name": "biojava-master/", "id": 269, "method_signature": "List<String> getPDBNameOfPotentialAtomsOnComponent2()"}, "2255": {"callee_method_names": ["Atom.setX", "Atom.setX", "Atom.setX", "Atom.setAltLoc", "Atom.setX", "List<Atom>.add", "List<Atom>.add", "List<Atom>.add", "List<Atom>.add", "Group.addAtom", "Group.addAtom", "Group.addAtom", "Group.addAtom", "Group.addAtom", "Group.addAtom", "Group.addAltLoc"], "method_name": "TestMmtfUtils.testGetAtomsForGroup", "method_implementation": "{\n    Group group = new AminoAcidImpl();\n    Group altLoc = new AminoAcidImpl();\n    Atom atomOne = new AtomImpl();\n    atomOne.setX(1.00);\n    Atom atomTwo = new AtomImpl();\n    atomTwo.setX(2.00);\n    Atom atomThree = new AtomImpl();\n    atomThree.setX(3.00);\n    atomThree.setAltLoc('B');\n    Atom atomFour = new AtomImpl();\n    atomFour.setX(4.00);\n    List<Atom> inputList = new ArrayList<>();\n    inputList.add(atomOne);\n    inputList.add(atomTwo);\n    inputList.add(atomFour);\n    inputList.add(atomThree);\n    group.addAtom(atomOne);\n    group.addAtom(atomTwo);\n    group.addAtom(atomFour);\n    altLoc.addAtom(atomOne);\n    altLoc.addAtom(atomTwo);\n    altLoc.addAtom(atomThree);\n    group.addAltLoc(altLoc);\n    List<Atom> atomList = MmtfUtils.getAtomsForGroup(group);\n    assertEquals(inputList, atomList);\n}", "repo_id": "9", "comment": "/**\n * Test getting the correct atoms from a group\n */\n", "repo_name": "biojava-master/", "id": 2255, "method_signature": "void testGetAtomsForGroup()"}, "697": {"callee_method_names": ["Random.nextInt", "Random.nextInt", "Random.nextInt", "Random.nextInt", "MultipleAlignment.getBlock", "MultipleAlignment.getBlock", "Block.getCoreLength", "Block.getAlignRes", "Block.getAlignRes", "Block.length", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "Block.getAlignRes", "Random.nextInt", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.length", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.length", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.length", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get"], "method_name": "MultipleMcOptimizer.shiftRow", "method_implementation": "{\n    // Select randomly the subunit\n    int str = rnd.nextInt(size);\n    // Select between moving right (0) or left (1)\n    int rl = rnd.nextInt(2);\n    // Select randomly the Block\n    int bk = rnd.nextInt(blockNr);\n    int res = rnd.nextInt(msa.getBlock(bk).length());\n    Block block = msa.getBlock(bk);\n    if (block.getCoreLength() <= Lmin)\n        return false;\n    // When the pivot residue is null try to add a residue from the freePool\n    if (block.getAlignRes().get(str).get(res) == null) {\n        // Residues not null at the right and left of the pivot null residue\n        int rightRes = res;\n        int leftRes = res;\n        // Find the boundary to the right abd left\n        while (block.getAlignRes().get(str).get(rightRes) == null && rightRes < block.length() - 1) {\n            rightRes++;\n        }\n        while (block.getAlignRes().get(str).get(leftRes) == null && leftRes > 0) {\n            leftRes--;\n        }\n        // If both are null return because the block is empty\n        if (block.getAlignRes().get(str).get(leftRes) == null && block.getAlignRes().get(str).get(rightRes) == null) {\n            return false;\n        } else if (block.getAlignRes().get(str).get(leftRes) == null) {\n            // Choose the sequentially previous residue of the known one\n            Integer residue = block.getAlignRes().get(str).get(rightRes) - 1;\n            if (freePool.get(str).contains(residue)) {\n                block.getAlignRes().get(str).set(res, residue);\n                freePool.get(str).remove(residue);\n            } else\n                return false;\n        } else if (block.getAlignRes().get(str).get(rightRes) == null) {\n            // Choose the sequentially next residue of the known one\n            Integer residue = block.getAlignRes().get(str).get(leftRes) + 1;\n            if (freePool.get(str).contains(residue)) {\n                block.getAlignRes().get(str).set(res, residue);\n                freePool.get(str).remove(residue);\n            } else\n                return false;\n        } else {\n            // If boundaries are consecutive no residue can be added\n            if (block.getAlignRes().get(str).get(rightRes) == block.getAlignRes().get(str).get(leftRes) + 1) {\n                return false;\n            } else {\n                // Choose randomly a residue in between left and right\n                Integer residue = rnd.nextInt(block.getAlignRes().get(str).get(rightRes) - block.getAlignRes().get(str).get(leftRes) - 1) + block.getAlignRes().get(str).get(leftRes) + 1;\n                if (freePool.get(str).contains(residue)) {\n                    block.getAlignRes().get(str).set(res, residue);\n                    freePool.get(str).remove(residue);\n                }\n            }\n        }\n        return true;\n    }\n    // When residue different than null shift the whole block\n    switch(rl) {\n        case // Move to the right\n        0:\n            // Find the nearest boundary to the left of the pivot\n            int leftBoundary = res - 1;\n            int leftPrevRes = res;\n            while (true) {\n                if (leftBoundary < 0)\n                    break;\n                else {\n                    if (block.getAlignRes().get(str).get(leftBoundary) == null)\n                        // Break if there is a gap (this is the boundary)\n                        break;\n                    else if (block.getAlignRes().get(str).get(leftPrevRes) > block.getAlignRes().get(str).get(leftBoundary) + 1)\n                        // Break if there is a discontinuity\n                        break;\n                }\n                leftPrevRes = leftBoundary;\n                leftBoundary--;\n            }\n            leftBoundary++;\n            // Find the nearest boundary to the right of the pivot\n            int rightBoundary = res + 1;\n            int rightPrevRes = res;\n            while (true) {\n                if (rightBoundary == block.length())\n                    break;\n                else {\n                    if (block.getAlignRes().get(str).get(rightBoundary) == null)\n                        // Break if there is a gap\n                        break;\n                    else if (block.getAlignRes().get(str).get(rightPrevRes) + 1 < block.getAlignRes().get(str).get(rightBoundary))\n                        // Discontinuity\n                        break;\n                }\n                rightPrevRes = rightBoundary;\n                rightBoundary++;\n            }\n            rightBoundary--;\n            // Residues at the boundary\n            Integer resR0 = block.getAlignRes().get(str).get(rightBoundary);\n            Integer resL0 = block.getAlignRes().get(str).get(leftBoundary);\n            // Remove the residue at the right of the block\n            block.getAlignRes().get(str).remove(rightBoundary);\n            if (resR0 != null)\n                freePool.get(str).add(resR0);\n            // Add the residue at the left of the block\n            if (resL0 != null)\n                resL0 -= 1;\n            if (freePool.get(str).contains(resL0)) {\n                block.getAlignRes().get(str).add(leftBoundary, resL0);\n                freePool.get(str).remove(resL0);\n            } else\n                block.getAlignRes().get(str).add(leftBoundary, null);\n            break;\n        case // Move to the left\n        1:\n            // Find the nearest boundary to the left of the pivot\n            int leftBoundary1 = res - 1;\n            int leftPrevRes1 = res;\n            while (true) {\n                if (leftBoundary1 < 0)\n                    break;\n                else {\n                    if (block.getAlignRes().get(str).get(leftBoundary1) == null)\n                        // Break if there is a gap (this is the boundary)\n                        break;\n                    else if (block.getAlignRes().get(str).get(leftPrevRes1) > block.getAlignRes().get(str).get(leftBoundary1) + 1)\n                        // Break if there is a discontinuity\n                        break;\n                }\n                leftPrevRes1 = leftBoundary1;\n                leftBoundary1--;\n            }\n            leftBoundary1++;\n            // Find the nearest boundary to the right of the pivot\n            int rightBoundary1 = res + 1;\n            int rightPrevRes1 = res;\n            while (true) {\n                if (rightBoundary1 == block.length())\n                    break;\n                else {\n                    if (block.getAlignRes().get(str).get(rightBoundary1) == null)\n                        // Break if there is a gap\n                        break;\n                    else if (block.getAlignRes().get(str).get(rightPrevRes1) + 1 < block.getAlignRes().get(str).get(rightBoundary1))\n                        // Discontinuity\n                        break;\n                }\n                rightPrevRes1 = rightBoundary1;\n                rightBoundary1++;\n            }\n            rightBoundary1--;\n            // Residues at the boundary\n            Integer resR1 = block.getAlignRes().get(str).get(rightBoundary1);\n            Integer resL1 = block.getAlignRes().get(str).get(leftBoundary1);\n            // Add the residue at the right of the block\n            if (resR1 != null)\n                resR1 += 1;\n            if (freePool.get(str).contains(resR1)) {\n                if (rightBoundary1 == block.length() - 1) {\n                    block.getAlignRes().get(str).add(resR1);\n                } else\n                    block.getAlignRes().get(str).add(rightBoundary1 + 1, resR1);\n                freePool.get(str).remove(resR1);\n            } else\n                block.getAlignRes().get(str).add(rightBoundary1 + 1, null);\n            // Remove the residue at the left of the block\n            block.getAlignRes().get(str).remove(leftBoundary1);\n            if (resL1 != null)\n                freePool.get(str).add(resL1);\n            break;\n    }\n    checkGaps();\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Move all the block residues of one subunit one position to the left or to\n * the right and move the corresponding boundary residues from the freePool\n * to the block.\n * <p>\n * The boundaries are determined by any irregularity (either a null or a\n * discontinuity in the alignment).\n *\n * @return true if the alignment has been changed, false otherwise.\n */\n", "repo_name": "biojava-master/", "id": 697, "method_signature": "boolean shiftRow()"}, "3211": {"callee_method_names": [], "method_name": "SoftHashMapTest.small", "method_implementation": "{\n    return new TestObject(name, 100);\n}", "repo_id": "9", "comment": "/*\n        *Create an object occupying negligible memory\n        */\n", "repo_name": "biojava-master/", "id": 3211, "method_signature": "TestObject small(String)"}, "2941": {"callee_method_names": [], "method_name": "AbstractSequence.getSequenceAsString", "method_implementation": "{\n    return SequenceMixin.toString(this);\n}", "repo_id": "9", "comment": "/**\n * Default case is to assume strand is positive because only CDSSequence can be either positive or negative Strand.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2941, "method_signature": "String getSequenceAsString()"}, "613": {"callee_method_names": [], "method_name": "URLConnectionTools.openURLConnection", "method_implementation": "{\n    return openURLConnection(url, DEFAULT_CONNECTION_TIMEOUT);\n}", "repo_id": "9", "comment": "/**\n * Open HttpURLConnection. Recommended way to open\n * HttpURLConnections, since this take care of setting timeouts\n * properly for java 1.4 and 1.5\n * uses the DEFAULT_CONNECTION_TIMEOUT (= 15 seconds)\n * @param url a URL to open a http connection to\n * @return HttpURLConnect the opened connection\n * @throws IOException an error in opening the URL\n */\n", "repo_name": "biojava-master/", "id": 613, "method_signature": "URLConnection openURLConnection(URL)"}, "3377": {"callee_method_ids": [3339], "callee_method_names": ["Graphics2D.setColor", "Graphics2D.getClipBounds", "CoordManager.getSeqPos", "Graphics2D.getComposite", "Graphics2D.setComposite", "Graphics2D.setColor", "List<AlignedPosition>.size", "CoordManager.getPanelPos", "List<AlignedPosition>.get", "AlignedPosition.getPos", "Graphics2D.drawString", "AlignedPosition.getPos", "Graphics2D.drawString", "Character[].toString", "Graphics2D.setComposite"], "method_name": "SequenceScalePanel.drawSequence", "method_implementation": "{\n    //g2D.drawString(panelName,10,10);\n    g2D.setColor(SEQUENCE_COLOR);\n    int aminosize = Math.round(1 * scale);\n    if (aminosize < 1)\n        aminosize = 1;\n    // only draw within the ranges of the Clip\n    Rectangle drawHere = g2D.getClipBounds();\n    int startpos = coordManager.getSeqPos(drawHere.x);\n    //int endpos   = coordManager.getSeqPos(drawHere.x+drawHere.width-2);\n    Composite oldComp = g2D.getComposite();\n    g2D.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.8f));\n    //logger.info(\"paint l \" + l + \" length \" + length );\n    if (startpos < 0)\n        startpos = 999;\n    if (scale > SEQUENCE_SHOW) {\n        g2D.setColor(Color.black);\n        //g2D.setColor(SCALE_COLOR);\n        int i = startpos;\n        // display the actual sequence!;\n        for (int gap = startpos; gap < apos.size(); gap++) {\n            int xpos = coordManager.getPanelPos(gap);\n            AlignedPosition m = apos.get(gap);\n            if (m.getPos(position) == -1) {\n                // a gap position\n                g2D.drawString(\"-\", xpos + 1, y + 2 + DEFAULT_Y_STEP);\n                continue;\n            }\n            i = m.getPos(position);\n            // TODO:\n            // color amino acids by hydrophobicity\n            g2D.drawString(seqArr[i].toString(), xpos + 1, y + 2 + DEFAULT_Y_STEP);\n        }\n        //\t\t\tin full sequence mode we need abit more space to look nice\n        y += 2;\n    }\n    g2D.setComposite(oldComp);\n    y += DEFAULT_Y_STEP + 2;\n    return y;\n}", "repo_id": "9", "comment": "/**\n * draw the Amino acid sequence\n *\n * @param g2D\n * @param y .. height of line to draw the sequence onto\n * @return the new y value\n */\n", "repo_name": "biojava-master/", "id": 3377, "method_signature": "int drawSequence(Graphics2D, int)"}, "2735": {"callee_method_names": [], "method_name": "EmblRecord.getEmblId", "method_implementation": "{\n    return emblId;\n}", "repo_id": "9", "comment": "/**\n * The ID (IDentification) line\n * The tokens represent:\n * 1. Primary accession number\n * 2. Sequence version number\n * 3. Topology: 'circular' or 'linear'\n * 4. Molecule type\n * 5. Data class\n * 6. Taxonomic division\n * 7. Sequence length\n *\n * @return EmblId\n */\n", "repo_name": "biojava-master/", "id": 2735, "method_signature": "EmblId getEmblId()"}, "3239": {"callee_method_ids": [641, 1327], "callee_method_names": ["String.toLowerCase", "AtomCache.setFiletype", "AtomCache.getFileParsingParams", "FileParsingParameters.setAtomCaThreshold", "FileParsingParameters.setParseBioAssembly"], "method_name": "DemoShowLargeAssembly.readStructure", "method_implementation": "{\n    // pre-computed files use lower case PDB IDs\n    pdbId = pdbId.toLowerCase();\n    // we just need this to track where to store PDB files\n    // this checks the PDB_DIR property (and uses a tmp location if not set)\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    FileParsingParameters p = cache.getFileParsingParams();\n    // some bio assemblies are large, we want an all atom representation and avoid\n    // switching to a Calpha-only representation for large molecules\n    // note, this requires several GB of memory for some of the largest assemblies, such a 1MX4\n    p.setAtomCaThreshold(Integer.MAX_VALUE);\n    // parse remark 350\n    p.setParseBioAssembly(true);\n    // download missing files\n    Structure structure = null;\n    try {\n        structure = StructureIO.getBiologicalAssembly(pdbId, bioAssemblyId);\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * Load a specific biological assembly for a PDB entry\n *\n * @param pdbId .. the PDB ID\n * @param bioAssemblyId .. the first assembly has the bioAssemblyId 1\n * @return a Structure object or null if something went wrong.\n */\n", "repo_name": "biojava-master/", "id": 3239, "method_signature": "Structure readStructure(String, int)"}, "1491": {"callee_method_names": ["Point3d[].distanceSquared"], "method_name": "CalcPoint.TMScore", "method_implementation": "{\n    if (x.length != y.length) {\n        throw new IllegalArgumentException(\"Point arrays are not of the same length.\");\n    }\n    double d0 = 1.24 * Math.cbrt(x.length - 15.0) - 1.8;\n    double d0Sq = d0 * d0;\n    double sum = 0;\n    for (int i = 0; i < x.length; i++) {\n        sum += 1.0 / (1.0 + x[i].distanceSquared(y[i]) / d0Sq);\n    }\n    return sum / lengthNative;\n}", "repo_id": "9", "comment": "/**\n * Returns the TM-Score for two superimposed sets of coordinates Yang Zhang\n * and Jeffrey Skolnick, PROTEINS: Structure, Function, and Bioinformatics\n * 57:702\u2013710 (2004)\n *\n * @param x\n *            coordinate set 1\n * @param y\n *            coordinate set 2\n * @param lengthNative\n *            total length of native sequence\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1491, "method_signature": "double TMScore(Point3d[], Point3d[], int)"}, "1559": {"callee_method_names": [], "method_name": "ScopDomain.getPdbId", "method_implementation": "{\n    return pdbId;\n}", "repo_id": "9", "comment": "/**\n * Gets the PDB identifier for this protein structure.\n * Before BioJava 6.0.0, this method used to return a {@link String}.\n *\n * @return the {@link PdbId} PDB identifier\n * @see #setPdbId(PdbId)\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 1559, "method_signature": "PdbId getPdbId()"}, "1920": {"callee_method_ids": [1876, 1876], "callee_method_names": ["Helix.getAngle", "Helix.getContacts", "Helix.getAngle", "Helix.getContacts"], "method_name": "HelixLayers.getByLargestContactsNotLowestAngle", "method_implementation": "{\n    double contacts = 0;\n    Helix lowest = getByLowestAngle();\n    // TODO why are there helices with almost identical helix parameters??\n    double angle = lowest.getAngle() + 0.05;\n    Helix largest = null;\n    for (Helix helix : helices) {\n        if (helix == lowest) {\n            continue;\n        }\n        if (helix.getContacts() > contacts && helix.getAngle() > angle) {\n            contacts = helix.getContacts();\n            largest = helix;\n        }\n    }\n    if (largest == null) {\n        return lowest;\n    }\n    return largest;\n}", "repo_id": "9", "comment": "/*\n\t * Returns Helix that has the largest number of contacts, besides\n\t * the Helix with the lowest twist angle\n\t */\n", "repo_name": "biojava-master/", "id": 1920, "method_signature": "Helix getByLargestContactsNotLowestAngle()"}, "2802": {"callee_method_names": ["FileInputStream.close"], "method_name": "GenbankReaderHelper.readGenbankRNASequence", "method_implementation": "{\n    FileInputStream inStream = new FileInputStream(file);\n    LinkedHashMap<String, RNASequence> rnaSequences = readGenbankRNASequence(inStream);\n    inStream.close();\n    return rnaSequences;\n}", "repo_id": "9", "comment": "/**\n * @param file\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2802, "method_signature": "LinkedHashMap<String,RNASequence> readGenbankRNASequence(File)"}, "3136": {"callee_method_names": ["URL.openConnection", "HttpURLConnection.setRequestProperty", "HttpURLConnection.setInstanceFollowRedirects", "HttpURLConnection.setConnectTimeout", "HttpURLConnection.setReadTimeout", "HttpURLConnection.getResponseCode", "HttpURLConnection.getHeaderField", "String.equals", "URL.toString", "HttpURLConnection.getHeaderField", "HttpURLConnection.disconnect", "URL.openConnection", "HttpURLConnection.setRequestProperty", "HttpURLConnection.addRequestProperty", "HttpURLConnection.setInstanceFollowRedirects", "HttpURLConnection.setConnectTimeout", "HttpURLConnection.setReadTimeout", "HttpURLConnection.connect", "HttpURLConnection.getResponseCode", "Logger.info", "HttpURLConnection.connect"], "method_name": "UniprotProxySequenceReader.openURLConnection", "method_implementation": "{\n    // This method should be moved to a utility class in BioJava 5.0\n    final int timeout = 5000;\n    final String useragent = \"BioJava\";\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestProperty(\"User-Agent\", useragent);\n    conn.setInstanceFollowRedirects(true);\n    conn.setConnectTimeout(timeout);\n    conn.setReadTimeout(timeout);\n    int status = conn.getResponseCode();\n    while (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER) {\n        // Redirect!\n        String newUrl = conn.getHeaderField(\"Location\");\n        if (newUrl.equals(url.toString())) {\n            throw new IOException(\"Cyclic redirect detected at \" + newUrl);\n        }\n        // Preserve cookies\n        String cookies = conn.getHeaderField(\"Set-Cookie\");\n        // open the new connection again\n        url = new URL(newUrl);\n        conn.disconnect();\n        conn = (HttpURLConnection) url.openConnection();\n        if (cookies != null) {\n            conn.setRequestProperty(\"Cookie\", cookies);\n        }\n        conn.addRequestProperty(\"User-Agent\", useragent);\n        conn.setInstanceFollowRedirects(true);\n        conn.setConnectTimeout(timeout);\n        conn.setReadTimeout(timeout);\n        conn.connect();\n        status = conn.getResponseCode();\n        logger.info(\"Redirecting from {} to {}\", url, newUrl);\n    }\n    conn.connect();\n    return conn;\n}", "repo_id": "9", "comment": "/**\n * Open a URL connection.\n *\n * Follows redirects.\n * @param url\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 3136, "method_signature": "HttpURLConnection openURLConnection(URL)"}, "2876": {"callee_method_names": [], "method_name": "ABITrace.getSubArray", "method_implementation": "{\n    for (int x = 0; x <= b.length - 1; x++) {\n        b[x] = traceData[traceDataOffset + x];\n    }\n}", "repo_id": "9", "comment": "/**\n * A utility method which fills array b with data from the trace starting at traceDataOffset.\n *\n * @param b - trace byte array\n * @param traceDataOffset - starting point\n */\n", "repo_name": "biojava-master/", "id": 2876, "method_signature": "void getSubArray(byte[], int)"}, "3669": {"callee_method_names": [], "method_name": "SurvivalInfo.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * @return the id\n */\n", "repo_name": "biojava-master/", "id": 3669, "method_signature": "String getId()"}, "3095": {"callee_method_names": [], "method_name": "Qualifier.getValue", "method_implementation": "{\n    return value;\n}", "repo_id": "9", "comment": "/**\n * @return the value\n */\n", "repo_name": "biojava-master/", "id": 3095, "method_signature": "String getValue()"}, "2772": {"callee_method_names": [], "method_name": "FastaWriterHelper.writeSequence", "method_implementation": "{\n    writeSequences(outputStream, singleSeqToCollection(sequence));\n}", "repo_id": "9", "comment": "/**\n * Write a sequence to OutputStream\n * @param outputStream\n * @param sequence\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2772, "method_signature": "void writeSequence(OutputStream, Sequence)"}, "3730": {"callee_method_names": ["LinkedHashMap.keySet", "ChangeValue.change"], "method_name": "WorkSheet.applyColumnFilter", "method_implementation": "{\n    for (String row : rowLookup.keySet()) {\n        String oldValue = this.getCell(row, column);\n        String newValue = changeValue.change(oldValue);\n        this.addCell(row, column, newValue);\n    }\n}", "repo_id": "9", "comment": "/**\n * Apply filter to a column to change values from say numberic to nominal\n * based on some range\n *\n * @param column\n * @param changeValue\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3730, "method_signature": "void applyColumnFilter(String, ChangeValue)"}, "1060": {"callee_method_names": ["Atom.getElement", "Group.hasAtom", "Atom.getName"], "method_name": "StructureTools.hasNonDeuteratedEquiv", "method_implementation": "{\n    // If it's deuterated and has a non-deuterated brother\n    return atom.getElement() == Element.D && currentGroup.hasAtom(replaceFirstChar(atom.getName(), 'D', 'H'));\n}", "repo_id": "9", "comment": "/**\n * Check to see if an Deuterated atom has a non deuterated brother in the group.\n * @param atom the input atom that is putatively deuterium\n * @param currentGroup the group the atom is in\n * @return true if the atom is deuterated and it's hydrogen equive exists.\n */\n", "repo_name": "biojava-master/", "id": 1060, "method_signature": "boolean hasNonDeuteratedEquiv(Atom, Group)"}, "303": {"callee_method_ids": [266, 267, 268, 269], "callee_method_names": ["ModificationCondition.getLinkages", "List<ModificationLinkage>.size", "List<ModificationLinkage>.get", "ModificationLinkage.getComponent1", "ModificationLinkage.getComponent2", "Map<Component,Set<Group>>.get", "Map<Component,Set<Group>>.get", "ModificationLinkage.getPDBNameOfPotentialAtomsOnComponent1", "ModificationLinkage.getPDBNameOfPotentialAtomsOnComponent2", "List<Group>.contains", "List<Group>.contains", "List<Atom[]>.add", "List<Atom[]>.isEmpty", "List<List<Atom[]>>.add"], "method_name": "ProteinModificationIdentifier.getMatchedAtomsOfLinkages", "method_implementation": "{\n    List<ModificationLinkage> linkages = condition.getLinkages();\n    int nLink = linkages.size();\n    List<List<Atom[]>> matchedAtomsOfLinkages = new ArrayList<List<Atom[]>>(nLink);\n    for (int iLink = 0; iLink < nLink; iLink++) {\n        ModificationLinkage linkage = linkages.get(iLink);\n        Component comp1 = linkage.getComponent1();\n        Component comp2 = linkage.getComponent2();\n        //\t\t\tboolean isAA1 = comp1.;\n        //\t\t\tboolean isAA2 = comp2.getType()==true;\n        Set<Group> groups1 = mapCompGroups.get(comp1);\n        Set<Group> groups2 = mapCompGroups.get(comp2);\n        List<Atom[]> list = new ArrayList<Atom[]>();\n        List<String> potentialNamesOfAtomOnGroup1 = linkage.getPDBNameOfPotentialAtomsOnComponent1();\n        for (String name : potentialNamesOfAtomOnGroup1) {\n            if (\"*\".equals(name)) {\n                // wildcard\n                // search all atoms\n                potentialNamesOfAtomOnGroup1 = null;\n                break;\n            }\n        }\n        List<String> potentialNamesOfAtomOnGroup2 = linkage.getPDBNameOfPotentialAtomsOnComponent2();\n        for (String name : potentialNamesOfAtomOnGroup2) {\n            if (\"*\".equals(name)) {\n                // wildcard\n                // search all atoms\n                potentialNamesOfAtomOnGroup2 = null;\n                break;\n            }\n        }\n        for (Group g1 : groups1) {\n            for (Group g2 : groups2) {\n                if (g1.equals(g2)) {\n                    continue;\n                }\n                // only for wildcard match of two residues\n                boolean ignoreNCLinkage = potentialNamesOfAtomOnGroup1 == null && potentialNamesOfAtomOnGroup2 == null && residues.contains(g1) && residues.contains(g2);\n                Atom[] atoms = StructureUtil.findNearestAtomLinkage(g1, g2, potentialNamesOfAtomOnGroup1, potentialNamesOfAtomOnGroup2, ignoreNCLinkage, bondLengthTolerance);\n                if (atoms != null) {\n                    list.add(atoms);\n                }\n            }\n        }\n        if (list.isEmpty()) {\n            // broken linkage\n            break;\n        }\n        matchedAtomsOfLinkages.add(list);\n    }\n    return matchedAtomsOfLinkages;\n}", "repo_id": "9", "comment": "/**\n * Get matched atoms for all linkages.\n */\n", "repo_name": "biojava-master/", "id": 303, "method_signature": "List<List<Atom[]>> getMatchedAtomsOfLinkages(ModificationCondition, Map)"}, "2606": {"callee_method_names": ["Object.getClass", "Object.hashCode"], "method_name": "Hashcoder.hash", "method_implementation": "{\n    int result = seed;\n    //If it was null then this is the result 0\n    if (o == null) {\n        result = hash(result, 0);\n    } else //If it wasn't an array then calculate the hashcode\n    if (!o.getClass().isArray()) {\n        result = hash(result, o.hashCode());\n    } else //Otherwise loop &\n    {\n        int length = Array.getLength(o);\n        for (int i = 0; i < length; i++) {\n            Object item = Array.get(o, i);\n            // recursive call!\n            result = hash(result, item);\n        }\n    }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * <code>o</code> is a possibly-null object field, and possibly an\n * array.\n *\n * If <code>o</code> is an array, then each element may be a primitive\n * or a possibly-null object.\n */\n", "repo_name": "biojava-master/", "id": 2606, "method_signature": "int hash(int, Object)"}, "352": {"callee_method_names": ["Atom.getX", "Atom.getY", "Atom.getZ", "Atom.setCoords"], "method_name": "Calc.unitVector", "method_implementation": "{\n    double amount = amount(a);\n    double[] coords = new double[3];\n    coords[0] = a.getX() / amount;\n    coords[1] = a.getY() / amount;\n    coords[2] = a.getZ() / amount;\n    a.setCoords(coords);\n    return a;\n}", "repo_id": "9", "comment": "/**\n * Returns the unit vector of vector a .\n *\n * @param a\n *            an Atom object\n * @return an Atom object\n */\n", "repo_name": "biojava-master/", "id": 352, "method_signature": "Atom unitVector(Atom)"}, "2433": {"callee_method_names": ["FeatureI.location", "FeatureI.location"], "method_name": "FeatureList.hasGaps", "method_implementation": "{\n    Location last = null;\n    for (FeatureI f : this) {\n        if (last != null && gapLength <= f.location().distance(last)) {\n            return true;\n        } else {\n            last = f.location();\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Check size of gaps between successive features in list. The features in\n * the list are assumed to be appropriately ordered.\n *\n * @param gapLength The minimum gap length to consider. Use a gapLength\n * of 0 to check if features are contiguous.\n * @return True if list has any gaps equal to or greater than gapLength.\n */\n", "repo_name": "biojava-master/", "id": 2433, "method_signature": "boolean hasGaps(int)"}, "2934": {"callee_method_names": [], "method_name": "AbstractSequence.getDatabaseReferences", "method_implementation": "{\n    return databaseReferences;\n}", "repo_id": "9", "comment": "/**\n * @return the databaseReferences\n */\n", "repo_name": "biojava-master/", "id": 2934, "method_signature": "DatabaseReferenceInterface getDatabaseReferences()"}, "2487": {"callee_method_names": ["GeneChromosomePosition.getOrientation", "GeneChromosomePosition.getExonStarts", "GeneChromosomePosition.getExonEnds", "GeneChromosomePosition.getCdsStart", "GeneChromosomePosition.getCdsEnd", "GeneChromosomePosition.getExonStarts", "GeneChromosomePosition.getExonEnds", "GeneChromosomePosition.getCdsStart", "GeneChromosomePosition.getCdsEnd"], "method_name": "ChromosomeMappingTools.getCDSPosForChromosomeCoordinate", "method_implementation": "{\n    if (chromosomePosition.getOrientation() == '+')\n        return getCDSPosForward(coordinate, chromosomePosition.getExonStarts(), chromosomePosition.getExonEnds(), chromosomePosition.getCdsStart(), chromosomePosition.getCdsEnd());\n    return getCDSPosReverse(coordinate, chromosomePosition.getExonStarts(), chromosomePosition.getExonEnds(), chromosomePosition.getCdsStart(), chromosomePosition.getCdsEnd());\n}", "repo_id": "9", "comment": "/**\n * I have a genomic coordinate, where is it on the mRNA\n *\n * @param coordinate\n * @param chromosomePosition\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2487, "method_signature": "int getCDSPosForChromosomeCoordinate(int, GeneChromosomePosition)"}, "810": {"callee_method_names": ["DecimalFormat.setMaximumIntegerDigits", "DecimalFormat.setMinimumFractionDigits", "DecimalFormat.setMaximumFractionDigits", "StringBuffer.append", "DecimalFormat.format", "DecimalFormat.format", "StringBuffer.toString"], "method_name": "AlternativeAlignment.toString", "method_implementation": "{\n    DecimalFormat d2 = new DecimalFormat();\n    // the result can be localized. To change this and enforce UK local do...\n    //(DecimalFormat)NumberFormat.getInstance(java.util.Locale.UK);\n    d2.setMaximumIntegerDigits(3);\n    d2.setMinimumFractionDigits(2);\n    d2.setMaximumFractionDigits(2);\n    StringBuffer s = new StringBuffer();\n    s.append(\"#\" + getAltAligNumber() + \" cluster:\" + cluster + \" eqr:\" + getEqr() + \" rmsd:\" + d2.format(getRmsd()) + \" %id:\" + getPercId() + \" gaps:\" + getGaps() + \" score:\" + d2.format(score));\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * print the idx positions of this alignment\n *\n * @return a String representation\n */\n", "repo_name": "biojava-master/", "id": 810, "method_signature": "String toString()"}, "3358": {"callee_method_names": ["NavigableMap<Double, Color>.remove"], "method_name": "GradientMapper.remove", "method_implementation": "{\n    if (((Double) position).isInfinite()) {\n        throw new UnsupportedOperationException(\"Cannot remove infinite endpoints\");\n    }\n    return mapping.remove(position);\n}", "repo_id": "9", "comment": "/**\n * @param position\n * @return\n * @see java.util.Map#remove(java.lang.Object)\n */\n", "repo_name": "biojava-master/", "id": 3358, "method_signature": "Color remove(Object)"}, "1791": {"callee_method_names": [], "method_name": "EcodDomain.setPdbId", "method_implementation": "{\n    this.pdbId = pdbId;\n}", "repo_id": "9", "comment": "/**\n * @param pdbId\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 1791, "method_signature": "void setPdbId(PdbId)"}, "1294": {"callee_method_names": ["Map<Integer,Group>.clear", "Structure.getChains", "Chain.getAtomGroups", "StringBuilder.length", "StringBuilder.append", "Map<Integer, Integer>.keySet", "Map<Integer, Integer>.get", "Map<Integer,Group>.put", "List<Group>.get", "StringBuilder.toString", "Logger.error", "Element.getMessage"], "method_name": "StructureSequenceMatcher.getProteinSequenceForStructure", "method_implementation": "{\n    if (groupIndexPosition != null) {\n        groupIndexPosition.clear();\n    }\n    StringBuilder seqStr = new StringBuilder();\n    for (Chain chain : struct.getChains()) {\n        List<Group> groups = chain.getAtomGroups();\n        Map<Integer, Integer> chainIndexPosition = new HashMap<Integer, Integer>();\n        int prevLen = seqStr.length();\n        // get the sequence for this chain\n        String chainSeq = SeqRes2AtomAligner.getFullAtomSequence(groups, chainIndexPosition, false);\n        seqStr.append(chainSeq);\n        // fix up the position to include previous chains, and map the value back to a Group\n        for (Integer seqIndex : chainIndexPosition.keySet()) {\n            Integer groupIndex = chainIndexPosition.get(seqIndex);\n            groupIndexPosition.put(prevLen + seqIndex, groups.get(groupIndex));\n        }\n    }\n    ProteinSequence s = null;\n    try {\n        s = new ProteinSequence(seqStr.toString());\n    } catch (CompoundNotFoundException e) {\n        // I believe this can't happen, please correct this if I'm wrong - JD 2014-10-24\n        // we can log an error if it does, it would mean there's a bad bug somewhere\n        logger.error(\"Could not create protein sequence, unknown compounds in string: {}\", e.getMessage());\n    }\n    return s;\n}", "repo_id": "9", "comment": "/**\n * Generates a ProteinSequence corresponding to the sequence of struct,\n * and maintains a mapping from the sequence back to the original groups.\n *\n * Chains are appended to one another. 'X' is used for heteroatoms.\n *\n * @param struct Input structure\n * @param groupIndexPosition An empty map, which will be populated with\n *  (residue index in returned ProteinSequence) -> (Group within struct)\n * @return A ProteinSequence with the full sequence of struct. Chains are\n *  concatenated in the same order as the input structures\n *\n * @see {@link SeqRes2AtomAligner#getFullAtomSequence(List, Map)}, which\n * \tdoes the heavy lifting.\n */\n", "repo_name": "biojava-master/", "id": 1294, "method_signature": "ProteinSequence getProteinSequenceForStructure(Structure, Map)"}, "3716": {"callee_method_names": ["double[][].equals"], "method_name": "WorkSheet.setMetaDataRowsAfterRow", "method_implementation": "{\n    ArrayList<String> rows = this.getRows();\n    boolean metarow = false;\n    for (String r : rows) {\n        if (r.equals(row) && !metarow) {\n            metarow = true;\n        }\n        if (metarow) {\n            this.markMetaDataRow(r);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @param row\n */\n", "repo_name": "biojava-master/", "id": 3716, "method_signature": "void setMetaDataRowsAfterRow(String)"}, "2322": {"callee_method_names": ["List<Subunit>.size", "List<Subunit>.size", "List<Subunit>.get"], "method_name": "TestSubunitExtractor.testCollagen", "method_implementation": "{\n    Structure s = StructureIO.getStructure(\"1A3I\");\n    List<Subunit> subunits = SubunitExtractor.extractSubunits(s, 5, 0.75, 20);\n    // We expect all 3 subunits to be returned\n    assertEquals(subunits.size(), 3);\n    subunits = SubunitExtractor.extractSubunits(s, 8, 0.75, 9);\n    // Now we expect only the long Subunit to be returned\n    assertEquals(subunits.size(), 1);\n    assertEquals(subunits.get(0).size(), 9);\n}", "repo_id": "9", "comment": "/**\n * Some collagen structures have very short Chains, so the minimum sequence\n * length is adjusted: 1A3I.\n *\n * @see SubunitClustererParameters#getMinimumSequenceLengthFraction()\n */\n", "repo_name": "biojava-master/", "id": 2322, "method_signature": "void testCollagen()"}, "2662": {"callee_method_names": [], "method_name": "Builder.waitForStartCodon", "method_implementation": "{\n    this.waitForStartCodon = waitForStartCodon;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * If set, then translation will not start until a start codon is\n * encountered\n */\n", "repo_name": "biojava-master/", "id": 2662, "method_signature": "Builder waitForStartCodon(boolean)"}, "332": {"callee_method_names": [], "method_name": "OntoTools.getIntegerOntology", "method_implementation": "{\n    return CORE_INTEGER;\n}", "repo_id": "9", "comment": "/**\n * Get the Ontology that defines integers.\n *\n * <p>This contains a term for each and every integer. I haven't decided yet\n * if it contains terms for arithmatic.</p>\n *\n * @return the integer Ontology\n */\n", "repo_name": "biojava-master/", "id": 332, "method_signature": "IntegerOntology getIntegerOntology()"}, "1894": {"callee_method_names": ["ArrayList.size", "String.length"], "method_name": "Stoichiometry.setStrategy", "method_implementation": "{\n    if (strategy == StringOverflowStrategy.CUSTOM) {\n        throw new IllegalArgumentException(\"Set this strategy by providing a function of the type Function<List<SubunitCluster>,String>.\");\n    }\n    if (this.strategy != strategy) {\n        this.strategy = strategy;\n        if (orderedClusters.size() > alphabet.length())\n            doResetAlphas();\n    }\n}", "repo_id": "9", "comment": "/**\n * Change string representation of a stoichiometry in case number of clusters exceeds number of letters in the alphabet.\n * This action may invalidate alphas already assigned to the clusters.\n * @param strategy\n *          {@link StringOverflowStrategy} used in this stoichiometry\n *          to construct human-readable representation in case number\n *          of clusters exceeds number of letters in the alphabet.\n */\n", "repo_name": "biojava-master/", "id": 1894, "method_signature": "void setStrategy(StringOverflowStrategy)"}, "3251": {"callee_method_names": ["String.equals", "AutoSuggestProvider.getSuggestion", "Vector<String>.size", "JList.setListData", "JList.setSelectedIndex", "JList.ensureIndexIsVisible", "JDialog.setVisible", "JDialog.setVisible"], "method_name": "SuggestionFetcher.doInBackground", "method_implementation": "{\n    try {\n        setFont(busy);\n        String userInput = getText().trim();\n        if (userInput == null || \"\".equals(userInput))\n            return \"\";\n        if (previousWord != null) {\n            if (userInput.equals(previousWord))\n                return \"\";\n        }\n        previousWord = userInput;\n        suggestions = autoSuggestProvider.getSuggestion(userInput);\n        setFont(regular);\n        if (suggestions.size() > 0) {\n            list.setListData(suggestions);\n            list.setSelectedIndex(0);\n            list.ensureIndexIsVisible(0);\n            dialog.setVisible(true);\n        } else {\n            dialog.setVisible(false);\n        }\n    } catch (Exception e) {\n        //e.printStackTrace();\n        // ignore...\n    }\n    return \"Done.\";\n}", "repo_id": "9", "comment": "/**\n * Standard run method used in threads\n * responsible for the actual search\n */\n", "repo_name": "biojava-master/", "id": 3251, "method_signature": "String doInBackground()"}, "1117": {"callee_method_names": [], "method_name": "SiftsChainEntry.getPdbEnd", "method_implementation": "{\n    return pdbEnd;\n}", "repo_id": "9", "comment": "/**\n * @return A residue number\n */\n", "repo_name": "biojava-master/", "id": 1117, "method_signature": "String getPdbEnd()"}, "531": {"callee_method_names": ["Atom[].clone"], "method_name": "AlignUtils.getFragmentFromIdxList", "method_implementation": "{\n    Atom[] subset = new Atom[idx.length];\n    for (int p = 0; p < idx.length; p++) {\n        int pos1 = idx[p];\n        subset[p] = (Atom) caall[pos1].clone();\n    }\n    return subset;\n}", "repo_id": "9", "comment": "/**\n * Get a subset of Atoms based by their positions\n *\n * @param caall\n * @param idx an array where each element is a position of all the Atoms to return\n * @return at Atom[] array\n */\n", "repo_name": "biojava-master/", "id": 531, "method_signature": "Atom[] getFragmentFromIdxList(Atom[], int[])"}, "134": {"callee_method_names": ["String.equals"], "method_name": "TestOutputStrings.test1buz1aliFlexible", "method_implementation": "{\n    String pdb1 = \"1buz\";\n    String chain1 = \"A\";\n    String pdb2 = \"1ali\";\n    String chain2 = \"A\";\n    String originalOutput = \"Align 1buzA.pdb 116 with 1aliA.pdb 446\" + newline + \"Twists 1 ini-len 64 ini-rmsd 3.12 opt-equ 88 opt-rmsd 3.34 chain-rmsd 5.32 Score 103.72 align-len 199 gaps 111 (55.78%)\" + newline + \"P-value 3.26e-01 Afp-num 15578 Identity 6.25% Similarity 25.89%\" + newline + \"Block  0 afp  1 score 23.14 rmsd  0.76 gap 0 (0.00%)\" + newline + \"Block  1 afp  7 score 100.08 rmsd  3.32 gap 17 (0.23%)\" + newline + \"\" + newline + \"                  .    :    .    :    .    :    .    :    .    :    .    :    .    :\" + newline + \"Chain 1:    5 DMNVKESVLCIRLTGELDH---------------------------------HTAETLKQKVTQSLEKDD\" + newline + \"              1 11111111111111                                    222222222222222222\" + newline + \"Chain 2:  246 VTEANQQKPLLGLFADGNMPVRWLGPKATYHGNIDKPAVTCTPNPQRNDSVPTLAQMTDKAIELLSKNEK\" + newline + \"\" + newline + \"                  .    :    .    :    .    :    .    :    .    :    .    :    .    :\" + newline + \"Chain 1:   42 IRHIVLNLEDLS------------FMDSSGLGVILGRYKQIK-QIGGEMVVCAISPAVKRLFDMSGLFKI\" + newline + \"              222222222222            222222222222222222 2222222222222              \" + newline + \"Chain 2:  316 GFFLQVEGASIDKQDHAANPCGQIGETVDLDEAVQRALEFAKKEGNTLVIVTADHAHASQIVAPDTKAPG\" + newline + \"\" + newline + \"                  .    :    .    :    .    :    .    :    .    :    .\" + newline + \"Chain 1:   99 I---------------------------------RFEQSE--------QQALLTLGVAS\" + newline + \"                                                22            222222 2222\" + newline + \"Chain 2:  386 LTQALNTKDGAVMVMSYGNSEEDSQENTGSQLRIAAYGPHAANVVGLTDQTDLFYTMKA\" + newline + \"\" + newline + \"Note: positions are from PDB; the numbers between alignments are block index\" + newline;\n    String result = MyTestHelper.compareAlignment(pdb1, chain1, pdb2, chain2, originalOutput, false);\n    if (!result.equals(\"\")) {\n        String msg = \"the created alignment images are not identical! \";\n        printMismatch(originalOutput, result);\n        printFirstMismatch(result, originalOutput);\n        Assert.fail(msg);\n    }\n}", "repo_id": "9", "comment": "// exact\n", "repo_name": "biojava-master/", "id": 134, "method_signature": "void test1buz1aliFlexible()"}, "1523": {"callee_method_names": [], "method_name": "JournalArticle.getAuthorList", "method_implementation": "{\n    return authorList;\n}", "repo_id": "9", "comment": "/**\n * Get the list of Authors of the JournalArticle\n *\n * @return the List of authors\n */\n", "repo_name": "biojava-master/", "id": 1523, "method_signature": "List<Author> getAuthorList()"}, "1160": {"callee_method_names": [], "method_name": "FileConvert.toMMCIF", "method_implementation": "{\n    return CifStructureConverter.toText(chain);\n}", "repo_id": "9", "comment": "/**\n * Convert a chain to its CIF representation.\n * @param chain data\n * @return a String representing this chain as CIF\n */\n", "repo_name": "biojava-master/", "id": 1160, "method_signature": "String toMMCIF(Chain)"}, "1093": {"callee_method_names": [], "method_name": "DownloadChemCompProvider.setChemCompPathUrlTemplate", "method_implementation": "{\n    DownloadChemCompProvider.chemCompPathUrlTemplate = chemCompPathUrlTemplate;\n}", "repo_id": "9", "comment": "/**\n * Set the path to append to the serverBaseUrl (settable in {@link #setServerBaseUrl(String)}).\n * The string can contain placeholders that will be expanded at runtime:\n * <li>\"{ccd_id}\" to be replaced by the chemical component identifier, in capitals</li>\n * <li>\"{ccd_id:beginIndex-endIndex}\" to be replaced by a substring of the chemical component identifier in capitals,\n * with indices following the same convention as {@link String#substring(int, int)} </li>\n * <li>\"{ccd_id:index}\" to be replaced by a substring of the chemical component identifier in capitals,\n * with index either a positive or negative integer to substring from left or right of the string respectively.</li>\n * If any of the indices are off-bounds, then the full chemical component identifier is replaced\n */\n", "repo_name": "biojava-master/", "id": 1093, "method_signature": "void setChemCompPathUrlTemplate(String)"}, "3536": {"callee_method_names": [], "method_name": "CoxCoefficient.getHazardRatioLoCI", "method_implementation": "{\n    return hazardRatioLoCI;\n}", "repo_id": "9", "comment": "/**\n * @return the hazardRatioLoCI\n */\n", "repo_name": "biojava-master/", "id": 3536, "method_signature": "double getHazardRatioLoCI()"}, "2889": {"callee_method_names": [], "method_name": "SequenceMixin.createIterator", "method_implementation": "{\n    return new SequenceIterator<C>(sequence);\n}", "repo_id": "9", "comment": "/**\n * Creates a simple sequence iterator which moves through a sequence going\n * from 1 to the length of the Sequence. Modification of the Sequence is not\n * allowed.\n */\n", "repo_name": "biojava-master/", "id": 2889, "method_signature": "Iterator<C> createIterator(Sequence)"}, "193": {"callee_method_names": [], "method_name": "ORonnModel.align", "method_implementation": "{\n    int dResidue, r;\n    float maxScore = -1000000;\n    float rho1 = 0;\n    int maxIdx = 0;\n    float rho0 = 0;\n    short[] dbAARow = model.dbAA[dIndex];\n    int numOfIterations = model.Length[dIndex] - ORonnModel.AA_ALPHABET;\n    for (dResidue = 0; dResidue <= numOfIterations; dResidue++) {\n        // go though the database sequence for maximised alignment\n        rho1 = 0.0f;\n        for (r = 0; r < ORonnModel.AA_ALPHABET; r++) {\n            // go through the query sequence for one alignment\n            rho1 += RonnConstraint.Blosum62[seqAA[sResidue + r]][dbAARow[dResidue + r]];\n        }\n        if (rho1 > maxScore) {\n            maxScore = rho1;\n            maxIdx = dResidue;\n        }\n    }\n    for (r = 0; r < ORonnModel.AA_ALPHABET; r++) {\n        rho0 += RonnConstraint.Blosum62[dbAARow[maxIdx + r]][dbAARow[maxIdx + r]];\n    }\n    return new float[] { rho0, maxScore };\n}", "repo_id": "9", "comment": "// sResidue query sequence index and dIndex database sequence index\n", "repo_name": "biojava-master/", "id": 193, "method_signature": "float[] align(int, int)"}, "355": {"callee_method_names": ["AminoAcid.getN", "AminoAcid.getCA", "AminoAcid.getC", "AminoAcid.getN"], "method_name": "Calc.getPsi", "method_implementation": "{\n    if (!isConnected(a, b)) {\n        throw new StructureException(\"can not calc Psi - AminoAcids are not connected!\");\n    }\n    Atom a_N = a.getN();\n    Atom a_CA = a.getCA();\n    Atom a_C = a.getC();\n    Atom b_N = b.getN();\n    // C and N were checked in isConnected already\n    if (a_CA == null)\n        throw new StructureException(\"Can not calculate Psi, CA atom is missing\");\n    return torsionAngle(a_N, a_CA, a_C, b_N);\n}", "repo_id": "9", "comment": "/**\n * Calculate the psi angle.\n *\n * @param a\n *            an AminoAcid object\n * @param b\n *            an AminoAcid object\n * @return a double\n * @throws StructureException\n *             if aminoacids not connected or if any of the 4 needed atoms\n *             missing\n */\n", "repo_name": "biojava-master/", "id": 355, "method_signature": "double getPsi(AminoAcid, AminoAcid)"}, "3097": {"callee_method_names": [], "method_name": "Qualifier.setName", "method_implementation": "{\n    this.name = name;\n}", "repo_id": "9", "comment": "/**\n * @param name the name to set\n */\n", "repo_name": "biojava-master/", "id": 3097, "method_signature": "void setName(String)"}, "2710": {"callee_method_names": [], "method_name": "BufferedReaderBytesRead.ensureOpen", "method_implementation": "{\n    if (in == null) {\n        throw new IOException(\"Stream closed\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Checks to make sure that the stream has not been closed\n */\n", "repo_name": "biojava-master/", "id": 2710, "method_signature": "void ensureOpen()"}, "2285": {"callee_method_names": ["Site.toPDB", "StringBuffer.toString"], "method_name": "SiteTest.testToPDB_StringBuffer", "method_implementation": "{\n    //        System.out.println(\"toPDB\");\n    StringBuffer buf = new StringBuffer(\"\");\n    String expResult = \"SITE     1 AC1  6 ARG H 221A LYS H 224  HOH H 403  HOH H 460                    \" + newline + \"SITE     2 AC1  6 HOH H 464  HOH H 497                                          \" + newline;\n    bindingSite.toPDB(buf);\n    String result = buf.toString();\n    //        System.out.println(\"Expected:\");\n    //        System.out.println(expResult);\n    //        System.out.println(\"Got:\");\n    //        System.out.println(result);\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of toPDB method, of class Site.\n */\n", "repo_name": "biojava-master/", "id": 2285, "method_signature": "void testToPDB_StringBuffer()"}, "1417": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.isNonStandardSg", "method_implementation": "{\n    return nonStandardSg;\n}", "repo_id": "9", "comment": "/**\n * Whether this structure has a non-standard space group not supported\n * by Biojava. If this is true {@link #getSpaceGroup()} will be null.\n * @since 4.2.5\n */\n", "repo_name": "biojava-master/", "id": 1417, "method_signature": "boolean isNonStandardSg()"}, "2113": {"callee_method_names": [], "method_name": "Axis.setFirstRepeat", "method_implementation": "{\n    this.firstRepeat = firstRepeat;\n}", "repo_id": "9", "comment": "/**\n * @param firstRepeat the index of the first repeat used by this axis\n */\n", "repo_name": "biojava-master/", "id": 2113, "method_signature": "void setFirstRepeat(int)"}, "2415": {"callee_method_names": [], "method_name": "Location.startsAfter", "method_implementation": "{\n    if (isSameStrand(other)) {\n        return mStart > other.mStart;\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Check if this location starts after the other location starts.\n * The locations may overlap.\n *\n * @param other The location to compare.\n * @return True if this starts after other.\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2415, "method_signature": "boolean startsAfter(Location)"}, "3325": {"callee_method_names": ["Container.getTreeLock", "Container.getSize", "Container.getSize", "Container.getParent", "Container.getParent", "Container.getSize", "Container.getInsets", "Container.getComponentCount", "Container.getComponent", "Component.isVisible", "Component.getPreferredSize", "Component.getMinimumSize", "Container.isValid"], "method_name": "WrapLayout.layoutSize", "method_implementation": "{\n    synchronized (target.getTreeLock()) {\n        //  Each row must fit with the width allocated to the containter.\n        //  When the container width = 0, the preferred width of the container\n        //  has not yet been calculated so lets ask for the maximum.\n        int targetWidth = target.getSize().width;\n        Container container = target;\n        while (container.getSize().width == 0 && container.getParent() != null) {\n            container = container.getParent();\n        }\n        targetWidth = container.getSize().width;\n        if (targetWidth == 0)\n            targetWidth = Integer.MAX_VALUE;\n        int hgap = getHgap();\n        int vgap = getVgap();\n        Insets insets = target.getInsets();\n        int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n        int maxWidth = targetWidth - horizontalInsetsAndGap;\n        //  Fit components into the allowed width\n        Dimension dim = new Dimension(0, 0);\n        int rowWidth = 0;\n        int rowHeight = 0;\n        int nmembers = target.getComponentCount();\n        for (int i = 0; i < nmembers; i++) {\n            Component m = target.getComponent(i);\n            if (m.isVisible()) {\n                Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();\n                //  Can't add the component to current row. Start a new row.\n                if (rowWidth + d.width > maxWidth) {\n                    addRow(dim, rowWidth, rowHeight);\n                    rowWidth = 0;\n                    rowHeight = 0;\n                }\n                //  Add a horizontal gap for all components after the first\n                if (rowWidth != 0) {\n                    rowWidth += hgap;\n                }\n                rowWidth += d.width;\n                rowHeight = Math.max(rowHeight, d.height);\n            }\n        }\n        addRow(dim, rowWidth, rowHeight);\n        dim.width += horizontalInsetsAndGap;\n        dim.height += insets.top + insets.bottom + vgap * 2;\n        //\tWhen using a scroll pane or the DecoratedLookAndFeel we need to\n        //  make sure the preferred size is less than the size of the\n        //  target containter so shrinking the container size works\n        //  correctly. Removing the horizontal gap is an easy way to do this.\n        Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n        if (scrollPane != null && target.isValid()) {\n            dim.width -= (hgap + 1);\n        }\n        return dim;\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the minimum or preferred dimension needed to layout the target\n * container.\n *\n * @param target target to get layout size for\n * @param preferred should preferred size be calculated\n * @return the dimension to layout the target container\n */\n", "repo_name": "biojava-master/", "id": 3325, "method_signature": "Dimension layoutSize(Container, boolean)"}, "1299": {"callee_method_names": ["TreeMap<String,EntityInfo>.values", "List<EntityInfo>.add"], "method_name": "EntityFinder.findUniqueEntities", "method_implementation": "{\n    List<EntityInfo> list = new ArrayList<>();\n    for (EntityInfo cluster : chainIds2entities.values()) {\n        boolean present = false;\n        for (EntityInfo cl : list) {\n            if (cl == cluster) {\n                present = true;\n                break;\n            }\n        }\n        if (!present)\n            list.add(cluster);\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Utility method to obtain a list of unique entities from the chainIds2entities map\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1299, "method_signature": "List<EntityInfo> findUniqueEntities(TreeMap)"}, "3003": {"callee_method_names": [], "method_name": "BitArrayWorker.bitsPerCompound", "method_implementation": "{\n    return BYTES_PER_INT / compoundsPerDatatype();\n}", "repo_id": "9", "comment": "/**\n * Returns how many bits are used to represent a compound e.g. 2 if using\n * 2bit encoding.\n */\n", "repo_name": "biojava-master/", "id": 3003, "method_signature": "int bitsPerCompound()"}, "865": {"callee_method_names": ["SparseVector[].put"], "method_name": "SparseSquareMatrix.put", "method_implementation": "{\n    if (i < 0 || i >= N)\n        throw new IllegalArgumentException(\"Illegal index\");\n    if (j < 0 || j >= N)\n        throw new IllegalArgumentException(\"Illegal index\");\n    rows[i].put(j, value);\n}", "repo_id": "9", "comment": "/**\n * set A[i][j] = value\n *\n * @param i\n * @param j\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 865, "method_signature": "void put(int, int, double)"}, "2135": {"callee_method_names": ["Class<?>.setStructure", "List<Model>.size", "List<Model>.remove", "Model.setChains", "List<Model>.add"], "method_name": "StructureImpl.setChains", "method_implementation": "{\n    for (Chain c : chains) {\n        c.setStructure(this);\n    }\n    if (models.size() > modelnr) {\n        models.remove(modelnr);\n    }\n    Model model = new Model();\n    model.setChains(chains);\n    models.add(modelnr, model);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2135, "method_signature": "void setChains(int, List)"}, "2574": {"callee_method_names": ["String.replaceAll", "String.startsWith", "String.length", "String.substring", "String.substring"], "method_name": "FileDownloadUtils.expandUserHome", "method_implementation": "{\n    // replace any / with the proper separator (/ or \\ for Linux and Windows respectively).\n    //The \"\\\\\" is to escape the separator if needed.\n    file = file.replaceAll(\"/\", \"\\\\\" + File.separator);\n    if (file.startsWith(\"~\") && (file.length() == 1 || File.separator.equals(file.substring(1, 2)))) {\n        file = System.getProperty(\"user.home\") + file.substring(1);\n    }\n    return file;\n}", "repo_id": "9", "comment": "/**\n * Expands ~ in paths to the user's home directory.\n *\n * <p>\n * This does not work for some special cases for paths: Other users' homes\n * (~user/...), and Tilde expansion within the path (/.../~/...). In these cases\n *  the original argument is returned.\n *\n * @param file A filepath starting with a tilde\n * @return An absolute path\n */\n", "repo_name": "biojava-master/", "id": 2574, "method_signature": "String expandUserHome(String)"}, "1959": {"callee_method_names": [], "method_name": "HelixAxisAligner.getSymmetry", "method_implementation": "{\n    run();\n    return \"H\";\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getTransformation()\n\t */\n", "repo_name": "biojava-master/", "id": 1959, "method_signature": "String getSymmetry()"}, "2646": {"callee_method_names": [], "method_name": "Table.intValue", "method_implementation": "{\n    return (16 * compoundToInt(getOne())) + (4 * compoundToInt(getTwo())) + (compoundToInt(getThree()));\n}", "repo_id": "9", "comment": "/**\n * Attempts to provide an int version of this codon which multiplies\n * each position by\n */\n", "repo_name": "biojava-master/", "id": 2646, "method_signature": "int intValue()"}, "1905": {"callee_method_names": ["Matrix4d.setTranslation", "Matrix4d.mul"], "method_name": "RotationSolver.combineWithTranslation", "method_implementation": "{\n    rotation.setTranslation(centroid);\n    rotation.mul(rotation, centroidInverse);\n}", "repo_id": "9", "comment": "/**\n * Adds translational component to rotation matrix\n * @param rotation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1905, "method_signature": "void combineWithTranslation(Matrix4d)"}, "3759": {"callee_method_ids": [3773, 3736, 3736, 3736, 3718, 3724], "callee_method_names": ["WorkSheet.setIndexColumnName", "WorkSheet.addCell", "WorkSheet.addCell", "WorkSheet.addCell", "WorkSheet.setMetaDataColumns", "WorkSheet.setMetaDataRows"], "method_name": "WorkSheet.getLogScale", "method_implementation": "{\n    WorkSheet workSheet = new WorkSheet(getRows(), getColumns());\n    workSheet.setIndexColumnName(this.getIndexColumnName());\n    ArrayList<String> rows = getRows();\n    ArrayList<String> columns = getColumns();\n    for (String row : rows) {\n        for (String col : columns) {\n            if (this.isMetaDataColumn(col) || this.isMetaDataRow(row)) {\n                String value = getCell(row, col);\n                workSheet.addCell(row, col, value);\n            } else {\n                String value = getCell(row, col);\n                try {\n                    Double d = Double.parseDouble(value);\n                    if (d == 0.0) {\n                        d = zeroValue;\n                    } else {\n                        d = Math.log(d) / Math.log(base);\n                    }\n                    workSheet.addCell(row, col, d + \"\");\n                } catch (Exception e) {\n                    workSheet.addCell(row, col, value);\n                }\n            }\n        }\n    }\n    ArrayList<String> metadataRows = this.getMetaDataRows();\n    ArrayList<String> metadataColumns = this.getMetaDataColumns();\n    workSheet.setMetaDataColumns(metadataColumns);\n    workSheet.setMetaDataRows(metadataRows);\n    return workSheet;\n}", "repo_id": "9", "comment": "/**\n * Get the log scale of this worksheet\n *\n * @param base\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3759, "method_signature": "WorkSheet getLogScale(double, double)"}, "2110": {"callee_method_names": [], "method_name": "Axis.getLevel", "method_implementation": "{\n    return level;\n}", "repo_id": "9", "comment": "/**\n * @return The level of this axis within it's parent hierarchy, or -1 if unset\n */\n", "repo_name": "biojava-master/", "id": 2110, "method_signature": "int getLevel()"}, "1077": {"callee_method_names": ["Logger.info", "Path.toString", "File.delete", "Path.toFile"], "method_name": "ZipChemCompProvider.purgeTempFiles", "method_implementation": "{\n    if (tempdir == null)\n        return;\n    s_logger.info(\"Removing: \" + tempdir);\n    Path dlPath = Paths.get(tempdir).resolve(\"chemcomp\");\n    File[] chemCompOutFiles = finder(dlPath.toString(), \"cif.gz\");\n    if (null != chemCompOutFiles)\n        for (File f : chemCompOutFiles) f.delete();\n    dlPath.toFile().delete();\n}", "repo_id": "9", "comment": "/**\n * Cleanup chemical component (.cif.gz) files downloaded to tmpdir.\n * @param tempdir : path to temporary directory for chemical components\n */\n", "repo_name": "biojava-master/", "id": 1077, "method_signature": "void purgeTempFiles(String)"}, "141": {"callee_method_ids": [449, 452, 451], "callee_method_names": ["QsAlignResult.length", "QsAlignResult.getRelation", "QsAlignResult.getRmsd"], "method_name": "TestQsAlignExamples.testPartialComplete", "method_implementation": "{\n    Structure s1 = StructureIO.getStructure(\"BIO:2b3m:1\");\n    Structure s2 = StructureIO.getStructure(\"BIO:1Q6W:7\");\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n    QsAlignParameters alignParams = new QsAlignParameters();\n    QsAlignResult result = QsAlign.align(s1, s2, clusterParams, alignParams);\n    assertEquals(result.length(), 2);\n    assertEquals(result.getRelation(), QsRelation.PARTIAL_COMPLETE);\n    assertTrue(result.getRmsd() < 10.0);\n}", "repo_id": "9", "comment": "/**\n * Hydratases (2B3M dimer, 1Q6W hexamer). The C2 dimer is\n * triplicated into a D3 assembly.\n */\n", "repo_name": "biojava-master/", "id": 141, "method_signature": "void testPartialComplete()"}, "1541": {"callee_method_names": ["AtomicBoolean.set"], "method_name": "ScopInstallation.nullifyComments", "method_implementation": "{\n    commentsMap = null;\n    installedCom.set(false);\n}", "repo_id": "9", "comment": "/**\n * Removes all of the comments (dir.com file) in order to free memory. The file will need to be reloaded if {@link #getComments(int)} is called subsequently.\n */\n", "repo_name": "biojava-master/", "id": 1541, "method_signature": "void nullifyComments()"}, "2756": {"callee_method_names": [], "method_name": "EmblReference.getReferencePosition", "method_implementation": "{\n    return referencePosition;\n}", "repo_id": "9", "comment": "/**\n * The RP (Reference Position) linetype is\n * an optional linetype which appears if\n * one or more contiguous base spans of\n * the presented sequence can be attributed\n * to the reference in question.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2756, "method_signature": "String getReferencePosition()"}, "2481": {"callee_method_names": ["List<Integer>.size", "Logger.debug", "List<Integer>.size", "List<Integer>.get", "List<Integer>.get", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.isDebugEnabled", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "Logger.debug", "StringBuffer.toString", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug"], "method_name": "ChromosomeMappingTools.getChromPosReverse", "method_implementation": "{\n    boolean inCoding = false;\n    int codingLength = 0;\n    if (cdsEnd < cdsStart) {\n        int tmp = cdsEnd;\n        cdsEnd = cdsStart;\n        cdsStart = tmp;\n    }\n    int lengthExons = 0;\n    // map reverse\n    for (int i = exonStarts.size() - 1; i >= 0; i--) {\n        logger.debug(\"Exon #\" + (i + 1) + \"/\" + exonStarts.size());\n        int end = exonStarts.get(i);\n        int start = exonEnds.get(i);\n        if (end < start) {\n            int tmp = end;\n            end = start;\n            start = tmp;\n        }\n        lengthExons += end - start;\n        logger.debug(\"     is \" + cdsPos + \" part of Reverse exon? \" + format(start + 1) + \" - \" + format(end) + \" | \" + (end - start + 1));\n        logger.debug(\"     CDS start: \" + format(cdsStart + 1) + \"-\" + format(cdsEnd) + \" coding length counter:\" + codingLength);\n        if (start + 1 <= cdsEnd && end >= cdsEnd) {\n            // FIRST EXON\n            inCoding = true;\n            int tmpstart = start;\n            if (start < cdsStart) {\n                tmpstart = cdsStart;\n            }\n            // here one of the few places where we don't say start+1\n            int check = codingLength + cdsEnd - tmpstart;\n            logger.debug(\"First Exon    | \" + (check) + \" | \" + format(start + 1) + \" \" + format(end) + \" | \" + (cdsEnd - tmpstart) + \" | \" + cdsPos);\n            if ((check > cdsPos)) {\n                int tmp = cdsPos - codingLength;\n                logger.debug(\" -> found position in UTR exon:  \" + format(cdsPos) + \" \" + format(tmpstart + 1) + \" tmp:\" + format(tmp) + \" cs:\" + format(cdsStart + 1) + \" ce:\" + format(cdsEnd) + \" cl:\" + codingLength);\n                return new ChromPos((cdsEnd - tmp), -1);\n            }\n            // don't add 1 here\n            codingLength += (cdsEnd - tmpstart);\n            boolean debug = logger.isDebugEnabled();\n            if (debug) {\n                StringBuffer b = new StringBuffer();\n                b.append(\"     UTR         :\" + format(cdsEnd + 1) + \" - \" + format(end) + newline);\n                if (tmpstart == start)\n                    b.append(\" ->  \");\n                else\n                    b.append(\" <-> \");\n                b.append(\"Exon        :\" + format(tmpstart + 1) + \" - \" + (cdsEnd) + \" | \" + format(cdsEnd - tmpstart + 1) + \" - \" + codingLength + \" | \" + (codingLength % 3) + newline);\n                // single exon with UTR on both ends\n                if (tmpstart != start)\n                    b.append(\"     UTR         :\" + format(cdsStart) + \" - \" + format(start + 1) + newline);\n                logger.debug(b.toString());\n            }\n        } else if (start <= cdsStart && end >= cdsStart) {\n            // LAST EXON\n            inCoding = false;\n            if (codingLength + end - cdsStart >= cdsPos) {\n                // how many remaining coding nucleotides?\n                int tmp = codingLength + end - cdsStart - cdsPos;\n                logger.debug(\"cdl: \" + codingLength + \" tmp:\" + tmp + \" cdsStart: \" + format(cdsStart));\n                logger.debug(\" -> XXX found position noncoding exon:  cdsPos:\" + cdsPos + \" s:\" + format(start + 1) + \" tmp:\" + format(tmp) + \" cdsStart:\" + (cdsStart + 1) + \" codingLength:\" + codingLength + \" cdsEnd:\" + format(cdsEnd));\n                return new ChromPos((cdsStart + tmp), -1);\n            }\n            codingLength += (end - cdsStart);\n            logger.debug(\" <-  Exon        : \" + format(cdsStart + 1) + \" - \" + format(end) + \" | \" + format(end - cdsStart + 1) + \" | \" + codingLength + \" | \" + (codingLength % 3));\n            logger.debug(\"     UTR         : \" + format(start + 1) + \" - \" + format(cdsStart));\n        } else if (inCoding) {\n            if (codingLength + end - start - 1 >= cdsPos) {\n                int tmp = cdsPos - codingLength;\n                if (tmp > (end - start)) {\n                    tmp = (end - start);\n                    logger.debug(\"changing tmp to {}\", tmp);\n                }\n                logger.debug(\"     \" + cdsPos + \" \" + codingLength + \" | \" + (cdsPos - codingLength) + \" | \" + (end - start) + \" | \" + tmp);\n                logger.debug(\"     Exon        : \" + format(start + 1) + \" - \" + format(end) + \" | \" + format(end - start) + \" | \" + codingLength + \" | \" + (codingLength % 3));\n                logger.debug(\" ->  RRR found position coding exon:  \" + cdsPos + \" \" + format(start + 1) + \" \" + format(end) + \" \" + tmp + \" \" + format(cdsStart + 1) + \" \" + codingLength);\n                return new ChromPos((end - tmp), cdsPos % 3);\n            }\n            // full exon is coding\n            codingLength += (end - start);\n            logger.debug(\"     Exon        : \" + format(start + 1) + \" - \" + format(end) + \" | \" + format(end - start + 1) + \" | \" + codingLength + \" | \" + (codingLength % 3));\n        } else {\n            // e.g. see UBQLN3\n            logger.debug(\" no translation!\");\n        }\n        logger.debug(\"     coding length: \" + codingLength + \"(phase:\" + (codingLength % 3) + \") CDS POS trying to map:\" + cdsPos);\n    }\n    logger.debug(\"length exons: {}\", lengthExons);\n    // could not map, or map over the full length??\n    return new ChromPos(-1, -1);\n}", "repo_id": "9", "comment": "/**\n * Get the CDS position mapped on the chromosome position\n *\n * @param exonStarts\n * @param exonEnds\n * @param cdsStart\n * @param cdsEnd\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2481, "method_signature": "ChromPos getChromPosReverse(int, List, List, int, int)"}, "872": {"callee_method_names": ["Pair<String>.getFirst", "Pair<CrystalTransform>.getFirst", "Pair<CrystalTransform>.getFirst", "Pair<String>.getSecond", "Pair<CrystalTransform>.getSecond", "Pair<CrystalTransform>.getSecond"], "method_name": "StructureInterface.getCrystalIds", "method_implementation": "{\n    return new Pair<>(moleculeIds.getFirst() + transforms.getFirst().getTransformId() + transforms.getFirst().getCrystalTranslation(), moleculeIds.getSecond() + transforms.getSecond().getTransformId() + transforms.getSecond().getCrystalTranslation());\n}", "repo_id": "9", "comment": "/**\n * Returns a pair of identifiers for each of the 2 member molecules that\n * identify them uniquely in the crystal:\n *   &lt;molecule id (asym unit id)&gt;+&lt;operator id&gt;+&lt;crystal translation&gt;\n * @return\n */\n", "repo_name": "biojava-master/", "id": 872, "method_signature": "Pair<String> getCrystalIds()"}, "2502": {"callee_method_names": ["LinkedHashMap<String, ChromosomeSequence>.values", "LinkedHashMap<String, GeneSequence>.values", "File.deleteOnExit"], "method_name": "GeneFeatureHelperTest.testGetGeneSequences", "method_implementation": "{\n    // logger.info(\"getGeneSequences\");\n    LinkedHashMap<String, ChromosomeSequence> chromosomeSequenceList = GeneFeatureHelper.loadFastaAddGeneFeaturesFromGmodGFF3(new File(\"src/test/resources/volvox_all.fna\"), new File(\"src/test/resources/volvox.gff3\"), true);\n    LinkedHashMap<String, GeneSequence> geneSequenceHashMap = GeneFeatureHelper.getGeneSequences(chromosomeSequenceList.values());\n    Collection<GeneSequence> geneSequences = geneSequenceHashMap.values();\n    File tmp = Files.createTempFile(\"volvox_all_genes_exon_uppercase\", \"fna\").toFile();\n    tmp.deleteOnExit();\n    FastaWriterHelper.writeGeneSequence(tmp, geneSequences, true);\n}", "repo_id": "9", "comment": "/**\n * Test of getGeneSequences method, of class GeneFeatureHelper.\n */\n", "repo_name": "biojava-master/", "id": 2502, "method_signature": "void testGetGeneSequences()"}, "610": {"callee_method_names": [], "method_name": "UserConfiguration.toXML", "method_implementation": "{\n    XMLWriter xw = new PrettyXMLWriter(pw);\n    toXML(xw);\n    return xw;\n}", "repo_id": "9", "comment": "/**\n * convert Configuration to an XML file so it can be serialized\n *\n * @param pw\n * @return XMLWriter\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 610, "method_signature": "XMLWriter toXML(PrintWriter)"}, "2892": {"callee_method_ids": [2565, 2566], "callee_method_names": ["CRC64Checksum.update", "C.getShortName", "CRC64Checksum.toString"], "method_name": "SequenceMixin.checksum", "method_implementation": "{\n    CRC64Checksum checksum = new CRC64Checksum();\n    for (C compound : sequence) {\n        checksum.update(compound.getShortName());\n    }\n    return checksum.toString();\n}", "repo_id": "9", "comment": "/**\n * Performs a simple CRC64 checksum on any given sequence.\n */\n", "repo_name": "biojava-master/", "id": 2892, "method_signature": "String checksum(Sequence)"}, "1233": {"callee_method_names": ["List<Group>.size", "List<Group>.get", "Group.isWater", "Group.getResidueNumber", "ResidueNumber.getSeqNum", "Logger.debug", "List<Group>.get", "Group.getPDBName", "Group.getPDBName", "Logger.debug", "Group.getPDBName", "Group.getPDBName", "List<Group>.size", "Logger.debug", "List<Group>.size", "Logger.debug", "List<Group>.size", "List<Group>.size", "Logger.debug", "List<Group>.get", "Group.getPDBName", "Group.getPDBName", "Logger.debug", "List<Group>.set", "Logger.debug", "Group.getResidueNumber", "Group.getPDBName", "Group.getResidueNumber", "Group.getPDBName"], "method_name": "SeqRes2AtomAligner.trySimpleMatch", "method_implementation": "{\n    // by default first ATOM position is 1\n    //\n    @SuppressWarnings(\"unchecked\")\n    List<Group> newSeqResGroups = (ArrayList<Group>) ((ArrayList<Group>) seqResGroups).clone();\n    boolean startAt1 = true;\n    for (int atomResPos = 0; atomResPos < atmResGroups.size(); atomResPos++) {\n        // let's try to match this case\n        Group atomResGroup = atmResGroups.get(atomResPos);\n        // let's ignore waters\n        if (atomResGroup.isWater()) {\n            continue;\n        }\n        ResidueNumber atomResNum = atomResGroup.getResidueNumber();\n        int seqResPos = atomResNum.getSeqNum();\n        if (seqResPos < 0) {\n            logger.debug(\"ATOM residue number < 0 : {}\", seqResPos);\n            return null;\n        }\n        if (seqResPos == 0) {\n            // make sure the first SEQRES is matching.\n            Group seqResGroup = seqResGroups.get(0);\n            if (seqResGroup.getPDBName().equals(atomResGroup.getPDBName())) {\n                // they match! seems in this case the numbering starts with 0...\n                startAt1 = false;\n            } else {\n                logger.debug(\"SEQRES position 1 ({}) does not match ATOM PDB res num 0 ({})\", seqResGroup.getPDBName(), atomResGroup.getPDBName());\n                return null;\n            }\n        }\n        if (startAt1)\n            seqResPos--;\n        // another check that would require the alignment approach\n        if (startAt1 && seqResPos >= seqResGroups.size()) {\n            // could be a HETATOM...\n            if (atomResGroup instanceof AminoAcid) {\n                logger.debug(\" ATOM residue nr: \" + seqResPos + \" > seqres! \" + seqResGroups.size() + \" \" + atomResGroup);\n                return null;\n            } else if (atomResGroup instanceof NucleotideImpl) {\n                logger.debug(\" NUCLEOTIDE residue nr: \" + seqResPos + \" > seqres! \" + seqResGroups.size() + \" \" + atomResGroup);\n                return null;\n            } else {\n                // we won't map HETATOM groups...\n                continue;\n            }\n        }\n        //\t\t\tif ( seqResPos < 0){\n        //\n        //\t\t\t\tSystem.err.println(\"What is going on??? \" + atomRes.getChainID() + \" \" + atomResGroup);\n        //\t\t\t}\n        if (seqResPos >= seqResGroups.size()) {\n            logger.debug(\"seqres groups don't match atom indices {}\", seqResPos);\n            if (atomResGroup instanceof AminoAcid)\n                return null;\n            else\n                continue;\n        }\n        Group seqResGroup = seqResGroups.get(seqResPos);\n        if (!seqResGroup.getPDBName().trim().equals(atomResGroup.getPDBName().trim())) {\n            // a mismatch! something is wrong in the mapping and we need to do an alignment\n            logger.debug(\"Mismatch of SEQRES pos \" + seqResPos + \" and ATOM record: \" + atomResGroup + \" | \" + seqResGroup);\n            return null;\n        }\n        // the two groups are identical and we can merge them\n        // replace the SEQRES group with the ATOM group...\n        Group replacedGroup = newSeqResGroups.set(seqResPos, atomResGroup);\n        logger.debug(\"Merging index {}: replaced seqres group {} ({}) with atom group {} ({})\", seqResPos, replacedGroup.getResidueNumber(), replacedGroup.getPDBName(), atomResGroup.getResidueNumber(), atomResGroup.getPDBName());\n    }\n    // all went ok. copy over the updated list to the original one.\n    // note: if something went wrong, we did not modifiy the original list.\n    //seqResGroups = newSeqResGroups;\n    //\t\t\tint pos = -1;\n    //\t\t\tfor (Group g: seqResGroups){\n    //\t\t\t\tpos++;\n    //\t\t\t\tlogger.debug(pos + \" \" + g);\n    //\t\t\t}\n    //System.out.println(\"I:\" + seqResGroups);\n    // all atom records could get matched correctly!\n    return newSeqResGroups;\n}", "repo_id": "9", "comment": "/**\n * A simple matching approach that tries to do a 1:1 mapping between SEQRES and ATOM records\n *\n * @param seqResGroups list of seqREs groups\n * @param atmResGroups list of atmRes Groups\n * @return the matching or null if the matching didn't work\n */\n", "repo_name": "biojava-master/", "id": 1233, "method_signature": "List<Group> trySimpleMatch(List, List)"}, "2625": {"callee_method_names": ["InputStream.read", "InputStream.read"], "method_name": "InputStreamProvider.getMagicNumber", "method_implementation": "{\n    int t = in.read();\n    if (t < 0)\n        throw new EOFException(\"Failed to read magic number\");\n    int magic = (t & 0xff) << 8;\n    t = in.read();\n    if (t < 0)\n        throw new EOFException(\"Failed to read magic number\");\n    magic += t & 0xff;\n    return magic;\n}", "repo_id": "9", "comment": "/**\n * open the file and read the magic number from the beginning\n * this is used to determine the compression type\n *\n * @param in an input stream to read from\n * @return the magic number\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2625, "method_signature": "int getMagicNumber(InputStream)"}, "3623": {"callee_method_ids": [3530, 3539, 3540, 3679, 3681, 3680], "callee_method_names": ["LinkedHashMap.values", "CoxCoefficient.getName", "CoxCoefficient.getMean", "CoxCoefficient.getStandardDeviation", "LinkedHashMap.size", "LinkedHashMap.keySet", "LinkedHashMap.get", "WaldTestInfo.getTest", "WaldTestInfo.getDf", "WaldTestInfo.getPvalue", "CoxMethod.name"], "method_name": "CoxInfo.toString", "method_implementation": "{\n    String o = beginLine + fmtpl(\"\", 9) + fmtpl(\"Avg\", 9) + fmtpl(\"SD\", 9) + endLine;\n    for (CoxCoefficient coe : coefficientsList.values()) {\n        o = o + beginLine + fmtpr(coe.getName(), 9) + fmt(coe.getMean(), 4, 9) + fmt(coe.getStandardDeviation(), 4, 9) + endLine;\n    }\n    o = o + beginLine + endLine;\n    o = o + beginLine + \"n= \" + this.numSamples + \", number of events=\" + this.numEvents + endLine;\n    o = o + getCoefficientText(true, beginLine, del, \"\", endLine);\n    o = o + beginLine + endLine;\n    if (baselineSurvivorFunction.size() > 0) {\n        o = o + beginLine + \"Baseline Survivor Function (at predictor means)\" + endLine;\n        for (Double time : baselineSurvivorFunction.keySet()) {\n            Double mean = baselineSurvivorFunction.get(time);\n            o = o + beginLine + fmt(time, 4, 10) + fmt(mean, 4, 10) + endLine;\n        }\n    }\n    o = o + beginLine + endLine;\n    o = o + beginLine + \"Overall Model Fit\" + endLine;\n    o = o + beginLine + \"Iterations=\" + iterations + endLine;\n    o = o + beginLine + \"Likelihood ratio test = \" + fmt(this.logTest, 2, 0) + \" df=\" + this.degreeFreedom + \" p-value=\" + fmt(this.logTestpval, 7, 0) + endLine;\n    o = o + beginLine + \"Wald test             = \" + fmt(waldTestInfo.getTest(), 2, 0) + \" df=\" + waldTestInfo.getDf() + \" p-value=\" + fmt(waldTestInfo.getPvalue(), 7, 0) + endLine;\n    o = o + beginLine + \"Score (logrank) test  = \" + fmt(scoreLogrankTest, 2, 0) + \" df=\" + ((int) (this.degreeFreedom)) + \" p-value=\" + fmt(this.scoreLogrankTestpvalue, 7, 0);\n    if (this.rscore != null) {\n        o = o + \",  Robust = \" + fmt(rscore, 2, 0) + \" p-value=\" + fmt(rscoreLogrankTestpvalue, 7, 0);\n    }\n    o = o + endLine;\n    //       o = o + \"Rank of solution flag=\" + flag + \"\\r\\n\";\n    //       o = o + \"Log lik Initial=\" + loglikInit + \"\\r\\n\";\n    //       o = o + \"Log lik Final=\" + loglikFinal + \"\\r\\n\";\n    o = o + beginLine + \"Method=\" + method.name() + endLine;\n    return o;\n}", "repo_id": "9", "comment": "/**\n * @param beginLine\n * @param del\n * @param endLine\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3623, "method_signature": "String toString(String, String, String)"}, "2418": {"callee_method_names": [], "method_name": "Location.endsBefore", "method_implementation": "{\n    if (isSameStrand(other)) {\n        return mEnd < other.mEnd;\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Check if this location ends before other location ends.\n * The locations may overlap.\n *\n * @param other The location to compare.\n * @return True if this ends before other.\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2418, "method_signature": "boolean endsBefore(Location)"}, "3784": {"callee_method_ids": [3694, 3692, 3697], "callee_method_names": ["SurvFitInfo.setStrataInfoHashMap", "SurvFitInfo.setUnweightedStrataInfoHashMap", "SurvFitInfo.setWeighted"], "method_name": "SurvFitKM.process", "method_implementation": "{\n    SurvFitInfo si = new SurvFitInfo();\n    LinkedHashMap<String, StrataInfo> strataInfoHashMap = this.processStrataInfo(variable, dataT, method, error, seFit, confInt, confType, confLower, startTime, newTime, useWeighted);\n    si.setStrataInfoHashMap(strataInfoHashMap);\n    LinkedHashMap<String, StrataInfo> unweightedStrataInfoHashMap = this.processStrataInfo(variable, dataT, method, error, seFit, confInt, confType, confLower, startTime, newTime, false);\n    si.setUnweightedStrataInfoHashMap(unweightedStrataInfoHashMap);\n    si.setWeighted(useWeighted);\n    return si;\n}", "repo_id": "9", "comment": "/**\n * @param variable\n * @param dataT\n * @param method\n * @param error\n * @param seFit\n * @param confInt\n * @param confType\n * @param confLower\n * @param startTime\n * @param newTime\n * @param useWeighted\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3784, "method_signature": "SurvFitInfo process(String, ArrayList, SurvFitKM.Method, SurvFitKM.Error, boolean, double, ConfType, ConfLower, Double, Double, boolean)"}, "1876": {"callee_method_names": [], "method_name": "Helix.getAngle", "method_implementation": "{\n    return getAxisAngle().angle;\n}", "repo_id": "9", "comment": "/**\n * Returns the pitch angle of the helix\n * @param transformation helix transformation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1876, "method_signature": "double getAngle()"}, "2928": {"callee_method_names": ["List<FeatureInterface<AbstractSequence<C>, C>>.remove", "LinkedHashMap.get", "FeatureInterface<AbstractSequence<C>,C>.getType", "ArrayList<FeatureInterface<AbstractSequence<C>, C>>.remove", "ArrayList<FeatureInterface<AbstractSequence<C>, C>>.isEmpty", "LinkedHashMap.remove", "FeatureInterface<AbstractSequence<C>,C>.getType"], "method_name": "AbstractSequence.removeFeature", "method_implementation": "{\n    features.remove(feature);\n    ArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(feature.getType());\n    if (featureList != null) {\n        featureList.remove(feature);\n        if (featureList.isEmpty()) {\n            groupedFeatures.remove(feature.getType());\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Remove a feature from the sequence\n * @param feature\n */\n", "repo_name": "biojava-master/", "id": 2928, "method_signature": "void removeFeature(FeatureInterface)"}, "43": {"callee_method_names": ["S.getCompoundSet", "S.getCompoundSet"], "method_name": "Alignments.getPairwiseAligner", "method_implementation": "{\n    if (!query.getCompoundSet().equals(target.getCompoundSet())) {\n        throw new IllegalArgumentException(\"Sequence compound sets must be the same\");\n    }\n    switch(type) {\n        default:\n        case GLOBAL:\n            return new NeedlemanWunsch<S, C>(query, target, gapPenalty, subMatrix);\n        case LOCAL:\n            return new SmithWaterman<S, C>(query, target, gapPenalty, subMatrix);\n        case GLOBAL_LINEAR_SPACE:\n        case LOCAL_LINEAR_SPACE:\n            // TODO other alignment options (Myers-Miller, Thompson)\n            throw new UnsupportedOperationException(Alignments.class.getSimpleName() + \" does not yet support \" + type + \" alignment\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Factory method which constructs a pairwise sequence aligner.\n *\n * @param <S> each {@link Sequence} of an alignment pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param query the first {@link Sequence} to align\n * @param target the second {@link Sequence} to align\n * @param type chosen type from list of pairwise sequence alignment routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return pairwise sequence aligner\n */\n", "repo_name": "biojava-master/", "id": 43, "method_signature": "PairwiseSequenceAligner<S,C> getPairwiseAligner(S, S, PairwiseSequenceAlignerType, GapPenalty, SubstitutionMatrix)"}, "2069": {"callee_method_names": ["List<Integer>.size"], "method_name": "ResidueGroup.order", "method_implementation": "{\n    return residues.size();\n}", "repo_id": "9", "comment": "/**\n * The order of symmetry of the group is the number of connected residues.\n *\n * @return size of residues List\n */\n", "repo_name": "biojava-master/", "id": 2069, "method_signature": "int order()"}, "2351": {"callee_method_names": [], "method_name": "FastqParser.getState", "method_implementation": "{\n    return state;\n}", "repo_id": "9", "comment": "/**\n * Return the parser state.\n *\n * @return the parser state\n */\n", "repo_name": "biojava-master/", "id": 2351, "method_signature": "State getState()"}, "1241": {"callee_method_names": [], "method_name": "FastaStructureParser.getAccessions", "method_implementation": "{\n    return accessions;\n}", "repo_id": "9", "comment": "/**\n * Gets the protein accessions mapped from the Fasta file.\n * Returns null if {@link #process()} has not been called.\n * @return An array of Structures for each protein\n *  in the fasta file, or null if process() hasn't been called.\n */\n", "repo_name": "biojava-master/", "id": 1241, "method_signature": "String[] getAccessions()"}, "460": {"callee_method_names": [], "method_name": "QsAlignParameters.getMaxRmsd", "method_implementation": "{\n    return maxRmsd;\n}", "repo_id": "9", "comment": "/**\n * The maximum allowed RMSD of the alignment, in A.\n *\n * @return maxRmsd\n */\n", "repo_name": "biojava-master/", "id": 460, "method_signature": "double getMaxRmsd()"}, "887": {"callee_method_ids": [840, 842, 843, 840, 842, 843], "callee_method_names": ["Map<ResidueNumber, GroupAsa>.values", "GroupAsa.getAsaU", "GroupAsa.getBsa", "GroupAsa.getBsaToAsaRatio", "List<Group>.add", "GroupAsa.getGroup", "Map<ResidueNumber, GroupAsa>.values", "GroupAsa.getAsaU", "GroupAsa.getBsa", "GroupAsa.getBsaToAsaRatio", "List<Group>.add", "GroupAsa.getGroup"], "method_name": "StructureInterface.getCoreResidues", "method_implementation": "{\n    List<Group> core1 = new ArrayList<>();\n    List<Group> core2 = new ArrayList<>();\n    for (GroupAsa groupAsa : groupAsas1.values()) {\n        if (groupAsa.getAsaU() > minAsaForSurface && groupAsa.getBsa() > 0) {\n            if (groupAsa.getBsaToAsaRatio() < bsaToAsaCutoff) {\n                //rim1.add(groupAsa.getGroup());\n            } else {\n                core1.add(groupAsa.getGroup());\n            }\n        }\n    }\n    for (GroupAsa groupAsa : groupAsas2.values()) {\n        if (groupAsa.getAsaU() > minAsaForSurface && groupAsa.getBsa() > 0) {\n            if (groupAsa.getBsaToAsaRatio() < bsaToAsaCutoff) {\n                //rim2.add(groupAsa.getGroup());\n            } else {\n                core2.add(groupAsa.getGroup());\n            }\n        }\n    }\n    return new Pair<>(core1, core2);\n}", "repo_id": "9", "comment": "/**\n * Returns the residues belonging to the interface core, defined as those residues at\n * the interface (BSA>0) and for which the BSA/ASA ratio is above the given bsaToAsaCutoff\n * @param bsaToAsaCutoff\n * @param minAsaForSurface the minimum ASA to consider a residue on the surface\n * @return\n */\n", "repo_name": "biojava-master/", "id": 887, "method_signature": "Pair<List<Group>> getCoreResidues(double, double)"}, "1443": {"callee_method_names": ["Chain.getAtomGroups", "Group.setResidueNumber", "Group.getResidueNumber", "Group.getResidueNumber", "Chain.getSeqResGroups", "Group.getResidueNumber", "Group.setResidueNumber", "Group.getResidueNumber", "Group.getResidueNumber"], "method_name": "CrystalBuilder.setChainIdsInResidueNumbers", "method_implementation": "{\n    for (Group g : c.getAtomGroups()) {\n        g.setResidueNumber(newChainName, g.getResidueNumber().getSeqNum(), g.getResidueNumber().getInsCode());\n    }\n    for (Group g : c.getSeqResGroups()) {\n        if (g.getResidueNumber() == null)\n            continue;\n        g.setResidueNumber(newChainName, g.getResidueNumber().getSeqNum(), g.getResidueNumber().getInsCode());\n    }\n}", "repo_id": "9", "comment": "/**\n * Auxiliary method to reset chain ids of residue numbers in a chain.\n * Used when cloning chains and resetting their ids: one needs to take care of\n * resetting the ids within residue numbers too.\n * @param c\n * @param newChainName\n */\n", "repo_name": "biojava-master/", "id": 1443, "method_signature": "void setChainIdsInResidueNumbers(Chain, String)"}, "1974": {"callee_method_names": ["Map<Double, List<Integer>>.get", "Map<Double, List<Integer>>.put", "List<List<Integer>>.clear", "Map<Double, List<Integer>>.values", "List<List<Integer>>.add"], "method_name": "HelixAxisAligner.calcAlignedOrbits", "method_implementation": "{\n    Map<Double, List<Integer>> depthMap = new TreeMap<Double, List<Integer>>();\n    double[] depth = getSubunitZDepth();\n    alignedOrbits = calcOrbits();\n    // calculate the mean depth of orbit along z-axis\n    for (List<Integer> orbit : alignedOrbits) {\n        // calculate the mean depth along z-axis for each orbit\n        double meanDepth = 0;\n        for (int subunit : orbit) {\n            meanDepth += depth[subunit];\n        }\n        meanDepth /= orbit.size();\n        if (depthMap.get(meanDepth) != null) {\n            meanDepth += 0.01;\n        }\n        //\t\t\tSystem.out.println(\"calcAlignedOrbits: \" + meanDepth + \" orbit: \" + orbit);\n        depthMap.put(meanDepth, orbit);\n    }\n    // now fill orbits back into list ordered by depth\n    alignedOrbits.clear();\n    for (List<Integer> orbit : depthMap.values()) {\n        // order subunit in a clockwise rotation around the z-axis\n        /// starting at the 12 O-clock position (+y position)\n        // TODO how should this be aligned??\n        //\t\talignWithReferenceAxis(orbit);\n        alignedOrbits.add(orbit);\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns a list of orbits (an orbit is a cyclic permutation of subunit indices that are related\n * by a rotation around the principal rotation axis) ordered from the +z direction to the -z direction (z-depth).\n * Within an orbit, subunit indices are ordered with a clockwise rotation around the z-axis.\n * @return list of orbits ordered by z-depth\n */\n", "repo_name": "biojava-master/", "id": 1974, "method_signature": "void calcAlignedOrbits()"}, "2654": {"callee_method_names": [], "method_name": "TranscriptionEngine.stopAtStopCodons", "method_implementation": "{\n    this.stopAtStopCodons = stopAtStopCodons;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * If set, then the last codon translated in the resulting peptide\n * sequence will be the stop codon\n */\n", "repo_name": "biojava-master/", "id": 2654, "method_signature": "Builder stopAtStopCodons(boolean)"}, "3119": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.toString", "method_implementation": "{\n    return getSequenceAsString();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3119, "method_signature": "String toString()"}, "957": {"callee_method_names": [], "method_name": "BiologicalAssemblyTransformation.getChainId", "method_implementation": "{\n    return this.chainId;\n}", "repo_id": "9", "comment": "/**\n * Returns the chain identifier (asym id) that this transformation should be applied to.\n * @return chain identifier\n */\n", "repo_name": "biojava-master/", "id": 957, "method_signature": "String getChainId()"}, "3836": {"callee_method_names": ["int.getName", "int.getIsotopes", "int.getIsotopes", "int.getName"], "method_name": "ElementTable.populateMaps", "method_implementation": "{\n    this.elementName2Element = new HashMap<String, Element>();\n    this.isotopeName2Isotope = new HashMap<String, Isotope>();\n    if (this.element != null) {\n        for (Element e : this.element) {\n            this.elementName2Element.put(e.getName(), e);\n            if (e.getIsotopes() != null) {\n                for (Isotope i : e.getIsotopes()) {\n                    this.isotopeName2Isotope.put(i.getName(), i);\n                }\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Populate the Maps for quick retrieval\n */\n", "repo_name": "biojava-master/", "id": 3836, "method_signature": "void populateMaps()"}, "1040": {"callee_method_names": ["Structure.getChains", "List<Atom>.addAll", "List<Atom>.toArray"], "method_name": "StructureTools.getRepresentativeAtomArray", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>();\n    for (Chain c : s.getChains()) {\n        Atom[] chainAtoms = getRepresentativeAtomArray(c);\n        atoms.addAll(Arrays.asList(chainAtoms));\n    }\n    return atoms.toArray(new Atom[0]);\n}", "repo_id": "9", "comment": "/**\n * Gets a representative atom for each group that is part of the chain\n * backbone. Note that modified aminoacids won't be returned as part of the\n * backbone if the {@link org.biojava.nbio.structure.chem.ReducedChemCompProvider} was used to load the\n * structure.\n *\n * For amino acids, the representative is a CA carbon. For nucleotides, the\n * representative is the {@value #NUCLEOTIDE_REPRESENTATIVE}. Other group\n * types will be ignored.\n *\n * @param s\n *            Input structure\n * @return representative Atoms of the structure backbone\n * @since Biojava 4.1.0\n */\n", "repo_name": "biojava-master/", "id": 1040, "method_signature": "Atom[] getRepresentativeAtomArray(Structure)"}, "1363": {"callee_method_names": [], "method_name": "AminoAcidImpl.setPDBName", "method_implementation": "{\n    pdb_name = s;\n}", "repo_id": "9", "comment": "/**\n * set three character name of AminoAcid.\n *\n * @param s  a String specifying the PDBName value\n * @see #getPDBName()\n */\n", "repo_name": "biojava-master/", "id": 1363, "method_signature": "void setPDBName(String)"}, "54": {"callee_method_names": ["List<ProfileProfileAligner<S,C>>.size", "List<Future<ProfilePair<S, C>>>.add"], "method_name": "Alignments.runProfileAligners", "method_implementation": "{\n    int n = 1, all = aligners.size();\n    List<Future<ProfilePair<S, C>>> futures = new ArrayList<Future<ProfilePair<S, C>>>();\n    for (ProfileProfileAligner<S, C> aligner : aligners) {\n        futures.add(ConcurrencyTools.submit(new CallableProfileProfileAligner<S, C>(aligner), String.format(\"Aligning pair %d of %d\", n++, all)));\n    }\n    return getListFromFutures(futures);\n}", "repo_id": "9", "comment": "/**\n * Factory method to run a list of alignments concurrently.  This method runs the alignments in parallel by\n * submitting all of the alignment tasks to the shared thread pool of the {@link ConcurrencyTools} utility.\n *\n * @param <S> each {@link Sequence} of the {@link Profile} pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param aligners list of alignments to run\n * @return list of {@link ProfilePair} results from running alignments\n */\n", "repo_name": "biojava-master/", "id": 54, "method_signature": "List<ProfilePair<S,C>> runProfileAligners(List)"}, "2246": {"callee_method_names": ["Structure.getChains", "Structure.getChains", "Structure.getChains", "Chain.getAtomGroups", "Chain.getAtomGroups", "Chain.getAtoms", "Set<Atom>.addAll", "Chain.getAtoms", "Chain.getAltLocs", "Set<Atom>.addAll", "Structure.getChains", "Structure.getChains", "Structure.getChains", "Structure.getChains", "Chain.getAtomGroups", "Chain.getAtomGroups", "Chain.getAtoms", "Set<Atom>.addAll", "Chain.getAtoms", "Chain.getAltLocs", "Set<Atom>.addAll", "Set<Atom>.size", "List<Atom>.size", "List<Atom>.size", "Set<Atom>.size", "Set<Atom>.size"], "method_name": "TestMmtfUtils.microHeterogenity", "method_implementation": "{\n    setUpBioJava();\n    Structure inputStructure = StructureIO.getStructure(\"4ck4\");\n    // Count the number of groups\n    Group before = inputStructure.getChains().get(0).getAtomGroup(17);\n    assertTrue(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n    List<Atom> totalAtoms = new ArrayList<>(getAllAtoms(inputStructure));\n    int totGroups = 0;\n    int totAtomsCounter = 0;\n    Set<Atom> totAtoms = new HashSet<>();\n    for (Chain c : inputStructure.getChains()) {\n        totGroups += c.getAtomGroups().size();\n        for (Group g : c.getAtomGroups()) {\n            totAtomsCounter += g.getAtoms().size();\n            totAtoms.addAll(g.getAtoms());\n            for (Group alt : g.getAltLocs()) {\n                totAtomsCounter += alt.getAtoms().size();\n                totAtoms.addAll(alt.getAtoms());\n            }\n        }\n    }\n    // Now \"fix\" the microheterogenity\n    MmtfUtils.fixMicroheterogenity(inputStructure);\n    assertEquals(before, inputStructure.getChains().get(0).getAtomGroup(17));\n    assertFalse(inputStructure.getChains().get(0).getAtomGroup(17).hasAltLoc());\n    assertFalse(inputStructure.getChains().get(0).getAtomGroup(18).hasAltLoc());\n    int totGroupsAfter = 0;\n    int totAtomsCounterAfter = 0;\n    Set<Atom> totAtomsAfter = new HashSet<>();\n    for (Chain c : inputStructure.getChains()) {\n        totGroupsAfter += c.getAtomGroups().size();\n        for (Group g : c.getAtomGroups()) {\n            totAtomsCounterAfter += g.getAtoms().size();\n            totAtomsAfter.addAll(g.getAtoms());\n            for (Group alt : g.getAltLocs()) {\n                totAtomsAfter.addAll(alt.getAtoms());\n                totAtomsCounterAfter += alt.getAtoms().size();\n            }\n        }\n    }\n    // Find the atoms after the fix.\n    List<Atom> totalAtomsAfter = new ArrayList<>(getAllAtoms(inputStructure));\n    // Get all of the duplicate atoms\n    Set<Atom> duplicates = findDuplicates(totalAtomsAfter);\n    for (Atom a : duplicates) {\n        System.out.println(a);\n    }\n    // There should be no duplicates\n    assertEquals(duplicates.size(), 0);\n    assertEquals(totalAtoms.size(), totalAtomsAfter.size());\n    // Check there are two more groups afterwards\n    assertEquals(totGroupsAfter - 2, totGroups);\n    // Check there are no more atoms afterwards\n    assertEquals(totAtomsAfter.size(), totAtoms.size());\n    // Check the counter are the same too\n    assertEquals(totAtomsCounterAfter, totAtomsCounter);\n}", "repo_id": "9", "comment": "/**\n * Integration test to see that the microheterogenity is being dealt with correctly.\n *\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2246, "method_signature": "void microHeterogenity()"}, "2679": {"callee_method_names": ["ArrayList.size", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "ArrayList.size", "StringBuilder.append", "Atom[].getAccession", "StringBuilder.append", "Atom[].getSubSequence", "StringBuilder.append", "ArrayList.size", "StringBuilder.append", "Atom[].getAccession", "StringBuilder.append", "Atom[].getSubSequence", "StringBuilder.append", "ArrayList.size", "StringBuilder.append", "StringBuilder.toString"], "method_name": "MultipleSequenceAlignment.toString", "method_implementation": "{\n    // TODO handle circular alignments\n    StringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n    if (webDisplay && sequences.size() == 2) {\n        s.append(\"<div><pre>\");\n    }\n    width = Math.max(1, width);\n    if (interlaced) {\n        String aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) + \"d%n\";\n        for (int i = 0; i < getLength(); i += width) {\n            int start = i + 1, end = Math.min(getLength(), i + width);\n            if (i > 0) {\n                s.append(String.format(\"%n\"));\n            }\n            if (aligIndices) {\n                if (end < i + width) {\n                    int line = end - start + 1;\n                    aligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) + \"d%n\";\n                }\n                if (idFormat != null) {\n                    s.append(String.format(idFormat, \"\"));\n                }\n                s.append(String.format(aligIndFormat, start, end));\n            }\n            int counter = 0;\n            for (S as : sequences) {\n                counter++;\n                if (webDisplay && sequences.size() == 2) {\n                    printSequenceAlignmentWeb(s, counter, idFormat, start, end);\n                } else {\n                    if (idFormat != null) {\n                        s.append(String.format(idFormat, as.getAccession()));\n                    }\n                    s.append(as.getSubSequence(start, end).getSequenceAsString());\n                    s.append(String.format(\"%n\"));\n                }\n                if (aligConservation && sequences.size() == 2 && counter == 1) {\n                    printConservation(s, idFormat, start, end, webDisplay);\n                }\n            }\n        }\n    } else {\n        for (S as : sequences) {\n            if (idFormat != null) {\n                s.append(String.format(idFormat, as.getAccession()));\n            }\n            for (int i = 0; i < getLength(); i += width) {\n                int start = i + 1, end = Math.min(getLength(), i + width);\n                s.append(as.getSubSequence(start, end).getSequenceAsString());\n                s.append(String.format(\"%n\"));\n            }\n        }\n    }\n    if (webDisplay && aligConservation && sequences.size() == 2) {\n        s.append(IOUtils.getPDBLegend());\n    }\n    return s.toString();\n}", "repo_id": "9", "comment": "// creates formatted String\n", "repo_name": "biojava-master/", "id": 2679, "method_signature": "String toString(int, String, String, boolean, boolean, boolean, boolean)"}, "2669": {"callee_method_names": [], "method_name": "RNAToAminoAcidTranslator.translateNCodons", "method_implementation": "{\n    return translateNCodons;\n}", "repo_id": "9", "comment": "/**\n * Indicates if we want to force exact translation of compounds or not i.e.\n * those with internal N RNA bases. This will cause a translation to an X\n * amino acid\n */\n", "repo_name": "biojava-master/", "id": 2669, "method_signature": "boolean translateNCodons()"}, "354": {"callee_method_names": ["AminoAcid.getC", "AminoAcid.getN", "AminoAcid.getCA", "AminoAcid.getC"], "method_name": "Calc.getPhi", "method_implementation": "{\n    if (!isConnected(a, b)) {\n        throw new StructureException(\"can not calc Phi - AminoAcids are not connected!\");\n    }\n    Atom a_C = a.getC();\n    Atom b_N = b.getN();\n    Atom b_CA = b.getCA();\n    Atom b_C = b.getC();\n    // C and N were checked in isConnected already\n    if (b_CA == null)\n        throw new StructureException(\"Can not calculate Phi, CA atom is missing\");\n    return torsionAngle(a_C, b_N, b_CA, b_C);\n}", "repo_id": "9", "comment": "/**\n * Calculate the phi angle.\n *\n * @param a\n *            an AminoAcid object\n * @param b\n *            an AminoAcid object\n * @return a double\n * @throws StructureException\n *             if aminoacids not connected or if any of the 4 needed atoms\n *             missing\n */\n", "repo_name": "biojava-master/", "id": 354, "method_signature": "double getPhi(AminoAcid, AminoAcid)"}, "850": {"callee_method_ids": [849, 849, 847, 847, 847, 847], "callee_method_names": ["SparseVector.size", "SparseVector.size", "SparseVector.contains", "SparseVector.get", "SparseVector.get", "SparseVector.contains", "SparseVector.get", "SparseVector.get"], "method_name": "SparseVector.dot", "method_implementation": "{\n    SparseVector a = this;\n    if (a.N != b.N)\n        throw new IllegalArgumentException(\"Vector lengths disagree. \" + a.N + \" != \" + b.N);\n    double sum = 0.0;\n    // iterate over the vector with the fewest nonzeros\n    if (a.symbolTable.size() <= b.symbolTable.size()) {\n        for (int i : a.symbolTable) if (b.symbolTable.contains(i))\n            sum += a.get(i) * b.get(i);\n    } else {\n        for (int i : b.symbolTable) if (a.symbolTable.contains(i))\n            sum += a.get(i) * b.get(i);\n    }\n    return sum;\n}", "repo_id": "9", "comment": "/**\n * Calculates the dot product of this vector a with b\n *\n * @param b\n * @return\n */\n", "repo_name": "biojava-master/", "id": 850, "method_signature": "double dot(SparseVector)"}, "3370": {"callee_method_names": ["ColorSpace.getNumComponents", "ColorSpace.getNumComponents"], "method_name": "LinearColorInterpolator.setColorSpace", "method_implementation": "{\n    if (dir.length < colorSpace.getNumComponents()) {\n        throw new IllegalArgumentException(\"Must specify an interpolation \" + \"direction for each colorspace component (\" + colorSpace.getNumComponents() + \")\");\n    }\n    this.colorSpace = colorSpace;\n    this.interpolationDirection = dir;\n}", "repo_id": "9", "comment": "/**\n * Sets the ColorSpace to use for interpolation.\n *\n * The most common scheme for color spaces is to use linear components\n * between 0 and 1 (for instance red,green,blue). For such a component, a\n * linear interpolation between two colors is used.\n *\n * Sometimes a component may be in cylindrical coordinates. In this case,\n * the component can be mapped in a number of ways. These are set by\n * InterpolationDirections.\n *\n * @param colorSpace The color space for interpolation\n * @param interpDirection An array of size colorSpace.getNumComponents()\n * \t\tgiving the interpolation direction for each component.\n */\n", "repo_name": "biojava-master/", "id": 3370, "method_signature": "void setColorSpace(ColorSpace, InterpolationDirection[])"}, "1454": {"callee_method_names": ["List<Matrix4d>.get"], "method_name": "SpaceGroup.calcAxisFoldTypes", "method_implementation": "{\n    axisTypes = new int[multiplicity];\n    for (int i = 0; i < this.transformations.size(); i++) {\n        axisTypes[i] = getRotAxisType(transformations.get(i));\n    }\n}", "repo_id": "9", "comment": "/**\n * Calculates the axis fold type (1, 2, 3, 4, 5, 6 for rotations or -1, -2, -3, -4, -6 improper rotations)\n * from the trace of the rotation matrix, see for instance\n * http://www.crystallography.fr/mathcryst/pdf/Gargnano/Aroyo_Gargnano_1.pdf\n */\n", "repo_name": "biojava-master/", "id": 1454, "method_signature": "void calcAxisFoldTypes()"}, "2049": {"callee_method_names": ["MultipleAlignment.size", "MultipleAlignment.putScore", "MultipleAlignment.putScore"], "method_name": "SymmetryTools.updateSymmetryScores", "method_implementation": "{\n    // Multiply by the order of symmetry to normalize score\n    double tmScore = MultipleAlignmentScorer.getAvgTMScore(symm) * symm.size();\n    double rmsd = MultipleAlignmentScorer.getRMSD(symm);\n    symm.putScore(MultipleAlignmentScorer.AVGTM_SCORE, tmScore);\n    symm.putScore(MultipleAlignmentScorer.RMSD, rmsd);\n}", "repo_id": "9", "comment": "/**\n * Update the scores (TM-score and RMSD) of a symmetry multiple alignment.\n * This method does not redo the superposition of the alignment.\n *\n * @param symm\n *            Symmetry Multiple Alignment of Repeats\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2049, "method_signature": "void updateSymmetryScores(MultipleAlignment)"}, "3723": {"callee_method_names": ["LinkedHashMap.put"], "method_name": "WorkSheet.markMetaDataRow", "method_implementation": "{\n    metaDataRowsHashMap.put(row, row);\n}", "repo_id": "9", "comment": "/**\n * @param row\n */\n", "repo_name": "biojava-master/", "id": 3723, "method_signature": "void markMetaDataRow(String)"}, "3361": {"callee_method_names": [], "method_name": "GradientMapper.getInterpolator", "method_implementation": "{\n    return interpolator;\n}", "repo_id": "9", "comment": "/**\n * @return the interpolator\n */\n", "repo_name": "biojava-master/", "id": 3361, "method_signature": "ColorInterpolator getInterpolator()"}, "2015": {"callee_method_names": [], "method_name": "SphereSampler.pind", "method_implementation": "{\n    return (sigma == 0) ? ind * delta : Math.sinh(sigma * ind * delta) / sigma;\n}", "repo_id": "9", "comment": "// unit sphere.\n", "repo_name": "biojava-master/", "id": 2015, "method_signature": "double pind(double, double, double)"}, "1681": {"callee_method_names": ["AtomPositionMap.getNavMap", "Iterator<Entry<ResidueNumber, Integer>>.hasNext", "Iterator<Entry<ResidueNumber, Integer>>.hasNext", "Iterator<Entry<ResidueNumber, Integer>>.next", "Entry<ResidueNumber, Integer>.getKey", "Entry<ResidueNumber, Integer>.getKey"], "method_name": "ResidueRange.iterator", "method_implementation": "{\n    //Use Entries to guarentee not null\n    final Iterator<Entry<ResidueNumber, Integer>> entryIt = map.getNavMap().entrySet().iterator();\n    if (!entryIt.hasNext()) {\n        // empty iterator\n        return Arrays.asList(new ResidueNumber[0]).iterator();\n    }\n    // Peek at upcoming entry\n    return new Iterator<ResidueNumber>() {\n\n        Entry<ResidueNumber, Integer> next = loadNext();\n\n        private Entry<ResidueNumber, Integer> loadNext() {\n            while (entryIt.hasNext()) {\n                next = entryIt.next();\n                ResidueNumber nextPos = next.getKey();\n                if (contains(nextPos, map)) {\n                    // loaded a valid next value\n                    return next;\n                }\n            }\n            next = null;\n            return next;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        @Override\n        public ResidueNumber next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            ResidueNumber pos = next.getKey();\n            loadNext();\n            return pos;\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Not modifiable\");\n        }\n    };\n}", "repo_id": "9", "comment": "/**\n * Returns a new Iterator over every {@link ResidueNumber} in this ResidueRange.\n * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n */\n", "repo_name": "biojava-master/", "id": 1681, "method_signature": "Iterator<ResidueNumber> iterator(AtomPositionMap)"}, "1520": {"callee_method_names": ["Matrix4d.setRotationScale"], "method_name": "Matrices.getRotationMatrix", "method_implementation": "{\n    Matrix3d rot = new Matrix3d();\n    transform.setRotationScale(rot);\n    return rot;\n}", "repo_id": "9", "comment": "/**\n * Convert a transformation matrix into a rotation matrix.\n *\n * @param transform\n *            Matrix4d\n * @return rotation matrix\n */\n", "repo_name": "biojava-master/", "id": 1520, "method_signature": "Matrix3d getRotationMatrix(Matrix4d)"}, "3727": {"callee_method_ids": [3701], "callee_method_names": ["LinkedHashMap.get", "HeaderInfo.setHide"], "method_name": "WorkSheet.hideRow", "method_implementation": "{\n    HeaderInfo rowInfo = rowLookup.get(row);\n    rowInfo.setHide(hide);\n}", "repo_id": "9", "comment": "/**\n * @param row\n * @param hide\n */\n", "repo_name": "biojava-master/", "id": 3727, "method_signature": "void hideRow(String, boolean)"}, "2402": {"callee_method_names": [], "method_name": "Location.window", "method_implementation": "{\n    final Location loc = this;\n    //return iterable anonymous inner class\n    return new Iterable<Location>() {\n\n        @Override\n        public LocIterator iterator() {\n            return new LocIterator(loc, windowSize, increment);\n        }\n    };\n}", "repo_id": "9", "comment": "/**\n *  Enable a \"sliding window\" iteration over a location\n *  to use with Java's \"for\" loop construct.\n *  The returned helper object implements the Iterable interface; the windowSize and increment semantics are implemented\n *  by an underlying LocIterator.\n *  <br><br>\n *  For example, given a location variable \"loc\":\n * <br>\n * <pre>\n * \t//use window size of 3 and increment of +3\n * \tfor( Location temp: loc.window( 3, 3 ))\n * \t{\n * \t//at each iteration, temp will be the location of the next 3 symbols\n * \t}\n * </pre>\n *\n *  @param windowSize The number of symbols to get on each iteration.\n *  @param increment The direction and number of symbols to advance at each iteration.\n *  @return An anonymous iterable object to use with Java's for( ... ) loop construct.\n */\n", "repo_name": "biojava-master/", "id": 2402, "method_signature": "Iterable<Location> window(int, int)"}, "400": {"callee_method_names": [], "method_name": "GroupIterator.hasNext", "method_implementation": "{\n    return hasSubGroup(current_model_pos, current_chain_pos, current_group_pos + 1);\n}", "repo_id": "9", "comment": "/**\n * is there a group after the current one in the structure?\n */\n", "repo_name": "biojava-master/", "id": 400, "method_signature": "boolean hasNext()"}, "3141": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.getUniprotDirectoryCache", "method_implementation": "{\n    return uniprotDirectoryCache;\n}", "repo_id": "9", "comment": "/**\n * Local directory cache of XML that can be downloaded\n * @return the uniprotDirectoryCache\n */\n", "repo_name": "biojava-master/", "id": 3141, "method_signature": "String getUniprotDirectoryCache()"}, "186": {"callee_method_ids": [641, 1633, 1623, 628, 1929], "callee_method_names": ["AtomCache.setFiletype", "List<String>.add", "List<String>.add", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "Map<String, String>.put", "List<Map<String, String>>.add", "List<String>.add", "List<String>.add", "Map<String, String>.put", "Map<String, String>.put", "Map<String, String>.put", "List<Map<String, String>>.add", "SubunitClustererParameters.setClustererMethod", "SubunitClustererParameters.setSequenceIdentityThreshold", "List<String>.size", "Logger.info", "List<String>.get", "AtomCache.getStructure", "List<String>.get", "List<String>.get", "QuatSymmetryResults.getSymmetry", "List<String>.get", "List<String>.get", "QuatSymmetryResults.getStoichiometry", "List<Map<String, String>>.get", "Logger.info", "boolean.getStoichiometry", "boolean.getSymmetry", "boolean.getStoichiometry", "List<String>.get", "Map<String, String>.containsKey", "boolean.getStoichiometry", "boolean.getSymmetry", "boolean.getStoichiometry", "List<String>.get", "Map<String, String>.get", "boolean.getStoichiometry", "boolean.getSymmetry"], "method_name": "TestQuatSymmetryDetectorExamples.testLocal", "method_implementation": "{\n    AtomCache atomCache = new AtomCache();\n    atomCache.setFiletype(StructureFiletype.MMTF);\n    List<String> testIds = new ArrayList<>();\n    List<String> testStoichiometries = new ArrayList<>();\n    List<Map<String, String>> testLocalSymmetries = new ArrayList<>();\n    Map<String, String> localSymmetries;\n    testIds.add(\"BIO:5NUQ:1\");\n    testStoichiometries.add(\"A3B\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"A3\", \"C3\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:4P2C:1\");\n    testStoichiometries.add(\"A5B5C\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"A5B5\", \"C5\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:3J96:1\");\n    testStoichiometries.add(\"A6B4CDE\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"B4\", \"C4\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:5WVK:1\");\n    testStoichiometries.add(\"A2B2C2D2E2F2G2H2I2J2K2L2M2N2OPQRSTUVWXYZabcdef\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"A2B2C2D2E2F2G2H2I2J2K2L2M2N2\", \"C2\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:5JXT:1\");\n    testStoichiometries.add(\"A16\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"A8\", \"D2\");\n    testLocalSymmetries.add(localSymmetries);\n    /* Bioassembly for 3R8R changed in January 2020 (PR #867)\n\t\ttestIds.add(\"BIO:3R8R:1\");\n\t\t\ttestStoichiometries.add(\"A12\");\n\t\t\tlocalSymmetries = new HashMap<>();\n\t\t\t\tlocalSymmetries.put(\"A10\",\"D5\");\n\t\t\ttestLocalSymmetries.add(localSymmetries);*/\n    testIds.add(\"BIO:1O18:1\");\n    testStoichiometries.add(\"A14B6C5D5\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"A14\", \"H\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:4A8A:1\");\n    testStoichiometries.add(\"A12B\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"A12\", \"T\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:5DN6:1\");\n    testStoichiometries.add(\"A12B3C3DEFGHIJKL\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"B3C3\", \"C3\");\n    localSymmetries.put(\"A12\", \"C12\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:5FL7:1\");\n    testStoichiometries.add(\"A10B3C3DE\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"B3C3\", \"C3\");\n    localSymmetries.put(\"A10\", \"C10\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:2OF5:1\");\n    testStoichiometries.add(\"A7B5\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"A7\", \"H\");\n    localSymmetries.put(\"A5B5\", \"H\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:6EM9:1\");\n    testStoichiometries.add(\"A8B2\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"B2\", \"C2\");\n    localSymmetries.put(\"A7\", \"H\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:4NTP:1\");\n    testStoichiometries.add(\"A16\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"A2\", \"C2\");\n    localSymmetries.put(\"A6\", \"D3\");\n    testLocalSymmetries.add(localSymmetries);\n    testIds.add(\"BIO:3JC9:1\");\n    testStoichiometries.add(\"A12B12C12D12E12F12G5H2\");\n    localSymmetries = new HashMap<>();\n    localSymmetries.put(\"A12B12C12D12E12H2\", \"C2\");\n    localSymmetries.put(\"A12B12C12D12E12F12\", \"C12\");\n    localSymmetries.put(\"G5\", \"H\");\n    testLocalSymmetries.add(localSymmetries);\n    QuatSymmetryParameters symmParams = new QuatSymmetryParameters();\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters(true);\n    clusterParams.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n    clusterParams.setSequenceIdentityThreshold(0.75);\n    for (int iTest = 0; iTest < testIds.size(); iTest++) {\n        logger.info(\"Processing \" + testIds.get(iTest));\n        Structure pdb = atomCache.getStructure(testIds.get(iTest));\n        Stoichiometry composition = SubunitClusterer.cluster(pdb, clusterParams);\n        // no global symmetry\n        QuatSymmetryResults globalSymmetry = QuatSymmetryDetector.calcGlobalSymmetry(composition, symmParams);\n        assertEquals(\"Unexpected global symmetry in \" + testIds.get(iTest), \"C1\", globalSymmetry.getSymmetry());\n        assertEquals(\"Unexpected global stoichiometry in \" + testIds.get(iTest), testStoichiometries.get(iTest), globalSymmetry.getStoichiometry().toString());\n        List<QuatSymmetryResults> foundLocal = QuatSymmetryDetector.calcLocalSymmetries(composition, symmParams);\n        Map<String, String> refLocal = testLocalSymmetries.get(iTest);\n        for (QuatSymmetryResults local : foundLocal) {\n            logger.info(\"Found stoichiometry \" + local.getStoichiometry().toString() + \" with symmetry \" + local.getSymmetry());\n            assertTrue(\"Stoichiometry \" + local.getStoichiometry().toString() + \" not expected for \" + testIds.get(iTest), refLocal.containsKey(local.getStoichiometry().toString()));\n            assertEquals(\"Symmetry \" + local.getSymmetry() + \" with stoichiometry \" + local.getStoichiometry().toString() + \" not expected for \" + testIds.get(iTest), refLocal.get(local.getStoichiometry().toString()), local.getSymmetry());\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * A selection of structures with no global symmetry, but local symmetry\n *\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 186, "method_signature": "void testLocal()"}, "211": {"callee_method_names": ["Matcher.replaceAll"], "method_name": "SequenceUtil.cleanSequence", "method_implementation": "{\n    assert sequence != null;\n    final Matcher m = SequenceUtil.WHITE_SPACE.matcher(sequence);\n    sequence = m.replaceAll(\"\").toUpperCase();\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Removes all whitespace chars in the sequence string\n *\n * @param sequence\n * @return cleaned up sequence\n */\n", "repo_name": "biojava-master/", "id": 211, "method_signature": "String cleanSequence(String)"}, "3018": {"callee_method_names": [], "method_name": "AbstractReference.setAuthors", "method_implementation": "{\n    this.authors = authors;\n}", "repo_id": "9", "comment": "/**\n * Set The authors are a list of Inventors that retrieved from the Reference section.\n *\n * @param authors\n */\n", "repo_name": "biojava-master/", "id": 3018, "method_signature": "void setAuthors(String)"}, "1076": {"callee_method_ids": [1097], "callee_method_names": ["DownloadChemCompProvider.getChemComp", "Path.resolve", "Path.toFile", "File.delete"], "method_name": "ZipChemCompProvider.downloadAndAdd", "method_implementation": "{\n    final ChemComp cc = m_dlProvider.getChemComp(recordName);\n    // final File [] files = finder(m_tempDir.resolve(\"chemcomp\").toString(), \"cif.gz\");\n    final File[] files = new File[1];\n    Path cif = m_tempDir.resolve(\"chemcomp\").resolve(recordName + \".cif.gz\");\n    files[0] = cif.toFile();\n    if (files[0] != null) {\n        addToZipFileSystem(m_zipFile, files, m_zipRootDir);\n        if (m_removeCif)\n            for (File f : files) f.delete();\n    }\n    return cc;\n}", "repo_id": "9", "comment": "/**\n * Use DownloadChemCompProvider to grab a gzipped cif record from the PDB.\n *  Zip all downloaded cif.gz files into the dictionary.\n *\n * @param recordName is the three-letter chemical component code (i.e. residue name).\n * @return ChemComp matching recordName\n */\n", "repo_name": "biojava-master/", "id": 1076, "method_signature": "ChemComp downloadAndAdd(String)"}, "1148": {"callee_method_names": ["Bond.getAtomA", "Bond.getAtomB", "SSBondImpl.setChainID1", "Bond.getAtomA", "SSBondImpl.setChainID2", "Bond.getAtomB", "SSBondImpl.setResnum1", "Bond.getAtomA", "SSBondImpl.setResnum2", "Bond.getAtomB", "Bond.getAtomA", "Bond.getAtomB", "SSBondImpl.setInsCode1", "SSBondImpl.setInsCode2"], "method_name": "SSBondImpl.toSsBond", "method_implementation": "{\n    if (!\"CYS\".equals(bond.getAtomA().getGroup().getPDBName()) || !\"CYS\".equals(bond.getAtomB().getGroup().getPDBName())) {\n        throw new IllegalArgumentException(\"Trying to create a SSBond from a Bond between 2 groups that are not CYS\");\n    }\n    SSBondImpl ssbond = new SSBondImpl();\n    ssbond.setChainID1(bond.getAtomA().getGroup().getChainId());\n    ssbond.setChainID2(bond.getAtomB().getGroup().getChainId());\n    ssbond.setResnum1(String.valueOf(bond.getAtomA().getGroup().getResidueNumber().getSeqNum()));\n    ssbond.setResnum2(String.valueOf(bond.getAtomB().getGroup().getResidueNumber().getSeqNum()));\n    Character iCode1 = bond.getAtomA().getGroup().getResidueNumber().getInsCode();\n    if (iCode1 == null)\n        iCode1 = ' ';\n    Character iCode2 = bond.getAtomB().getGroup().getResidueNumber().getInsCode();\n    if (iCode2 == null)\n        iCode2 = ' ';\n    ssbond.setInsCode1(String.valueOf(iCode1));\n    ssbond.setInsCode2(String.valueOf(iCode2));\n    return ssbond;\n}", "repo_id": "9", "comment": "/**\n * Converts the given {@link Bond} object into a {@link SSBondImpl}.\n *\n * @return\n * @throws IllegalArgumentException if this Bond is not between two CYS residues\n */\n", "repo_name": "biojava-master/", "id": 1148, "method_signature": "SSBondImpl toSsBond(Bond)"}, "2891": {"callee_method_names": ["Sequence<C>.getAsList", "Sequence<C>.getCompoundSet"], "method_name": "SequenceMixin.shuffle", "method_implementation": "{\n    List<C> compounds = sequence.getAsList();\n    Collections.shuffle(compounds);\n    return new ArrayListSequenceReader<C>(compounds, sequence.getCompoundSet());\n}", "repo_id": "9", "comment": "/**\n * Implements sequence shuffling by first materializing the given\n * {@link Sequence} into a {@link List}, applying\n * {@link Collections#shuffle(List)} and then returning the shuffled\n * elements in a new instance of {@link SequenceBackingStore} which behaves\n * as a {@link Sequence}.\n */\n", "repo_name": "biojava-master/", "id": 2891, "method_signature": "Sequence<C> shuffle(Sequence)"}, "3209": {"callee_method_names": ["BlastTabularParser.setFile"], "method_name": "BlastTabularParserTest.testSetFile", "method_implementation": "{\n    System.out.println(\"setFile\");\n    File f = null;\n    BlastTabularParser instance = new BlastTabularParser();\n    instance.setFile(f);\n}", "repo_id": "9", "comment": "/**\n * Test of setFile method, of class BlastTabularParser.\n */\n", "repo_name": "biojava-master/", "id": 3209, "method_signature": "void testSetFile()"}, "2116": {"callee_method_names": [], "method_name": "StructureImpl.findGroup", "method_implementation": "{\n    return findGroup(chainName, pdbResnum, 0);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2116, "method_signature": "Group findGroup(String, String)"}, "221": {"callee_method_names": [], "method_name": "ProteinModificationImpl.setPdbccId", "method_implementation": "{\n    this.pdbccId = pdbccId;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the Protein Data Bank Chemical Component ID.\n * @param pdbccId Protein Data Bank Chemical Component ID.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 221, "method_signature": "Builder setPdbccId(String)"}, "3533": {"callee_method_names": [], "method_name": "CoxCoefficient.getRobustStdError", "method_implementation": "{\n    return robustStdError;\n}", "repo_id": "9", "comment": "/**\n * @return the robustStdError\n */\n", "repo_name": "biojava-master/", "id": 3533, "method_signature": "double getRobustStdError()"}, "2176": {"callee_method_ids": [465, 465, 465, 465, 465, 465, 465, 465, 465], "callee_method_names": ["StructureName.isPdbId", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isPdbId", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isPdbId", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isScopName", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isCathID", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isURL", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isURL", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isEcodDomain", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isBioAssembly", "StructureName.getSource", "StructureName.getPdbId"], "method_name": "TestStructureName.testGuesses", "method_implementation": "{\n    StructureName sn;\n    // Basic case\n    sn = new StructureName(\"4hhb\");\n    assertTrue(sn.isPdbId());\n    assertTrue(sn.getSource() == PDB);\n    assertEquals(new PdbId(\"4HHB\"), sn.getPdbId());\n    sn = new StructureName(\"4hhb.A:1-50\");\n    assertTrue(sn.isPdbId());\n    assertTrue(sn.getSource() == PDB);\n    assertEquals(new PdbId(\"4HHB\"), sn.getPdbId());\n    // Invalid strings should NOT work.\n    sn = new StructureName(\"x\");\n    assertTrue(sn.isPdbId());\n    assertTrue(sn.getSource() == PDB);\n    assertEquals(null, sn.getPdbId());\n    // SCOP\n    sn = new StructureName(\"d2gs2a_\");\n    assertTrue(sn.isScopName());\n    assertTrue(sn.getSource() == SCOP);\n    assertEquals(new PdbId(\"2GS2\"), sn.getPdbId());\n    // CATH\n    sn = new StructureName(\"1qvrC03\");\n    assertTrue(sn.isCathID());\n    assertTrue(sn.getSource() == CATH);\n    assertEquals(new PdbId(\"1QVR\"), sn.getPdbId());\n    // URL\n    sn = new StructureName(\"http://www.rcsb.org/pdb/files/1B8G.pdb.gz\");\n    assertTrue(sn.isURL());\n    assertTrue(sn.getSource() == URL);\n    assertEquals(new PdbId(\"1B8G\"), sn.getPdbId());\n    sn = new StructureName(\"file:///4hhb.pdb\");\n    assertTrue(sn.isURL());\n    assertTrue(sn.getSource() == URL);\n    assertEquals(new PdbId(\"4HHB\"), sn.getPdbId());\n    // Files are hard to test, since they rely on existing files\n    // You can run these tests locally after updating the hard-coded paths\n    //sn = new StructureName(\"~/pdb/4hhb.pdb\");\n    //assertTrue(sn.isFile());\n    //assertTrue(sn.getSource() == FILE);\n    //assertEquals(\"4HHB\",sn.getPdbId());\n    //sn = new StructureName(\"/Users/blivens/pdb/4hhb.pdb\");\n    //assertTrue(sn.isFile());\n    //assertTrue(sn.getSource() == FILE);\n    //assertEquals(\"4HHB\",sn.getPdbId());\n    //sn = new StructureName(\"~/pdb/1f9m-1.pdb\");\n    //assertTrue(sn.isFile());\n    //assertTrue(sn.getSource() == FILE);\n    //assertEquals(\"1F9M\",sn.getPdbId());\n    // ECOD\n    sn = new StructureName(\"e1lyw.1\");\n    assertTrue(sn.isEcodDomain());\n    assertTrue(sn.getSource() == ECOD);\n    assertEquals(new PdbId(\"1LYW\"), sn.getPdbId());\n    // BIO is not guessed\n    sn = new StructureName(\"2ehz:1\");\n    assertFalse(sn.isBioAssembly());\n    assertTrue(sn.getSource() == PDB);\n    //Not Guessed\n    assertEquals(null, sn.getPdbId());\n}", "repo_id": "9", "comment": "/**\n * Test without prefixes\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2176, "method_signature": "void testGuesses()"}, "2970": {"callee_method_names": ["ArrayList.clear", "ArrayList.add"], "method_name": "ArrayListSequenceReader.setContents", "method_implementation": "{\n    parsedCompounds.clear();\n    for (C c : list) {\n        parsedCompounds.add(c);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param list\n */\n", "repo_name": "biojava-master/", "id": 2970, "method_signature": "void setContents(List)"}, "3285": {"callee_method_ids": [487, 490, 489], "callee_method_names": ["AFPChain.getBlockNum", "AFPChain.getOptLen", "AFPChain.getOptAln", "List<String>.add"], "method_name": "DisplayAFP.getPDBresnum", "method_implementation": "{\n    List<String> lst = new ArrayList<String>();\n    if (aligPos > 1) {\n        System.err.println(\"multiple alignments not supported yet!\");\n        return lst;\n    }\n    int blockNum = afpChain.getBlockNum();\n    int[] optLen = afpChain.getOptLen();\n    int[][][] optAln = afpChain.getOptAln();\n    if (optLen == null)\n        return lst;\n    for (int bk = 0; bk < blockNum; bk++) {\n        for (int i = 0; i < optLen[bk]; i++) {\n            int pos = optAln[bk][aligPos][i];\n            if (pos < ca.length) {\n                String pdbInfo = JmolTools.getPdbInfo(ca[pos]);\n                //lst.add(ca1[pos].getParent().getPDBCode());\n                lst.add(pdbInfo);\n            }\n        }\n    }\n    return lst;\n}", "repo_id": "9", "comment": "/**\n * Return a list of pdb Strings corresponding to the aligned positions of the molecule.\n * Only supports a pairwise alignment with the AFPChain DS.\n *\n * @param aligPos\n * @param afpChain\n * @param ca\n */\n", "repo_name": "biojava-master/", "id": 3285, "method_signature": "List<String> getPDBresnum(int, AFPChain, Atom[])"}, "117": {"callee_method_names": ["NeedlemanWunsch<DNASequence, NucleotideCompound>.addAnchor", "NeedlemanWunsch<DNASequence, NucleotideCompound>.getPair"], "method_name": "NeedlemanWunschTest.should_align_ending_anchor", "method_implementation": "{\n    DNASequence query = new DNASequence(\"AAG\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"AATT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    NeedlemanWunsch<DNASequence, NucleotideCompound> aligner = new NeedlemanWunsch<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 0, (short) 10), SubstitutionMatrixHelper.getNuc4_4());\n    aligner.addAnchor(2, 3);\n    assertEquals(String.format(\"AA-G%nAATT%n\"), aligner.getPair().toString());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 117, "method_signature": "void should_align_ending_anchor()"}, "2025": {"callee_method_names": [], "method_name": "Prism.getSideLengthFromCircumscribedRadius", "method_implementation": "{\n    if (n == 2) {\n        return radius;\n    }\n    return radius * (2 * Math.sin(Math.PI / n));\n}", "repo_id": "9", "comment": "// http://www.mathopenref.com/polygonradius.html\n", "repo_name": "biojava-master/", "id": 2025, "method_signature": "double getSideLengthFromCircumscribedRadius(double, int)"}, "1015": {"callee_method_names": ["Iterator<Group>.hasNext", "Iterator<Group>.next", "Group.size"], "method_name": "StructureTools.getNrAtoms", "method_implementation": "{\n    int nrAtoms = 0;\n    Iterator<Group> iter = new GroupIterator(s);\n    while (iter.hasNext()) {\n        Group g = iter.next();\n        nrAtoms += g.size();\n    }\n    return nrAtoms;\n}", "repo_id": "9", "comment": "/**\n * Count how many Atoms are contained within a Structure object.\n *\n * @param s\n *            the structure object\n * @return the number of Atoms in this Structure\n */\n", "repo_name": "biojava-master/", "id": 1015, "method_signature": "int getNrAtoms(Structure)"}, "3614": {"callee_method_names": ["LinkedHashMap.size"], "method_name": "CoxInfo.getNumberCoefficients", "method_implementation": "{\n    return coefficientsList.size();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3614, "method_signature": "int getNumberCoefficients()"}, "1244": {"callee_method_ids": [1451], "callee_method_names": ["SpaceGroup.getShortSymbol"], "method_name": "MmtfUtils.getSpaceGroupAsString", "method_implementation": "{\n    if (spaceGroup == null) {\n        return \"NA\";\n    } else {\n        return spaceGroup.getShortSymbol();\n    }\n}", "repo_id": "9", "comment": "/**\n * Get the string representation of a space group.\n * @param spaceGroup the input SpaceGroup object\n * @return the space group as a string.\n */\n", "repo_name": "biojava-master/", "id": 1244, "method_signature": "String getSpaceGroupAsString(SpaceGroup)"}, "1953": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setRmsdIntra", "method_implementation": "{\n    this.rmsdIntra = rmsdIntra;\n}", "repo_id": "9", "comment": "/**\n * @param rmsdIntra the rmsdIntra to set\n */\n", "repo_name": "biojava-master/", "id": 1953, "method_signature": "void setRmsdIntra(double)"}, "1447": {"callee_method_names": ["String.length", "String.substring", "String.substring", "HashMap<String, SpaceGroup>.get"], "method_name": "SymoplibParser.getSpaceGroup", "method_implementation": "{\n    if (shortName == null || shortName.length() <= 2)\n        return null;\n    // PDB uses group \"P 1-\" for 13 racemic mixture entries (as of Sep2011), e.g. 3e7r\n    // they call the space group \"P 1-\" unusually (symop.lib and everyone else call it \"P -1\")\n    if (\"P 1-\".equals(shortName))\n        shortName = \"P -1\";\n    // enantiomorphic space groups contain sometime letters indicating glide planes which should always be lower case\n    // in some PDB entries like 4gwv they are in upper case, we fix that here: convert any non-first letter to lower case\n    shortName = shortName.substring(0, 1) + shortName.substring(1).toLowerCase();\n    return name2sgs.get(shortName);\n}", "repo_id": "9", "comment": "/**\n * Get the space group for the given international short name, using\n * the PDB format, e.g. 'P 21 21 21' or 'C 1 c 1'\n * @param shortName\n * @return the SpaceGroup or null if the shortName is not valid\n */\n", "repo_name": "biojava-master/", "id": 1447, "method_signature": "SpaceGroup getSpaceGroup(String)"}, "2410": {"callee_method_names": [], "method_name": "Location.downstream", "method_implementation": "{\n    if (length < 0) {\n        throw new IllegalArgumentException(\"Parameter must be >= 0; is=\" + length);\n    }\n    if (Math.signum(mEnd + length) == Math.signum(mEnd) || 0 == Math.signum(mEnd + length)) {\n        return new Location(mEnd, mEnd + length);\n    } else {\n        throw new IndexOutOfBoundsException(\"Specified length causes crossing of origin: \" + length + \"; \" + toString());\n    }\n}", "repo_id": "9", "comment": "/**\n * Return the adjacent location of specified length directly downstream of this location.\n *\n * @return The downstream location.\n * @param length The length of the downstream location.\n * @throws IndexOutOfBoundsException Specified length causes crossing of origin.\n */\n", "repo_name": "biojava-master/", "id": 2410, "method_signature": "Location downstream(int)"}, "2486": {"callee_method_names": ["GeneChromosomePosition.getOrientation"], "method_name": "ChromosomeMappingTools.getChromosomalRangesForCDS", "method_implementation": "{\n    if (chromPos.getOrientation() == '+')\n        return getCDSExonRangesForward(chromPos, CHROMOSOME);\n    return getCDSExonRangesReverse(chromPos, CHROMOSOME);\n}", "repo_id": "9", "comment": "/**\n * Extracts the boundaries of the coding regions in chromosomal coordinates\n *\n * @param chromPos\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2486, "method_signature": "List<Range<Integer>> getChromosomalRangesForCDS(GeneChromosomePosition)"}, "261": {"callee_method_names": ["Map<String, Set<ProteinModification>>.keySet"], "method_name": "ProteinModificationRegistry.allPsimodIds", "method_implementation": "{\n    lazyInit();\n    Set<String> ret = byPsimodId.keySet();\n    return Collections.unmodifiableSet(ret);\n}", "repo_id": "9", "comment": "/**\n * @return set of PSI-MOD IDs of all registered ProteinModifications.\n */\n", "repo_name": "biojava-master/", "id": 261, "method_signature": "Set<String> allPsimodIds()"}, "167": {"callee_method_ids": [1556, 1556, 1556, 1556, 1556, 1556, 1556], "callee_method_names": ["ScopDatabase.getDomainsForPDB", "List<ScopDomain>.size", "List<ScopDomain>.get", "List<ScopDomain>.get", "List<ScopDomain>.get", "List<ScopDomain>.get", "ScopDatabase.getScopNode", "List<ScopDomain>.get", "ScopDatabase.getScopDescriptionBySunid", "ScopNode.getSunid", "ScopNode.getSunid", "ScopDescription.getName", "ScopDescription.getDescription", "ScopDescription.getClassificationId", "ScopDatabase.getScopNode", "ScopNode.getParentSunid", "ScopDatabase.getScopDescriptionBySunid", "ScopNode.getSunid", "ScopNode.getSunid", "ScopDescription.getName", "ScopDescription.getDescription", "ScopDescription.getClassificationId", "ScopDatabase.getScopNode", "ScopNode.getParentSunid", "ScopDatabase.getScopDescriptionBySunid", "ScopNode.getSunid", "ScopNode.getSunid", "ScopDescription.getName", "ScopDescription.getDescription", "ScopDescription.getClassificationId", "ScopDatabase.getScopNode", "ScopNode.getParentSunid", "ScopDatabase.getScopDescriptionBySunid", "ScopNode.getSunid", "ScopNode.getSunid", "ScopDescription.getName", "ScopDescription.getDescription", "ScopDescription.getClassificationId", "ScopDatabase.getScopNode", "ScopNode.getParentSunid", "ScopDatabase.getScopDescriptionBySunid", "ScopNode.getSunid", "ScopNode.getSunid", "ScopDescription.getName", "ScopDescription.getDescription", "ScopDescription.getClassificationId", "ScopDatabase.getScopNode", "ScopNode.getParentSunid", "ScopDatabase.getScopDescriptionBySunid", "ScopNode.getSunid", "ScopNode.getSunid", "ScopDescription.getName", "ScopDescription.getDescription", "ScopDescription.getClassificationId", "ScopDatabase.getScopNode", "ScopNode.getParentSunid", "ScopDatabase.getScopDescriptionBySunid", "ScopNode.getSunid", "ScopNode.getSunid", "ScopDescription.getName", "ScopDescription.getDescription", "ScopDescription.getClassificationId", "ScopDatabase.getScopNode", "ScopNode.getParentSunid", "ScopDatabase.getScopDescriptionBySunid", "ScopNode.getSunid", "ScopNode.getSunid"], "method_name": "ScopDatabaseTest.traverseHierarchy", "method_implementation": "{\n    String pdbId = \"4HHB\";\n    List<ScopDomain> domains = scop.getDomainsForPDB(pdbId);\n    assertEquals(tag + \"Wrong number of domains\", 4, domains.size());\n    // Check domains (order doesn't matter)\n    assertEquals(tag + \"Wrong domain\", \"d4hhba_\", domains.get(0).getScopId());\n    assertEquals(tag + \"Wrong domain\", \"d4hhbb_\", domains.get(2).getScopId());\n    assertEquals(tag + \"Wrong domain\", \"d4hhbc_\", domains.get(1).getScopId());\n    assertEquals(tag + \"Wrong domain\", \"d4hhbd_\", domains.get(3).getScopId());\n    // Check the heirarchy\n    ScopNode node = scop.getScopNode(domains.get(0).getSunid());\n    ScopDescription desc = scop.getScopDescriptionBySunid(node.getSunid());\n    assertEquals(tag, 15251, node.getSunid());\n    assertEquals(tag, \"d4hhba_\", desc.getName());\n    assertEquals(tag, \"4hhb A:\", desc.getDescription());\n    assertEquals(tag, \"a.1.1.2\", desc.getClassificationId());\n    node = scop.getScopNode(node.getParentSunid());\n    desc = scop.getScopDescriptionBySunid(node.getSunid());\n    assertEquals(tag, 46487, node.getSunid());\n    assertEquals(tag, \"-\", desc.getName());\n    assertTrue(tag, Pattern.matches(\"Human \\\\(Homo sapiens\\\\)( \\\\[TaxId: 9606\\\\])?\", desc.getDescription()));\n    assertEquals(tag, \"a.1.1.2\", desc.getClassificationId());\n    node = scop.getScopNode(node.getParentSunid());\n    desc = scop.getScopDescriptionBySunid(node.getSunid());\n    assertEquals(tag, 46486, node.getSunid());\n    assertEquals(tag, \"-\", desc.getName());\n    assertEquals(tag, \"Hemoglobin, alpha-chain\", desc.getDescription());\n    assertEquals(tag, \"a.1.1.2\", desc.getClassificationId());\n    node = scop.getScopNode(node.getParentSunid());\n    desc = scop.getScopDescriptionBySunid(node.getSunid());\n    assertEquals(tag, 46463, node.getSunid());\n    assertEquals(tag, \"-\", desc.getName());\n    assertEquals(tag, \"Globins\", desc.getDescription());\n    assertEquals(tag, \"a.1.1.2\", desc.getClassificationId());\n    node = scop.getScopNode(node.getParentSunid());\n    desc = scop.getScopDescriptionBySunid(node.getSunid());\n    assertEquals(tag, 46458, node.getSunid());\n    assertEquals(tag, \"-\", desc.getName());\n    assertEquals(tag, \"Globin-like\", desc.getDescription());\n    assertEquals(tag, \"a.1.1\", desc.getClassificationId());\n    node = scop.getScopNode(node.getParentSunid());\n    desc = scop.getScopDescriptionBySunid(node.getSunid());\n    assertEquals(tag, 46457, node.getSunid());\n    assertEquals(tag, \"-\", desc.getName());\n    assertEquals(tag, \"Globin-like\", desc.getDescription());\n    assertEquals(tag, \"a.1\", desc.getClassificationId());\n    node = scop.getScopNode(node.getParentSunid());\n    desc = scop.getScopDescriptionBySunid(node.getSunid());\n    assertEquals(tag, 46456, node.getSunid());\n    assertEquals(tag, \"-\", desc.getName());\n    assertEquals(tag, \"All alpha proteins\", desc.getDescription());\n    assertEquals(tag, \"a\", desc.getClassificationId());\n    // root node\n    node = scop.getScopNode(node.getParentSunid());\n    desc = scop.getScopDescriptionBySunid(node.getSunid());\n    assertEquals(tag, 0, node.getSunid());\n    assertNull(tag + \"Root should not have a description\", desc);\n}", "repo_id": "9", "comment": "/**\n * Traverse through the SCOP hierarchy\n */\n", "repo_name": "biojava-master/", "id": 167, "method_signature": "void traverseHierarchy()"}, "2519": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum100", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum100\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 100 matrix by Henikoff & Henikoff\n * @return Blosum 100 matrix\n */\n", "repo_name": "biojava-master/", "id": 2519, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum100()"}, "685": {"callee_method_names": ["List<Atom[]>.size", "List<Integer>.size", "List<Atom[]>.get", "List<Atom[]>.size", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.get", "List<Integer>.get", "List<Integer>.get"], "method_name": "MultipleAlignmentScorer.getRefTMScore", "method_implementation": "{\n    if (transformed.size() != lengths.size())\n        throw new IllegalArgumentException(\"Input sizes differ\");\n    double sumTM = 0;\n    int comparisons = 0;\n    int len = transformed.get(reference).length;\n    for (int r = 0; r < transformed.size(); r++) {\n        if (r == reference)\n            continue;\n        // remove nulls from both arrays\n        Atom[] ref = new Atom[len];\n        Atom[] aln = new Atom[len];\n        int nonNullLen = 0;\n        for (int c = 0; c < len; c++) {\n            if (transformed.get(reference)[c] != null && transformed.get(r)[c] != null) {\n                ref[nonNullLen] = transformed.get(reference)[c];\n                aln[nonNullLen] = transformed.get(r)[c];\n                nonNullLen++;\n            }\n        }\n        // truncate nulls\n        if (nonNullLen < len) {\n            ref = Arrays.copyOf(ref, nonNullLen);\n            aln = Arrays.copyOf(aln, nonNullLen);\n        }\n        sumTM += Calc.getTMScore(ref, aln, lengths.get(reference), lengths.get(r));\n        comparisons++;\n    }\n    return sumTM / comparisons;\n}", "repo_id": "9", "comment": "/**\n * Calculates the average TMScore from all structures to a reference\n * structure, given a set of superimposed atoms.\n * <p>\n * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n * length.\n *\n * @param transformed\n *            Arrays of aligned atoms, after superposition\n * @param lengths\n *            lengths of the full input structures\n * @param reference\n *            Index of the reference structure\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 685, "method_signature": "double getRefTMScore(List, List, int)"}, "2904": {"callee_method_names": [], "method_name": "AbstractSequence.getUserCollection", "method_implementation": "{\n    return userCollection;\n}", "repo_id": "9", "comment": "/**\n * Provided for convince if the developer needs to associate data with a sequence\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2904, "method_signature": "Collection<Object> getUserCollection()"}, "3498": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.getBlastFromPosition", "method_implementation": "{\n    return Integer.parseInt(getAlignmentOption(QUERY_FROM));\n}", "repo_id": "9", "comment": "/**\n * @return an integer value for the QUERY_FROM parameter\n * @see #setBlastFromToPosition(int, int)\n */\n", "repo_name": "biojava-master/", "id": 3498, "method_signature": "int getBlastFromPosition()"}, "3010": {"callee_method_names": [], "method_name": "BitArrayWorker.getIndexToCompoundsLookup", "method_implementation": "{\n    if (indexToCompoundsLookup == null) {\n        indexToCompoundsLookup = generateIndexToCompounds();\n    }\n    return indexToCompoundsLookup;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of compounds the index position of which is used\n * to translate from the byte representation into a compound.\n */\n", "repo_name": "biojava-master/", "id": 3010, "method_signature": "List<C> getIndexToCompoundsLookup()"}, "3672": {"callee_method_names": [], "method_name": "SurvivalInfo.setOrder", "method_implementation": "{\n    this.order = order;\n}", "repo_id": "9", "comment": "/**\n * @param order the order to set\n */\n", "repo_name": "biojava-master/", "id": 3672, "method_signature": "void setOrder(int)"}, "1861": {"callee_method_names": [], "method_name": "Rotation.getFold", "method_implementation": "{\n    return fold;\n}", "repo_id": "9", "comment": "/**\n * @return the fold\n */\n", "repo_name": "biojava-master/", "id": 1861, "method_signature": "int getFold()"}, "3712": {"callee_method_names": [], "method_name": "WorkSheet.hideMetaDataColumns", "method_implementation": "{\n    ArrayList<String> metadataColumns = this.getMetaDataColumns();\n    for (String column : metadataColumns) {\n        this.hideColumn(column, value);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 3712, "method_signature": "void hideMetaDataColumns(boolean)"}, "1114": {"callee_method_names": ["Element.getAttribute", "Element.getAttribute", "Element.getAttribute", "Element.getElementsByTagName", "NodeList.getLength", "NodeList.getLength", "NodeList.item", "Element.getElementsByTagName", "NodeList.getLength", "NodeList.getLength", "NodeList.item", "SiftsSegment.addResidue"], "method_name": "SiftsXMLParser.getSiftsSegment", "method_implementation": "{\n    String segId = el.getAttribute(\"segId\");\n    String start = el.getAttribute(\"start\");\n    String end = el.getAttribute(\"end\");\n    SiftsSegment seg = new SiftsSegment(segId, start, end);\n    if (debug)\n        System.out.println(\"parsed \" + seg);\n    // get nodelist of segments...\n    NodeList nl = el.getElementsByTagName(\"listResidue\");\n    if (nl != null && nl.getLength() > 0) {\n        for (int i = 0; i < nl.getLength(); i++) {\n            //get the entity element\n            Element listResidueEl = (Element) nl.item(i);\n            NodeList residueNodes = listResidueEl.getElementsByTagName(\"residue\");\n            if (residueNodes != null && residueNodes.getLength() > 0) {\n                for (int j = 0; j < residueNodes.getLength(); j++) {\n                    Element residue = (Element) residueNodes.item(j);\n                    SiftsResidue pos = getResidue(residue);\n                    seg.addResidue(pos);\n                }\n            }\n        }\n    }\n    return seg;\n}", "repo_id": "9", "comment": "/**\n * segId=\"4hhb_A_1_140\" start=\"1\" end=\"140\"\n *\n * @param el\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1114, "method_signature": "SiftsSegment getSiftsSegment(Element)"}, "2254": {"callee_method_names": ["Structure.addChain", "Chain.addGroup", "Chain.addGroup", "Chain.addGroup"], "method_name": "TestMmtfUtils.testGetNumGroups", "method_implementation": "{\n    Structure structure = new StructureImpl();\n    Chain chain = new ChainImpl();\n    Group groupOne = new AminoAcidImpl();\n    Group groupTwo = new HetatomImpl();\n    Group groupThree = new NucleotideImpl();\n    structure.addChain(chain);\n    chain.addGroup(groupOne);\n    chain.addGroup(groupTwo);\n    chain.addGroup(groupThree);\n    assertEquals(3, MmtfUtils.getNumGroups(structure));\n}", "repo_id": "9", "comment": "/**\n * Test getting the number of groups from a structure.\n */\n", "repo_name": "biojava-master/", "id": 2254, "method_signature": "void testGetNumGroups()"}, "3135": {"callee_method_names": ["String.length", "StringBuilder.length", "String.toUpperCase", "Logger.info", "StringBuilder.indexOf", "StringBuilder.indexOf", "StringBuilder.replace", "String.length", "Logger.info", "StringBuilder.toString", "Logger.error", "StringBuilder.toString"], "method_name": "UniprotProxySequenceReader.getUniprotXML", "method_implementation": "{\n    StringBuilder sb = new StringBuilder();\n    // try in cache\n    if (uniprotDirectoryCache != null && uniprotDirectoryCache.length() > 0) {\n        sb = fetchFromCache(accession);\n    }\n    // http://www.uniprot.org/uniprot/?query=SORBIDRAFT_03g027040&format=xml\n    if (sb.length() == 0) {\n        String uniprotURL = getUniprotbaseURL() + \"/uniprot/\" + accession.toUpperCase() + \".xml\";\n        logger.info(\"Loading: {}\", uniprotURL);\n        sb = fetchUniprotXML(uniprotURL);\n        //strip out name space stuff to make it easier on xpath\n        int index = sb.indexOf(\"xmlns=\");\n        if (index != -1) {\n            int lastIndex = sb.indexOf(\">\", index);\n            sb.replace(index, lastIndex, \"\");\n        }\n        if (uniprotDirectoryCache != null && uniprotDirectoryCache.length() > 0)\n            writeCache(sb, accession);\n    }\n    logger.info(\"Load complete\");\n    try {\n        //       logger.debug(sb.toString());\n        Document document = XMLHelper.inputStreamToDocument(new ByteArrayInputStream(sb.toString().getBytes()));\n        return document;\n    } catch (SAXException | ParserConfigurationException e) {\n        logger.error(\"Exception on xml parse of: {}\", sb.toString());\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * @param accession\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 3135, "method_signature": "Document getUniprotXML(String)"}, "3563": {"callee_method_ids": [3610, 3673, 3675, 3655, 3667, 3667, 3667, 3657, 3659, 3654, 3632, 3641, 3634, 3631, 3606, 3531, 3531, 3532, 3531, 3532, 3531, 3532, 3531, 3532, 3616, 3530], "callee_method_names": ["String.indexOf", "String.split", "CoxInfo.setSurvivalInfoList", "ArrayList<SurvivalInfo>.size", "ArrayList<String>.size", "ArrayList<SurvivalInfo>.get", "SurvivalInfo.getTime", "SurvivalInfo.getStatus", "SurvivalInfo.getOffset", "SurvivalInfo.getClusterValue", "SurvivalInfo.getClusterValue", "SurvivalInfo.toString", "ArrayList<String>.add", "SurvivalInfo.getClusterValue", "SurvivalInfo.getWeight", "SurvivalInfo.getStrata", "ArrayList<String>.size", "ArrayList<String>.get", "SurvivalInfo.getVariable", "CoxInfo.setScoreLogrankTest", "CoxInfo.setDegreeFreedom", "CoxInfo.setScoreLogrankTestpvalue", "CoxInfo.getScoreLogrankTest", "CoxInfo.setVariance", "ArrayList<String>.get", "CoxCoefficient.getCoeff", "CoxCoefficient.getCoeff", "CoxCoefficient.getStdError", "CoxCoefficient.getCoeff", "CoxCoefficient.getStdError", "CoxCoefficient.getCoeff", "CoxCoefficient.getStdError", "CoxCoefficient.getCoeff", "CoxCoefficient.getStdError", "CoxInfo.setCoefficient", "CoxCoefficient.getName"], "method_name": "CoxR.process", "method_implementation": "{\n    //make sure data is converted to numbers if labels are used\n    SurvivalInfoHelper.categorizeData(data);\n    //create variables if testing for interaction\n    for (String variable : variables) {\n        if (variable.indexOf(\":\") != -1) {\n            String[] d = variable.split(\":\");\n            SurvivalInfoHelper.addInteraction(d[0], d[1], data);\n        }\n    }\n    Collections.sort(data);\n    // Collections.reverse(data);\n    CoxInfo coxInfo = new CoxInfo();\n    coxInfo.setSurvivalInfoList(data);\n    int i, j, k, person;\n    boolean gotofinish = false;\n    double[][] cmat, imat;\n    /*ragged arrays covar[][], */\n    double wtave;\n    double[] a, newbeta;\n    double[] a2;\n    double[][] cmat2;\n    double[] scale;\n    double denom = 0, zbeta, risk;\n    double temp, temp2;\n    int ndead;\n    /* actually, the sum of their weights */\n    double newlk = 0;\n    double dtime, d2;\n    double deadwt;\n    /*sum of case weights for the deaths*/\n    double efronwt;\n    /* sum of weighted risk scores for the deaths*/\n    int halving;\n    /*are we doing step halving at the moment? */\n    @SuppressWarnings(\"unused\")\n    int nrisk = 0;\n    /* number of subjects in the current risk set */\n    /* copies of scalar input arguments */\n    int nused, nvar;\n    /* vector inputs */\n    //  double *time, *weights, *offset;\n    //  int *status, *strata;\n    /* returned objects */\n    // double imat2[][];\n    double[] u, loglik, means;\n    double sctest;\n    int flag = 0;\n    int iter = 0;\n    //SEXP rlist, rlistnames;\n    //  int nprotect;  /* number of protect calls I have issued */\n    /* get local copies of some input args */\n    // LENGTH(offset2);\n    nused = data.size();\n    // ncols(covar2);\n    nvar = variables.size();\n    //       imat2 = new double[nvar][nvar];\n    //        nprotect++;\n    //dmatrix(REAL(imat2),  nvar, nvar);\n    imat = new double[nvar][nvar];\n    //(double *) R_alloc(2*nvar*nvar + 4*nvar, sizeof(double));\n    a = new double[nvar];\n    //a + nvar;\n    newbeta = new double[nvar];\n    //newbeta + nvar;\n    a2 = new double[nvar];\n    //a2 + nvar;\n    scale = new double[nvar];\n    //dmatrix(scale + nvar,   nvar, nvar);\n    cmat = new double[nvar][nvar];\n    //dmatrix(scale + nvar +nvar*nvar, nvar, nvar);\n    cmat2 = new double[nvar][nvar];\n    /*\n\t\t ** create output variables\n\t\t */\n    //    PROTECT(beta2 = duplicate(ibeta));\n    //    beta = REAL(beta2);\n    //  beta = new double[nvar];\n    // beta = beta2;\n    //  PROTECT(means2 = allocVector(REALSXP, nvar));\n    //  means = REAL(means2);\n    means = new double[nvar];\n    double[] sd = new double[nvar];\n    //double[] se = new double[nvar];\n    //   means = means2;\n    //   PROTECT(u2 = allocVector(REALSXP, nvar));\n    //   u = REAL(u2);\n    u = new double[nvar];\n    //   u = u2;\n    //    PROTECT(loglik2 = allocVector(REALSXP, 2));\n    //    loglik = REAL(loglik2);\n    loglik = new double[2];\n    //   loglik = loglik2;\n    //    PROTECT(sctest2 = allocVector(REALSXP, 1));\n    //    sctest = REAL(sctest2);\n    //        sctest = new double[1];\n    //   sctest = sctest2;\n    //    PROTECT(flag2 = allocVector(INTSXP, 1));\n    //    flag = INTEGER(flag2);\n    //        flag = new int[1];\n    //     flag = flag2;\n    //    PROTECT(iter2 = allocVector(INTSXP, 1));\n    //    iterations = INTEGER(iter2);\n    //        iterations = new int[1];\n    //        iterations = iter2;\n    //       nprotect += 7;\n    /*\n\t\t ** Subtract the mean from each covar, as this makes the regression\n\t\t **  much more stable.\n\t\t */\n    double[] time = new double[nused];\n    int[] status = new int[nused];\n    double[] offset = new double[nused];\n    double[] weights = new double[nused];\n    int[] strata = new int[nused];\n    double[][] covar = new double[nvar][nused];\n    ArrayList<String> clusterList = null;\n    if (cluster) {\n        clusterList = new ArrayList<String>();\n    }\n    //copy data over to local arrays to minimuze changing code\n    for (person = 0; person < nused; person++) {\n        SurvivalInfo si = data.get(person);\n        time[person] = si.getTime();\n        status[person] = si.getStatus();\n        offset[person] = si.getOffset();\n        if (cluster) {\n            if (si.getClusterValue() == null && si.getClusterValue().length() == 0) {\n                throw new Exception(\"Cluster value is not valid for \" + si.toString());\n            }\n            clusterList.add(si.getClusterValue());\n        }\n        if (useWeighted) {\n            weights[person] = si.getWeight();\n        } else {\n            weights[person] = 1.0;\n        }\n        if (useStrata) {\n            strata[person] = si.getStrata();\n        } else {\n            strata[person] = 0;\n        }\n        for (i = 0; i < variables.size(); i++) {\n            String variable = variables.get(i);\n            covar[i][person] = si.getVariable(variable);\n        }\n    }\n    double tempsd = 0;\n    i = 0;\n    for (i = 0; i < nvar; i++) {\n        temp = 0;\n        tempsd = 0;\n        //calculate the mean sd\n        for (person = 0; person < nused; person++) {\n            // * weights[person];\n            temp += covar[i][person];\n            //*weights[person] * weights[person]\n            tempsd += (covar[i][person]) * (covar[i][person]);\n        }\n        temp /= nused;\n        //   temp /= weightCount;\n        means[i] = temp;\n        tempsd /= nused;\n        //  tempsd /= weightCount;\n        tempsd = Math.sqrt(tempsd - temp * temp);\n        //standard deviation\n        sd[i] = tempsd;\n        //subtract the mean\n        for (person = 0; person < nused; person++) {\n            covar[i][person] -= temp;\n        }\n        if (doscale == 1) {\n            /* and also scale it */\n            temp = 0;\n            for (person = 0; person < nused; person++) {\n                //fabs\n                temp += Math.abs(covar[i][person]);\n            }\n            if (temp > 0) {\n                temp = nused / temp;\n                /* scaling */\n            } else {\n                temp = 1.0;\n                /* rare case of a constant covariate */\n            }\n            scale[i] = temp;\n            for (person = 0; person < nused; person++) {\n                covar[i][person] *= temp;\n            }\n        }\n    }\n    if (doscale == 1) {\n        for (i = 0; i < nvar; i++) {\n            beta[i] /= scale[i];\n            /*rescale initial betas */\n        }\n    } else {\n        for (i = 0; i < nvar; i++) {\n            scale[i] = 1.0;\n        }\n    }\n    /*\n\t\t ** do the initial iteration step\n\t\t */\n    strata[nused - 1] = 1;\n    loglik[1] = 0;\n    for (i = 0; i < nvar; i++) {\n        //u = s1\n        u[i] = 0;\n        //a2 = a\n        a2[i] = 0;\n        for (j = 0; j < nvar; j++) {\n            //s2\n            imat[i][j] = 0;\n            //a\n            cmat2[i][j] = 0;\n        }\n    }\n    for (person = nused - 1; person >= 0; ) {\n        if (strata[person] == 1) {\n            nrisk = 0;\n            denom = 0;\n            for (i = 0; i < nvar; i++) {\n                a[i] = 0;\n                for (j = 0; j < nvar; j++) {\n                    cmat[i][j] = 0;\n                }\n            }\n        }\n        dtime = time[person];\n        ndead = 0;\n        /*number of deaths at this time point */\n        deadwt = 0;\n        /* sum of weights for the deaths */\n        efronwt = 0;\n        /* sum of weighted risks for the deaths */\n        while (person >= 0 && time[person] == dtime) {\n            /* walk through the this set of tied times */\n            nrisk++;\n            zbeta = offset[person];\n            /* form the term beta*z (vector mult) */\n            for (i = 0; i < nvar; i++) {\n                //x\n                zbeta += beta[i] * covar[i][person];\n            }\n            zbeta = coxsafe(zbeta);\n            //risk = v\n            risk = Math.exp(zbeta) * weights[person];\n            denom += risk;\n            /* a is the vector of weighted sums of x, cmat sums of squares */\n            for (i = 0; i < nvar; i++) {\n                //a = s1\n                a[i] += risk * covar[i][person];\n                for (j = 0; j <= i; j++) {\n                    //cmat = s2;\n                    cmat[i][j] += risk * covar[i][person] * covar[j][person];\n                }\n            }\n            if (status[person] == 1) {\n                ndead++;\n                deadwt += weights[person];\n                efronwt += risk;\n                loglik[1] += weights[person] * zbeta;\n                for (i = 0; i < nvar; i++) {\n                    u[i] += weights[person] * covar[i][person];\n                }\n                if (method == CoxMethod.Efron) {\n                    /* Efron */\n                    for (i = 0; i < nvar; i++) {\n                        a2[i] += risk * covar[i][person];\n                        for (j = 0; j <= i; j++) {\n                            cmat2[i][j] += risk * covar[i][person] * covar[j][person];\n                        }\n                    }\n                }\n            }\n            person--;\n            if (person >= 0 && strata[person] == 1) {\n                //added catch of person = 0 and person-- = -1\n                break;\n                /*ties don't cross strata */\n            }\n        }\n        if (ndead > 0) {\n            /* we need to add to the main terms */\n            if (method == CoxMethod.Breslow) {\n                /* Breslow */\n                loglik[1] -= deadwt * Math.log(denom);\n                for (i = 0; i < nvar; i++) {\n                    temp2 = a[i] / denom;\n                    /* mean */\n                    u[i] -= deadwt * temp2;\n                    for (j = 0; j <= i; j++) {\n                        imat[j][i] += deadwt * (cmat[i][j] - temp2 * a[j]) / denom;\n                    }\n                }\n            } else {\n                /* Efron */\n                /*\n\t\t\t\t\t ** If there are 3 deaths we have 3 terms: in the first the\n\t\t\t\t\t **  three deaths are all in, in the second they are 2/3\n\t\t\t\t\t **  in the sums, and in the last 1/3 in the sum.  Let k go\n\t\t\t\t\t **  from 0 to (ndead -1), then we will sequentially use\n\t\t\t\t\t **     denom - (k/ndead)*efronwt as the denominator\n\t\t\t\t\t **     a - (k/ndead)*a2 as the \"a\" term\n\t\t\t\t\t **     cmat - (k/ndead)*cmat2 as the \"cmat\" term\n\t\t\t\t\t **  and reprise the equations just above.\n\t\t\t\t\t */\n                for (k = 0; k < ndead; k++) {\n                    temp = (double) k / ndead;\n                    wtave = deadwt / ndead;\n                    d2 = denom - temp * efronwt;\n                    loglik[1] -= wtave * Math.log(d2);\n                    for (i = 0; i < nvar; i++) {\n                        temp2 = (a[i] - temp * a2[i]) / d2;\n                        u[i] -= wtave * temp2;\n                        for (j = 0; j <= i; j++) {\n                            imat[j][i] += (wtave / d2) * ((cmat[i][j] - temp * cmat2[i][j]) - temp2 * (a[j] - temp * a2[j]));\n                        }\n                    }\n                }\n                for (i = 0; i < nvar; i++) {\n                    a2[i] = 0;\n                    for (j = 0; j < nvar; j++) {\n                        cmat2[i][j] = 0;\n                    }\n                }\n            }\n        }\n    }\n    /* end  of accumulation loop */\n    loglik[0] = loglik[1];\n    /* save the loglik for iterations 0 */\n    /* am I done?\n\t\t **   update the betas and test for convergence\n\t\t */\n    for (i = 0; i < nvar; i++) /*use 'a' as a temp to save u0, for the score test*/\n    {\n        a[i] = u[i];\n    }\n    flag = Cholesky2.process(imat, nvar, toler);\n    chsolve2(imat, nvar, a);\n    /* a replaced by  a *inverse(i) */\n    temp = 0;\n    for (i = 0; i < nvar; i++) {\n        temp += u[i] * a[i];\n    }\n    sctest = temp;\n    /* score test */\n    /*\n\t\t **  Never, never complain about convergence on the first step.  That way,\n\t\t **  if someone HAS to they can force one iterations at a time.\n\t\t */\n    for (i = 0; i < nvar; i++) {\n        newbeta[i] = beta[i] + a[i];\n    }\n    if (maxiter == 0) {\n        chinv2(imat, nvar);\n        for (i = 0; i < nvar; i++) {\n            beta[i] *= scale[i];\n            /*return to original scale */\n            u[i] /= scale[i];\n            imat[i][i] *= scale[i] * scale[i];\n            for (j = 0; j < i; j++) {\n                imat[j][i] *= scale[i] * scale[j];\n                imat[i][j] = imat[j][i];\n            }\n        }\n        // goto finish;\n        gotofinish = true;\n    }\n    /*\n\t\t ** here is the main loop\n\t\t */\n    if (!gotofinish) {\n        halving = 0;\n        /* =1 when in the midst of \"step halving\" */\n        for (iter = 1; iter <= maxiter; iter++) {\n            newlk = 0;\n            for (i = 0; i < nvar; i++) {\n                u[i] = 0;\n                for (j = 0; j < nvar; j++) {\n                    imat[i][j] = 0;\n                }\n            }\n            /*\n\t\t\t\t ** The data is sorted from smallest time to largest\n\t\t\t\t ** Start at the largest time, accumulating the risk set 1 by 1\n\t\t\t\t */\n            for (person = nused - 1; person >= 0; ) {\n                if (strata[person] == 1) {\n                    /* rezero temps for each strata */\n                    denom = 0;\n                    nrisk = 0;\n                    for (i = 0; i < nvar; i++) {\n                        a[i] = 0;\n                        for (j = 0; j < nvar; j++) {\n                            cmat[i][j] = 0;\n                        }\n                    }\n                }\n                dtime = time[person];\n                deadwt = 0;\n                ndead = 0;\n                efronwt = 0;\n                while (person >= 0 && time[person] == dtime) {\n                    nrisk++;\n                    zbeta = offset[person];\n                    for (i = 0; i < nvar; i++) {\n                        zbeta += newbeta[i] * covar[i][person];\n                    }\n                    zbeta = coxsafe(zbeta);\n                    risk = Math.exp(zbeta) * weights[person];\n                    denom += risk;\n                    for (i = 0; i < nvar; i++) {\n                        a[i] += risk * covar[i][person];\n                        for (j = 0; j <= i; j++) {\n                            cmat[i][j] += risk * covar[i][person] * covar[j][person];\n                        }\n                    }\n                    if (status[person] == 1) {\n                        ndead++;\n                        deadwt += weights[person];\n                        newlk += weights[person] * zbeta;\n                        for (i = 0; i < nvar; i++) {\n                            u[i] += weights[person] * covar[i][person];\n                        }\n                        if (method == CoxMethod.Efron) {\n                            /* Efron */\n                            efronwt += risk;\n                            for (i = 0; i < nvar; i++) {\n                                a2[i] += risk * covar[i][person];\n                                for (j = 0; j <= i; j++) {\n                                    cmat2[i][j] += risk * covar[i][person] * covar[j][person];\n                                }\n                            }\n                        }\n                    }\n                    person--;\n                    if (person >= 0 && strata[person] == 1) {\n                        //added catch of person = 0 and person-- = -1\n                        break;\n                        /*ties don't cross strata */\n                    }\n                }\n                if (ndead > 0) {\n                    /* add up terms*/\n                    if (method == CoxMethod.Breslow) {\n                        /* Breslow */\n                        newlk -= deadwt * Math.log(denom);\n                        for (i = 0; i < nvar; i++) {\n                            temp2 = a[i] / denom;\n                            /* mean */\n                            u[i] -= deadwt * temp2;\n                            for (j = 0; j <= i; j++) {\n                                imat[j][i] += (deadwt / denom) * (cmat[i][j] - temp2 * a[j]);\n                            }\n                        }\n                    } else {\n                        /* Efron */\n                        for (k = 0; k < ndead; k++) {\n                            temp = (double) k / ndead;\n                            wtave = deadwt / ndead;\n                            d2 = denom - temp * efronwt;\n                            newlk -= wtave * Math.log(d2);\n                            for (i = 0; i < nvar; i++) {\n                                temp2 = (a[i] - temp * a2[i]) / d2;\n                                u[i] -= wtave * temp2;\n                                for (j = 0; j <= i; j++) {\n                                    imat[j][i] += (wtave / d2) * ((cmat[i][j] - temp * cmat2[i][j]) - temp2 * (a[j] - temp * a2[j]));\n                                }\n                            }\n                        }\n                        for (i = 0; i < nvar; i++) {\n                            /*in anticipation */\n                            a2[i] = 0;\n                            for (j = 0; j < nvar; j++) {\n                                cmat2[i][j] = 0;\n                            }\n                        }\n                    }\n                }\n            }\n            /* end  of accumulation loop  */\n            /* am I done?\n\t\t\t\t **   update the betas and test for convergence\n\t\t\t\t */\n            flag = Cholesky2.process(imat, nvar, toler);\n            if (Math.abs(1 - (loglik[1] / newlk)) <= eps && halving == 0) {\n                /* all done */\n                loglik[1] = newlk;\n                chinv2(imat, nvar);\n                /* invert the information matrix */\n                for (i = 0; i < nvar; i++) {\n                    beta[i] = newbeta[i] * scale[i];\n                    u[i] /= scale[i];\n                    imat[i][i] *= scale[i] * scale[i];\n                    for (j = 0; j < i; j++) {\n                        imat[j][i] *= scale[i] * scale[j];\n                        imat[i][j] = imat[j][i];\n                    }\n                }\n                //  goto finish;\n                gotofinish = true;\n                break;\n            }\n            if (iter == maxiter) {\n                break;\n                /*skip the step halving calc*/\n            }\n            if (newlk < loglik[1]) {\n                /*it is not converging ! */\n                halving = 1;\n                for (i = 0; i < nvar; i++) {\n                    newbeta[i] = (newbeta[i] + beta[i]) / 2;\n                    /*half of old increment */\n                }\n            } else {\n                halving = 0;\n                loglik[1] = newlk;\n                chsolve2(imat, nvar, u);\n                j = 0;\n                for (i = 0; i < nvar; i++) {\n                    beta[i] = newbeta[i];\n                    newbeta[i] = newbeta[i] + u[i];\n                }\n            }\n        }\n        /* return for another iteration */\n    }\n    if (!gotofinish) {\n        /*\n\t\t\t ** We end up here only if we ran out of iterations\n\t\t\t */\n        loglik[1] = newlk;\n        chinv2(imat, nvar);\n        for (i = 0; i < nvar; i++) {\n            beta[i] = newbeta[i] * scale[i];\n            u[i] /= scale[i];\n            imat[i][i] *= scale[i] * scale[i];\n            for (j = 0; j < i; j++) {\n                imat[j][i] *= scale[i] * scale[j];\n                imat[i][j] = imat[j][i];\n            }\n        }\n        flag = 1000;\n    }\n    //finish:\n    /*\n\t\t for (j = 0; j < numCovariates; j++) {\n\t\t b[j] = b[j] / SD[j];\n\t\t * ix = j * (numCovariates + 1) + j\n\t\t SE[j] = Math.sqrt(a[ix(j, j, numCovariates + 1)]) / SD[j];\n\t\t //            o = o + (\"   \" + variables.get(j) + \"    \" + Fmt(b[j]) + Fmt(SE[j]) + Fmt(Math.exp(b[j])) + Fmt(Norm(Math.abs(b[j] / SE[j]))) + Fmt(Math.exp(b[j] - 1.95 * SE[j])) + Fmt(Math.exp(b[j] + 1.95 * SE[j])) + NL);\n\t\t CoxCoefficient coe = coxInfo.getCoefficient(variables.get(j));\n\t\t coe.coeff = b[j];\n\t\t coe.stdError = SE[j];\n\t\t coe.hazardRatio = Math.exp(b[j]);\n\t\t coe.pvalue = Norm(Math.abs(b[j] / SE[j]));\n\t\t coe.hazardRatioLoCI = Math.exp(b[j] - 1.95 * SE[j]);\n\t\t coe.hazardRatioHiCI = Math.exp(b[j] + 1.95 * SE[j]);\n\t\t }\n\n\t\t */\n    coxInfo.setScoreLogrankTest(sctest);\n    coxInfo.setDegreeFreedom(beta.length);\n    coxInfo.setScoreLogrankTestpvalue(ChiSq.chiSq(coxInfo.getScoreLogrankTest(), beta.length));\n    coxInfo.setVariance(imat);\n    coxInfo.u = u;\n    //     for (int n = 0; n < beta.length; n++) {\n    //         se[n] = Math.sqrt(imat[n][n]); // / sd[n];\n    //     }\n    //       System.out.println(\"coef,se, means,u\");\n    for (int n = 0; n < beta.length; n++) {\n        CoxCoefficient coe = new CoxCoefficient();\n        coe.name = variables.get(n);\n        coe.mean = means[n];\n        coe.standardDeviation = sd[n];\n        coe.coeff = beta[n];\n        coe.stdError = Math.sqrt(imat[n][n]);\n        coe.hazardRatio = Math.exp(coe.getCoeff());\n        coe.z = coe.getCoeff() / coe.getStdError();\n        coe.pvalue = ChiSq.norm(Math.abs(coe.getCoeff() / coe.getStdError()));\n        double z = 1.959964;\n        coe.hazardRatioLoCI = Math.exp(coe.getCoeff() - z * coe.getStdError());\n        coe.hazardRatioHiCI = Math.exp(coe.getCoeff() + z * coe.getStdError());\n        coxInfo.setCoefficient(coe.getName(), coe);\n        // System.out.println(beta[n] + \",\" + se[n] + \",\" + means[n] + \",\" + sd[n] + \",\" + u[n]); //+ \",\" + imat[n] \",\" + loglik[n] + \",\" + sctest[n] + \",\" + iterations[n] + \",\" + flag[n]\n    }\n    coxInfo.maxIterations = maxiter;\n    coxInfo.eps = eps;\n    coxInfo.toler = toler;\n    coxInfo.iterations = iter;\n    coxInfo.flag = flag;\n    coxInfo.loglikInit = loglik[0];\n    coxInfo.loglikFinal = loglik[1];\n    coxInfo.method = method;\n    //    System.out.println(\"loglik[0]=\" + loglik[0]);\n    //    System.out.println(\"loglik[1]=\" + loglik[1]);\n    //    System.out.println(\"chisq? sctest[0]=\" + sctest[0]);\n    //    System.out.println(\"?overall model p-value=\" + chiSq(sctest[0], beta.length));\n    //      System.out.println();\n    //       for (int n = 0; n < covar[0].length; n++) {\n    //           System.out.print(n);\n    //           for (int variable = 0; variable < covar.length; variable++) {\n    //               System.out.print(\"\\t\" + covar[variable][n]);\n    //           }\n    //           System.out.println();\n    //       }\n    //      for (SurvivalInfo si : data) {\n    //          System.out.println(si.order + \" \" + si.getScore());\n    //      }\n    //        coxInfo.dump();\n    coxphfitSCleanup(coxInfo, useWeighted, robust, clusterList);\n    return coxInfo;\n}", "repo_id": "9", "comment": "/**\n * @param variables\n * @param data\n * @param maxiter\n * @param method\n * @param eps\n * @param toler\n * @param beta\n * @param doscale\n * @param useStrata\n * @param useWeighted\n * @param robust\n * @param cluster\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3563, "method_signature": "CoxInfo process(ArrayList, ArrayList, int, CoxMethod, double, double, double[], int, boolean, boolean, boolean, boolean)"}, "2840": {"callee_method_names": ["ArrayList<String>.get", "ArrayList<String>.size", "ArrayList<String>.get"], "method_name": "GenericGenbankHeaderFormat._write_multi_line", "method_implementation": "{\n    if (text == null) {\n        text = \"\";\n    }\n    int max_len = MAX_WIDTH - HEADER_WIDTH;\n    ArrayList<String> lines = _split_multi_line(text, max_len);\n    String output = _write_single_line(tag, lines.get(0));\n    for (int i = 1; i < lines.size(); i++) {\n        output += _write_single_line(\"\", lines.get(i));\n    }\n    return output;\n}", "repo_id": "9", "comment": "/**\n * Used in the the 'header' of each GenBank record.\n *\n * @param tag\n * @param text\n */\n", "repo_name": "biojava-master/", "id": 2840, "method_signature": "String _write_multi_line(String, String)"}, "911": {"callee_method_ids": [891, 891, 2583], "callee_method_names": ["List<StructureInterface>.size", "Logger.debug", "List<StructureInterface>.size", "List<StructureInterface>.size", "List<StructureInterface>.size", "List<StructureInterface>.size", "List<StructureInterface>.size", "List<StructureInterface>.get", "List<StructureInterface>.get", "StructureInterface.getContactOverlapScore", "StructureInterface.getContactOverlapScore", "Logger.debug", "List<StructureInterface>.size", "SingleLinkageClusterer.getClusters", "Map<Integer, Set<Integer>>.keySet", "Map<Integer, Set<Integer>>.get", "List<StructureInterface>.add", "List<StructureInterface>.get", "StructureInterfaceCluster.setMembers", "List<StructureInterface>.size", "List<StructureInterface>.indexOf", "List<StructureInterface>.get", "List<StructureInterface>.size", "List<StructureInterface>.indexOf", "List<StructureInterface>.get", "StructureInterfaceCluster.setAverageScore", "List<StructureInterfaceCluster>.add", "StructureInterfaceCluster.getMembers", "StructureInterface.setCluster", "Logger.debug", "List<StructureInterface>.size", "List<StructureInterfaceCluster>.size", "List<StructureInterfaceCluster>.sort", "StructureInterfaceCluster.setId"], "method_name": "StructureInterfaceList.getClusters", "method_implementation": "{\n    if (clusters != null) {\n        return clusters;\n    }\n    clusters = new ArrayList<>();\n    // nothing to do if we have no interfaces\n    if (list.size() == 0)\n        return clusters;\n    logger.debug(\"Calculating all-vs-all Jaccard scores for {} interfaces\", list.size());\n    double[][] matrix = new double[list.size()][list.size()];\n    for (int i = 0; i < list.size(); i++) {\n        for (int j = i + 1; j < list.size(); j++) {\n            StructureInterface iInterf = list.get(i);\n            StructureInterface jInterf = list.get(j);\n            double scoreDirect = iInterf.getContactOverlapScore(jInterf, false);\n            double scoreInvert = iInterf.getContactOverlapScore(jInterf, true);\n            double maxScore = Math.max(scoreDirect, scoreInvert);\n            matrix[i][j] = maxScore;\n        }\n    }\n    logger.debug(\"Will now cluster {} interfaces based on full all-vs-all Jaccard scores matrix\", list.size());\n    SingleLinkageClusterer slc = new SingleLinkageClusterer(matrix, true);\n    Map<Integer, Set<Integer>> clusteredIndices = slc.getClusters(contactOverlapScoreClusterCutoff);\n    for (int clusterIdx : clusteredIndices.keySet()) {\n        List<StructureInterface> members = new ArrayList<>();\n        for (int idx : clusteredIndices.get(clusterIdx)) {\n            members.add(list.get(idx));\n        }\n        StructureInterfaceCluster cluster = new StructureInterfaceCluster();\n        cluster.setMembers(members);\n        double averageScore = 0.0;\n        int countPairs = 0;\n        for (int i = 0; i < members.size(); i++) {\n            int iIdx = list.indexOf(members.get(i));\n            for (int j = i + 1; j < members.size(); j++) {\n                averageScore += matrix[iIdx][list.indexOf(members.get(j))];\n                countPairs++;\n            }\n        }\n        if (countPairs > 0) {\n            averageScore = averageScore / countPairs;\n        } else {\n            // if only one interface in cluster we set the score to the maximum\n            averageScore = 1.0;\n        }\n        cluster.setAverageScore(averageScore);\n        clusters.add(cluster);\n    }\n    // finally we have to set the back-references in each StructureInterface\n    for (StructureInterfaceCluster cluster : clusters) {\n        for (StructureInterface interf : cluster.getMembers()) {\n            interf.setCluster(cluster);\n        }\n    }\n    logger.debug(\"Done clustering {} interfaces based on full all-vs-all Jaccard scores matrix. Found a total of {} clusters\", list.size(), clusters.size());\n    // now we sort by areas (descending) and assign ids based on that sorting\n    //note we invert so that sorting is descending\n    clusters.sort((o1, o2) -> Double.compare(o2.getTotalArea(), o1.getTotalArea()));\n    int id = 1;\n    for (StructureInterfaceCluster cluster : clusters) {\n        cluster.setId(id);\n        id++;\n    }\n    return clusters;\n}", "repo_id": "9", "comment": "/**\n * Calculate the interface clusters for this StructureInterfaceList\n * using Jaccard contact set scores to measure the similarity of interfaces.\n * Subsequent calls will use the cached value without recomputing the clusters.\n * The clusters will be assigned ids by sorting descending by {@link StructureInterfaceCluster#getTotalArea()}\n * @param contactOverlapScoreClusterCutoff the contact overlap score above which a pair will be\n * clustered\n * @return\n */\n", "repo_name": "biojava-master/", "id": 911, "method_signature": "List<StructureInterfaceCluster> getClusters(double)"}, "2649": {"callee_method_names": ["Map<Frame, Sequence<AminoAcidCompound>>.get"], "method_name": "TranscriptionEngine.translate", "method_implementation": "{\n    Map<Frame, Sequence<AminoAcidCompound>> trans = multipleFrameTranslation(dna, Frame.ONE);\n    return trans.get(Frame.ONE);\n}", "repo_id": "9", "comment": "/**\n * Quick method to let you go from a CDS to a Peptide quickly. It assumes\n * you are translating only in the first frame\n *\n * @param dna\n *            The CDS to translate\n * @return The Protein Sequence\n */\n", "repo_name": "biojava-master/", "id": 2649, "method_signature": "Sequence<AminoAcidCompound> translate(Sequence)"}, "812": {"callee_method_names": [], "method_name": "AlternativeAlignment.setCluster", "method_implementation": "{\n    this.cluster = cluster;\n}", "repo_id": "9", "comment": "/**\n * set the number of the cluster this alignment belongs to.\n * All alignments in a cluster are quite similar.\n *\n * @param cluster the number of the cluster\n */\n", "repo_name": "biojava-master/", "id": 812, "method_signature": "void setCluster(int)"}, "1332": {"callee_method_names": [], "method_name": "FileParsingParameters.setCreateAtomCharges", "method_implementation": "{\n    this.createAtomCharges = createAtomCharges;\n}", "repo_id": "9", "comment": "/**\n * Should we create charges on atoms when parsing a file?\n *\n * @param createAtomCharges\n *            true if we should create the charges, false if not\n */\n", "repo_name": "biojava-master/", "id": 1332, "method_signature": "void setCreateAtomCharges(boolean)"}, "3070": {"callee_method_names": ["ExonSequence.getAccession", "ArrayList.remove", "LinkedHashMap.remove", "ArrayList.clear", "LinkedHashMap.clear", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "GeneSequence.removeExon", "method_implementation": "{\n    for (ExonSequence exonSequence : exonSequenceList) {\n        if (exonSequence.getAccession().getID().equals(accession)) {\n            exonSequenceList.remove(exonSequence);\n            exonSequenceHashMap.remove(accession);\n            // we now have a new gap which creates an intron\n            intronSequenceList.clear();\n            intronSequenceHashMap.clear();\n            intronAdded = false;\n            try {\n                addIntronsUsingExons();\n            } catch (Exception e) {\n                logger.error(\"Remove Exon validate() error \" + e.getMessage());\n            }\n            return exonSequence;\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Remove the exon sequence\n * @param accession\n * @return exon sequence\n */\n", "repo_name": "biojava-master/", "id": 3070, "method_signature": "ExonSequence removeExon(String)"}, "1719": {"callee_method_names": [], "method_name": "BasePairParameters.getPairingParameters", "method_implementation": "{\n    return pairingParameters;\n}", "repo_id": "9", "comment": "/**\n * This method reports all the pair parameters, in the order of:\n * buckle, propeller, opening (in degrees), shear, stagger, stretch (in \u00c5).\n * @return A double[][] with length equal to number of base pairs for rows, and 6 columns\n */\n", "repo_name": "biojava-master/", "id": 1719, "method_signature": "double[][] getPairingParameters()"}, "2005": {"callee_method_names": [], "method_name": "Octahedron.setMidRadius", "method_implementation": "{\n    double side = getSideLengthFromMiddleRadius(radius);\n    this.cirumscribedRadius = getCircumscribedRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Sets the radius of radius of a sphere, that is tangent to each\n * of the octahedron's edges\n * @param midRadius the midRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2005, "method_signature": "void setMidRadius(double)"}, "2591": {"callee_method_names": ["String.indexOf", "Element.getChildNodes", "NodeList.getLength", "NodeList.item", "Node.getNodeType", "Node.getNodeName", "ArrayList<Element>.add", "XPath.evaluate", "NodeList.getLength", "NodeList.item", "ArrayList<Element>.add"], "method_name": "XMLHelper.selectElements", "method_implementation": "{\n    ArrayList<Element> resultVector = new ArrayList<Element>();\n    if (element == null) {\n        return resultVector;\n    }\n    if (xpathExpression.indexOf(\"/\") == -1) {\n        NodeList nodeList = element.getChildNodes();\n        for (int i = 0; i < nodeList.getLength(); i++) {\n            Node node = nodeList.item(i);\n            if (node.getNodeType() == Node.ELEMENT_NODE && node.getNodeName().equals(xpathExpression)) {\n                resultVector.add((Element) node);\n            }\n        }\n    } else {\n        XPath xpath = XPathFactory.newInstance().newXPath();\n        NodeList nodes = (NodeList) xpath.evaluate(xpathExpression, element, XPathConstants.NODESET);\n        for (int i = 0; i < nodes.getLength(); i++) {\n            Node node = nodes.item(i);\n            resultVector.add((Element) node);\n        }\n    }\n    return resultVector;\n}", "repo_id": "9", "comment": "/**\n * Gets a list of elements matching {@code}xpathExpression{@code}. If xpathExpression lacks\n * a '/' character, only immediate children o {@code}element{@code} are searched over.\n * <br/>\n * If {@code}xpathExpression{@code} contains an '/' character, a full XPath search is made\n * @param element\n * @param xpathExpression\n * @return A possibly empty but non-null {@code}ArrayList{@code}\n * @throws XPathExpressionException\n */\n", "repo_name": "biojava-master/", "id": 2591, "method_signature": "ArrayList<Element> selectElements(Element, String)"}, "3269": {"callee_method_names": [], "method_name": "AbstractAlignmentJmol.getJmolPanel", "method_implementation": "{\n    return jmolPanel;\n}", "repo_id": "9", "comment": "/**\n * Return the jmolPanel instance of the AlignmentJmol.\n */\n", "repo_name": "biojava-master/", "id": 3269, "method_signature": "JmolPanel getJmolPanel()"}, "207": {"callee_method_names": ["String.length"], "method_name": "FastaSequence.getLength", "method_implementation": "{\n    return sequence.length();\n}", "repo_id": "9", "comment": "/**\n * @return sequence length\n */\n", "repo_name": "biojava-master/", "id": 207, "method_signature": "int getLength()"}, "2175": {"callee_method_ids": [465, 465, 465, 465, 465, 465, 465, 468, 465, 468, 465, 465, 465, 465, 465], "callee_method_names": ["StructureName.isPdbId", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isPdbId", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isPdbId", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isScopName", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isCathID", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isURL", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isURL", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isFile", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isFile", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isURL", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isEcodDomain", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isBioAssembly", "StructureName.getSource", "StructureName.getPdbId", "StructureName.isPdbId", "StructureName.getSource", "StructureName.getPdbId"], "method_name": "TestStructureName.testPrefixes", "method_implementation": "{\n    StructureName sn;\n    // Basic case\n    sn = new StructureName(\"PDB:4hhb\");\n    assertTrue(sn.isPdbId());\n    assertTrue(sn.getSource() == PDB);\n    assertEquals(new PdbId(\"4HHB\"), sn.getPdbId());\n    sn = new StructureName(\"PDB:4hhb.A:1-50\");\n    assertTrue(sn.isPdbId());\n    assertTrue(sn.getSource() == PDB);\n    assertEquals(new PdbId(\"4HHB\"), sn.getPdbId());\n    // Invalid strings work too, they just don't load\n    sn = new StructureName(\"PDB:x\");\n    assertTrue(sn.isPdbId());\n    assertTrue(sn.getSource() == PDB);\n    assertEquals(null, sn.getPdbId());\n    // SCOP\n    sn = new StructureName(\"SCOP:d2gs2a_\");\n    assertTrue(sn.isScopName());\n    assertTrue(sn.getSource() == SCOP);\n    assertEquals(new PdbId(\"2GS2\"), sn.getPdbId());\n    // CATH\n    sn = new StructureName(\"CATH:1qvrC03\");\n    assertTrue(sn.isCathID());\n    assertTrue(sn.getSource() == CATH);\n    assertEquals(new PdbId(\"1QVR\"), sn.getPdbId());\n    // URL\n    sn = new StructureName(\"URL:http://www.rcsb.org/pdb/files/1B8G.pdb.gz\");\n    assertTrue(sn.isURL());\n    assertTrue(sn.getSource() == URL);\n    assertEquals(new PdbId(\"1B8G\"), sn.getPdbId());\n    sn = new StructureName(\"URL:file:///4hhb.pdb\");\n    assertTrue(sn.isURL());\n    assertTrue(sn.getSource() == URL);\n    assertEquals(new PdbId(\"4HHB\"), sn.getPdbId());\n    // File: expand home directory (invalid URL)\n    sn = new StructureName(\"FILE:~/4hhb.pdb\");\n    assertTrue(sn.isFile());\n    assertTrue(sn.getSource() == FILE);\n    assertEquals(new PdbId(\"4HHB\"), sn.getPdbId());\n    // Relative file (invalid URL)\n    sn = new StructureName(\"file:4hhb.pdb\");\n    assertTrue(sn.isFile());\n    assertTrue(sn.getSource() == FILE);\n    assertEquals(new PdbId(\"4HHB\"), sn.getPdbId());\n    // Absolute paths are valid URLs\n    sn = new StructureName(\"file:/4hhb_other.pdb\");\n    assertTrue(sn.isURL());\n    assertTrue(sn.getSource() == URL);\n    assertEquals(new PdbId(\"4HHB\"), sn.getPdbId());\n    // ECOD\n    sn = new StructureName(\"e1lyw.1\");\n    assertTrue(sn.isEcodDomain());\n    assertTrue(sn.getSource() == ECOD);\n    assertEquals(new PdbId(\"1LYW\"), sn.getPdbId());\n    // BIO\n    sn = new StructureName(\"BIO:2ehz:1\");\n    assertTrue(sn.isBioAssembly());\n    assertTrue(sn.getSource() == BIO);\n    assertEquals(new PdbId(\"2EHZ\"), sn.getPdbId());\n    // Invalid prefix\n    sn = new StructureName(\"XXX:2ehz\");\n    assertTrue(sn.isPdbId());\n    assertTrue(sn.getSource() == PDB);\n    //\t\tassertEquals(\"XXX:2ehz\",sn.getPdbId());\n    // As long as it is EXPLICITLY defined to wrong type, it should NOT be recognized.\n    assertEquals(null, sn.getPdbId());\n}", "repo_id": "9", "comment": "/**\n * Test explicit prefixes\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2175, "method_signature": "void testPrefixes()"}, "2084": {"callee_method_names": [], "method_name": "SymmetryAxes.getOperator", "method_implementation": "{\n    return operator;\n}", "repo_id": "9", "comment": "/**\n * Get the transformation operator for this axis as an homogeneous matrix\n * @return the transformation operator\n */\n", "repo_name": "biojava-master/", "id": 2084, "method_signature": "Matrix4d getOperator()"}, "1508": {"callee_method_names": [], "method_name": "SuperPositionQCP.innerProduct", "method_implementation": "{\n    double x1, x2, y1, y2, z1, z2;\n    double g1 = 0.0, g2 = 0.0;\n    Sxx = 0;\n    Sxy = 0;\n    Sxz = 0;\n    Syx = 0;\n    Syy = 0;\n    Syz = 0;\n    Szx = 0;\n    Szy = 0;\n    Szz = 0;\n    if (weight != null) {\n        wsum = 0;\n        for (int i = 0; i < coords1.length; i++) {\n            wsum += weight[i];\n            x1 = weight[i] * coords1[i].x;\n            y1 = weight[i] * coords1[i].y;\n            z1 = weight[i] * coords1[i].z;\n            g1 += x1 * coords1[i].x + y1 * coords1[i].y + z1 * coords1[i].z;\n            x2 = coords2[i].x;\n            y2 = coords2[i].y;\n            z2 = coords2[i].z;\n            g2 += weight[i] * (x2 * x2 + y2 * y2 + z2 * z2);\n            Sxx += (x1 * x2);\n            Sxy += (x1 * y2);\n            Sxz += (x1 * z2);\n            Syx += (y1 * x2);\n            Syy += (y1 * y2);\n            Syz += (y1 * z2);\n            Szx += (z1 * x2);\n            Szy += (z1 * y2);\n            Szz += (z1 * z2);\n        }\n    } else {\n        for (int i = 0; i < coords1.length; i++) {\n            g1 += coords1[i].x * coords1[i].x + coords1[i].y * coords1[i].y + coords1[i].z * coords1[i].z;\n            g2 += coords2[i].x * coords2[i].x + coords2[i].y * coords2[i].y + coords2[i].z * coords2[i].z;\n            Sxx += coords1[i].x * coords2[i].x;\n            Sxy += coords1[i].x * coords2[i].y;\n            Sxz += coords1[i].x * coords2[i].z;\n            Syx += coords1[i].y * coords2[i].x;\n            Syy += coords1[i].y * coords2[i].y;\n            Syz += coords1[i].y * coords2[i].z;\n            Szx += coords1[i].z * coords2[i].x;\n            Szy += coords1[i].z * coords2[i].y;\n            Szz += coords1[i].z * coords2[i].z;\n        }\n        wsum = coords1.length;\n    }\n    e0 = (g1 + g2) * 0.5;\n}", "repo_id": "9", "comment": "/**\n * Calculates the inner product between two coordinate sets x and y\n * (optionally weighted, if weights set through\n * {@link #set(Point3d[], Point3d[], double[])}). It also calculates an\n * upper bound of the most positive root of the key matrix.\n * http://theobald.brandeis.edu/qcp/qcprot.c\n *\n * @param coords1\n * @param coords2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1508, "method_signature": "void innerProduct(Point3d[], Point3d[])"}, "2249": {"callee_method_ids": [1411], "callee_method_names": ["CrystalCell.setA", "CrystalCell.setB", "CrystalCell.setC", "CrystalCell.setAlpha", "CrystalCell.setBeta", "CrystalCell.setGamma", "PDBCrystallographicInfo.setCrystalCell"], "method_name": "TestMmtfUtils.testGetUnitCellAsArray", "method_implementation": "{\n    PDBCrystallographicInfo xtalInfo = new PDBCrystallographicInfo();\n    CrystalCell cell = new CrystalCell();\n    cell.setA(1.0);\n    cell.setB(2.0);\n    cell.setC(3.0);\n    cell.setAlpha(4.0);\n    cell.setBeta(5.0);\n    cell.setGamma(6.0);\n    float[] testArray = new float[] { 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f };\n    xtalInfo.setCrystalCell(cell);\n    float[] outputArray = MmtfUtils.getUnitCellAsArray(xtalInfo);\n    assertArrayEquals(testArray, outputArray, 0.0f);\n}", "repo_id": "9", "comment": "/**\n * Test that getting the unit cell as an array of doubles works.\n */\n", "repo_name": "biojava-master/", "id": 2249, "method_signature": "void testGetUnitCellAsArray()"}, "2407": {"callee_method_names": [], "method_name": "Location.prefix", "method_implementation": "{\n    if (isSameStrand(other)) {\n        if (other.mStart >= mStart) {\n            return new Location(mStart, (other.mStart < mEnd) ? other.mStart : mEnd);\n        } else {\n            //other is out of bounds -- no prefix\n            throw new IndexOutOfBoundsException(\"Specified location not within this location.\");\n        }\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * The part of this location before the other location (not inclusive).\n *\n * @param other The other location.\n * @return The part of this location before the other location.\n * @throws IllegalArgumentException Locations are on opposite strands.\n * @throws IndexOutOfBoundsException This location does not contain other location.\n */\n", "repo_name": "biojava-master/", "id": 2407, "method_signature": "Location prefix(Location)"}, "3706": {"callee_method_ids": [3700], "callee_method_names": ["LinkedHashMap.keySet", "LinkedHashMap.get", "HeaderInfo.isHide", "ArrayList<String>.add"], "method_name": "WorkSheet.getMetaDataColumns", "method_implementation": "{\n    ArrayList<String> metaColumns = new ArrayList<String>();\n    for (String key : metaDataColumnsHashMap.keySet()) {\n        HeaderInfo hi = columnLookup.get(key);\n        if (!hi.isHide()) {\n            metaColumns.add(key);\n        }\n    }\n    return metaColumns;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3706, "method_signature": "ArrayList<String> getMetaDataColumns()"}, "913": {"callee_method_names": [], "method_name": "BoundingBox.getDimensions", "method_implementation": "{\n    double[] dim = new double[3];\n    dim[0] = xmax - xmin;\n    dim[1] = ymax - ymin;\n    dim[2] = zmax - zmin;\n    return dim;\n}", "repo_id": "9", "comment": "/**\n * Returns the dimensions of this bounding box.\n *\n * @return a double array (x,y,z) with the dimensions of the box.\n */\n", "repo_name": "biojava-master/", "id": 913, "method_signature": "double[] getDimensions()"}, "756": {"callee_method_names": [], "method_name": "CeParameters.setORmsdThr", "method_implementation": "{\n    this.oRmsdThr = oRmsdThr;\n}", "repo_id": "9", "comment": "/**\n * Set the Original RMSD threshold from which the alignment optimization is started\n *\n * @param oRmsdThr the threshold\n */\n", "repo_name": "biojava-master/", "id": 756, "method_signature": "void setORmsdThr(Double)"}, "842": {"callee_method_names": [], "method_name": "GroupAsa.getBsa", "method_implementation": "{\n    return (asaU - asaC);\n}", "repo_id": "9", "comment": "/**\n * Returns the BSA value for this group, i.e. the difference between ASA uncomplexed and ASA complexed\n * @return\n */\n", "repo_name": "biojava-master/", "id": 842, "method_signature": "double getBsa()"}, "2674": {"callee_method_names": ["ArrayList.get"], "method_name": "MultipleSequenceAlignment.getCompoundSet", "method_implementation": "{\n    return sequences.get(0).getCompoundSet();\n}", "repo_id": "9", "comment": "/**\n * Get the Compounds defined in the first sequence\n * @return get compound set\n */\n", "repo_name": "biojava-master/", "id": 2674, "method_signature": "CompoundSet<C> getCompoundSet()"}, "1113": {"callee_method_names": ["Element.getAttribute", "Element.getAttribute", "Element.getElementsByTagName", "NodeList.getLength", "NodeList.getLength", "NodeList.item", "Logger.debug", "SiftsEntity.addSegment", "Logger.debug"], "method_name": "SiftsXMLParser.getSiftsEntity", "method_implementation": "{\n    //for each <employee> element get text or int values of\n    //name ,id, age and name\n    String type = empEl.getAttribute(\"type\");\n    String entityId = empEl.getAttribute(\"entityId\");\n    //Create a new Employee with the value read from the xml nodes\n    SiftsEntity entity = new SiftsEntity(type, entityId);\n    // get nodelist of segments...\n    NodeList nl = empEl.getElementsByTagName(\"segment\");\n    if (nl != null && nl.getLength() > 0) {\n        for (int i = 0; i < nl.getLength(); i++) {\n            //get the entity element\n            Element el = (Element) nl.item(i);\n            SiftsSegment s = getSiftsSegment(el);\n            logger.debug(\"new segment: {}\", s);\n            entity.addSegment(s);\n        }\n    }\n    logger.debug(\"new SIFTS entity: {}\", entity);\n    return entity;\n}", "repo_id": "9", "comment": "/**\n * <entity type=\"protein\" entityId=\"A\">\n */\n", "repo_name": "biojava-master/", "id": 1113, "method_signature": "SiftsEntity getSiftsEntity(Element)"}, "560": {"callee_method_names": [], "method_name": "RotationAxis.getScrewTranslation", "method_implementation": "{\n    return screwTranslation;\n}", "repo_id": "9", "comment": "/**\n * Get the component of translation parallel to the axis of rotation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 560, "method_signature": "Atom getScrewTranslation()"}, "1721": {"callee_method_names": [], "method_name": "BasePairParameters.getPairSequence", "method_implementation": "{\n    return pairSequence;\n}", "repo_id": "9", "comment": "/**\n * This method returns the primary strand's sequence where parameters were found.\n * There are spaces in the string anywhere there was a break in the helix or when\n * it goes from one helix to another helix in the structure. (the \"step\" is still returned)\n * @return String of primary sequence with spaces between gaps and new helices.\n */\n", "repo_name": "biojava-master/", "id": 1721, "method_signature": "String getPairSequence()"}, "1242": {"callee_method_names": ["Structure.nrModels", "Structure.getModel", "String.getAtomGroups", "Group.getAltLocs", "Character.getPDBName", "Group.getPDBName", "List<Group>.add", "List<Group>.add", "Group.getAltLocs", "List<Group>.addAll", "String.setAtomGroups"], "method_name": "MmtfUtils.fixMicroheterogenity", "method_implementation": "{\n    // Loop through the models\n    for (int i = 0; i < bioJavaStruct.nrModels(); i++) {\n        // Then the chains\n        List<Chain> chains = bioJavaStruct.getModel(i);\n        for (Chain c : chains) {\n            // Build a new list of groups\n            List<Group> outGroups = new ArrayList<>();\n            for (Group g : c.getAtomGroups()) {\n                List<Group> removeList = new ArrayList<>();\n                for (Group altLoc : g.getAltLocs()) {\n                    // Check if they are not equal -> microheterogenity\n                    if (!altLoc.getPDBName().equals(g.getPDBName())) {\n                        // Now add this group to the main list\n                        removeList.add(altLoc);\n                    }\n                }\n                // Add this group\n                outGroups.add(g);\n                // Remove any microhet alt locs\n                g.getAltLocs().removeAll(removeList);\n                // Add these microhet alt locs\n                outGroups.addAll(removeList);\n            }\n            c.setAtomGroups(outGroups);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * This sets all microheterogeneous groups\n * (previously alternate location groups) as separate groups.\n * This is required because mmtf groups cannot have multiple HET codes.\n * @param bioJavaStruct\n */\n", "repo_name": "biojava-master/", "id": 1242, "method_signature": "void fixMicroheterogenity(Structure)"}, "1736": {"callee_method_names": ["Structure.getChains", "double[].isNucleicAcid", "List<Chain>.add", "List<Chain>.size", "List<Chain>.size", "List<Chain>.get", "List<Chain>.get", "List<Chain>.remove"], "method_name": "BasePairParameters.getNucleicChains", "method_implementation": "{\n    if (structure == null)\n        return new ArrayList<>();\n    List<Chain> chains = structure.getChains();\n    List<Chain> result = new ArrayList<>();\n    for (Chain c : chains) {\n        if (c.isNucleicAcid()) {\n            result.add(c);\n        }\n    }\n    if (removeDups)\n        for (int i = 0; i < result.size(); i++) {\n            for (int j = i + 2; j < result.size(); j++) {\n                // remove duplicate sequences (structures with two or more identical units)\n                if (result.get(i).getAtomSequence().equals(result.get(j).getAtomSequence())) {\n                    result.remove(j);\n                }\n            }\n        }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * This method reports all the nucleic acid chains and has an option to remove duplicates if you\n * are considering an analysis of only unique DNA or RNA helices in the Structure.\n * @param removeDups If true, it will ignore duplicate chains\n * @return A list of all the nucleic acid chains in order of the Structure\n */\n", "repo_name": "biojava-master/", "id": 1736, "method_signature": "List<Chain> getNucleicChains(boolean)"}, "1782": {"callee_method_names": [], "method_name": "PDBHeader.getJournalArticle", "method_implementation": "{\n    return this.journalArticle;\n}", "repo_id": "9", "comment": "/**\n * Get the associated publication as defined by the JRNL records in a PDB\n * file.\n * @return a JournalArticle\n */\n", "repo_name": "biojava-master/", "id": 1782, "method_signature": "JournalArticle getJournalArticle()"}, "2166": {"callee_method_names": ["StructureIdentifier.toCanonical", "Chain.getAtomGroups", "List<Group>.listIterator", "ListIterator<Group>.hasNext", "ListIterator<Group>.next", "Group.getResidueNumber", "ListIterator<Group>.hasNext", "ListIterator<Group>.next", "Group.getResidueNumber", "List<ResidueRange>.add", "Chain.getName"], "method_name": "StructureImpl.toCanonical", "method_implementation": "{\n    StructureIdentifier real = getStructureIdentifier();\n    if (real != null) {\n        try {\n            return real.toCanonical();\n        } catch (StructureException e) {\n            // generate fake one if needed\n        }\n    }\n    // No identifier set, so generate based on residues present in the structure\n    List<ResidueRange> range = new ArrayList<>();\n    for (Chain chain : getChains()) {\n        List<Group> groups = chain.getAtomGroups();\n        ListIterator<Group> groupsIt = groups.listIterator();\n        if (!groupsIt.hasNext()) {\n            // no groups in chain\n            continue;\n        }\n        Group g = groupsIt.next();\n        ResidueNumber first = g.getResidueNumber();\n        //TODO Detect missing intermediate residues -sbliven, 2015-01-28\n        //Already better than previous whole-chain representation\n        // get last residue\n        while (groupsIt.hasNext()) {\n            g = groupsIt.next();\n        }\n        ResidueNumber last = g.getResidueNumber();\n        range.add(new ResidueRange(chain.getName(), first, last));\n    }\n    return new SubstructureIdentifier(getPdbId(), range);\n}", "repo_id": "9", "comment": "/**\n * Creates a SubstructureIdentifier based on the residues in this Structure.\n *\n * Only the first and last residues of each chain are considered, so chains\n * with gaps\n * @return A {@link SubstructureIdentifier} with residue ranges constructed from each chain\n */\n", "repo_name": "biojava-master/", "id": 2166, "method_signature": "SubstructureIdentifier toCanonical()"}, "906": {"callee_method_names": ["StructureInterfaceCluster.addMember", "List<StructureInterfaceCluster>.add", "List<StructureInterfaceCluster>.stream", "double.getMembers", "SparseVector.equals", "Optional<StructureInterfaceCluster>.isPresent", "Optional<StructureInterfaceCluster>.get", "Logger.warn", "StructureInterfaceCluster.addMember", "StructureInterfaceCluster.addMember", "List<StructureInterfaceCluster>.add"], "method_name": "StructureInterfaceList.addNcsEquivalent", "method_implementation": "{\n    this.add(interfaceNew);\n    if (clustersNcs == null) {\n        clustersNcs = new ArrayList<>();\n    }\n    if (interfaceRef == null) {\n        StructureInterfaceCluster newCluster = new StructureInterfaceCluster();\n        newCluster.addMember(interfaceNew);\n        clustersNcs.add(newCluster);\n        return;\n    }\n    Optional<StructureInterfaceCluster> clusterRef = clustersNcs.stream().filter(r -> r.getMembers().stream().anyMatch(c -> c.equals(interfaceRef))).findFirst();\n    if (clusterRef.isPresent()) {\n        clusterRef.get().addMember(interfaceNew);\n        return;\n    }\n    logger.warn(\"The specified reference interface, if not null, should have been added to this set previously. \" + \"Creating new cluster and adding both interfaces. This is likely a bug.\");\n    this.add(interfaceRef);\n    StructureInterfaceCluster newCluster = new StructureInterfaceCluster();\n    newCluster.addMember(interfaceRef);\n    newCluster.addMember(interfaceNew);\n    clustersNcs.add(newCluster);\n}", "repo_id": "9", "comment": "/**\n * Add an interface to the list, possibly defining it as NCS-equivalent to an interface already in the list.\n * Used to build up the NCS clustering.\n * @param interfaceNew\n *          an interface to be added to the list.\n * @param interfaceRef\n *          interfaceNew will be added to the cluster which contains interfaceRef.\n *          If interfaceRef is null, new cluster will be created for interfaceNew.\n * @since 5.0.0\n */\n", "repo_name": "biojava-master/", "id": 906, "method_signature": "void addNcsEquivalent(StructureInterface, StructureInterface)"}, "2581": {"callee_method_names": ["LinkedPair.getFirst", "LinkedPair.getSecond"], "method_name": "SingleLinkageClusterer.merge", "method_implementation": "{\n    int first = closestPair.getFirst();\n    int second = closestPair.getSecond();\n    for (int other = 0; other < numItems; other++) {\n        matrix[Math.min(first, other)][Math.max(first, other)] = link(getDistance(first, other), getDistance(second, other));\n    }\n}", "repo_id": "9", "comment": "/**\n * Merge 2 rows/columns of the matrix by the linkage function (see {@link #link(double, double)}\n * @param closestPair\n */\n", "repo_name": "biojava-master/", "id": 2581, "method_signature": "void merge(LinkedPair)"}, "403": {"callee_method_names": ["Structure.nrModels", "Structure.getModel", "List<Chain>.size", "List<Chain>.get"], "method_name": "GroupIterator.getCurrentChain", "method_implementation": "{\n    if (current_model_pos >= structure.nrModels()) {\n        return null;\n    }\n    List<Chain> model = structure.getModel(current_model_pos);\n    if (current_chain_pos >= model.size()) {\n        return null;\n    }\n    return model.get(current_chain_pos);\n}", "repo_id": "9", "comment": "/**\n * Get the current Chain. Returns null if we are at the end of the iteration.\n *\n * @return the Chain of the current position\n */\n", "repo_name": "biojava-master/", "id": 403, "method_signature": "Chain getCurrentChain()"}, "1800": {"callee_method_names": [], "method_name": "EcodFactory.setEcodDatabase", "method_implementation": "{\n    getEcodDatabase(version);\n    defaultVersion = version;\n}", "repo_id": "9", "comment": "/**\n * Updates the default version\n * @param version\n */\n", "repo_name": "biojava-master/", "id": 1800, "method_signature": "void setEcodDatabase(String)"}, "271": {"callee_method_names": [], "method_name": "ModificationLinkage.getLabelOfAtomOnComponent2", "method_implementation": "{\n    return labelOfAtomOnComponent2;\n}", "repo_id": "9", "comment": "/**\n * @return label of the atom on the second component.\n */\n", "repo_name": "biojava-master/", "id": 271, "method_signature": "String getLabelOfAtomOnComponent2()"}, "1129": {"callee_method_names": [], "method_name": "LocalPDBDirectory.setFetchBehavior", "method_implementation": "{\n    this.fetchBehavior = fetchBehavior;\n}", "repo_id": "9", "comment": "/**\n * Set the behavior for fetching files from the server.\n * This replaces the {@link #setAutoFetch(boolean)} method with a more\n * extensive set of options.\n * @param fetchBehavior\n */\n", "repo_name": "biojava-master/", "id": 1129, "method_signature": "void setFetchBehavior(FetchBehavior)"}, "3736": {"callee_method_ids": [3698, 3698], "callee_method_names": ["LinkedHashMap.get", "LinkedHashMap.get", "HeaderInfo.getIndex", "HeaderInfo.getIndex"], "method_name": "WorkSheet.addCell", "method_implementation": "{\n    HeaderInfo rowIndex = rowLookup.get(row);\n    HeaderInfo colIndex = columnLookup.get(col);\n    if (rowIndex == null) {\n        throw new Exception(\"Row \" + row + \" not found in worksheet\");\n    }\n    if (colIndex == null) {\n        throw new Exception(\"Column \" + col + \" not found in worksheet\");\n    }\n    data[rowIndex.getIndex()][colIndex.getIndex()] = new CompactCharSequence(value);\n}", "repo_id": "9", "comment": "/**\n * Add data to a cell\n *\n * @param row\n * @param col\n * @param value\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3736, "method_signature": "void addCell(String, String, String)"}, "3268": {"callee_method_names": [], "method_name": "AbstractAlignmentJmol.getColorPalette", "method_implementation": "{\n    return colorPalette;\n}", "repo_id": "9", "comment": "/**\n * Return the color pattelete of the AlignmentJmol instance.\n */\n", "repo_name": "biojava-master/", "id": 3268, "method_signature": "ColorBrewer getColorPalette()"}, "3019": {"callee_method_names": [], "method_name": "AbstractReference.getJournal", "method_implementation": "{\n    return journal;\n}", "repo_id": "9", "comment": "/**\n * The journal usually contains the Publication Number, Publication Date and Assignee\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3019, "method_signature": "String getJournal()"}, "42": {"callee_method_names": ["List<E>.add", "Logger.error", "Logger.error"], "method_name": "Alignments.getListFromFutures", "method_implementation": "{\n    List<E> list = new ArrayList<E>();\n    for (Future<E> f : futures) {\n        // TODO when added to ConcurrencyTools, log completions and exceptions instead of printing stack traces\n        try {\n            list.add(f.get());\n        } catch (InterruptedException e) {\n            logger.error(\"Interrupted Exception: \", e);\n        } catch (ExecutionException e) {\n            logger.error(\"Execution Exception: \", e);\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Factory method which retrieves calculated elements from a list of tasks on the concurrent execution queue.\n *\n * @param <E> each task calculates a value of type E\n * @param futures list of tasks\n * @return calculated elements\n */\n", "repo_name": "biojava-master/", "id": 42, "method_signature": "List<E> getListFromFutures(List)"}, "1691": {"callee_method_names": [], "method_name": "AtomImpl.setCoords", "method_implementation": "{\n    coords = new Point3d(c);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1691, "method_signature": "void setCoords(double[])"}, "661": {"callee_method_names": ["MultipleAlignment.getEnsemble", "MultipleAlignment.getAtomArrays", "List<Atom[]>.size", "List<Atom[]>.size", "List<Atom[]>.get", "MultipleAlignment.length", "MultipleAlignment.getBlockSets", "List<Atom[]>.size", "List<Atom[]>.size", "Atom[].clone", "MultipleAlignment.length", "List<Atom[]>.add"], "method_name": "MultipleAlignmentTools.transformAtoms", "method_implementation": "{\n    if (alignment.getEnsemble() == null) {\n        throw new NullPointerException(\"No ensemble set for this alignment\");\n    }\n    List<Atom[]> atomArrays = alignment.getAtomArrays();\n    List<Atom[]> transformed = new ArrayList<Atom[]>(atomArrays.size());\n    // Loop through structures\n    for (int i = 0; i < atomArrays.size(); i++) {\n        Matrix4d transform = null;\n        // all CA atoms from structure\n        Atom[] curr = atomArrays.get(i);\n        // Concatenated list of all blocks for this structure\n        Atom[] transformedAtoms = new Atom[alignment.length()];\n        int transformedAtomsLength = 0;\n        // Each blockset gets transformed independently\n        for (BlockSet bs : alignment.getBlockSets()) {\n            Atom[] blocksetAtoms = new Atom[bs.length()];\n            int blockPos = 0;\n            for (Block blk : bs.getBlocks()) {\n                if (blk.size() != atomArrays.size()) {\n                    throw new IllegalStateException(String.format(\"Mismatched block size. Expected %d \" + \"structures, found %d.\", atomArrays.size(), blk.size()));\n                }\n                // Extract aligned atoms\n                for (int j = 0; j < blk.length(); j++) {\n                    Integer alignedPos = blk.getAlignRes().get(i).get(j);\n                    if (alignedPos != null) {\n                        blocksetAtoms[blockPos] = (Atom) curr[alignedPos].clone();\n                    }\n                    blockPos++;\n                }\n            }\n            // Transform according to the blockset or alignment matrix\n            Matrix4d blockTrans = null;\n            if (bs.getTransformations() != null)\n                blockTrans = bs.getTransformations().get(i);\n            if (blockTrans == null) {\n                blockTrans = transform;\n            }\n            for (Atom a : blocksetAtoms) {\n                if (a != null)\n                    Calc.transform(a, blockTrans);\n                transformedAtoms[transformedAtomsLength] = a;\n                transformedAtomsLength++;\n            }\n        }\n        assert (transformedAtomsLength == alignment.length());\n        transformed.add(transformedAtoms);\n    }\n    return transformed;\n}", "repo_id": "9", "comment": "/**\n * Transforms atoms according to the superposition stored in the alignment.\n * <p>\n * For each structure in the alignment, returns an atom for each\n * representative atom in the aligned columns, omitting unaligned residues\n * (i.e. an array of length <tt>alignment.length()</tt> ).\n * <p>\n * All blocks are concatenated together, so Atoms may not appear in the same\n * order as in their parent structure. If the alignment blocks contain null\n * residues (gaps), then the returned array will also contain null Atoms in\n * the same positions.\n *\n * @param alignment\n *            MultipleAlignment\n * @return List of Atom arrays of only the aligned atoms of every structure\n *         (null Atom if a gap position)\n */\n", "repo_name": "biojava-master/", "id": 661, "method_signature": "List<Atom[]> transformAtoms(MultipleAlignment)"}, "3431": {"callee_method_names": ["MultipleAlignmentJmol.getFrame", "JMenu.setMnemonic", "JMenuItem.addActionListener", "JMenu.add", "JMenuItem.addActionListener", "JMenu.add", "JMenuItem.addActionListener", "JMenu.add", "JMenuItem.addActionListener", "JMenu.add", "JMenuItem.addActionListener", "JMenu.add", "JMenuItem.addActionListener", "JMenu.add", "JMenuBar.add", "MultipleAlignmentJmol.getFrame"], "method_name": "SymmetryDisplay.addSymmetryMenu", "method_implementation": "{\n    JMenuBar menubar = jmol.getFrame().getJMenuBar();\n    JMenu symm = new JMenu(\"Symmetry\");\n    symm.setMnemonic(KeyEvent.VK_S);\n    SymmetryListener li = new SymmetryListener(jmol, symmResult);\n    JMenuItem repeats = new JMenuItem(\"Repeats Superposition\");\n    repeats.addActionListener(li);\n    symm.add(repeats);\n    JMenuItem multiple = new JMenuItem(\"Multiple Structure Alignment\");\n    multiple.addActionListener(li);\n    symm.add(multiple);\n    JMenuItem self = new JMenuItem(\"Optimal Self Alignment\");\n    self.addActionListener(li);\n    symm.add(self);\n    JMenuItem pg = new JMenuItem(\"Show Symmetry Group\");\n    pg.addActionListener(li);\n    symm.add(pg);\n    JMenuItem ax = new JMenuItem(\"Show Symmetry Axes\");\n    ax.addActionListener(li);\n    symm.add(ax);\n    JMenuItem news = new JMenuItem(\"New Symmetry Analysis\");\n    news.addActionListener(li);\n    symm.add(news);\n    menubar.add(symm, 3);\n    jmol.getFrame().pack();\n}", "repo_id": "9", "comment": "/**\n * Adds a Symmetry menu to the Jmol display, so that further symmetry\n * analysis can be triggered.\n *\n * @param jmol\n *            parent jmol\n * @param symmResult\n *            CeSymmResult\n */\n", "repo_name": "biojava-master/", "id": 3431, "method_signature": "void addSymmetryMenu(MultipleAlignmentJmol, CeSymmResult)"}, "668": {"callee_method_names": ["Phylogeny.setName"], "method_name": "MultipleAlignmentTools.getHSDMTree", "method_implementation": "{\n    MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msa = MultipleAlignmentTools.toProteinMSA(msta);\n    BasicSymmetricalDistanceMatrix distmat = (BasicSymmetricalDistanceMatrix) DistanceMatrixCalculator.dissimilarityScore(msa, SubstitutionMatrixHelper.getAminoAcidSubstitutionMatrix(\"PRLA000102\"));\n    Phylogeny tree = TreeConstructor.distanceTree(distmat, TreeConstructorType.NJ);\n    tree.setName(\"HSDM Tree\");\n    return tree;\n}", "repo_id": "9", "comment": "/**\n * Calculate a phylogenetic tree of the MultipleAlignment using\n * dissimilarity scores (DS), based in SDM Substitution Matrix (ideal for\n * distantly related proteins, structure-derived) and the Neighbor Joining\n * algorithm from forester.\n *\n * @param msta\n *            MultipleAlignment of protein structures\n * @return Phylogeny phylogenetic tree\n * @throws CompoundNotFoundException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 668, "method_signature": "Phylogeny getHSDMTree(MultipleAlignment)"}, "3508": {"callee_method_ids": [3637, 3673, 3675, 3659, 3657, 3661, 3654], "callee_method_names": ["ArrayList<SurvivalInfo>.size", "CoxInfo.getCoefficientsList", "ArrayList<String>.size", "ArrayList<SurvivalInfo>.get", "SurvivalInfo.getTime", "SurvivalInfo.getStatus", "SurvivalInfo.getStrata", "SurvivalInfo.getWeight", "SurvivalInfo.getScore", "ArrayList<String>.size", "ArrayList<String>.get", "SurvivalInfo.getVariable"], "method_name": "AgScore.process", "method_implementation": "{\n    int i, k;\n    //double temp;\n    int n = survivalInfoList.size();\n    ArrayList<String> variables = new ArrayList<String>(coxInfo.getCoefficientsList().keySet());\n    int nvar = variables.size();\n    int dd;\n    double[] event = new double[n];\n    double[] start = new double[n];\n    double[] stop = new double[n];\n    double[] strata = new double[n];\n    double[] weights = new double[n];\n    double[] score = new double[n];\n    double[] a = new double[nvar];\n    double[] a2 = new double[nvar];\n    double[] mean = new double[nvar];\n    double[] mh1 = new double[nvar];\n    double[] mh2 = new double[nvar];\n    double[] mh3 = new double[nvar];\n    double denom = 0;\n    double time = 0;\n    double e_denom = 0;\n    double meanwt = 0;\n    double deaths = 0;\n    double risk;\n    double[][] covar = new double[nvar][n];\n    double[][] resid = new double[nvar][n];\n    double hazard;\n    double downwt, temp1, temp2, d2;\n    int person = 0;\n    //  n = *nx;\n    //  nvar  = *nvarx;\n    for (int p = 0; p < n; p++) {\n        SurvivalInfo si = survivalInfoList.get(p);\n        stop[p] = si.getTime();\n        event[p] = si.getStatus();\n        if (useStrata) {\n            strata[p] = si.getStrata();\n        } else {\n            strata[p] = 0;\n        }\n        weights[p] = si.getWeight();\n        score[p] = si.getScore();\n        for (int v = 0; v < variables.size(); v++) {\n            String variable = variables.get(v);\n            Double value = si.getVariable(variable);\n            covar[v][p] = value;\n        }\n    }\n    for (person = 0; person < n; ) {\n        if (event[person] == 0) {\n            person++;\n        } else {\n            /*\n\t\t\t\t ** compute the mean over the risk set, also hazard at this time\n\t\t\t\t */\n            denom = 0;\n            e_denom = 0;\n            meanwt = 0;\n            deaths = 0;\n            for (i = 0; i < nvar; i++) {\n                a[i] = 0;\n                a2[i] = 0;\n            }\n            time = stop[person];\n            for (k = person; k < n; k++) {\n                if (start[k] < time) {\n                    risk = score[k] * weights[k];\n                    denom += risk;\n                    for (i = 0; i < nvar; i++) {\n                        a[i] = a[i] + risk * covar[i][k];\n                    }\n                    if (stop[k] == time && event[k] == 1) {\n                        deaths++;\n                        e_denom += risk;\n                        meanwt += weights[k];\n                        for (i = 0; i < nvar; i++) {\n                            a2[i] = a2[i] + risk * covar[i][k];\n                        }\n                    }\n                }\n                if (strata[k] == 1) {\n                    break;\n                }\n            }\n            /* add things in for everyone in the risk set*/\n            if (deaths < 2 || method == CoxMethod.Breslow) {\n                /* easier case */\n                hazard = meanwt / denom;\n                for (i = 0; i < nvar; i++) {\n                    mean[i] = a[i] / denom;\n                }\n                for (k = person; k < n; k++) {\n                    if (start[k] < time) {\n                        risk = score[k];\n                        for (i = 0; i < nvar; i++) {\n                            resid[i][k] -= (covar[i][k] - mean[i]) * risk * hazard;\n                        }\n                        if (stop[k] == time) {\n                            person++;\n                            if (event[k] == 1) {\n                                for (i = 0; i < nvar; i++) {\n                                    resid[i][k] += (covar[i][k] - mean[i]);\n                                }\n                            }\n                        }\n                    }\n                    if (strata[k] == 1) {\n                        break;\n                    }\n                }\n            } else {\n                /*\n\t\t\t\t\t ** If there are 3 deaths, let m1, m2, m3 be the three\n\t\t\t\t\t **   weighted means,  h1, h2, h3 be the three hazard jumps.\n\t\t\t\t\t ** Then temp1 = h1 + h2 + h3\n\t\t\t\t\t **      temp2 = h1 + (2/3)h2 + (1/3)h3\n\t\t\t\t\t **      mh1   = m1*h1 + m2*h2 + m3*h3\n\t\t\t\t\t **      mh2   = m1*h1 + (2/3)m2*h2 + (1/3)m3*h3\n\t\t\t\t\t **      mh3   = (1/3)*(m1+m2+m3)\n\t\t\t\t\t */\n                temp1 = 0;\n                temp2 = 0;\n                for (i = 0; i < nvar; i++) {\n                    mh1[i] = 0;\n                    mh2[i] = 0;\n                    mh3[i] = 0;\n                }\n                meanwt /= deaths;\n                for (dd = 0; dd < deaths; dd++) {\n                    downwt = dd / deaths;\n                    d2 = denom - downwt * e_denom;\n                    hazard = meanwt / d2;\n                    temp1 += hazard;\n                    temp2 += (1 - downwt) * hazard;\n                    for (i = 0; i < nvar; i++) {\n                        mean[i] = (a[i] - downwt * a2[i]) / d2;\n                        mh1[i] += mean[i] * hazard;\n                        mh2[i] += mean[i] * (1 - downwt) * hazard;\n                        mh3[i] += mean[i] / deaths;\n                    }\n                }\n                for (k = person; k < n; k++) {\n                    if (start[k] < time) {\n                        risk = score[k];\n                        if (stop[k] == time && event[k] == 1) {\n                            for (i = 0; i < nvar; i++) {\n                                resid[i][k] += covar[i][k] - mh3[i];\n                                resid[i][k] -= risk * covar[i][k] * temp2;\n                                resid[i][k] += risk * mh2[i];\n                            }\n                        } else {\n                            for (i = 0; i < nvar; i++) {\n                                resid[i][k] -= risk * (covar[i][k] * temp1 - mh1[i]);\n                            }\n                        }\n                    }\n                    if (strata[k] == 1) {\n                        break;\n                    }\n                }\n                for (; stop[person] == time; person++) {\n                    if (strata[person] == 1) {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    //appears to be backward internally\n    double[][] flipresid = new double[n][nvar];\n    for (int s = 0; s < resid.length; s++) {\n        for (int t = 0; t < resid[0].length; t++) {\n            flipresid[t][s] = resid[s][t];\n        }\n    }\n    return flipresid;\n}", "repo_id": "9", "comment": "/**\n * @param method\n * @param survivalInfoList\n * @param coxInfo\n * @param useStrata\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3508, "method_signature": "double[][] process(CoxMethod, ArrayList, CoxInfo, boolean)"}, "2731": {"callee_method_names": [], "method_name": "EmblId.getSequenceVersion", "method_implementation": "{\n    return sequenceVersion;\n}", "repo_id": "9", "comment": "/**\n * return the sequence version\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2731, "method_signature": "String getSequenceVersion()"}, "830": {"callee_method_names": [], "method_name": "AlternativeAlignment.setDistanceMatrix", "method_implementation": "{\n    this.distanceMatrix = distanceMatrix;\n}", "repo_id": "9", "comment": "/**\n * The distance matrix this alignment is based on\n *\n * @param distanceMatrix\n */\n", "repo_name": "biojava-master/", "id": 830, "method_signature": "void setDistanceMatrix(Matrix)"}, "1684": {"callee_method_names": [], "method_name": "AugmentedResidueRange.getResidue", "method_implementation": "{\n    return super.getResidue(positionInRange, map);\n}", "repo_id": "9", "comment": "/**\n * Returns the ResidueNumber that is at position {@code positionInRange} in <em>this</em> ResidueRange.\n * @return The ResidueNumber, or false if it does not exist or is not within this ResidueRange\n */\n", "repo_name": "biojava-master/", "id": 1684, "method_signature": "ResidueNumber getResidue(int)"}, "2307": {"callee_method_names": ["List<Point3d[]>.size", "List<Point3d[]>.get", "List<Point3d[]>.get", "Logger.debug", "List<Point3d[]>.size", "SuperPosition.getRmsd", "List<Point3d[]>.get", "List<Point3d[]>.get", "SuperPosition.getRmsd", "List<Point3d[]>.get", "List<Point3d[]>.get", "SuperPosition.getRmsd", "List<Point3d[]>.get", "List<Point3d[]>.get", "Logger.info", "List<Point3d[]>.get"], "method_name": "TestSuperPosition.testRMSD", "method_implementation": "{\n    // for the rmsd test we first make sure that both cloud points are not centered in origin so that the centering is tested too\n    // first cloud points are already centered, we translate cloud2 only\n    for (int c = 0; c < cloud2.size(); c++) {\n        CalcPoint.translate(translation2, cloud2.get(c));\n        Point3d centroid2 = CalcPoint.centroid(cloud2.get(c));\n        LOGGER.debug(\"Centroid c2 (index %d): (%.2f, %.2f, %.2f)\\n\", c, centroid2.x, centroid2.y, centroid2.z);\n    }\n    for (int c = 0; c < cloud1.size(); c++) {\n        // Use SVD superposition\n        SuperPosition svd = new SuperPositionSVD(false);\n        long svdStart = System.nanoTime();\n        double svdrmsd = svd.getRmsd(cloud1.get(c), cloud2.get(c));\n        long svdTime = (System.nanoTime() - svdStart) / 1000;\n        // Use quaternion superposition\n        SuperPosition quat = new SuperPositionQuat(false);\n        long quatStart = System.nanoTime();\n        double quatrmsd = quat.getRmsd(cloud1.get(c), cloud2.get(c));\n        long quatTime = (System.nanoTime() - quatStart) / 1000;\n        // Use QCP algorithm\n        SuperPosition qcp = new SuperPositionQCP(false);\n        long qcpStart = System.nanoTime();\n        double qcprmsd = qcp.getRmsd(cloud1.get(c), cloud2.get(c));\n        long qcpTime = (System.nanoTime() - qcpStart) / 1000;\n        LOGGER.info(String.format(\"RMSD %d points: SVD time %d us, \" + \"Quat time: %d us, QCP time: %d us\", cloud1.get(c).length, svdTime, quatTime, qcpTime));\n        // Check that the returned RMSDs are equal\n        assertEquals(quatrmsd, qcprmsd, 0.001);\n        assertEquals(svdrmsd, quatrmsd, 0.001);\n        assertEquals(svdrmsd, qcprmsd, 0.001);\n    }\n}", "repo_id": "9", "comment": "/**\n * Test method to obtain the RMSD of a superposition.\n */\n", "repo_name": "biojava-master/", "id": 2307, "method_signature": "void testRMSD()"}, "2164": {"callee_method_names": [], "method_name": "StructureImpl.getPdbId", "method_implementation": "{\n    return this.pdbId;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 2164, "method_signature": "PdbId getPdbId()"}, "1044": {"callee_method_names": ["String.trim", "Map<String, Character>.get", "Map<String, Character>.get"], "method_name": "StructureTools.get1LetterCode", "method_implementation": "{\n    Character code1;\n    // is it a standard amino acid ?\n    code1 = get1LetterCodeAmino(groupCode3);\n    if (code1 == null) {\n        // hm groupCode3 is not standard\n        // perhaps it is a nucleotide?\n        groupCode3 = groupCode3.trim();\n        if (isNucleotide(groupCode3)) {\n            code1 = nucleotides30.get(groupCode3);\n            if (code1 == null) {\n                code1 = nucleotides23.get(groupCode3);\n            }\n            if (code1 == null) {\n                code1 = UNKNOWN_GROUP_LABEL;\n            }\n        } else {\n            // does not seem to be so let's assume it is\n            // nonstandard aminoacid and label it \"X\"\n            // logger.warning(\"unknown group name \"+groupCode3 );\n            code1 = UNKNOWN_GROUP_LABEL;\n        }\n    }\n    return code1;\n}", "repo_id": "9", "comment": "/**\n * Convert a three letter amino acid or nucleotide code into a single\n * character code. If the code does not correspond to an amino acid or\n * nucleotide, returns {@link #UNKNOWN_GROUP_LABEL}.\n *\n * Returned null for nucleotides prior to version 4.0.1.\n *\n * @param groupCode3\n *            three letter representation\n * @return The 1-letter abbreviation\n */\n", "repo_name": "biojava-master/", "id": 1044, "method_signature": "Character get1LetterCode(String)"}, "3240": {"callee_method_names": ["MultipleAlignment.getBlocks", "List<String>.add"], "method_name": "MultipleAlignmentJmolDisplay.getPDBresnum", "method_implementation": "{\n    List<String> lst = new ArrayList<String>();\n    for (Block block : multAln.getBlocks()) {\n        for (int i = 0; i < block.length(); i++) {\n            Integer pos = block.getAlignRes().get(structNum).get(i);\n            if (//gap\n            pos == null)\n                //gap\n                continue;\n            else if (pos < ca.length) {\n                String pdbInfo = JmolTools.getPdbInfo(ca[pos]);\n                lst.add(pdbInfo);\n            }\n        }\n    }\n    return lst;\n}", "repo_id": "9", "comment": "/**\n * Utility method used in the {@link MultipleAlignmentJmol} Frame,\n * when the aligned residues of a structure in the alignment have\n * to be selected for formatting them (coloring and style).\n *\n * @param structNum the structure index (row) of the alignment\n * @param multAln the MultipleAlignment that contains the equivalent\n * \t\t\tpositions\n * @param ca the atom array of the structure specified\n * \t\t\t(corresponding to the structure index)\n * @return List of pdb Strings corresponding to the aligned positions\n * \t\t\tof the structure.\n */\n", "repo_name": "biojava-master/", "id": 3240, "method_signature": "List<String> getPDBresnum(int, MultipleAlignment, Atom[])"}, "1050": {"callee_method_ids": [929, 937], "callee_method_names": ["Grid.addAtoms", "Grid.getAtomContacts"], "method_name": "StructureTools.getRepresentativeAtomsInContact", "method_implementation": "{\n    Grid grid = new Grid(cutoff);\n    Atom[] atoms = getRepresentativeAtomArray(chain);\n    grid.addAtoms(atoms);\n    return grid.getAtomContacts();\n}", "repo_id": "9", "comment": "/**\n * Returns the set of intra-chain contacts for the given chain for C-alpha\n * or C3' atoms (including non-standard aminoacids appearing as HETATM\n * groups), i.e. the contact map. Uses a spatial hashing algorithm that\n * speeds up the calculation without need of full distance matrix.\n *\n * @param chain\n * @param cutoff\n * @return\n * @since Biojava 4.1.0\n */\n", "repo_name": "biojava-master/", "id": 1050, "method_signature": "AtomContactSet getRepresentativeAtomsInContact(Chain, double)"}, "9": {"callee_method_names": [], "method_name": "GuideTree.getRoot", "method_implementation": "{\n    return root;\n}", "repo_id": "9", "comment": "/**\n * Returns the root {@link Node} which corresponds to the full multiple sequence alignment.\n *\n * @return the root node\n */\n", "repo_name": "biojava-master/", "id": 9, "method_signature": "Node getRoot()"}, "22": {"callee_method_ids": [26, 27], "callee_method_names": ["String.equals", "StockholmStructure.addGSAccessionNumber", "String.equals", "StockholmStructure.addGSDescription", "String.equals", "StockholmStructure.addGSdbReference", "String.equals", "StockholmStructure.addGSOrganismSpecies", "String.equals", "StockholmStructure.addGSOrganismClassification", "String.equals", "StockholmStructure.addGSLook", "Logger.warn"], "method_name": "StockholmFileParser.handleSequenceAnnotation", "method_implementation": "{\n    if (featureName.equals(GS_ACCESSION_NUMBER)) {\n        stockholmStructure.addGSAccessionNumber(seqName, value);\n    } else if (featureName.equals(GS_DESCRIPTION)) {\n        stockholmStructure.addGSDescription(seqName, value);\n    } else if (featureName.equals(GS_DATABASE_REFERENCE)) {\n        stockholmStructure.addGSdbReference(seqName, value);\n    } else if (featureName.equals(GS_ORGANISM_SPECIES)) {\n        stockholmStructure.addGSOrganismSpecies(seqName, value);\n    } else if (featureName.equals(GS_ORGANISM_CLASSIFICATION)) {\n        stockholmStructure.addGSOrganismClassification(seqName, value);\n    } else if (featureName.equals(GS_LOOK)) {\n        stockholmStructure.addGSLook(seqName, value);\n    } else {\n        // unknown feature\n        logger.warn(\"Unknown Sequence Feature [{}].\\nPlease contact the Biojava team.\", featureName);\n    }\n}", "repo_id": "9", "comment": "/**\n * #=GS &lt;seqname&gt; &lt;feature&gt; &lt;Generic per-Sequence annotation, free text&gt;\n *\n * @param line\n *            the line to be parsed\n */\n", "repo_name": "biojava-master/", "id": 22, "method_signature": "void handleSequenceAnnotation(String, String, String)"}, "1627": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setRMSDThreshold", "method_implementation": "{\n    this.rmsdThreshold = rmsdThreshold;\n}", "repo_id": "9", "comment": "/**\n * Structure similarity threshold (measured with RMSD) to consider for the\n * structural subunit clustering.\n *\n * @param rmsdThreshold\n */\n", "repo_name": "biojava-master/", "id": 1627, "method_signature": "void setRMSDThreshold(double)"}, "3804": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getxAxisTimeValues", "method_implementation": "{\n    return xAxisTimeValues;\n}", "repo_id": "9", "comment": "/**\n * @return the xAxisTimeValues\n */\n", "repo_name": "biojava-master/", "id": 3804, "method_signature": "ArrayList<Double> getxAxisTimeValues()"}, "2595": {"callee_method_names": ["ProteinSequence[].getLength", "ProteinSequence[].getLength"], "method_name": "SequenceTools.equalLengthSequences", "method_implementation": "{\n    for (int i = 0; i < sequences.length - 1; i++) {\n        if (sequences[i] == null)\n            continue;\n        for (int j = i + 1; j < sequences.length; j++) {\n            if (sequences[j] == null)\n                continue;\n            if (sequences[i].getLength() == sequences[j].getLength())\n                return true;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * A method to check whether an array of sequences contains at least two sequences having an equal length.\n *\n * @param sequences the array of {@link org.biojava.nbio.core.sequence.ProteinSequence} sequences\n * @return true if any two sequences are of an equal length\n */\n", "repo_name": "biojava-master/", "id": 2595, "method_signature": "boolean equalLengthSequences(ProteinSequence[])"}, "2500": {"callee_method_names": ["File.deleteOnExit"], "method_name": "GeneFeatureHelperTest.testOutputFastaSequenceLengthGFF3", "method_implementation": "{\n    // logger.info(\"outputFastaSequenceLengthGFF3\");\n    File fastaSequenceFile = new File(\"src/test/resources/volvox_all.fna\");\n    File gffFile = Files.createTempFile(\"volvox_length\", \"gff3\").toFile();\n    gffFile.deleteOnExit();\n    GeneFeatureHelper.outputFastaSequenceLengthGFF3(fastaSequenceFile, gffFile);\n    FileAssert.assertEquals(\"volvox_length.gff3 and volvox_length_output.gff3 are not equal\", gffFile, new File(\"src/test/resources/volvox_length_reference.gff3\"));\n}", "repo_id": "9", "comment": "/**\n * Test of outputFastaSequenceLengthGFF3 method, of class GeneFeatureHelper.\n */\n", "repo_name": "biojava-master/", "id": 2500, "method_signature": "void testOutputFastaSequenceLengthGFF3()"}, "1358": {"callee_method_names": [], "method_name": "AminoAcidImpl.getAminoType", "method_implementation": "{\n    return amino_char;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1358, "method_signature": "Character getAminoType()"}, "3580": {"callee_method_names": [], "method_name": "Matrix.transpose", "method_implementation": "{\n    int m = A.length;\n    int n = A[0].length;\n    double[][] C = new double[n][m];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            C[j][i] = A[i][j];\n        }\n    }\n    return C;\n}", "repo_id": "9", "comment": "/**\n * @param A\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3580, "method_signature": "double[][] transpose(double[][])"}, "3225": {"callee_method_names": ["GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>.parseHeader", "ProteinSequence.getAccession", "ProteinSequence.getAccession"], "method_name": "GenericFastaHeaderParserTest.testParseHeader", "method_implementation": "{\n    String header = \"\";\n    ProteinSequence sequence = new ProteinSequence(\"\");\n    GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound> instance = new GenericFastaHeaderParser<ProteinSequence, AminoAcidCompound>();\n    header = \"gi|gi-number|gb|accession|locus\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"accession\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.GENBANK);\n    header = \"gi|gi-number|emb|accession|locus\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"accession\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.ENA);\n    header = \"gi|gi-number|dbj|accession|locus\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"accession\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.DDBJ);\n    header = \"pir||entry\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"entry\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.NBRF);\n    header = \"prf||name\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"name\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.PRF);\n    header = \"sp|accession|name\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"accession\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.UNIPROT);\n    header = \"pdb|entry|chain\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"entry:chain\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.PDB1);\n    header = \"entry:chain|PDBID|CHAIN|SEQUENCE\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"entry:chain\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.PDB2);\n    header = \"PDB:1ECY_A mol:protein length:142  ECOTIN\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"1ECY_A\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.PDBe);\n    header = \"pat|country|number\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"number\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.PATENTS);\n    header = \"bbs|number\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"number\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.GENINFO);\n    header = \"gnl|database|identifier\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"identifier\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.GENERAL);\n    header = \"ref|accession|locus\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"accession\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.NCBI);\n    header = \"lcl|identifier\";\n    instance.parseHeader(header, sequence);\n    assertEquals(\"identifier\", sequence.getAccession().getID());\n    assertEquals(sequence.getAccession().getDataSource(), DataSource.LOCAL);\n}", "repo_id": "9", "comment": "/**\n * GenBank                           gi|gi-number|gb|accession|locus\n * ENA Data Library                 gi|gi-number|emb|accession|locus\n * DDBJ, DNA Database of Japan       gi|gi-number|dbj|accession|locus\n * NBRF PIR                          pir||entry\n * Protein Research Foundation       prf||name\n * SWISS-PROT                        sp|accession|name\n * Brookhaven Protein Data Bank (1)  pdb|entry|chain\n * Brookhaven Protein Data Bank (2)  entry:chain|PDBID|CHAIN|SEQUENCE\n * PDB EBI                           PDB:1ECY_A mol:protein length:142  ECOTIN\n * Patents                           pat|country|number\n * GenInfo Backbone Id               bbs|number\n * General database identifier       gnl|database|identifier\n * NCBI Reference Sequence           ref|accession|locus\n * Local Sequence identifier         lcl|identifier\n *\n * @author Scooter Willis <willishf at gmail dot com>\n */\n", "repo_name": "biojava-master/", "id": 3225, "method_signature": "void testParseHeader()"}, "2278": {"callee_method_ids": [1318, 1190], "callee_method_names": ["FileParsingParameters.setHeaderOnly", "Logger.info", "PDBFileParser.setFileParsingParameters", "PDBFileParser.parsePDBFile", "Logger.info", "Structure.getIdentifier", "Logger.info", "Logger.info", "Structure.getIdentifier"], "method_name": "TestHeaderOnly.testSpeed2", "method_implementation": "{\n    // Test the file parsing speed when the files are already downloaded.\n    InputStream cifStream = new GZIPInputStream(this.getClass().getResourceAsStream(\"/4hhb.cif.gz\"));\n    InputStream pdbStream = new GZIPInputStream(this.getClass().getResourceAsStream(\"/4hhb.pdb.gz\"));\n    assertNotNull(cifStream);\n    FileParsingParameters params = new FileParsingParameters();\n    // Flip this true/false to compare parsing speed.\n    params.setHeaderOnly(true);\n    logger.info(\"Testing PDB parsing speed\");\n    PDBFileParser pdbpars = new PDBFileParser();\n    pdbpars.setFileParsingParameters(params);\n    //pdbpars.setLoadChemCompInfo(true);\n    long start = System.nanoTime();\n    Structure s1 = pdbpars.parsePDBFile(pdbStream);\n    long stop = System.nanoTime();\n    double diff = (stop - start) / 1000000000.0;\n    logger.info(String.format(\"[%s] Elapsed time: %.3f s\", s1.getIdentifier(), diff));\n    logger.info(\"Testing mmCIF parsing speed\");\n    start = System.nanoTime();\n    Structure s2 = CifStructureConverter.fromInputStream(cifStream, params);\n    stop = System.nanoTime();\n    diff = (stop - start) / 1000000000.0;\n    logger.info(String.format(\"[%s] Elapsed time: %.3f s\", s2.getIdentifier(), diff));\n    /* Running from an SSD..\n\t\t * PDB .165s (all atom) -> 0.009s (only header)  95% faster.\n\t\t * mmCIF 0.323s (no header) -> 0.175s (only header) 45% faster.\n\t\t */\n}", "repo_id": "9", "comment": "// Test using local files.\n", "repo_name": "biojava-master/", "id": 2278, "method_signature": "void testSpeed2()"}, "1247": {"callee_method_names": ["DateFormat.format"], "method_name": "MmtfUtils.dateToIsoString", "method_implementation": "{\n    DateFormat dateStringFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n    return dateStringFormat.format(inputDate);\n}", "repo_id": "9", "comment": "/**\n * Covert a Date object to ISO time format.\n * @param inputDate The input date object\n * @return the time in ISO time format\n */\n", "repo_name": "biojava-master/", "id": 1247, "method_signature": "String dateToIsoString(Date)"}, "244": {"callee_method_names": [], "method_name": "ProteinModificationRegistry.init", "method_implementation": "{\n    lazyInit();\n}", "repo_id": "9", "comment": "/**\n * Initialization the static variables and register common modifications.\n */\n", "repo_name": "biojava-master/", "id": 244, "method_signature": "void init()"}, "1398": {"callee_method_names": ["Pattern.matcher"], "method_name": "PdbId.isShortCompatible", "method_implementation": "{\n    return PATTERN_SHORTABLE_EXTENDED_PDBID.matcher(extendedId).matches();\n}", "repo_id": "9", "comment": "/**\n * Checks whether an Extended PDB ID is shortable, <i>assuming it is a valid extended PDB ID</i>.\n * @see #isValidExtendedPdbId(String)\n * @param extendedId the supposedly valid extended PDB ID.\n * @return <code>true</code> if <code>extendedId</code> can be shortened\n * (ie. it matches the regular expression \"(pdb|PDB)_0000[1-9][a-zA-Z0-9]{3}\"), <code>false</code> otherwise.\n */\n", "repo_name": "biojava-master/", "id": 1398, "method_signature": "boolean isShortCompatible(String)"}, "717": {"callee_method_names": [], "method_name": "CECalculator.checkPrintRmsdNew", "method_implementation": "{\n    int is = 0;\n    // calc initial RMSD for bestTrace1\n    Atom[] strBuf1 = new Atom[traceMaxSize];\n    Atom[] strBuf2 = new Atom[traceMaxSize];\n    for (int jt = 0; jt < nBestTrace; jt++) {\n        for (int i = 0; i < winSize; i++) {\n            setStrBuf(strBuf1, is + i, ca1, bestTrace1[jt] + i);\n            setStrBuf(strBuf2, is + i, ca2, bestTrace2[jt] + i);\n        }\n        is += winSize;\n    }\n    //sup_str(strBuf1, strBuf2, nBestTrace*winSize, d_);\n    double rmsdNew = calc_rmsd(strBuf1, strBuf2, nBestTrace * winSize, true);\n    //afpChain.setTotalRmsdIni(rmsdNew);\n    if (isPrint) {\n        System.out.println(\"rmsdNew after trace: \" + rmsdNew);\n        for (int k = 0; k < nBestTrace; k++) System.out.println(String.format(\"(%d,%d,%d) \", bestTrace1[k] + 1, bestTrace2[k] + 1, 8));\n    }\n    if (isPrint) {\n        System.out.println(\"best traces: \" + nBestTraces);\n    }\n}", "repo_id": "9", "comment": "/**\n * calc initial RMSD for bestTrace1 in debug only\n */\n", "repo_name": "biojava-master/", "id": 717, "method_signature": "void checkPrintRmsdNew(int, int, Atom[], Atom[])"}, "3436": {"callee_method_names": [], "method_name": "ViewerTest.testStructureLoad", "method_implementation": "{\n    //\t\tif (  java.awt.GraphicsEnvironment.isHeadless())\n    //    \t\treturn;\n    //\n    //\t\tPDBFileReader parser = new PDBFileReader();\n    //\t\tparser.setAutoFetch(true);\n    //\t\ttry {\n    //\t\t\tstructure = parser.getStructureById(\"4hhb\");\n    //\n    //\t\t\tviewer.setStructure(structure);\n    //\n    //\t\t\t// manipulate the coodriantes\n    //\t\t\t//\n    //\t\t\t//Calc.rotate(structure,Matrix m);\n    //\n    //\t\t\tviewer.repaint();\n    //\n    //\t\t\tSelection selection = new SelectionImpl();\n    //\n    //\t\t\t//selection can be a whole structure, mol_id, chain, residue, atom or SCOP, Pfam, UniProt features\n    //\n    //\t\t\tviewer.setSelection(selection);\n    //\n    //\t\t\tviewer.setColor(Color.RED);\n    //\n    //\t\t\tviewer.setStyle(RenderStyle.WIREFRAME);\n    //\n    //\t\t\tviewer.clear();\n    //\n    //\t\t\tviewer.setZoom(50);\n    //\t\t} catch (Exception e){\n    //\t\t\tfail(e.getMessage());\n    //\t\t}\n}", "repo_id": "9", "comment": "/**\n * then load a PDB file.\n */\n", "repo_name": "biojava-master/", "id": 3436, "method_signature": "void testStructureLoad()"}, "681": {"callee_method_names": ["List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.size", "List<Atom[]>.get"], "method_name": "MultipleAlignmentScorer.getRefRMSD", "method_implementation": "{\n    double sumSqDist = 0;\n    int totalLength = 0;\n    for (int c = 0; c < transformed.get(reference).length; c++) {\n        Atom refAtom = transformed.get(reference)[c];\n        if (refAtom == null)\n            continue;\n        double nonNullSqDist = 0;\n        int nonNullLength = 0;\n        for (int r = 0; r < transformed.size(); r++) {\n            if (r == reference)\n                continue;\n            Atom atom = transformed.get(r)[c];\n            if (atom != null) {\n                nonNullSqDist += Calc.getDistanceFast(refAtom, atom);\n                nonNullLength++;\n            }\n        }\n        if (nonNullLength > 0) {\n            totalLength++;\n            sumSqDist += nonNullSqDist / nonNullLength;\n        }\n    }\n    return Math.sqrt(sumSqDist / totalLength);\n}", "repo_id": "9", "comment": "/**\n * Calculates the average RMSD from all structures to a reference s\n * tructure, given a set of superimposed atoms.\n * <p>\n * Complexity: T(n,l) = O(l*n), if n=number of structures and l=alignment\n * length.\n * <p>\n * For ungapped alignments, this is just the sqroot of the average distance\n * from an atom to the aligned atom from the reference. Thus, for R\n * structures aligned over C columns (with structure 0 as the reference), we\n * have:\n *\n * <pre>\n * RefRMSD = \\sqrt{ 1/(C*(R-1)) * \\sum_{r=1}^{R-1} \\sum_{j=0}^{C-1}\n * (atom[1][c]-atom[r][c])^2 }\n * </pre>\n * <p>\n * For gapped alignments, null atoms are omitted from consideration, so that\n * the RMSD is the average over all columns with non-null reference of the\n * average RMSD within the non-null elements of the column.\n *\n * @param transformed\n * @param reference\n * @return\n */\n", "repo_name": "biojava-master/", "id": 681, "method_signature": "double getRefRMSD(List, int)"}, "1122": {"callee_method_names": [], "method_name": "LocalPDBDirectory.setPath", "method_implementation": "{\n    path = new File(FileDownloadUtils.expandUserHome(p));\n    initPaths();\n}", "repo_id": "9", "comment": "/**\n * Sets the path for the directory where PDB files are read/written\n */\n", "repo_name": "biojava-master/", "id": 1122, "method_signature": "void setPath(String)"}, "2698": {"callee_method_names": ["Iterator<Map.Entry<String, ProteinSequence>>.hasNext", "FastaReader<ProteinSequence,AminoAcidCompound>.process", "FastaReader<ProteinSequence,AminoAcidCompound>.close", "LinkedHashMap.entrySet", "Iterator<Map.Entry<String, ProteinSequence>>.hasNext", "Iterator<Map.Entry<String, ProteinSequence>>.next", "Map.Entry<String, ProteinSequence>.getValue", "FastaReader<ProteinSequence,AminoAcidCompound>.close"], "method_name": "FastaStreamer.next", "method_implementation": "{\n    try {\n        if (!iterator.hasNext()) {\n            chunk = reader.process(getBatchSize());\n            if (null == chunk) {\n                closed = true;\n                reader.close();\n                return null;\n            }\n            iterator = chunk.entrySet().iterator();\n        }\n        if (iterator.hasNext()) {\n            Map.Entry<String, ProteinSequence> entry = iterator.next();\n            return createSequence(entry.getValue());\n        }\n        closed = true;\n        reader.close();\n    } catch (IOException exception) {\n        throw new UncheckedIOException(String.format(\"I/O error reading the FASTA file from '%s'\", getPath()), exception);\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Fetch the next header/protein tuple from the cache.  If the cache is empty, fetch another\n * batch from the source file\n *\n * @param reader\n * \t\tthe input stream from which the FASTA content is read\n * @return the protein sequence\n */\n", "repo_name": "biojava-master/", "id": 2698, "method_signature": "ProteinSequence next(FastaReader)"}, "1255": {"callee_method_names": ["String.equals"], "method_name": "MmtfUtils.getSecStructTypeFromDsspIndex", "method_implementation": "{\n    String dsspType = DsspType.dsspTypeFromInt(dsspIndex).getDsspType();\n    for (SecStrucType secStrucType : SecStrucType.values()) {\n        if (dsspType.equals(secStrucType.name)) {\n            return secStrucType;\n        }\n    }\n    // Return a null entry.\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Set the DSSP type based on a numerical index.\n * @param dsspIndex the integer index of the type to set\n * @return the instance of the SecStrucType object holding this secondary\n * structure type.\n */\n", "repo_name": "biojava-master/", "id": 1255, "method_signature": "SecStrucType getSecStructTypeFromDsspIndex(int)"}, "3699": {"callee_method_names": [], "method_name": "HeaderInfo.setIndex", "method_implementation": "{\n    this.index = index;\n}", "repo_id": "9", "comment": "/**\n * @param index the index to set\n */\n", "repo_name": "biojava-master/", "id": 3699, "method_signature": "void setIndex(Integer)"}, "3023": {"callee_method_names": ["Location.getSubLocations", "Location.isComplex", "List<Location>.addAll", "List<Location>.add"], "method_name": "AbstractLocation.getAllSubLocations", "method_implementation": "{\n    List<Location> flatSubLocations = new ArrayList<Location>();\n    for (Location l : location.getSubLocations()) {\n        if (l.isComplex()) {\n            flatSubLocations.addAll(getAllSubLocations(l));\n        } else {\n            flatSubLocations.add(l);\n        }\n    }\n    return flatSubLocations;\n}", "repo_id": "9", "comment": "/**\n * Here to allow for recursion\n */\n", "repo_name": "biojava-master/", "id": 3023, "method_signature": "List<Location> getAllSubLocations(Location)"}, "3647": {"callee_method_names": ["LinkedHashMap.put", "LinkedHashMap.put"], "method_name": "SurvivalInfo.addUnknownDataTypeVariable", "method_implementation": "{\n    originalMetaData.put(variable, value);\n    unknownDataType.put(variable, value);\n}", "repo_id": "9", "comment": "/**\n * @param variable\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 3647, "method_signature": "void addUnknownDataTypeVariable(String, String)"}, "135": {"callee_method_names": ["String.equals"], "method_name": "TestOutputStrings.test1a211hwgFlexible", "method_implementation": "{\n    String pdb1 = \"1a21\";\n    String chain1 = \"A\";\n    String pdb2 = \"1hwg\";\n    String chain2 = \"C\";\n    String originalOutput = \"Align 1a21A.pdb 194 with 1hwgC.pdb 191\" + newline + \"Twists 1 ini-len 120 ini-rmsd 3.04 opt-equ 150 opt-rmsd 2.96 chain-rmsd 4.21 Score 233.34 align-len 210 gaps 60 (28.57%)\" + newline + \"P-value 1.15e-05 Afp-num 12696 Identity 11.98% Similarity 23.95%\" + newline + \"Block  0 afp  4 score 66.42 rmsd  2.03 gap 6 (0.16%)\" + newline + \"Block  1 afp 11 score 184.29 rmsd  3.24 gap 69 (0.44%)\" + newline + \"\" + newline + \"                  .    :    .    :    .    :    .    :    .    :    .    :    .    :\" + newline + \"Chain 1:    6 RAYNLTWKSTN-FKTILEWEPKSIDHVYTVQISTRLENWKSKCFLTAE---TECDLTDEVVKDVGQTYMA\" + newline + \"              11111111111 111111111     111111111111111111       222222222   222222 \" + newline + \"Chain 2:   32 EPKFTKCRSPERETFSCHWTD-----PIQLFYTRRNQEWKECPDYVSAGENSCYFNSSFT---SIWIPYC\" + newline + \"\" + newline + \"                  .    :    .    :    .    :    .    :    .    :    .    :    .    :\" + newline + \"Chain 1:   72 RVLSYPARNTTGFPEEPPFRNSPEFTPYLDTNLGQPTIQSFEQVG-------TKLNVTVQDARTLVTFLS\" + newline + \"                                    22222222222222222222222       222222222222   222\" + newline + \"Chain 2:  109 IKLTSNGGTVDE----------KCFSVDEIVQPDPPIALNWTLLNVSLTGIHADIQVRWEAPRN---ADI\" + newline + \"\" + newline + \"                  .    :    .    :    .    :    .    :    .    :    .    :    .    :\" + newline + \"Chain 1:  141 LRAVFGKDLNYTLYYWR-----KKTAT-TNTNEFLIDVDKGE-NYCFSVQAVIPSRKRKQRSPESLTECT\" + newline + \"              222222  222222222     22222 22222222222222 2222222222222  222222222222\" + newline + \"Chain 2:  166 QKGWMV--LEYELQYKEVNETKWKMMDPILTTSVPVYSLKVDKEYEVRVRSKQRNS--GNYGEFSEVLYV\" + newline + \"\" + newline + \"Note: positions are from PDB; the numbers between alignments are block index\" + newline;\n    String result = MyTestHelper.compareAlignment(pdb1, chain1, pdb2, chain2, originalOutput, false);\n    if (!result.equals(\"\")) {\n        String msg = \"the created alignment images are not identical! \";\n        printMismatch(originalOutput, result);\n        printFirstMismatch(result, originalOutput);\n        Assert.fail(msg);\n    }\n}", "repo_id": "9", "comment": "//exact\n", "repo_name": "biojava-master/", "id": 135, "method_signature": "void test1a211hwgFlexible()"}, "2872": {"callee_method_names": ["DataInputStream.readByte"], "method_name": "ABITrace.setQcalls", "method_implementation": "{\n    qCalls = new int[seqLength];\n    byte[] qq = new byte[seqLength];\n    getSubArray(qq, PCON);\n    DataInputStream dis = new DataInputStream(new ByteArrayInputStream(qq));\n    for (int i = 0; i <= seqLength - 1; ++i) {\n        try {\n            qCalls[i] = (int) dis.readByte();\n        } catch (//This shouldn't happen. If it does something must be seriously wrong.\n        IOException e) {\n            throw new IllegalStateException(\"Unexpected IOException encountered while manipulating internal streams.\");\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Fetch the quality calls from the trace data.\n */\n", "repo_name": "biojava-master/", "id": 2872, "method_signature": "void setQcalls()"}, "1556": {"callee_method_names": ["String.isEmpty", "String.indexOf", "String.indexOf", "String.substring"], "method_name": "ScopDescription.getClassificationId", "method_implementation": "{\n    if (classificationId == null || classificationId.isEmpty()) {\n        return null;\n    }\n    int numParts = 0;\n    switch(category) {\n        case Family:\n            numParts++;\n        case Superfamily:\n            numParts++;\n        case Fold:\n            numParts++;\n        case Class:\n            numParts++;\n            break;\n        default:\n            throw new IllegalArgumentException(\"Only Class, Fold, Superfamily, and Family are supported.\");\n    }\n    int endChar = -1;\n    for (int i = 0; i < numParts - 1; i++) {\n        endChar = classificationId.indexOf('.', endChar + 1);\n        if (endChar < 0) {\n            // Not enough items in the classification for this category\n            return null;\n        }\n    }\n    endChar = classificationId.indexOf('.', endChar + 1);\n    if (endChar < 0) {\n        // category goes to the end\n        return classificationId;\n    } else {\n        return classificationId.substring(0, endChar);\n    }\n}", "repo_id": "9", "comment": "/**\n * Return a portion of the classificationID corresponding to the specified\n * category (class, fold, superfamily, family).\n *\n * <p>Example: for SCOP family \"b.5.1.1\",\n * getClassificationId(ScopCategory.Superfamily) => \"b.5.1\"\n */\n", "repo_name": "biojava-master/", "id": 1556, "method_signature": "String getClassificationId(ScopCategory)"}, "2225": {"callee_method_ids": [1785, 1785, 1785, 1785, 1785, 1785, 1784, 1784, 978, 978, 977, 977], "callee_method_names": ["Structure.getPDBHeader", "Structure.getPDBHeader", "PDBHeader.getNrBioAssemblies", "PDBHeader.getNrBioAssemblies", "PDBHeader.getNrBioAssemblies", "PDBHeader.getNrBioAssemblies", "PDBHeader.getNrBioAssemblies", "PDBHeader.getNrBioAssemblies", "PDBHeader.getBioAssemblies", "PDBHeader.getBioAssemblies", "Map<Integer, BioAssemblyInfo>.keySet", "Map<Integer, BioAssemblyInfo>.keySet", "Map<Integer, BioAssemblyInfo>.get", "Map<Integer, BioAssemblyInfo>.keySet", "Map<Integer, BioAssemblyInfo>.containsKey", "Map<Integer, BioAssemblyInfo>.get", "Map<Integer, BioAssemblyInfo>.get", "BioAssemblyInfo.getMacromolecularSize", "BioAssemblyInfo.getMacromolecularSize", "BioAssemblyInfo.getTransforms", "BioAssemblyInfo.getTransforms", "Matrix4d.getChainId", "Matrix4d.getChainId", "Matrix4d.getTransformationMatrix", "Matrix4d.getTransformationMatrix", "Structure.size", "Structure.size", "Atom[].toPDB", "Atom[].toPDB"], "method_name": "TestQuaternaryStructureProviders.comparePdbVsMmcif", "method_implementation": "{\n    Structure pdbS = getPdbBioAssembly(pdbId, bioMolecule, true);\n    Structure mmcifS = getMmcifBioAssembly(pdbId, bioMolecule, true);\n    PDBHeader pHeader = pdbS.getPDBHeader();\n    PDBHeader mHeader = mmcifS.getPDBHeader();\n    assertTrue(\"not correct nr of bioassemblies \" + pHeader.getNrBioAssemblies() + \" \", pHeader.getNrBioAssemblies() >= bioMolecule);\n    assertTrue(\"not correct nr of bioassemblies \" + mHeader.getNrBioAssemblies() + \" \", mHeader.getNrBioAssemblies() >= bioMolecule);\n    // mmcif files contain sometimes partial virus assemblies, so they can contain more info than pdb\n    assertTrue(pHeader.getNrBioAssemblies() <= mHeader.getNrBioAssemblies());\n    Map<Integer, BioAssemblyInfo> pMap = pHeader.getBioAssemblies();\n    Map<Integer, BioAssemblyInfo> mMap = mHeader.getBioAssemblies();\n    assertTrue(pMap.keySet().size() <= mMap.keySet().size());\n    assertEquals(mmSize, mMap.get(bioMolecule).getMacromolecularSize());\n    for (int k : pMap.keySet()) {\n        assertTrue(mMap.containsKey(k));\n        BioAssemblyInfo pBioAssemb = pMap.get(k);\n        BioAssemblyInfo mBioAssemb = mMap.get(k);\n        assertEquals(\"Macromolecular sizes don't coincide!\", pBioAssemb.getMacromolecularSize(), mBioAssemb.getMacromolecularSize());\n        List<BiologicalAssemblyTransformation> pL = pBioAssemb.getTransforms();\n        // mmcif list can be longer due to the use of internal chain IDs\n        List<BiologicalAssemblyTransformation> mL = mBioAssemb.getTransforms();\n        //assertEquals(pL.size(), mL.size());\n        for (BiologicalAssemblyTransformation m1 : pL) {\n            boolean found = false;\n            for (BiologicalAssemblyTransformation m2 : mL) {\n                if (!m1.getChainId().equals(m2.getChainId()))\n                    continue;\n                if (!m1.getTransformationMatrix().epsilonEquals(m2.getTransformationMatrix(), 0.0001))\n                    continue;\n                found = true;\n            }\n            if (!found) {\n                System.err.println(\"did not find matching matrix \" + m1);\n                System.err.println(mL);\n            }\n            assertTrue(found);\n        }\n    }\n    assertEquals(\"Not the same number of chains!\", pdbS.size(), mmcifS.size());\n    Atom[] pdbA = StructureTools.getAllAtomArray(pdbS);\n    Atom[] mmcifA = StructureTools.getAllAtomArray(mmcifS);\n    assertEquals(pdbA.length, mmcifA.length);\n    assertEquals(pdbA[0].toPDB(), mmcifA[0].toPDB());\n}", "repo_id": "9", "comment": "/**\n * Bioassembly tests for a single PDB entry\n * @param pdbId\n * @param bioMolecule the bio assembly identifier to test\n * @param mmSize the expected mmSize of given bioMolecule number\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2225, "method_signature": "void comparePdbVsMmcif(String, int, int)"}, "2442": {"callee_method_ids": [2431], "callee_method_names": ["FeatureI.userData", "FeatureList.add"], "method_name": "FeatureList.selectByUserData", "method_implementation": "{\n    FeatureList list = new FeatureList();\n    for (FeatureI f : this) {\n        if (f.userData().containsKey(key)) {\n            list.add(f);\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Create a list of all features that include the specified key in their userMap().\n *\n * @param key The key to consider.\n * @return A list of features that include the key.\n */\n", "repo_name": "biojava-master/", "id": 2442, "method_signature": "FeatureList selectByUserData(String)"}, "185": {"callee_method_ids": [1633, 1929, 1633, 1929], "callee_method_names": ["SubunitClustererParameters.setClustererMethod", "QuatSymmetryResults.getSymmetry", "QuatSymmetryResults.getStoichiometry", "SubunitClustererParameters.setClustererMethod", "QuatSymmetryResults.getSymmetry", "QuatSymmetryResults.getStoichiometry", "QuatSymmetryResults.isPseudoStoichiometric"], "method_name": "TestQuatSymmetryDetectorExamples.testPseudosymmetry", "method_implementation": "{\n    Structure pdb = StructureIO.getStructure(\"BIO:4hhb:1\");\n    // Non-pseudosymmetry\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n    clusterParams.setClustererMethod(SubunitClustererMethod.SEQUENCE);\n    QuatSymmetryParameters symmParams = new QuatSymmetryParameters();\n    QuatSymmetryResults symmetry = QuatSymmetryDetector.calcGlobalSymmetry(pdb, symmParams, clusterParams);\n    // C2 symmetry\n    assertEquals(\"C2\", symmetry.getSymmetry());\n    assertEquals(\"A2B2\", symmetry.getStoichiometry().toString());\n    // Use pseudosymmetry (structural clustering)\n    clusterParams.setClustererMethod(SubunitClustererMethod.STRUCTURE);\n    symmetry = QuatSymmetryDetector.calcGlobalSymmetry(pdb, symmParams, clusterParams);\n    // D2 pseudo-symmetry\n    assertEquals(\"D2\", symmetry.getSymmetry());\n    assertEquals(\"A4\", symmetry.getStoichiometry().toString());\n    assertTrue(symmetry.isPseudoStoichiometric());\n}", "repo_id": "9", "comment": "/**\n * Hemoglobin has both symmetry and pseudosymmetry: 4HHB\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 185, "method_signature": "void testPseudosymmetry()"}, "1966": {"callee_method_names": ["Vector3d.sub", "Vector3d.scale"], "method_name": "HelixAxisAligner.getDimension", "method_implementation": "{\n    run();\n    Vector3d dimension = new Vector3d();\n    dimension.sub(maxBoundary, minBoundary);\n    dimension.scale(0.5);\n    return dimension;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getDimension()\n\t */\n", "repo_name": "biojava-master/", "id": 1966, "method_signature": "Vector3d getDimension()"}, "3842": {"callee_method_names": ["String.toCharArray", "Set<Character>.contains", "StringBuilder.append", "Set<Character>.add", "StringBuilder.append", "StringBuilder.append", "StringBuilder.deleteCharAt", "StringBuilder.length", "StringBuilder.append", "Logger.warn", "StringBuilder.toString", "StringBuilder.toString"], "method_name": "Utils.cleanSequence", "method_implementation": "{\n    Set<Character> invalidCharSet = new HashSet<Character>();\n    StringBuilder cleanSeq = new StringBuilder();\n    if (cSet == null)\n        cSet = PeptideProperties.standardAASet;\n    for (char c : sequence.toCharArray()) {\n        if (!cSet.contains(c)) {\n            cleanSeq.append(\"-\");\n            invalidCharSet.add(c);\n        } else {\n            cleanSeq.append(c);\n        }\n    }\n    // TODO: Should be StringJoiner once JDK8 used\n    StringBuilder stringBuilder = new StringBuilder();\n    for (char c : invalidCharSet) {\n        stringBuilder.append(\"\\'\" + c + \"\\'\");\n    }\n    stringBuilder.deleteCharAt(stringBuilder.length() - 1);\n    stringBuilder.append(\" are being replaced with '-'\");\n    logger.warn(stringBuilder.toString());\n    return cleanSeq.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns a new sequence with all invalid characters being replaced by '-'.\n * Note that any character outside of the 20 standard protein amino acid codes are considered as invalid.\n *\n * @param sequence\n * \t\tprotein sequence to be clean\n * @param cSet\n * \t\tuser defined characters that are valid. Can be null. If null, then 20 standard protein amino acid codes will be considered as valid.\n * @return\n * \t\ta new sequence with all invalid characters being replaced by '-'.\n */\n", "repo_name": "biojava-master/", "id": 3842, "method_signature": "String cleanSequence(String, Set)"}, "2256": {"callee_method_names": ["List<Atom>.add", "List<Atom>.add", "List<Atom>.add"], "method_name": "TestMmtfUtils.testGetNumBondsFromGroup", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>();\n    Atom atomOne = new AtomImpl();\n    Atom atomTwo = new AtomImpl();\n    Atom atomThree = new AtomImpl();\n    atoms.add(atomOne);\n    atoms.add(atomTwo);\n    atoms.add(atomThree);\n    // Make the same bond twice iwth different atom orders\n    new BondImpl(atomOne, atomTwo, 2);\n    new BondImpl(atomTwo, atomOne, 2);\n    // Make the same bond twice\n    new BondImpl(atomOne, atomThree, 2);\n    new BondImpl(atomOne, atomThree, 2);\n    // Make this bond twice with different orders\n    new BondImpl(atomTwo, atomThree, 2);\n    new BondImpl(atomTwo, atomThree, 1);\n    assertEquals(3, MmtfUtils.getNumBondsInGroup(atoms));\n}", "repo_id": "9", "comment": "/**\n * Test getting the number of bonds from a list of atoms.\n */\n", "repo_name": "biojava-master/", "id": 2256, "method_signature": "void testGetNumBondsFromGroup()"}, "1102": {"callee_method_names": [], "method_name": "DownloadChemCompProvider.setDownloadAll", "method_implementation": "{\n    this.downloadAll = downloadAll;\n}", "repo_id": "9", "comment": "/**\n * By default this provider will download only some of the {@link ChemComp} files.\n * The user has to request that all files should be downloaded by setting this parameter to true.\n *\n * @param downloadAll if the all components should be downloaded and installed at startup. (default: false)\n */\n", "repo_name": "biojava-master/", "id": 1102, "method_signature": "void setDownloadAll(boolean)"}, "3002": {"callee_method_names": [], "method_name": "BitSequenceReader.getCompoundSet", "method_implementation": "{\n    return compoundSet;\n}", "repo_id": "9", "comment": "/**\n * Returns the compound set backing this store\n */\n", "repo_name": "biojava-master/", "id": 3002, "method_signature": "CompoundSet<C> getCompoundSet()"}, "960": {"callee_method_names": ["Matrix4d.transform"], "method_name": "BiologicalAssemblyTransformation.transformPoint", "method_implementation": "{\n    Point3d p = new Point3d(point[0], point[1], point[2]);\n    transformation.transform(p);\n    point[0] = p.x;\n    point[1] = p.y;\n    point[2] = p.z;\n}", "repo_id": "9", "comment": "/**\n * Applies the transformation to given point.\n */\n", "repo_name": "biojava-master/", "id": 960, "method_signature": "void transformPoint(double[])"}, "133": {"callee_method_names": ["SubstitutionMatrix<NucleotideCompound>.getMatrix", "SubstitutionMatrix<NucleotideCompound>.getValue", "DNACompoundSet.getCompoundForString", "DNACompoundSet.getCompoundForString", "SubstitutionMatrix<NucleotideCompound>.getValue", "DNACompoundSet.getCompoundForString", "DNACompoundSet.getCompoundForString", "SubstitutionMatrix<NucleotideCompound>.getValue", "DNACompoundSet.getCompoundForString", "DNACompoundSet.getCompoundForString", "SubstitutionMatrix<NucleotideCompound>.getValue", "DNACompoundSet.getCompoundForString", "DNACompoundSet.getCompoundForString"], "method_name": "SimpleSubstitutionMatrixTest.testCaseEquivalence", "method_implementation": "{\n    DNACompoundSet dnacs = DNACompoundSet.getDNACompoundSet();\n    SubstitutionMatrix<NucleotideCompound> dnaTest = new SimpleSubstitutionMatrix<NucleotideCompound>(dnacs, \"# Test\\nA C G T\\nA 5 0 0 0\\nC 0 5 0 0\\nG 0 0 5 0\\nT 0 0 0 1\\n\", \"DNA Test\");\n    @SuppressWarnings(\"unused\")\n    short[][] matrix = dnaTest.getMatrix();\n    assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"G\"), dnacs.getCompoundForString(\"g\")), 5);\n    assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"A\"), dnacs.getCompoundForString(\"g\")), 0);\n    assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"g\"), dnacs.getCompoundForString(\"G\")), 5);\n    assertEquals(dnaTest.getValue(dnacs.getCompoundForString(\"g\"), dnacs.getCompoundForString(\"A\")), 0);\n}", "repo_id": "9", "comment": "/*\n\t * Author: Daniel Cameron\n\t */\n", "repo_name": "biojava-master/", "id": 133, "method_signature": "void testCaseEquivalence()"}, "2655": {"callee_method_names": [], "method_name": "TranscriptionEngine.waitForStartCodon", "method_implementation": "{\n    this.waitForStartCodon = waitForStartCodon;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * If set, then translation will not start until a start codon is\n * encountered\n */\n", "repo_name": "biojava-master/", "id": 2655, "method_signature": "Builder waitForStartCodon(boolean)"}, "986": {"callee_method_names": [], "method_name": "HetatomImpl.getType", "method_implementation": "{\n    return type;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 986, "method_signature": "GroupType getType()"}, "2404": {"callee_method_names": [], "method_name": "Location.iterator", "method_implementation": "{\n    return new LocIterator(this, windowSize, increment);\n}", "repo_id": "9", "comment": "/**\n * Create a location iterator over this location,\n * using specified window size and increment.\n *\n * @param windowSize The number of symbols to get on each iteration.\n * @param increment The direction and number of symbols to advance at each iteration.\n * @return An iterator over a Location (a LocIterator object).\n */\n", "repo_name": "biojava-master/", "id": 2404, "method_signature": "LocIterator iterator(int, int)"}, "3092": {"callee_method_names": [], "method_name": "AbstractFeature.getUserObject", "method_implementation": "{\n    return userObject;\n}", "repo_id": "9", "comment": "/**\n * @return the userObject\n */\n", "repo_name": "biojava-master/", "id": 3092, "method_signature": "Object getUserObject()"}, "1145": {"callee_method_names": [], "method_name": "SSBondImpl.setSerNum", "method_implementation": "{\n    this.serNum = serNum;\n}", "repo_id": "9", "comment": "/**\n * get serial number of this SSBOND in PDB file\n *\n * @param serNum\n */\n", "repo_name": "biojava-master/", "id": 1145, "method_signature": "void setSerNum(int)"}, "1404": {"callee_method_names": ["CrystalCell.getA"], "method_name": "PDBCrystallographicInfo.getA", "method_implementation": "{\n    return (float) cell.getA();\n}", "repo_id": "9", "comment": "/**\n * @return the unit cell parameter a\n */\n", "repo_name": "biojava-master/", "id": 1404, "method_signature": "float getA()"}, "1385": {"callee_method_names": [], "method_name": "DBRef.setDbSeqEnd", "method_implementation": "{\n    this.dbSeqEnd = dbSeqEnd;\n}", "repo_id": "9", "comment": "/**\n * The begin of the sequence position in the database\n *\n * @param dbSeqEnd sequence position\n * @see #getDbSeqEnd()\n */\n", "repo_name": "biojava-master/", "id": 1385, "method_signature": "void setDbSeqEnd(int)"}, "2127": {"callee_method_names": ["Class<?>.setStructure", "Model.setChains", "List<Model>.isEmpty", "List<Model>.add", "List<Model>.set"], "method_name": "StructureImpl.setModel", "method_implementation": "{\n    if (modelChains == null)\n        throw new IllegalArgumentException(\"trying to set model to null!\");\n    for (Chain c : modelChains) c.setStructure(this);\n    //System.out.println(\"model size:\" + models.size());\n    Model model = new Model();\n    model.setChains(modelChains);\n    if (models.isEmpty()) {\n        models.add(model);\n    } else {\n        models.set(position, model);\n    }\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2127, "method_signature": "void setModel(int, List)"}, "958": {"callee_method_names": [], "method_name": "BiologicalAssemblyTransformation.setTransformationMatrix", "method_implementation": "{\n    this.transformation = transformation;\n}", "repo_id": "9", "comment": "/**\n * Sets the transformation using a 4x4 transformation matrix\n * @param transformation\n */\n", "repo_name": "biojava-master/", "id": 958, "method_signature": "void setTransformationMatrix(Matrix4d)"}, "2832": {"callee_method_names": [], "method_name": "GenericGenbankHeaderParser.setAccession", "method_implementation": "{\n    if (accession == null)\n        throw new ParserException(\"Accession cannot be null\");\n    this.accession = accession;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n * The last accession passed to this routine will always be the one used.\n */\n", "repo_name": "biojava-master/", "id": 2832, "method_signature": "void setAccession(String)"}, "1079": {"callee_method_names": ["File.listFiles", "String.endsWith"], "method_name": "ZipChemCompProvider.finder", "method_implementation": "{\n    if (null == dirName || null == suffix) {\n        return null;\n    }\n    final File dir = new File(dirName);\n    return dir.listFiles((dir1, filename) -> filename.endsWith(suffix));\n}", "repo_id": "9", "comment": "/**\n * Return File(s) in dirName that match suffix.\n * @param dirName\n * @param suffix\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1079, "method_signature": "File[] finder(String, String)"}, "2834": {"callee_method_names": [], "method_name": "GenericGenbankHeaderParser.setIdentifier", "method_implementation": "{\n    if (identifier == null)\n        throw new ParserException(\"Identifier cannot be null\");\n    if (this.identifier != null)\n        throw new ParserException(\"Current BioEntry already has a identifier\");\n    this.identifier = identifier;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2834, "method_signature": "void setIdentifier(String)"}, "3272": {"callee_method_names": ["Logger.error", "Structure.getPDBCode", "JmolPanel.setStructure"], "method_name": "AbstractAlignmentJmol.setStructure", "method_implementation": "{\n    if (jmolPanel == null) {\n        logger.error(\"please install Jmol first\");\n        return;\n    }\n    setTitle(s.getPDBCode());\n    jmolPanel.setStructure(s);\n    // actually this is very simple\n    // just convert the structure to a PDB file\n    //String pdb = s.toPDB();\n    //System.out.println(s.isNmr());\n    //System.out.println(pdb);\n    // Jmol could also read the file directly from your file system\n    //viewer.openFile(\"/Path/To/PDB/1tim.pdb\");\n    //System.out.println(pdb);\n    //jmolPanel.openStringInline(pdb);\n    // send the PDB file to Jmol.\n    // there are also other ways to interact with Jmol,\n    // e.g make it directly\n    // access the biojava structure object, but they require more\n    // code. See the SPICE code repository for how to do this.\n    structure = s;\n}", "repo_id": "9", "comment": "/**\n * Set a new Structure to visualize in the AlignmentJmol window.\n * @param s\n */\n", "repo_name": "biojava-master/", "id": 3272, "method_signature": "void setStructure(Structure)"}, "3603": {"callee_method_names": ["ArrayList<String>.size", "ArrayList<String>.size", "ArrayList<String>.size", "ArrayList<String>.get", "LinkedHashMap<String, Double>.get", "LinkedHashMap<String, Double>.put", "LinkedHashMap<String, Double>.size", "LinkedHashMap<String, Double>.keySet", "ArrayList<String>.size", "ArrayList<String>.get", "LinkedHashMap<String, Double>.get", "LinkedHashMap<String, Double>.clear"], "method_name": "ResidualsCoxph.rowsum", "method_implementation": "{\n    LinkedHashMap<String, Double> sumMap = new LinkedHashMap<String, Double>();\n    if (rr.length != sets.size()) {\n        throw new Exception(\"Cluster value for each sample are not of equal length n=\" + rr.length + \" cluster length=\" + sets.size());\n    }\n    double[][] sum = null;\n    for (int j = 0; j < rr[0].length; j++) {\n        for (int i = 0; i < sets.size(); i++) {\n            String s = sets.get(i);\n            //get in order\n            Double v = sumMap.get(s);\n            if (v == null) {\n                v = 0.0;\n            }\n            v = v + rr[i][j];\n            sumMap.put(s, v);\n        }\n        if (sum == null) {\n            sum = new double[sumMap.size()][rr[0].length];\n        }\n        ArrayList<String> index = new ArrayList<String>(sumMap.keySet());\n        //sorting does seem to make a difference in test cases at the .0000000001\n        //     ArrayList<Integer> in = new ArrayList<Integer>();\n        //     for (String s : index) {\n        //         in.add(Integer.parseInt(s));\n        //     }\n        //     Collections.sort(index);\n        for (int m = 0; m < index.size(); m++) {\n            String key = index.get(m);\n            sum[m][j] = sumMap.get(key);\n        }\n        sumMap.clear();\n    }\n    return sum;\n}", "repo_id": "9", "comment": "/**\n * From R in residuals.coxph.S rowsum(rr, collapse)\n *\n * @param rr\n * @param sets\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3603, "method_signature": "double[][] rowsum(double[][], ArrayList)"}, "3337": {"callee_method_names": ["AlignmentGui.setVisible"], "method_name": "MenuCreator.showPairDialog", "method_implementation": "{\n    AlignmentGui gui = AlignmentGui.getInstance();\n    gui.setVisible(true);\n}", "repo_id": "9", "comment": "/**\n * provide a display for the pairwise structure alignment\n */\n", "repo_name": "biojava-master/", "id": 3337, "method_signature": "void showPairDialog()"}, "2211": {"callee_method_names": ["Group.getPDBName", "Group.getPDBName", "Group.getAtoms", "Group.getAtoms", "Group.getAtoms", "Group.getAtoms", "Atom.getAltLoc", "Atom.getAltLoc"], "method_name": "TestAltLocs.ensureAllAtomsSameAltCode", "method_implementation": "{\n    // If they're the exact same group just return\n    if (groupInputAltLocGroup == inputMainGroup) {\n        return;\n    }\n    // Check that the atom group is the same size as the alt loc group (as long as it's not a case of microheterogenity\n    if (groupInputAltLocGroup.getPDBName().equals(inputMainGroup.getPDBName())) {\n        assertEquals(groupInputAltLocGroup.getAtoms().size(), inputMainGroup.getAtoms().size());\n    }\n    Character defaultAltLoc = null;\n    for (Atom atom : groupInputAltLocGroup.getAtoms()) {\n        // If this is in the original atom group just carry on\n        if (inputMainGroup.getAtoms().contains(atom)) {\n            continue;\n        }\n        if (defaultAltLoc == null) {\n            defaultAltLoc = atom.getAltLoc();\n            continue;\n        }\n        Character altLoc = atom.getAltLoc();\n        assertEquals(defaultAltLoc, altLoc);\n    }\n}", "repo_id": "9", "comment": "/**\n * Test to check that all atoms have the same alt code (unless they're in the main group)\n * @param groupInputAltLocGroup The input alt loc group\n */\n", "repo_name": "biojava-master/", "id": 2211, "method_signature": "void ensureAllAtomsSameAltCode(Group, Group)"}, "213": {"callee_method_names": ["Logger.info", "Matcher.find"], "method_name": "SequenceUtil.isProteinSequence", "method_implementation": "{\n    sequence = SequenceUtil.cleanSequence(sequence);\n    if (SequenceUtil.isNonAmbNucleotideSequence(sequence)) {\n        return false;\n    }\n    if (SequenceUtil.DIGIT.matcher(sequence).find()) {\n        return false;\n    }\n    if (SequenceUtil.NON_AA.matcher(sequence).find()) {\n        logger.info(\"Found non aa: {}\", sequence);\n        return false;\n    }\n    final Matcher protmatcher = SequenceUtil.AA.matcher(sequence);\n    return protmatcher.find();\n}", "repo_id": "9", "comment": "/**\n * @param sequence\n * @return true is the sequence is a protein sequence, false overwise\n */\n", "repo_name": "biojava-master/", "id": 213, "method_signature": "boolean isProteinSequence(String)"}, "1801": {"callee_method_names": ["ReadWriteLock.readLock", "Logger.trace", "Logger.trace", "ReadWriteLock.readLock", "ReadWriteLock.readLock", "Logger.trace", "Map<PdbId, List<EcodDomain>>.get", "List<EcodDomain>.size", "List<EcodDomain>.add", "Logger.trace", "ReadWriteLock.readLock"], "method_name": "EcodInstallation.getDomainsForPdb", "method_implementation": "{\n    domainsFileLock.readLock().lock();\n    try {\n        logger.trace(\"LOCK readlock\");\n        while (domainMap == null) {\n            // unlock to allow ensureDomainsFileInstalled to get the write lock\n            logger.trace(\"UNLOCK readlock\");\n            domainsFileLock.readLock().unlock();\n            indexDomains();\n            domainsFileLock.readLock().lock();\n            logger.trace(\"LOCK readlock\");\n        }\n        PdbId pdbId = null;\n        try {\n            pdbId = new PdbId(id);\n        } catch (IllegalArgumentException e) {\n            return null;\n        }\n        List<EcodDomain> doms = domainMap.get(pdbId);\n        if (doms == null) {\n            return null;\n        }\n        // Deep clone\n        List<EcodDomain> clonedDoms = new ArrayList<EcodDomain>(doms.size());\n        for (EcodDomain d : doms) {\n            clonedDoms.add(new EcodDomain(d));\n        }\n        return clonedDoms;\n    } finally {\n        logger.trace(\"UNLOCK readlock\");\n        domainsFileLock.readLock().unlock();\n    }\n}", "repo_id": "9", "comment": "/**\n * \tpublic EcodInstallation(String cacheLocation) {\n * \t\tthis( cacheLocation, DEFAULT_VERSION );\n * \t}\n *\n * \t/**\n *  Get a list of all ECOD domains for a particular PDB ID\n *  @param id\n *  @return the list of domains, or null if no matching domains were found\n *  @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1801, "method_signature": "List<EcodDomain> getDomainsForPdb(String)"}, "1139": {"callee_method_names": ["String.length", "String.substring", "String.substring", "File.exists", "File.mkdirs", "Logger.error", "File.toString"], "method_name": "LocalPDBDirectory.getDir", "method_implementation": "{\n    File dir = null;\n    int offset = pdbId.length() - 3;\n    if (obsolete) {\n        // obsolete is always split\n        String middle = pdbId.substring(offset, offset + 2).toLowerCase();\n        dir = new File(obsoleteDirPath, middle);\n    } else {\n        String middle = pdbId.substring(offset, offset + 2).toLowerCase();\n        dir = new File(splitDirPath, middle);\n    }\n    if (!dir.exists()) {\n        boolean success = dir.mkdirs();\n        if (!success)\n            logger.error(\"Could not create mmCIF dir {}\", dir.toString());\n    }\n    return dir;\n}", "repo_id": "9", "comment": "/**\n * Gets the directory in which the file for a given MMCIF file would live,\n * creating it if necessary.\n *\n * The obsolete parameter is necessary to avoid additional server queries.\n * @param pdbId\n * @param obsolete Whether the pdbId is obsolete or not\n * @return File pointing to the directory,\n */\n", "repo_name": "biojava-master/", "id": 1139, "method_signature": "File getDir(String, boolean)"}, "217": {"callee_method_names": ["BufferedWriter.write", "BufferedWriter.close", "OutputStreamWriter.close"], "method_name": "SequenceUtil.writeFasta", "method_implementation": "{\n    final OutputStreamWriter outWriter = new OutputStreamWriter(os);\n    final BufferedWriter fasta_out = new BufferedWriter(outWriter);\n    for (final FastaSequence fs : sequences) {\n        fasta_out.write(fs.getOnelineFasta());\n    }\n    fasta_out.close();\n    outWriter.close();\n}", "repo_id": "9", "comment": "/**\n * Writes FastaSequence in the file, each sequence will take one line only\n *\n * @param os\n * @param sequences\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 217, "method_signature": "void writeFasta(OutputStream, List)"}, "1745": {"callee_method_names": [], "method_name": "BasePairParameters.match", "method_implementation": "{\n    if (a == 'A' && b == 'T' && !RNA)\n        return true;\n    if (a == 'A' && b == 'U' && RNA)\n        return true;\n    if (a == 'T' && b == 'A' && !RNA)\n        return true;\n    if (a == 'U' && b == 'A' && RNA)\n        return true;\n    if (a == 'G' && b == 'C')\n        return true;\n    if (a == 'C' && b == 'G')\n        return true;\n    return false;\n}", "repo_id": "9", "comment": "/**\n * This returns true if a is the complement of b, false otherwise. (used internally)\n * @param a First letter\n * @param b Potential matching letter\n * @param RNA Whether it is RNA (if false, DNA rules are used)\n * @return True if the bases are complementary.\n */\n", "repo_name": "biojava-master/", "id": 1745, "method_signature": "boolean match(char, char, boolean)"}, "210": {"callee_method_names": ["Matcher.find"], "method_name": "SequenceUtil.isNonAmbNucleotideSequence", "method_implementation": "{\n    sequence = SequenceUtil.cleanSequence(sequence);\n    if (SequenceUtil.DIGIT.matcher(sequence).find()) {\n        return false;\n    }\n    if (SequenceUtil.NON_NUCLEOTIDE.matcher(sequence).find()) {\n        return false;\n        /*\n\t\t * System.out.format(\"I found the text starting at \" +\n\t\t * \"index %d and ending at index %d.%n\", nonDNAmatcher .start(),\n\t\t * nonDNAmatcher.end());\n\t\t */\n    }\n    final Matcher DNAmatcher = SequenceUtil.NUCLEOTIDE.matcher(sequence);\n    return DNAmatcher.find();\n}", "repo_id": "9", "comment": "/**\n * Ambiguous DNA chars : AGTCRYMKSWHBVDN // differs from protein in only one\n * (!) - B char\n */\n", "repo_name": "biojava-master/", "id": 210, "method_signature": "boolean isNonAmbNucleotideSequence(String)"}, "1989": {"callee_method_names": ["QuatSymmetrySubunits.getTraces", "Point3d.set", "Matrix4d.transform"], "method_name": "RotationAxisAligner.calcBoundaries", "method_implementation": "{\n    minBoundary.x = Double.MAX_VALUE;\n    maxBoundary.x = Double.MIN_VALUE;\n    minBoundary.y = Double.MAX_VALUE;\n    maxBoundary.x = Double.MIN_VALUE;\n    minBoundary.z = Double.MAX_VALUE;\n    maxBoundary.z = Double.MIN_VALUE;\n    Point3d probe = new Point3d();\n    for (Point3d[] list : subunits.getTraces()) {\n        for (Point3d p : list) {\n            probe.set(p);\n            transformationMatrix.transform(probe);\n            minBoundary.x = Math.min(minBoundary.x, probe.x);\n            maxBoundary.x = Math.max(maxBoundary.x, probe.x);\n            minBoundary.y = Math.min(minBoundary.y, probe.y);\n            maxBoundary.y = Math.max(maxBoundary.y, probe.y);\n            minBoundary.z = Math.min(minBoundary.z, probe.z);\n            maxBoundary.z = Math.max(maxBoundary.z, probe.z);\n            xyRadiusMax = Math.max(xyRadiusMax, Math.sqrt(probe.x * probe.x + probe.y * probe.y));\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Calculates the min and max boundaries of the structure after it has been\n * transformed into its canonical orientation.\n */\n", "repo_name": "biojava-master/", "id": 1989, "method_signature": "void calcBoundaries()"}, "2842": {"callee_method_names": ["Formatter.format", "S.getOriginalHeader", "Formatter.toString", "Formatter.close"], "method_name": "GenericGenbankHeaderFormat._write_original_first_line", "method_implementation": "{\n    StringBuilder sb = new StringBuilder();\n    Formatter formatter = new Formatter(sb, Locale.US);\n    formatter.format(\"LOCUS       %s\" + lineSep, StringManipulationHelper.padRight(sequence.getOriginalHeader(), 16));\n    String output = formatter.toString();\n    formatter.close();\n    return output;\n}", "repo_id": "9", "comment": "/**\n * Write the original LOCUS line.\n *\n * @param sequence\n */\n", "repo_name": "biojava-master/", "id": 2842, "method_signature": "String _write_original_first_line(S)"}, "3062": {"callee_method_names": [], "method_name": "GeneSequence.getStrand", "method_implementation": "{\n    return strand;\n}", "repo_id": "9", "comment": "/**\n * A gene should have Strand\n * @return the strand\n */\n", "repo_name": "biojava-master/", "id": 3062, "method_signature": "Strand getStrand()"}, "2298": {"callee_method_names": ["Structure.nrModels", "Structure.getChains", "ChemComp.getAtomGroups", "Group.size", "Group.getAtoms", "Group.getAltLocs", "List<Atom>.addAll", "Block.getBonds", "Logger.debug", "Block.getPDBserial", "Block.getName"], "method_name": "TestBond.countAtomsWithoutBonds", "method_implementation": "{\n    Structure inputStructure = StructureIO.getStructure(pdbId);\n    // Loop through the structure\n    int nonBondedCounter = 0;\n    for (int i = 0; i < inputStructure.nrModels(); i++) {\n        for (Chain c : inputStructure.getChains(i)) {\n            for (Group g : c.getAtomGroups()) {\n                // Skip single atom groups\n                if (g.size() <= 1) {\n                    continue;\n                }\n                // Get all the atoms\n                List<Atom> atomsList = new ArrayList<>(g.getAtoms());\n                for (Group altLocOne : g.getAltLocs()) {\n                    atomsList.addAll(altLocOne.getAtoms());\n                }\n                // Check they all have bonds\n                for (Atom a : atomsList) {\n                    if (a.getBonds() == null) {\n                        logger.debug(\"Atom {}-{} has no bonds\", a.getPDBserial(), a.getName());\n                        nonBondedCounter++;\n                    }\n                }\n            }\n        }\n    }\n    return nonBondedCounter;\n}", "repo_id": "9", "comment": "/**\n * Loops through whole structure counting all atoms (in groups larger than 1 atom)\n * that have no bonds.\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2298, "method_signature": "int countAtomsWithoutBonds(String)"}, "3486": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.setBlastDatabase", "method_implementation": "{\n    setAlignmentOption(DATABASE, database);\n}", "repo_id": "9", "comment": "/**\n * Sets the database to be used with blastall\n * <p>\n * A list of available databases can be acquired by calling {@link NCBIQBlastService#printRemoteBlastInfo()}\n * <p>\n * Blastall equivalent: -d\n *\n * @param db : a valid name to a NCBI blastable database\n */\n", "repo_name": "biojava-master/", "id": 3486, "method_signature": "void setBlastDatabase(String)"}, "1393": {"callee_method_names": [], "method_name": "DBRef.setSeqBegin", "method_implementation": "{\n    this.seqbegin = seqbegin;\n}", "repo_id": "9", "comment": "/**\n *   Initial sequence number of the PDB sequence segment.\n *\n * @param seqbegin start seq. position\n * @see #getSeqBegin()\n */\n", "repo_name": "biojava-master/", "id": 1393, "method_signature": "void setSeqBegin(int)"}, "1086": {"callee_method_names": ["UserConfiguration.getCacheFilePath"], "method_name": "AllChemCompProvider.initPath", "method_implementation": "{\n    if (path == null) {\n        UserConfiguration config = new UserConfiguration();\n        path = config.getCacheFilePath();\n    }\n}", "repo_id": "9", "comment": "/**\n * make sure all paths are initialized correctly\n */\n", "repo_name": "biojava-master/", "id": 1086, "method_signature": "void initPath()"}, "1638": {"callee_method_names": [], "method_name": "SubunitClustererParameters.isOptimizeAlignment", "method_implementation": "{\n    return optimizeAlignment;\n}", "repo_id": "9", "comment": "/**\n * Whether the alignment algorithm should try its best to optimize the alignment,\n * or we are happy with a quick and dirty result. Effect depends on implementation\n * of the specific algorithm's method.\t *\n *\n * @return optimizeAlignment\n */\n", "repo_name": "biojava-master/", "id": 1638, "method_signature": "boolean isOptimizeAlignment()"}, "1930": {"callee_method_ids": [1921, 1935], "callee_method_names": ["HelixLayers.size", "HelixLayers.getScores", "RotationGroup.getOrder", "RotationGroup.getScores"], "method_name": "QuatSymmetryResults.getScores", "method_implementation": "{\n    if (helixLayers != null && helixLayers.size() > 0) {\n        return helixLayers.getScores();\n    } else if (rotationGroup != null && rotationGroup.getOrder() > 0) {\n        return rotationGroup.getScores();\n    }\n    return new QuatSymmetryScores();\n}", "repo_id": "9", "comment": "/**\n * @return the quaternary scores as an object\n */\n", "repo_name": "biojava-master/", "id": 1930, "method_signature": "QuatSymmetryScores getScores()"}, "2755": {"callee_method_names": [], "method_name": "EmblReference.getReferenceComment", "method_implementation": "{\n    return referenceComment;\n}", "repo_id": "9", "comment": "/**\n * The RC (Reference Comment) linetype is an optional linetype which appears if\n * The reference has a comment.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2755, "method_signature": "String getReferenceComment()"}, "1064": {"callee_method_names": ["String.substring", "String.substring", "String.substring"], "method_name": "CathDomain.getPdbIdAndChain", "method_implementation": "{\n    return domainName.substring(0, 4) + (!\"0\".equals(domainName.substring(4, 5)) ? \".\" + domainName.substring(4, 5) : \"\");\n}", "repo_id": "9", "comment": "/**\n * Returns a string of the form {@code PDBID.CHAIN}.\n * For example: {@code 1hiv.A}.\n */\n", "repo_name": "biojava-master/", "id": 1064, "method_signature": "String getPdbIdAndChain()"}, "1689": {"callee_method_names": [], "method_name": "AtomImpl.setPDBserial", "method_implementation": "{\n    pdbserial = i;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1689, "method_signature": "void setPDBserial(int)"}, "2260": {"callee_method_names": [], "method_name": "TestMmtfUtils.testGetNcsMatrix", "method_implementation": "{\n    double[][] testData = new double[][] { { 1.0, 2.0, 3.0, 4.0, 11.0, 12.0, 13.0, 14.0, 21.0, 22.0, 23.0, 24.0, 31.0, 32.0, 33.0, 34.0 } };\n    testInput(testData);\n}", "repo_id": "9", "comment": "/**\n * Test that the NCS data can be roundtripped.\n */\n", "repo_name": "biojava-master/", "id": 2260, "method_signature": "void testGetNcsMatrix()"}, "3328": {"callee_method_names": [], "method_name": "SequenceDisplay.setIdx1", "method_implementation": "{\n    this.idx1 = idx;\n}", "repo_id": "9", "comment": "/**\n * set the identical positions in the alignment\n *\n * @param idx identical positions for structure1\n */\n", "repo_name": "biojava-master/", "id": 3328, "method_signature": "void setIdx1(int[])"}, "1173": {"callee_method_names": ["String.substring", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "String.length", "String.substring", "String.substring", "String.length", "Logger.debug", "String.split", "ArrayList.contains", "ArrayList.contains", "Logger.debug", "String.replace", "StringTokenizer.hasMoreTokens", "StringTokenizer.nextToken", "String.equals", "ArrayList.contains", "Logger.debug", "String.concat", "Logger.debug", "String.equals", "ArrayList.contains"], "method_name": "PDBFileParser.pdb_SOURCE_Handler", "method_implementation": "{\n    // works in the same way as the pdb_COMPND_Handler.\n    String continuationNr = line.substring(9, 10).trim();\n    logger.debug(\"current continuationNo     is {}\", continuationNr);\n    logger.debug(\"previousContinuationField  is {}\", previousContinuationField);\n    logger.debug(\"current continuationField  is {}\", continuationField);\n    logger.debug(\"current continuationString is {}\", continuationString);\n    logger.debug(\"current compound           is {}\", current_compound);\n    // following the docs, the last valid character should be 79, chop off the rest\n    if (line.length() > 79) {\n        line = line.substring(0, 79);\n    }\n    line = line.substring(10, line.length());\n    logger.debug(\"LINE: >{}<\", line);\n    String[] fieldList = line.split(\"\\\\s+\");\n    if (!\"\".equals(fieldList[0]) && sourceFieldValues.contains(fieldList[0])) {\n        //\t\t\tSystem.out.println(\"[PDBFileParser.pdb_COMPND_Handler] Setting continuationField to '\" + fieldList[0] + \"'\");\n        continuationField = fieldList[0];\n        if (\"\".equals(previousContinuationField)) {\n            previousContinuationField = continuationField;\n        }\n    } else if ((fieldList.length > 1) && (sourceFieldValues.contains(fieldList[1]))) {\n        //\t\t\tSystem.out.println(\"[PDBFileParser.pdb_COMPND_Handler] Setting continuationField to '\" + fieldList[1] + \"'\");\n        continuationField = fieldList[1];\n        if (\"\".equals(previousContinuationField)) {\n            previousContinuationField = continuationField;\n        }\n    } else {\n        if (\"\".equals(continuationNr)) {\n            logger.debug(\"looks like an old PDB file\");\n            continuationField = \"MOLECULE:\";\n            if (\"\".equals(previousContinuationField)) {\n                previousContinuationField = continuationField;\n            }\n        }\n    }\n    line = line.replace(continuationField, \"\").trim();\n    StringTokenizer compndTokens = new StringTokenizer(line);\n    //\t\tSystem.out.println(\"PDBFileParser.pdb_COMPND_Handler: Tokenizing '\" + line + \"'\");\n    while (compndTokens.hasMoreTokens()) {\n        String token = compndTokens.nextToken();\n        if (\"\".equals(previousContinuationField)) {\n            //\t\t\t\tSystem.out.println(\"previousContinuationField is empty. Setting to : \" + continuationField);\n            previousContinuationField = continuationField;\n        }\n        if (previousContinuationField.equals(continuationField) && sourceFieldValues.contains(continuationField)) {\n            logger.debug(\"Still in field {}\", continuationField);\n            continuationString = continuationString.concat(token + \" \");\n            logger.debug(\"continuationString = {}\", continuationString);\n        }\n        if (!continuationField.equals(previousContinuationField)) {\n            if (\"\".equals(continuationString)) {\n                continuationString = token;\n            } else {\n                sourceValueSetter(previousContinuationField, continuationString);\n                previousContinuationField = continuationField;\n                continuationString = token + \" \";\n            }\n        } else if (ignoreCompndFieldValues.contains(token)) {\n            // this field shall be ignored\n            //continuationField = token;\n        }\n    }\n    if (isLastSourceLine) {\n        // final line in the section - finish off the compound\n        //\t\t\tSystem.out.println(\"[pdb_SOURCE_Handler] Final SOURCE line - Finishing off final MolID header.\");\n        sourceValueSetter(continuationField, continuationString);\n        continuationString = \"\";\n        //compounds.add(current_compound);\n    }\n}", "repo_id": "9", "comment": "/**\n * Handler for\n * SOURCE Record format\n *\n * The SOURCE record specifies the biological and/or chemical source of each biological molecule in the entry. Sources are described by both the common name and the scientific name, e.g., genus and species. Strain and/or cell-line for immortalized cells are given when they help to uniquely identify the biological entity studied.\n * Record Format\n * <pre>\n * COLUMNS   DATA TYPE         FIELD          DEFINITION\n * -------------------------------------------------------------------------------\n *  1 -  6   Record name       \"SOURCE\"\n *  9 - 10   Continuation      continuation   Allows concatenation of multiple records.\n * 11 - 70   Specification     srcName        Identifies the source of the macromolecule in\n *            list                            a token: value format.\n * </pre>\n * @param line the line to be parsed\n */\n", "repo_name": "biojava-master/", "id": 1173, "method_signature": "void pdb_SOURCE_Handler(String)"}, "2839": {"callee_method_names": ["String.length", "String.replace"], "method_name": "GenericGenbankHeaderFormat._write_single_line", "method_implementation": "{\n    assert tag.length() < HEADER_WIDTH;\n    return StringManipulationHelper.padRight(tag, HEADER_WIDTH) + text.replace('\\n', ' ') + lineSep;\n}", "repo_id": "9", "comment": "/**\n * Used in the the 'header' of each GenBank record.\n *\n * @param tag\n * @param text\n */\n", "repo_name": "biojava-master/", "id": 2839, "method_signature": "String _write_single_line(String, String)"}, "225": {"callee_method_names": [], "method_name": "ProteinModificationImpl.setPsimodId", "method_implementation": "{\n    this.psimodId = psimodId;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the PSI-MOD ID.\n * @param psimodId PSI-MOD ID.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 225, "method_signature": "Builder setPsimodId(String)"}, "2335": {"callee_method_names": ["LinkedList.removeFirst"], "method_name": "GlobalsHelper.restoreState", "method_implementation": "{\n    PathInfo paths = stack.removeFirst();\n    if (paths.pdbPath == null) {\n        System.clearProperty(UserConfiguration.PDB_DIR);\n    } else {\n        System.setProperty(UserConfiguration.PDB_DIR, paths.pdbPath);\n    }\n    if (paths.pdbCachePath == null) {\n        System.clearProperty(UserConfiguration.PDB_CACHE_DIR);\n    } else {\n        System.setProperty(UserConfiguration.PDB_CACHE_DIR, paths.pdbCachePath);\n    }\n    StructureIO.setAtomCache(paths.atomCache);\n    // Use side effect setting the path for all DownloadChemCompProvider due to static state\n    new DownloadChemCompProvider(paths.downloadChemCompProviderPath);\n    ChemCompGroupFactory.setChemCompProvider(paths.chemCompProvider);\n    ScopFactory.setScopDatabase(paths.scop);\n}", "repo_id": "9", "comment": "/**\n * Restore global state to the previous settings\n * @throws NoSuchElementException if there is no prior state to restore\n */\n", "repo_name": "biojava-master/", "id": 2335, "method_signature": "void restoreState()"}, "557": {"callee_method_names": [], "method_name": "RotationAxis.getRotationAxis", "method_implementation": "{\n    return rotationAxis;\n}", "repo_id": "9", "comment": "/**\n * Get a unit vector along the rotation axis\n * @return rotationAxis\n */\n", "repo_name": "biojava-master/", "id": 557, "method_signature": "Atom getRotationAxis()"}, "571": {"callee_method_names": [], "method_name": "RotationAxis.getProjectedPoint", "method_implementation": "{\n    if (rotationPos == null) {\n        // translation only\n        return null;\n    }\n    Atom localPoint = Calc.subtract(point, rotationPos);\n    double dot = Calc.scalarProduct(localPoint, rotationAxis);\n    Atom localProjected = Calc.scale(rotationAxis, dot);\n    Atom projected = Calc.add(localProjected, rotationPos);\n    return projected;\n}", "repo_id": "9", "comment": "/**\n * Projects a given point onto the axis of rotation\n * @param point\n * @return An atom which lies on the axis, or null if the RotationAxis is purely translational\n */\n", "repo_name": "biojava-master/", "id": 571, "method_signature": "Atom getProjectedPoint(Atom)"}, "1972": {"callee_method_names": [], "method_name": "HelixAxisAligner.getOrbits", "method_implementation": "{\n    run();\n    return alignedOrbits;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getOrbits()\n\t */\n", "repo_name": "biojava-master/", "id": 1972, "method_signature": "List<List<Integer>> getOrbits()"}, "1262": {"callee_method_names": ["Structure.addModel", "List<Map<String, Chain>>.add"], "method_name": "MmtfStructureReader.setModelInfo", "method_implementation": "{\n    modelNumber = inputModelNumber;\n    structure.addModel(new ArrayList<Chain>(chainCount));\n    chainMap.add(new LinkedHashMap<>());\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface#setModelInfo(int, int)\n\t */\n", "repo_name": "biojava-master/", "id": 1262, "method_signature": "void setModelInfo(int, int)"}, "1094": {"callee_method_names": ["UserConfiguration.getCacheFilePath"], "method_name": "DownloadChemCompProvider.getPath", "method_implementation": "{\n    if (path == null) {\n        UserConfiguration config = new UserConfiguration();\n        path = new File(config.getCacheFilePath());\n    }\n    return path;\n}", "repo_id": "9", "comment": "/**\n * Get this provider's cache path\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1094, "method_signature": "File getPath()"}, "2289": {"callee_method_ids": [1571], "callee_method_names": ["Site.getGroups"], "method_name": "SiteTest.testGetGroups", "method_implementation": "{\n    //        System.out.println(\"getGroups\");\n    List<Group> expResult = bindingSiteGroups;\n    List<Group> result = bindingSite.getGroups();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of getGroups method, of class Site.\n */\n", "repo_name": "biojava-master/", "id": 2289, "method_signature": "void testGetGroups()"}, "3686": {"callee_method_names": ["LinkedHashMap<String,Double>.keySet"], "method_name": "SurvivalInfoHelper.isCategorical", "method_implementation": "{\n    try {\n        for (String value : values.keySet()) {\n            Double.parseDouble(value);\n        }\n        return false;\n    } catch (Exception e) {\n        return true;\n    }\n}", "repo_id": "9", "comment": "/**\n * If any not numeric value then categorical\n * @param values\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3686, "method_signature": "boolean isCategorical(LinkedHashMap)"}, "1003": {"callee_method_names": ["ResidueNumber.getChainName", "ResidueNumber.getChainName", "ResidueNumber.getChainName"], "method_name": "AtomPositionMap.getLengthDirectional", "method_implementation": "{\n    if (!start.getChainName().equals(end.getChainName())) {\n        throw new IllegalArgumentException(String.format(\"Chains differ between %s and %s. Unable to calculate length.\", start, end));\n    }\n    Integer startPos = getPosition(start);\n    Integer endPos = getPosition(end);\n    if (startPos == null) {\n        throw new IllegalArgumentException(\"Residue \" + start + \" was not found.\");\n    }\n    if (endPos == null) {\n        throw new IllegalArgumentException(\"Residue \" + start + \" was not found.\");\n    }\n    return getLengthDirectional(startPos, endPos, start.getChainName());\n}", "repo_id": "9", "comment": "/**\n * Calculates the number of atoms between two ResidueNumbers, inclusive. Both residues\n * must belong to the same chain.\n * Will return a negative value if the start is past the end.\n * @param start First residue\n * @param end Last residue\n * @return The number of atoms from A to B inclusive\n * @throws IllegalArgumentException if start and end are on different chains,\n *  or if either of the residues doesn't exist\n */\n", "repo_name": "biojava-master/", "id": 1003, "method_signature": "int getLengthDirectional(ResidueNumber, ResidueNumber)"}, "2973": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.countCompounds", "method_implementation": "{\n    return SequenceMixin.countCompounds(this, compounds);\n}", "repo_id": "9", "comment": "/**\n * @param compounds\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2973, "method_signature": "int countCompounds(C[])"}, "1087": {"callee_method_names": [], "method_name": "AllChemCompProvider.downloadFile", "method_implementation": "{\n    initPath();\n    initServerName();\n    String localName = getLocalFileName();\n    String u = serverName + \"/\" + COMPONENTS_FILE_LOCATION;\n    downloadFileFromRemote(new URL(u), new File(localName));\n}", "repo_id": "9", "comment": "/**\n * Downloads the components.cif.gz file from the wwPDB site.\n */\n", "repo_name": "biojava-master/", "id": 1087, "method_signature": "void downloadFile()"}, "2587": {"callee_method_names": ["DocumentBuilderFactory.newDocumentBuilder", "DocumentBuilderFactory.setFeature", "DocumentBuilder.parse", "Document.getDocumentElement"], "method_name": "XMLHelper.inputStreamToDocument", "method_implementation": "{\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n    DocumentBuilder db = dbf.newDocumentBuilder();\n    dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n    Document doc = db.parse(inputStream);\n    doc.getDocumentElement().normalize();\n    return doc;\n}", "repo_id": "9", "comment": "/**\n * Creates an {@code}org.w3c.dom.Document{@code} from the content of the {@code}inputStream{@code}\n * @param inputStream\n * @return a {@code}Document{@code}\n * @throws SAXException\n * @throws IOException\n * @throws ParserConfigurationException\n */\n", "repo_name": "biojava-master/", "id": 2587, "method_signature": "Document inputStreamToDocument(InputStream)"}, "1899": {"callee_method_names": ["Class<?>.isPseudoStoichiometric"], "method_name": "Stoichiometry.isPseudoStoichiometric", "method_implementation": "{\n    for (SubunitCluster c : orderedClusters) {\n        if (c.isPseudoStoichiometric())\n            return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * A pseudostoichiometric {@link SubunitCluster} was obtained using the\n * {@link SubunitClustererMethod#STRUCTURE} similarity,\n * or {@link SubunitClustererMethod#SEQUENCE} similarity with low scores.\n *\n * @return true if any of the clusters is pseudostoichiometric, false\n *         otherwise\n */\n", "repo_name": "biojava-master/", "id": 1899, "method_signature": "boolean isPseudoStoichiometric()"}, "2543": {"callee_method_names": ["AlignedSequence<S, C>.getLength", "List<Step>.get", "AlignedSequence<S, C>.isGap", "List<Location>.add", "List<Location>.add", "List<Location>.size", "List<Location>.size", "List<Location>.get", "List<Location>.get", "List<Location>.get", "List<Location>.size"], "method_name": "SimpleAlignedSequence.setLocation", "method_implementation": "{\n    List<Location> sublocations = new ArrayList<Location>();\n    int start = 0, step = 0, oStep = numBefore + numAfter, oMax = this.original.getLength(), pStep = 0, pMax = (prev == null) ? 0 : prev.getLength();\n    boolean inGap = true;\n    // build sublocations: pieces of sequence separated by gaps\n    for (; step < length; step++) {\n        boolean isGapStep = (steps.get(step) == Step.GAP), isGapPrev = (pStep < pMax && prev.isGap(pStep + 1));\n        if (!isGapStep && !isGapPrev) {\n            oStep++;\n            if (inGap) {\n                inGap = false;\n                start = step + 1;\n            }\n        } else if (!inGap) {\n            inGap = true;\n            sublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n        }\n        if (prev != null && !isGapStep) {\n            pStep++;\n        }\n    }\n    if (!inGap) {\n        sublocations.add(new SimpleLocation(start, step, Strand.UNDEFINED));\n    }\n    // combine sublocations into 1 Location\n    if (sublocations.size() == 0) {\n        location = null;\n    } else if (sublocations.size() == 1) {\n        location = sublocations.get(0);\n    } else {\n        location = new SimpleLocation(sublocations.get(0).getStart(), sublocations.get(sublocations.size() - 1).getEnd(), Strand.UNDEFINED, false, sublocations);\n    }\n    // TODO handle circular alignments\n    // check that alignment has correct number of compounds in it to fit original sequence\n    if (step != length || oStep != oMax || pStep != pMax) {\n        throw new IllegalArgumentException(\"Given sequence does not fit in alignment.\");\n    }\n}", "repo_id": "9", "comment": "// helper method to initialize the location\n", "repo_name": "biojava-master/", "id": 2543, "method_signature": "void setLocation(List)"}, "1987": {"callee_method_names": ["Map<Double, List<Integer>>.get", "Map<Double, List<Integer>>.put", "List<List<Integer>>.clear", "Map<Double, List<Integer>>.values", "List<List<Integer>>.add"], "method_name": "RotationAxisAligner.calcAlignedOrbits", "method_implementation": "{\n    Map<Double, List<Integer>> depthMap = new TreeMap<Double, List<Integer>>();\n    double[] depth = getSubunitZDepth();\n    alignedOrbits = calcOrbits();\n    // calculate the mean depth of orbit along z-axis\n    for (List<Integer> orbit : alignedOrbits) {\n        // calculate the mean depth along z-axis for each orbit\n        double meanDepth = 0;\n        for (int subunit : orbit) {\n            meanDepth += depth[subunit];\n        }\n        meanDepth /= orbit.size();\n        if (depthMap.get(meanDepth) != null) {\n            // System.out.println(\"Conflict in depthMap\");\n            meanDepth += 0.01;\n        }\n        depthMap.put(meanDepth, orbit);\n    }\n    // now fill orbits back into list ordered by depth\n    alignedOrbits.clear();\n    for (List<Integer> orbit : depthMap.values()) {\n        // order subunit in a clockwise rotation around the z-axis\n        /// starting at the 12 O-clock position (+y position)\n        alignWithReferenceAxis(orbit);\n        alignedOrbits.add(orbit);\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns a list of orbits (an orbit is a cyclic permutation of subunit indices that are related\n * by a rotation around the principal rotation axis) ordered from the +z direction to the -z direction (z-depth).\n * Within an orbit, subunit indices are ordered with a clockwise rotation around the z-axis.\n * @return list of orbits ordered by z-depth\n */\n", "repo_name": "biojava-master/", "id": 1987, "method_signature": "void calcAlignedOrbits()"}, "886": {"callee_method_names": ["Map<ResidueNumber, GroupAsa>.get"], "method_name": "StructureInterface.getSecondGroupAsa", "method_implementation": "{\n    return groupAsas2.get(resNum);\n}", "repo_id": "9", "comment": "/**\n * Gets the GroupAsa for the corresponding residue number of second chain\n * @param resNum\n * @return\n */\n", "repo_name": "biojava-master/", "id": 886, "method_signature": "GroupAsa getSecondGroupAsa(ResidueNumber)"}, "158": {"callee_method_names": ["Structure.toMMCIF", "String.contains", "String.contains"], "method_name": "TestMMCIFWriting.testBiounitWriting1STP", "method_implementation": "{\n    Structure s = StructureIO.getBiologicalAssembly(\"1STP\", 1);\n    String mmcif = s.toMMCIF();\n    assertNotNull(mmcif);\n    assertTrue(mmcif.contains(\"A_1\"));\n    assertTrue(mmcif.contains(\"A_2\"));\n}", "repo_id": "9", "comment": "/**\n * Test that a bioassembly formed with a symmetry mate gets written out without problems.\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 158, "method_signature": "void testBiounitWriting1STP()"}, "3385": {"callee_method_names": ["StringBuilder.append", "Quat4d.set", "Polyhedron.getViewMatrix", "Quat4d.normalize", "Quat4d.set", "RotationAxisAligner.getRotationMatrix", "Quat4d.normalize", "Quat4d.mul", "Quat4d.normalize", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getOrientation", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    s.append(setCentroid());\n    // calculate  orientation\n    Quat4d q = new Quat4d();\n    q.set(polyhedron.getViewMatrix(index));\n    q.normalize();\n    Quat4d r = new Quat4d();\n    r.set(rotationAxisAligner.getRotationMatrix());\n    r.normalize();\n    q.mul(r);\n    q.normalize();\n    // set orientation\n    s.append(\"moveto 4 quaternion{\");\n    s.append(jMolFloat(q.x));\n    s.append(\",\");\n    s.append(jMolFloat(q.y));\n    s.append(\",\");\n    s.append(jMolFloat(q.z));\n    s.append(\",\");\n    s.append(jMolFloat(q.w));\n    s.append(\"}\");\n    s.append(\";\");\n    return s.toString();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#getOrientation(int)\n\t */\n", "repo_name": "biojava-master/", "id": 3385, "method_signature": "String getOrientation(int)"}, "2170": {"callee_method_ids": [1716], "callee_method_names": ["ResidueRangeAndLength.getChainName", "ResidueRangeAndLength.getStart", "ResidueRangeAndLength.getEnd", "ResidueRangeAndLength.getLength", "List<ResidueRangeAndLength>.add"], "method_name": "ResidueRangeTest.testWithLengths", "method_implementation": "{\n    // more:\n    String[] ids = new String[] { \"1w0p\", \"3qq3\", \"3chc\", \"2ei7\" };\n    // ,\n    // \"2qbr\"\n    String[] chains = new String[] { \"A\", \"B\", \"A\", \"L\" };\n    ResidueNumber[] starts = new ResidueNumber[] { new ResidueNumber(\"A\", 5, ' '), new ResidueNumber(\"B\", 10, 's'), new ResidueNumber(\"A\", 15, 'm'), new ResidueNumber(\"L\", 44, ' ') };\n    ResidueNumber[] ends = new ResidueNumber[] { new ResidueNumber(\"A\", 117, ' '), new ResidueNumber(\"B\", 200, 's'), new ResidueNumber(\"A\", 464, 'q'), new ResidueNumber(\"L\", 254, 't') };\n    int[] lengths = new int[] { 117 - 5, 200 - 10, 111, 55 };\n    int totalLength = 0;\n    List<ResidueRangeAndLength> ranges = new ArrayList<ResidueRangeAndLength>(ids.length);\n    for (int i = 0; i < ids.length; i++) {\n        ResidueRangeAndLength rr = new ResidueRangeAndLength(chains[i], starts[i], ends[i], lengths[i]);\n        assertEquals(\"The chain is incorrect\", chains[i], rr.getChainName());\n        assertEquals(\"The start is incorrect\", starts[i], rr.getStart());\n        assertEquals(\"The end is incorrect\", ends[i], rr.getEnd());\n        assertEquals(\"The length is incorrect\", lengths[i], rr.getLength());\n        ranges.add(rr);\n        totalLength += lengths[i];\n        assertEquals(\"Total length is wrong\", totalLength, ResidueRangeAndLength.calcLength(ranges));\n    }\n}", "repo_id": "9", "comment": "/**\n * Tests creating ResidueRanges and calculating their lengths.\n */\n", "repo_name": "biojava-master/", "id": 2170, "method_signature": "void testWithLengths()"}, "3264": {"callee_method_names": ["AFPChain.getName1", "AFPChain.getName2", "JFrame.addWindowListener", "JFrame.setVisible", "JFrame.dispose", "JFrame.getContentPane", "JFrame.pack", "JFrame.setVisible"], "method_name": "DotPlotPanel.showDotPlotJFrame", "method_implementation": "{\n    DotPlotPanel dotplot = new DotPlotPanel(afpChain);\n    //Create JFrame\n    String title = String.format(\"Dot plot of %s vs. %s\", afpChain.getName1(), afpChain.getName2());\n    // Create window\n    JFrame frame = new JFrame(title);\n    frame.addWindowListener(new WindowAdapter() {\n\n        @Override\n        public void windowClosing(WindowEvent e) {\n            JFrame f = (JFrame) e.getSource();\n            f.setVisible(false);\n            f.dispose();\n        }\n    });\n    frame.getContentPane().add(dotplot);\n    frame.pack();\n    frame.setVisible(true);\n    return frame;\n}", "repo_id": "9", "comment": "/**\n * Helper function to create and display a JFrame with a single DotPlotPanel\n *\n * @param afpChain\n * @param background\n */\n", "repo_name": "biojava-master/", "id": 3264, "method_signature": "JFrame showDotPlotJFrame(AFPChain)"}, "2311": {"callee_method_names": [], "method_name": "TestUnitQuaternions.testOrientationMetricRange", "method_implementation": "{\n    // no rotation quaternion\n    Quat4d qa = new Quat4d(0, 0, 0, 1);\n    Quat4d qb = new Quat4d(qa);\n    // Two equal quaternions produce the minimum score of 0\n    assertEquals(UnitQuaternions.orientationMetric(qa, qb), 0, 0.01);\n    // 90 degrees rotation over x\n    qa = new Quat4d(0.707, 0, 0, 0.707);\n    // 270 degrees rotation over x\n    qb = new Quat4d(0.707, 0, 0, -0.707);\n    // two quaternions with 180 degree axis produce the max score Pi / 2\n    assertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 2, 0.01);\n    // 90 degrees rotation over y\n    qb = new Quat4d(0, 0.707, 0, 0.707);\n    // two quaternions with 90 degree axis produce the score Pi / 4\n    assertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 3, 0.01);\n    // two quaternions with 45 degree axis produce the score Pi / 8\n    qb = new Quat4d(0.383, 0, 0, 0.924);\n    assertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 8, 0.01);\n    // 90 degrees rotation over x in negative\n    qb = new Quat4d(0, -0.707, 0, -0.707);\n    // assert no negative angles are returned\n    assertEquals(UnitQuaternions.orientationMetric(qa, qb), Math.PI / 3, 0.01);\n}", "repo_id": "9", "comment": "/**\n * Test {@link UnitQuaternions#orientationMetric(Point3d[], Point3d[])}.\n * <p>\n * Tests the range of values of the metric with a perfect correlation,\n * perfect anticorrelation and intermediate values.\n */\n", "repo_name": "biojava-master/", "id": 2311, "method_signature": "void testOrientationMetricRange()"}, "789": {"callee_method_names": ["ConfigStrucAligParams.isTryAllCPs", "ConfigStrucAligParams.getCPPoint"], "method_name": "OptimalCECPMain.align", "method_implementation": "{\n    if (params.isTryAllCPs()) {\n        return alignOptimal(ca1, ca2, param, null);\n    } else {\n        int cpPoint = params.getCPPoint();\n        return alignPermuted(ca1, ca2, param, cpPoint);\n    }\n}", "repo_id": "9", "comment": "/**\n * Finds the optimal alignment between two proteins allowing for a circular\n * permutation (CP).\n *\n * The precise algorithm is controlled by the\n * {@link OptimalCECPParameters parameters}. If the parameter\n * {@link OptimalCECPParameters#isTryAllCPs() tryAllCPs} is true, all possible\n * CP sites are tried and the optimal site is returned. Otherwise, the\n * {@link OptimalCECPParameters#getCPPoint() cpPoint} parameter is used to\n * determine the CP point, greatly reducing the computation required.\n *\n * @param ca1 CA atoms of the first protein\n * @param ca2 CA atoms of the second protein\n * @param param {@link CeParameters} object\n * @return The best-scoring alignment\n * @throws StructureException\n *\n * @see #alignOptimal(Atom[], Atom[], Object, AFPChain[])\n */\n", "repo_name": "biojava-master/", "id": 789, "method_signature": "AFPChain align(Atom[], Atom[], Object)"}, "3286": {"callee_method_ids": [490], "callee_method_names": ["AFPChain.getOptLen"], "method_name": "DisplayAFP.getAtomForAligPos", "method_implementation": "{\n    int[] optLen = afpChain.getOptLen();\n    // int[][][] optAln = afpChain.getOptAln();\n    if (optLen == null)\n        return null;\n    if (chainNr < 0 || chainNr > 1) {\n        throw new StructureException(\"So far only pairwise alignments are supported, but you requested results for alinged chain nr \" + chainNr);\n    }\n    //if (  afpChain.getAlgorithmName().startsWith(\"jFatCat\")){\n    /// for FatCat algorithms...\n    int capos = getUngappedFatCatPos(afpChain, chainNr, aligPos);\n    if (capos < 0) {\n        capos = getNextFatCatPos(afpChain, chainNr, aligPos, getPrevious);\n        //System.out.println(\" got next\" + capos + \" for \" + chainNr + \" alignedPos: \" + aligPos);\n    } else {\n        //System.out.println(\"got aligned fatcat position: \" + capos + \" \" + chainNr + \" for alig pos: \" + aligPos);\n    }\n    if (capos < 0) {\n        System.err.println(\"could not match position \" + aligPos + \" in chain \" + chainNr + \". Returing null...\");\n        return null;\n    }\n    if (capos > ca.length) {\n        System.err.println(\"Atom array \" + chainNr + \" does not have \" + capos + \" atoms. Returning null.\");\n        return null;\n    }\n    return ca[capos];\n    //}\n    //\n    //\n    //      int ungappedPos = getUngappedPos(afpChain, aligPos);\n    //      System.out.println(\"getAtomForAligPOs \" + aligPos  + \" \" + ungappedPos );\n    //      return ca[ungappedPos];\n    //\n    //      if ( ungappedPos >= optAln[bk][chainNr].length)\n    //         return null;\n    //      int pos = optAln[bk][chainNr][ungappedPos];\n    //      if ( pos > ca.length)\n    //         return null;\n    //      return ca[pos];\n}", "repo_id": "9", "comment": "/**\n * Return the atom at alignment position aligPos. at the present only works with block 0\n * @param chainNr the number of the aligned pair. 0... first chain, 1... second chain.\n * @param afpChain an afpChain object\n * @param aligPos position on the alignment\n * @param getPrevious gives the previous position if false, gives the next posible atom\n * @return a CA atom that is at a particular position of the alignment\n */\n", "repo_name": "biojava-master/", "id": 3286, "method_signature": "Atom getAtomForAligPos(AFPChain, int, int, Atom[], boolean)"}, "3657": {"callee_method_names": [], "method_name": "SurvivalInfo.getWeight", "method_implementation": "{\n    return weight;\n}", "repo_id": "9", "comment": "/**\n * @return the weight\n */\n", "repo_name": "biojava-master/", "id": 3657, "method_signature": "double getWeight()"}, "2573": {"callee_method_names": ["String.contains", "String.replaceAll", "String.endsWith", "String.substring", "String.length", "String.endsWith"], "method_name": "FileDownloadUtils.toUnixPath", "method_implementation": "{\n    String uPath = path;\n    if (uPath.contains(\"\\\\\")) {\n        uPath = uPath.replaceAll(\"\\\\\\\\\", \"/\");\n    }\n    // this should be removed, it's need since \"\\\" is added AtomCache code\n    if (uPath.endsWith(\"//\")) {\n        uPath = uPath.substring(0, uPath.length() - 1);\n    }\n    if (!uPath.endsWith(\"/\")) {\n        uPath = uPath + \"/\";\n    }\n    return uPath;\n}", "repo_id": "9", "comment": "/**\n * Converts path to Unix convention and adds a terminating slash if it was\n * omitted.\n *\n * @param path original platform dependent path\n * @return path in Unix convention\n * @author Peter Rose\n * @since 3.2\n */\n", "repo_name": "biojava-master/", "id": 2573, "method_signature": "String toUnixPath(String)"}, "1709": {"callee_method_names": [], "method_name": "BondImpl.getOther", "method_implementation": "{\n    if (exclude != atomA && exclude != atomB) {\n        throw new IllegalArgumentException(\"Atom to exclude is not in bond.\");\n    }\n    if (exclude == atomA) {\n        return atomB;\n    } else {\n        return atomA;\n    }\n}", "repo_id": "9", "comment": "/**\n * A utility method to get the other atom in a bond, given one of its atoms.\n * If the atom passed is one of the atoms in this bond, then this method is\n * essentially equivalent to saying\n * <code>atom == bond.getAtomA() ? bond.getAtomB() : bond.getAtomA()</code>.\n * <p>\n * <i>Note:</i> Comparison of atoms in this method is done with\n * <code>==</code>, not <code>equals</code>.\n *\n * @param exclude the atom of the bond to not return\n * @throws IllegalArgumentException if the passed atom is not in this bond\n * @return the atom in this bond that was not passed as an argument\n */\n", "repo_name": "biojava-master/", "id": 1709, "method_signature": "Atom getOther(Atom)"}, "3093": {"callee_method_names": [], "method_name": "AbstractFeature.setUserObject", "method_implementation": "{\n    this.userObject = userObject;\n}", "repo_id": "9", "comment": "/**\n * Allow the user to associate an object with the feature. This way if a feature which is displayed in a GUI\n * is clicked on the application can then get a user defined object associated with the feature.\n * @param userObject the userObject to set\n */\n", "repo_name": "biojava-master/", "id": 3093, "method_signature": "void setUserObject(Object)"}, "1595": {"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "SecStrucState.getTurn", "StringBuffer.append", "SecStrucState.getTurn", "StringBuffer.append", "SecStrucState.getTurn", "StringBuffer.append", "SecStrucState.getType", "StringBuffer.append", "SecStrucGroup[].getPDBName", "StringBuffer.toString", "StringBuffer.toString", "StringBuffer.toString", "StringBuffer.toString", "StringBuffer.toString"], "method_name": "SecStrucCalc.printHelixSummary", "method_implementation": "{\n    //3-10 helix\n    StringBuffer g = new StringBuffer();\n    //alpha helix\n    StringBuffer h = new StringBuffer();\n    //pi-helix\n    StringBuffer i = new StringBuffer();\n    //SS summary\n    StringBuffer ss = new StringBuffer();\n    //AA one-letter\n    StringBuffer aa = new StringBuffer();\n    String nl = System.getProperty(\"line.separator\");\n    g.append(\"3 turn: \");\n    h.append(\"4 turn: \");\n    i.append(\"5 turn: \");\n    ss.append(\"SS:     \");\n    aa.append(\"AA:     \");\n    for (int k = 0; k < groups.length; k++) {\n        SecStrucState state = getSecStrucState(k);\n        g.append(state.getTurn()[0]);\n        h.append(state.getTurn()[1]);\n        i.append(state.getTurn()[2]);\n        ss.append(state.getType());\n        aa.append(StructureTools.get1LetterCode(groups[k].getPDBName()));\n    }\n    return g.toString() + nl + h.toString() + nl + i.toString() + nl + ss.toString() + nl + aa.toString();\n}", "repo_id": "9", "comment": "/**\n * Generate a summary of this SS prediction with information about\n * the three types of helix turns in different row sequences.\n * <p>\n * This is similar to the summary output of Jmol, and useful to visualize\n * the helix patterns.\n *\n * @return String helix summary\n */\n", "repo_name": "biojava-master/", "id": 1595, "method_signature": "String printHelixSummary()"}, "2725": {"callee_method_names": ["FastaHeaderFormatInterface<GeneSequence, NucleotideCompound>.getHeader", "OutputStream.write", "OutputStream.write", "String.getBytes", "OutputStream.write", "String.getSequence5PrimeTo3Prime", "String.toLowerCase", "String.getBioBegin", "String.getBioEnd", "String.getExonSequences", "String.getStrand", "ExonSequence.getBioBegin", "ExonSequence.getBioEnd", "ExonSequence.getBioEnd", "ExonSequence.getBioBegin", "StringBuilder.length", "StringBuilder.length", "Logger.warn", "String.getAccession", "String.getStrand", "ExonSequence.getBioBegin", "ExonSequence.getBioEnd", "StringBuilder.charAt", "String.toUpperCase", "StringBuilder.setCharAt", "StringBuilder.toString", "String.length", "OutputStream.write", "String.charAt", "OutputStream.write", "String.getLength", "OutputStream.write"], "method_name": "FastaGeneWriter.process", "method_implementation": "{\n    byte[] lineSep = System.getProperty(\"line.separator\").getBytes();\n    for (GeneSequence sequence : sequences) {\n        String header = headerFormat.getHeader(sequence);\n        os.write('>');\n        os.write(header.getBytes());\n        os.write(lineSep);\n        int compoundCount = 0;\n        String seq = \"\";\n        //GeneSequence currently has a strand attribute to indicate direction\n        seq = sequence.getSequence5PrimeTo3Prime().getSequenceAsString();\n        if (showExonUppercase) {\n            StringBuilder sb = new StringBuilder(seq.toLowerCase());\n            int geneBioBegin = sequence.getBioBegin();\n            int geneBioEnd = sequence.getBioEnd();\n            for (ExonSequence exonSequence : sequence.getExonSequences()) {\n                int featureBioBegin = 0;\n                int featureBioEnd = 0;\n                if (sequence.getStrand() != Strand.NEGATIVE) {\n                    featureBioBegin = exonSequence.getBioBegin() - geneBioBegin;\n                    featureBioEnd = exonSequence.getBioEnd() - geneBioBegin;\n                } else {\n                    featureBioBegin = geneBioEnd - exonSequence.getBioEnd();\n                    featureBioEnd = geneBioEnd - exonSequence.getBioBegin();\n                }\n                if (featureBioBegin < 0 || featureBioEnd < 0 || featureBioEnd > sb.length() || featureBioBegin > sb.length()) {\n                    logger.warn(\"Bad Feature, Accession: {}, Sequence Strand: {}, Gene Begin: {}, Gene End: {}, Exon Begin: {}, Exon End: {}\", sequence.getAccession().toString(), sequence.getStrand(), geneBioBegin, geneBioEnd, exonSequence.getBioBegin(), exonSequence.getBioEnd());\n                } else {\n                    for (int i = featureBioBegin; i <= featureBioEnd; i++) {\n                        char ch = sb.charAt(i);\n                        //probably not the fastest but the safest way if language is not standard ASCII\n                        String temp = String.valueOf(ch);\n                        ch = temp.toUpperCase().charAt(0);\n                        sb.setCharAt(i, ch);\n                    }\n                }\n            }\n            seq = sb.toString();\n        }\n        for (int i = 0; i < seq.length(); i++) {\n            os.write(seq.charAt(i));\n            compoundCount++;\n            if (compoundCount == lineLength) {\n                os.write(lineSep);\n                compoundCount = 0;\n            }\n        }\n        //If we had sequence which was a reciprocal of line length\n        //then don't write the line terminator as this has already written\n        //it\n        if ((sequence.getLength() % getLineLength()) != 0) {\n            os.write(lineSep);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2725, "method_signature": "void process()"}, "2341": {"callee_method_names": [], "method_name": "FastqBuilder.getDescription", "method_implementation": "{\n    return description;\n}", "repo_id": "9", "comment": "/**\n * Return the description for this FASTQ formatted sequence builder.\n *\n * @return the description for this FASTQ formatted sequence builder\n */\n", "repo_name": "biojava-master/", "id": 2341, "method_signature": "String getDescription()"}, "3633": {"callee_method_names": [], "method_name": "CoxInfo.getScoreLogrankTestpvalue", "method_implementation": "{\n    return scoreLogrankTestpvalue;\n}", "repo_id": "9", "comment": "/**\n * @return the scoreLogrankTestpvalue\n */\n", "repo_name": "biojava-master/", "id": 3633, "method_signature": "Double getScoreLogrankTestpvalue()"}, "2488": {"callee_method_names": ["Logger.debug", "Logger.debug", "ResidueRangeAndLength.lowerEndpoint", "ResidueRangeAndLength.upperEndpoint"], "method_name": "ChromosomeMappingTools.getCDSPosForward", "method_implementation": "{\n    // the genetic coordinate is not in a coding region\n    if ((chromPos < (cdsStart + base)) || (chromPos > (cdsEnd + base))) {\n        logger.debug(\"The {} position is not in a coding region\", format(chromPos));\n        return -1;\n    }\n    logger.debug(\"looking for CDS position for {}\", format(chromPos));\n    // map the genetic coordinates of coding region on a stretch of a reverse strand\n    List<Range<Integer>> cdsRegions = getCDSRegions(exonStarts, exonEnds, cdsStart, cdsEnd);\n    int codingLength = 0;\n    int lengthExon = 0;\n    for (Range<Integer> range : cdsRegions) {\n        int start = range.lowerEndpoint();\n        int end = range.upperEndpoint();\n        lengthExon = end - start;\n        if (start + base <= chromPos && end >= chromPos) {\n            return codingLength + (chromPos - start);\n        } else {\n            codingLength += lengthExon;\n        }\n    }\n    return -1;\n}", "repo_id": "9", "comment": "/**\n * Converts the genetic coordinate to the position of the nucleotide on the mRNA sequence for a gene\n * living on the forward DNA strand.\n *\n * @param chromPos The genetic coordinate on a chromosome\n * @param exonStarts The list holding the genetic coordinates pointing to the start positions of the exons (including UTR regions)\n * @param exonEnds The list holding the genetic coordinates pointing to the end positions of the exons (including UTR regions)\n * @param cdsStart The start position of a coding region\n * @param cdsEnd The end position of a coding region\n *\n * @return the position of the nucleotide base on the mRNA sequence corresponding to the input genetic coordinate (base 1)\n *\n * @author Yana Valasatava\n */\n", "repo_name": "biojava-master/", "id": 2488, "method_signature": "int getCDSPosForward(int, List, List, int, int)"}, "3443": {"callee_method_names": ["StructureViewer.setStyle"], "method_name": "StructureViewerTest.testSetStyle", "method_implementation": "{\n    if (java.awt.GraphicsEnvironment.isHeadless())\n        return;\n    RenderStyle wireframe = null;\n    StructureViewer instance = new StructureViewerImpl();\n    instance.setStyle(wireframe);\n    // TODO review the generated test code and remove the default call to fail.\n    //fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of setStyle method, of class StructureViewer.\n */\n", "repo_name": "biojava-master/", "id": 3443, "method_signature": "void testSetStyle()"}, "2321": {"callee_method_ids": [1347, 1347, 1349, 1349, 1349], "callee_method_names": ["EntityInfo.setMolId", "EntityInfo.setMolId", "Structure.addEntityInfo", "Structure.addEntityInfo", "Chain.setId", "Chain.setId", "EntityInfo.addChain", "EntityInfo.addChain", "Chain.setId", "EntityInfo.addChain", "Structure.addChain", "Structure.addChain", "Structure.addChain", "Chain.setAtomGroups", "Chain.setSeqResGroups", "Chain.setEntityInfo", "Chain.setAtomGroups", "List<Group>.subList", "Chain.setSeqResGroups", "Chain.setEntityInfo", "Chain.setAtomGroups", "Chain.setSeqResGroups", "Chain.setEntityInfo"], "method_name": "TestSubunitCluster.mockStructure", "method_implementation": "{\n    Structure structure = new StructureImpl();\n    EntityInfo entity1 = new EntityInfo();\n    entity1.setMolId(1);\n    EntityInfo entity2 = new EntityInfo();\n    entity2.setMolId(2);\n    structure.addEntityInfo(entity1);\n    structure.addEntityInfo(entity2);\n    Chain chainA = new ChainImpl();\n    chainA.setId(\"A\");\n    Chain chainB = new ChainImpl();\n    chainB.setId(\"B\");\n    entity1.addChain(chainA);\n    entity1.addChain(chainB);\n    Chain chainC = new ChainImpl();\n    chainC.setId(\"C\");\n    entity2.addChain(chainC);\n    structure.addChain(chainA);\n    structure.addChain(chainB);\n    structure.addChain(chainC);\n    // entity 1: chain A 10 observed residues, chain B 9 observed residues (first unobserved)\n    List<Group> aGroups = getGroupList(10, \"ALA\", chainA);\n    chainA.setAtomGroups(new ArrayList<>(aGroups));\n    chainA.setSeqResGroups(aGroups);\n    chainA.setEntityInfo(entity1);\n    List<Group> bGroups = getGroupList(10, \"ALA\", chainB);\n    chainB.setAtomGroups(new ArrayList<>(bGroups.subList(1, 10)));\n    chainB.setSeqResGroups(bGroups);\n    chainB.setEntityInfo(entity1);\n    List<Group> cGroups = getGroupList(20, \"GLY\", chainC);\n    chainC.setAtomGroups(new ArrayList<>(cGroups));\n    chainC.setSeqResGroups(cGroups);\n    chainC.setEntityInfo(entity2);\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * Create a mock structure with 2 entities 1 (chains A, B) and 2 (chain C).\n * @return a structure\n */\n", "repo_name": "biojava-master/", "id": 2321, "method_signature": "Structure mockStructure()"}, "122": {"callee_method_names": ["NeedlemanWunsch<DNASequence, NucleotideCompound>.getSimilarity"], "method_name": "NeedlemanWunschTest.testIntOverflowBug", "method_implementation": "{\n    SubstitutionMatrix<NucleotideCompound> matrix = SubstitutionMatrixHelper.getNuc4_4();\n    SimpleGapPenalty gap = new SimpleGapPenalty();\n    String str1 = \"AGATATATCTGAAGCTTAAAGGGCAGTGACAATGGCTGGCTCGGTTAACGGGAATCATAGTGCTGTAGGACCTGGTATAAATTATGAGACGGTGTCTCAAGTGGATGAGTTCTGTAAAGCACTTAGAGGGAAAAGGCCGATCCATAGTATTTTGATAGCTAACAATGGAATGGCGGCTGTGAAGTTTATACGTAGTGTCAGAACATGGGCTTATGAAACATTTGGTACGGAAAAAGCCATATTGTTGGTGGGGATGGCAACCCCTGAAGACATGCGGATCAATGCGGAGCATATCAGAATCGCTGATCAGTTTGTTGAGGTTCCCGGAGGAACCAACAATAACAATTATGCTAACGTTCAGCTGATTGTGGAGATGGCTGAAGTAACACGCGTGGATGCAGTTTGGCCTGGTTGGGGTCATGCATCTGAAAACCCCGAATTACCTGATGCCCTAGATGCAAAAGGAATCATATTTCTTGGTCCTCCAGCATCTTCAATGGCAGCACTGGGAGATAAGATTGGTTCTTCGTTGATTGCACAAGCTGCTGATGTACCCACTCTGCCATGGAGTGGTTCCCATGTTAAAATACCTCCTAATAGCAACTTGGTAACCATCCCAGAGGAGATCTACCGGCAAGCATGTGTCTACACAACTGAAGAAGCGATTGCTAGCTGTCAAGTTGTCGGTTACCCAGCAATGATCAAAGCATCGTGGGGTGGTGGTGGTAAAGGAATCAGGAAGGTTCATAATGATGATGAGGTTAGGGCTCTATTCAAGCAAGTTCAGGGTGAGGTCCCAGGCTCACCAATATTCATAATGAAGGTTGCGTCACAGAGTCGGCATCTAGAGGTCCAGCTGCTCTGTGACAAGCATGGAAATGTTTCAGCTCTGCATAGCCGTGATTGTAGCGTCCAGAGAAGACATCAAAAGATCATAGAGGAGGGTCCAATTACTGTGGCTCCGCCAGAAACTGTCAAGAAACTTGAACAAGCAGCTAGAAGGTTGGCTAAGAGTGTTAACTATGTTGGAGCTGCTACTGTTGAGTATCTCTACAGTATGGACACTGGGGAGTACTACTTCTTAGAGCTTAACCCTCGCTTACAGGTTGAGCATCCTGTCACTGAGTGGATTGCCGAGATAAATCTTCCTGCTGCCCAAGTTGCTGTGGGGATGGGAATTCCTCTCTGGCAAATCCCTGAGATAAGACGGTTCTATGGAATAGAACATGGTGGAGGTTATGATTCTTGGCGAAAAACATCTGTTGTAGCCTTCCCTTTTGATTTTGATAAAGCTCAATCTATAAGGCCAAAAGGTCATTGTGTGGCTGTACGTGTGACAAGTGAGGATCCTGATGACGGGTTCAAACCAACCAGCGGTAGAGTTCAGGAGTTGAGTTTTAAGAGCAAGCCAAATGTGTGGGCGTACTTCTCTGTCAAGTCTGGTGGAGGCATCCACGAGTTCTCGGATTCCCAGTTTGGACATGTTTTTGCATTTGGGGAATCCAGAGCCCTGGCGATAGCGAATATGGTTCTTGGGCTAAAAGAAATTCAGATCCGTGGAGAAATTAGGACTAACGTTGACTACACGATCGACCTTTTACATGCTTCTGATTACCGTGATAACAAAATTCACACTGGTTGGTTGGATAGTAGGATTGCTATGCGGGTCAGAGCTGAGAGGCCTCCATGGTATCTCTCTGTTGTCGGCGGAGCTCTCTATAAAGCATCAGCGACCAGTGCTGCTGTGGTTTCAGATTACGTTGGTTATCTGGAGAAGGGGCAAATCCCTCCAAAGCATATATCTCTTGTACATTCTCAAGTGTCTCTGAATATTGAAGGAAGTAAATATACGATTGATGTAGTCCGGGGTGGATCAGGAACCTACAGGCTAAGAATGAACAAGTCAGAAGTGGTAGCAGAAATACACACTCTACGTGATGGAGGTCTGTTGATGCAGTTGGATGGCAAAAGCCATGTGATATATGCAGAGGAAGAAGCTGCAGGAACTCGTCTTCTCATTGATGGAAGAACTTGTTTGCTACAGAATGACCACGATCCATCAAAGTTAATGGCTGAGACACCGTGCAAGTTGATGAGGTATTTGATTTCCGACAACAGCAATATTGACGCTGATACGCCTTATGCCGAAGTTGAGGTCATGAAGATGTGCATGCCACTTCTTTCACCTGCTTCAGGAGTTATCCATTTTAAAATGTCTGAAGGACAAGCCATGCAGGCTGGTGAACTTATAGCCAATCTTGATCTTGATGATCCTTCTGCTGTAAGAAAGGCCGAACCCTTCCATGGAAGTTTCCCAAGATTAGGGCTTCCAACTGCAATATCCGGTAGAGTTCATCAGAGATGTGCCGCAACATTAAATGCTGCACGCATGATTCTTGCTGGCTATGAGCATAAAGTAGATGAGGTTGTTCAAGACTTACTTAATTGCCTTGATAGCCCTGAACTCCCATTTCTTCAGTGGCAAGAGTGCTTTGCAGTTCTGGCGACACGACTACCTAAAAATCTCAGGAACATGCTAGAATCAAAGTATAGGGAATTTGAGAGTATTTCCAGAAACTCTTTGACCACCGATTTCCCTGCCAAACTTTTAAAAGGCATTCTTGAGGCACATTTATCTTCTTGTGATGAGAAAGAGAGAGGTGCCCTTGAAAGGCTCATTGAACCATTGATGAGCCTTGCAAAATCTTATGAAGGTGGTAGAGAAAGTCATGCCCGTGTTATTGTTCATTCTCTCTTTGAAGAATATCTATCAGTAGAAGAATTATTCAATGATAACATGCTGGCTGATGTTATAGAACGCATGCGTCAGCTATACAAGAAAGATCTGTTGAAAATTGTGGATATAGTGCTCTCACACCAGGGCATAAAAAACAAAAACAAACTCGTTCTCCGGCTCATGGAGCAGCTTGTTTACCCTAATCCTGCTGCTTACAGAGATAAACTTATTCGATTCTCAACACTTAACCATACTAACTACTCTGAGTTGGCGCTCAAGGCGAGTCAATTACTTGAACAGACCAAACTAAGTGAGCTTCGTTCAAACATTGCTAGAAGCCTTTCAGAGTTAGAAATGTTTACAGAGGACGGAGAAAATATGGATACTCCCAAGAGGAAAAGTGCCATTAATGAAAGAATAGAAGATCTTGTAAGCGCATCTTTAGCTGTTGAAGACGCTCTCGTGGGACTATTTGACCATAGCGATCACACACTTCAAAGACGGGTTGTTGAGACTTATATTCGCAGATTATACCAGCCCTACGTCGTTAAAGATAGCGTGAGGATGCAGTGGCACCGTTCTGGTCTTCTTGCTTCCTGGGAGTTCCTAGAGGAGCATATGGAAAGAAAAAACATTGGCTTAGACGATCCCGACACATCTGAAAAAGGATTGGTTGAGAAGCGTAGTAAGAGAAAATGGGGGGCTATGGTTATAATCAAATCTTTGCAGTTTCTTCCAAGTATAATAAGTGCAGCATTGAGAGAAACAAAGCACAACGACTATGAAACTGCCGGAGCTCCTTTATCTGGCAATATGATGCACATTGCTATTGTGGGCATCAACAACCAGATGAGTCTGCTTCAGGACAGTGGGGATGAAGACCAAGCTCAGGAAAGAGTAAACAAGTTGGCCAAAATTCTTAAAGAGGAAGAAGTGAGTTCAAGCCTCTGTTCTGCCGGTGTTGGTGTAATCAGCTGTATAATTCAGCGAGATGAAGGACGAACACCCATGAGACATTCTTTCCATTGGTCGTTGGAGAAACAGTATTATGTAGAAGAGCCGTTGCTGCGTCATCTTGAACCTCCTCTGTCCATTTACCTTGAGTTGGATAAGCTGAAAGGATACTCAAATATACAATATACGCCTTCTCGAGATCGTCAATGGCATCTGTATACTGTTACAGACAAGCCAGTGCCAATCAAGAGGATGTTCCTGAGATCTCTTGTTCGACAGGCTACAATGAACGATGGATTTATATTGCAGCAAGGGCAGGATAAGCAGCTTAGCCAAACACTGATCTCCATGGCGTTTACGTCGAAATGTGTTCTGAGGTCTTTGATGGATGCCATGGAGGAACTGGAACTGAATGCCCATAATGCTGCAATGAAACCAGATCACGCACATATGTTTCTTTGCATATTGCGTGAGCAGCAGATAGATGATCTTGTGCCTTTCCCCAGGAGAGTTGAAGTGAATGCGGAGGATGAAGAAACTACAGTTGAAATGATCTTAGAAGAAGCAGCACGAGAGATACATAGATCTGTTGGAGTGAGAATGCATAGGTTGGGCGTGTGCGAGTGGGAAGTGCGGCTGTGGTTGGTGTCCTCTGGACTGGCATGTGGTGCTTGGAGGGTTGTGGTTGCAAACGTGACAGGCCGTACATGCACTGTCCACATATACCGAGAAGTTGAAACTCCTGGAAGAAACAGTTTAATCTACCACTCAATAACCAAGAAGGGACCTTTGCATGAAACACCAATCAGTGATCAATATAAGCCCCTGGGATATCTCGACAGGCAACGTTTAGCAGCAAGGAGGAGTAACACTACTTATTGCTATGACTTCCCGTTGGCATTTGGGACAGCCTTGGAACTGTTGTGGGCATCACAACACCCAGGAGTTAAGAAACCATATAAGGATACTCTGATCAATGTTAAAGAGCTTGTATTCTCAAAACCAGAAGGTTCTTCGGGTACATCTCTAGATCTGGTTGAAAGACCACCCGGTCTCAACGACTTTGGAATGGTTGCCTGGTGCCTAGATATGTCGACCCCAGAGTTTCCTATGGGGCGGAAACTTCTCGTGATTGCGAATGATGTCACCTTCAAAGCTGGTTCTTTTGGTCCTAGAGAGGACGCGTTTTTCCTTGCTGTTACTGAACTCGCTTGTGCCAAGAAGCTTCCCTTGATTTACTTGGCAGCAAATTCTGGTGCCCGACTTGGGGTTGCTGAAGAAGTCAAAGCCTGCTTCAAAGTTGGATGGTCGGATGAAATTTCCCCTGAGAATGGTTTTCAGTATATATACCTAAGCCCTGAAGACCACGAAAGGATTGGATCATCTGTCATTGCCCATGAAGTAAAGCTCTCTAGTGGGGAAACTAGGTGGGTGATTGATACGATCGTTGGCAAAGAAGATGGTATTGGTGTAGAGAACTTAACAGGAAGTGGGGCCATAGCGGGTGCTTACTCAAAGGCATACAATGAAACTTTTACTTTAACCTTTGTTAGTGGAAGAACGGTTGGAATTGGTGCTTATCTTGCCCGCCTAGGTATGCGGTGCATACAGAGACTTGATCAGCCGATCATCTTGACTGGCTTCTCTACACTCAACAAGTTACTTGGGCGTGAGGTCTATAGCTCTCACATGCAACTGGGTGGCCCGAAAATCATGGGCACAAATGGTGTTGTTCATCTTACAGTCTCAGATGATCTTGAAGGCGTATCAGCAATTCTCAACTGGCTCAGCTACATTCCTGCTTACGTGGGTGGTCCTCTTCCTGTTCTTGCCCCTTTAGATCCACCGGAGAGAATTGTGGAGTATGTCCCAGAGAACTCTTGCGACCCACGAGCGGCTATAGCTGGGGTCAAAGACAATACCGGTAAATGGCTTGGAGGTATCTTTGATAAAAATAGTTTCATTGAGACTCTTGAAGGCTGGGCAAGGACGGTAGTGACTGGTAGAGCCAAGCTCGGGGGAATACCCGTTGGAGTTGTTGCAGTTGAGACACAGACTGTCATGCAGATCATCCCAGCCGATCCTGGACAGCTTGACTCTCATGAAAGAGTGGTTCCGCAAGCAGGGCAAGTCTGGTTTCCTGATTCAGCGGCCAAGACTGCTCAAGCGCTTATGGATTTCAACCGGGAAGAGCTTCCATTGTTTATCCTAGCGAACTGGAGAGGGTTTTCAGGTGGGCAGAGAGATCTTTTCGAAGGAATACTTCAGGCAGGTTCAACTATAGTAGAAAATCTGAGAACCTATCGTCAGCCAGTGTTTGTGTACATCCCAATGATGGGAGAGCTGCGCGGTGGAGCGTGGGTTGTTGTTGACAGCCAGATAAATTCGGATTATGTTGAAATGTATGCTGATGAAACAGCTCGTGGAAATGTGCTTGAGCCAGAAGGGACAATAGAGATAAAATTTAGAACAAAAGAGCTATTAGAGTGCATGGGAAGGTTGGACCAGAAGCTAATCAGTCTGAAAGCAAAACTGCAAGATGCCAAGCAAAGCGAGGCCTATGCAAACATCGAGCTTCTCCAGCAACAGATTAAAGCCCGAGAGAAACAGCTTTTACCAGTTTATATCCAAATCGCCACCAAATTTGCAGAACTTCATGACACTTCCATGAGAATGGCTGCAAAGGGAGTGATCAAAAGTGTTGTGGAATGGAGCGGCTCGCGGTCCTTCTTCTACAAAAAGCTCAATAGGAGAATCGCTGAGAGCTCTCTTGTGAAAAACGTAAGAGAAGCATCTGGAGACAACTTAGCATATAAATCTTCAATGCGTCTGATTCAGGATTGGTTCTGCAACTCTGATATTGCAAAGGGGAAAGAAGAAGCTTGGACAGACGACCAAGTGTTCTTTACATGGAAGGACAATGTTAGTAACTACGAGTTGAAGCTGAGCGAGTTGAGAGCGCAGAAACTACTGAACCAACTTGCAGAGATTGGGAATTCCTCAGATTTGCAAGCTCTGCCACAAGGACTTGCTAATCTTCTAAACAAGGTGGAGCCGTCGAAAAGAGAAGAGCTGGTGGCTGCTATTCGAAAGGTCTTGGGTTGACTGA\";\n    String str2 = \"TAAAGTCTTCGATATCAGTCAACCCAAGACCTTTCGAATAGCAGCCACCAGCTCTTCTCTTTTCGACGGCTCCACCTTGTTTAGAAGATTAGCA\";\n    //System.out.println(\"Lengths: \"+str1.length()+\" \"+str2.length());\n    DNASequence target = new DNASequence(str1, AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence query = new DNASequence(str2, AmbiguityDNACompoundSet.getDNACompoundSet());\n    NeedlemanWunsch<DNASequence, NucleotideCompound> aligner = new NeedlemanWunsch<DNASequence, NucleotideCompound>(query, target, gap, matrix);\n    //System.out.println(\"getScore: \" + aligner.getScore());\n    //System.out.println(\"getMaxScore: \" + aligner.getMaxScore());\n    //System.out.println(\"getMinScore: \" + aligner.getMinScore());\n    //System.out.println(\"getSimilarity: \" + aligner.getSimilarity());\n    assertTrue(\"Similarity must be positive, this must be an integer overflow bug!\", aligner.getSimilarity() > 0);\n}", "repo_id": "9", "comment": "/**\n * See issue #202 in github\n * @author Jose M Duarte\n */\n", "repo_name": "biojava-master/", "id": 122, "method_signature": "void testIntOverflowBug()"}, "804": {"callee_method_names": ["Object.getClass"], "method_name": "FragmentJoiner.resizeArray", "method_implementation": "{\n    int oldSize = java.lang.reflect.Array.getLength(oldArray);\n    Class elementType = oldArray.getClass().getComponentType();\n    Object newArray = java.lang.reflect.Array.newInstance(elementType, newSize);\n    int preserveLength = Math.min(oldSize, newSize);\n    if (preserveLength > 0)\n        System.arraycopy(oldArray, 0, newArray, 0, preserveLength);\n    return newArray;\n}", "repo_id": "9", "comment": "/**\n * Reallocates an array with a new size, and copies the contents\n * of the old array to the new array.\n * @param oldArray  the old array, to be reallocated.\n * @param newSize   the new array size.\n * @return          A new array with the same contents.\n */\n", "repo_name": "biojava-master/", "id": 804, "method_signature": "Object resizeArray(Object, int)"}, "3530": {"callee_method_names": [], "method_name": "CoxCoefficient.getName", "method_implementation": "{\n    return name;\n}", "repo_id": "9", "comment": "/**\n * @return the name\n */\n", "repo_name": "biojava-master/", "id": 3530, "method_signature": "String getName()"}, "1724": {"callee_method_names": [], "method_name": "BasePairParameters.getBuckle", "method_implementation": "{\n    checkArgument(bp);\n    return pairingParameters[bp][0];\n}", "repo_id": "9", "comment": "/**\n * This method returns the buckle in degrees for the given base pair\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in degrees)\n */\n", "repo_name": "biojava-master/", "id": 1724, "method_signature": "Double getBuckle(int)"}, "1066": {"callee_method_names": [], "method_name": "CathFactory.setCath", "method_implementation": "{\n    CathFactory.cath = cath;\n}", "repo_id": "9", "comment": "/**\n * Sets the default (singleton) CathDatabase.\n */\n", "repo_name": "biojava-master/", "id": 1066, "method_signature": "void setCath(CathDatabase)"}, "4": {"callee_method_names": [], "method_name": "SimpleGapPenalty.setExtensionPenalty", "method_implementation": "{\n    this.gep = -Math.abs(gep);\n    setType();\n}", "repo_id": "9", "comment": "/**\n * @param gep Should be nonnegative\n */\n", "repo_name": "biojava-master/", "id": 4, "method_signature": "void setExtensionPenalty(int)"}, "832": {"callee_method_names": ["Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "ExecutorService.submit", "ExecutorService.shutdown", "ExecutorService.isTerminated", "Logger.debug"], "method_name": "AsaCalculator.calculateAsas", "method_implementation": "{\n    double[] asas = new double[atomCoords.length];\n    long start = System.currentTimeMillis();\n    if (useSpatialHashingForNeighbors) {\n        logger.debug(\"Will use spatial hashing to find neighbors\");\n        neighborIndices = findNeighborIndicesSpatialHashing();\n    } else {\n        logger.debug(\"Will not use spatial hashing to find neighbors\");\n        neighborIndices = findNeighborIndices();\n    }\n    long end = System.currentTimeMillis();\n    logger.debug(\"Took {} s to find neighbors\", (end - start) / 1000.0);\n    start = System.currentTimeMillis();\n    if (nThreads <= 1) {\n        // (i.e. it will also be 1 thread if 0 or negative number specified)\n        logger.debug(\"Will use 1 thread for ASA calculation\");\n        for (int i = 0; i < atomCoords.length; i++) {\n            asas[i] = calcSingleAsa(i);\n        }\n    } else {\n        logger.debug(\"Will use {} threads for ASA calculation\", nThreads);\n        ExecutorService threadPool = Executors.newFixedThreadPool(nThreads);\n        for (int i = 0; i < atomCoords.length; i++) {\n            threadPool.submit(new AsaCalcWorker(i, asas));\n        }\n        threadPool.shutdown();\n        while (!threadPool.isTerminated()) ;\n    }\n    end = System.currentTimeMillis();\n    logger.debug(\"Took {} s to calculate all {} atoms ASAs (excluding neighbors calculation)\", (end - start) / 1000.0, atomCoords.length);\n    return asas;\n}", "repo_id": "9", "comment": "/**\n * Calculates the Accessible Surface Areas for the atoms given in constructor and with parameters given.\n * Beware that the parallel implementation is quite memory hungry. It scales well as long as there is\n * enough memory available.\n * @return an array with asa values corresponding to each atom of the input array\n */\n", "repo_name": "biojava-master/", "id": 832, "method_signature": "double[] calculateAsas()"}, "2308": {"callee_method_names": ["Matrix4d.set", "Matrix4d.setTranslation", "SuperPosition.getRmsd", "SuperPosition.getRmsd", "Logger.info"], "method_name": "TestSuperPositionQCP.testSymmetryQCP", "method_implementation": "{\n    // Generate an array of points with symmetry\n    Point3d[] set1 = new Point3d[16];\n    set1[0] = new Point3d(14.065934, 47.068832, -32.895836);\n    set1[1] = new Point3d(-14.065934, -47.068832, -32.895836);\n    set1[2] = new Point3d(-47.068832, 14.065934, -32.895836);\n    set1[3] = new Point3d(47.068832, -14.065934, -32.895836);\n    set1[4] = new Point3d(-14.065934, 47.068832, 32.895836);\n    set1[5] = new Point3d(14.065934, -47.068832, 32.895836);\n    set1[6] = new Point3d(47.068832, 14.065934, 32.895836);\n    set1[7] = new Point3d(-47.068832, -14.065934, 32.895836);\n    set1[8] = new Point3d(43.813946, 22.748293, -32.14434);\n    set1[9] = new Point3d(-43.813946, -22.748293, -32.14434);\n    set1[10] = new Point3d(-22.748293, 43.813946, -32.14434);\n    set1[11] = new Point3d(22.748293, -43.813946, -32.14434);\n    set1[12] = new Point3d(-43.813946, 22.748293, 32.14434);\n    set1[13] = new Point3d(43.813946, -22.748293, 32.14434);\n    set1[14] = new Point3d(22.748293, 43.813946, 32.14434);\n    set1[15] = new Point3d(-22.748293, -43.813946, 32.14434);\n    Point3d[] set2 = CalcPoint.clonePoint3dArray(set1);\n    // Use a random transformation to set2\n    AxisAngle4d rotAxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n    Vector3d translation = new Vector3d(0.345, 2.453, 5.324);\n    Matrix4d transform = new Matrix4d();\n    transform.set(rotAxis);\n    transform.setTranslation(translation);\n    CalcPoint.transform(transform, set2);\n    // Use Quaternion superposition to obtain the RMSD\n    SuperPosition algorithm = new SuperPositionQuat(false);\n    long quatStart = System.nanoTime();\n    double quatrmsd = algorithm.getRmsd(set1, set2);\n    long quatTime = (System.nanoTime() - quatStart) / 1000;\n    // Use QCP algorithm to get the RMSD\n    algorithm = new SuperPositionQCP(false);\n    long qcpStart = System.nanoTime();\n    double qcprmsd = algorithm.getRmsd(set1, set2);\n    long qcpTime = (System.nanoTime() - qcpStart) / 1000;\n    LOGGER.info(String.format(\"RMSD Symmetry: Quat time: %d us\" + \", QCP time: %d us\", quatTime, qcpTime));\n    // Check that the returned RMSDs are equal\n    assertEquals(quatrmsd, qcprmsd, 0.001);\n}", "repo_id": "9", "comment": "/**\n * Test case proposed by Peter Rose from his observations about quaternary\n * symmetry artifacts with the QCP algorithm.\n */\n", "repo_name": "biojava-master/", "id": 2308, "method_signature": "void testSymmetryQCP()"}, "1456": {"callee_method_names": [], "method_name": "SpaceGroup.getAxisFoldType", "method_implementation": "{\n    if (axisTypes == null)\n        calcAxisFoldTypes();\n    return axisTypes[transformId];\n}", "repo_id": "9", "comment": "/**\n * Given a transformId returns the type of axis of rotation: 1 (no rotation), 2, 3, 4 or 6 -fold\n * and for improper rotations: -1, -2, -3, -4 and -6\n *\n * @param transformId\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1456, "method_signature": "int getAxisFoldType(int)"}, "1272": {"callee_method_ids": [1261], "callee_method_names": ["MmtfStructureReader.getStructure"], "method_name": "MmtfActions.readFromFile", "method_implementation": "{\n    // Get the reader - this is the bit that people need to implement.\n    MmtfStructureReader mmtfStructureReader = new MmtfStructureReader();\n    // Do the inflation\n    new StructureDataToAdapter(new GenericDecoder(ReaderUtils.getDataFromFile(filePath)), mmtfStructureReader);\n    // Get the structue\n    return mmtfStructureReader.getStructure();\n}", "repo_id": "9", "comment": "/**\n * Get a Structure object from a mmtf file.\n * @param filePath the mmtf file\n * @return a Structure object relating to the input byte array.\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1272, "method_signature": "Structure readFromFile(Path)"}, "1829": {"callee_method_ids": [403], "callee_method_names": ["GroupIterator.getCurrentChain"], "method_name": "AtomIterator.getCurrentChain", "method_implementation": "{\n    return groupiter.getCurrentChain();\n}", "repo_id": "9", "comment": "/**\n * Get the  chain that contains the current atom.\n *\n * @return a Chain object\n */\n", "repo_name": "biojava-master/", "id": 1829, "method_signature": "Chain getCurrentChain()"}, "3877": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getAromaticity"], "method_name": "PeptideProperties.getAromaticity", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getAromaticity(pSequence);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the aromaticity value of sequence. The sequence argument\n * must be a protein sequence consisting of only non-ambiguous characters.\n * <p>\n * Calculates the aromaticity value of a protein according to Lobry, 1994.\n * It is simply the relative frequency of Phe+Trp+Tyr.\n * *\n *\n * @param sequence a protein sequence consisting of non-ambiguous characters only\n * @return the aromaticity value of sequence\n */\n", "repo_name": "biojava-master/", "id": 3877, "method_signature": "double getAromaticity(String)"}, "3413": {"callee_method_ids": [1971], "callee_method_names": ["HelixAxisAligner.getSubunits", "HelixAxisAligner.getHelixLayers", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "List<Point3d>.get", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "List<Point3d>.size", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "List<Point3d>.get", "StringBuilder.append", "List<Point3d>.get", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorH.drawPolyhedron", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    // for now, return empty script until this has been implemented properly\n    //\t\tif (s.length() == 0)\n    //\t\t\treturn s.toString();\n    //\t\tPoint3d[] vertices = getRepeatUnitCenters();\n    List<Point3d> vertices = helixAxisAligner.getSubunits().getOriginalCenters();\n    vertices = extendUnitCenters(vertices);\n    int index = 0;\n    Color4f c = new Color4f(Color.MAGENTA);\n    //\t\tdouble width = getMaxExtension()*0.015;\n    double width = getMaxExtension() * 0.007;\n    //\t\tList<List<Integer>> layerLines = helixAxisAligner.getHelixLayers().getByLargestContactsNotLowestAngle().getLayerLines();\n    //\t\tlayerLines.addAll(helixAxisAligner.getHelixLayers().getByLowestAngle().getLayerLines());\n    List<List<Integer>> layerLines = helixAxisAligner.getHelixLayers().getByLargestContacts().getLayerLines();\n    for (List<Integer> line : layerLines) {\n        s.append(\"draw polyhedron\");\n        s.append(name);\n        s.append(index++);\n        s.append(\" line\");\n        for (int i : line) {\n            s.append(getJmolPoint(vertices.get(i)));\n        }\n        s.append(\"width \");\n        s.append(fDot2(width));\n        s.append(\" color\");\n        s.append(getJmolColor(c));\n        s.append(\" off;\");\n    }\n    List<Point3d> interiorVertices = interiorCenters(vertices);\n    for (int i = 0; i < vertices.size(); i++) {\n        s.append(\"draw polyhedron\");\n        s.append(name);\n        s.append(index++);\n        s.append(\" line\");\n        s.append(getJmolPoint(vertices.get(i)));\n        s.append(getJmolPoint(interiorVertices.get(i)));\n        s.append(\"width \");\n        s.append(fDot2(width));\n        s.append(\" color\");\n        s.append(getJmolColor(c));\n        s.append(\" off;\");\n    }\n    //\t\tMatrix4d transformation = helixAxisTransformation.getHelixLayers().getByLowestAngle().getTransformation();\n    //\n    //\t\tPoint3d[] vertices2 = SuperPosition.clonePoint3dArray(vertices);\n    //\t\tfor (Point3d p: vertices2) {\n    //\t\t\ttransformation.transform(p);\n    //\t\t}\n    //\n    //\t\t// extend grid by one turn in +z direction\n    //\t\tfor (int[] lineLoop: getLayerLines()) {\n    //\t\t\ts.append(\"draw line\");\n    //\t\t\ts.append(name);\n    //\t\t\ts.append(index++);\n    //\t\t\ts.append(\" line\");\n    //\t\t\tint count = 0;\n    //\t\t\tfor (int i: lineLoop) {\n    //\t\t\t\tfor (Point3d v: vertices) {\n    //\t\t\t\t\tif (v.distance(vertices2[i]) > 0.1) {\n    //\t\t\t\t\t\tcount++;\n    //\t\t\t\t\t\tbreak;\n    //\t\t\t\t\t}\n    //\t\t\t\t}\n    //\t\t\t\tif (count > 0) {\n    //\t\t\t\t\ts.append(getJmolPoint(vertices2[i]));\n    //\t\t\t\t} else {\n    //\t\t\t\t\ts.append(\" \");\n    //\t\t\t\t}\n    //\t\t\t}\n    //\t\t\ts.append(\"width \");\n    //\t\t    s.append(fDot2(width));\n    //\t\t\ts.append(\" color\");\n    //\t\t\ts.append(getJmolColor(c));\n    //\t\t\ts.append(\" off;\");\n    //\t\t}\n    //\n    //\n    //\t\t// extend grid by one turn into -z direction\n    //\t\tPoint3d[] vertices3 = SuperPosition.clonePoint3dArray(vertices);\n    //\t\tMatrix4d m = new Matrix4d();\n    //\t\tm.set(transformation);\n    //\t\tm.invert();\n    //\t\tfor (Point3d p: vertices3) {\n    //\t\t\tm.transform(p);\n    //\t\t}\n    //\n    //\t\tfor (int[] lineLoop: getLayerLines()) {\n    //\t\t\ts.append(\"draw line\");\n    //\t\t\ts.append(name);\n    //\t\t\ts.append(index++);\n    //\t\t\ts.append(\" line\");\n    //\t\t\tint count = 0;\n    //\t\t\tfor (int i: lineLoop) {\n    //\t\t\t\tfor (Point3d v: vertices) {\n    //\t\t\t\t\tif (v.distance(vertices3[i]) > 0.1) {\n    //\t\t\t\t\t\tcount++;\n    //\t\t\t\t\t}\n    //\t\t\t\t}\n    //\t\t\t\tif (count > 0) {\n    //\t\t\t\t\ts.append(getJmolPoint(vertices3[i]));\n    //\t\t\t\t} else {\n    //\t\t\t\t\ts.append(\" \");\n    //\t\t\t\t}\n    //\t\t\t}\n    //\t\t\ts.append(\"width \");\n    //\t\t    s.append(fDot2(width));\n    //\t\t\ts.append(\" color\");\n    //\t\t\ts.append(getJmolColor(c));\n    //\t\t\ts.append(\" off;\");\n    //\t\t}\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script that draws an invisible polyhedron around a structure.\n * Use showPolyhedron() and hidePolyhedron() to toggle visibility.\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3413, "method_signature": "String drawPolyhedron()"}, "333": {"callee_method_names": ["Object.hashCode", "Object[].hashCode", "Object.equals"], "method_name": "SmallMap.get", "method_implementation": "{\n    // Doesn't actually need to check if mappings is null, since numMappings\n    // will necessarily be zero.\n    int keyHash = key.hashCode();\n    for (int i = 0; i < numMappings * 2; i += 2) {\n        if (keyHash == mappings[i].hashCode() && key.equals(mappings[i])) {\n            return mappings[i + 1];\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * @throws NullPointerException if key is null\n */\n", "repo_name": "biojava-master/", "id": 333, "method_signature": "Object get(Object)"}, "239": {"callee_method_names": [], "method_name": "Builder.setDescription", "method_implementation": "{\n    // description is created on the fly in getDescription\n    return this;\n}", "repo_id": "9", "comment": "/**\n * @param description description of the modification.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 239, "method_signature": "Builder setDescription(String)"}, "2281": {"callee_method_names": ["String.length", "String.length", "Structure.getPolyChainByPDB", "Chain.getSeqResGroups", "String.length", "List<Group>.size", "Chain.getSeqResSequence", "String.length", "List<Group>.get"], "method_name": "TestHeaderOnly.check1REPChainC", "method_implementation": "{\n    String sequence = \"MAETAVINHKKRKNSPRIVQSNDLTEAAYSLSRDQKRMLYLFVDQIRK\" + \"SDGTLQEHDGICEIHVAKYAEIFGLTSAEASKDIRQALKSFAGKEVVFYRPEEDAGDE\" + \"KGYESFPWFIKPAHSPSRGLYSVHINPYLIPFFIGLQNRFTQFRLSETKEITNPYAMR\" + \"LYESLCQYRKPDGSGIVSLKIDWIIERYQLPQSYQRMPDFRRRFLQVCVNEINSRTPM\" + \"RLSYIEKKKGRQTTHIVFSFRDITSMTTG\";\n    boolean[] shouldMatch = new boolean[sequence.length()];\n    for (int i = 0; i < sequence.length(); i++) shouldMatch[i] = true;\n    // 1-14 is gap\n    for (int i = 0; i < 14; i++) shouldMatch[i] = false;\n    // 50-55 is gap\n    for (int i = 49; i < 55; i++) shouldMatch[i] = false;\n    // 98-109 is gap\n    for (int i = 97; i < 109; i++) shouldMatch[i] = false;\n    // 247-251 is gap\n    for (int i = 246; i < 251; i++) shouldMatch[i] = false;\n    Chain c = s.getPolyChainByPDB(\"C\");\n    List<Group> seqres = c.getSeqResGroups();\n    // Check lengths\n    Assert.assertEquals(sequence.length(), seqres.size());\n    // Check sequences.\n    Assert.assertEquals(sequence, c.getSeqResSequence());\n    for (int i = 0; i < sequence.length(); i++) {\n        Assert.assertEquals(shouldMatch[i], hasAtoms(seqres.get(i)));\n    }\n}", "repo_id": "9", "comment": "/**\n * Check that the gapped residues have no atoms, but that ungapped residues\n * have atoms.\n *\n * @param s: Structure to test.\n */\n", "repo_name": "biojava-master/", "id": 2281, "method_signature": "void check1REPChainC(Structure)"}, "1330": {"callee_method_names": [], "method_name": "FileParsingParameters.setCreateAtomBonds", "method_implementation": "{\n    this.createAtomBonds = createAtomBonds;\n}", "repo_id": "9", "comment": "/**\n * Should we create bonds between atoms when parsing a file.\n * Will create intra-group bonds from information available in chemical component files and\n * some other bonds from struc_conn category in mmCIF file.\n *\n * @param createAtomBonds\n *            true if we should create the bonds, false if not\n * @see BondMaker\n */\n", "repo_name": "biojava-master/", "id": 1330, "method_signature": "void setCreateAtomBonds(boolean)"}, "1977": {"callee_method_names": ["Matrix4d.mul", "Matrix4d.set"], "method_name": "HelixAxisAligner.calcZDirection", "method_implementation": "{\n    calcBoundaries();\n    // if the longer part of the structure faces towards the back (-z direction),\n    // rotate around y-axis so the longer part faces the viewer (+z direction)\n    if (Math.abs(minBoundary.z) > Math.abs(maxBoundary.z)) {\n        Matrix4d rot = flipY();\n        rot.mul(transformationMatrix);\n        transformationMatrix.set(rot);\n    }\n}", "repo_id": "9", "comment": "/*\n\t * Modifies the rotation part of the transformation axis for\n\t * a Cn symmetric complex, so that the narrower end faces the\n\t * viewer, and the wider end faces away from the viewer. Example: 3LSV\n\t */\n", "repo_name": "biojava-master/", "id": 1977, "method_signature": "void calcZDirection()"}, "1896": {"callee_method_names": [], "method_name": "Stoichiometry.getAlphabet", "method_implementation": "{\n    return alphabet;\n}", "repo_id": "9", "comment": "/**\n * @return Alphabet (a sequence of characters) used in this stoichiometry to construct human-readable representation.\n */\n", "repo_name": "biojava-master/", "id": 1896, "method_signature": "String getAlphabet()"}, "650": {"callee_method_ids": [487, 490, 489], "callee_method_names": ["AFPChain.getBlockNum", "AFPChain.getOptLen", "AFPChain.getOptAln"], "method_name": "AFPAlignmentDisplay.getBlockNrForAlignPos", "method_implementation": "{\n    // moved here from DisplayAFP;\n    int blockNum = afpChain.getBlockNum();\n    int[] optLen = afpChain.getOptLen();\n    int[][][] optAln = afpChain.getOptAln();\n    int len = 0;\n    int p1b = 0;\n    int p2b = 0;\n    for (int i = 0; i < blockNum; i++) {\n        for (int j = 0; j < optLen[i]; j++) {\n            int p1 = optAln[i][0][j];\n            int p2 = optAln[i][1][j];\n            if (len != 0) {\n                // check for gapped region\n                int lmax = (p1 - p1b - 1) > (p2 - p2b - 1) ? (p1 - p1b - 1) : (p2 - p2b - 1);\n                for (int k = 0; k < lmax; k++) {\n                    len++;\n                }\n            }\n            p1b = p1;\n            p2b = p2;\n            if (len >= aligPos) {\n                return i;\n            }\n            len++;\n        }\n    }\n    return blockNum;\n}", "repo_id": "9", "comment": "/**\n * get the block number for an aligned position\n *\n * @param afpChain\n * @param aligPos\n * @return\n */\n", "repo_name": "biojava-master/", "id": 650, "method_signature": "int getBlockNrForAlignPos(AFPChain, int)"}, "1797": {"callee_method_names": ["Object.getClass", "String.equals", "String.equals", "String.equals", "String.equals", "Integer.equals", "Integer.equals", "String.equals", "Long.equals", "Set<String>.equals", "Boolean.equals", "PdbId.equals", "String.equals", "Integer.equals", "String.equals", "Long.equals", "Integer.equals", "String.equals"], "method_name": "EcodDomain.equals", "method_implementation": "{\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    EcodDomain other = (EcodDomain) obj;\n    if (architectureName == null) {\n        if (other.architectureName != null)\n            return false;\n    } else if (!architectureName.equals(other.architectureName))\n        return false;\n    if (chainId == null) {\n        if (other.chainId != null)\n            return false;\n    } else if (!chainId.equals(other.chainId))\n        return false;\n    if (domainId == null) {\n        if (other.domainId != null)\n            return false;\n    } else if (!domainId.equals(other.domainId))\n        return false;\n    if (fGroupName == null) {\n        if (other.fGroupName != null)\n            return false;\n    } else if (!fGroupName.equals(other.fGroupName))\n        return false;\n    if (fGroup == null) {\n        if (other.fGroup != null)\n            return false;\n    } else if (!fGroup.equals(other.fGroup))\n        return false;\n    if (hGroup == null) {\n        if (other.hGroup != null)\n            return false;\n    } else if (!hGroup.equals(other.hGroup))\n        return false;\n    if (hGroupName == null) {\n        if (other.hGroupName != null)\n            return false;\n    } else if (!hGroupName.equals(other.hGroupName))\n        return false;\n    if (assemblyId == null) {\n        if (other.assemblyId != null)\n            return false;\n    } else if (!assemblyId.equals(other.assemblyId))\n        return false;\n    if (ligands == null) {\n        if (other.ligands != null)\n            return false;\n    } else if (!ligands.equals(other.ligands))\n        return false;\n    if (manual == null) {\n        if (other.manual != null)\n            return false;\n    } else if (!manual.equals(other.manual))\n        return false;\n    if (pdbId == null) {\n        if (other.pdbId != null)\n            return false;\n    } else if (!pdbId.equals(other.pdbId))\n        return false;\n    if (range == null) {\n        if (other.range != null)\n            return false;\n    } else if (!range.equals(other.range))\n        return false;\n    if (tGroup == null) {\n        if (other.tGroup != null)\n            return false;\n    } else if (!tGroup.equals(other.tGroup))\n        return false;\n    if (tGroupName == null) {\n        if (other.tGroupName != null)\n            return false;\n    } else if (!tGroupName.equals(other.tGroupName))\n        return false;\n    if (uid == null) {\n        if (other.uid != null)\n            return false;\n    } else if (!uid.equals(other.uid))\n        return false;\n    if (xGroup == null) {\n        if (other.xGroup != null)\n            return false;\n    } else if (!xGroup.equals(other.xGroup))\n        return false;\n    if (xGroupName == null) {\n        if (other.xGroupName != null)\n            return false;\n    } else if (!xGroupName.equals(other.xGroupName))\n        return false;\n    return true;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n", "repo_name": "biojava-master/", "id": 1797, "method_signature": "boolean equals(Object)"}, "2736": {"callee_method_names": [], "method_name": "EmblRecord.getEmblReference", "method_implementation": "{\n    return emblReference;\n}", "repo_id": "9", "comment": "/**\n * The Reference (RN, RC, RP, RX, RG, RA, RT, RL) Lines\n * These lines comprise the literature citations within the database.\n * The citations provide access to the papers from which the data has been\n * abstracted.\n *\n * @return EmblReference\n */\n", "repo_name": "biojava-master/", "id": 2736, "method_signature": "List<EmblReference> getEmblReference()"}, "1364": {"callee_method_ids": [1363, 1359, 1360], "callee_method_names": ["AminoAcidImpl.setPDBFlag", "AminoAcidImpl.setResidueNumber", "AminoAcidImpl.setPDBName", "AminoAcidImpl.setAminoType", "AminoAcidImpl.setRecordType", "AminoAcidImpl.addAltLoc", "AminoAcidImpl.setChemComp"], "method_name": "AminoAcidImpl.clone", "method_implementation": "{\n    AminoAcidImpl n = new AminoAcidImpl();\n    n.setPDBFlag(has3D());\n    n.setResidueNumber(getResidueNumber());\n    n.setPDBName(getPDBName());\n    n.setAminoType(getAminoType());\n    n.setRecordType(recordType);\n    //clone atoms and bonds.\n    cloneAtomsAndBonds(n);\n    // copying the alt loc groups if present, otherwise they stay null\n    if (getAltLocs() != null && !getAltLocs().isEmpty()) {\n        for (Group altLocGroup : this.getAltLocs()) {\n            Group nAltLocGroup = (Group) altLocGroup.clone();\n            n.addAltLoc(nAltLocGroup);\n        }\n    }\n    if (chemComp != null)\n        n.setChemComp(chemComp);\n    return n;\n}", "repo_id": "9", "comment": "/**\n * returns and identical copy of this Group object .\n * @return  and identical copy of this Group object\n */\n", "repo_name": "biojava-master/", "id": 1364, "method_signature": "Object clone()"}, "138": {"callee_method_ids": [449, 452], "callee_method_names": ["QsAlignResult.length", "QsAlignResult.getRelation"], "method_name": "TestQsAlignExamples.testDifferent", "method_implementation": "{\n    Structure s1 = StructureIO.getStructure(\"4hhb\");\n    Structure s2 = StructureIO.getStructure(\"3ifv\");\n    SubunitClustererParameters clusterParams = new SubunitClustererParameters();\n    QsAlignParameters alignParams = new QsAlignParameters();\n    QsAlignResult result = QsAlign.align(s1, s2, clusterParams, alignParams);\n    assertEquals(result.length(), 0);\n    assertEquals(result.getRelation(), QsRelation.DIFFERENT);\n}", "repo_id": "9", "comment": "/**\n * Different: test two completely different proteins (4HHB, 3IFV).\n */\n", "repo_name": "biojava-master/", "id": 138, "method_signature": "void testDifferent()"}, "1713": {"callee_method_names": ["ResidueRange.getLength"], "method_name": "ResidueRangeAndLength.calcLength", "method_implementation": "{\n    int l = 0;\n    for (ResidueRangeAndLength rr : rrs) {\n        l += rr.getLength();\n    }\n    return l;\n}", "repo_id": "9", "comment": "/**\n * Calculates the combined number of residues of the ResidueRanges in {@code rrs}.\n *\n * Assumes no overlap. If two or more ranges cover the same residues, will over-count the union of the residues.\n *\n * @param rrs\n *            A list of ResidueRanges\n * @return The combined length\n * @throws IllegalArgumentException\n *             If the {@link #getLength() length} of one or more ResidueRange is null\n * @see #getLength()\n */\n", "repo_name": "biojava-master/", "id": 1713, "method_signature": "int calcLength(List)"}, "1648": {"callee_method_names": [], "method_name": "SubunitClustererParameters.isUseGlobalMetrics", "method_implementation": "{\n    return useGlobalMetrics;\n}", "repo_id": "9", "comment": "/**\n * Use metrics calculated relative to the whole sequence or structure,\n * rather than the aligned part only\n *\n * @return useGlobalMetrics\n */\n", "repo_name": "biojava-master/", "id": 1648, "method_signature": "boolean isUseGlobalMetrics()"}, "1033": {"callee_method_names": ["Chain.getAtomGroups", "Group.getAtom", "Logger.debug", "Group.getResidueNumber", "Group.getPDBName", "List<Atom>.add", "List<Atom>.addAll", "List<Atom>.toArray"], "method_name": "StructureTools.getAtomArray", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>();\n    for (Group g : c.getAtomGroups()) {\n        // a temp container for the atoms of this group\n        List<Atom> thisGroupAtoms = new ArrayList<>();\n        // flag to check if this group contains all the requested atoms.\n        boolean thisGroupAllAtoms = true;\n        for (String atomName : atomNames) {\n            Atom a = g.getAtom(atomName);\n            if (a == null) {\n                logger.debug(\"Group {} ({}) does not have the required atom '{}'\", g.getResidueNumber(), g.getPDBName(), atomName);\n                // this group does not have a required atom, skip it...\n                thisGroupAllAtoms = false;\n                break;\n            }\n            thisGroupAtoms.add(a);\n        }\n        if (thisGroupAllAtoms) {\n            // add the atoms of this group to the array.\n            atoms.addAll(thisGroupAtoms);\n        }\n    }\n    return atoms.toArray(new Atom[0]);\n}", "repo_id": "9", "comment": "/**\n * Returns an array of the requested Atoms from the Chain object. Iterates\n * over all groups and checks if the requested atoms are in this group, no\n * matter if this is a AminoAcid or Hetatom group. If the group does not\n * contain all requested atoms then no atoms are added for that group.\n *\n * @param c\n *            the Chain to get the atoms from\n *\n * @param atomNames\n *            contains the atom names to be used.\n * @return an Atom[] array\n */\n", "repo_name": "biojava-master/", "id": 1033, "method_signature": "Atom[] getAtomArray(Chain, String[])"}, "3114": {"callee_method_names": ["String.replaceAll", "CompoundSet<C>.getMaxSingleCompoundStringLength", "CompoundSet<C>.getCompoundForString", "String.length"], "method_name": "UniprotProxySequenceReader.setContents", "method_implementation": "{\n    // Horrendously inefficient - pretty much the way the old BJ did things.\n    // TODO Should be optimised.\n    // NOTE This chokes on whitespace in the sequence, so whitespace is stripped\n    this.sequence = sequence.replaceAll(\"\\\\s\", \"\").trim();\n    this.parsedCompounds.clear();\n    for (int i = 0; i < this.sequence.length(); ) {\n        String compoundStr = null;\n        C compound = null;\n        for (int compoundStrLength = 1; compound == null && compoundStrLength <= compoundSet.getMaxSingleCompoundStringLength(); compoundStrLength++) {\n            compoundStr = this.sequence.substring(i, i + compoundStrLength);\n            compound = compoundSet.getCompoundForString(compoundStr);\n        }\n        if (compound == null) {\n            throw new CompoundNotFoundException(\"Compound \" + compoundStr + \" not found\");\n        } else {\n            i += compoundStr.length();\n        }\n        this.parsedCompounds.add(compound);\n    }\n}", "repo_id": "9", "comment": "/**\n * Once the sequence is retrieved set the contents and make sure everything this is valid\n * Some uniprot records contain white space in the sequence. We must strip it out so setContents doesn't fail.\n * @param sequence\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 3114, "method_signature": "void setContents(String)"}, "2118": {"callee_method_names": [], "method_name": "StructureImpl.getName", "method_implementation": "{\n    return name;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2118, "method_signature": "String getName()"}, "679": {"callee_method_names": ["List<Atom[]>.size", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.size", "List<Atom[]>.get"], "method_name": "MultipleAlignmentScorer.getRMSD", "method_implementation": "{\n    double sumSqDist = 0;\n    int comparisons = 0;\n    for (int r1 = 0; r1 < transformed.size(); r1++) {\n        for (int c = 0; c < transformed.get(r1).length; c++) {\n            Atom refAtom = transformed.get(r1)[c];\n            if (refAtom == null)\n                continue;\n            double nonNullSqDist = 0;\n            int nonNullLength = 0;\n            for (int r2 = r1 + 1; r2 < transformed.size(); r2++) {\n                Atom atom = transformed.get(r2)[c];\n                if (atom != null) {\n                    nonNullSqDist += Calc.getDistanceFast(refAtom, atom);\n                    nonNullLength++;\n                }\n            }\n            if (nonNullLength > 0) {\n                comparisons++;\n                sumSqDist += nonNullSqDist / nonNullLength;\n            }\n        }\n    }\n    return Math.sqrt(sumSqDist / comparisons);\n}", "repo_id": "9", "comment": "/**\n * Calculates the RMSD of all-to-all structure comparisons (distances),\n * given a set of superimposed atoms.\n *\n * @param transformed\n * @return double RMSD\n * @see #getRMSD(MultipleAlignment)\n */\n", "repo_name": "biojava-master/", "id": 679, "method_signature": "double getRMSD(List)"}, "484": {"callee_method_names": [], "method_name": "AFPChain.getAfpSet", "method_implementation": "{\n    return afpSet;\n}", "repo_id": "9", "comment": "/**\n * Get the set of AFPs for this alignment.\n * An AFP is a local ungapped alignment between the two peptides.\n *\n * AFPs are set before the final optimization step. To get the final\n * alignment, look at the aligned pairs from {@link #getOptAln()}.\n *\n * @return The optimal set of AFPs\n * @see #getOptAln()\n */\n", "repo_name": "biojava-master/", "id": 484, "method_signature": "List<AFP> getAfpSet()"}, "1711": {"callee_method_names": [], "method_name": "BondImpl.getLength", "method_implementation": "{\n    return Calc.getDistance(atomA, atomB);\n}", "repo_id": "9", "comment": "/**\n * Gets the distance between the two atoms of this bond.\n * <p>\n * This distance is calculated by {@link Calc#getDistance(Atom, Atom)}.\n *\n * @return the distance between the two atoms of this bond.\n */\n", "repo_name": "biojava-master/", "id": 1711, "method_signature": "double getLength()"}, "2304": {"callee_method_ids": [1322, 1190, 1438, 903, 909, 911, 901, 901, 901], "callee_method_names": ["FileParsingParameters.setAlignSeqRes", "PDBFileParser.setFileParsingParameters", "PDBFileParser.parsePDBFile", "Structure.getChains", "Structure.getEntityInfos", "CrystalBuilder.getUniqueInterfaces", "StructureInterfaceList.calcAsas", "StructureInterfaceList.removeInterfacesBelowArea", "StructureInterfaceList.getClusters", "StructureInterfaceList.size", "List<StructureInterfaceCluster>.size", "List<StructureInterfaceCluster>.get", "List<StructureInterfaceCluster>.get", "StructureInterfaceList.get", "StructureInterfaceList.get", "StructureInterfaceList.get"], "method_name": "TestInterfaceClustering.test3DDONoSeqresPdb", "method_implementation": "{\n    // 3ddo contains 6 chains in 1 entity, with residue numbering completely different in each of the chains\n    InputStream inStream = new GZIPInputStream(this.getClass().getResourceAsStream(\"/org/biojava/nbio/structure/io/3ddo_raw_noseqres.pdb.gz\"));\n    assertNotNull(inStream);\n    PDBFileParser pdbpars = new PDBFileParser();\n    FileParsingParameters params = new FileParsingParameters();\n    params.setAlignSeqRes(true);\n    pdbpars.setFileParsingParameters(params);\n    Structure s = pdbpars.parsePDBFile(inStream);\n    assertNotNull(s);\n    assertEquals(6, s.getChains().size());\n    assertEquals(1, s.getEntityInfos().size());\n    CrystalBuilder cb = new CrystalBuilder(s);\n    StructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n    interfaces.calcAsas(100, 1, 0);\n    interfaces.removeInterfacesBelowArea();\n    List<StructureInterfaceCluster> clusters = interfaces.getClusters();\n    // 22 if below 35A2 interfaces are filtered\n    assertEquals(22, interfaces.size());\n    // we simply want to test that some interfaces cluster together, for this entry\n    // it is problematic because of different residue numbering between different chains of same entity\n    assertTrue(\"Expected fewer than 22 interfaces (some interfaces should cluster together)\", clusters.size() < 22);\n    // first 2 clusters are of size 3\n    assertEquals(\"Cluster 1 should have 3 members\", 3, clusters.get(0).getMembers().size());\n    assertEquals(\"Cluster 2 should have 3 members\", 3, clusters.get(1).getMembers().size());\n    // detection of isologous test: first 3 interfaces should be isologous\n    assertTrue(\"Interface 1 should be isologous\", interfaces.get(1).isIsologous());\n    assertTrue(\"Interface 2 should be isologous\", interfaces.get(2).isIsologous());\n    assertTrue(\"Interface 3 should be isologous\", interfaces.get(3).isIsologous());\n}", "repo_id": "9", "comment": "//@Test\n", "repo_name": "biojava-master/", "id": 2304, "method_signature": "void test3DDONoSeqresPdb()"}, "164": {"callee_method_names": ["Structure.getPDBHeader"], "method_name": "TestNcsOpsParsing.test1smt", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    StructureIO.setAtomCache(cache);\n    Structure s = StructureIO.getStructure(\"1smt\");\n    Matrix4d[] ops = s.getPDBHeader().getCrystallographicInfo().getNcsOperators();\n    assertNull(ops);\n}", "repo_id": "9", "comment": "/**\n * A structure without struct_ncs_ops\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 164, "method_signature": "void test1smt()"}, "106": {"callee_method_names": [], "method_name": "DistanceMatrixCalculator.fractionalDissimilarity", "method_implementation": "{\n    Msa fMsa = ForesterWrapper.convert(msa);\n    DistanceMatrix DM = PairwiseDistanceCalculator.calcFractionalDissimilarities(fMsa);\n    return DM;\n}", "repo_id": "9", "comment": "/**\n * The fractional dissimilarity (D) is defined as the percentage of sites\n * that differ between two aligned sequences. The percentage of identity\n * (PID) is the fraction of identical sites between two aligned sequences.\n *\n * <pre>\n * D = 1 - PID\n * </pre>\n *\n * The gapped positons in the alignment are ignored in the calculation. This\n * method is a wrapper to the forester implementation of the calculation:\n * {@link PairwiseDistanceCalculator#calcFractionalDissimilarities(Msa)}\n *\n * @param msa\n *            MultipleSequenceAlignment\n * @return DistanceMatrix\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 106, "method_signature": "DistanceMatrix fractionalDissimilarity(MultipleSequenceAlignment)"}, "1280": {"callee_method_names": [], "method_name": "MmtfSummaryDataBean.setAllAtoms", "method_implementation": "{\n    this.allAtoms = allAtoms;\n}", "repo_id": "9", "comment": "/**\n * @param allAtoms the list of atoms (in all models) in the structure\n */\n", "repo_name": "biojava-master/", "id": 1280, "method_signature": "void setAllAtoms(List)"}, "2077": {"callee_method_names": ["List<List<Integer>>.get", "List<Integer>.add", "List<Integer>.size", "List<List<Integer>>.get", "List<Integer>.get", "List<List<Integer>>.get", "List<Integer>.get", "List<Integer>.add", "List<Integer>.size"], "method_name": "SymmOptimizer.checkGaps", "method_implementation": "{\n    List<Integer> shrinkColumns = new ArrayList<Integer>();\n    // Loop for each column\n    for (int res = 0; res < length; res++) {\n        int gapCount = 0;\n        // Loop for each repeat and count the gaps\n        for (int su = 0; su < order; su++) {\n            if (block.get(su).get(res) == null)\n                gapCount++;\n        }\n        if ((order - gapCount) < Rmin) {\n            // Add the column to the shrink list\n            shrinkColumns.add(res);\n        }\n    }\n    // Shrink the columns that have more gaps than allowed\n    for (int col = shrinkColumns.size() - 1; col >= 0; col--) {\n        for (int su = 0; su < order; su++) {\n            Integer residue = block.get(su).get(shrinkColumns.get(col));\n            block.get(su).remove((int) shrinkColumns.get(col));\n            if (residue != null)\n                freePool.add(residue);\n            Collections.sort(freePool);\n        }\n        length--;\n    }\n    if (shrinkColumns.size() != 0)\n        return true;\n    else\n        return false;\n}", "repo_id": "9", "comment": "/**\n * Method that loops through all the alignment columns and checks that there\n * are no more gaps than the maximum allowed: Rmin.\n * <p>\n * There must be at least Rmin residues different than null in every\n * alignment column. In case there is a column with more gaps than allowed\n * it will be shrinked (moved to freePool).\n *\n * @return true if any columns has been shrinked and false otherwise\n */\n", "repo_name": "biojava-master/", "id": 2077, "method_signature": "boolean checkGaps()"}, "2922": {"callee_method_names": [], "method_name": "AbstractSequence.setReferences", "method_implementation": "{\n    this.references = references;\n}", "repo_id": "9", "comment": "/**\n * Set the list of {@link AbstractReference}\n * @since 5.0.0\n * @param references\n */\n", "repo_name": "biojava-master/", "id": 2922, "method_signature": "void setReferences(List)"}, "3299": {"callee_method_names": [], "method_name": "AFPChainCoordManager.getAligSeq", "method_implementation": "{\n    int i1 = getSeqPos(0, point);\n    Point t1 = getPanelPos(0, i1);\n    if (Math.abs(t1.x - point.x) <= DEFAULT_CHAR_SIZE && Math.abs(t1.y - point.y) < DEFAULT_CHAR_SIZE) {\n        return 0;\n    }\n    int i2 = getSeqPos(1, point);\n    Point t2 = getPanelPos(1, i2);\n    if (Math.abs(t2.x - point.x) < DEFAULT_CHAR_SIZE && Math.abs(t2.y - point.y) < DEFAULT_CHAR_SIZE) {\n        return 1;\n    }\n    //System.out.println(\" i1: \" + i1 +\" t1 : \" + Math.abs(t1.x - point.x) + \" \" + Math.abs(t1.y-point.y));\n    //System.out.println(i2);\n    return -1;\n}", "repo_id": "9", "comment": "/**\n * returns the AligSeq (0 or 1) for a point\n * returns -1 if not over an alig seq.\n * @param point\n * @return which of the two sequences a point on the panel corresponds to\n */\n", "repo_name": "biojava-master/", "id": 3299, "method_signature": "int getAligSeq(Point)"}, "3415": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorH.hideAxes", "method_implementation": "{\n    return \"draw axes* off;\";\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script to hide axes\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3415, "method_signature": "String hideAxes()"}, "3196": {"callee_method_names": ["Hsp.hashCode", "Hsp.hashCode", "Hsp.hashCode", "Hsp.hashCode", "Hsp.hashCode", "Hsp.hashCode"], "method_name": "HspTest.testHashCode", "method_implementation": "{\n    System.out.println(\"hashCode\");\n    Hsp instance;\n    int expResult;\n    int result;\n    instance = new BlastHspBuilder().setHspNum(1).setHspBitScore(377.211).setHspEvalue(8.04143e-093).setHspQueryFrom(1).setHspQueryTo(224).setHspHitFrom(1035).setHspHitTo(811).setHspQueryFrame(-1).setHspIdentity(213).setHspPositive(213).setHspGaps(5).setHspAlignLen(227).setHspQseq(\"CTGACGACAGCCATGCACCACCTGTCTCGACTTTCCCCCGAAGGGCACCTAATGTATCTCTACCTCGTTAGTCGGATGTCAAGACCTGGTAAGGTTTTTTCGCGTATCTTCGAATTAAACCACATACTCCACTGCTTGTGCGG-CCCCCGTCAATTCCTTTGAGTTTCAACCTTGCGGCCGTACTCCC-AGGTGGA-TACTTATTGTGTTAACTCCGGCACGGAAGG\").setHspHseq(\"CTGACGACAACCATGCACCACCTGTCTCAACTTTCCCC-GAAGGGCACCTAATGTATCTCTACTTCGTTAGTTGGATGTCAAGACCTGGTAAGGTT-CTTCGCGTTGCTTCGAATTAAACCACATACTCCACTGCTTGTGCGGGCCCCCGTCAATTCCTTTGAGTTTCAACCTTGCGGTCGTACTCCCCAGGTGGATTACTTATTGTGTTAACTCCGGCACAGAAGG\").setHspIdentityString(\"||||||||| |||||||||||||||||| ||||||||| |||||||||||||||||||||||| |||||||| |||||||||||||||||||||||  |||||||  |||||||||||||||||||||||||||||||||||| |||||||||||||||||||||||||||||||||| ||||||||| ||||||| |||||||||||||||||||||||| |||||\").createBlastHsp();\n    expResult = hspImpl.hashCode();\n    result = instance.hashCode();\n    assertEquals(expResult, result);\n    instance = new BlastHspBuilder().setPercentageIdentity(100.00 / 100).setHspAlignLen(48).setMismatchCount(0).setHspGaps(0).setHspQueryFrom(1).setHspQueryTo(48).setHspHitFrom(344).setHspHitTo(391).setHspEvalue(4e-19).setHspBitScore(95.6).createBlastHsp();\n    expResult = uncompleteHsp.hashCode();\n    result = instance.hashCode();\n    assertEquals(expResult, result);\n    Hsp uncompleteHsp2 = new BlastHspBuilder().setPercentageIdentity(100.00 / 100).setHspAlignLen(48).setMismatchCount(0).setHspGaps(0).setHspQueryFrom(1).setHspQueryTo(48).setHspHitFrom(344).setHspHitTo(391).setHspEvalue(4e-19).setHspBitScore(95.6).createBlastHsp();\n    assertEquals(uncompleteHsp.hashCode(), uncompleteHsp2.hashCode());\n}", "repo_id": "9", "comment": "/**\n * Test of hashCode method, of class Hsp.\n */\n", "repo_name": "biojava-master/", "id": 3196, "method_signature": "void testHashCode()"}, "990": {"callee_method_names": [], "method_name": "HetatomImpl.getId", "method_implementation": "{\n    return id;\n}", "repo_id": "9", "comment": "/**\n * the Hibernate database ID\n *\n * @return the id\n */\n", "repo_name": "biojava-master/", "id": 990, "method_signature": "long getId()"}, "1546": {"callee_method_names": ["String.toLowerCase", "Map<Integer, ScopDescription>.keySet", "Map<Integer, ScopDescription>.get", "ScopDescription.getDescription", "List<ScopDescription>.add"], "method_name": "ScopInstallation.filterByDescription", "method_implementation": "{\n    try {\n        ensureDesInstalled();\n    } catch (IOException e) {\n        throw new ScopIOException(e);\n    }\n    query = query.toLowerCase();\n    List<ScopDescription> matches = new ArrayList<ScopDescription>();\n    for (Integer i : sunidMap.keySet()) {\n        ScopDescription sc = sunidMap.get(i);\n        if (sc.getDescription().toLowerCase().startsWith(query)) {\n            matches.add(sc);\n        }\n    }\n    return matches;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#filterByDescription(java.lang.String)\n\t */\n", "repo_name": "biojava-master/", "id": 1546, "method_signature": "List<ScopDescription> filterByDescription(String)"}, "1196": {"callee_method_names": ["Chain.getAtomGroups", "List<Chain>.add", "Chain.setName", "Chain.getName", "Group.isWater", "List<Chain>.add", "Chain.setName", "Chain.getName", "Group.isWater", "Chain.addGroup", "List<Chain>.add", "List<Chain>.add", "List<List<Chain>>.add", "List<List<Chain>>.add"], "method_name": "PDBFileParser.splitNonPolyChain", "method_implementation": "{\n    List<Chain> splitNonPolys = new ArrayList<>();\n    List<Chain> waterChains = new ArrayList<>();\n    Chain split = null;\n    boolean previousGroupIsWater = false;\n    for (Group g : chain.getAtomGroups()) {\n        if (!previousGroupIsWater) {\n            // add last one if there's one\n            if (split != null) {\n                splitNonPolys.add(split);\n            }\n            split = new ChainImpl();\n            split.setName(chain.getName());\n        } else if (!g.isWater()) {\n            // previous group is water and this group is not water: we change from a water chain to a non-poly\n            // we'll need to add now the water chain to the list of water chains\n            waterChains.add(split);\n            split = new ChainImpl();\n            split.setName(chain.getName());\n        }\n        if (g.isWater()) {\n            previousGroupIsWater = true;\n        } else {\n            previousGroupIsWater = false;\n        }\n        // this should include alt locs (referenced from the main group)\n        split.addGroup(g);\n    }\n    // adding the last split chain: either to water or non-poly depending on what was the last seen group\n    if (split != null) {\n        if (previousGroupIsWater)\n            waterChains.add(split);\n        else\n            splitNonPolys.add(split);\n    }\n    List<List<Chain>> all = new ArrayList<>(2);\n    all.add(splitNonPolys);\n    all.add(waterChains);\n    return all;\n}", "repo_id": "9", "comment": "/**\n * Split the given chain (containing non-polymer groups and water groups only)\n * into individual chains per non-polymer group and individual chains per contiguous sets of water groups.\n * @param chain\n * @return a list of lists of size 2: first list is the split non-poly chains, second list is the split water chains\n */\n", "repo_name": "biojava-master/", "id": 1196, "method_signature": "List<List<Chain>> splitNonPolyChain(Chain)"}, "731": {"callee_method_names": [], "method_name": "CeCalculatorEnhanced.initIntraDistmatrix", "method_implementation": "{\n    double[][] intraDist = new double[nse][nse];\n    //\n    for (int ise1 = 0; ise1 < nse; ise1++) {\n        for (int ise2 = 0; ise2 < nse; ise2++) {\n            intraDist[ise1][ise2] = getDistanceWithSidechain(ca[ise1], ca[ise2]);\n        }\n    }\n    return intraDist;\n}", "repo_id": "9", "comment": "/**\n * build up intramolecular distance matrix dist1 & dist2\n *\n * @param ca\n * @param nse\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 731, "method_signature": "double[][] initIntraDistmatrix(Atom[], int)"}, "2576": {"callee_method_names": ["URLConnection.setReadTimeout", "URLConnection.setConnectTimeout"], "method_name": "FileDownloadUtils.prepareURLConnection", "method_implementation": "{\n    URLConnection connection = new URL(url).openConnection();\n    connection.setReadTimeout(timeout);\n    connection.setConnectTimeout(timeout);\n    return connection;\n}", "repo_id": "9", "comment": "/**\n * Prepare {@link URLConnection} with customised timeouts.\n *\n * @param url The URL\n * @param timeout The timeout in millis for both the connection timeout and\n * the response read timeout. Note that the total timeout is effectively two\n * times the given timeout.\n *\n * <p>\n * Example of code.      <code>\n * UrlConnection conn = prepareURLConnection(\"http://www.google.com/\", 20000);\n * conn.connect();\n * conn.getInputStream();\n * </code>\n * <p>\n *\n * <bold>NB. User should execute connect() method before getting input\n * stream.</bold>\n * @return\n * @throws IOException\n * @author Jacek Grzebyta\n */\n", "repo_name": "biojava-master/", "id": 2576, "method_signature": "URLConnection prepareURLConnection(String, int)"}, "1107": {"callee_method_names": ["Map<String, ChemComp>.put", "ChemComp.getId", "ChemComp.getPdbxReplaces", "Map<String, String>.put", "ChemComp.getId", "ChemComp.getPdbxReplacedBy", "Map<String, String>.put", "ChemComp.getId"], "method_name": "ChemicalComponentDictionary.addChemComp", "method_implementation": "{\n    dictionary.put(comp.getId(), comp);\n    String rep = comp.getPdbxReplaces();\n    if (rep != null && !\"?\".equals(rep)) {\n        replaces.put(comp.getId(), rep);\n    }\n    String isrep = comp.getPdbxReplacedBy();\n    if (isrep != null && !\"?\".equals(isrep)) {\n        isReplacedBy.put(comp.getId(), isrep);\n    }\n}", "repo_id": "9", "comment": "/**\n * Add a new component to the dictionary\n * @param comp\n */\n", "repo_name": "biojava-master/", "id": 1107, "method_signature": "void addChemComp(ChemComp)"}, "3302": {"callee_method_names": [], "method_name": "MySaveFileListener.setTextOutput", "method_implementation": "{\n    printText = text;\n}", "repo_id": "9", "comment": "/**\n * If true, the alignment format saved will be a text output (FASTA for\n * MultipleAlignments and FatCat for pairwise alignments)\n *\n * @param text if true the output will be text format\n */\n", "repo_name": "biojava-master/", "id": 3302, "method_signature": "void setTextOutput(boolean)"}, "377": {"callee_method_names": ["Atom.getElement"], "method_name": "Calc.centerOfMass", "method_implementation": "{\n    Atom center = new AtomImpl();\n    float totalMass = 0.0f;\n    for (Atom a : points) {\n        float mass = a.getElement().getAtomicMass();\n        totalMass += mass;\n        center = scaleAdd(mass, a, center);\n    }\n    center = scaleEquals(center, 1.0f / totalMass);\n    return center;\n}", "repo_id": "9", "comment": "/**\n * Returns the center of mass of the set of atoms. Atomic masses of the\n * Atoms are used.\n *\n * @param points\n *            a set of Atoms\n * @return an Atom representing the center of mass\n */\n", "repo_name": "biojava-master/", "id": 377, "method_signature": "Atom centerOfMass(Atom[])"}, "336": {"callee_method_names": ["BufferedReader.readLine", "String.length", "String.charAt", "String.charAt", "String.length", "String.substring", "String.length", "String.length", "String.length", "String.length", "String.charAt", "String.charAt", "String.charAt", "String.charAt", "String.charAt", "String.substring", "String.substring", "String.length"], "method_name": "OboFileParser.parseOBO", "method_implementation": "{\n    String line;\n    String currentStanza;\n    while ((line = oboFile.readLine()) != null) {\n        if (line.length() == 0)\n            continue;\n        if (line.charAt(0) == '[') {\n            if (line.charAt(line.length() - 1) != ']')\n                throw new IOException(\"Unclosed stanza: \\\"\" + line + \"\\\"\");\n            String stanzaname = line.substring(1, line.length() - 1);\n            if (stanzaname.length() < 1)\n                throw new IOException(\"Empty stanza: \\\"\" + line + \"\\\"\");\n            currentStanza = stanzaname;\n            //logger.info(\"stanza: {}\", currentStanza);\n            triggerNewStanza(currentStanza);\n        } else {\n            // a content line\n            SOPair pair;\n            pair = unescape(line, ':', 0, true);\n            //logger.info(pair);\n            String name = pair.str;\n            int lineEnd = findUnescaped(line, '!', 0, line.length(), true);\n            if (lineEnd == -1)\n                lineEnd = line.length();\n            // find nested values\n            NestedValue nv = null;\n            int trailingStartIndex = -1;\n            int trailingEndIndex = -1;\n            for (int i = lineEnd - 1; i >= 0; i--) {\n                if (Character.isWhitespace(line.charAt(i))) {\n                    // keep going until we see non-whitespace\n                } else if (line.charAt(i) == '}') {\n                    // if the first thing we see is a closing brace,\n                    // we have a trailing modifier\n                    if (i >= 1 && line.charAt(i - 1) == '\\\\')\n                        continue;\n                    trailingEndIndex = i;\n                    break;\n                } else\n                    break;\n            }\n            if (trailingEndIndex != -1) {\n                for (int i = trailingEndIndex - 1; i >= 0; i--) {\n                    if (line.charAt(i) == '{') {\n                        if (i >= 1 && line.charAt(i - 1) == '\\\\')\n                            continue;\n                        trailingStartIndex = i + 1;\n                    }\n                }\n            }\n            int valueStopIndex;\n            if (trailingStartIndex == -1 && trailingEndIndex != -1)\n                throw new IOException(\"Unterminated trailing modifier. \" + line);\n            else if (trailingStartIndex != -1) {\n                valueStopIndex = trailingStartIndex - 1;\n                String trailing = line.substring(trailingStartIndex, trailingEndIndex).trim();\n                nv = new NestedValue();\n                getNestedValue(nv, trailing, 0);\n            } else\n                valueStopIndex = lineEnd;\n            String value = line.substring(pair.index + 1, valueStopIndex).trim();\n            /*\n\t\t\t\t * if (nv != null) logger.warn(\"nv = \"+nv+\", value =\n\t\t\t\t * |\"+value+\"|\");\n\t\t\t\t */\n            if (value.length() == 0)\n                throw new IOException(\"Tag found with no value \" + line);\n            if (isSynonym(name)) {\n                Synonym synonym = parseSynonym(name, value);\n                triggerNewSynonym(synonym);\n            } else {\n                //logger.info(\"new key:\" + name + \" \" + value);\n                triggerNewKey(name, value);\n            }\n            //logger.info(\"parsed key: \" + name +\" value: \" + value + \" nv: \" + nv);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * parse an ontology file\n *\n * @param oboFile\n * @throws IOException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 336, "method_signature": "void parseOBO(BufferedReader)"}, "1100": {"callee_method_names": ["Logger.debug", "File.toString", "Logger.error", "Logger.debug", "URLConnection.getInputStream", "PrintWriter.println", "URL.toString", "PrintWriter.flush", "File.toPath", "Logger.error", "int.getMessage", "File.delete"], "method_name": "DownloadChemCompProvider.downloadChemCompRecord", "method_implementation": "{\n    String localName = getLocalFileName(recordName);\n    File newFile;\n    try {\n        newFile = Files.createTempFile(\"chemcomp\" + recordName, \"cif\").toFile();\n        logger.debug(\"Will write chem comp file to temp file {}\", newFile.toString());\n    } catch (IOException e) {\n        logger.error(\"Could not write to temp directory {} to create the chemical component download temp file\", System.getProperty(\"java.io.tmpdir\"));\n        return false;\n    }\n    String u = serverBaseUrl + expandPathUrlTemplate(chemCompPathUrlTemplate, recordName);\n    logger.debug(\"Downloading chem comp definition from {}\", u);\n    URL url = null;\n    try {\n        url = new URL(u);\n        URLConnection uconn = URLConnectionTools.openURLConnection(url);\n        try (PrintWriter pw = new PrintWriter(new GZIPOutputStream(new FileOutputStream(newFile)));\n            BufferedReader fileBuffer = new BufferedReader(new InputStreamReader(uconn.getInputStream()))) {\n            String line;\n            boolean success = false;\n            while ((line = fileBuffer.readLine()) != null) {\n                pw.println(line);\n                success = true;\n            }\n            if (!success) {\n                throw new IOException(\"Malformed URL or no content found in \" + url.toString());\n            }\n            pw.flush();\n        }\n        // Now we move this across to where it actually wants to be\n        Files.move(newFile.toPath(), Paths.get(localName), StandardCopyOption.REPLACE_EXISTING);\n        return true;\n    } catch (IOException e) {\n        logger.error(\"Could not download {} OR store locally to {} Error ={}\", url, localName, e.getMessage());\n        newFile.delete();\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * @param recordName : three-letter name\n * @return true if successful download\n */\n", "repo_name": "biojava-master/", "id": 1100, "method_signature": "boolean downloadChemCompRecord(String)"}, "558": {"callee_method_names": ["Atom.getX", "Atom.getY", "Atom.getZ"], "method_name": "RotationAxis.getAxisAngle4d", "method_implementation": "{\n    return new AxisAngle4d(rotationAxis.getX(), rotationAxis.getY(), rotationAxis.getZ(), theta);\n}", "repo_id": "9", "comment": "/**\n * Returns the rotation axis and angle in a single javax.vecmath.AxisAngle4d object\n * @return\n */\n", "repo_name": "biojava-master/", "id": 558, "method_signature": "AxisAngle4d getAxisAngle4d()"}, "3561": {"callee_method_names": [], "method_name": "CoxVariables.getCoxInfoHashMap", "method_implementation": "{\n    return coxInfoHashMap;\n}", "repo_id": "9", "comment": "/**\n * @return the coxInfoHashMap\n */\n", "repo_name": "biojava-master/", "id": 3561, "method_signature": "LinkedHashMap<String,CoxInfo> getCoxInfoHashMap()"}, "1741": {"callee_method_names": ["String.length", "String.charAt"], "method_name": "BasePairParameters.complement", "method_implementation": "{\n    String result = \"\";\n    for (int i = sequence.length() - 1; i >= 0; i--) {\n        result += complementBase(sequence.charAt(i), RNA);\n    }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * Simple helper method for quickly checking the complement of a sequence, see also DNASequence nad RNASequence classes\n * for more extensively useful functions not used in this narrow context of structural biology of base pairs.  (Used internally)\n */\n", "repo_name": "biojava-master/", "id": 1741, "method_signature": "String complement(String, boolean)"}, "2951": {"callee_method_names": [], "method_name": "SequenceProxyView.getBioStart", "method_implementation": "{\n    return bioStart;\n}", "repo_id": "9", "comment": "/**\n * @return the bioStart\n */\n", "repo_name": "biojava-master/", "id": 2951, "method_signature": "Integer getBioStart()"}, "823": {"callee_method_names": [], "method_name": "AlternativeAlignment.count_gaps", "method_implementation": "{\n    int i0 = i1[0];\n    int j0 = i2[0];\n    int gaps = 0;\n    for (int i = 1; i < i1.length; i++) {\n        if (Math.abs(i1[i] - i0) != 1 || (Math.abs(i2[i] - j0) != 1)) {\n            gaps += 1;\n        }\n        i0 = i1[i];\n        j0 = i2[i];\n    }\n    return gaps;\n}", "repo_id": "9", "comment": "/**\n * Count the number of gaps in an alignment represented by idx1,idx2.\n *\n * @param i1\n * @param i2\n * @return the number of gaps in this alignment\n */\n", "repo_name": "biojava-master/", "id": 823, "method_signature": "int count_gaps(int[], int[])"}, "3173": {"callee_method_ids": [2637, 2686], "callee_method_names": ["DNASequence.getRNASequence", "RNASequence.getProteinSequence", "ProteinSequence.setAccession"], "method_name": "TranscriptSequence.getProteinSequence", "method_implementation": "{\n    DNASequence dnaCodingSequence = getDNACodingSequence();\n    RNASequence rnaCodingSequence = dnaCodingSequence.getRNASequence(engine);\n    ProteinSequence proteinSequence = rnaCodingSequence.getProteinSequence(engine);\n    proteinSequence.setAccession(new AccessionID(this.getAccession().getID()));\n    return proteinSequence;\n}", "repo_id": "9", "comment": "/**\n * Get the protein sequence with user defined TranscriptEngine\n * @param engine\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3173, "method_signature": "ProteinSequence getProteinSequence(TranscriptionEngine)"}, "3631": {"callee_method_names": [], "method_name": "CoxInfo.getScoreLogrankTest", "method_implementation": "{\n    return scoreLogrankTest;\n}", "repo_id": "9", "comment": "/**\n * @return the scoreLogrankTest\n */\n", "repo_name": "biojava-master/", "id": 3631, "method_signature": "Double getScoreLogrankTest()"}, "3770": {"callee_method_ids": [3756, 3738, 3738, 3741], "callee_method_names": ["WorkSheet.getRows", "WorkSheet.isValidColumn", "WorkSheet.isValidColumn", "WorkSheet.getCell"], "method_name": "WorkSheet.appendWorkSheetRows", "method_implementation": "{\n    ArrayList<String> newRows = worksheet.getRows();\n    this.addRows(newRows, \"\");\n    for (String col : this.getColumns()) {\n        if (!worksheet.isValidColumn(col)) {\n            continue;\n        }\n        for (String row : newRows) {\n            if (worksheet.isValidColumn(col)) {\n                String value = worksheet.getCell(row, col);\n                this.addCell(row, col, value);\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Add rows from a second worksheet to be joined by common column. If the\n * appended worksheet doesn't contain a column in the master worksheet then\n * default value of \"\" is used. Columns in the appended worksheet not found\n * in the master worksheet are not added.\n *\n * @param worksheet\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3770, "method_signature": "void appendWorkSheetRows(WorkSheet)"}, "1264": {"callee_method_names": ["AminoAcid.setAminoType", "ChemComp.setOneLetterCode", "ChemComp.setType", "String.toUpperCase", "ChemComp.setResidueType", "ChemComp.setPolymerType", "Group.setChemComp", "Group.setPDBName", "Group.setResidueNumber", "Chain.getName", "Group.setResidueNumber", "Chain.getName", "Group.setAtoms", "Chain.addGroup"], "method_name": "MmtfStructureReader.setGroupInfo", "method_implementation": "{\n    // Get the polymer type\n    ResidueType residueType = ResidueType.getResidueTypeFromString(chemCompType);\n    if (residueType == null)\n        throw new IllegalStateException(\"Couldn't resolve residue type for \" + chemCompType);\n    int polymerType = getGroupTypIndicator(residueType.polymerType);\n    switch(polymerType) {\n        case 1:\n            AminoAcid aa = new AminoAcidImpl();\n            // Now set the one letter code\n            aa.setAminoType(singleLetterCode);\n            group = aa;\n            break;\n        case 2:\n            group = new NucleotideImpl();\n            break;\n        default:\n            group = new HetatomImpl();\n            break;\n    }\n    atomsInGroup = new ArrayList<>();\n    ChemComp chemComp = new ChemComp();\n    chemComp.setOneLetterCode(String.valueOf(singleLetterCode));\n    chemComp.setType(chemCompType.toUpperCase());\n    chemComp.setResidueType(residueType);\n    chemComp.setPolymerType(residueType.polymerType);\n    group.setChemComp(chemComp);\n    group.setPDBName(groupName);\n    if (insertionCode == MmtfStructure.UNAVAILABLE_CHAR_VALUE) {\n        group.setResidueNumber(chain.getName().trim(), groupNumber, null);\n    } else {\n        group.setResidueNumber(chain.getName().trim(), groupNumber, insertionCode);\n    }\n    group.setAtoms(new ArrayList<>(atomCount));\n    if (polymerType == 1 || polymerType == 2) {\n        MmtfUtils.insertSeqResGroup(chain, group, sequenceIndexId);\n    }\n    if (atomCount > 0) {\n        chain.addGroup(group);\n    }\n    MmtfUtils.setSecStructType(group, secStructType);\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.rcsb.mmtf.decoder.StructureDecoderInterface\n\t * #setGroupInfo(java.lang.String, int, char, int, int)\n\t */\n", "repo_name": "biojava-master/", "id": 1264, "method_signature": "void setGroupInfo(String, int, char, String, int, int, char, int, int)"}, "391": {"callee_method_names": ["Matrix.getColumnPackedCopy", "Atom.getCoordsAsPoint3d"], "method_name": "Calc.getTransformation", "method_implementation": "{\n    return new Matrix4d(new Matrix3d(rot.getColumnPackedCopy()), new Vector3d(trans.getCoordsAsPoint3d()), 1.0);\n}", "repo_id": "9", "comment": "/**\n * Convert JAMA rotation and translation to a Vecmath transformation matrix.\n * Because the JAMA matrix is a pre-multiplication matrix and the Vecmath\n * matrix is a post-multiplication one, the rotation matrix is transposed to\n * ensure that the transformation they produce is the same.\n *\n * @param rot\n *            3x3 Rotation matrix\n * @param trans\n *            3x1 translation vector in Atom coordinates\n * @return 4x4 transformation matrix\n */\n", "repo_name": "biojava-master/", "id": 391, "method_signature": "Matrix4d getTransformation(Matrix, Atom)"}, "1740": {"callee_method_names": [], "method_name": "BasePairParameters.complementBase", "method_implementation": "{\n    if (base == 'A' && RNA)\n        return 'U';\n    if (base == 'A')\n        return 'T';\n    if (base == 'T' && !RNA)\n        return 'A';\n    if (base == 'U' && RNA)\n        return 'A';\n    if (base == 'C')\n        return 'G';\n    if (base == 'G')\n        return 'C';\n    return ' ';\n}", "repo_id": "9", "comment": "/**\n * This method returns the complement of a base. (used internally)\n * @param base The letter of the base\n * @param RNA Whether it is RNA (if false, it is DNA)\n * @return The character representing the complement of the base\n */\n", "repo_name": "biojava-master/", "id": 1740, "method_signature": "char complementBase(char, boolean)"}, "898": {"callee_method_names": ["HashMap<Pair<AtomIdentifier>, AtomContact>.get", "Atom.getPDBserial", "Atom.getGroup", "Atom.getPDBserial", "Atom.getGroup"], "method_name": "AtomContactSet.getContact", "method_implementation": "{\n    return contacts.get(new Pair<AtomIdentifier>(new AtomIdentifier(atom1.getPDBserial(), atom1.getGroup().getChainId()), new AtomIdentifier(atom2.getPDBserial(), atom2.getGroup().getChainId())));\n}", "repo_id": "9", "comment": "/**\n * Returns the corresponding AtomContact or null if no contact exists between the 2 given atoms\n * @param atom1\n * @param atom2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 898, "method_signature": "AtomContact getContact(Atom, Atom)"}, "3161": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.getAccession", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported yet.\");\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3161, "method_signature": "AccessionID getAccession()"}, "2201": {"callee_method_ids": [619, 1004, 1002, 1002, 1002], "callee_method_names": ["AtomCache.getAtoms", "AtomPositionMap.getNavMap", "NavigableMap<ResidueNumber, Integer>.keySet", "AtomPositionMap.getPosition", "NavigableMap<ResidueNumber, Integer>.get", "AtomPositionMap.getLength", "AtomPositionMap.getLength", "AtomPositionMap.getLength"], "method_name": "AtomPositionMapTest.testInsertionCodes", "method_implementation": "{\n    String pdbId = \"1qdm\";\n    // has 2 insertion code regions, lettered P and S, as well as disordered regions:\n    // 6P-26P,2-163,169-247,1S-37S,65S-104S,248-338\n    // Len:21,  162,     79,    37,      40,     91 = 430\n    AtomPositionMap map = new AtomPositionMap(cache.getAtoms(pdbId));\n    NavigableMap<ResidueNumber, Integer> navMap = map.getNavMap();\n    for (ResidueNumber n : navMap.keySet()) {\n        assertEquals(\"An element is missing\", map.getPosition(n).intValue(), navMap.get(n).intValue());\n    }\n    // 2+37+21\n    int length1 = 60;\n    // 2+37+40+53\n    int length2 = 132;\n    ResidueNumber start = new ResidueNumber(\"A\", 246, null);\n    ResidueNumber mid = new ResidueNumber(\"A\", 85, 'S');\n    ResidueNumber end = new ResidueNumber(\"A\", 300, null);\n    int realLength1 = map.getLength(start, mid);\n    assertEquals(\"Real atom length is wrong\", length1, realLength1);\n    int realLength2 = map.getLength(start, end);\n    assertEquals(\"Real atom length is wrong\", length2, realLength2);\n    int realLength = map.getLength(new ResidueNumber(\"A\", 6, 'P'), new ResidueNumber(\"A\", 338, null));\n    assertEquals(\"Full length wrong\", 430, realLength);\n}", "repo_id": "9", "comment": "/**\n * Tests with insertion codes.\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2201, "method_signature": "void testInsertionCodes()"}, "1823": {"callee_method_names": [], "method_name": "EcodParser.getVersion", "method_implementation": "{\n    return version;\n}", "repo_id": "9", "comment": "/**\n * @return the requestedVersion for this file, or null if none was parsed\n */\n", "repo_name": "biojava-master/", "id": 1823, "method_signature": "String getVersion()"}, "429": {"callee_method_names": [], "method_name": "FatCatParameters.getRmsdCut", "method_implementation": "{\n    return rmsdCut;\n}", "repo_id": "9", "comment": "/**\n * The cutoff to be used during AFP detection\n *\n * @return rmsdCut parameter\n */\n", "repo_name": "biojava-master/", "id": 429, "method_signature": "Double getRmsdCut()"}, "1103": {"callee_method_ids": [1106], "callee_method_names": ["ChemComp.getResidueType", "ChemComp.isStandard", "ChemComp.getOneLetterCode", "ChemicalComponentDictionary.getParent", "ChemComp.getOneLetterCode", "ChemComp.getPolymerType", "ChemComp.getId", "ChemComp.getId", "ChemComp.getMonNstdParentCompId"], "method_name": "ChemCompTools.getOneLetterCode", "method_implementation": "{\n    if (cc.getResidueType() == ResidueType.nonPolymer) {\n        return null;\n    }\n    if (cc.isStandard()) {\n        return cc.getOneLetterCode().charAt(0);\n    }\n    ChemComp parent = dictionary.getParent(cc);\n    if (parent == null) {\n        //System.err.println(\"parent is null \" + cc);\n        return cc.getOneLetterCode().charAt(0);\n    }\n    PolymerType poly = cc.getPolymerType();\n    if (poly == PolymerType.peptide || poly == PolymerType.dpeptide) {\n        Character c = getAminoOneLetter(parent.getId());\n        if (c == null) {\n            c = UNKNOWN_ONE_LETTER_CODE;\n        }\n        return c;\n    }\n    if (poly == PolymerType.dna) {\n        Character c = getDNAOneLetter(parent.getId());\n        if (c == null) {\n            c = UNKNOWN_NUCLEOTIDE;\n        }\n        return c;\n    }\n    return cc.getMonNstdParentCompId().charAt(0);\n}", "repo_id": "9", "comment": "// so does: 4F3,5ZA and others\n", "repo_name": "biojava-master/", "id": 1103, "method_signature": "Character getOneLetterCode(ChemComp, ChemicalComponentDictionary)"}, "2921": {"callee_method_names": [], "method_name": "AbstractSequence.getReferences", "method_implementation": "{\n    return references;\n}", "repo_id": "9", "comment": "/**\n * @since 5.0.0\n * @return the list of {@link AbstractReference}\n */\n", "repo_name": "biojava-master/", "id": 2921, "method_signature": "List<AbstractReference> getReferences()"}, "3451": {"callee_method_names": ["HashMap.put"], "method_name": "NCBIQBlastOutputProperties.setOutputOption", "method_implementation": "{\n    param.put(key, value);\n}", "repo_id": "9", "comment": "/**\n * Sets the value of specified output parameter\n */\n", "repo_name": "biojava-master/", "id": 3451, "method_signature": "void setOutputOption(BlastOutputParameterEnum, String)"}, "925": {"callee_method_names": ["ArrayList<Integer>.size", "ArrayList<Integer>.size"], "method_name": "GridCell.toString", "method_implementation": "{\n    return String.format(\"GridCell [%d iAtoms,%d jAtoms]\", iIndices.size(), jIndices == null ? \"-\" : jIndices.size());\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#toString()\n\t */\n", "repo_name": "biojava-master/", "id": 925, "method_signature": "String toString()"}, "948": {"callee_method_names": [], "method_name": "OrderedPair.setElement1", "method_implementation": "{\n    this.element1 = element1;\n}", "repo_id": "9", "comment": "/**\n * Sets the first element of an ordered pair.\n *\n * @param element1 the first element of an ordered pair\n */\n", "repo_name": "biojava-master/", "id": 948, "method_signature": "void setElement1(T)"}, "2264": {"callee_method_names": [], "method_name": "TestBondFinding.testInterGroupBonds", "method_implementation": "{\n    // Normal\n    assertEquals(2236, getInterBonds(\"1QMZ\"));\n    // \tDisulphide\n    assertEquals(956, getInterBonds(\"2QWO\"));\n    // Covalent ligand\n    assertEquals(2294, getInterBonds(\"4QDV\"));\n    // DNA\n    assertEquals(22, getInterBonds(\"4XSN\"));\n}", "repo_id": "9", "comment": "/**\n * Test that the bonds we are finding are consistent.\n *\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2264, "method_signature": "void testInterGroupBonds()"}, "1394": {"callee_method_names": [], "method_name": "DBRef.getSeqEnd", "method_implementation": "{\n    return seqEnd;\n}", "repo_id": "9", "comment": "/**\n * Ending sequence number   of the PDB sequence segment.\n *\n *  @return sequence end position\n *  @see #getSeqEnd()\n */\n", "repo_name": "biojava-master/", "id": 1394, "method_signature": "int getSeqEnd()"}, "3395": {"callee_method_names": ["RotationGroup.getPointGroup", "StringBuilder.append", "StringBuilder.append", "RotationGroup.getPointGroup", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Polyhedron.getViewName", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "Polyhedron.getViewName", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.playOrientations", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    // draw point group\n    if (\"C1\".equals(rotationGroup.getPointGroup())) {\n        s.append(drawFooter(\"Asymmetric\", \"white\"));\n    } else {\n        s.append(drawFooter(\"Point group \" + rotationGroup.getPointGroup(), \"white\"));\n    }\n    // draw polygon\n    // draw invisibly\n    s.append(drawPolyhedron());\n    s.append(showPolyhedron());\n    // draw axes\n    s.append(drawAxes());\n    s.append(showAxes());\n    // loop over all orientations with 4 sec. delay\n    for (int i = 0; i < getOrientationCount(); i++) {\n        s.append(deleteHeader());\n        s.append(getOrientationWithZoom(i));\n        s.append(drawHeader(polyhedron.getViewName(i), \"white\"));\n        s.append(\"delay 4;\");\n    }\n    // go back to first orientation\n    s.append(deleteHeader());\n    s.append(getOrientationWithZoom(0));\n    s.append(drawHeader(polyhedron.getViewName(0), \"white\"));\n    return s.toString();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#playOrientations()\n\t */\n", "repo_name": "biojava-master/", "id": 3395, "method_signature": "String playOrientations()"}, "3169": {"callee_method_ids": [3056, 3056, 3056], "callee_method_names": ["LinkedHashMap.containsKey", "AccessionID.getID", "AccessionID.getID", "CDSSequence.setAccession", "ArrayList.add", "LinkedHashMap.put", "AccessionID.getID"], "method_name": "TranscriptSequence.addCDS", "method_implementation": "{\n    if (cdsSequenceHashMap.containsKey(accession.getID())) {\n        throw new Exception(\"Duplicate accession id \" + accession.getID());\n    }\n    //sense should be the same as parent\n    CDSSequence cdsSequence = new CDSSequence(this, begin, end, phase);\n    cdsSequence.setAccession(accession);\n    cdsSequenceList.add(cdsSequence);\n    Collections.sort(cdsSequenceList, new CDSComparator());\n    cdsSequenceHashMap.put(accession.getID(), cdsSequence);\n    return cdsSequence;\n}", "repo_id": "9", "comment": "/**\n * Add a Coding Sequence region with phase to the transcript sequence\n * @param accession\n * @param begin\n * @param end\n * @param phase 0,1,2\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3169, "method_signature": "CDSSequence addCDS(AccessionID, int, int, int)"}, "1909": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.getHelixRmsdToRiseRatio", "method_implementation": "{\n    return helixRmsdToRiseRatio;\n}", "repo_id": "9", "comment": "/**\n * @return the helixRmsdToRiseRatio\n */\n", "repo_name": "biojava-master/", "id": 1909, "method_signature": "double getHelixRmsdToRiseRatio()"}, "1617": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setMinimumSequenceLength", "method_implementation": "{\n    this.minimumSequenceLength = minimumSequenceLength;\n}", "repo_id": "9", "comment": "/**\n * Set the minimum number of residues of a subunits to be considered in the\n * clusters.\n *\n * @param minimumSequenceLength\n */\n", "repo_name": "biojava-master/", "id": 1617, "method_signature": "void setMinimumSequenceLength(int)"}, "603": {"callee_method_ids": [487], "callee_method_names": ["AFPChain.getBlockRotationMatrix", "AFPChain.setBlockRotationMatrix", "AFPChain.setBlockShiftVector", "AFPChain.getAlgorithmName", "AFPChain.getAlgorithmName", "AFPChain.getGroup", "AFPChain.getBlockRotationMatrix", "AFPChain.getBlockShiftVector", "AFPChain.getBlockNum", "List<Group>.size", "AFPChain.getBlockRotationMatrix", "AFPChain.getBlockRotationMatrix", "AFPChain.getBlockShiftVector"], "method_name": "AlignmentTools.prepareGroupsForDisplay", "method_implementation": "{\n    if (afpChain.getBlockRotationMatrix().length == 0) {\n        // probably the alignment is too short!\n        System.err.println(\"No rotation matrix found to rotate 2nd structure!\");\n        afpChain.setBlockRotationMatrix(new Matrix[] { Matrix.identity(3, 3) });\n        afpChain.setBlockShiftVector(new Atom[] { new AtomImpl() });\n    }\n    // List of groups to be rotated according to the alignment\n    Group[] twistedGroups = new Group[ca2.length];\n    //int blockNum = afpChain.getBlockNum();\n    int i = -1;\n    // List of groups from the structure not included in ca2 (e.g. ligands)\n    // Will be rotated according to first block\n    List<Group> hetatms2 = StructureTools.getUnalignedGroups(ca2);\n    if ((afpChain.getAlgorithmName().equals(FatCatRigid.algorithmName)) || (afpChain.getAlgorithmName().equals(FatCatFlexible.algorithmName))) {\n        for (Atom a : ca2) {\n            i++;\n            twistedGroups[i] = a.getGroup();\n        }\n        twistedGroups = AFPTwister.twistOptimized(afpChain, ca1, ca2);\n        //} else  if  (( blockNum == 1 ) || (afpChain.getAlgorithmName().equals(CeCPMain.algorithmName))) {\n    } else {\n        Matrix m = afpChain.getBlockRotationMatrix()[0];\n        Atom shift = afpChain.getBlockShiftVector()[0];\n        shiftCA2(afpChain, ca2, m, shift, twistedGroups);\n    }\n    if (afpChain.getBlockNum() > 0) {\n        // Superimpose ligands relative to the first block\n        if (hetatms2.size() > 0) {\n            if (afpChain.getBlockRotationMatrix().length > 0) {\n                Matrix m1 = afpChain.getBlockRotationMatrix()[0];\n                //m1.print(3,3);\n                Atom vector1 = afpChain.getBlockShiftVector()[0];\n                //System.out.println(\"shift vector:\" + vector1);\n                for (Group g : hetatms2) {\n                    Calc.rotate(g, m1);\n                    Calc.shift(g, vector1);\n                }\n            }\n        }\n    }\n    return twistedGroups;\n}", "repo_id": "9", "comment": "/**\n * Rotate the Atoms/Groups so they are aligned for the 3D visualisation\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @return an array of Groups that are transformed for 3D display\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 603, "method_signature": "Group[] prepareGroupsForDisplay(AFPChain, Atom[], Atom[])"}, "1906": {"callee_method_names": ["DistanceBox<Integer>.getNeighborsWithCache", "Integer.distanceSquared", "List<Integer>.add", "List<Integer>.size", "List<Integer>.clear", "Set<Integer>.size", "List<Integer>.clear"], "method_name": "RotationSolver.getPermutation", "method_implementation": "{\n    List<Integer> permutation = new ArrayList<Integer>(transformedCoords.length);\n    double sum = 0.0f;\n    for (Point3d t : transformedCoords) {\n        List<Integer> neighbors = box.getNeighborsWithCache(t);\n        int closest = -1;\n        double minDist = Double.MAX_VALUE;\n        for (int j : neighbors) {\n            double dist = t.distanceSquared(originalCoords[j]);\n            if (dist < minDist) {\n                closest = j;\n                minDist = dist;\n            }\n        }\n        sum += minDist;\n        if (closest == -1) {\n            break;\n        }\n        permutation.add(closest);\n    }\n    double rmsd = Math.sqrt(sum / transformedCoords.length);\n    if (rmsd > distanceThreshold || permutation.size() != transformedCoords.length) {\n        permutation.clear();\n        return permutation;\n    }\n    // check uniqueness of indices\n    Set<Integer> set = new HashSet<Integer>(permutation);\n    // if size mismatch, clear permutation (its invalid)\n    if (set.size() != originalCoords.length) {\n        permutation.clear();\n    }\n    return permutation;\n}", "repo_id": "9", "comment": "/**\n * Compare this.transformedCoords with the original coords. For each\n * subunit, return the transformed subunit with the closest position.\n * @return A list mapping each subunit to the closest transformed subunit\n */\n", "repo_name": "biojava-master/", "id": 1906, "method_signature": "List<Integer> getPermutation()"}, "3613": {"callee_method_ids": [3643], "callee_method_names": ["LinkedHashMap.keySet", "SurvivalInfo.setResidualVariable"], "method_name": "CoxInfo.setVariableResiduals", "method_implementation": "{\n    ArrayList<String> variables = new ArrayList<String>(coefficientsList.keySet());\n    int p = 0;\n    for (SurvivalInfo si : this.survivalInfoList) {\n        int i = 0;\n        for (String v : variables) {\n            si.setResidualVariable(v, rr[p][i]);\n            i++;\n        }\n        p++;\n    }\n}", "repo_id": "9", "comment": "/**\n * @param rr\n */\n", "repo_name": "biojava-master/", "id": 3613, "method_signature": "void setVariableResiduals(double[][])"}, "3091": {"callee_method_names": [], "method_name": "AbstractFeature.setShortDescription", "method_implementation": "{\n    this.shortDescription = shortDescription;\n}", "repo_id": "9", "comment": "/**\n * @param shortDescription the shortDescription to set\n */\n", "repo_name": "biojava-master/", "id": 3091, "method_signature": "void setShortDescription(String)"}, "1334": {"callee_method_names": ["StringWriter.append", "StringWriter.append", "StringWriter.toString"], "method_name": "ResidueNumber.toString", "method_implementation": "{\n    StringWriter writer = new StringWriter();\n    //\t   if ( chainName != null){\n    //\t\t   writer.append(chainName);\n    //\t\t   writer.append(\":\");\n    //\t   }\n    writer.append(String.valueOf(seqNum));\n    if (insCode != null && (insCode != ' '))\n        writer.append(insCode);\n    return writer.toString();\n}", "repo_id": "9", "comment": "/**\n * @return The residue number and insertion code as a string, eg \"74A\"\n * @see java.lang.Object#toString()\n */\n", "repo_name": "biojava-master/", "id": 1334, "method_signature": "String toString()"}, "157": {"callee_method_ids": [641], "callee_method_names": ["AtomCache.setFiletype", "List<Structure>.size", "List<Structure>.size", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "List<Structure>.get", "char.getId", "char.getName", "char.getId", "char.getName", "List<Structure>.get", "char.getId", "char.getName", "char.getId", "char.getName"], "method_name": "TestBioassemblies.test4OPJ", "method_implementation": "{\n    AtomCache prevAtomCache = StructureIO.getAtomCache();\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    StructureIO.setAtomCache(cache);\n    List<Structure> multiModelBioAssemblies = StructureIO.getBiologicalAssemblies(\"4OPJ\", true);\n    List<Structure> flattenedBioAssemblies = StructureIO.getBiologicalAssemblies(\"4OPJ\", false);\n    // 2 bioassemblies in this case\n    assertEquals(2, multiModelBioAssemblies.size());\n    assertEquals(2, flattenedBioAssemblies.size());\n    // checking number of models: 2 operators in each assembly\n    assertEquals(2, multiModelBioAssemblies.get(0).nrModels());\n    assertEquals(1, flattenedBioAssemblies.get(0).nrModels());\n    assertEquals(2, multiModelBioAssemblies.get(1).nrModels());\n    assertEquals(1, flattenedBioAssemblies.get(1).nrModels());\n    // for multimodel bioassembly, we should have 2 models corresponding to 2 operators\n    assertEquals(2, multiModelBioAssemblies.get(0).nrModels());\n    // for flattened bioassembly we should have only 1 model\n    assertEquals(1, flattenedBioAssemblies.get(0).nrModels());\n    // 3 chains divided into 2 models in bioassembly 1\n    assertEquals(3, multiModelBioAssemblies.get(0).getPolyChains(0).size() + multiModelBioAssemblies.get(0).getPolyChains(1).size());\n    // 3 chains in flattened structure in bioassembly 1\n    assertEquals(3, flattenedBioAssemblies.get(0).getPolyChains().size());\n    // 3 chains divided into 2 models in bioassembly 2\n    assertEquals(3, multiModelBioAssemblies.get(1).getPolyChains(0).size() + multiModelBioAssemblies.get(1).getPolyChains(1).size());\n    // 3 chains in flattened structure in bioassembly 2\n    assertEquals(3, flattenedBioAssemblies.get(1).getPolyChains().size());\n    // chain ids and names don't contain underscores in multimodel\n    for (int modelIdx = 0; modelIdx < multiModelBioAssemblies.get(0).nrModels(); modelIdx++) {\n        List<Chain> model = multiModelBioAssemblies.get(0).getModel(modelIdx);\n        for (Chain c : model) {\n            System.out.println(c.getId() + \" \" + c.getName());\n            assertTrue(!c.getId().contains(\"_\"));\n            assertTrue(!c.getName().contains(\"_\"));\n        }\n    }\n    // chain ids and names contain underscores in flattened\n    for (Chain c : flattenedBioAssemblies.get(0).getChains()) {\n        System.out.println(c.getId() + \" \" + c.getName());\n        assertTrue(c.getId().contains(\"_\"));\n        assertTrue(c.getName().contains(\"_\"));\n    }\n    StructureIO.setAtomCache(prevAtomCache);\n}", "repo_id": "9", "comment": "/**\n * A difficult case: see http://www.mail-archive.com/jmol-users@lists.sourceforge.net/msg25927.html\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 157, "method_signature": "void test4OPJ()"}, "2658": {"callee_method_names": [], "method_name": "Builder.build", "method_implementation": "{\n    return new TranscriptionEngine(getTable(), getRnaAminoAcidTranslator(), getDnaRnaTranslator(), getProteinCreator(), getRnaCreator(), getDnaCompounds(), getRnaCompounds(), getAminoAcidCompounds());\n}", "repo_id": "9", "comment": "/**\n * The method to finish any calls to the builder with which returns a\n * transcription engine. The engine is designed to provide everything\n * required for transcription to those classes which will do the\n * transcription.\n */\n", "repo_name": "biojava-master/", "id": 2658, "method_signature": "TranscriptionEngine build()"}, "767": {"callee_method_names": [], "method_name": "StartupParameters.setPrintCE", "method_implementation": "{\n    this.printCE = printCE;\n}", "repo_id": "9", "comment": "/**\n * Display the output string in CE style\n *\n * @param printCE a flag\n */\n", "repo_name": "biojava-master/", "id": 767, "method_signature": "void setPrintCE(boolean)"}, "2001": {"callee_method_names": [], "method_name": "Octahedron.setCirumscribedRadius", "method_implementation": "{\n    this.cirumscribedRadius = cirumscribedRadius;\n}", "repo_id": "9", "comment": "/**\n * Set the radius of a circumscribed sphere, that goes\n * through all vertices\n * @param cirumscribedRadius the cirumscribedRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2001, "method_signature": "void setCirumscribedRadius(double)"}, "869": {"callee_method_names": [], "method_name": "SparseSquareMatrix.plus", "method_implementation": "{\n    SparseSquareMatrix A = this;\n    if (A.N != B.N)\n        throw new IllegalArgumentException(\"Dimensions disagree. \" + A.N + \" != \" + B.N);\n    SparseSquareMatrix C = new SparseSquareMatrix(N);\n    for (int i = 0; i < N; i++) C.rows[i] = A.rows[i].plus(B.rows[i]);\n    return C;\n}", "repo_id": "9", "comment": "/**\n * return C = A + B\n *\n * @param B\n * @return\n */\n", "repo_name": "biojava-master/", "id": 869, "method_signature": "SparseSquareMatrix plus(SparseSquareMatrix)"}, "1517": {"callee_method_names": ["Matrix.eig", "EigenvalueDecomposition.getV", "Quat4d.normalize", "Quat4d.conjugate"], "method_name": "UnitQuaternions.relativeOrientation", "method_implementation": "{\n    // inverse\n    Matrix m = CalcPoint.formMatrix(moved, fixed);\n    EigenvalueDecomposition eig = m.eig();\n    double[][] v = eig.getV().getArray();\n    Quat4d q = new Quat4d(v[1][3], v[2][3], v[3][3], v[0][3]);\n    q.normalize();\n    q.conjugate();\n    return q;\n}", "repo_id": "9", "comment": "/**\n * Calculate the relative quaternion orientation of two arrays of points.\n *\n * @param fixed\n *            point array, coordinates will not be modified\n * @param moved\n *            point array, coordinates will not be modified\n * @return a unit quaternion representing the relative orientation, to\n *         rotate moved to bring it to the same orientation as fixed.\n */\n", "repo_name": "biojava-master/", "id": 1517, "method_signature": "Quat4d relativeOrientation(Point3d[], Point3d[])"}, "949": {"callee_method_names": [], "method_name": "OrderedPair.getElement2", "method_implementation": "{\n    return element2;\n}", "repo_id": "9", "comment": "/**\n * @return element2 the second element of an ordered pair\n */\n", "repo_name": "biojava-master/", "id": 949, "method_signature": "T getElement2()"}, "2908": {"callee_method_names": [], "method_name": "AbstractSequence.getDescription", "method_implementation": "{\n    return description;\n}", "repo_id": "9", "comment": "/**\n * @return the description\n */\n", "repo_name": "biojava-master/", "id": 2908, "method_signature": "String getDescription()"}, "825": {"callee_method_names": [], "method_name": "AlternativeAlignment.getShift", "method_implementation": "{\n    return currentTranMatrix;\n}", "repo_id": "9", "comment": "/**\n * returns the shift vector that has to be applied on structure to to shift on structure one\n *\n * @return the shift vector\n */\n", "repo_name": "biojava-master/", "id": 825, "method_signature": "Atom getShift()"}, "806": {"callee_method_names": [], "method_name": "FragmentJoiner.getDensity", "method_implementation": "{\n    Atom centroid1 = Calc.getCentroid(ca1subset);\n    Atom centroid2 = Calc.getCentroid(ca2subset);\n    // get Average distance to centroid ...\n    double d1 = 0;\n    double d2 = 0;\n    for (int i = 0; i < ca1subset.length; i++) {\n        double dd1 = Calc.getDistance(centroid1, ca1subset[i]);\n        double dd2 = Calc.getDistance(centroid2, ca2subset[i]);\n        d1 += dd1;\n        d2 += dd2;\n    }\n    double avd1 = d1 / ca1subset.length;\n    double avd2 = d2 / ca2subset.length;\n    return Math.min(avd1, avd2);\n}", "repo_id": "9", "comment": "/**\n * this is probably useless\n *\n * @param ca1subset\n * @param ca2subset\n * @return a double\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 806, "method_signature": "double getDensity(Atom[], Atom[])"}, "312": {"callee_method_names": [], "method_name": "Component.isNTerminal", "method_implementation": "{\n    return isNTerminal;\n}", "repo_id": "9", "comment": "/**\n * @return true if occurring on N terminal; false, otherwise.\n */\n", "repo_name": "biojava-master/", "id": 312, "method_signature": "boolean isNTerminal()"}, "463": {"callee_method_names": [], "method_name": "QsAlignParameters.setMaxOrientationAngle", "method_implementation": "{\n    this.maxOrientationAngle = maxOrientationAngle;\n}", "repo_id": "9", "comment": "/**\n * The maximum orientation angle between two equivalent Subunits, in\n * radians. Range [0, Pi].\n *\n * @param maxOrientationAngle\n *            maximum orientation angle\n */\n", "repo_name": "biojava-master/", "id": 463, "method_signature": "void setMaxOrientationAngle(double)"}, "1566": {"callee_method_names": ["Logger.debug", "ScopDatabase.getClass", "ScopDatabase.getScopVersion", "HashMap.put"], "method_name": "ScopFactory.setScopDatabase", "method_implementation": "{\n    logger.debug(\"ScopFactory: Setting ScopDatabase to type: {}\", scop.getClass().getName());\n    defaultVersion = scop.getScopVersion();\n    versionedScopDBs.put(defaultVersion, scop);\n}", "repo_id": "9", "comment": "/**\n * Set the default scop version and instance\n * @param scop\n */\n", "repo_name": "biojava-master/", "id": 1566, "method_signature": "void setScopDatabase(ScopDatabase)"}, "1497": {"callee_method_names": ["SuperPositionQuat.setCentered", "SuperPositionQuat.superpose"], "method_name": "SuperPositions.superposeAtOrigin", "method_implementation": "{\n    superposer.setCentered(true);\n    return superposer.superpose(fixed, moved);\n}", "repo_id": "9", "comment": "/**\n * Use the {@link SuperPosition#superpose(Point3d[], Point3d[])} method of\n * the default static SuperPosition algorithm contained in this Class,\n * assuming that the point arrays are centered at the origin.\n */\n", "repo_name": "biojava-master/", "id": 1497, "method_signature": "Matrix4d superposeAtOrigin(Point3d[], Point3d[])"}, "3308": {"callee_method_ids": [619, 619], "callee_method_names": ["UserConfiguration.getPdbFilePath", "UserConfiguration.getPdbFilePath", "JFrame.setDefaultCloseOperation", "AtomCache.getAtoms", "PdbPair.getName1", "AtomCache.getAtoms", "PdbPair.getName2", "JFrame.dispose", "PdbPair.getName1", "PdbPair.getName2"], "method_name": "WebStartMain.main", "method_implementation": "{\n    AligUIManager.setLookAndFeel();\n    if (args.length == 0) {\n        //JOptionPane.showMessageDialog(null,\n        //\t\t\"Not enough arguments. Need at least 3, but only got \" + args.length);\n        // we did not get enough arguments, show the general user interface...\n        javax.swing.SwingUtilities.invokeLater(new Runnable() {\n\n            @Override\n            public void run() {\n                AlignmentGui.getInstance();\n            }\n        });\n        return;\n    } else if (args.length < 3) {\n        //String arg0 = args[0];\n        javax.swing.SwingUtilities.invokeLater(new Runnable() {\n\n            @Override\n            public void run() {\n                AlignmentGui.getInstance();\n            }\n        });\n        return;\n    }\n    String arg0 = args[0];\n    if (!(\"fatcat\".equals(arg0) || \"biojava\".equals(arg0) || \"fatcat_flexible\".equals(arg0) || \"ce\".equals(arg0) || \"ce_cp\".equals(arg0) || \"sw\".equals(arg0))) {\n        JOptionPane.showMessageDialog(null, \"Wrong arguments. First argument has to be \\\"fatcat\\\", \\\"ce\\\", \\\"ce_cp\\\", \\\"sw\\\", \\\"fatcat_flexible\\\", or \\\"biojava\\\", but got \" + arg0);\n        return;\n    }\n    try {\n        String name1 = args[1];\n        String name2 = args[2];\n        PdbPair pair = new PdbPair(name1, name2);\n        System.out.println(\"### user provided: \" + pair);\n        UserConfiguration config = getWebStartConfig();\n        System.setProperty(UserConfiguration.PDB_DIR, config.getPdbFilePath());\n        System.out.println(\"using PDB file path: \" + config.getPdbFilePath());\n        AtomCache cache = new AtomCache(config);\n        JFrame frame = new JFrame();\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        showProgressBar(frame, \"Loading PDB files...\", \"Loading files from local directory or via FTP.\");\n        Atom[] ca1 = cache.getAtoms(pair.getName1());\n        Atom[] ca2 = cache.getAtoms(pair.getName2());\n        frame.dispose();\n        System.out.println(\"done reading structures\");\n        if (\"ce\".equalsIgnoreCase(arg0) || \"ce_cp\".equalsIgnoreCase(arg0) || \"sw\".equalsIgnoreCase(arg0) || \"fatcat\".equalsIgnoreCase(arg0) || \"fatcat_flexible\".equalsIgnoreCase(arg0)) {\n            try {\n                StructureAlignment algorithm;\n                if (\"ce\".equalsIgnoreCase(arg0))\n                    algorithm = StructureAlignmentFactory.getAlgorithm(CeMain.algorithmName);\n                else if (\"ce_cp\".equalsIgnoreCase(arg0))\n                    algorithm = StructureAlignmentFactory.getAlgorithm(CeCPMain.algorithmName);\n                else if (\"fatcat\".equalsIgnoreCase(arg0))\n                    algorithm = StructureAlignmentFactory.getAlgorithm(FatCatRigid.algorithmName);\n                else if (\"fatcat_flexible\".equalsIgnoreCase(arg0))\n                    algorithm = StructureAlignmentFactory.getAlgorithm(FatCatFlexible.algorithmName);\n                else\n                    algorithm = new SmithWaterman3Daligner();\n                showStructureAlignment(algorithm, ca1, ca2, pair.getName1(), pair.getName2());\n            } catch (Exception e) {\n                e.printStackTrace();\n                JOptionPane.showMessageDialog(null, \"Something went wrong! : \" + e.getMessage());\n            }\n        } else if (\"biojava\".equalsIgnoreCase(arg0)) {\n            try {\n                //showBiojava(ca1,ca2);\n            } catch (Exception e) {\n                e.printStackTrace();\n                JOptionPane.showMessageDialog(null, \"Something went wrong! : \" + e.getMessage());\n                System.exit(0);\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n        JOptionPane.showMessageDialog(null, \"Error: \" + e.getMessage());\n        System.exit(0);\n        return;\n    }\n}", "repo_id": "9", "comment": "/**\n *  If no arguments, shows AlignmentGui for pairwise alignments.\n *  if 1 argument: dbmenu shows the DBSearchGUI, otherwise the AlignentGUI is shown.\n *\n * if more than 3 arguments takes the following arguments\n * arg0 : fatcat or biojava .\n * arg1 : pdb1.X\n * arg2 ; pdb2.X\n *\n * The 4th argument is optional and it could be the serverLocation which the client should talk to.\n *\n * @param args\n */\n", "repo_name": "biojava-master/", "id": 3308, "method_signature": "void main(String[])"}, "3174": {"callee_method_names": [], "method_name": "TranscriptSequence.getStartCodonSequence", "method_implementation": "{\n    return startCodonSequence;\n}", "repo_id": "9", "comment": "/**\n * @return the startCodonSequence\n */\n", "repo_name": "biojava-master/", "id": 3174, "method_signature": "StartCodonSequence getStartCodonSequence()"}, "72": {"callee_method_names": ["ArrayList.size", "ArrayList.get", "ArrayList.get"], "method_name": "AnchoredPairwiseSequenceAligner.getAnchors", "method_implementation": "{\n    int[] anchor = new int[getScoreMatrixDimensions()[0] - 1];\n    for (int i = 0; i < anchor.length; i++) {\n        anchor[i] = -1;\n    }\n    for (int i = 0; i < anchors.size(); i++) {\n        anchor[anchors.get(i).getQueryIndex()] = anchors.get(i).getTargetIndex();\n    }\n    return anchor;\n}", "repo_id": "9", "comment": "/**\n * Returns the list of anchors.  The populated elements correspond to query compounds with a connection established\n * to a target compound.\n *\n * @return the list of anchors\n */\n", "repo_name": "biojava-master/", "id": 72, "method_signature": "int[] getAnchors()"}, "3483": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.getBlastProgram", "method_implementation": "{\n    BlastProgramEnum program = BlastProgramEnum.valueOf(getAlignmentOption(PROGRAM));\n    boolean isMegablast = BlastProgramEnum.blastn == program && \"on\".equals(getAlignmentOption(MEGABLAST));\n    return !isMegablast ? program : BlastProgramEnum.megablast;\n}", "repo_id": "9", "comment": "/**\n * @return {@linkplain BlastProgramEnum} used for blast run\n */\n", "repo_name": "biojava-master/", "id": 3483, "method_signature": "BlastProgramEnum getBlastProgram()"}, "45": {"callee_method_names": [], "method_name": "Alignments.getPairwiseScorer", "method_implementation": "{\n    switch(type) {\n        default:\n        case GLOBAL:\n            return getPairwiseAligner(query, target, PairwiseSequenceAlignerType.GLOBAL, gapPenalty, subMatrix);\n        case GLOBAL_IDENTITIES:\n            return new FractionalIdentityScorer<S, C>(getPairwiseAligner(query, target, PairwiseSequenceAlignerType.GLOBAL, gapPenalty, subMatrix));\n        case GLOBAL_SIMILARITIES:\n            return new FractionalSimilarityScorer<S, C>(getPairwiseAligner(query, target, PairwiseSequenceAlignerType.GLOBAL, gapPenalty, subMatrix));\n        case LOCAL:\n            return getPairwiseAligner(query, target, PairwiseSequenceAlignerType.LOCAL, gapPenalty, subMatrix);\n        case LOCAL_IDENTITIES:\n            return new FractionalIdentityScorer<S, C>(getPairwiseAligner(query, target, PairwiseSequenceAlignerType.LOCAL, gapPenalty, subMatrix));\n        case LOCAL_SIMILARITIES:\n            return new FractionalSimilarityScorer<S, C>(getPairwiseAligner(query, target, PairwiseSequenceAlignerType.LOCAL, gapPenalty, subMatrix));\n        case KMERS:\n        case WU_MANBER:\n            // TODO other scoring options\n            throw new UnsupportedOperationException(Alignments.class.getSimpleName() + \" does not yet support \" + type + \" scoring\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Factory method which constructs a pairwise sequence scorer.\n *\n * @param <S> each {@link Sequence} of a pair is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n * @param query the first {@link Sequence} to score\n * @param target the second {@link Sequence} to score\n * @param type chosen type from list of pairwise sequence scoring routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return sequence pair scorer\n */\n", "repo_name": "biojava-master/", "id": 45, "method_signature": "PairwiseSequenceScorer<S,C> getPairwiseScorer(S, S, PairwiseSequenceScorerType, GapPenalty, SubstitutionMatrix)"}, "2006": {"callee_method_names": [], "method_name": "Octahedron.getVertices", "method_implementation": "{\n    Point3d[] octahedron = new Point3d[6];\n    octahedron[0] = new Point3d(-cirumscribedRadius, 0, 0);\n    octahedron[1] = new Point3d(cirumscribedRadius, 0, 0);\n    octahedron[2] = new Point3d(0, -cirumscribedRadius, 0);\n    octahedron[3] = new Point3d(0, cirumscribedRadius, 0);\n    octahedron[4] = new Point3d(0, 0, -cirumscribedRadius);\n    octahedron[5] = new Point3d(0, 0, cirumscribedRadius);\n    return octahedron;\n}", "repo_id": "9", "comment": "/**\n * Returns the vertices of an n-fold polygon of given radius and center\n * @param n\n * @param radius\n * @param center\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2006, "method_signature": "Point3d[] getVertices()"}, "3798": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getPercentageY", "method_implementation": "{\n    value = 1.0 - value;\n    double d = top + (((bottom - top) * value) / (maxPercentage - minPercentage));\n    return (int) d;\n}", "repo_id": "9", "comment": "/**\n * Get the Y coordinate based on percent value 0.0-1.0\n *\n * @param value\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3798, "method_signature": "int getPercentageY(double)"}, "3812": {"callee_method_ids": [3795, 3789, 3810], "callee_method_names": ["ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "LinkedHashMap<String, ArrayList<CensorStatus>>.put", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "ArrayList<CensorStatus>.add", "LinkedHashMap<String, ArrayList<CensorStatus>>.put", "JFrame.setDefaultCloseOperation", "JFrame.add", "KaplanMeierFigure.setSize", "JFrame.setSize", "JFrame.setVisible", "ArrayList<String>.add", "ArrayList<String>.add", "KaplanMeierFigure.setSurvivalData", "KaplanMeierFigure.setFigureLineInfo", "KaplanMeierFigure.savePNGKMNumRisk", "double[][].printStackTrace"], "method_name": "KaplanMeierFigure.main", "method_implementation": "{\n    // TODO code application logic here\n    try {\n        KaplanMeierFigure kaplanMeierFigure = new KaplanMeierFigure();\n        LinkedHashMap<String, ArrayList<CensorStatus>> survivalDataHashMap = new LinkedHashMap<String, ArrayList<CensorStatus>>();\n        //            if (false) { //http://sph.bu.edu/otlt/MPH-Modules/BS/BS704_Survival/\n        //                ArrayList<CensorStatus> graph1 = new ArrayList<CensorStatus>();\n        //                graph1.add(new CensorStatus(\"A\", 24.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 3.0, \"1\"));\n        //                graph1.add(new CensorStatus(\"A\", 11.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 19.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 24.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 13.0, \"0\"));\n        //\n        //                graph1.add(new CensorStatus(\"A\", 14.0, \"1\"));\n        //                graph1.add(new CensorStatus(\"A\", 2.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 18.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 17.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 24.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 21.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 12.0, \"0\"));\n        //\n        //                graph1.add(new CensorStatus(\"A\", 1.0, \"1\"));\n        //                graph1.add(new CensorStatus(\"A\", 10.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 23.0, \"1\"));\n        //                graph1.add(new CensorStatus(\"A\", 6.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 5.0, \"1\"));\n        //                graph1.add(new CensorStatus(\"A\", 9.0, \"0\"));\n        //                graph1.add(new CensorStatus(\"A\", 17.0, \"1\"));\n        //\n        //                survivalDataHashMap.put(\"Label 1\", graph1);\n        //\n        //\n        //\n        //            }\n        if (true) {\n            ArrayList<CensorStatus> graph1 = new ArrayList<CensorStatus>();\n            graph1.add(new CensorStatus(\"A\", 1.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 1.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 1.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 2.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 2.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 3.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 4.0, \"0\"));\n            graph1.add(new CensorStatus(\"A\", 5.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 5.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 8.0, \"0\"));\n            graph1.add(new CensorStatus(\"A\", 8.0, \"0\"));\n            graph1.add(new CensorStatus(\"A\", 8.0, \"0\"));\n            graph1.add(new CensorStatus(\"A\", 8.0, \"0\"));\n            graph1.add(new CensorStatus(\"A\", 8.0, \"0\"));\n            graph1.add(new CensorStatus(\"A\", 8.0, \"0\"));\n            graph1.add(new CensorStatus(\"A\", 8.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 9.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 9.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 9.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 9.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 9.0, \"1\"));\n            graph1.add(new CensorStatus(\"A\", 13.0, \"0\"));\n            graph1.add(new CensorStatus(\"A\", 13.0, \"0\"));\n            graph1.add(new CensorStatus(\"A\", 13.0, \"1\"));\n            survivalDataHashMap.put(\"Label 1\", graph1);\n            ArrayList<CensorStatus> graph2 = new ArrayList<CensorStatus>();\n            graph2.add(new CensorStatus(\"A\", 1.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 1.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 1.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 3.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 3.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 4.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 5.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 5.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 5.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 5.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 6.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 6.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 7.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 7.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 7.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 7.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 8.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 8.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 8.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 8.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 8.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 8.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 9.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 9.0, \"1\"));\n            graph2.add(new CensorStatus(\"A\", 10.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 10.0, \"0\"));\n            graph2.add(new CensorStatus(\"A\", 10.0, \"0\"));\n            survivalDataHashMap.put(\"Label 2\", graph2);\n        }\n        ArrayList<String> figureInfo = new ArrayList<String>();\n        //DecimalFormat dfe = new DecimalFormat(\"0.00E0\");\n        //DecimalFormat df = new DecimalFormat(\"0.00\");\n        JFrame application = new JFrame();\n        application.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        application.add(kaplanMeierFigure);\n        kaplanMeierFigure.setSize(500, 400);\n        // window is 500 pixels wide, 400 high\n        application.setSize(500, 400);\n        application.setVisible(true);\n        ArrayList<String> titles = new ArrayList<String>();\n        titles.add(\"Line 1\");\n        titles.add(\"Line 2\");\n        kaplanMeierFigure.setSurvivalData(titles, survivalDataHashMap, true);\n        //   figureInfo.add(\"HR=2.1 95% CI(1.8-2.5)\");\n        //   figureInfo.add(\"p-value=.001\");\n        kaplanMeierFigure.setFigureLineInfo(figureInfo);\n        kaplanMeierFigure.savePNGKMNumRisk(\"test.png\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3812, "method_signature": "void main(String[])"}, "3279": {"callee_method_ids": [3283], "callee_method_names": ["Pattern.matcher", "Matcher.find", "Logger.info", "Matcher.group", "Matcher.group", "Matcher.group", "Matcher.group", "Matcher.group", "AtomInfo.setAtomName", "AtomInfo.setResidueName", "AtomInfo.setResidueNumber", "String.replaceAll", "String.substring", "String.length", "AtomInfo.setChainId", "String.substring", "String.length", "AtomInfo.setModelNumber"], "method_name": "AtomInfoParser.parse", "method_implementation": "{\n    Matcher matcher = pattern.matcher(jmolAtomInfo);\n    boolean found = matcher.find();\n    if (!found) {\n        logger.info(\"Could not parse the atomInfo string {}\", jmolAtomInfo);\n        return new AtomInfo();\n    }\n    String residueName = matcher.group(1);\n    String residueNumber = matcher.group(2);\n    String chainId = matcher.group(3);\n    String atomName = matcher.group(4);\n    String modelNumber = matcher.group(5);\n    //System.out.println(jmolAtomInfo +\" | \" +  residueName + \" number:\" + residueNumber + \" chain:\" + chainName +\n    //\t\t\" atomName:\" + atomName + \" modelNumber:\" + modelNumber );\n    AtomInfo info = new AtomInfo();\n    info.setAtomName(atomName);\n    info.setResidueName(residueName);\n    info.setResidueNumber(residueNumber.replaceAll(\"\\\\^\", \"\"));\n    String ci = \" \";\n    if (chainId != null)\n        ci = chainId.substring(1, chainId.length());\n    info.setChainId(ci);\n    int mn = 1;\n    if (modelNumber != null)\n        mn = Integer.parseInt(modelNumber.substring(1, modelNumber.length()));\n    info.setModelNumber(mn);\n    return info;\n}", "repo_id": "9", "comment": "/**\n * parses e.g.\n *  [MET]361:A.CA/1 #2843\n *  [GLY]339:A.CA #2573\n *  [ASN]44.CA #704\n *\n * @param jmolAtomInfo\n * @return an AtomInfo\n */\n", "repo_name": "biojava-master/", "id": 3279, "method_signature": "AtomInfo parse(String)"}, "699": {"callee_method_names": ["MultipleAlignment.length", "MultipleAlignment.getBlocks", "MultipleAlignment.getBlock", "Matrix.get", "Matrix.get", "Random.nextDouble", "MultipleAlignment.getBlock", "Block.getCoreLength", "Block.getAlignRes", "Block.getAlignRes", "List<SortedSet<Integer>>.get"], "method_name": "MultipleMcOptimizer.shrinkBlock", "method_implementation": "{\n    // Select column by maximum distance\n    Matrix residueDistances = MultipleAlignmentTools.getAverageResidueDistances(msa);\n    double[] colDistances = new double[msa.length()];\n    double maxDist = Double.MIN_VALUE;\n    int position = 0;\n    int block = 0;\n    int column = 0;\n    for (int b = 0; b < msa.getBlocks().size(); b++) {\n        for (int col = 0; col < msa.getBlock(b).length(); col++) {\n            int normalize = 0;\n            for (int s = 0; s < size; s++) {\n                if (residueDistances.get(s, column) != -1) {\n                    colDistances[column] += residueDistances.get(s, column);\n                    normalize++;\n                }\n            }\n            colDistances[column] /= normalize;\n            if (colDistances[column] > maxDist) {\n                if (rnd.nextDouble() > 0.5) {\n                    maxDist = colDistances[column];\n                    position = col;\n                    block = b;\n                }\n            }\n            column++;\n        }\n    }\n    Block currentBlock = msa.getBlock(block);\n    if (currentBlock.getCoreLength() <= Lmin)\n        return false;\n    for (int str = 0; str < size; str++) {\n        Integer residue = currentBlock.getAlignRes().get(str).get(position);\n        currentBlock.getAlignRes().get(str).remove(position);\n        if (residue != null)\n            freePool.get(str).add(residue);\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Deletes an alignment column at a randomly selected position.\n */\n", "repo_name": "biojava-master/", "id": 699, "method_signature": "boolean shrinkBlock()"}, "3490": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.setBlastWordSize", "method_implementation": "{\n    setAlignmentOption(WORD_SIZE, Integer.toString(word));\n}", "repo_id": "9", "comment": "/**\n * Sets the WORD_SIZE parameter to be use with blastall\n * <p>\n * <b>WARNING!!</b> At this point, the method does not verify the validity of your choice; for example, word size of\n * greater than 5 with blastp returns error messages from QBlast. Word size range depends on the algorithm chosen.\n * <p>\n * More at https://www.ncbi.nlm.nih.gov/staff/tao/URLAPI/new/node74.html\n * <p>\n * Blastall equivalent: -W\n *\n * @param word: an int used to set WORD_SIZE\n */\n", "repo_name": "biojava-master/", "id": 3490, "method_signature": "void setBlastWordSize(int)"}, "2534": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getGonnet250", "method_implementation": "{\n    return getAminoAcidMatrix(\"gonnet250\");\n}", "repo_id": "9", "comment": "/**\n * Returns PAM 250 matrix by Gonnet, Cohen & Benner\n * @return Gonnet 250 matrix\n */\n", "repo_name": "biojava-master/", "id": 2534, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getGonnet250()"}, "105": {"callee_method_names": ["BasicSymmetricalDistanceMatrix.getSize", "BasicSymmetricalDistanceMatrix.setIdentifier", "BasicSymmetricalDistanceMatrix.getIdentifier", "BasicSymmetricalDistanceMatrix.setValue", "BasicSymmetricalDistanceMatrix.getValue"], "method_name": "ForesterWrapper.cloneDM", "method_implementation": "{\n    int n = distM.getSize();\n    BasicSymmetricalDistanceMatrix cloneDM = new BasicSymmetricalDistanceMatrix(n);\n    for (int i = 0; i < n; i++) {\n        cloneDM.setIdentifier(i, distM.getIdentifier(i));\n        for (int j = i + 1; j < n; j++) {\n            cloneDM.setValue(i, j, distM.getValue(i, j));\n        }\n    }\n    return cloneDM;\n}", "repo_id": "9", "comment": "/**\n * Helper function to clone a forester symmetrical DistanceMatrix.\n *\n * @param distM\n *            forester symmetrical DistanceMatrix\n * @return identical copy of the forester symmetrical DistanceMatrix\n */\n", "repo_name": "biojava-master/", "id": 105, "method_signature": "BasicSymmetricalDistanceMatrix cloneDM(BasicSymmetricalDistanceMatrix)"}, "1053": {"callee_method_names": ["Structure.getChains", "Chain.getAtomGroups", "ResidueNumber.equals", "Map<Group, Double>.containsKey", "Map<Group, Double>.put", "Map<Group, Double>.put", "Map<Group, Double>.get", "Map<Group, Integer>.containsKey", "Map<Group, Integer>.put", "Map<Group, Integer>.put", "Map<Group, Integer>.get", "Map<Group, Double>.get", "Map<Group, Double>.put", "Map<Group, Double>.entrySet", "Map<Group, Integer>.get", "Map.Entry<ResidueNumber, Integer>.getKey", "Map<Group, Double>.put", "Map.Entry<ResidueNumber, Integer>.getKey", "Map.Entry<ResidueNumber, Integer>.getValue", "Map<Group, Double>.replaceAll"], "method_name": "StructureTools.getGroupDistancesWithinShell", "method_implementation": "{\n    // for speed, we avoid calculating square roots\n    radius = radius * radius;\n    Map<Group, Double> distances = new HashMap<Group, Double>();\n    // we only need this if we're averaging distances\n    // note that we can't use group.getAtoms().size() because some the\n    // group's atoms be outside the shell\n    Map<Group, Integer> atomCounts = new HashMap<Group, Integer>();\n    for (Chain chain : structure.getChains()) {\n        groupLoop: for (Group chainGroup : chain.getAtomGroups()) {\n            // exclude water\n            if (!includeWater && chainGroup.isWater())\n                continue;\n            // check blacklist of residue numbers\n            for (ResidueNumber rn : excludeResidues) {\n                if (rn.equals(chainGroup.getResidueNumber()))\n                    continue groupLoop;\n            }\n            for (Atom testAtom : chainGroup.getAtoms()) {\n                // use getDistanceFast as we are doing a lot of comparisons\n                double dist = Calc.getDistanceFast(centroid, testAtom);\n                // if we're the shell\n                if (dist <= radius) {\n                    if (!distances.containsKey(chainGroup))\n                        distances.put(chainGroup, Double.POSITIVE_INFINITY);\n                    if (useAverageDistance) {\n                        // sum the distance; we'll divide by the total\n                        // number later\n                        // here, we CANNOT use fastDistance (distance\n                        // squared) because we want the arithmetic mean\n                        distances.put(chainGroup, distances.get(chainGroup) + Math.sqrt(dist));\n                        if (!atomCounts.containsKey(chainGroup))\n                            atomCounts.put(chainGroup, 0);\n                        atomCounts.put(chainGroup, atomCounts.get(chainGroup) + 1);\n                    } else {\n                        // take the minimum distance among all atoms of\n                        // chainGroup\n                        // note that we can't break here because we might\n                        // find a smaller distance\n                        if (dist < distances.get(chainGroup)) {\n                            distances.put(chainGroup, dist);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (useAverageDistance) {\n        for (Map.Entry<Group, Double> entry : distances.entrySet()) {\n            int count = atomCounts.get(entry.getKey());\n            distances.put(entry.getKey(), entry.getValue() / count);\n        }\n    } else {\n        // in this case we used getDistanceFast\n        distances.replaceAll((k, v) -> Math.sqrt(v));\n    }\n    return distances;\n}", "repo_id": "9", "comment": "/**\n * Finds Groups in {@code structure} that contain at least one Atom that is\n * within {@code radius} Angstroms of {@code centroid}.\n *\n * @param structure\n *            The structure from which to find Groups\n * @param centroid\n *            The centroid of the shell\n * @param excludeResidues\n *            A list of ResidueNumbers to exclude\n * @param radius\n *            The radius from {@code centroid}, in Angstroms\n * @param includeWater\n *            Whether to include Groups whose <em>only</em> atoms are water\n * @param useAverageDistance\n *            When set to true, distances are the arithmetic mean (1-norm)\n *            of the distances of atoms that belong to the group and that\n *            are within the shell; otherwise, distances are the minimum of\n *            these values\n * @return A map of Groups within (or partially within) the shell, to their\n *         distances in Angstroms\n */\n", "repo_name": "biojava-master/", "id": 1053, "method_signature": "Map<Group,Double> getGroupDistancesWithinShell(Structure, Atom, Set, double, boolean, boolean)"}, "537": {"callee_method_names": ["Matrix.set"], "method_name": "AlignUtils.getDistanceMatrix", "method_implementation": "{\n    int r = ca1.length;\n    int c = ca2.length;\n    Matrix out = new Matrix(r, c);\n    for (int i = 0; i < r; i++) {\n        Atom a1 = ca1[i];\n        for (int j = 0; j < c; j++) {\n            Atom b1 = ca2[j];\n            double d = Calc.getDistance(a1, b1);\n            out.set(i, j, d);\n        }\n    }\n    return out;\n}", "repo_id": "9", "comment": "/**\n * Matrix of all distances between two sets of Atoms. Does not\n * superimpose or modify the Atoms.\n *\n * @param ca1\n * @param ca2\n * @return a Matrix\n */\n", "repo_name": "biojava-master/", "id": 537, "method_signature": "Matrix getDistanceMatrix(Atom[], Atom[])"}, "1163": {"callee_method_ids": [1780], "callee_method_names": ["String.substring", "PDBHeader.getAuthors", "PDBHeader.setAuthors", "PDBHeader.setAuthors"], "method_name": "PDBFileParser.pdb_AUTHOR_Handler", "method_implementation": "{\n    String authors = line.substring(10).trim();\n    String auth = pdbHeader.getAuthors();\n    if (auth == null) {\n        pdbHeader.setAuthors(authors);\n    } else {\n        auth += authors;\n        pdbHeader.setAuthors(auth);\n    }\n}", "repo_id": "9", "comment": "/**\n * Parses the following record:\n * <pre>\n *  COLUMNS      DATA  TYPE      FIELD         DEFINITION\n * ------------------------------------------------------------------------------------\n *  1 -  6      Record name     \"AUTHOR\"\n *  9 - 10      Continuation    continuation  Allows concatenation of multiple records.\n * 11 - 79      List            authorList    List of the author names, separated\n *                                            by commas.\n *\n * </pre>\n * @param line\n */\n", "repo_name": "biojava-master/", "id": 1163, "method_signature": "void pdb_AUTHOR_Handler(String)"}, "1821": {"callee_method_names": [], "method_name": "EcodInstallation.getVersion", "method_implementation": "{\n    return version;\n}", "repo_id": "9", "comment": "/**\n * @return the requestedVersion for this file, or null if none was parsed\n */\n", "repo_name": "biojava-master/", "id": 1821, "method_signature": "String getVersion()"}, "1419": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.isNonStandardCoordFrameConvention", "method_implementation": "{\n    return nonStandardCoordFrameConvention;\n}", "repo_id": "9", "comment": "/**\n * Whether this structure is non-standard coordinate frame convention, for which our scale matrix\n * calculation and thus the crystal reconstruction will be incorrect.\n * There's ~ 200 old structures in the PDB affected by the non-standard frame problem, hopefully they will\n * be remediated in the future.\n * For more info see: https://github.com/eppic-team/owl/issues/4\n * @since 4.2.5\n */\n", "repo_name": "biojava-master/", "id": 1419, "method_signature": "boolean isNonStandardCoordFrameConvention()"}, "2389": {"callee_method_ids": [2421], "callee_method_names": ["Pattern.split", "String[].trim", "String[].trim", "String[].trim", "String[].trim", "String[].trim", "String[].trim", "String[].trim", "Location.isNegative", "String[].trim", "String.split"], "method_name": "GFF3Reader.parseLine", "method_implementation": "{\n    //FIXME update to use regex split on tabs\n    //FIXME better errors on parse failures\n    String[] line = p.split(s);\n    String seqname = line[0].trim();\n    String source = line[1].trim();\n    String type = line[2].trim();\n    String locStart = line[3].trim();\n    String locEnd = line[4].trim();\n    Double score;\n    try {\n        score = Double.parseDouble(line[5].trim());\n    } catch (Exception e) {\n        score = 0.0;\n    }\n    char strand = line[6].trim().charAt(0);\n    //added by scooter willis to deal with glimmer predictions that\n    //have the start after the end but is a negative strand\n    int locationStart = Integer.parseInt(locStart);\n    int locationEnd = Integer.parseInt(locEnd);\n    if (locationStart > locationEnd) {\n        int temp = locationStart;\n        locationStart = locationEnd;\n        locationEnd = temp;\n    }\n    Location location = Location.fromBio(locationStart, locationEnd, strand);\n    assert (strand == '-') == location.isNegative();\n    int frame;\n    try {\n        frame = Integer.parseInt(line[7].trim());\n    } catch (Exception e) {\n        frame = -1;\n    }\n    String attributes = line[8];\n    /*    //grab everything until end of line (or # comment)\n\t\tstart = end + 1;\n\t\tend = s.indexOf('#', start);\n\t\tString attributes = null;\n\t\tif (end < 0) {\n\t\t\tattributes = new String(s.substring(start));\n\t\t} else {\n\t\t\tattributes = new String(s.substring(start, end));\n\t\t}\n */\n    return new Feature(seqname, source, type, location, score, frame, attributes.split(\"#\")[0]);\n}", "repo_id": "9", "comment": "/**\n * create Feature from line of GFF file\n */\n", "repo_name": "biojava-master/", "id": 2389, "method_signature": "Feature parseLine(String)"}, "3525": {"callee_method_names": [], "method_name": "StrataInfo.getNdead", "method_implementation": "{\n    return ndead;\n}", "repo_id": "9", "comment": "/**\n * @return the ndead\n */\n", "repo_name": "biojava-master/", "id": 3525, "method_signature": "LinkedHashMap<Double,Integer> getNdead()"}, "196": {"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "ProteinSequence.getAccession", "StringBuffer.toString"], "method_name": "Jronn.convertProteinSequencetoFasta", "method_implementation": "{\n    StringBuffer buf = new StringBuffer();\n    for (AminoAcidCompound compound : sequence) {\n        String c = compound.getShortName();\n        if (!SequenceUtil.NON_AA.matcher(c).find()) {\n            buf.append(c);\n        } else {\n            buf.append(\"X\");\n        }\n    }\n    return new FastaSequence(sequence.getAccession().getID(), buf.toString());\n}", "repo_id": "9", "comment": "/**\n * Utility method to convert a BioJava ProteinSequence object to the FastaSequence\n *  object used internally in JRonn.\n *\n * @param sequence\n * @return\n */\n", "repo_name": "biojava-master/", "id": 196, "method_signature": "FastaSequence convertProteinSequencetoFasta(ProteinSequence)"}, "432": {"callee_method_names": [], "method_name": "FatCatParameters.getMaxTra", "method_implementation": "{\n    return maxTra;\n}", "repo_id": "9", "comment": "/**\n * get the maximum number of Twists that are allowed...\n *\n * @return max nr of allowed twists\n */\n", "repo_name": "biojava-master/", "id": 432, "method_signature": "Integer getMaxTra()"}, "3713": {"callee_method_names": [], "method_name": "WorkSheet.hideMetaDataRows", "method_implementation": "{\n    ArrayList<String> metadataRows = this.getMetaDataRows();\n    for (String row : metadataRows) {\n        this.hideRow(row, value);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 3713, "method_signature": "void hideMetaDataRows(boolean)"}, "1425": {"callee_method_names": [], "method_name": "CrystalTransform.isPureCrystalTranslation", "method_implementation": "{\n    return (transformId == 0 && (crystalTranslation.x != 0 || crystalTranslation.y != 0 || crystalTranslation.z != 0));\n}", "repo_id": "9", "comment": "/**\n * Tells whether this transformation is a pure crystal lattice translation,\n * i.e. no rotational component and an integer translation vector.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1425, "method_signature": "boolean isPureCrystalTranslation()"}, "3872": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getAAComposition"], "method_name": "PeptideProperties.getAAComposition", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getAAComposition(pSequence);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the composition of the 20 standard amino acid in the sequence.\n * The sequence argument must be a protein sequence consisting of only\n * non-ambiguous characters.\n * The composition of an amino acid is the total number of its occurrence,\n * divided by the total length of the sequence.\n *\n * @param sequence\n *            a protein sequence consisting of non-ambiguous characters only\n * @return the composition of the 20 standard amino acid in the sequence\n * @see AminoAcidCompound\n */\n", "repo_name": "biojava-master/", "id": 3872, "method_signature": "Map<AminoAcidCompound,Double> getAAComposition(String)"}, "3652": {"callee_method_names": ["ArrayList<String>.addAll", "LinkedHashMap.keySet", "ArrayList<String>.addAll", "LinkedHashMap.keySet"], "method_name": "SurvivalInfo.getDataVariables", "method_implementation": "{\n    ArrayList<String> v = new ArrayList<String>();\n    v.addAll(data.keySet());\n    v.addAll(unknownDataType.keySet());\n    return v;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3652, "method_signature": "ArrayList<String> getDataVariables()"}, "21": {"callee_method_names": ["String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "String.equals", "StockholmStructure.getConsAnnotation", "Logger.warn"], "method_name": "StockholmFileParser.handleConsensusAnnotation", "method_implementation": "{\n    if (featureName.equals(GC_SECONDARY_STRUCTURE)) {\n        stockholmStructure.getConsAnnotation().setSecondaryStructure(value);\n    } else if (featureName.equals(GC_SEQUENSE_CONSENSUS)) {\n        stockholmStructure.getConsAnnotation().setSequenceConsensus(value);\n    } else if (featureName.equals(GC_SURFACE_ACCESSIBILITY)) {\n        stockholmStructure.getConsAnnotation().setSurfaceAccessibility(value);\n    } else if (featureName.equals(GC_TRANS_MEMBRANE)) {\n        stockholmStructure.getConsAnnotation().setTransMembrane(value);\n    } else if (featureName.equals(GC_POSTERIOR_PROBABILITY)) {\n        stockholmStructure.getConsAnnotation().setPosteriorProbability(value);\n    } else if (featureName.equals(GC_LIGAND_BINDING)) {\n        stockholmStructure.getConsAnnotation().setLigandBinding(value);\n    } else if (featureName.equals(GC_ACTIVE_SITE)) {\n        stockholmStructure.getConsAnnotation().setActiveSite(value);\n    } else if (featureName.equals(GC_AS_PFAM_PREDICTED)) {\n        stockholmStructure.getConsAnnotation().setAsPFamPredicted(value);\n    } else if (featureName.equals(GC_AS_SWISSPROT)) {\n        stockholmStructure.getConsAnnotation().setAsSwissProt(value);\n    } else if (featureName.equals(GC_INTRON)) {\n        stockholmStructure.getConsAnnotation().setIntron(value);\n    } else if (featureName.equals(GC_REFERENCE_ANNOTATION)) {\n        stockholmStructure.getConsAnnotation().setReferenceAnnotation(value);\n    } else if (featureName.equals(GC_MODEL_MASK)) {\n        stockholmStructure.getConsAnnotation().setModelMask(value);\n    } else {\n        // unknown feature\n        logger.warn(\"Unknown Consensus Feature [{}].\\nPlease contact the Biojava team.\", featureName);\n    }\n}", "repo_id": "9", "comment": "/**\n * usually a single line of:<br>\n * #=GC &lt;feature&gt; &lt;Generic per-Column annotation, exactly 1 char per column&gt;\n *\n * @param featureName\n *            the feature name :)\n * @param value\n *            the line to be parsed.\n */\n", "repo_name": "biojava-master/", "id": 21, "method_signature": "void handleConsensusAnnotation(String, String)"}, "1197": {"callee_method_names": ["List<List<Chain>>.size", "List<List<Chain>>.get", "PolymerType.setId", "List<List<Chain>>.get", "List<List<Chain>>.get"], "method_name": "PDBFileParser.assignAsymIds", "method_implementation": "{\n    for (int i = 0; i < polys.size(); i++) {\n        String asymId = \"A\";\n        for (Chain poly : polys.get(i)) {\n            poly.setId(asymId);\n            asymId = getNextAsymId(asymId);\n        }\n        for (Chain nonPoly : nonPolys.get(i)) {\n            nonPoly.setId(asymId);\n            asymId = getNextAsymId(asymId);\n        }\n        for (Chain water : waters.get(i)) {\n            water.setId(asymId);\n            asymId = getNextAsymId(asymId);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Assign asym ids following the rules used by the PDB to assign asym ids in mmCIF files\n * @param polys\n * @param nonPolys\n * @param waters\n */\n", "repo_name": "biojava-master/", "id": 1197, "method_signature": "void assignAsymIds(List, List, List)"}, "1600": {"callee_method_names": ["SecStrucGroup[].getPDBName", "Logger.debug", "SecStrucGroup[].getResidueNumber", "SecStrucState.getAccept1", "SecStrucState.getAccept2", "SecStrucState.getDonor1", "SecStrucState.getDonor2", "Logger.debug", "SecStrucState.setAccept2", "SecStrucState.getAccept1", "HBond.setEnergy", "HBond.setPartner", "SecStrucState.setAccept1", "Logger.debug", "HBond.setEnergy", "HBond.setPartner", "SecStrucState.setAccept2", "Logger.debug", "SecStrucState.setDonor2", "SecStrucState.getDonor1", "HBond.setEnergy", "HBond.setPartner", "SecStrucState.setDonor1", "Logger.debug", "HBond.setEnergy", "HBond.setPartner", "SecStrucState.setDonor2"], "method_name": "SecStrucCalc.trackHBondEnergy", "method_implementation": "{\n    if (\"PRO\".equals(groups[i].getPDBName())) {\n        logger.debug(\"Ignore: PRO {}\", groups[i].getResidueNumber());\n        return;\n    }\n    SecStrucState stateOne = getSecStrucState(i);\n    SecStrucState stateTwo = getSecStrucState(j);\n    double acc1e = stateOne.getAccept1().getEnergy();\n    double acc2e = stateOne.getAccept2().getEnergy();\n    double don1e = stateTwo.getDonor1().getEnergy();\n    double don2e = stateTwo.getDonor2().getEnergy();\n    //Acceptor: N-H-->O\n    if (energy < acc1e) {\n        logger.debug(\"{} < {}\", energy, acc1e);\n        stateOne.setAccept2(stateOne.getAccept1());\n        HBond bond = new HBond();\n        bond.setEnergy(energy);\n        bond.setPartner(j);\n        stateOne.setAccept1(bond);\n    } else if (energy < acc2e) {\n        logger.debug(\"{} < {}\", energy, acc2e);\n        HBond bond = new HBond();\n        bond.setEnergy(energy);\n        bond.setPartner(j);\n        stateOne.setAccept2(bond);\n    }\n    //The other side of the bond: donor O-->N-H\n    if (energy < don1e) {\n        logger.debug(\"{} < {}\", energy, don1e);\n        stateTwo.setDonor2(stateTwo.getDonor1());\n        HBond bond = new HBond();\n        bond.setEnergy(energy);\n        bond.setPartner(i);\n        stateTwo.setDonor1(bond);\n    } else if (energy < don2e) {\n        logger.debug(\"{} < {}\", energy, don2e);\n        HBond bond = new HBond();\n        bond.setEnergy(energy);\n        bond.setPartner(i);\n        stateTwo.setDonor2(bond);\n    }\n}", "repo_id": "9", "comment": "/**\n * Store Hbonds in the Groups.\n * DSSP allows two HBonds per aminoacids to allow bifurcated bonds.\n */\n", "repo_name": "biojava-master/", "id": 1600, "method_signature": "void trackHBondEnergy(int, int, double)"}, "891": {"callee_method_ids": [894, 919], "callee_method_names": ["StructureInterface.getParentChains", "Pair<Chain>.getFirst", "Pair<Chain>.getSecond", "Pair<Chain>.getFirst", "Pair<Chain>.getSecond", "Logger.warn", "StructureInterface.getId", "Pair<Chain>.getFirst", "Pair<Chain>.getSecond", "Pair<Chain>.getFirst", "Pair<Chain>.getSecond", "StructureInterface.getGroupContacts", "GroupContactSet.hasContact", "GroupContactSet.size", "GroupContactSet.size", "Logger.debug", "Pair<Chain>.getFirst", "Pair<Chain>.getSecond", "Pair<Chain>.getFirst", "Pair<Chain>.getSecond"], "method_name": "StructureInterface.getContactOverlapScore", "method_implementation": "{\n    Pair<Chain> thisChains = getParentChains();\n    Pair<Chain> otherChains = other.getParentChains();\n    if (thisChains.getFirst().getEntityInfo() == null || thisChains.getSecond().getEntityInfo() == null || otherChains.getFirst().getEntityInfo() == null || otherChains.getSecond().getEntityInfo() == null) {\n        // this happens in cases like 2uub\n        logger.warn(\"Found chains with null compounds while comparing interfaces {} and {}. Contact overlap score for them will be 0.\", this.getId(), other.getId());\n        return 0;\n    }\n    Pair<EntityInfo> thisCompounds = new Pair<EntityInfo>(thisChains.getFirst().getEntityInfo(), thisChains.getSecond().getEntityInfo());\n    Pair<EntityInfo> otherCompounds = new Pair<EntityInfo>(otherChains.getFirst().getEntityInfo(), otherChains.getSecond().getEntityInfo());\n    if (checkMolIdMatch(thisCompounds, otherCompounds)) {\n        int common = 0;\n        GroupContactSet thisContacts = getGroupContacts();\n        GroupContactSet otherContacts = other.getGroupContacts();\n        for (GroupContact thisContact : thisContacts) {\n            ResidueIdentifier first;\n            ResidueIdentifier second;\n            if (!invert) {\n                first = new ResidueIdentifier(thisContact.getPair().getFirst());\n                second = new ResidueIdentifier(thisContact.getPair().getSecond());\n            } else {\n                first = new ResidueIdentifier(thisContact.getPair().getSecond());\n                second = new ResidueIdentifier(thisContact.getPair().getFirst());\n            }\n            if (otherContacts.hasContact(first, second)) {\n                common++;\n            }\n        }\n        return (2.0 * common) / (thisContacts.size() + otherContacts.size());\n    } else {\n        logger.debug(\"Chain pairs {},{} and {},{} belong to different compound pairs, contact overlap score will be 0 \", thisChains.getFirst().getId(), thisChains.getSecond().getId(), otherChains.getFirst().getId(), otherChains.getSecond().getId());\n        return 0.0;\n    }\n}", "repo_id": "9", "comment": "/**\n * Calculates the Jaccard contact set score (intersection over union) between this StructureInterface and\n * the given one. The calculation assumes that both interfaces come from the same structure. The output\n * will not necessarily make sense if the two interfaces come from different structures.\n * The two sides of the given StructureInterface need to match this StructureInterface\n * in the sense that they must come from the same Entity, i.e.\n * their residue numbers need to align with 100% identity, except for unobserved\n * density residues. The SEQRES indices obtained through {@link EntityInfo#getAlignedResIndex(Group, Chain)} are\n * used to match residues, thus if no SEQRES is present or if {@link FileParsingParameters#setAlignSeqRes(boolean)}\n * is not used, this calculation is not guaranteed to work properly.\n * @param other the interface to be compared to this one\n * @param invert if false the comparison will be done first-to-first and second-to-second,\n * if true the match will be first-to-second and second-to-first\n * @return the contact overlap score, range [0.0,1.0]\n */\n", "repo_name": "biojava-master/", "id": 891, "method_signature": "double getContactOverlapScore(StructureInterface, boolean)"}, "3409": {"callee_method_ids": [1961], "callee_method_names": ["StringBuilder.append", "Quat4d.set", "HelixAxisAligner.getRotationMatrix", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorH.getDefaultOrientation", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    s.append(setCentroid());\n    Quat4d q = new Quat4d();\n    q.set(helixAxisAligner.getRotationMatrix());\n    // set orientation\n    s.append(\"moveto 0 quaternion{\");\n    s.append(jMolFloat(q.x));\n    s.append(\",\");\n    s.append(jMolFloat(q.y));\n    s.append(\",\");\n    s.append(jMolFloat(q.z));\n    s.append(\",\");\n    s.append(jMolFloat(q.w));\n    s.append(\"};\");\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script to set the default orientation for a structure\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3409, "method_signature": "String getDefaultOrientation()"}, "2547": {"callee_method_names": [], "method_name": "Hsp.getHspIdentityString", "method_implementation": "{\n    return hspIdentityString;\n}", "repo_id": "9", "comment": "/**\n * Identity string representing correspondence between aligned residues\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2547, "method_signature": "String getHspIdentityString()"}, "2713": {"callee_method_names": ["Reader.read"], "method_name": "BufferedReaderBytesRead.read1", "method_implementation": "{\n    if (nextChar >= nChars) {\n        /* If the requested length is at least as large as the buffer, and\n\t\t\tif there is no mark/reset activity, and if line feeds are not\n\t\t\tbeing skipped, do not bother to copy the characters into the\n\t\t\tlocal buffer.  In this way buffered streams will cascade\n\t\t\tharmlessly. */\n        if (len >= cb.length && markedChar <= UNMARKED && !skipLF) {\n            return in.read(cbuf, off, len);\n        }\n        fill();\n    }\n    if (nextChar >= nChars) {\n        return -1;\n    }\n    if (skipLF) {\n        skipLF = false;\n        if (cb[nextChar] == '\\n') {\n            nextChar++;\n            if (nextChar >= nChars) {\n                fill();\n            }\n            if (nextChar >= nChars) {\n                return -1;\n            }\n        }\n    }\n    int n = Math.min(len, nChars - nextChar);\n    System.arraycopy(cb, nextChar, cbuf, off, n);\n    nextChar += n;\n    return n;\n}", "repo_id": "9", "comment": "/**\n * Reads characters into a portion of an array, reading from the underlying\n * stream if necessary.\n */\n", "repo_name": "biojava-master/", "id": 2713, "method_signature": "int read1(char[], int, int)"}, "1315": {"callee_method_names": [], "method_name": "FileParsingParameters.isParseSecStruc", "method_implementation": "{\n    return parseSecStruc;\n}", "repo_id": "9", "comment": "/**\n * Is secondary structure assignment being parsed from the file?\n * default is null\n * @return boolean if HELIX STRAND and TURN fields are being parsed\n */\n", "repo_name": "biojava-master/", "id": 1315, "method_signature": "boolean isParseSecStruc()"}, "79": {"callee_method_names": ["List<Anchor>.size", "List<Anchor>.get", "List<Anchor>.get", "List<Subproblem>.add", "List<Anchor>.get", "List<Anchor>.get", "List<Anchor>.get", "List<Subproblem>.add"], "method_name": "AlignerHelper.getSubproblems", "method_implementation": "{\n    Collections.sort(anchors, new Anchor.QueryIndexComparator());\n    List<Subproblem> list = new ArrayList<Subproblem>();\n    // sentinal anchor\n    Anchor last = new Anchor(-1, -1);\n    boolean isAnchored = false;\n    for (int i = 0; i < anchors.size(); i++) {\n        if (anchors.get(i).targetIndex <= last.targetIndex || anchors.get(i).queryIndex <= last.queryIndex) {\n            throw new IllegalArgumentException(\"Anchor set must allow at least one possible alignment.\");\n        }\n        list.add(new Subproblem(last.queryIndex + 1, last.targetIndex + 1, anchors.get(i).queryIndex, anchors.get(i).targetIndex, isAnchored));\n        last = anchors.get(i);\n        isAnchored = true;\n    }\n    list.add(new Subproblem(last.queryIndex + 1, last.targetIndex + 1, querySequenceLength, targetSequenceLength, isAnchored));\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Convert a list of anchors into a subproblem list.\n * @param anchors anchored read pairs\n * @param querySequenceLength length of query sequence\n * @param targetSequenceLength length of target sequence\n * @return list alignment subproblems\n */\n", "repo_name": "biojava-master/", "id": 79, "method_signature": "List<Subproblem> getSubproblems(List, int, int)"}, "765": {"callee_method_names": [], "method_name": "StartupParameters.getAlignPairs", "method_implementation": "{\n    return alignPairs;\n}", "repo_id": "9", "comment": "/**\n * The file that contains a list of PDB pairs to be aligned\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 765, "method_signature": "String getAlignPairs()"}, "814": {"callee_method_names": [], "method_name": "AlternativeAlignment.getScore", "method_implementation": "{\n    return score;\n}", "repo_id": "9", "comment": "/**\n * the alignment score\n *\n * @return the score of this alignment\n */\n", "repo_name": "biojava-master/", "id": 814, "method_signature": "float getScore()"}, "339": {"callee_method_names": ["StructureProvider.getStructureById", "Structure.getNonPolyChainsByPDB", "List<Chain>.get", "Chain.getAtomGroups", "Chain.getName", "Structure.getNonPolyChainsByPDB", "Group.getChemComp", "Chain.getSeqResSequence", "Chain.getAtomSequence", "Chain.getAtomGroups", "Structure.getEntityInfos"], "method_name": "DemoMMCIFReader.loadFromDirectAccess", "method_implementation": "{\n    String pdbId = \"1A4W\";\n    StructureProvider pdbreader = new CifFileReader();\n    try {\n        Structure s = pdbreader.getStructureById(pdbId);\n        System.out.println(\"Getting chain H of 1A4W\");\n        List<Chain> hs = s.getNonPolyChainsByPDB(\"H\");\n        Chain h = hs.get(0);\n        List<Group> ligands = h.getAtomGroups();\n        System.out.println(\"These ligands have been found in chain \" + h.getName());\n        for (Group l : ligands) {\n            System.out.println(l);\n        }\n        System.out.println(\"Accessing QWE directly: \");\n        Group qwe = s.getNonPolyChainsByPDB(\"H\").get(2).getGroupByPDB(new ResidueNumber(\"H\", 373, null));\n        System.out.println(qwe.getChemComp());\n        System.out.println(h.getSeqResSequence());\n        System.out.println(h.getAtomSequence());\n        System.out.println(h.getAtomGroups(GroupType.HETATM));\n        System.out.println(\"Entities: \" + s.getEntityInfos());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * An example demonstrating how to directly use the mmCif file parsing classes. This could potentially be used\n * to use the parser to populate a data-structure that is different from the biojava-structure data model.\n */\n", "repo_name": "biojava-master/", "id": 339, "method_signature": "void loadFromDirectAccess()"}, "319": {"callee_method_names": ["List<Component>.add", "List<Component>.add"], "method_name": "ProteinModificationRegistryTest.testRegisterModification", "method_implementation": "{\n    // define the involved components, in this case two cystines (CYS)\n    List<Component> components = new ArrayList<Component>(2);\n    components.add(Component.of(\"CYS\"));\n    components.add(Component.of(\"CYS\"));\n    // define the atom linkages between the components, in this case the SG atoms on both CYS groups\n    ModificationLinkage linkage = new ModificationLinkage(components, 0, \"SG\", 1, \"SG\");\n    // define the modification condition, i.e. what components are involved and what atoms are linked between them\n    ModificationCondition condition = new ModificationConditionImpl(components, Collections.singletonList(linkage));\n    // build a modification\n    ProteinModification mod = new ProteinModificationImpl.Builder(\"0018_test\", ModificationCategory.CROSS_LINK_2, ModificationOccurrenceType.NATURAL, condition).setDescription(\"A protein modification that effectively cross-links two L-cysteine residues to form L-cystine.\").setFormula(\"C 6 H 8 N 2 O 2 S 2\").setResidId(\"AA0025\").setResidName(\"L-cystine\").setPsimodId(\"MOD:00034\").setPsimodName(\"L-cystine (cross-link)\").setSystematicName(\"(R,R)-3,3'-disulfane-1,2-diylbis(2-aminopropanoic acid)\").addKeyword(\"disulfide bond\").addKeyword(\"redox-active center\").build();\n    //register the modification\n    ProteinModificationRegistry.register(mod);\n    Assert.assertNotNull(ProteinModificationRegistry.getById(\"0018_test\"));\n}", "repo_id": "9", "comment": "/**\n * Note: if you change this unit test, also change the cook book:\n * http://www.biojava.org/wiki/BioJava:CookBook3:AddProtMod\n */\n", "repo_name": "biojava-master/", "id": 319, "method_signature": "void testRegisterModification()"}, "1260": {"callee_method_names": ["Chain.getSeqResGroups", "Chain.getAtomGroups", "String.length", "String.charAt", "List<Group>.size", "List<Group>.get"], "method_name": "MmtfUtils.addSeqRes", "method_implementation": "{\n    List<Group> seqResGroups = modelChain.getSeqResGroups();\n    GroupType chainType = getChainType(modelChain.getAtomGroups());\n    for (int i = 0; i < sequence.length(); i++) {\n        char singleLetterCode = sequence.charAt(i);\n        Group group = null;\n        if (seqResGroups.size() > i) {\n            group = seqResGroups.get(i);\n        }\n        if (group != null) {\n            continue;\n        }\n        group = getSeqResGroup(singleLetterCode, chainType);\n        addGroupAtId(seqResGroups, group, i);\n    }\n}", "repo_id": "9", "comment": "/**\n * Add the missing groups to the SeqResGroups.\n * @param modelChain the chain to add the information for\n * @param sequence the sequence of the construct\n */\n", "repo_name": "biojava-master/", "id": 1260, "method_signature": "void addSeqRes(Chain, String)"}, "863": {"callee_method_names": ["TreeMap<Key, Value>.tailMap", "SortedMap<Key, Value>.isEmpty", "SortedMap<Key, Value>.firstKey"], "method_name": "SymbolTable.ceil", "method_implementation": "{\n    SortedMap<Key, Value> tail = st.tailMap(k);\n    if (tail.isEmpty())\n        return null;\n    else\n        return tail.firstKey();\n}", "repo_id": "9", "comment": "/**\n * Return the smallest key in the table >= k.\n */\n", "repo_name": "biojava-master/", "id": 863, "method_signature": "Key ceil(Key)"}, "1441": {"callee_method_ids": [1424], "callee_method_names": ["ArrayList<CrystalTransform>.iterator", "Iterator<CrystalTransform>.hasNext", "Iterator<CrystalTransform>.next", "CrystalTransform.isEquivalent", "Logger.debug", "Iterator<CrystalTransform>.remove"], "method_name": "CrystalBuilder.isRedundantTransform", "method_implementation": "{\n    Iterator<CrystalTransform> it = visitedCrystalTransforms.iterator();\n    while (it.hasNext()) {\n        CrystalTransform v = it.next();\n        if (tt.isEquivalent(v)) {\n            logger.debug(\"Skipping redundant transformation: \" + tt + \", equivalent to \" + v);\n            // there's only 1 possible equivalent partner for each visited matrix\n            // (since the equivalent is its inverse matrix and the inverse matrix is unique)\n            // thus once the partner has been seen, we don't need to check it ever again\n            it.remove();\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Checks whether given transformId/translation is symmetry redundant\n * Two transformations are symmetry redundant if their matrices (4d) multiplication gives the identity, i.e.\n * if one is the inverse of the other.\n * @param tt\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1441, "method_signature": "boolean isRedundantTransform(CrystalTransform)"}, "3176": {"callee_method_names": [], "method_name": "TranscriptSequence.getStopCodonSequence", "method_implementation": "{\n    return stopCodonSequence;\n}", "repo_id": "9", "comment": "/**\n * @return the stopCodonSequence\n */\n", "repo_name": "biojava-master/", "id": 3176, "method_signature": "StopCodonSequence getStopCodonSequence()"}, "2376": {"callee_method_names": [], "method_name": "Fastq.builder", "method_implementation": "{\n    return new FastqBuilder(fastq);\n}", "repo_id": "9", "comment": "/**\n * Create and return a new FastqBuilder configured from the\n * specified FASTQ formatted sequence.\n * The FastqBuilder will not be null.\n *\n * @since 6.0.0\n * @param fastq FASTQ formatted sequence, must not be null\n * @return a new FastqBuilder configured from the specified FASTQ\n *    formatted sequence\n */\n", "repo_name": "biojava-master/", "id": 2376, "method_signature": "FastqBuilder builder(Fastq)"}, "376": {"callee_method_names": ["Atom.getX", "Atom.getY", "Atom.getZ", "Atom.setCoords"], "method_name": "Calc.getCentroid", "method_implementation": "{\n    // if we don't catch this case, the centroid returned is (NaN,NaN,NaN), which can cause lots of problems down the line\n    if (atomSet.length == 0)\n        throw new IllegalArgumentException(\"Atom array has length 0, can't calculate centroid!\");\n    double[] coords = new double[3];\n    coords[0] = 0;\n    coords[1] = 0;\n    coords[2] = 0;\n    for (Atom a : atomSet) {\n        coords[0] += a.getX();\n        coords[1] += a.getY();\n        coords[2] += a.getZ();\n    }\n    int n = atomSet.length;\n    coords[0] = coords[0] / n;\n    coords[1] = coords[1] / n;\n    coords[2] = coords[2] / n;\n    Atom vec = new AtomImpl();\n    vec.setCoords(coords);\n    return vec;\n}", "repo_id": "9", "comment": "/**\n * Returns the centroid of the set of atoms.\n *\n * @param atomSet\n *            a set of Atoms\n * @return an Atom representing the Centroid of the set of atoms\n */\n", "repo_name": "biojava-master/", "id": 376, "method_signature": "Atom getCentroid(Atom[])"}, "259": {"callee_method_names": ["Map<String, Set<ProteinModification>>.keySet"], "method_name": "ProteinModificationRegistry.allPdbccIds", "method_implementation": "{\n    lazyInit();\n    Set<String> ret = byPdbccId.keySet();\n    return Collections.unmodifiableSet(ret);\n}", "repo_id": "9", "comment": "/**\n * @return set of PDBCC IDs of all registered ProteinModifications.\n */\n", "repo_name": "biojava-master/", "id": 259, "method_signature": "Set<String> allPdbccIds()"}, "2609": {"callee_method_names": [], "method_name": "ConcurrencyTools.setThreadPoolCPUsFraction", "method_implementation": "{\n    setThreadPoolSize(Math.max(1, Math.round(fraction * Runtime.getRuntime().availableProcessors())));\n}", "repo_id": "9", "comment": "/**\n * Sets thread pool to a given fraction of the available processors.\n *\n * @param fraction portion of available processors to use in thread pool\n */\n", "repo_name": "biojava-master/", "id": 2609, "method_signature": "void setThreadPoolCPUsFraction(float)"}, "2618": {"callee_method_names": ["BufferedReader.readLine", "StringBuilder.append", "InputStream.close", "Logger.error", "StringBuilder.toString"], "method_name": "StringManipulationHelper.convertStreamToString", "method_implementation": "{\n    BufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n    StringBuilder sb = new StringBuilder();\n    String line = null;\n    try {\n        while ((line = reader.readLine()) != null) {\n            sb.append(line).append(UNIX_NEWLINE);\n        }\n    } catch (IOException e) {\n        // logger.error(\"Exception: \", e);\n    } finally {\n        try {\n            stream.close();\n        } catch (IOException e) {\n            logger.error(\"Exception: \", e);\n        }\n    }\n    return sb.toString();\n}", "repo_id": "9", "comment": "/**\n * Converts an InputStream of text to a String, closing the stream\n * before returning.\n * <ul>\n * <li> Newlines are converted to Unix newlines (\\n)\n * <li> Default charset encoding is used to read the stream.\n * <li> Any IOException reading the stream is 'squashed' and not made\n *   available to caller\n * <li> An additional newline is appended at the end of the string.\n * <ul>\n * @author andreas\n * @param stream\n * @return a possibly empty but non-null String\n */\n", "repo_name": "biojava-master/", "id": 2618, "method_signature": "String convertStreamToString(InputStream)"}, "2521": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum35", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum35\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 35 matrix by Henikoff & Henikoff\n * @return Blosum 35 matrix\n */\n", "repo_name": "biojava-master/", "id": 2521, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum35()"}, "1831": {"callee_method_ids": [399, 400, 404], "callee_method_names": ["Group.size", "GroupIterator.clone", "GroupIterator.hasNext", "GroupIterator.next", "Group.size"], "method_name": "AtomIterator.hasNext", "method_implementation": "{\n    // trying to iterate over an empty structure...\n    if (group == null)\n        return false;\n    // if there is another group ...\n    if (current_atom_pos < group.size() - 1) {\n        return true;\n    } else {\n        // search through the next groups if they contain an atom\n        if (groupiter != null) {\n            GroupIterator tmp = (GroupIterator) groupiter.clone();\n            while (tmp.hasNext()) {\n                Group tmpg = tmp.next();\n                if (tmpg.size() > 0) {\n                    return true;\n                }\n            }\n        } else {\n            // just an iterator over one group ...\n            return false;\n        }\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Is there a next atom ?\n * @return true if there is an atom after the current one\n */\n", "repo_name": "biojava-master/", "id": 1831, "method_signature": "boolean hasNext()"}, "1127": {"callee_method_names": [], "method_name": "LocalPDBDirectory.getObsoleteBehavior", "method_implementation": "{\n    return obsoleteBehavior;\n}", "repo_id": "9", "comment": "/**\n * Returns how this instance deals with obsolete entries. Note that this\n * setting may be ignored by some implementations or in some situations,\n * such as when {@link #isAutoFetch()} is false.\n *\n * <p>For most implementations, the default value is\n * {@link ObsoleteBehavior#THROW_EXCEPTION THROW_EXCEPTION}.\n *\n * @return The ObsoleteBehavior\n * @since 4.0.0\n */\n", "repo_name": "biojava-master/", "id": 1127, "method_signature": "ObsoleteBehavior getObsoleteBehavior()"}, "2833": {"callee_method_names": [], "method_name": "GenericGenbankHeaderParser.setDescription", "method_implementation": "{\n    if (this.description != null)\n        throw new ParserException(\"Current BioEntry already has a description\");\n    this.description = description;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2833, "method_signature": "void setDescription(String)"}, "709": {"callee_method_names": [], "method_name": "OptimalCECPParameters.getCPPoint", "method_implementation": "{\n    return cpPoint;\n}", "repo_id": "9", "comment": "/**\n * @return the cpPoint\n */\n", "repo_name": "biojava-master/", "id": 709, "method_signature": "Integer getCPPoint()"}, "510": {"callee_method_names": [], "method_name": "AFPChain.hashCode", "method_implementation": "{\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + blockNum;\n    result = prime * result + ca1Length;\n    result = prime * result + ca2Length;\n    result = prime * result + Arrays.hashCode(optAln);\n    result = prime * result + Arrays.hashCode(optLen);\n    result = prime * result + optLength;\n    return result;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see java.lang.Object#hashCode()\n\t */\n", "repo_name": "biojava-master/", "id": 510, "method_signature": "int hashCode()"}, "1589": {"callee_method_ids": [929, 937], "callee_method_names": ["Map<ResidueNumber, Integer>.put", "SecStrucGroup.getResidueNumber", "SecStrucGroup.getCA", "Grid.addAtoms", "Grid.getAtomContacts"], "method_name": "SecStrucCalc.initContactSet", "method_implementation": "{\n    // Initialise an array of atoms\n    atoms = new Atom[groups.length];\n    // Remake this local var\n    indResMap = new HashMap<>();\n    for (int i = 0; i < groups.length; i++) {\n        SecStrucGroup one = groups[i];\n        indResMap.put(one.getResidueNumber(), i);\n        atoms[i] = one.getCA();\n    }\n    Grid grid = new Grid(CA_MIN_DIST);\n    if (atoms.length == 0) {\n        contactSet = new AtomContactSet(CA_MIN_DIST);\n    } else {\n        grid.addAtoms(atoms);\n        contactSet = grid.getAtomContacts();\n    }\n}", "repo_id": "9", "comment": "/**\n * Function to generate the contact sets\n */\n", "repo_name": "biojava-master/", "id": 1589, "method_signature": "void initContactSet()"}, "1639": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setOptimizeAlignment", "method_implementation": "{\n    this.optimizeAlignment = optimizeAlignment;\n}", "repo_id": "9", "comment": "/**\n * Whether the alignment algorithm should try its best to optimize the alignment,\n * or we are happy with a quick and dirty result. Effect depends on implementation\n * of the specific algorithm's method.\t *\n *\n * @param optimizeAlignment\n */\n", "repo_name": "biojava-master/", "id": 1639, "method_signature": "void setOptimizeAlignment(boolean)"}, "3200": {"callee_method_names": ["URL.getFile"], "method_name": "SearchIOTest.testConstructorWithoutFactoryGuess", "method_implementation": "{\n    String resource = \"/org/biojava/nbio/core/search/io/blast/testBlastReport.blastxml\";\n    URL resourceURL = getClass().getResource(resource);\n    File file = new File(resourceURL.getFile());\n    ResultFactory blastResultFactory = new BlastXMLParser();\n    final SearchIO instance;\n    try {\n        instance = new SearchIO(file, blastResultFactory);\n    } catch (Exception e) {\n        fail(\"test failed:\\n\" + e.getMessage());\n    }\n}", "repo_id": "9", "comment": "/**\n * Constructor test specifying Factory\n */\n", "repo_name": "biojava-master/", "id": 3200, "method_signature": "void testConstructorWithoutFactoryGuess()"}, "356": {"callee_method_names": ["AminoAcid.getC", "AminoAcid.getN"], "method_name": "Calc.isConnected", "method_implementation": "{\n    Atom C = null;\n    Atom N = null;\n    C = a.getC();\n    N = b.getN();\n    if (C == null || N == null)\n        return false;\n    // one could also check if the CA atoms are < 4 A...\n    double distance = getDistance(C, N);\n    return distance < 2.5;\n}", "repo_id": "9", "comment": "/**\n * Test if two amino acids are connected, i.e. if the distance from C to N <\n * 2.5 Angstrom.\n *\n * If one of the AminoAcids has an atom missing, returns false.\n *\n * @param a\n *            an AminoAcid object\n * @param b\n *            an AminoAcid object\n * @return true if ...\n */\n", "repo_name": "biojava-master/", "id": 356, "method_signature": "boolean isConnected(AminoAcid, AminoAcid)"}, "3256": {"callee_method_names": ["MultipleAlignmentGUI.setVisible"], "method_name": "MenuCreator.showMultipleDialog", "method_implementation": "{\n    MultipleAlignmentGUI gui = MultipleAlignmentGUI.getInstance();\n    gui.setVisible(true);\n}", "repo_id": "9", "comment": "/**\n * Provide a display for the multiple structure alignment.\n */\n", "repo_name": "biojava-master/", "id": 3256, "method_signature": "void showMultipleDialog()"}, "1574": {"callee_method_names": [], "method_name": "Site.setDescription", "method_implementation": "{\n    this.description = description;\n}", "repo_id": "9", "comment": "/**\n * sets the REMARK 800 description of the site\n */\n", "repo_name": "biojava-master/", "id": 1574, "method_signature": "void setDescription(String)"}, "3105": {"callee_method_names": [], "method_name": "DBReferenceInfo.setProperties", "method_implementation": "{\n    this.properties = properties;\n}", "repo_id": "9", "comment": "/**\n * @param properties the properties to set\n */\n", "repo_name": "biojava-master/", "id": 3105, "method_signature": "void setProperties(LinkedHashMap)"}, "3779": {"callee_method_ids": [3792], "callee_method_names": ["KaplanMeierFigure.getSurvivalFitInfo", "KaplanMeierFigure.getWidth"], "method_name": "NumbersAtRiskPanel.setKaplanMeierFigure", "method_implementation": "{\n    this.kmf = kmf;\n    int numRows = kmf.getSurvivalFitInfo().getStrataInfoHashMap().size();\n    int height = (numRows + 1) * getFontMetrics(getFont()).getHeight();\n    int width = kmf.getWidth();\n    setPreferredSize(new Dimension(width, height));\n    this.setSize(width, height);\n}", "repo_id": "9", "comment": "/**\n * Pick up needed info and details from the KM Figure\n * @param kmf\n */\n", "repo_name": "biojava-master/", "id": 3779, "method_signature": "void setKaplanMeierFigure(KaplanMeierFigure)"}, "2349": {"callee_method_names": ["String.toString", "String.toString"], "method_name": "FastqBuilder.build", "method_implementation": "{\n    if (description == null) {\n        throw new IllegalStateException(\"description must not be null\");\n    }\n    if (sequence == null) {\n        throw new IllegalStateException(\"sequence must not be null\");\n    }\n    if (quality == null) {\n        throw new IllegalStateException(\"quality must not be null\");\n    }\n    if (!sequenceAndQualityLengthsMatch()) {\n        throw new IllegalStateException(\"sequence and quality scores must be the same length\");\n    }\n    Fastq fastq = new Fastq(description, sequence.toString(), quality.toString(), variant);\n    return fastq;\n}", "repo_id": "9", "comment": "/**\n * Build and return a new FASTQ formatted sequence configured from the properties of this builder.\n *\n * @return a new FASTQ formatted sequence configured from the properties of this builder\n * @throws IllegalStateException if the configuration of this builder results in an illegal state\n */\n", "repo_name": "biojava-master/", "id": 2349, "method_signature": "Fastq build()"}, "1712": {"callee_method_names": [], "method_name": "ResidueRangeAndLength.iterator", "method_implementation": "{\n    // just a bit faster\n    return super.iterator(map);\n}", "repo_id": "9", "comment": "/**\n * Returns a new Iterator over every {@link ResidueNumber} in this ResidueRange.\n * Stores the contents of {@code map} until the iterator is finished, so calling code should set the iterator to {@code null} if it did not finish.\n */\n", "repo_name": "biojava-master/", "id": 1712, "method_signature": "Iterator<ResidueNumber> iterator(AtomPositionMap)"}, "3094": {"callee_method_names": [], "method_name": "Qualifier.getName", "method_implementation": "{\n    return name;\n}", "repo_id": "9", "comment": "/**\n * @return the name\n */\n", "repo_name": "biojava-master/", "id": 3094, "method_signature": "String getName()"}, "1955": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setTmIntra", "method_implementation": "{\n    this.tmIntra = tmIntra;\n}", "repo_id": "9", "comment": "/**\n * @param tmIntra the tmIntra to set\n */\n", "repo_name": "biojava-master/", "id": 1955, "method_signature": "void setTmIntra(double)"}, "790": {"callee_method_names": ["Atom[].getGroup", "Atom[].getGroup", "AFPChain.setName2", "Atom[].getGroup", "AFPChain.getAlignScore", "AFPChain.getAlignScore"], "method_name": "OptimalCECPMain.alignOptimal", "method_implementation": "{\n    long startTime = System.currentTimeMillis();\n    if (alignments != null && alignments.length != ca2.length) {\n        throw new IllegalArgumentException(\"scores param should have same length as ca2\");\n    }\n    AFPChain unaligned = super.align(ca1, ca2, param);\n    AFPChain bestAlignment = unaligned;\n    if (debug) {\n        // print progress bar header\n        System.out.print(\"|\");\n        for (int cp = 1; cp < ca2.length - 1; cp++) {\n            System.out.print(\"=\");\n        }\n        System.out.println(\"|\");\n        System.out.print(\".\");\n    }\n    if (alignments != null) {\n        alignments[0] = unaligned;\n    }\n    for (int cp = 1; cp < ca2.length; cp++) {\n        // clone ca2 to prevent side effects from propegating\n        Atom[] ca2p = StructureTools.cloneAtomArray(ca2);\n        //permute one each time. Alters ca2p as a side effect\n        AFPChain currentAlignment = alignPermuted(ca1, ca2p, param, cp);\n        // increment progress bar\n        if (debug)\n            System.out.print(\".\");\n        // fix up names, since cloning ca2 wipes it\n        if (ca2.length != 0 && ca2[0].getGroup().getChain() != null && ca2[0].getGroup().getChain().getStructure() != null) {\n            currentAlignment.setName2(ca2[0].getGroup().getChain().getStructure().getName() + \" CP=\" + cp);\n        }\n        double currentScore = currentAlignment.getAlignScore();\n        if (alignments != null) {\n            alignments[cp] = currentAlignment;\n        }\n        if (currentScore > bestAlignment.getAlignScore()) {\n            bestAlignment = currentAlignment;\n        }\n    }\n    if (debug) {\n        long elapsedTime = System.currentTimeMillis() - startTime;\n        System.out.println();\n        System.out.format(\"%d alignments took %.4f s (%.1f ms avg)\\n\", ca2.length, elapsedTime / 1000., (double) elapsedTime / ca2.length);\n    }\n    return bestAlignment;\n}", "repo_id": "9", "comment": "/**\n * Finds the optimal alignment between two proteins allowing for a circular\n * permutation (CP).\n *\n * This algorithm performs a CE alignment for each possible CP site. This is\n * quite slow. Use {@link #alignHeuristic(Atom[], Atom[], Object)} for a\n * faster algorithm.\n *\n * @param ca1 CA atoms of the first protein\n * @param ca2 CA atoms of the second protein\n * @param param {@link CeParameters} object\n * @param alignments If not null, should be an empty array of the same length as\n *  ca2. This will be filled with the alignments from permuting ca2 by\n *  0 to n-1 residues.\n * @return The best-scoring alignment\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 790, "method_signature": "AFPChain alignOptimal(Atom[], Atom[], Object, AFPChain[])"}, "3343": {"callee_method_names": ["ColorSpace.toRGB"], "method_name": "HSVColorSpace.fromCIEXYZ", "method_implementation": "{\n    ColorSpace CIEXYZcs = ColorSpace.getInstance(CS_CIEXYZ);\n    float[] rgb = CIEXYZcs.toRGB(ciexyzvalue);\n    return this.fromRGB(rgb);\n}", "repo_id": "9", "comment": "/**\n * @param ciexyzvalue The color components in CIEXYZ colorspace\n * @return the equivalent HSV components\n * @see java.awt.color.ColorSpace#fromCIEXYZ(float[])\n */\n", "repo_name": "biojava-master/", "id": 3343, "method_signature": "float[] fromCIEXYZ(float[])"}, "1492": {"callee_method_names": [], "method_name": "CalcPoint.GTSlikeScore", "method_implementation": "{\n    if (x.length != y.length) {\n        throw new IllegalArgumentException(\"Point arrays are not of the same length.\");\n    }\n    int contacts = 0;\n    for (Point3d px : x) {\n        double minDist = Double.MAX_VALUE;\n        for (Point3d py : y) {\n            minDist = Math.min(minDist, px.distanceSquared(py));\n        }\n        if (minDist > 64)\n            continue;\n        contacts++;\n        if (minDist > 16)\n            continue;\n        contacts++;\n        if (minDist > 4)\n            continue;\n        contacts++;\n        if (minDist > 1)\n            continue;\n        contacts++;\n    }\n    return contacts * 25.0 / x.length;\n}", "repo_id": "9", "comment": "/*\n\t * Needs documentation!\n\t *\n\t * @param x\n\t *\n\t * @param y\n\t *\n\t * @return\n\t */\n", "repo_name": "biojava-master/", "id": 1492, "method_signature": "double GTSlikeScore(Point3d[], Point3d[])"}, "2974": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.getInverse", "method_implementation": "{\n    return SequenceMixin.inverse(this);\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2974, "method_signature": "SequenceView<C> getInverse()"}, "3440": {"callee_method_names": ["StructureViewer.getSelection"], "method_name": "StructureViewerTest.testGetSelection", "method_implementation": "{\n    if (java.awt.GraphicsEnvironment.isHeadless())\n        return;\n    StructureViewer instance = new StructureViewerImpl();\n    Selection expResult = null;\n    Selection result = instance.getSelection();\n    Assert.assertEquals(expResult, result);\n    // TODO review the generated test code and remove the default call to fail.\n    //  fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of getSelection method, of class StructureViewer.\n */\n", "repo_name": "biojava-master/", "id": 3440, "method_signature": "void testGetSelection()"}, "321": {"callee_method_names": [], "method_name": "ProteinModificationRegistryTest.testGetBy", "method_implementation": "{\n    ProteinModification mod;\n    Set<ProteinModification> mods;\n    mod = ProteinModificationRegistry.getById(\"0001\");\n    Assert.assertNotNull(mod);\n    // a set of protein modifications by RESID ID\n    mods = ProteinModificationRegistry.getByResidId(\"AA0151\");\n    Assert.assertNotNull(mods);\n    // a set of protein modifications by PSI-MOD ID\n    mods = ProteinModificationRegistry.getByPsimodId(\"MOD:00305\");\n    Assert.assertNotNull(mods);\n    // a set of protein modifications by PDBCC ID\n    mods = ProteinModificationRegistry.getByPdbccId(\"SEP\");\n    Assert.assertNotNull(mods);\n    // a set of protein modifications by category\n    mods = ProteinModificationRegistry.getByCategory(ModificationCategory.ATTACHMENT);\n    Assert.assertNotNull(mods);\n    // a set of protein modifications by occurrence type\n    mods = ProteinModificationRegistry.getByOccurrenceType(ModificationOccurrenceType.NATURAL);\n    Assert.assertNotNull(mods);\n    // a set of protein modifications by a keyword\n    mods = ProteinModificationRegistry.getByKeyword(\"phosphoprotein\");\n    Assert.assertNotNull(mods);\n    // a set of protein modifications by involved components.\n    mods = ProteinModificationRegistry.getByComponent(Component.of(\"FAD\"));\n    Assert.assertNotNull(mods);\n}", "repo_id": "9", "comment": "/**\n * Note: if you change this unit test, also change the cook book:\n * http://www.biojava.org/wiki/BioJava:CookBook3:SupportedProtMod\n */\n", "repo_name": "biojava-master/", "id": 321, "method_signature": "void testGetBy()"}, "2704": {"callee_method_names": ["String.length", "String.substring", "String.substring", "String.substring"], "method_name": "GenericInsdcHeaderFormat._wrap_location", "method_implementation": "{\n    int length = MAX_WIDTH - QUALIFIER_INDENT;\n    if (location.length() <= length) {\n        return location;\n    }\n    int index = location.substring(0, length).lastIndexOf(\",\");\n    if (-1 == index) {\n        //No good place to split (!)\n        return location;\n    }\n    return location.substring(0, index + 1) + lineSep + QUALIFIER_INDENT_STR + _wrap_location(location.substring(index + 1));\n}", "repo_id": "9", "comment": "/**\n * Split a feature location into lines (break at commas).\n * @param location\n */\n", "repo_name": "biojava-master/", "id": 2704, "method_signature": "String _wrap_location(String)"}, "2985": {"callee_method_names": [], "method_name": "BitSequenceReader.countCompounds", "method_implementation": "{\n    return SequenceMixin.countCompounds(this, compounds);\n}", "repo_id": "9", "comment": "/**\n * Counts the number of times a compound appears in this sequence store\n */\n", "repo_name": "biojava-master/", "id": 2985, "method_signature": "int countCompounds(C[])"}, "2931": {"callee_method_names": [], "method_name": "AbstractSequence.setComments", "method_implementation": "{\n    this.comments = comments;\n}", "repo_id": "9", "comment": "/**\n * Set comments.\n * @param comments\n */\n", "repo_name": "biojava-master/", "id": 2931, "method_signature": "void setComments(List)"}, "3371": {"callee_method_names": [], "method_name": "SqrtColorMapper.transform", "method_implementation": "{\n    double sqrtValue = Double.NEGATIVE_INFINITY;\n    if (value >= 0)\n        sqrtValue = Math.sqrt(value);\n    return sqrtValue;\n}", "repo_id": "9", "comment": "/**\n * Return sqrt(value).\n * If value is negative, return the color corresponding to negative infinity.\n *\n * @param value Value to be mapped\n * @return sqrt(value), or NEGATIVE_INFINITY\n * @see org.biojava.nbio.structure.gui.util.color.ContinuousColorMapper#getColor(double)\n */\n", "repo_name": "biojava-master/", "id": 3371, "method_signature": "double transform(double)"}, "2047": {"callee_method_names": ["AxisAngle4d.getGroup", "List<Group>.add", "Logger.info"], "method_name": "SymmetryTools.getGroups", "method_implementation": "{\n    List<Group> groups = new ArrayList<Group>(rAtoms.length);\n    for (Atom a : rAtoms) {\n        Group g = a.getGroup();\n        if (g != null)\n            groups.add(g);\n        else\n            logger.info(\"Group not found for representative Atom {}\", a);\n    }\n    return groups;\n}", "repo_id": "9", "comment": "/**\n * Returns the List of Groups of the corresponding representative Atom\n * array. The representative Atom array needs to fulfill: no two Atoms are\n * from the same Group and Groups are sequential (connected in the original\n * Structure), except if they are from different Chains.\n *\n * @param rAtoms\n *            array of representative Atoms (CA, P, etc).\n * @return List of Groups\n */\n", "repo_name": "biojava-master/", "id": 2047, "method_signature": "List<Group> getGroups(Atom[])"}, "2527": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum62", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum62\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 62 matrix by Henikoff & Henikoff\n * @return Blosum 62 matrix\n */\n", "repo_name": "biojava-master/", "id": 2527, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum62()"}, "1327": {"callee_method_names": [], "method_name": "FileParsingParameters.setAtomCaThreshold", "method_implementation": "{\n    this.atomCaThreshold = atomCaThreshold;\n}", "repo_id": "9", "comment": "/**\n * The maximum number of atoms that will be parsed before the parser switches to a CA-only\n * representation of the PDB file. If this limit is exceeded also the SEQRES groups will be\n * ignored.\n * @param atomCaThreshold maximum number of atoms for all atom representation.\n */\n", "repo_name": "biojava-master/", "id": 1327, "method_signature": "void setAtomCaThreshold(int)"}, "2074": {"callee_method_ids": [2075], "callee_method_names": ["CeSymmResult.isRefined", "CeSymmResult.getParams", "CeSymmResult.getMultipleAlignment", "SymmOptimizer.optimize", "CeSymmResult.setMultipleAlignment", "Logger.debug", "MultipleAlignmentEnsemble.getMessage"], "method_name": "CeSymm.analyzeLevel", "method_implementation": "{\n    if (atoms.length < 1)\n        throw new IllegalArgumentException(\"Empty Atom array given.\");\n    CeSymmResult result = align(atoms, params);\n    if (result.isRefined()) {\n        // STEP 5: symmetry alignment optimization\n        if (result.getParams().getOptimization()) {\n            try {\n                MultipleAlignment msa = result.getMultipleAlignment();\n                SymmOptimizer optimizer = new SymmOptimizer(result);\n                msa = optimizer.optimize();\n                result.setMultipleAlignment(msa);\n            } catch (RefinerFailedException e) {\n                logger.debug(\"Optimization failed:{}\", e.getMessage());\n            }\n        }\n    }\n    return result;\n}", "repo_id": "9", "comment": "/**\n * Analyze a single level of symmetry.\n *\n * @param atoms\n *            Atom array of the current level\n * @return CeSymmResult\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2074, "method_signature": "CeSymmResult analyzeLevel(Atom[], CESymmParameters)"}, "2245": {"callee_method_ids": [641, 1330, 1322, 1095], "callee_method_names": ["AtomCache.setFiletype", "AtomCache.getFileParsingParams", "FileParsingParameters.setCreateAtomBonds", "FileParsingParameters.setAlignSeqRes", "FileParsingParameters.setParseBioAssembly", "DownloadChemCompProvider.checkDoFirstInstall", "AtomCache.setFileParsingParams"], "method_name": "TestMmtfUtils.setUpBioJava", "method_implementation": "{\n    // Set up the atom cache etc\n    AtomCache cache = new AtomCache();\n    cache.setFiletype(StructureFiletype.CIF);\n    FileParsingParameters params = cache.getFileParsingParams();\n    params.setCreateAtomBonds(true);\n    params.setAlignSeqRes(true);\n    params.setParseBioAssembly(true);\n    DownloadChemCompProvider cc = new DownloadChemCompProvider();\n    ChemCompGroupFactory.setChemCompProvider(cc);\n    cc.checkDoFirstInstall();\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    return cache;\n}", "repo_id": "9", "comment": "/**\n * Set up the configuration parameters for BioJava.\n */\n", "repo_name": "biojava-master/", "id": 2245, "method_signature": "AtomCache setUpBioJava()"}, "2020": {"callee_method_names": [], "method_name": "Prism.getInscribedRadius", "method_implementation": "{\n    double side = getSideLengthFromCircumscribedRadius(circumscribedRadius, n);\n    return getInscribedRadiusFromSideLength(side, n);\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of an inscribed sphere, that is tangent to each\n * of the icosahedron's faces\n * @return the inscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2020, "method_signature": "double getInscribedRadius()"}, "2867": {"callee_method_names": [], "method_name": "ABITrace.calculateScale", "method_implementation": "{\n    double newScale = 0.0;\n    double max = (double) getMaximum();\n    double ht = (double) height;\n    newScale = ((ht - 50.0)) / max;\n    return newScale;\n}", "repo_id": "9", "comment": "/**\n * Returns the scaling factor necessary to allow all of the traces to fit vertically\n * into the specified space.\n *\n * @param height - required height in pixels\n * @return - scaling factor\n */\n", "repo_name": "biojava-master/", "id": 2867, "method_signature": "double calculateScale(int)"}, "3680": {"callee_method_names": [], "method_name": "WaldTestInfo.getPvalue", "method_implementation": "{\n    double pvalue = ChiSq.chiSq(getTest(), df);\n    return pvalue;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3680, "method_signature": "double getPvalue()"}, "704": {"callee_method_names": [], "method_name": "MultipleAlignmentImpl.updateCache", "method_implementation": "{\n    updateCoreLength();\n    updateLength();\n}", "repo_id": "9", "comment": "/**\n * Updates all cached properties\n *\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 704, "method_signature": "void updateCache()"}, "1951": {"callee_method_names": [], "method_name": "QuatSymmetryScores.setRmsdCenters", "method_implementation": "{\n    this.rmsdCenters = rmsdCenters;\n}", "repo_id": "9", "comment": "/**\n * @param rmsdCenters the rmsdCenters to set\n */\n", "repo_name": "biojava-master/", "id": 1951, "method_signature": "void setRmsdCenters(double)"}, "1892": {"callee_method_names": ["ArrayList.get"], "method_name": "Stoichiometry.getComponent", "method_implementation": "{\n    return new Stoichiometry(Collections.singletonList(orderedClusters.get(i)), this.strategy, false);\n}", "repo_id": "9", "comment": "/**\n * Make a Stoichiometry object that corresponds to a single component.\n * @param i component index\n * @return new {@link Stoichiometry} object.\n */\n", "repo_name": "biojava-master/", "id": 1892, "method_signature": "Stoichiometry getComponent(int)"}, "2968": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.getCompoundSet", "method_implementation": "{\n    return compoundSet;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2968, "method_signature": "CompoundSet<C> getCompoundSet()"}, "3601": {"callee_method_ids": [3620], "callee_method_names": ["ArrayList<String>.add", "ArrayList<String>.add", "CoxInfo.dump", "double[][].printStackTrace"], "method_name": "CoxHelper.main", "method_implementation": "{\n    // TODO code application logic here\n    try {\n        if (true) {\n            String datafile = \"/Users/Scooter/scripps/ngs/DataSets/E2197/misc/ecoglabtransfer/500790/2013.05.10.12.28.58.313/clindasl0228.txt\";\n            ArrayList<String> variables = new ArrayList<String>();\n            variables.add(\"nndpos\");\n            variables.add(\"meno\");\n            //              variables.add(\"er1\");\n            //              variables.add(\"meno:er1\");\n            CoxInfo ci = CoxHelper.process(datafile, \"ttr\", \"recind\", \"wt\", \"sstrat\", \"Seq\", variables, false, true);\n            //  ci.dump();\n            System.out.println(ci);\n            System.out.println();\n            CoxCC.process(ci);\n            ci.dump();\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3601, "method_signature": "void main(String[])"}, "3372": {"callee_method_names": ["ContinuousColorMapper.getColor"], "method_name": "ContinuousColorMapperTransform.getColor", "method_implementation": "{\n    return mapper.getColor(transform(value));\n}", "repo_id": "9", "comment": "/**\n * Return the color corresponding to submapper.getColor(transform(value)).\n *\n * @param value Value to be mapped\n * @return color corresponding to transform(value)\n * @see org.biojava.nbio.structure.gui.util.color.ContinuousColorMapper#getColor(double)\n */\n", "repo_name": "biojava-master/", "id": 3372, "method_signature": "Color getColor(double)"}, "2470": {"callee_method_ids": [2424], "callee_method_names": ["Location.toString"], "method_name": "LocIterator.toString", "method_implementation": "{\n    return \"bounds=\" + mBounds.toString() + \"; pos=\" + mPosition + \"; winsize=\" + mWindowSize + \"; inc=\" + mIncrement;\n}", "repo_id": "9", "comment": "/**\n * Get string representation of iterator.\n *\n * @return Description of internal state.\n */\n", "repo_name": "biojava-master/", "id": 2470, "method_signature": "String toString()"}, "2554": {"callee_method_names": [], "method_name": "BlastTabularParser.setDatabaseReferences", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported for this parser.\");\n}", "repo_id": "9", "comment": "/**\n * Intended for use with run module.\n * Although possible, does not make a lot of sense to have it with limited\n * information such those in tabular report\n * @param sequences\n */\n", "repo_name": "biojava-master/", "id": 2554, "method_signature": "void setDatabaseReferences(List)"}, "2438": {"callee_method_ids": [2431], "callee_method_names": ["FeatureI.type", "FeatureList.add"], "method_name": "FeatureList.selectByType", "method_implementation": "{\n    FeatureList list = new FeatureList();\n    for (FeatureI f : this) {\n        if (f.type().equals(type)) {\n            list.add(f);\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Create a list of all features that are of the specified type, as defined by\n * the type() method of the features.\n * This might be, for example, \"exon\" or \"CDS\".\n *\n * @param type The type to match.\n * @return A list of features of the specified type.\n */\n", "repo_name": "biojava-master/", "id": 2438, "method_signature": "FeatureList selectByType(String)"}, "607": {"callee_method_ids": [487, 487, 489, 489], "callee_method_names": ["AFPChain.getBlockNum", "AFPChain.getBlockNum", "AFPChain.getOptAln", "AFPChain.getBlockSize", "AFPChain.getOptAln"], "method_name": "AlignmentTools.deleteColumn", "method_implementation": "{\n    // Check validity of the inputs\n    if (afpChain.getBlockNum() <= block) {\n        throw new IndexOutOfBoundsException(String.format(\"Block index requested (%d) is higher than the total number of AFPChain blocks (%d).\", block, afpChain.getBlockNum()));\n    }\n    if (afpChain.getOptAln()[block][0].length <= pos) {\n        throw new IndexOutOfBoundsException(String.format(\"Position index requested (%d) is higher than the total number of aligned position in the AFPChain block (%d).\", block, afpChain.getBlockSize()[block]));\n    }\n    int[][][] optAln = afpChain.getOptAln();\n    int[] newPos0 = new int[optAln[block][0].length - 1];\n    int[] newPos1 = new int[optAln[block][1].length - 1];\n    int position = 0;\n    for (int p = 0; p < optAln[block][0].length; p++) {\n        if (p == pos)\n            continue;\n        newPos0[position] = optAln[block][0][p];\n        newPos1[position] = optAln[block][1][p];\n        position++;\n    }\n    optAln[block][0] = newPos0;\n    optAln[block][1] = newPos1;\n    return AlignmentTools.replaceOptAln(optAln, afpChain, ca1, ca2);\n}", "repo_id": "9", "comment": "/**\n * Delete an alignment position from the original alignment object.\n *\n * @param afpChain\n *            original alignment, will be modified\n * @param ca1\n *            atom array, will not be modified\n * @param ca2\n *            atom array, will not be modified\n * @param block\n *            block of the alignment position\n * @param pos\n *            position index in the block\n * @return the original alignment, with the alignment position removed\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 607, "method_signature": "AFPChain deleteColumn(AFPChain, Atom[], Atom[], int, int)"}, "502": {"callee_method_names": [], "method_name": "AFPChain.setAlgorithmName", "method_implementation": "{\n    this.algorithmName = algorithmName;\n}", "repo_id": "9", "comment": "/**\n * Caution has to be made when changing the algorithmName of an AFPChain,\n * since downstream analysis methods (scores, display, etc) behave\n * differently if the alignment is flexible (created with FatCat).\n *\n * @param algorithmName\n */\n", "repo_name": "biojava-master/", "id": 502, "method_signature": "void setAlgorithmName(String)"}, "2706": {"callee_method_names": ["FeatureInterface<AbstractSequence<C>,C>.getChildrenFeatures", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "Formatter.format", "Formatter.toString", "Formatter.close", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "long.getStrand", "Formatter.format", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "long.getStrand", "Formatter.toString", "Formatter.close", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "ArrayList<String>.add", "Formatter.format", "Formatter.toString", "Formatter.close", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "ArrayList<String>.add", "Formatter.format", "Formatter.toString", "Formatter.close", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "FeatureInterface<AbstractSequence<C>,C>.getChildrenFeatures", "File.getLocations", "Formatter.format", "FeatureInterface<AbstractSequence<C>,C>.getLocations", "File.getLocations", "Formatter.toString", "Formatter.close", "FeatureInterface<AbstractSequence<C>,C>.getChildrenFeatures", "ArrayList<String>.add", "File.getLocations", "Formatter.format", "Formatter.toString", "Formatter.close", "FeatureInterface<AbstractSequence<C>,C>.getChildrenFeatures", "ArrayList<String>.add", "File.getLocations", "Formatter.format", "Formatter.toString", "Formatter.close"], "method_name": "GenericInsdcHeaderFormat._insdc_feature_location_string", "method_implementation": "{\n    if (feature.getChildrenFeatures().isEmpty()) {\n        if (feature.getLocations().getSubLocations().isEmpty()) {\n            //Non-recursive.\n            String location = _insdc_location_string_ignoring_strand_and_subfeatures(feature.getLocations(), record_length);\n            if (feature.getLocations().getStrand() == Strand.NEGATIVE) {\n                StringBuilder sb = new StringBuilder();\n                Formatter formatter = new Formatter(sb, Locale.US);\n                formatter.format(\"complement(%s)\", location);\n                String output = formatter.toString();\n                formatter.close();\n                location = output;\n            }\n            return location;\n        } else if (feature.getLocations().getStrand() == Strand.NEGATIVE) {\n            // As noted above, treat reverse complement strand features carefully:\n            // check if any of the sublocations strand differs from the parent features strand\n            for (Location l : feature.getLocations().getSubLocations()) {\n                if (l.getStrand() != Strand.NEGATIVE) {\n                    StringBuilder sb = new StringBuilder();\n                    Formatter formatter = new Formatter(sb, Locale.US);\n                    formatter.format(\"Inconsistent strands: %s for parent, %s for child\", feature.getLocations().getStrand(), l.getStrand());\n                    String output = formatter.toString();\n                    formatter.close();\n                    throw new RuntimeException(output);\n                }\n            }\n            StringBuilder sb = new StringBuilder();\n            Formatter formatter = new Formatter(sb, Locale.US);\n            ArrayList<String> locations = new ArrayList<String>();\n            for (Location l : feature.getLocations().getSubLocations()) {\n                locations.add(_insdc_location_string_ignoring_strand_and_subfeatures((AbstractLocation) l, record_length));\n            }\n            String location = StringManipulationHelper.join(locations, \",\");\n            formatter.format(\"complement(%s(%s))\", /* feature.location_operator */\n            \"join\", location);\n            String output = formatter.toString();\n            formatter.close();\n            return output;\n        } else {\n            //Convert feature sub-locations into joins\n            //This covers typical forward strand features, and also an evil mixed strand:\n            StringBuilder sb = new StringBuilder();\n            Formatter formatter = new Formatter(sb, Locale.US);\n            ArrayList<String> locations = new ArrayList<String>();\n            for (Location l : feature.getLocations().getSubLocations()) {\n                locations.add(_insdc_location_string_ignoring_strand_and_subfeatures((AbstractLocation) l, record_length));\n            }\n            String location = StringManipulationHelper.join(locations, \",\");\n            formatter.format(\"%s(%s)\", /*feature.location_operator*/\n            \"join\", location);\n            String output = formatter.toString();\n            formatter.close();\n            return output;\n        }\n    }\n    // As noted above, treat reverse complement strand features carefully:\n    if (feature.getLocations().getStrand() == Strand.NEGATIVE) {\n        for (FeatureInterface<?, ?> f : feature.getChildrenFeatures()) {\n            if (f.getLocations().getStrand() != Strand.NEGATIVE) {\n                StringBuilder sb = new StringBuilder();\n                Formatter formatter = new Formatter(sb, Locale.US);\n                formatter.format(\"Inconsistent strands: %s for parent, %s for child\", feature.getLocations().getStrand(), f.getLocations().getStrand());\n                String output = formatter.toString();\n                formatter.close();\n                throw new RuntimeException(output);\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        Formatter formatter = new Formatter(sb, Locale.US);\n        ArrayList<String> locations = new ArrayList<String>();\n        for (FeatureInterface<AbstractSequence<C>, C> f : feature.getChildrenFeatures()) {\n            locations.add(_insdc_location_string_ignoring_strand_and_subfeatures(f.getLocations(), record_length));\n        }\n        String location = StringManipulationHelper.join(locations, \",\");\n        formatter.format(\"complement(%s(%s))\", /*feature.location_operator*/\n        \"join\", location);\n        String output = formatter.toString();\n        formatter.close();\n        return output;\n    }\n    //This covers typical forward strand features, and also an evil mixed strand:\n    StringBuilder sb = new StringBuilder();\n    Formatter formatter = new Formatter(sb, Locale.US);\n    ArrayList<String> locations = new ArrayList<String>();\n    for (FeatureInterface<AbstractSequence<C>, C> f : feature.getChildrenFeatures()) {\n        locations.add(_insdc_location_string_ignoring_strand_and_subfeatures(f.getLocations(), record_length));\n    }\n    String location = StringManipulationHelper.join(locations, \",\");\n    formatter.format(\"%s(%s)\", /*feature.location_operator*/\n    \"join\", location);\n    String output = formatter.toString();\n    formatter.close();\n    return output;\n}", "repo_id": "9", "comment": "/**\n *  Build a GenBank/EMBL location string from a SeqFeature (PRIVATE).\n *\n * \tThere is a choice of how to show joins on the reverse complement strand,\n * \tGenBank used \"complement(join(1,10),(20,100))\" while EMBL used to use\n * \t\"join(complement(20,100),complement(1,10))\" instead (but appears to have\n * \tnow adopted the GenBank convention). Notice that the order of the entries\n * \tis reversed! This function therefore uses the first form. In this situation\n * \twe expect the parent feature and the two children to all be marked as\n * \tstrand == -1, and in the order 0:10 then 19:100.\n *\n * \tAlso need to consider dual-strand examples like these from the Arabidopsis\n * \tthaliana chloroplast NC_000932: join(complement(69611..69724),139856..140650)\n * \tgene ArthCp047, GeneID:844801 or its CDS (protein NP_051038.1 GI:7525057)\n * \twhich is further complicated by a splice:\n * \tjoin(complement(69611..69724),139856..140087,140625..140650)\n *\n * \tFor mixed this mixed strand feature, the parent SeqFeature should have\n * \tno strand (either 0 or None) while the child features should have either\n * \tstrand +1 or -1 as appropriate, and be listed in the order given here.\n *  @param feature\n *  @param record_length\n */\n", "repo_name": "biojava-master/", "id": 2706, "method_signature": "String _insdc_feature_location_string(FeatureInterface, int)"}, "1881": {"callee_method_names": ["Vector3d.sub", "Vector3d.dot"], "method_name": "HelixSolver.getRise", "method_implementation": "{\n    AxisAngle4d axis = getAxisAngle(transformation);\n    Vector3d h = new Vector3d(axis.x, axis.y, axis.z);\n    Vector3d p = new Vector3d();\n    p.sub(p1, p2);\n    return p.dot(h);\n}", "repo_id": "9", "comment": "/**\n * Returns the rise of a helix given the subunit centers of two adjacent\n * subunits and the helix transformation\n *\n * @param transformation\n *            helix transformation\n * @param p1\n *            center of one subunit\n * @param p2\n *            center of an adjacent subunit\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1881, "method_signature": "double getRise(Matrix4d, Point3d, Point3d)"}, "3072": {"callee_method_names": [], "method_name": "GeneSequence.getExonSequences", "method_implementation": "{\n    return new ArrayList<>(exonSequenceList);\n}", "repo_id": "9", "comment": "/**\n * Get the exons as an ArrayList. Modifying this list will not modify the underlying collection\n * @return exons\n */\n", "repo_name": "biojava-master/", "id": 3072, "method_signature": "ArrayList<ExonSequence> getExonSequences()"}, "3064": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "GeneSequence.getTranscript", "method_implementation": "{\n    return transcriptSequenceHashMap.get(accession);\n}", "repo_id": "9", "comment": "/**\n * Get the transcript sequence by accession\n * @param accession\n * @return the transcript\n */\n", "repo_name": "biojava-master/", "id": 3064, "method_signature": "TranscriptSequence getTranscript(String)"}, "3636": {"callee_method_names": [], "method_name": "CoxInfo.setMetaDataFilter", "method_implementation": "{\n    this.metaDataFilter = metaDataFilter;\n}", "repo_id": "9", "comment": "/**\n * @param metaDataFilter the metaDataFilter to set\n */\n", "repo_name": "biojava-master/", "id": 3636, "method_signature": "void setMetaDataFilter(LinkedHashMap)"}, "3166": {"callee_method_ids": [3062], "callee_method_names": ["GeneSequence.getStrand"], "method_name": "TranscriptSequence.getStrand", "method_implementation": "{\n    return parentGeneSequence.getStrand();\n}", "repo_id": "9", "comment": "/**\n * @return the strand\n */\n", "repo_name": "biojava-master/", "id": 3166, "method_signature": "Strand getStrand()"}, "2054": {"callee_method_names": ["StructureIdentifier.toCanonical", "MultipleAlignment.getBlocks", "Atom[].getGroup", "Block.getStartResidue", "Atom[].getGroup", "Block.getFinalResidue", "ResidueNumber.getChainName", "List<StructureIdentifier>.add"], "method_name": "CeSymmResult.getRepeatsID", "method_implementation": "{\n    if (!isRefined())\n        return null;\n    List<StructureIdentifier> repeats = new ArrayList<StructureIdentifier>(numRepeats);\n    PdbId pdbId = structureId.toCanonical().getPdbId();\n    Block align = multipleAlignment.getBlocks().get(0);\n    for (int su = 0; su < numRepeats; su++) {\n        // Get the start and end residues of the repeat\n        ResidueNumber res1 = atoms[align.getStartResidue(su)].getGroup().getResidueNumber();\n        ResidueNumber res2 = atoms[align.getFinalResidue(su)].getGroup().getResidueNumber();\n        ResidueRange range = new ResidueRange(res1.getChainName(), res1, res2);\n        StructureIdentifier id = new SubstructureIdentifier(pdbId, Arrays.asList(range));\n        repeats.add(id);\n    }\n    return repeats;\n}", "repo_id": "9", "comment": "/**\n * Return the symmetric repeats as structure identifiers, if the result is\n * symmetric and it was refined, return null otherwise.\n *\n * @return List of StructureIdentifiers or null if not defined\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2054, "method_signature": "List<StructureIdentifier> getRepeatsID()"}, "3312": {"callee_method_ids": [817, 818], "callee_method_names": ["Graphics2D.getStroke", "Graphics2D.setStroke", "AlternativeAlignment.getIdx1", "AlternativeAlignment.getIdx2", "Graphics.setColor", "Graphics.fillRect", "Graphics.fillRect", "Graphics.fillRect", "Graphics2D.setStroke"], "method_name": "JMatrixPanel.drawPairs", "method_implementation": "{\n    if (aligs == null)\n        return;\n    int nr = aligs.length;\n    Graphics2D g2D = (Graphics2D) g;\n    Stroke oldStroke = g2D.getStroke();\n    g2D.setStroke(stroke);\n    Color color;\n    float hue;\n    int width = Math.round(scale);\n    int w2 = width / 2;\n    for (int i = 0; i < aligs.length; i++) {\n        AlternativeAlignment a = aligs[i];\n        int[] idx1 = a.getIdx1();\n        int[] idx2 = a.getIdx2();\n        int xold = -1;\n        int yold = -1;\n        boolean start = true;\n        if ((selectedAlignmentPos != -1) && (selectedAlignmentPos == i)) {\n            color = Color.white;\n        } else {\n            hue = i * (1 / (float) nr);\n            color = Color.getHSBColor(hue, 1.0f, 1.0f);\n        }\n        g.setColor(color);\n        for (int j = 0; j < idx1.length; j++) {\n            int x1 = Math.round(idx1[j] * scale);\n            int y1 = Math.round(idx2[j] * scale);\n            if (!start) {\n                //g.drawLine(xold+1,yold,x1+1,y1);\n                //g2D.draw(new Line2D.Double(xold,yold,x1,y1));\n                g.fillRect(xold, yold, 2, 2);\n            } else {\n                g.fillRect(x1, y1, w2, w2);\n                start = false;\n            }\n            xold = x1;\n            yold = y1;\n        }\n        if (!start)\n            g.fillRect(xold, yold, w2, w2);\n    }\n    g2D.setStroke(oldStroke);\n}", "repo_id": "9", "comment": "/**\n * draw alternative alignments\n *\n * @param g\n */\n", "repo_name": "biojava-master/", "id": 3312, "method_signature": "void drawPairs(Graphics)"}, "1081": {"callee_method_names": ["File.isDirectory", "File.exists", "File.toPath", "Path.resolve", "File.getName", "Logger.error"], "method_name": "ZipChemCompProvider.addToZipFileSystem", "method_implementation": "{\n    boolean ret = false;\n    /* URIs in Java 7 cannot have spaces, must use Path instead\n         * and so, cannot use the properties map to describe need to create\n         * a new zip archive.  ZipChemCompProvider.initilizeZip to creates the\n         * missing zip file */\n    /*\n\t\t// convert the filename to a URI\n\t\tString uriString = \"jar:file:\" + zipFile.toUri().getPath();\n\t\tfinal URI uri = URI.create(uriString);\n\n\t\t// if filesystem doesn't exist, create one.\n\t\tfinal Map<String, String> env = new HashMap<>();\n\t\t// Create a new zip if one isn't present.\n\t\tif (!zipFile.toFile().exists()) {\n\t\t\tSystem.out.println(\"Need to create \" + zipFile.toString());\n\t\t}\n\t\tenv.put(\"create\", String.valueOf(!zipFile.toFile().exists()));\n\t\t// Specify the encoding as UTF -8\n\t\tenv.put(\"encoding\", \"UTF-8\");\n\t\t*/\n    // Copy in each file.\n    // Don't remove the (ClassLoader) cast! It is required for openjdk 11.\n    try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, (ClassLoader) null)) {\n        Files.createDirectories(pathWithinArchive);\n        for (File f : files) {\n            if (!f.isDirectory() && f.exists()) {\n                Path externalFile = f.toPath();\n                Path pathInZipFile = zipfs.getPath(pathWithinArchive.resolve(f.getName()).toString());\n                Files.copy(externalFile, pathInZipFile, StandardCopyOption.REPLACE_EXISTING);\n            }\n        }\n        ret = true;\n    } catch (IOException ex) {\n        s_logger.error(\"Unable to add entries to Chemical Component zip archive : {}\", ex.getMessage());\n        ret = false;\n    }\n    return ret;\n}", "repo_id": "9", "comment": "/**\n * Add an array of files to a zip archive.\n * Synchronized to prevent simultaneous reading/writing.\n *\n * @param zipFile is a destination zip archive\n * @param files is an array of files to be added\n * @param pathWithinArchive is the path within the archive to add files to\n * @return true if successfully appended these files.\n */\n", "repo_name": "biojava-master/", "id": 1081, "method_signature": "boolean addToZipFileSystem(Path, File[], Path)"}, "267": {"callee_method_names": ["List<Component>.get"], "method_name": "ModificationLinkage.getComponent2", "method_implementation": "{\n    return components.get(indexOfComponent2);\n}", "repo_id": "9", "comment": "/**\n * @return the second component.\n */\n", "repo_name": "biojava-master/", "id": 267, "method_signature": "Component getComponent2()"}, "1424": {"callee_method_names": ["Matrix4d.mul", "Matrix4d.epsilonEquals"], "method_name": "CrystalTransform.isEquivalent", "method_implementation": "{\n    Matrix4d mul = new Matrix4d();\n    mul.mul(this.matTransform, other.matTransform);\n    if (mul.epsilonEquals(IDENTITY, 0.0001)) {\n        return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Returns true if the given CrystalTransform is equivalent to this one.\n * Two crystal transforms are equivalent if one is the inverse of the other, i.e.\n * their transformation matrices multiplication is equal to the identity.\n * @param other\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1424, "method_signature": "boolean isEquivalent(CrystalTransform)"}, "1807": {"callee_method_names": [], "method_name": "EcodInstallation.getUrl", "method_implementation": "{\n    return url;\n}", "repo_id": "9", "comment": "/**\n * Get the top-level ECOD server URL. Defaults to \"http://prodata.swmed.edu\"\n * @return the url to the ecod server\n */\n", "repo_name": "biojava-master/", "id": 1807, "method_signature": "String getUrl()"}, "3177": {"callee_method_names": ["StopCodonSequence.setAccession"], "method_name": "TranscriptSequence.addStopCodonSequence", "method_implementation": "{\n    this.stopCodonSequence = new StopCodonSequence(this, begin, end);\n    stopCodonSequence.setAccession(accession);\n}", "repo_id": "9", "comment": "/**\n * Sets the stop codon sequence at given begin /  end location. Note that calling this method multiple times\n * will replace any existing value.\n * @param accession\n * @param begin\n * @param end\n */\n", "repo_name": "biojava-master/", "id": 3177, "method_signature": "void addStopCodonSequence(AccessionID, int, int)"}, "996": {"callee_method_names": ["Logger.debug", "Map<K, V>.put", "Map<K, V>.keySet"], "method_name": "SerializableCache.cache", "method_implementation": "{\n    if (data == null) {\n        return;\n    }\n    if (serializedCache != null) {\n        logger.debug(\"Caching {}  {}\", name, data);\n        serializedCache.put(name, data);\n        // every 1000 objects we are writing to disk\n        if (serializedCache.keySet().size() % 1000 == 0) {\n            flushCache();\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * This will not cache null values.\n *  Null means not cached yet.\n *  If you want to cache \"no data exists\" use e.g. empty collections to represent this.\n *\n * @param name\n * @param data\n */\n", "repo_name": "biojava-master/", "id": 996, "method_signature": "void cache(K, V)"}, "2031": {"callee_method_names": [], "method_name": "Icosahedron.getCirumscribedRadius", "method_implementation": "{\n    return circumscribedRadius;\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a circumscribed sphere, that goes\n * through all vertices\n * @return the cirumscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2031, "method_signature": "double getCirumscribedRadius()"}, "2932": {"callee_method_names": [], "method_name": "AbstractSequence.getFeaturesKeyWord", "method_implementation": "{\n    return featuresKeyWord;\n}", "repo_id": "9", "comment": "/**\n * @return the featuresKeyWord\n */\n", "repo_name": "biojava-master/", "id": 2932, "method_signature": "FeaturesKeyWordInterface getFeaturesKeyWord()"}, "1666": {"callee_method_names": ["ArrayList.get", "ArrayList.get", "ArrayList.get", "ArrayList.get"], "method_name": "SubunitCluster.getAlignedAtomsSubunit", "method_implementation": "{\n    Atom[] aligned = new Atom[subunitEQR.get(index).size()];\n    // Add only the aligned positions of the Subunit in the Cluster\n    for (int p = 0; p < subunitEQR.get(index).size(); p++) {\n        aligned[p] = subunits.get(index).getRepresentativeAtoms()[subunitEQR.get(index).get(p)];\n    }\n    return aligned;\n}", "repo_id": "9", "comment": "/**\n * @param index\n *            Subunit index in the Cluster\n * @return An Atom array of length {@link #length()} with the aligned Atoms\n *         from the selected Subunit in the Cluster\n */\n", "repo_name": "biojava-master/", "id": 1666, "method_signature": "Atom[] getAlignedAtomsSubunit(int)"}, "3470": {"callee_method_names": ["URL.openConnection", "URLConnection.getOutputStream", "OutputStreamWriter.write", "OutputStreamWriter.flush"], "method_name": "NCBIQBlastService.sendDeleteRequest", "method_implementation": "{\n    OutputStreamWriter writer = null;\n    try {\n        String deleteRequest = \"CMD=Delete&RID=\" + id;\n        URLConnection serviceConnection = setQBlastServiceProperties(serviceUrl.openConnection());\n        writer = new OutputStreamWriter(serviceConnection.getOutputStream());\n        writer.write(deleteRequest);\n        writer.flush();\n    } catch (IOException ignore) {\n        // ignore it this is an optional operation\n    } finally {\n        IOUtils.close(writer);\n    }\n}", "repo_id": "9", "comment": "/**\n * Sends a delete request for given request id. Optional operation, ignores IOExceptions.<br/>\n * Can be used after results of given search are no longer needed to be kept on Blast server\n *\n * @param id request id, as returned by {@code sendAlignmentRequest} method\n */\n", "repo_name": "biojava-master/", "id": 3470, "method_signature": "void sendDeleteRequest(String)"}, "2178": {"callee_method_ids": [628, 633], "callee_method_names": ["AtomCache.getStructure", "List<ResidueRangeAndLength>.get", "List<ResidueRangeAndLength>.get", "AtomCache.getStructureForDomain", "Structure.getPolyChains", "Structure.getPolyChainByPDB", "Structure.getPolyChainByPDB", "Chain.getAtomGroups", "Chain.getAtomGroups"], "method_name": "AtomCacheTest.testGetStructureForDomain1", "method_implementation": "{\n    // note that prior to Apr 2023, the example here was 1h6w, but it was obsoleted\n    String ranges = \"A:246-262,B:263-345\";\n    Structure whole = cache.getStructure(\"3bzy\");\n    AtomPositionMap map = new AtomPositionMap(StructureTools.getAllAtomArray(whole), AtomPositionMap.ANYTHING_MATCHER);\n    List<ResidueRangeAndLength> rrs = ResidueRangeAndLength.parseMultiple(ranges, map);\n    int expectedLengthA = rrs.get(0).getLength();\n    int expectedLengthB = rrs.get(1).getLength();\n    Structure structure = cache.getStructureForDomain(\"d3bzy.1\");\n    assertEquals(2, structure.getPolyChains().size());\n    Chain a = structure.getPolyChainByPDB(\"A\");\n    Chain b = structure.getPolyChainByPDB(\"B\");\n    assertEquals(expectedLengthA, a.getAtomGroups().size());\n    assertEquals(expectedLengthB, b.getAtomGroups().size());\n}", "repo_id": "9", "comment": "/**\n * Tests {@link AtomCache#getStructureForDomain(String)} on a multi-chain domain with no ligands but an explicit range (not whole-chain).\n */\n", "repo_name": "biojava-master/", "id": 2178, "method_signature": "void testGetStructureForDomain1()"}, "3012": {"callee_method_names": [], "method_name": "BitArrayWorker.biologicalIndexToArrayIndex", "method_implementation": "{\n    return ((index - 1) / compoundsPerDatatype());\n}", "repo_id": "9", "comment": "/**\n * Converting a biological index to the int which is used to store that\n * position's data.\n *\n * <ul>\n * <li>Assuming 2bit encoding using the 17 base in a sequence</li>\n * <li>Convert into 0 index; 17 - 1 = 16</li>\n * <li>Divide by the number of compounds per int; 16 / 16</li>\n * <li>Floor the value; floor(1) = 1</li>\n * </ul>\n *\n * Running this for position 13\n *\n * <ul>\n * <li>13 - 1 = 12</li>\n * <li>12 / 16 = 0.75</li>\n * <li>floor(0.75) = 0</li>\n * </ul>\n */\n", "repo_name": "biojava-master/", "id": 3012, "method_signature": "int biologicalIndexToArrayIndex(int)"}, "942": {"callee_method_names": ["List<Chain>.removeIf", "Chain.getAtomGroups"], "method_name": "InterfaceFinder.trimPolyChains", "method_implementation": "{\n    polyChains.removeIf(chain -> {\n        int count = chain.getAtomGroups().stream().map(Group::getAtoms).mapToInt(Collection::size).sum();\n        return count == 0;\n    });\n}", "repo_id": "9", "comment": "/**\n * Remove polymer chains with 0 atoms.\n */\n", "repo_name": "biojava-master/", "id": 942, "method_signature": "void trimPolyChains()"}, "1202": {"callee_method_names": [], "method_name": "CifStructureConverter.fromPath", "method_implementation": "{\n    return fromInputStream(Files.newInputStream(path), parameters);\n}", "repo_id": "9", "comment": "/**\n * Read data from a file and convert to Structure.\n * @param path the source of information - can be gzipped or binary or text data\n * @param parameters parameters for parsing\n * @return the target\n */\n", "repo_name": "biojava-master/", "id": 1202, "method_signature": "Structure fromPath(Path, FileParsingParameters)"}, "3188": {"callee_method_names": [], "method_name": "WindowedSequence.get", "method_implementation": "{\n    int start = toStartIndex(index);\n    int end = index + (getWindowSize() - 1);\n    return getBackingSequence().getSubSequence(start, end);\n}", "repo_id": "9", "comment": "/**\n * Returns the window specified at the given index in offsets i.e. asking\n * for position 2 in a moving window sequence of size 3 will get you\n * the window starting at position 4.\n */\n", "repo_name": "biojava-master/", "id": 3188, "method_signature": "SequenceView<C> get(int)"}, "1099": {"callee_method_names": ["Pattern.matcher", "Matcher.find", "Matcher.group", "String.contains", "String.substring", "String.length", "String.substring", "String.contains", "String.split", "String.substring", "Logger.debug", "StringBuilder.append", "Matcher.start", "Matcher.end", "String.length", "StringBuilder.append", "String.length", "StringBuilder.toString"], "method_name": "DownloadChemCompProvider.expandPathUrlTemplate", "method_implementation": "{\n    Matcher m = CCD_ID_TEMPLATE_REGEX.matcher(templateStr);\n    StringBuilder output = new StringBuilder();\n    int lastIndex = 0;\n    while (m.find()) {\n        String repString = ccdId;\n        String indicesStr = m.group(1);\n        try {\n            if (indicesStr == null) {\n                // no substringing\n                repString = ccdId;\n            } else if (!indicesStr.contains(\"_\")) {\n                // left/right substring\n                int idx = Integer.parseInt(indicesStr);\n                if (idx < 0) {\n                    // right substring\n                    repString = ccdId.substring(ccdId.length() + idx);\n                } else {\n                    // left substring\n                    repString = ccdId.substring(0, idx);\n                }\n            } else if (indicesStr.contains(\"_\")) {\n                // start and end index\n                String[] tokens = indicesStr.split(\"_\");\n                int begIdx = Integer.parseInt(tokens[0]);\n                int endIdx = Integer.parseInt(tokens[1]);\n                repString = ccdId.substring(begIdx, endIdx);\n            }\n        } catch (IndexOutOfBoundsException e) {\n            // we don't set repString, it keeps original value ccdId\n            logger.debug(\"Indices included in path URL template {} are out of bounds for string {}\", templateStr, ccdId);\n        }\n        output.append(templateStr, lastIndex, m.start()).append(repString);\n        lastIndex = m.end();\n        // TODO when we upgrade to java 11, use the new methods introduced in java 9, see https://stackoverflow.com/questions/9605716/java-regular-expression-find-and-replace\n    }\n    if (lastIndex < templateStr.length()) {\n        output.append(templateStr, lastIndex, templateStr.length());\n    }\n    return output.toString();\n}", "repo_id": "9", "comment": "/**\n * Expands the given path URL template, replacing the placeholders as specified in {@link #setChemCompPathUrlTemplate(String)}\n * by the ccdId given (or its substrings, if indices are present in the template)\n * @param templateStr the template string with placeholders for ccd ids\n * @param ccdId the ccd id to replace (in full or a substring)\n * @return the input templateStr with placeholders replaced\n */\n", "repo_name": "biojava-master/", "id": 1099, "method_signature": "String expandPathUrlTemplate(String, String)"}, "2451": {"callee_method_names": [], "method_name": "Feature.seqname", "method_implementation": "{\n    return mSeqname;\n}", "repo_id": "9", "comment": "/**\n * Get the sequence name. (GFF field 1). Note that feature objects have\n * no link or reference to the actual sequence object to which\n * they refer; they are completely uncoupled.\n *\n * @return Sequence name.\n */\n", "repo_name": "biojava-master/", "id": 2451, "method_signature": "String seqname()"}, "2344": {"callee_method_names": ["String.length"], "method_name": "FastqBuilder.appendSequence", "method_implementation": "{\n    if (sequence == null) {\n        throw new IllegalArgumentException(\"sequence must not be null\");\n    }\n    if (this.sequence == null) {\n        this.sequence = new StringBuilder(sequence.length());\n    }\n    this.sequence.append(sequence);\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Return this FASTQ formatted sequence builder configured with the specified sequence\n * appended to its current sequence.\n *\n * @param sequence sequence to append to the sequence for this FASTQ formatted sequence builder, must not be null\n * @return this FASTQ formatted sequence builder configured with the specified sequence\n *    appended to its current sequence\n */\n", "repo_name": "biojava-master/", "id": 2344, "method_signature": "FastqBuilder appendSequence(String)"}, "2729": {"callee_method_ids": [3106, 3108], "callee_method_names": ["GenbankSequenceParser<S, C>.getSequence", "SequenceCreatorInterface<C>.getSequence", "GenbankSequenceParser<S, C>.getSequenceHeaderParser", "GenericGenbankHeaderParser<S, C>.parseHeader", "GenbankSequenceParser<S, C>.getHeader", "GenericGenbankHeaderParser<S, C>.getAccession", "GenericGenbankHeaderParser<S, C>.getVersion", "GenericGenbankHeaderParser<S, C>.getIdentifier", "S.setAccession", "GenbankSequenceParser<S, C>.getFeatures", "GenbankSequenceParser<S, C>.getDatabaseReferences", "List<DBReferenceInfo>.get", "S.setTaxonomy", "DBReferenceInfo.getDatabase", "DBReferenceInfo.getId", "LinkedHashMap<String, S>.put", "S.getAccession"], "method_name": "GenbankReader.process", "method_implementation": "{\n    if (closed) {\n        throw new IOException(\"Cannot perform action: resource has been closed.\");\n    }\n    LinkedHashMap<String, S> sequences = new LinkedHashMap<>();\n    int i = 0;\n    while (true) {\n        if (max > 0 && i >= max)\n            break;\n        i++;\n        String seqString = genbankParser.getSequence(bufferedReader, 0);\n        //reached end of file?\n        if (seqString == null)\n            break;\n        @SuppressWarnings(\"unchecked\")\n        S sequence = (S) sequenceCreator.getSequence(seqString, 0);\n        GenericGenbankHeaderParser<S, C> genbankHeaderParser = genbankParser.getSequenceHeaderParser();\n        genbankHeaderParser.parseHeader(genbankParser.getHeader(), sequence);\n        String id = genbankHeaderParser.getAccession();\n        int version = genbankHeaderParser.getVersion();\n        String identifier = genbankHeaderParser.getIdentifier();\n        AccessionID accession = new AccessionID(id, DataSource.GENBANK, version, identifier);\n        sequence.setAccession(accession);\n        // add features to new sequence\n        genbankParser.getFeatures().values().stream().flatMap(List::stream).forEach(sequence::addFeature);\n        // add taxonomy ID to new sequence\n        List<DBReferenceInfo> dbQualifier = genbankParser.getDatabaseReferences().get(\"db_xref\");\n        if (dbQualifier != null) {\n            DBReferenceInfo q = dbQualifier.get(0);\n            sequence.setTaxonomy(new TaxonomyID(q.getDatabase() + \":\" + q.getId(), DataSource.GENBANK));\n        }\n        sequences.put(sequence.getAccession().getID(), sequence);\n    }\n    return sequences;\n}", "repo_id": "9", "comment": "/**\n * This method tries to parse maximum <code>max</code> records from\n * the open File or InputStream, and leaves the underlying resource open.<br>\n *\n * Subsequent calls to the same method continue parsing the rest of the file.<br>\n * This is particularly useful when dealing with very big data files,\n * (e.g. NCBI nr database), which can't fit into memory and will take long\n * time before the first result is available.<br>\n * <b>N.B.</b>\n * <ul>\n * <li>This method can't be called after calling its NO-ARGUMENT twin.</li>\n * <li>remember to close the underlying resource when you are done.</li>\n * </ul>\n * @see #process()\n * @author Amr ALHOSSARY\n * @since 3.0.6\n * @param max maximum number of records to return.\n * @return {@link HashMap} containing maximum <code>max</code> parsed Genbank records\n * present, starting current fileIndex onwards.\n * @throws IOException\n * @throws CompoundNotFoundException\n */\n", "repo_name": "biojava-master/", "id": 2729, "method_signature": "LinkedHashMap<String,S> process(int)"}, "640": {"callee_method_names": [], "method_name": "AtomCache.getFiletype", "method_implementation": "{\n    return filetype;\n}", "repo_id": "9", "comment": "/**\n * Returns the currently active file type that will be parsed.\n * @return a StructureFiletype\n */\n", "repo_name": "biojava-master/", "id": 640, "method_signature": "StructureFiletype getFiletype()"}, "1085": {"callee_method_names": ["SoftHashMap.clear"], "method_name": "ChemCompGroupFactory.clearCache", "method_implementation": "{\n    cache.clear();\n}", "repo_id": "9", "comment": "/**\n * Force the in-memory cache to be reset.\n *\n * Note that the ChemCompProvider may have additional memory or disk caches that need to be cleared too.\n */\n", "repo_name": "biojava-master/", "id": 1085, "method_signature": "void clearCache()"}, "2087": {"callee_method_names": [], "method_name": "SymmetryAxes.getRotationAxis", "method_implementation": "{\n    if (rotAxis == null) {\n        rotAxis = new RotationAxis(operator);\n    }\n    return rotAxis;\n}", "repo_id": "9", "comment": "/**\n * Get the transformation operator as a rotation axis. For open\n * symmetry this will have a non-zero screw component.\n * @return a RotationAxis for this Axis\n */\n", "repo_name": "biojava-master/", "id": 2087, "method_signature": "RotationAxis getRotationAxis()"}, "2823": {"callee_method_names": ["PrintWriter.print", "PrintWriter.flush", "PrintWriter.close", "PrintWriter.close"], "method_name": "IOUtils.print", "method_implementation": "{\n    PrintWriter out = null;\n    try {\n        out = new PrintWriter(new BufferedWriter(new FileWriter(file)));\n        out.print(string);\n        out.flush();\n        out.close();\n    } finally {\n        if (out != null)\n            out.close();\n    }\n}", "repo_id": "9", "comment": "/**\n * Prints {@code string} to {@code file}.\n * @throws IOException If any I/O exception occurs while printing; this method does not catch any exceptions\n */\n", "repo_name": "biojava-master/", "id": 2823, "method_signature": "void print(String, File)"}, "19": {"callee_method_ids": [25], "callee_method_names": ["String.split", "StockholmStructure.appendToSequence"], "method_name": "StockholmFileParser.handleSequenceLine", "method_implementation": "{\n    String[] lineContent = line.split(\"\\\\s+\");\n    if (lineContent.length != 2) {\n        throw new ParserException(\"Could not split sequence line into sequence name and sequence:\\n\" + line);\n    }\n    stockholmStructure.appendToSequence(lineContent[0], lineContent[1]);\n}", "repo_id": "9", "comment": "/**\n * Handles a line that corresponds to a sequence. <br>\n * e.g.: COATB_BPIKE/30-81 AEPNAATNYATEAMDSLKTQAIDLISQTWPVVTTVVVAGLVIRLFKKFSSKA<br>\n * N.B.: This function can't tolerate sequences with intrinsic white space.\n *\n * @param line\n *            the line to be parsed\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 19, "method_signature": "void handleSequenceLine(String)"}, "1608": {"callee_method_names": ["Map<SecStrucType, Integer>.put", "Group.hasAminoAtoms", "Group.getProperty", "String.equals", "Group.getChainId", "Group.getResidueNumber", "Map<SecStrucType, Integer>.get", "List<SecStrucElement>.add", "Map<SecStrucType, Integer>.put", "Map<SecStrucType, Integer>.get", "Group.getResidueNumber", "Group.getChainId", "Group.getResidueNumber", "Group.getChainId"], "method_name": "SecStrucTools.getSecStrucElements", "method_implementation": "{\n    List<SecStrucElement> listSSE = new ArrayList<>();\n    // SecStruc information - initialize\n    SecStrucType type = SecStrucType.coil;\n    ResidueNumber previous = new ResidueNumber();\n    ResidueNumber start = new ResidueNumber();\n    String chainId = \"\";\n    // counts the number of residues in SSE\n    int count = 0;\n    // Create a map for the IDs of the SSE in the structure\n    Map<SecStrucType, Integer> ids = new TreeMap<>();\n    for (SecStrucType t : SecStrucType.values()) ids.put(t, 1);\n    for (Group g : groups) {\n        if (g.hasAminoAtoms()) {\n            Object p = g.getProperty(Group.SEC_STRUC);\n            if (p == null)\n                continue;\n            SecStrucInfo ss = (SecStrucInfo) p;\n            if (count > 0) {\n                // If chain and type are equal increment counter\n                if (ss.type == type && chainId.equals(g.getChainId())) {\n                    previous = g.getResidueNumber();\n                    count++;\n                    continue;\n                } else {\n                    // Save the current SSE if chain or type change\n                    SecStrucElement sse = new SecStrucElement(type, start, previous, count, ids.get(type), chainId);\n                    listSSE.add(sse);\n                    ids.put(type, ids.get(type) + 1);\n                    count = 0;\n                    // Initialize a new SSE one\n                    if (ss.type != SecStrucType.coil) {\n                        type = ss.type;\n                        start = g.getResidueNumber();\n                        previous = start;\n                        chainId = g.getChainId();\n                        count = 1;\n                    }\n                }\n            } else {\n                // This is for the first residue only\n                if (ss.type != SecStrucType.coil) {\n                    type = ss.type;\n                    start = g.getResidueNumber();\n                    previous = start;\n                    chainId = g.getChainId();\n                    count = 1;\n                }\n            }\n        }\n    }\n    return listSSE;\n}", "repo_id": "9", "comment": "/**\n * Obtain the List of secondary structure elements (SecStrucElement) of a\n * List of Groups (assumed to be sequential, this is, connected in the\n * original Structure).\n *\n * @param groups\n *            Structure with SS assignments\n * @return List of SecStrucElement objects\n */\n", "repo_name": "biojava-master/", "id": 1608, "method_signature": "List<SecStrucElement> getSecStrucElements(List)"}, "2214": {"callee_method_ids": [1322, 1330], "callee_method_names": ["FileParsingParameters.setAlignSeqRes", "FileParsingParameters.setCreateAtomBonds", "AtomCache.setFileParsingParams", "Structure.getChains", "List<Integer>.getAtomGroups", "List<Atom>.add", "ChemComp.getBonds", "Atom.getName", "Atom.getName"], "method_name": "TestAltLocs.testAddBondsDoesntChangeGroups", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    FileParsingParameters params = new FileParsingParameters();\n    params.setAlignSeqRes(true);\n    params.setCreateAtomBonds(true);\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    Structure structure = StructureIO.getStructure(\"4CUP\");\n    // Loop through and find\n    for (Chain chain : structure.getChains()) {\n        List<Group> groups = chain.getAtomGroups();\n        for (Group mainGroup : groups) {\n            // atoms with no residue number don't have atom information\n            if (mainGroup.getResidueNumber() == null) {\n                continue;\n            }\n            if (mainGroup.getAltLocs().isEmpty()) {\n                continue;\n            }\n            int oldSize = mainGroup.size();\n            // Now add support for altLocGroup\n            List<Atom> atomsList = new ArrayList<>(mainGroup.getAtoms());\n            for (Group altLocOne : mainGroup.getAltLocs()) {\n                for (Atom atomAltLocOne : altLocOne.getAtoms()) {\n                    atomsList.add(atomAltLocOne);\n                }\n            }\n            // Get the chem copm\n            ChemComp aminoChemComp = ChemCompGroupFactory.getChemComp(mainGroup.getPDBName());\n            // Now iterate through this list\n            for (Atom atomA : atomsList) {\n                for (ChemCompBond chemCompBond : aminoChemComp.getBonds()) {\n                    //\n                    if (chemCompBond.getAtomId1().equals(atomA.getName())) {\n                        // Get the other atom in the group\n                        for (Atom atomB : atomsList) {\n                            if (chemCompBond.getAtomId2().equals(atomB.getName())) {\n                                int bondOrder = chemCompBond.getNumericalBondOrder();\n                                new BondImpl(atomA, atomB, bondOrder);\n                            }\n                        }\n                    }\n                }\n            }\n            assertEquals(oldSize, mainGroup.size());\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * A test that adding bonds to atoms between groups - doesn't change the size of the groups\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2214, "method_signature": "void testAddBondsDoesntChangeGroups()"}, "1828": {"callee_method_names": ["ObjectMapper.getTypeFactory", "ObjectMapper.readValue", "TypeFactory.constructCollectionType"], "method_name": "PDBStatus.getCurrentPDBIds", "method_implementation": "{\n    // Build REST query URL\n    String urlStr = String.format(ALL_CURRENT_ENDPOINT, DEFAULT_RCSB_DATA_API_SERVER);\n    URL u = new URL(urlStr);\n    InputStream stream = URLConnectionTools.getInputStream(u, 60000);\n    ObjectMapper objectMapper = new ObjectMapper();\n    TypeFactory typeFactory = objectMapper.getTypeFactory();\n    List<String> pdbIdList = objectMapper.readValue(stream, typeFactory.constructCollectionType(List.class, String.class));\n    return new TreeSet<>(pdbIdList);\n}", "repo_id": "9", "comment": "/**\n * Returns all current PDB IDs\n *\n * @return a list of PDB IDs\n * @throws IOException if a problem occurs retrieving the information\n */\n", "repo_name": "biojava-master/", "id": 1828, "method_signature": "SortedSet<String> getCurrentPDBIds()"}, "1621": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setMinimumSequenceLengthFraction", "method_implementation": "{\n    this.minimumSequenceLengthFraction = minimumSequenceLengthFraction;\n}", "repo_id": "9", "comment": "/**\n * If the shortest subunit sequence length is higher or equal the\n * minimumSequenceLengthFraction times the median subunit sequence length,\n * then the minimumSequenceLength is set to shortest subunit sequence\n * length, but not shorter than the absoluteMinimumSequenceLength.\n * <p>\n * This adaptive feature allows the consideration of structures mainly\n * constructed by very short chains, such as collagen (1A3I)\n *\n * @param minimumSequenceLengthFraction\n */\n", "repo_name": "biojava-master/", "id": 1621, "method_signature": "void setMinimumSequenceLengthFraction(double)"}, "1942": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getRmsd", "method_implementation": "{\n    return rmsd;\n}", "repo_id": "9", "comment": "/**\n * @return the rmsd\n */\n", "repo_name": "biojava-master/", "id": 1942, "method_signature": "double getRmsd()"}, "673": {"callee_method_names": ["MultipleAlignment.getBlockSets", "MultipleAlignment.getBlockSet", "List<Matrix4d>.size", "MultipleAlignment.getBlockSets", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "MultipleAlignment.size", "StringBuffer.append", "List<Matrix4d>.get", "List<Matrix4d>.get", "List<Matrix4d>.get", "List<Matrix4d>.get", "StringBuffer.append", "StringBuffer.append", "List<Matrix4d>.get", "List<Matrix4d>.get", "List<Matrix4d>.get", "List<Matrix4d>.get", "StringBuffer.append", "StringBuffer.append", "List<Matrix4d>.get", "List<Matrix4d>.get", "List<Matrix4d>.get", "List<Matrix4d>.get", "StringBuffer.append", "StringBuffer.toString"], "method_name": "MultipleAlignmentWriter.toTransformMatrices", "method_implementation": "{\n    StringBuffer txt = new StringBuffer();\n    for (int bs = 0; bs < alignment.getBlockSets().size(); bs++) {\n        List<Matrix4d> btransforms = alignment.getBlockSet(bs).getTransformations();\n        if (btransforms == null || btransforms.size() < 1)\n            continue;\n        if (alignment.getBlockSets().size() > 1) {\n            txt.append(\"Operations for block \");\n            txt.append(bs + 1);\n            txt.append(\"\\n\");\n        }\n        for (int str = 0; str < alignment.size(); str++) {\n            String origString = \"ref\";\n            txt.append(String.format(Locale.US, \"     X\" + (str + 1) + \" = (%9.6f)*X\" + origString + \" + (%9.6f)*Y\" + origString + \" + (%9.6f)*Z\" + origString + \" + (%12.6f)\", btransforms.get(str).getElement(0, 0), btransforms.get(str).getElement(0, 1), btransforms.get(str).getElement(0, 2), btransforms.get(str).getElement(0, 3)));\n            txt.append(\"\\n\");\n            txt.append(String.format(Locale.US, \"     Y\" + (str + 1) + \" = (%9.6f)*X\" + origString + \" + (%9.6f)*Y\" + origString + \" + (%9.6f)*Z\" + origString + \" + (%12.6f)\", btransforms.get(str).getElement(1, 0), btransforms.get(str).getElement(1, 1), btransforms.get(str).getElement(1, 2), btransforms.get(str).getElement(1, 3)));\n            txt.append(\"\\n\");\n            txt.append(String.format(Locale.US, \"     Z\" + (str + 1) + \" = (%9.6f)*X\" + origString + \" + (%9.6f)*Y\" + origString + \" + (%9.6f)*Z\" + origString + \" + (%12.6f)\", btransforms.get(str).getElement(2, 0), btransforms.get(str).getElement(2, 1), btransforms.get(str).getElement(2, 2), btransforms.get(str).getElement(2, 3)));\n            txt.append(\"\\n\\n\");\n        }\n    }\n    return txt.toString();\n}", "repo_id": "9", "comment": "/**\n * Converts the transformation Matrices of the alignment into a String\n * output.\n *\n * @param afpChain\n * @return String transformation Matrices\n */\n", "repo_name": "biojava-master/", "id": 673, "method_signature": "String toTransformMatrices(MultipleAlignment)"}, "262": {"callee_method_names": ["Map<Component, Set<ProteinModification>>.keySet"], "method_name": "ProteinModificationRegistry.allComponents", "method_implementation": "{\n    lazyInit();\n    Set<Component> ret = byComponent.keySet();\n    return Collections.unmodifiableSet(ret);\n}", "repo_id": "9", "comment": "/**\n * @return set of components involved in all registered ProteinModifications.\n */\n", "repo_name": "biojava-master/", "id": 262, "method_signature": "Set<Component> allComponents()"}, "80": {"callee_method_names": [], "method_name": "AlignerHelper.setCuts", "method_implementation": "{\n    for (Cut c : cuts) {\n        c.update(x, subproblem, pointers);\n    }\n}", "repo_id": "9", "comment": "// updates cut rows given the latest row of traceback pointers\n", "repo_name": "biojava-master/", "id": 80, "method_signature": "void setCuts(int, Subproblem, Last[][], Cut[])"}, "2188": {"callee_method_names": ["List<Atom[]>.add", "List<Integer>.add", "List<List<Integer>>.add", "MultipleAlignment.getEnsemble", "Block.setAlignRes", "ReferenceSuperimposer.superimpose"], "method_name": "TestMultipleAlignmentScorer.identityMSTA", "method_implementation": "{\n    //Generate the identical Atom arrays\n    List<Atom[]> atomArrays = new ArrayList<Atom[]>(20);\n    for (int i = 0; i < 3; i++) atomArrays.add(makeDummyCA(20));\n    //Generate the identity alignment (1-1-1,2-2-2,etc)\n    List<List<Integer>> alnRes = new ArrayList<List<Integer>>(3);\n    for (int str = 0; str < 3; str++) {\n        List<Integer> chain = new ArrayList<Integer>(20);\n        for (int res = 0; res < 20; res++) chain.add(res);\n        alnRes.add(chain);\n    }\n    //MultipleAlignment generation\n    MultipleAlignment msa = new MultipleAlignmentImpl();\n    msa.getEnsemble().setAtomArrays(atomArrays);\n    BlockSet bs = new BlockSetImpl(msa);\n    Block b = new BlockImpl(bs);\n    b.setAlignRes(alnRes);\n    //Superimpose the alignment (which should give the identity matrices)\n    ReferenceSuperimposer imposer = new ReferenceSuperimposer();\n    imposer.superimpose(msa);\n    return msa;\n}", "repo_id": "9", "comment": "/**\n * Generates an identity MultipleAlignment: 3 structures with\n * the same Atoms and perfectly aligned, so that TM-score = 1\n * and RMSD = 0.\n * @return MultipleAlignment identity\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2188, "method_signature": "MultipleAlignment identityMSTA()"}, "839": {"callee_method_names": ["Atom.getElement", "Logger.warn", "Atom.getName", "Atom.getPDBserial", "Atom.getGroup", "Logger.warn", "Atom.getName", "Atom.getPDBserial", "Atom.getElement", "Group.getType", "Atom.getElement"], "method_name": "AsaCalculator.getRadius", "method_implementation": "{\n    if (atom.getElement() == null) {\n        logger.warn(\"Unrecognised atom \" + atom.getName() + \" with serial \" + atom.getPDBserial() + \", assigning the default vdw radius (Nitrogen vdw radius).\");\n        return Element.N.getVDWRadius();\n    }\n    Group res = atom.getGroup();\n    if (res == null) {\n        logger.warn(\"Unknown parent residue for atom \" + atom.getName() + \" with serial \" + atom.getPDBserial() + \", assigning its default vdw radius\");\n        return atom.getElement().getVDWRadius();\n    }\n    GroupType type = res.getType();\n    if (type == GroupType.AMINOACID)\n        return getRadiusForAmino(((AminoAcid) res), atom);\n    if (type == GroupType.NUCLEOTIDE)\n        return getRadiusForNucl((NucleotideImpl) res, atom);\n    return atom.getElement().getVDWRadius();\n}", "repo_id": "9", "comment": "/**\n * Gets the van der Waals radius of the given atom following the values defined by\n * Chothia (1976) J.Mol.Biol.105,1-14\n * NOTE: the vdw values defined by the paper assume no Hydrogens and thus \"inflates\"\n * slightly the heavy atoms to account for Hydrogens. Thus this method cannot be used\n * in a structure that contains Hydrogens!\n *\n * If atom is neither part of a nucleotide nor of a standard aminoacid,\n * the default vdw radius for the element is returned. If atom is of\n * unknown type (element) the vdw radius of {@link Element().N} is returned\n *\n * @param atom\n * @return\n */\n", "repo_name": "biojava-master/", "id": 839, "method_signature": "double getRadius(Atom)"}, "3104": {"callee_method_names": [], "method_name": "DBReferenceInfo.getProperties", "method_implementation": "{\n    return properties;\n}", "repo_id": "9", "comment": "/**\n * Get the properties\n * @return the properties\n */\n", "repo_name": "biojava-master/", "id": 3104, "method_signature": "LinkedHashMap<String,String> getProperties()"}, "1877": {"callee_method_names": ["AxisAngle4d.set"], "method_name": "Helix.getAxisAngle", "method_implementation": "{\n    AxisAngle4d axis = new AxisAngle4d();\n    axis.set(this.transformation);\n    return axis;\n}", "repo_id": "9", "comment": "/**\n * Returns the AxisAngle of the helix transformation\n * @param transformation helix transformation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1877, "method_signature": "AxisAngle4d getAxisAngle()"}, "2385": {"callee_method_names": [], "method_name": "TwoBitParser.close", "method_implementation": "{\n    cur_seq_name = null;\n    cur_nn_blocks = null;\n    cur_mask_blocks = null;\n    cur_seq_pos = -1;\n    cur_dna_size = -1;\n    cur_nn_block_num = -1;\n    cur_mask_block_num = -1;\n    cur_bits = null;\n    buffer_size = 0;\n    buffer_pos = -1;\n    file_pos = -1;\n    start_file_pos = -1;\n}", "repo_id": "9", "comment": "/**\n * Method closes current sequence and it's necessary to invoke it before setting\n * new current sequence.\n */\n", "repo_name": "biojava-master/", "id": 2385, "method_signature": "void close()"}, "857": {"callee_method_names": ["TreeMap<Key, Value>.containsKey"], "method_name": "SymbolTable.contains", "method_implementation": "{\n    return st.containsKey(key);\n}", "repo_id": "9", "comment": "/**\n * Is the key in the table?\n */\n", "repo_name": "biojava-master/", "id": 857, "method_signature": "boolean contains(Key)"}, "1108": {"callee_method_names": ["Map<String, ChemComp>.size"], "method_name": "ChemicalComponentDictionary.size", "method_implementation": "{\n    return dictionary.size();\n}", "repo_id": "9", "comment": "/**\n * Returns the number of ChemComps in this dictionary\n * @return nr. of ChemComps\n */\n", "repo_name": "biojava-master/", "id": 1108, "method_signature": "int size()"}, "1191": {"callee_method_names": [], "method_name": "PDBFileParser.addCharges", "method_implementation": "{\n    ChargeAdder.addCharges(structure);\n}", "repo_id": "9", "comment": "/**\n * Add the charges to the Structure\n */\n", "repo_name": "biojava-master/", "id": 1191, "method_signature": "void addCharges()"}, "1860": {"callee_method_names": [], "method_name": "Rotation.setTransformation", "method_implementation": "{\n    this.transformation = transformation;\n}", "repo_id": "9", "comment": "/**\n * @param transformation the transformation to set\n */\n", "repo_name": "biojava-master/", "id": 1860, "method_signature": "void setTransformation(Matrix4d)"}, "37": {"callee_method_names": ["List<S>.get"], "method_name": "Alignments.getMultipleSequenceAlignment", "method_implementation": "{\n    // TODO convert other factories to this parameter style?\n    CompoundSet<C> cs = sequences.get(0).getCompoundSet();\n    PairwiseSequenceScorerType ps = PairwiseSequenceScorerType.GLOBAL_IDENTITIES;\n    GapPenalty gapPenalty = new SimpleGapPenalty();\n    SubstitutionMatrix<C> subMatrix = null;\n    if (cs == AminoAcidCompoundSet.getAminoAcidCompoundSet()) {\n        // compound types must be equal since compound sets are equal\n        @SuppressWarnings(\"unchecked\")\n        SubstitutionMatrix<C> temp = (SubstitutionMatrix<C>) SubstitutionMatrixHelper.getBlosum62();\n        subMatrix = temp;\n    } else if (cs == DNACompoundSet.getDNACompoundSet()) {\n        // compound types must be equal since compound sets are equal\n        @SuppressWarnings(\"unchecked\")\n        SubstitutionMatrix<C> temp = (SubstitutionMatrix<C>) SubstitutionMatrixHelper.getNuc4_4();\n        subMatrix = temp;\n    } else if (cs == AmbiguityDNACompoundSet.getDNACompoundSet()) {\n        // compound types must be equal since compound sets are equal\n        @SuppressWarnings(\"unchecked\")\n        SubstitutionMatrix<C> temp = (SubstitutionMatrix<C>) SubstitutionMatrixHelper.getNuc4_4();\n        subMatrix = temp;\n    }\n    ProfileProfileAlignerType pa = ProfileProfileAlignerType.GLOBAL;\n    for (Object o : settings) {\n        if (o instanceof PairwiseSequenceScorerType) {\n            ps = (PairwiseSequenceScorerType) o;\n        } else if (o instanceof GapPenalty) {\n            gapPenalty = (GapPenalty) o;\n        } else if (o instanceof SubstitutionMatrix<?>) {\n            if (cs != ((SubstitutionMatrix<?>) o).getCompoundSet()) {\n                throw new IllegalArgumentException(\"Compound sets of the sequences and substitution matrix must match.\");\n            }\n            // compound types must be equal since compound sets are equal\n            @SuppressWarnings(\"unchecked\")\n            SubstitutionMatrix<C> temp = (SubstitutionMatrix<C>) o;\n            subMatrix = temp;\n        } else if (o instanceof ProfileProfileAlignerType) {\n            pa = (ProfileProfileAlignerType) o;\n        }\n    }\n    // stage 1: pairwise similarity calculation\n    List<PairwiseSequenceScorer<S, C>> scorers = getAllPairsScorers(sequences, ps, gapPenalty, subMatrix);\n    runPairwiseScorers(scorers);\n    // stage 2: hierarchical clustering into a guide tree\n    GuideTree<S, C> tree = new GuideTree<S, C>(sequences, scorers);\n    scorers = null;\n    // stage 3: progressive alignment\n    Profile<S, C> msa = getProgressiveAlignment(tree, pa, gapPenalty, subMatrix);\n    // TODO stage 4: refinement\n    return msa;\n}", "repo_id": "9", "comment": "/**\n * Factory method which computes a multiple sequence alignment for the given {@link List} of {@link Sequence}s.\n *\n * @param <S> each {@link Sequence} of the {@link List} is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n * @param sequences the {@link List} of {@link Sequence}s to align\n * @param settings optional settings that adjust the alignment\n * @return multiple sequence alignment {@link Profile}\n */\n", "repo_name": "biojava-master/", "id": 37, "method_signature": "Profile<S,C> getMultipleSequenceAlignment(List, Object[])"}, "2171": {"callee_method_names": ["List<ResidueRange>.get", "List<ResidueRange>.get", "List<ResidueRange>.get", "List<ResidueRange>.get", "List<ResidueRange>.get", "ResidueRange.getChainName", "ResidueRange.getStart", "ResidueRange.getEnd", "List<ResidueRange>.get", "ResidueRange.getChainName", "ResidueRange.getStart", "ResidueRange.getEnd", "List<ResidueRange>.get", "ResidueRange.getChainName", "ResidueRange.getStart", "ResidueRange.getEnd", "List<ResidueRange>.get", "ResidueRange.getChainName", "ResidueRange.getStart", "ResidueRange.getEnd", "List<ResidueRange>.get", "ResidueRange.getChainName", "ResidueRange.getStart", "ResidueRange.getEnd", "List<ResidueRange>.get", "ResidueRange.getChainName", "ResidueRange.getStart", "ResidueRange.getEnd", "List<ResidueRange>.get", "ResidueRange.getChainName", "ResidueRange.getStart", "ResidueRange.getEnd", "List<ResidueRange>.get", "ResidueRange.getChainName", "ResidueRange.getStart", "ResidueRange.getEnd"], "method_name": "ResidueRangeTest.testParseAndEqual", "method_implementation": "{\n    String rangeStr;\n    List<ResidueRange> ranges;\n    ResidueRange range;\n    // String pdbId1 = \"2eke\";\n    rangeStr = \"C_1023-1063,C_1064-1084\";\n    ranges = ResidueRange.parseMultiple(rangeStr);\n    assertEquals(new ResidueRange(\"C\", new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null)), ranges.get(0));\n    assertEquals(new ResidueRange(\"C\", new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null)), ranges.get(1));\n    // String pdbId = \"1qdm\";\n    rangeStr = \"A_3S-37S,A_65S-99S\";\n    ranges = ResidueRange.parseMultiple(rangeStr);\n    assertEquals(new ResidueRange(\"A\", new ResidueNumber(\"A\", 3, 'S'), new ResidueNumber(\"A\", 37, 'S')), ranges.get(0));\n    assertEquals(new ResidueRange(\"A\", new ResidueNumber(\"A\", 65, 'S'), new ResidueNumber(\"A\", 99, 'S')), ranges.get(1));\n    // Multi-character chains\n    rangeStr = \"AB,A1,ABCD_1-55,NotAG00dID:-5-1R\";\n    ranges = ResidueRange.parseMultiple(rangeStr);\n    range = ranges.get(0);\n    assertEquals(\"Error parsing \" + rangeStr, \"AB\", range.getChainName());\n    assertNull(\"Error parsing \" + rangeStr, range.getStart());\n    assertNull(\"Error parsing \" + rangeStr, range.getEnd());\n    range = ranges.get(1);\n    assertEquals(\"Error parsing \" + rangeStr, \"A1\", range.getChainName());\n    assertNull(\"Error parsing \" + rangeStr, range.getStart());\n    assertNull(\"Error parsing \" + rangeStr, range.getEnd());\n    range = ranges.get(2);\n    assertEquals(\"Error parsing \" + rangeStr, \"ABCD\", range.getChainName());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"ABCD\", 1, null), range.getStart());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"ABCD\", 55, null), range.getEnd());\n    range = ranges.get(3);\n    assertEquals(\"Error parsing \" + rangeStr, \"NotAG00dID\", range.getChainName());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"NotAG00dID\", -5, null), range.getStart());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"NotAG00dID\", 1, 'R'), range.getEnd());\n    // Wildcard chains\n    rangeStr = \"_,__,_:1-5,_:+1-+5\";\n    ranges = ResidueRange.parseMultiple(rangeStr);\n    range = ranges.get(0);\n    assertEquals(\"Error parsing \" + rangeStr, \"_\", range.getChainName());\n    assertNull(\"Error parsing \" + rangeStr, range.getStart());\n    assertNull(\"Error parsing \" + rangeStr, range.getEnd());\n    range = ranges.get(1);\n    assertEquals(\"Error parsing \" + rangeStr, \"_\", range.getChainName());\n    assertNull(\"Error parsing \" + rangeStr, range.getStart());\n    assertNull(\"Error parsing \" + rangeStr, range.getEnd());\n    range = ranges.get(2);\n    assertEquals(\"Error parsing \" + rangeStr, \"_\", range.getChainName());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"_\", 1, null), range.getStart());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"_\", 5, null), range.getEnd());\n    range = ranges.get(3);\n    assertEquals(\"Error parsing \" + rangeStr, \"_\", range.getChainName());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"_\", 1, null), range.getStart());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"_\", 5, null), range.getEnd());\n}", "repo_id": "9", "comment": "/**\n * Tests {@link ResidueRange#parseMultiple(String)}.\n */\n", "repo_name": "biojava-master/", "id": 2171, "method_signature": "void testParseAndEqual()"}, "1923": {"callee_method_names": [], "method_name": "QuatSymmetryResults.getSubunitClusters", "method_implementation": "{\n    return Collections.unmodifiableList(clusters);\n}", "repo_id": "9", "comment": "/**\n * Returns the List of SubunitCluster used to calculate symmetry.\n *\n * @return an unmodifiable view of the original List\n */\n", "repo_name": "biojava-master/", "id": 1923, "method_signature": "List<SubunitCluster> getSubunitClusters()"}, "1601": {"callee_method_names": ["Logger.debug", "Integer.toString"], "method_name": "SecStrucCalc.calculateTurns", "method_implementation": "{\n    for (int i = 0; i < groups.length; i++) {\n        for (int turn = 3; turn <= 5; turn++) {\n            if (i + turn >= groups.length)\n                continue;\n            //Check for H bond from NH(i+n) to CO(i)\n            if (isBonded(i, i + turn)) {\n                logger.debug(\"Turn at ({},{}) turn {}\", i, (i + turn), turn);\n                getSecStrucState(i).setTurn('>', turn);\n                getSecStrucState(i + turn).setTurn('<', turn);\n                //Bracketed residues get the helix number\n                for (int j = i + 1; j < i + turn; j++) {\n                    Integer t = turn;\n                    char helix = t.toString().charAt(0);\n                    getSecStrucState(j).setTurn(helix, turn);\n                }\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Detect helical turn patterns.\n */\n", "repo_name": "biojava-master/", "id": 1601, "method_signature": "void calculateTurns()"}, "3548": {"callee_method_names": [], "method_name": "CoxCoefficient.setHazardRatioHiCI", "method_implementation": "{\n    this.hazardRatioHiCI = hazardRatioHiCI;\n}", "repo_id": "9", "comment": "/**\n * @param hazardRatioHiCI the hazardRatioHiCI to set\n */\n", "repo_name": "biojava-master/", "id": 3548, "method_signature": "void setHazardRatioHiCI(double)"}, "238": {"callee_method_names": [], "method_name": "Builder.setSystematicName", "method_implementation": "{\n    this.sysName = sysName;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the systematic name.\n * @param sysName systematic name.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 238, "method_signature": "Builder setSystematicName(String)"}, "3423": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorH.getSymmetryColors", "method_implementation": "{\n    int offset = 0;\n    int dMax = nColors + offset;\n    Color[] col = ColorBrewer.Spectral.getColorPalette(dMax);\n    Color4f[] colors = ColorConverter.convertColor4f(col);\n    System.arraycopy(colors, offset, colors, 0, dMax - offset);\n    return colors;\n}", "repo_id": "9", "comment": "/**\n * Returns a unique color palette based on point group\n * @param nColors\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3423, "method_signature": "Color4f[] getSymmetryColors(int)"}, "3538": {"callee_method_names": [], "method_name": "CoxCoefficient.getPvalue", "method_implementation": "{\n    return pvalue;\n}", "repo_id": "9", "comment": "/**\n * @return the pvalue\n */\n", "repo_name": "biojava-master/", "id": 3538, "method_signature": "double getPvalue()"}, "1717": {"callee_method_names": ["List<Pair<Group>>.size", "List<Pair<Group>>.size", "List<Pair<Group>>.size", "List<Pair<Group>>.get", "ArrayList.add", "Matrix4d.clone", "Matrix4d.invert", "Matrix4d.mul"], "method_name": "BasePairParameters.analyze", "method_implementation": "{\n    if (structure == null) {\n        pairingParameters = null;\n        stepParameters = null;\n        return this;\n    }\n    List<Chain> nucleics = this.getNucleicChains(nonredundant);\n    List<Pair<Group>> pairs = this.findPairs(nucleics);\n    this.pairingParameters = new double[pairs.size()][6];\n    this.stepParameters = new double[pairs.size()][6];\n    Matrix4d lastStep;\n    Matrix4d currentStep = null;\n    for (int i = 0; i < pairs.size(); i++) {\n        lastStep = currentStep;\n        currentStep = this.basePairReferenceFrame(pairs.get(i));\n        referenceFrames.add((Matrix4d) currentStep.clone());\n        for (int j = 0; j < 6; j++) pairingParameters[i][j] = pairParameters[j];\n        if (i != 0) {\n            lastStep.invert();\n            lastStep.mul(currentStep);\n            double[] sparms = calculateTp(lastStep);\n            for (int j = 0; j < 6; j++) stepParameters[i][j] = sparms[j];\n        }\n    }\n    return this;\n}", "repo_id": "9", "comment": "/**\n * This method is the main function call to extract all step parameters, pairing parameters, and sequence\n * information from the Structure object provided to the constructor.\n * @return This same object with the populated data, convenient for output\n *  (e.g. <i>log.info(new BasePairParameters(structure).analyze());</i>)\n */\n", "repo_name": "biojava-master/", "id": 1717, "method_signature": "BasePairParameters analyze()"}, "3398": {"callee_method_ids": [1885, 1884], "callee_method_names": ["RotationGroup.getPointGroup", "RotationAxisAligner.getSubunits", "QuatSymmetrySubunits.getModelNumbers", "QuatSymmetrySubunits.getChainIds", "RotationAxisAligner.getOrbits", "QuatSymmetrySubunits.getSubunitCount", "RotationGroup.getRotation", "String.startsWith", "String.startsWith", "List<List<Integer>>.size", "List<List<Integer>>.size", "List<List<Integer>>.size", "List<List<Integer>>.size", "List<List<Integer>>.size", "List<List<Integer>>.size", "Map<Color4f, List<String>>.get", "Map<Color4f, List<String>>.put", "List<List<Integer>>.get", "List<String>.add", "List<List<Integer>>.size", "List<List<Integer>>.size", "Map<Color4f, List<String>>.get", "Map<Color4f, List<String>>.put", "List<List<Integer>>.get", "List<Integer>.size", "List<Integer>.get", "List<String>.add"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.colorBySymmetry", "method_implementation": "{\n    // TODO needs some refactoring\n    String pointGroup = rotationGroup.getPointGroup();\n    QuatSymmetrySubunits subunits = rotationAxisAligner.getSubunits();\n    List<Integer> modelNumbers = subunits.getModelNumbers();\n    List<String> chainIds = subunits.getChainIds();\n    List<List<Integer>> orbits = rotationAxisAligner.getOrbits();\n    int n = subunits.getSubunitCount();\n    int fold = rotationGroup.getRotation(0).getFold();\n    Map<Color4f, List<String>> colorMap = new HashMap<Color4f, List<String>>();\n    // Simple Cn symmetry\n    if (pointGroup.startsWith(\"C\") && n == fold) {\n        colorMap = getCnColorMap();\n        // complex cases\n    } else if ((pointGroup.startsWith(\"D\") && orbits.size() > 2) || \"T\".equals(pointGroup) || \"O\".equals(pointGroup) || \"I\".equals(pointGroup)) {\n        int nColor = 0;\n        if (orbits.size() % 2 == 0) {\n            nColor = orbits.size() / 2;\n        } else {\n            nColor = (orbits.size() + 1) / 2;\n        }\n        Color4f[] colors = getSymmetryColors(nColor);\n        for (int i = 0; i < orbits.size(); i++) {\n            int colorIndex = i;\n            // reverse colors once the center of the structure has been reached\n            if (i >= nColor) {\n                colorIndex = orbits.size() - 1 - i;\n            }\n            Color4f c = colors[colorIndex];\n            List<String> ids = colorMap.get(c);\n            if (ids == null) {\n                ids = new ArrayList<String>();\n                colorMap.put(c, ids);\n            }\n            for (int subunit : orbits.get(i)) {\n                String id = getChainSpecification(modelNumbers, chainIds, subunit);\n                ids.add(id);\n            }\n        }\n        // Simple Dn symmetry\n    } else {\n        Color4f[] colors = getSymmetryColors(orbits.size());\n        for (int i = 0; i < orbits.size(); i++) {\n            Color4f c = new Color4f(colors[i]);\n            List<String> ids = colorMap.get(c);\n            if (ids == null) {\n                ids = new ArrayList<String>();\n                colorMap.put(c, ids);\n            }\n            List<Integer> orbit = orbits.get(i);\n            for (int j = 0; j < orbit.size(); j++) {\n                String id = getChainSpecification(modelNumbers, chainIds, orbit.get(j));\n                ids.add(id);\n            }\n        }\n    }\n    return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#colorBySymmetry()\n\t */\n", "repo_name": "biojava-master/", "id": 3398, "method_signature": "String colorBySymmetry()"}, "2262": {"callee_method_names": [], "method_name": "TestMmtfUtils.testNullNcsMatrix", "method_implementation": "{\n    double[][] output = MmtfUtils.getNcsAsArray(null);\n    assertNotNull(output);\n    Matrix4d[] outputMat = MmtfUtils.getNcsAsMatrix4d(null);\n    assertNull(outputMat);\n    double[][] outputMatArr = MmtfUtils.getNcsAsArray(outputMat);\n    assertNotNull(outputMatArr);\n}", "repo_id": "9", "comment": "/**\n * Test what happens if the NCS is null\n */\n", "repo_name": "biojava-master/", "id": 2262, "method_signature": "void testNullNcsMatrix()"}, "1190": {"callee_method_ids": [1324, 1326, 1319, 1315, 1329, 1331, 1315, 1317], "callee_method_names": ["FileParsingParameters.getMaxAtoms", "FileParsingParameters.getAtomCaThreshold", "ArrayList.clear", "ArrayList.clear", "ArrayList.clear", "ArrayList.clear", "List<Map<String, String>>.clear", "List<Map<String, String>>.clear", "List<Map<String, String>>.clear", "LinkedHashMap.clear", "FileParsingParameters.isParseCAOnly", "BufferedReader.readLine", "String.equals", "String.startsWith", "String.length", "String.startsWith", "Logger.info", "String.length", "String.trim", "String.substring", "ArrayList.add", "ArrayList.add", "ArrayList.add", "String.startsWith", "FileParsingParameters.isParseSecStruc", "Logger.info", "FileParsingParameters.shouldCreateAtomBonds", "FileParsingParameters.shouldCreateAtomCharges", "FileParsingParameters.isParseSecStruc", "FileParsingParameters.isHeaderOnly"], "method_name": "PDBFileParser.parsePDBFile", "method_implementation": "{\n    // set the correct max values for parsing...\n    loadMaxAtoms = params.getMaxAtoms();\n    atomCAThreshold = params.getAtomCaThreshold();\n    // (re)set structure\n    allModels = new ArrayList<>();\n    structure = new StructureImpl();\n    currentModel = null;\n    currentChain = null;\n    currentGroup = null;\n    // we initialise to true since at the beginning of the file we are always starting a new molecule\n    startOfMolecule = true;\n    startOfModel = true;\n    seqResChains = new ArrayList<Chain>();\n    siteMap = new LinkedHashMap<String, Site>();\n    pdbHeader = new PDBHeader();\n    connects = new ArrayList<Map<String, Integer>>();\n    previousContinuationField = \"\";\n    continuationField = \"\";\n    continuationString = \"\";\n    current_compound = null;\n    sourceLines.clear();\n    compndLines.clear();\n    keywordsLines.clear();\n    isLastCompndLine = false;\n    isLastSourceLine = false;\n    prevMolId = -1;\n    entities.clear();\n    helixList.clear();\n    strandList.clear();\n    turnList.clear();\n    lengthCheck = -1;\n    atomCount = 0;\n    atomOverflow = false;\n    linkRecords = new ArrayList<LinkRecord>();\n    siteToResidueMap.clear();\n    blankChainIdsPresent = false;\n    parseCAonly = params.isParseCAOnly();\n    String line = null;\n    while ((line = buf.readLine()) != null) {\n        // ignore empty lines\n        if (\"\".equals(line) || (line.equals(NEWLINE))) {\n            continue;\n        }\n        // ignore short TER and END lines\n        if (line.startsWith(\"END\")) {\n            continue;\n        }\n        if (line.length() < 6 && !line.startsWith(\"TER\")) {\n            logger.info(\"Found line length below 6. Ignoring it, line: >\" + line + \"<\");\n            continue;\n        }\n        String recordName = null;\n        if (line.length() < 6)\n            recordName = line.trim();\n        else\n            recordName = line.substring(0, 6).trim();\n        try {\n            if (\"ATOM\".equals(recordName))\n                pdb_ATOM_Handler(line);\n            else if (\"SEQRES\".equals(recordName))\n                pdb_SEQRES_Handler(line);\n            else if (\"HETATM\".equals(recordName))\n                pdb_ATOM_Handler(line);\n            else if (\"MODEL\".equals(recordName))\n                pdb_MODEL_Handler(line);\n            else if (\"TER\".equals(recordName))\n                pdb_TER_Handler();\n            else if (\"HEADER\".equals(recordName))\n                pdb_HEADER_Handler(line);\n            else if (\"AUTHOR\".equals(recordName))\n                pdb_AUTHOR_Handler(line);\n            else if (\"TITLE\".equals(recordName))\n                pdb_TITLE_Handler(line);\n            else if (\"SOURCE\".equals(recordName))\n                //pdb_SOURCE_Handler\n                sourceLines.add(line);\n            else if (\"COMPND\".equals(recordName))\n                //pdb_COMPND_Handler\n                compndLines.add(line);\n            else if (\"KEYWDS\".equals(recordName))\n                keywordsLines.add(line);\n            else if (\"JRNL\".equals(recordName))\n                pdb_JRNL_Handler(line);\n            else if (\"EXPDTA\".equals(recordName))\n                pdb_EXPDTA_Handler(line);\n            else if (\"CRYST1\".equals(recordName))\n                pdb_CRYST1_Handler(line);\n            else if (recordName.startsWith(\"MTRIX\"))\n                pdb_MTRIXn_Handler(line);\n            else if (\"REMARK\".equals(recordName))\n                pdb_REMARK_Handler(line);\n            else if (\"CONECT\".equals(recordName))\n                pdb_CONECT_Handler(line);\n            else if (\"REVDAT\".equals(recordName))\n                pdb_REVDAT_Handler(line);\n            else if (\"DBREF\".equals(recordName))\n                pdb_DBREF_Handler(line);\n            else if (\"SITE\".equals(recordName))\n                pdb_SITE_Handler(line);\n            else if (\"SSBOND\".equals(recordName))\n                pdb_SSBOND_Handler(line);\n            else if (\"LINK\".equals(recordName))\n                pdb_LINK_Handler(line);\n            else if (params.isParseSecStruc()) {\n                if (\"HELIX\".equals(recordName))\n                    pdb_HELIX_Handler(line);\n                else if (\"SHEET\".equals(recordName))\n                    pdb_SHEET_Handler(line);\n                else if (\"TURN\".equals(recordName))\n                    pdb_TURN_Handler(line);\n            }\n        } catch (StringIndexOutOfBoundsException | NullPointerException ex) {\n            logger.info(\"Unable to parse [\" + line + \"]\");\n        }\n    }\n    makeCompounds(compndLines, sourceLines);\n    handlePDBKeywords(keywordsLines);\n    triggerEndFileChecks();\n    if (params.shouldCreateAtomBonds()) {\n        formBonds();\n    }\n    if (params.shouldCreateAtomCharges()) {\n        addCharges();\n    }\n    if (params.isParseSecStruc() && !params.isHeaderOnly())\n        setSecStruc();\n    // Now correct the alternate location group\n    StructureTools.cleanUpAltLocs(structure);\n    return structure;\n}", "repo_id": "9", "comment": "/**\n * Parse a PDB file and return a datastructure implementing\n * PDBStructure interface.\n *\n * @param buf  a BufferedReader object\n * @return the Structure object\n * @throws IOException ...\n */\n", "repo_name": "biojava-master/", "id": 1190, "method_signature": "Structure parsePDBFile(BufferedReader)"}, "542": {"callee_method_names": ["Logger.debug", "Atom[].getGroup", "Group.clone", "Group.getAtom", "Atom[].getName", "Group.getChain", "int.getName", "Chain.getName", "Chain.setName", "Chain.getName", "List<Chain>.add", "Chain.addGroup"], "method_name": "AFPTwister.cloneAtomRange", "method_implementation": "{\n    logger.debug(\"modifyCod from: {} to: {}\", r1, r2);\n    // special clone method, can;t use StructureTools.cloneCAArray, since we\n    // access the data\n    // slightly differently here.\n    List<Chain> model = new ArrayList<>();\n    for (int i = r1; i < r2; i++) {\n        Group g = p2[i].getGroup();\n        Group newG = (Group) g.clone();\n        p1[i] = newG.getAtom(p2[i].getName());\n        Chain parentC = g.getChain();\n        Chain newChain = null;\n        for (Chain c : model) {\n            if (c.getName().equals(parentC.getName())) {\n                newChain = c;\n                break;\n            }\n        }\n        if (newChain == null) {\n            newChain = new ChainImpl();\n            newChain.setName(parentC.getName());\n            model.add(newChain);\n        }\n        newChain.addGroup(newG);\n    }\n    // modify caCod\n}", "repo_id": "9", "comment": "// orig name: modifyCod\n", "repo_name": "biojava-master/", "id": 542, "method_signature": "void cloneAtomRange(Atom[], Atom[], int, int)"}, "1232": {"callee_method_names": ["Chain.getAtomGroups", "Chain.getAtomGroups", "Logger.debug", "Chain.getId", "List<Group>.size", "Chain.getId", "List<Group>.size", "Chain.setSeqResGroups", "Logger.debug", "Chain.getAtomGroups", "Chain.getAtomGroups", "Logger.debug", "Chain.getId", "Logger.debug", "Chain.getId", "Chain.getAtomGroups", "Logger.debug", "Chain.getId", "Logger.debug", "Chain.getId", "Chain.getAtomGroups", "Chain.setSeqResGroups"], "method_name": "SeqRes2AtomAligner.mapSeqresRecords", "method_implementation": "{\n    List<Group> seqResGroups = seqRes.getAtomGroups();\n    List<Group> atmResGroups = atomRes.getAtomGroups();\n    logger.debug(\"Comparing ATOM {} ({} groups) to SEQRES {} ({} groups) \", atomRes.getId(), atmResGroups.size(), seqRes.getId(), seqResGroups.size());\n    List<Group> matchedGroups = trySimpleMatch(seqResGroups, atmResGroups);\n    if (matchedGroups != null) {\n        // update the new SEQRES list\n        atomRes.setSeqResGroups(matchedGroups);\n        return;\n    }\n    logger.debug(\"Could not map SEQRES to ATOM records easily, need to align...\");\n    int numAminosSeqres = seqRes.getAtomGroups(GroupType.AMINOACID).size();\n    int numNucleotidesSeqres = seqRes.getAtomGroups(GroupType.NUCLEOTIDE).size();\n    if (numAminosSeqres < 1) {\n        if (numNucleotidesSeqres > 1) {\n            logger.debug(\"SEQRES chain {} is a nucleotide chain ({} nucleotides), aligning nucleotides...\", seqRes.getId(), numNucleotidesSeqres);\n            alignNucleotideChains(seqRes, atomRes);\n            return;\n        } else {\n            logger.debug(\"SEQRES chain {} contains {} amino acids and {} nucleotides, ignoring...\", seqRes.getId(), numAminosSeqres, numNucleotidesSeqres);\n            return;\n        }\n    }\n    if (atomRes.getAtomGroups(GroupType.AMINOACID).size() < 1) {\n        logger.debug(\"ATOM chain {} does not contain amino acids, ignoring...\", atomRes.getId());\n        return;\n    }\n    logger.debug(\"Proceeding to do protein alignment for chain {}\", atomRes.getId());\n    boolean noMatchFound = alignProteinChains(seqResGroups, atomRes.getAtomGroups());\n    if (!noMatchFound) {\n        atomRes.setSeqResGroups(seqResGroups);\n    }\n}", "repo_id": "9", "comment": "/**\n * Map the seqRes groups to the atomRes chain.\n * Updates the atomRes chain object with the mapped data\n * The seqRes chain should not be needed after this and atomRes should be further used.\n *\n * @param atomRes the chain containing ATOM groups (in atomGroups slot). This chain\n * is modified to contain in its seqresGroups slot the mapped atom groups\n * @param seqRes the chain containing SEQRES groups (in atomGroups slot). This chain\n * is not modified\n */\n", "repo_name": "biojava-master/", "id": 1232, "method_signature": "void mapSeqresRecords(Chain, Chain)"}, "3510": {"callee_method_names": [], "method_name": "Chsolve2.process", "method_implementation": "{\n    int i, j;\n    double temp;\n    /*\n\t\t ** solve Fb =y\n\t\t */\n    for (i = 0; i < n; i++) {\n        temp = y[test][i];\n        for (j = 0; j < i; j++) {\n            temp -= y[test][j] * matrix[i][j];\n        }\n        y[test][i] = temp;\n    }\n    /*\n\t\t ** solve DF'z =b\n\t\t */\n    for (i = (n - 1); i >= 0; i--) {\n        if (matrix[i][i] == 0) {\n            y[test][i] = 0;\n        } else {\n            temp = y[test][i] / matrix[i][i];\n            for (j = i + 1; j < n; j++) {\n                temp -= y[test][j] * matrix[j][i];\n            }\n            y[test][i] = temp;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @param matrix\n * @param n\n * @param y\n * @param test\n */\n", "repo_name": "biojava-master/", "id": 3510, "method_signature": "void process(double[][], int, double[][], int)"}, "23": {"callee_method_names": ["String.equals", "StockholmStructure.addSurfaceAccessibility", "String.equals", "StockholmStructure.addTransMembrane", "String.equals", "StockholmStructure.addPosteriorProbability", "String.equals", "StockholmStructure.addLigandBinding", "String.equals", "StockholmStructure.addActiveSite", "String.equals", "StockholmStructure.addASPFamPredicted", "String.equals", "StockholmStructure.addASSwissProt", "String.equals", "StockholmStructure.addIntron", "String.equals", "StockholmStructure.addSecondaryStructure", "Logger.warn"], "method_name": "StockholmFileParser.handleResidueAnnotation", "method_implementation": "{\n    if (featureName.equals(GR_SURFACE_ACCESSIBILITY)) {\n        stockholmStructure.addSurfaceAccessibility(seqName, value);\n    } else if (featureName.equals(GR_TRANS_MEMBRANE)) {\n        stockholmStructure.addTransMembrane(seqName, value);\n    } else if (featureName.equals(GR_POSTERIOR_PROBABILITY)) {\n        stockholmStructure.addPosteriorProbability(seqName, value);\n    } else if (featureName.equals(GR_LIGAND_BINDING)) {\n        stockholmStructure.addLigandBinding(seqName, value);\n    } else if (featureName.equals(GR_ACTIVE_SITE)) {\n        stockholmStructure.addActiveSite(seqName, value);\n    } else if (featureName.equals(GR_AS_PFAM_PREDICTED)) {\n        stockholmStructure.addASPFamPredicted(seqName, value);\n    } else if (featureName.equals(GR_AS_SWISSPROT)) {\n        stockholmStructure.addASSwissProt(seqName, value);\n    } else if (featureName.equals(GR_INTRON)) {\n        stockholmStructure.addIntron(seqName, value);\n    } else if (featureName.equals(GR_SECONDARY_STRUCTURE)) {\n        stockholmStructure.addSecondaryStructure(seqName, value);\n    } else {\n        // unknown feature\n        logger.warn(\"Unknown Residue Feature [{}].\\nPlease contact the Biojava team.\", featureName);\n    }\n}", "repo_id": "9", "comment": "/**\n * #=GR &lt;seqname&gt; &lt;feature&gt; &lt;Generic per-Residue annotation, exactly 1 char per residue&gt;\n *\n * @param line\n *            the line to be parsed\n */\n", "repo_name": "biojava-master/", "id": 23, "method_signature": "void handleResidueAnnotation(String, String, String)"}, "233": {"callee_method_names": [], "method_name": "Builder.setPdbccName", "method_implementation": "{\n    this.pdbccName = pdbccName;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the Protein Data Bank Chemical Component name.\n * @param pdbccName Protein Data Bank Chemical Component name.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 233, "method_signature": "Builder setPdbccName(String)"}, "1237": {"callee_method_ids": [628], "callee_method_names": ["FastaReader<ProteinSequence, AminoAcidCompound>.process", "LinkedHashMap<String, ProteinSequence>.values", "ProteinSequence[].getAccession", "AtomCache.getStructure", "ProteinSequence[].getLength"], "method_name": "FastaStructureParser.process", "method_implementation": "{\n    if (sequences == null) {\n        // only process once, then return cached values\n        LinkedHashMap<String, ProteinSequence> sequenceMap = reader.process();\n        sequences = sequenceMap.values().toArray(new ProteinSequence[0]);\n        accessions = new String[sequences.length];\n        structures = new Structure[sequences.length];\n        residues = new ResidueNumber[sequences.length][];\n        // Match each sequence  to a series of PDB Residue numbers\n        for (int i = 0; i < sequences.length; i++) {\n            accessions[i] = sequences[i].getAccession().getID();\n            //System.out.println(\"Fetching \"+accession);\n            structures[i] = cache.getStructure(accessions[i]);\n            residues[i] = StructureSequenceMatcher.matchSequenceToStructure(sequences[i], structures[i]);\n            assert (residues[i].length == sequences[i].getLength());\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Parses the fasta file and loads it into memory.\n *\n * Information can be subsequently accessed through\n * {@link #getSequences()},\n * {@link #getStructures()},\n * {@link #getResidues()}, and\n * {@link #getAccessions()}.\n *\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 1237, "method_signature": "void process()"}, "1838": {"callee_method_names": [], "method_name": "StructureIO.getBiologicalAssembly", "method_implementation": "{\n    return getBiologicalAssembly(pdbId, biolAssemblyNr, AtomCache.DEFAULT_BIOASSEMBLY_STYLE);\n}", "repo_id": "9", "comment": "/**\n * Returns the biological assembly for the given PDB id and bioassembly identifier,\n * using multiModel={@value AtomCache#DEFAULT_BIOASSEMBLY_STYLE}\n * @param pdbId\n * @param biolAssemblyNr - the ith biological assembly that is available for a PDB ID (we start counting at 1, 0 represents the asym unit).\n * @return a Structure object or null if that assembly is not available\n * @throws StructureException if there is no bioassembly available for given biolAssemblyNr or some other problems encountered while loading it\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1838, "method_signature": "Structure getBiologicalAssembly(String, int)"}, "3873": {"callee_method_names": ["Map<AminoAcidCompound, Double>.keySet", "Map<AminoAcidCompound, Double>.get"], "method_name": "PeptideProperties.getAACompositionString", "method_implementation": "{\n    Map<AminoAcidCompound, Double> aa2Composition = getAAComposition(sequence);\n    Map<String, Double> aaString2Composition = new HashMap<String, Double>();\n    aaString2Composition = aa2Composition.keySet().stream().collect(Collectors.toMap(aaCompound -> aaCompound.getShortName(), aaCompound -> aa2Composition.get(aaCompound)));\n    return aaString2Composition;\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the composition of the 20 standard amino acid in the sequence.\n * The sequence argument must be a protein sequence consisting of only\n * non-ambiguous characters.\n * The composition of an amino acid is the total number of its occurrence,\n * divided by the total length of the sequence.\n *\n * @param sequence\n * \t\ta protein sequence consisting of non-ambiguous characters only\n * @return the composition of the 20 standard amino acid in the sequence\n */\n", "repo_name": "biojava-master/", "id": 3873, "method_signature": "Map<String,Double> getAACompositionString(String)"}, "1021": {"callee_method_names": ["Chain.getAtomGroups", "Group.isWater", "List<Atom>.addAll", "Group.getAtoms", "List<Atom>.toArray"], "method_name": "StructureTools.getAllAtomArray", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>();\n    for (Group g : c.getAtomGroups()) {\n        if (g.isWater())\n            continue;\n        atoms.addAll(g.getAtoms());\n    }\n    return atoms.toArray(new Atom[0]);\n}", "repo_id": "9", "comment": "/**\n * Returns and array of all atoms of the chain, including\n * Hydrogens (if present) and all HETATOMs. Waters are not included.\n *\n * @param c\n *            input chain\n * @return all atom array\n */\n", "repo_name": "biojava-master/", "id": 1021, "method_signature": "Atom[] getAllAtomArray(Chain)"}, "439": {"callee_method_names": [], "method_name": "StructureAlignmentOptimizer.setParameters", "method_implementation": "{\n    //Dc = 2.0\n    Dc = 3.0;\n    increase = 0.5;\n    stopLenPer = 0.95;\n    stopRmsdPer = 1.1;\n    stopRmsd = -1.0;\n    rmsdCut = 3.0;\n    gapIni = 5.0;\n    gapExt = 0.5;\n}", "repo_id": "9", "comment": "/**\n * refer CE, similarity = Dc - dij, Dc is increased by 0.5 each cycle,\n * optimization continues until either\n * i)alignment length is less than 95% of alignment length before optimization\n * ii)rmsd is less than 110% of rmsd at the cycle when condition i) was first satisfied\n */\n", "repo_name": "biojava-master/", "id": 439, "method_signature": "void setParameters()"}, "2747": {"callee_method_names": [], "method_name": "EmblRecord.getOrganismClassification", "method_implementation": "{\n    return organismClassification;\n}", "repo_id": "9", "comment": "/**\n * The OC (Organism Classification) lines contain the taxonomic classification\n * Of the source organism\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2747, "method_signature": "String getOrganismClassification()"}, "914": {"callee_method_names": [], "method_name": "BoundingBox.overlaps", "method_implementation": "{\n    if (this == o)\n        return true;\n    // x dimension\n    if (!areOverlapping(xmin, xmax, o.xmin, o.xmax, cutoff)) {\n        return false;\n    }\n    // y dimension\n    if (!areOverlapping(ymin, ymax, o.ymin, o.ymax, cutoff)) {\n        return false;\n    }\n    // z dimension\n    if (!areOverlapping(zmin, zmax, o.zmin, o.zmax, cutoff)) {\n        return false;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Returns true if this bounding box overlaps given one, i.e. they are within\n * one cutoff distance in one of their 3 dimensions.\n * @param cutoff\n * @return\n */\n", "repo_name": "biojava-master/", "id": 914, "method_signature": "boolean overlaps(BoundingBox, double)"}, "2187": {"callee_method_names": ["Block.length", "Block.length", "Block.getCoreLength", "Block.getCoreLength", "Block.getAlignRes", "Block.getAlignRes", "Block.getAlignRes", "List<Integer>.equals"], "method_name": "TestMultipleAlignmentXMLParser.equals", "method_implementation": "{\n    if (a.length() != b.length())\n        return false;\n    if (a.getCoreLength() != b.getCoreLength())\n        return false;\n    //Check all aligned residues\n    for (int i = 0; i < a.getAlignRes().size(); i++) {\n        List<Integer> chain1 = a.getAlignRes().get(i);\n        List<Integer> chain2 = b.getAlignRes().get(i);\n        if (!chain1.equals(chain2))\n            return false;\n    }\n    return true;\n}", "repo_id": "9", "comment": "/**\n * Compares the basic properties of two Blocks to determine if\n * they are equal or not.\n * Consider moving this code inside the MultipleAlignment DS.\n *\n * @param a\n * @param b\n * @return true if they are equal, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 2187, "method_signature": "boolean equals(Block, Block)"}, "1481": {"callee_method_names": [], "method_name": "SuperPositionAbstract.setCentered", "method_implementation": "{\n    this.centered = centered;\n}", "repo_id": "9", "comment": "/**\n * @param centered\n *            true if the point arrays are centered at the origin (faster),\n *            false otherwise\n */\n", "repo_name": "biojava-master/", "id": 1481, "method_signature": "void setCentered(boolean)"}, "2711": {"callee_method_names": ["Reader.read"], "method_name": "BufferedReaderBytesRead.fill", "method_implementation": "{\n    int dst;\n    if (markedChar <= UNMARKED) {\n        /* No mark */\n        dst = 0;\n    } else {\n        /* Marked */\n        int delta = nextChar - markedChar;\n        if (delta >= readAheadLimit) {\n            /* Gone past read-ahead limit: Invalidate mark */\n            markedChar = INVALIDATED;\n            readAheadLimit = 0;\n            dst = 0;\n        } else {\n            if (readAheadLimit <= cb.length) {\n                /* Shuffle in the current buffer */\n                System.arraycopy(cb, markedChar, cb, 0, delta);\n                markedChar = 0;\n                dst = delta;\n            } else {\n                /* Reallocate buffer to accommodate read-ahead limit */\n                char[] ncb = new char[readAheadLimit];\n                System.arraycopy(cb, markedChar, ncb, 0, delta);\n                cb = ncb;\n                markedChar = 0;\n                dst = delta;\n            }\n            nextChar = nChars = delta;\n        }\n    }\n    int n;\n    do {\n        n = in.read(cb, dst, cb.length - dst);\n    } while (n == 0);\n    if (n > 0) {\n        nChars = dst + n;\n        nextChar = dst;\n    }\n}", "repo_id": "9", "comment": "/**\n * Fills the input buffer, taking the mark into account if it is valid.\n */\n", "repo_name": "biojava-master/", "id": 2711, "method_signature": "void fill()"}, "2395": {"callee_method_names": [], "method_name": "Location.plus", "method_implementation": "{\n    if (isNegative()) {\n        return opposite();\n    } else {\n        return this;\n    }\n}", "repo_id": "9", "comment": "/**\n * Return location that is in same position on plus strand. If location is already\n * on plus strand, just return the location unchanged.\n *\n * @return Location on plus strand.\n */\n", "repo_name": "biojava-master/", "id": 2395, "method_signature": "Location plus()"}, "1239": {"callee_method_names": [], "method_name": "FastaStructureParser.getStructures", "method_implementation": "{\n    return structures;\n}", "repo_id": "9", "comment": "/**\n * Gets the protein structures mapped from the Fasta file.\n * Returns null if {@link #process()} has not been called.\n * @return An array of Structures for each protein\n *  in the fasta file, or null if process() hasn't been called.\n */\n", "repo_name": "biojava-master/", "id": 1239, "method_signature": "Structure[] getStructures()"}, "3316": {"callee_method_names": [], "method_name": "JMatrixPanel.setCellColor", "method_implementation": "{\n    this.cellColor = cellColor;\n}", "repo_id": "9", "comment": "/**\n * @param cellColor the color mapping of the JMatrixPanel to set\n */\n", "repo_name": "biojava-master/", "id": 3316, "method_signature": "void setCellColor(ContinuousColorMapper)"}, "749": {"callee_method_names": [], "method_name": "CeParameters.setScoringStrategy", "method_implementation": "{\n    this.scoringStrategy = scoringStrategy;\n}", "repo_id": "9", "comment": "/**\n * Set the scoring strategy to use. 0 is default CE scoring scheme. 1 uses\n * Side chain orientation.\n *\n * @param scoringStrategy\n */\n", "repo_name": "biojava-master/", "id": 749, "method_signature": "void setScoringStrategy(ScoringStrategy)"}, "2273": {"callee_method_ids": [1322], "callee_method_names": ["FileParsingParameters.setAlignSeqRes"], "method_name": "TestDifficultMmCIFFiles.testQuotingCornerCase", "method_implementation": "{\n    InputStream inStream = this.getClass().getResourceAsStream(\"/org/biojava/nbio/structure/io/difficult_mmcif_quoting.cif\");\n    FileParsingParameters fileParsingParams = new FileParsingParameters();\n    fileParsingParams.setAlignSeqRes(true);\n    Structure s = CifStructureConverter.fromInputStream(inStream, fileParsingParams);\n    assertNotNull(s);\n}", "repo_id": "9", "comment": "/**\n * This is to test the issue discussed here:\n * http://www.globalphasing.com/startools/\n * Essentially single quote characters (') are valid not only for quoting, but also as parts of\n * data values as long as some rules of the STAR format are followed.\n * For instance Phenix produces mmCIF files with non-quoted strings containing single quote characters\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2273, "method_signature": "void testQuotingCornerCase()"}, "1238": {"callee_method_names": [], "method_name": "FastaStructureParser.getSequences", "method_implementation": "{\n    return sequences;\n}", "repo_id": "9", "comment": "/**\n * Gets the protein sequences read from the Fasta file.\n * Returns null if {@link #process()} has not been called.\n * @return An array ProteinSequences from\n *  parsing the fasta file, or null if process() hasn't been called.\n */\n", "repo_name": "biojava-master/", "id": 1238, "method_signature": "ProteinSequence[] getSequences()"}, "3027": {"callee_method_names": [], "method_name": "Location.location", "method_implementation": "{\n    int min = Math.min(start, end);\n    //if this is true then we have a coord on the +ve strand even though Strand could be negative\n    boolean isReverse = (min != start);\n    if (isReverse) {\n        return new SimpleLocation(new SimplePoint(start).reverse(length), new SimplePoint(end).reverse(length), strand);\n    }\n    return new SimpleLocation(start, end, strand);\n}", "repo_id": "9", "comment": "/**\n * Returns a location object which unlike the location constructors\n * allows you to input reverse coordinates and will convert\n * these into the right location on the positive strand.\n */\n", "repo_name": "biojava-master/", "id": 3027, "method_signature": "Location location(int, int, Strand, int)"}, "3359": {"callee_method_names": ["NavigableMap<Double, Color>.size"], "method_name": "GradientMapper.size", "method_implementation": "{\n    return mapping.size() - 2;\n}", "repo_id": "9", "comment": "/**\n * @return Number of finite endpoints\n * @see java.util.Map#size()\n */\n", "repo_name": "biojava-master/", "id": 3359, "method_signature": "int size()"}, "3314": {"callee_method_names": ["Matrix.getRowDimension", "Matrix.getColumnDimension", "Matrix.get", "ContinuousColorMapper.getColor", "Graphics2D.setColor", "Graphics2D.fillRect"], "method_name": "JMatrixPanel.drawDistances", "method_implementation": "{\n    Graphics2D g = (Graphics2D) g1;\n    int c = matrix.getRowDimension();\n    int d = matrix.getColumnDimension();\n    float scale = getScale();\n    int width = Math.round(scale);\n    for (int i = 0; i < c; i++) {\n        int ipaint = Math.round(i * scale);\n        for (int j = 0; j < d; j++) {\n            double val = matrix.get(i, j);\n            int jpaint = Math.round(j * scale);\n            Color color = cellColor.getColor(val);\n            g.setColor(color);\n            g.fillRect(ipaint, jpaint, width, width);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * For each element in matrix, draw it as a colored square or pixel.\n *\n * The color of a matrix element with value x is specified as\n *   - H: 1-x/scalevalue\n *   - S: saturation\n *   - B: 1-x/scalevalue\n * @param g1\n */\n", "repo_name": "biojava-master/", "id": 3314, "method_signature": "void drawDistances(Graphics)"}, "1869": {"callee_method_names": [], "method_name": "Rotation.getNStart", "method_implementation": "{\n    int nStart = 0;\n    for (int i : permutation) {\n        if (i == -1) {\n            nStart++;\n        }\n    }\n    return nStart;\n}", "repo_id": "9", "comment": "/**\n * Returns the number of starts if this rotation represents a helical rotation\n */\n", "repo_name": "biojava-master/", "id": 1869, "method_signature": "int getNStart()"}, "2566": {"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.length", "StringBuffer.insert", "StringBuffer.toString"], "method_name": "CRC64Checksum.toString", "method_implementation": "{\n    StringBuffer builder = new StringBuffer();\n    builder.append(Long.toHexString(crc >>> 4));\n    builder.append(Long.toHexString(crc & 0xF));\n    for (int i = 16 - builder.length(); i > 0; --i) builder.insert(0, '0');\n    return builder.toString().toUpperCase();\n}", "repo_id": "9", "comment": "/**\n * Returns a zero-padded 16 character wide string containing the current\n * value of this checksum in uppercase hexadecimal format.\n */\n", "repo_name": "biojava-master/", "id": 2566, "method_signature": "String toString()"}, "567": {"callee_method_names": ["Atom.setCoords"], "method_name": "RotationAxis.calculateTranslationalAxis", "method_implementation": "{\n    // set axis parallel to translation\n    rotationAxis = Calc.scale(translation, 1. / Calc.amount(translation));\n    // position is undefined\n    rotationPos = null;\n    screwTranslation = translation;\n    otherTranslation = new AtomImpl();\n    otherTranslation.setCoords(new double[] { 0, 0, 0 });\n}", "repo_id": "9", "comment": "/**\n * Handle cases with small angles of rotation\n * @param rotation\n * @param translation\n */\n", "repo_name": "biojava-master/", "id": 567, "method_signature": "void calculateTranslationalAxis(Matrix, Atom)"}, "1218": {"callee_method_names": [], "method_name": "ChemCompConverter.fromPath", "method_implementation": "{\n    return fromInputStream(Files.newInputStream(path));\n}", "repo_id": "9", "comment": "/**\n * Read data from a file and convert to chem comp dictionary.\n * @param path the source of information - can be gzipped or binary or text data\n * @return the target\n */\n", "repo_name": "biojava-master/", "id": 1218, "method_signature": "ChemicalComponentDictionary fromPath(Path)"}, "1765": {"callee_method_names": [], "method_name": "PDBHeader.getIdCode", "method_implementation": "{\n    if (this.pdbId == null)\n        return null;\n    return this.pdbId.getId();\n}", "repo_id": "9", "comment": "/**\n * The PDB code for this protein structure.\n *\n * @return the PDB identifier\n * @see #setIdCode(String)\n * @deprecated use {@link #getPdbId()}\n */\n", "repo_name": "biojava-master/", "id": 1765, "method_signature": "String getIdCode()"}, "1699": {"callee_method_names": [], "method_name": "AtomImpl.getGroup", "method_implementation": "{\n    return parent;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1699, "method_signature": "Group getGroup()"}, "3292": {"callee_method_names": ["Point.setLocation"], "method_name": "MultipleAlignmentCoordManager.getPanelPos", "method_implementation": "{\n    Point p = new Point();\n    int lineNr = pos / DEFAULT_LINE_LENGTH;\n    int linePos = pos % DEFAULT_LINE_LENGTH;\n    int x = linePos * DEFAULT_CHAR_SIZE + DEFAULT_X_SPACE + DEFAULT_LEGEND_SIZE;\n    int y = lineNr * DEFAULT_Y_STEP + DEFAULT_Y_SPACE;\n    y += DEFAULT_LINE_SEPARATION * structure;\n    p.setLocation(x, y);\n    return p;\n}", "repo_id": "9", "comment": "/**\n * Get the X position on the Panel of a particular sequence position.\n *\n * @param structure index of the structure for the sequence position.\n * @param pos sequence position, the aligned position index\n * @return the point on a panel for a sequence position\n */\n", "repo_name": "biojava-master/", "id": 3292, "method_signature": "Point getPanelPos(int, int)"}, "472": {"callee_method_ids": [465, 1400], "callee_method_names": ["StructureName.getPdbId", "PdbId.getId"], "method_name": "PdbPair.getPDBCode1", "method_implementation": "{\n    PdbId pdbId = name1.getPdbId();\n    return pdbId == null ? null : pdbId.getId();\n}", "repo_id": "9", "comment": "/**\n * @deprecated use {@link #getPDBCode1()} instead\n * @return\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 472, "method_signature": "String getPDBCode1()"}, "1739": {"callee_method_names": ["Matrix4d.getElement"], "method_name": "BasePairParameters.calculateTp", "method_implementation": "{\n    double[][] A = new double[4][4];\n    for (int i = 0; i < 4; i++) for (int j = 0; j < 4; j++) {\n        A[i][j] = input.getElement(i, j);\n    }\n    double[] M = new double[6];\n    double cosgamma, gamma, phi, omega, sgcp, omega2_minus_phi, sm, cm, sp, cp, sg, cg;\n    cosgamma = A[2][2];\n    if (cosgamma > 1.0)\n        cosgamma = 1.0;\n    else if (cosgamma < -1.0)\n        cosgamma = -1.0;\n    gamma = acos(cosgamma);\n    sgcp = A[1][1] * A[0][2] - A[0][1] * A[1][2];\n    if (gamma == 0.0)\n        omega = -atan2(A[0][1], A[1][1]);\n    else\n        omega = atan2(A[2][1] * A[0][2] + sgcp * A[1][2], sgcp * A[0][2] - A[2][1] * A[1][2]);\n    omega2_minus_phi = atan2(A[1][2], A[0][2]);\n    phi = omega / 2.0 - omega2_minus_phi;\n    M[0] = gamma * sin(phi) * 180.0 / PI;\n    M[1] = gamma * cos(phi) * 180.0 / PI;\n    M[2] = omega * 180.0 / PI;\n    sm = sin(omega / 2.0 - phi);\n    cm = cos(omega / 2.0 - phi);\n    sp = sin(phi);\n    cp = cos(phi);\n    sg = sin(gamma / 2.0);\n    cg = cos(gamma / 2.0);\n    M[3] = (cm * cg * cp - sm * sp) * A[0][3] + (sm * cg * cp + cm * sp) * A[1][3] - sg * cp * A[2][3];\n    M[4] = (-cm * cg * sp - sm * cp) * A[0][3] + (-sm * cg * sp + cm * cp) * A[1][3] + sg * sp * A[2][3];\n    M[5] = (cm * sg) * A[0][3] + (sm * sg) * A[1][3] + cg * A[2][3];\n    return M;\n}", "repo_id": "9", "comment": "/**\n * This method calculates pairing and step parameters from 4x4 transformation matrices (used internally)\n * that comes out as a Matrix4d.\n * @param input the 4x4 matrix representing the transformation from strand II -> strand I or pair i to pair i+1\n * @return Six parameters as double[6]\n */\n", "repo_name": "biojava-master/", "id": 1739, "method_signature": "double[] calculateTp(Matrix4d)"}, "1674": {"callee_method_names": [], "method_name": "Subunit.setName", "method_implementation": "{\n    this.name = name;\n}", "repo_id": "9", "comment": "/**\n * The Name of a Subunit is a free-text field, user defined.\n *\n * @param name\n *            of the Subunit\n */\n", "repo_name": "biojava-master/", "id": 1674, "method_signature": "void setName(String)"}, "1058": {"callee_method_ids": [1190, 628], "callee_method_names": ["File.exists", "PDBFileParser.parsePDBFile", "AtomCache.getStructure"], "method_name": "StructureTools.getStructure", "method_implementation": "{\n    File f = new File(FileDownloadUtils.expandUserHome(name));\n    if (f.exists()) {\n        if (parser == null) {\n            parser = new PDBFileParser();\n        }\n        InputStream inStream = new FileInputStream(f);\n        return parser.parsePDBFile(inStream);\n    } else {\n        if (cache == null) {\n            cache = new AtomCache();\n        }\n        return cache.getStructure(name);\n    }\n}", "repo_id": "9", "comment": "/**\n * Flexibly get a structure from an input String. The intent of this method\n * is to allow any reasonable string which could refer to a structure to be\n * correctly parsed. The following are currently supported:\n * <ol>\n * <li>Filename (if name refers to an existing file)\n * <li>PDB ID\n * <li>SCOP domains\n * <li>PDP domains\n * <li>Residue ranges\n * <li>Other formats supported by AtomCache\n * </ol>\n *\n * @param name\n *            Some reference to the protein structure\n * @param parser\n *            A clean PDBFileParser to use if it is a file. If null, a\n *            PDBFileParser will be instantiated if needed.\n * @param cache\n *            An AtomCache to use if the structure can be fetched from the\n *            PDB. If null, a AtomCache will be instantiated if needed.\n * @return A Structure object\n * @throws IOException\n *             if name is an existing file, but doesn't parse correctly\n * @throws StructureException\n *             if the format is unknown, or if AtomCache throws an\n *             exception.\n */\n", "repo_name": "biojava-master/", "id": 1058, "method_signature": "Structure getStructure(String, PDBFileParser, AtomCache)"}, "584": {"callee_method_names": [], "method_name": "AlignmentTools.getSymmetryOrder", "method_implementation": "{\n    // alignment comes from the afpChain alignment\n    Map<Integer, Integer> alignment = AlignmentTools.alignmentAsMap(afpChain);\n    // Now construct identity to map aligned residues in sequential order\n    Map<Integer, Integer> identity = guessSequentialAlignment(alignment, true);\n    return AlignmentTools.getSymmetryOrder(alignment, identity, maxSymmetry, minimumMetricChange);\n}", "repo_id": "9", "comment": "/**\n * Guesses the order of symmetry in an alignment\n *\n * <p>Uses {@link #getSymmetryOrder(Map alignment, Map identity, int, float)}\n * to determine the the symmetry order. For the identity alignment, sorts\n * the aligned residues of each protein sequentially, then defines the ith\n * residues of each protein to be equivalent.\n *\n * <p>Note that the selection of the identity alignment here is <i>very</i>\n * naive, and only works for proteins with very good coverage. Wherever\n * possible, it is better to construct an identity function explicitly\n * from a sequence alignment (or use an {@link IdentityMap} for internally\n * symmetric proteins) and use {@link #getSymmetryOrder(Map, Map, int, float)}.\n */\n", "repo_name": "biojava-master/", "id": 584, "method_signature": "int getSymmetryOrder(AFPChain, int, float)"}, "3110": {"callee_method_names": ["ArrayList.add"], "method_name": "QuantityFeature.addQuantity", "method_implementation": "{\n    quantities.add(value);\n}", "repo_id": "9", "comment": "/**\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 3110, "method_signature": "void addQuantity(Number)"}, "2530": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum75", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum75\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 75 matrix by Henikoff & Henikoff\n * @return Blosum 75 matrix\n */\n", "repo_name": "biojava-master/", "id": 2530, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum75()"}, "2863": {"callee_method_ids": [2788], "callee_method_names": ["DNASequenceCreator.getSequence"], "method_name": "ABITrace.getSequence", "method_implementation": "{\n    DNASequenceCreator creator = new DNASequenceCreator(ABITracerCompoundSet.getABITracerCompoundSet());\n    return creator.getSequence(sequence, 0);\n}", "repo_id": "9", "comment": "/**\n * Returns the original programmatically determined (unedited) sequence as a <code>AbstractSequence<NucleotideCompound></code>.\n *\n * @return AbstractSequence<NucleotideCompound> sequence\n */\n", "repo_name": "biojava-master/", "id": 2863, "method_signature": "AbstractSequence<NucleotideCompound> getSequence()"}, "1626": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getRMSDThreshold", "method_implementation": "{\n    return rmsdThreshold;\n}", "repo_id": "9", "comment": "/**\n * Structure similarity threshold (measured with RMSD) to consider for the\n * structural subunit clustering.\n *\n * @return rmsdThreshold\n */\n", "repo_name": "biojava-master/", "id": 1626, "method_signature": "double getRMSDThreshold()"}, "1167": {"callee_method_ids": [1774, 1775, 1777, 1777], "callee_method_names": ["PDBHeader.getModDate", "Date.equals", "String.substring", "DateFormat.parse", "PDBHeader.setModDate", "PDBHeader.setRelDate", "Logger.info", "String.substring", "DateFormat.parse", "PDBHeader.setRelDate", "Logger.info"], "method_name": "PDBFileParser.pdb_REVDAT_Handler", "method_implementation": "{\n    // keep the first as latest modified date and the last as release date\n    Date modDate = pdbHeader.getModDate();\n    if (modDate == null || modDate.equals(new Date(0))) {\n        // modified date is still uninitialized\n        String modificationDate = line.substring(13, 22).trim();\n        try {\n            Date dep = dateFormat.parse(modificationDate);\n            pdbHeader.setModDate(dep);\n            pdbHeader.setRelDate(dep);\n        } catch (ParseException e) {\n            logger.info(\"Could not parse revision date string '\" + modificationDate + \"'. \");\n        }\n    } else {\n        // set as the release date\n        String releaseDate = line.substring(13, 22).trim();\n        try {\n            Date dep = dateFormat.parse(releaseDate);\n            pdbHeader.setRelDate(dep);\n        } catch (ParseException e) {\n            logger.info(\"Could not parse revision date string '\" + releaseDate + \"'. \");\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Handler for\n * REVDAT Record format:\n * <pre>\n *\n * COLUMNS       DATA TYPE      FIELD         DEFINITION\n * ----------------------------------------------------------------------------------\n * 1 -  6       Record name    \"REVDAT\"\n * 8 - 10       Integer        modNum        Modification number.\n * 11 - 12       Continuation   continuation  Allows concatenation of multiple\n * records.\n * 14 - 22       Date           modDate       Date of modification (or release for\n * new entries).  This is not repeated\n * on continuation lines.\n * 24 - 28       String(5)      modId         Identifies this particular\n * modification.  It links to the\n * archive used internally by PDB.\n * This is not repeated on continuation\n * lines.\n * 32            Integer        modType       An integer identifying the type of\n * modification.  In case of revisions\n * with more than one possible modType,\n * the highest value applicable will be\n * assigned.\n * 40 - 45       LString(6)     record        Name of the modified record.\n * 47 - 52       LString(6)     record        Name of the modified record.\n * 54 - 59       LString(6)     record        Name of the modified record.\n * 61 - 66       LString(6)     record        Name of the modified record.\n * </pre>\n */\n", "repo_name": "biojava-master/", "id": 1167, "method_signature": "void pdb_REVDAT_Handler(String)"}, "3540": {"callee_method_names": [], "method_name": "CoxCoefficient.getStandardDeviation", "method_implementation": "{\n    return standardDeviation;\n}", "repo_id": "9", "comment": "/**\n * @return the standardDeviation\n */\n", "repo_name": "biojava-master/", "id": 3540, "method_signature": "double getStandardDeviation()"}, "3458": {"callee_method_names": [], "method_name": "NCBIQBlastOutputProperties.getDescriptionNumber", "method_implementation": "{\n    return Integer.parseInt(getOutputOption(DESCRIPTIONS));\n}", "repo_id": "9", "comment": "/**\n * @return number of descriptions fetched - an int with the value of the key DESCRIPTIONS\n */\n", "repo_name": "biojava-master/", "id": 3458, "method_signature": "int getDescriptionNumber()"}, "2950": {"callee_method_names": [], "method_name": "AbstractSequence.getInverse", "method_implementation": "{\n    return SequenceMixin.inverse(this);\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2950, "method_signature": "SequenceView<C> getInverse()"}, "3487": {"callee_method_names": ["HashMap.containsKey"], "method_name": "NCBIQBlastAlignmentProperties.getBlastExpect", "method_implementation": "{\n    if (param.containsKey(EXPECT)) {\n        return Double.parseDouble(getAlignmentOption(EXPECT));\n    }\n    return 10;\n}", "repo_id": "9", "comment": "/**\n * @return double value of EXPECT parameter used for blast run\n */\n", "repo_name": "biojava-master/", "id": 3487, "method_signature": "double getBlastExpect()"}, "1410": {"callee_method_names": [], "method_name": "PDBCrystallographicInfo.getCrystalCell", "method_implementation": "{\n    return cell;\n}", "repo_id": "9", "comment": "/**\n * Return the crystal cell\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1410, "method_signature": "CrystalCell getCrystalCell()"}, "702": {"callee_method_names": ["BlockSet.length"], "method_name": "MultipleAlignmentImpl.updateLength", "method_implementation": "{\n    if (getBlockSets().size() == 0) {\n        throw new IndexOutOfBoundsException(\"Empty MultipleAlignment: blockSets size == 0.\");\n    } else // Otherwise try to calculate it from the BlockSet information\n    {\n        length = 0;\n        for (BlockSet blockSet : blockSets) length += blockSet.length();\n    }\n}", "repo_id": "9", "comment": "/**\n * Force recalculation of the length (aligned columns) based on the BlockSet\n * lengths.\n */\n", "repo_name": "biojava-master/", "id": 702, "method_signature": "void updateLength()"}, "2774": {"callee_method_names": [], "method_name": "IUPACParser.getTables", "method_implementation": "{\n    if (tables == null) {\n        tables = parseTables();\n    }\n    return tables;\n}", "repo_id": "9", "comment": "/**\n * Returns a list of all available IUPAC tables\n */\n", "repo_name": "biojava-master/", "id": 2774, "method_signature": "List<IUPACTable> getTables()"}, "3861": {"callee_method_names": ["AminoAcidCompositionTable.getSymbolSet", "AminoAcidCompositionTable.getAminoAcidCompoundSet", "Logger.error", "int.getMessage", "IPeptideProperties.getMolecularWeightBasedOnXML"], "method_name": "PeptideProperties.getMolecularWeightBasedOnXML", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence, aminoAcidCompositionTable.getSymbolSet());\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence, aminoAcidCompositionTable.getAminoAcidCompoundSet());\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getMolecularWeightBasedOnXML(pSequence, aminoAcidCompositionTable);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method that returns the molecular weight of sequence. The sequence argument must be a protein sequence consisting of only non-ambiguous characters.\n * This method will sum the molecular weight of each amino acid in the\n * sequence. Molecular weights are based on the AminoAcidCompositionTable.\n * Those input files must be XML using the defined schema.\n *\n * @param sequence\n * \ta protein sequence consisting of non-ambiguous characters only\n * @param aminoAcidCompositionTable\n * \ta amino acid composition table obtained by calling IPeptideProperties.obtainAminoAcidCompositionTable\n * @return the total molecular weight of sequence + weight of water molecule\n * \tthrown if the method IPeptideProperties.setMolecularWeightXML(File, File) is not successfully called before calling this method.\n */\n", "repo_name": "biojava-master/", "id": 3861, "method_signature": "double getMolecularWeightBasedOnXML(String, AminoAcidCompositionTable)"}, "1075": {"callee_method_names": ["String.equals", "Logger.info", "ChemComp.getName", "ChemComp.getAtoms", "Logger.info", "HashSet.add"], "method_name": "ZipChemCompProvider.getChemComp", "method_implementation": "{\n    if (null == recordName)\n        return null;\n    // handle non-existent ChemComp codes and do not repeatedly attempt to add these.\n    for (String str : unavailable) {\n        if (recordName.equals(str))\n            return getEmptyChemComp(recordName);\n    }\n    // Try to pull from zip, if fail then download.\n    ChemComp cc = getFromZip(recordName);\n    if (cc == null) {\n        s_logger.info(\"File {} not found in archive. Attempting download from PDB.\", recordName);\n        cc = downloadAndAdd(recordName);\n    }\n    // If a null record or an empty chemcomp, return a default ChemComp and blacklist.\n    if (cc == null || (null == cc.getName() && cc.getAtoms().size() == 0)) {\n        s_logger.info(\"Unable to find or download {} - excluding from future searches.\", recordName);\n        unavailable.add(recordName);\n        return getEmptyChemComp(recordName);\n    }\n    return cc;\n}", "repo_id": "9", "comment": "/**\n * (non-Javadoc)\n * @see ChemCompProvider#getChemComp(java.lang.String)\n *\n * @param recordName : three letter PDB name for a residue\n * @return ChemComp from .zip or ChemComp from repository.  Will return empty ChemComp when unable to find a residue and will return null if not provided a valid recordName.\n */\n", "repo_name": "biojava-master/", "id": 1075, "method_signature": "ChemComp getChemComp(String)"}, "1500": {"callee_method_names": ["SuperPositionQuat.setCentered", "SuperPositionQuat.getRmsd"], "method_name": "SuperPositions.getRmsd", "method_implementation": "{\n    superposer.setCentered(false);\n    return superposer.getRmsd(fixed, moved);\n}", "repo_id": "9", "comment": "/**\n * Use the {@link SuperPosition#getRmsd(Point3d[], Point3d[])} method of the\n * default static SuperPosition algorithm contained in this Class.\n */\n", "repo_name": "biojava-master/", "id": 1500, "method_signature": "double getRmsd(Point3d[], Point3d[])"}, "1643": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setUseTMScore", "method_implementation": "{\n    this.useTMScore = useTMScore;\n}", "repo_id": "9", "comment": "/**\n * Use TMScore for evaluating structure similarity\n *\n * @param useTMScore\n */\n", "repo_name": "biojava-master/", "id": 1643, "method_signature": "void setUseTMScore(boolean)"}, "594": {"callee_method_ids": [477, 487, 487, 498, 490, 489, 487, 487, 487, 490, 490, 490, 490], "callee_method_names": ["AFPChain.setCa1Length", "AFPChain.setCa2Length", "AFPChain.getFocusRes1", "AFPChain.getFocusRes2", "AFPChain.getCa1Length", "AFPChain.setFocusRes1", "AFPChain.getCa2Length", "AFPChain.setFocusRes2", "AFPChain.getNrEQR", "AFPChain.getOptLength", "AFPChain.getOptLength", "AFPChain.getBlockNum", "AFPChain.setBlockRotationMatrix", "AFPChain.getBlockNum", "AFPChain.setBlockShiftVector", "AFPChain.setTotalRmsdOpt", "AFPChain.setTMScore", "AFPChain.getOptLen", "AFPChain.getOptAln", "AFPChain.getBlockNum", "AFPChain.getBlockNum", "AFPChain.getBlockNum", "AFPChain.getOptLen", "AFPChain.getOptLen", "Atom[].clone", "AFPChain.getOptLen", "Logger.warn", "AFPChain.getOptLen", "AFPChain.setOptRmsd", "AFPChain.setBlockRmsd", "AFPChain.setBlockScore"], "method_name": "AlignmentTools.updateSuperposition", "method_implementation": "{\n    //Update ca information, because the atom array might also be changed\n    afpChain.setCa1Length(ca1.length);\n    afpChain.setCa2Length(ca2.length);\n    //We need this to get the correct superposition\n    int[] focusRes1 = afpChain.getFocusRes1();\n    int[] focusRes2 = afpChain.getFocusRes2();\n    if (focusRes1 == null) {\n        focusRes1 = new int[afpChain.getCa1Length()];\n        afpChain.setFocusRes1(focusRes1);\n    }\n    if (focusRes2 == null) {\n        focusRes2 = new int[afpChain.getCa2Length()];\n        afpChain.setFocusRes2(focusRes2);\n    }\n    if (afpChain.getNrEQR() == 0)\n        return;\n    // create new arrays for the subset of atoms in the alignment.\n    Atom[] ca1aligned = new Atom[afpChain.getOptLength()];\n    Atom[] ca2aligned = new Atom[afpChain.getOptLength()];\n    fillAlignedAtomArrays(afpChain, ca1, ca2, ca1aligned, ca2aligned);\n    //Superimpose the two structures in correspondance to the new alignment\n    Matrix4d trans = SuperPositions.superpose(Calc.atomsToPoints(ca1aligned), Calc.atomsToPoints(ca2aligned));\n    Matrix matrix = Matrices.getRotationJAMA(trans);\n    Atom shift = Calc.getTranslationVector(trans);\n    Matrix[] blockMxs = new Matrix[afpChain.getBlockNum()];\n    Arrays.fill(blockMxs, matrix);\n    afpChain.setBlockRotationMatrix(blockMxs);\n    Atom[] blockShifts = new Atom[afpChain.getBlockNum()];\n    Arrays.fill(blockShifts, shift);\n    afpChain.setBlockShiftVector(blockShifts);\n    for (Atom a : ca2aligned) {\n        Calc.rotate(a, matrix);\n        Calc.shift(a, shift);\n    }\n    //Calculate the RMSD and TM score for the new alignment\n    double rmsd = Calc.rmsd(ca1aligned, ca2aligned);\n    double tmScore = Calc.getTMScore(ca1aligned, ca2aligned, ca1.length, ca2.length);\n    afpChain.setTotalRmsdOpt(rmsd);\n    afpChain.setTMScore(tmScore);\n    int[] blockLens = afpChain.getOptLen();\n    int[][][] optAln = afpChain.getOptAln();\n    //Calculate the RMSD and TM score for every block of the new alignment\n    double[] blockRMSD = new double[afpChain.getBlockNum()];\n    double[] blockScore = new double[afpChain.getBlockNum()];\n    for (int k = 0; k < afpChain.getBlockNum(); k++) {\n        //Create the atom arrays corresponding to the aligned residues in the block\n        Atom[] ca1block = new Atom[afpChain.getOptLen()[k]];\n        Atom[] ca2block = new Atom[afpChain.getOptLen()[k]];\n        int position = 0;\n        for (int i = 0; i < blockLens[k]; i++) {\n            int pos1 = optAln[k][0][i];\n            int pos2 = optAln[k][1][i];\n            Atom a1 = ca1[pos1];\n            Atom a2 = (Atom) ca2[pos2].clone();\n            ca1block[position] = a1;\n            ca2block[position] = a2;\n            position++;\n        }\n        if (position != afpChain.getOptLen()[k]) {\n            logger.warn(\"AFPChainScorer getTMScore: Problems reconstructing block alignment! nr of loaded atoms is \" + position + \" but should be \" + afpChain.getOptLen()[k]);\n            // we need to resize the array, because we allocated too many atoms earlier on.\n            ca1block = (Atom[]) resizeArray(ca1block, position);\n            ca2block = (Atom[]) resizeArray(ca2block, position);\n        }\n        //Superimpose the two block structures\n        Matrix4d transb = SuperPositions.superpose(Calc.atomsToPoints(ca1block), Calc.atomsToPoints(ca2block));\n        blockMxs[k] = Matrices.getRotationJAMA(trans);\n        blockShifts[k] = Calc.getTranslationVector(trans);\n        Calc.transform(ca2block, transb);\n        //Calculate the RMSD and TM score for the block\n        double rmsdb = Calc.rmsd(ca1block, ca2block);\n        double tmScoreb = Calc.getTMScore(ca1block, ca2block, ca1.length, ca2.length);\n        blockRMSD[k] = rmsdb;\n        blockScore[k] = tmScoreb;\n    }\n    afpChain.setOptRmsd(blockRMSD);\n    afpChain.setBlockRmsd(blockRMSD);\n    afpChain.setBlockScore(blockScore);\n}", "repo_id": "9", "comment": "/**\n * After the alignment changes (optAln, optLen, blockNum, at a minimum),\n * many other properties which depend on the superposition will be invalid.\n *\n * This method re-runs a rigid superposition over the whole alignment\n * and repopulates the required properties, including RMSD (TotalRMSD) and\n * TM-Score.\n * @param afpChain\n * @param ca1\n * @param ca2 Second set of ca atoms. Will be modified based on the superposition\n * @throws StructureException\n * @see {@link CECalculator#calc_rmsd(Atom[], Atom[], int, boolean)}\n *  contains much of the same code, but stores results in a CECalculator\n *  instance rather than an AFPChain\n */\n", "repo_name": "biojava-master/", "id": 594, "method_signature": "void updateSuperposition(AFPChain, Atom[], Atom[])"}, "3355": {"callee_method_names": ["NavigableMap<Double, Color>.keySet"], "method_name": "GradientMapper.keySet", "method_implementation": "{\n    return mapping.keySet();\n}", "repo_id": "9", "comment": "/**\n * @return\n * @see java.util.Map#keySet()\n */\n", "repo_name": "biojava-master/", "id": 3355, "method_signature": "Set<Double> keySet()"}, "973": {"callee_method_names": ["ArrayList.size", "ArrayList.add", "ArrayList.indexOf", "ArrayList.add", "ArrayList.indexOf", "Structure.addChain", "Structure.nrModels", "List<Chain>.add", "Structure.addModel", "Structure.addChain"], "method_name": "BiologicalAssemblyBuilder.addChainMultiModel", "method_implementation": "{\n    // multi-model bioassembly\n    if (modelIndex.size() == 0)\n        modelIndex.add(\"PLACEHOLDER FOR ASYM UNIT\");\n    int modelCount = modelIndex.indexOf(transformId);\n    if (modelCount == -1) {\n        modelIndex.add(transformId);\n        modelCount = modelIndex.indexOf(transformId);\n    }\n    if (modelCount == 0) {\n        s.addChain(newChain);\n    } else if (modelCount > s.nrModels()) {\n        List<Chain> newModel = new ArrayList<>();\n        newModel.add(newChain);\n        s.addModel(newModel);\n    } else {\n        s.addChain(newChain, modelCount - 1);\n    }\n}", "repo_id": "9", "comment": "/**\n * Adds a chain to the given structure to form a biological assembly,\n * adding the symmetry expanded chains as new models per transformId.\n * @param s\n * @param newChain\n * @param transformId\n */\n", "repo_name": "biojava-master/", "id": 973, "method_signature": "void addChainMultiModel(Structure, Chain, String)"}, "3507": {"callee_method_names": [], "method_name": "ChiSq.main", "method_implementation": "{\n    // TODO code application logic here\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3507, "method_signature": "void main(String[])"}, "161": {"callee_method_names": ["String.split"], "method_name": "CifFileSupplierIntegrationTest.testBiounitWriting", "method_implementation": "{\n    Structure s = createDummyStructure();\n    String mmcif = CifStructureConverter.toText(s);\n    String[] lines = mmcif.split(\"\\n\");\n    long atomLines = Arrays.stream(lines).filter(l -> l.startsWith(\"ATOM\")).count();\n    assertNotNull(mmcif);\n    assertEquals(4, atomLines);\n}", "repo_id": "9", "comment": "/**\n * Tests that structures containing symmetry mates with modified chain identifiers\n * can be written out correctly.\n */\n", "repo_name": "biojava-master/", "id": 161, "method_signature": "void testBiounitWriting()"}, "1156": {"callee_method_names": ["Atom.getGroup", "Group.getType", "GroupType.equals", "Group.getPDBName", "Group.getResidueNumber", "Atom.getPDBserial", "Atom.getAltLoc", "DecimalFormat.format", "Atom.getX", "DecimalFormat.format", "Atom.getY", "DecimalFormat.format", "Atom.getZ", "DecimalFormat.format", "Atom.getOccupancy", "DecimalFormat.format", "Atom.getTempFactor", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "Atom.getElement", "Element.toString", "Element.equals", "StringBuffer.append", "StringBuffer.toString", "StringBuffer.append"], "method_name": "FileConvert.toPDB", "method_implementation": "{\n    Group g = a.getGroup();\n    GroupType type = g.getType();\n    String record = \"\";\n    if (type.equals(GroupType.HETATM)) {\n        record = \"HETATM\";\n    } else {\n        record = \"ATOM  \";\n    }\n    // format output ...\n    String resName = g.getPDBName();\n    String pdbcode = g.getResidueNumber().toString();\n    int seri = a.getPDBserial();\n    String serial = String.format(\"%5d\", seri);\n    String fullName = formatAtomName(a);\n    Character altLoc = a.getAltLoc();\n    if (altLoc == null)\n        altLoc = ' ';\n    String resseq = \"\";\n    if (hasInsertionCode(pdbcode))\n        resseq = String.format(\"%5s\", pdbcode);\n    else\n        resseq = String.format(\"%4s\", pdbcode) + \" \";\n    String x = String.format(\"%8s\", d3.format(a.getX()));\n    String y = String.format(\"%8s\", d3.format(a.getY()));\n    String z = String.format(\"%8s\", d3.format(a.getZ()));\n    String occupancy = String.format(\"%6s\", d2.format(a.getOccupancy()));\n    String tempfactor = String.format(\"%6s\", d2.format(a.getTempFactor()));\n    String leftResName = String.format(\"%3s\", resName);\n    StringBuffer s = new StringBuffer();\n    s.append(record);\n    s.append(serial);\n    s.append(\" \");\n    s.append(fullName);\n    s.append(altLoc);\n    s.append(leftResName);\n    s.append(\" \");\n    s.append(chainID);\n    s.append(resseq);\n    s.append(\"   \");\n    s.append(x);\n    s.append(y);\n    s.append(z);\n    s.append(occupancy);\n    s.append(tempfactor);\n    Element e = a.getElement();\n    String eString = e.toString().toUpperCase();\n    if (e.equals(Element.R)) {\n        eString = \"X\";\n    }\n    str.append(String.format(\"%-76s%2s\", s.toString(), eString));\n    str.append(newline);\n}", "repo_id": "9", "comment": "/**\n * Print ATOM record in the following syntax\n * <pre>\n * ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N\n *\n * COLUMNS        DATA TYPE       FIELD         DEFINITION\n * ---------------------------------------------------------------------------------\n * 1 -  6        Record name     \"ATOM  \"\n * 7 - 11        Integer         serial        Atom serial number.\n * 13 - 16        Atom            name          Atom name.\n * 17             Character       altLoc        Alternate location indicator.\n * 18 - 20        Residue name    resName       Residue name.\n * 22             Character       chainID       Chain identifier.\n * 23 - 26        Integer         resSeq        Residue sequence number.\n * 27             AChar           iCode         Code for insertion of residues.\n * 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in\n * Angstroms.\n * 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in\n * Angstroms.\n * 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in\n * Angstroms.\n * 55 - 60        Real(6.2)       occupancy     Occupancy.\n * 61 - 66        Real(6.2)       tempFactor    Temperature factor.\n * 73 - 76        LString(4)      segID         Segment identifier, left-justified.\n * 77 - 78        LString(2)      element       Element symbol, right-justified.\n * 79 - 80        LString(2)      charge        Charge on the atom.\n * </pre>\n * @param a\n * @param str\n * @param chainID the chain ID that the Atom will have in the output string\n */\n", "repo_name": "biojava-master/", "id": 1156, "method_signature": "void toPDB(Atom, StringBuffer, String)"}, "499": {"callee_method_names": [], "method_name": "AFPChain.getProbability", "method_implementation": "{\n    return probability;\n}", "repo_id": "9", "comment": "/**\n * The probability (FATCAT) or Z-score (CE) of the alignment.\n *\n * @return either the probability (FATCAT) or the Z-score (CE) of the alignment.\n */\n", "repo_name": "biojava-master/", "id": 499, "method_signature": "double getProbability()"}, "3780": {"callee_method_names": [], "method_name": "NumbersAtRiskPanel.main", "method_implementation": "{\n    // TODO code application logic here\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3780, "method_signature": "void main(String[])"}, "3615": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "CoxInfo.getCoefficient", "method_implementation": "{\n    return coefficientsList.get(name);\n}", "repo_id": "9", "comment": "/**\n * @param name\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3615, "method_signature": "CoxCoefficient getCoefficient(String)"}, "1851": {"callee_method_names": [], "method_name": "Rotation.getSubunitRmsd", "method_implementation": "{\n    return subunitRmsd;\n}", "repo_id": "9", "comment": "/**\n * @return the subunitRmsd\n */\n", "repo_name": "biojava-master/", "id": 1851, "method_signature": "double getSubunitRmsd()"}, "1157": {"callee_method_names": [], "method_name": "FileConvert.hasInsertionCode", "method_implementation": "{\n    try {\n        Integer.parseInt(pdbserial);\n    } catch (NumberFormatException e) {\n        return true;\n    }\n    return false;\n}", "repo_id": "9", "comment": "/**\n * test if pdbserial has an insertion code\n */\n", "repo_name": "biojava-master/", "id": 1157, "method_signature": "boolean hasInsertionCode(String)"}, "3529": {"callee_method_names": [], "method_name": "CoxCoefficient.getHRText", "method_implementation": "{\n    return fmt(hazardRatio, 2, 0) + \" CI(\" + fmt(hazardRatioLoCI, 2, 0) + \"-\" + fmt(hazardRatioHiCI, 2, 0) + \")\";\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3529, "method_signature": "String getHRText()"}, "984": {"callee_method_names": ["List<Atom>.size", "List<Atom>.get"], "method_name": "HetatomImpl.getAtom", "method_implementation": "{\n    if ((position < 0) || (position >= atoms.size())) {\n        //throw new StructureException(\"No atom found at position \"+position);\n        return null;\n    }\n    return atoms.get(position);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 984, "method_signature": "Atom getAtom(int)"}, "2506": {"callee_method_names": ["List<AlignedSequence<S, C>>.size", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "List<AlignedSequence<S, C>>.size", "StringBuilder.append", "Atom[].getAccession", "StringBuilder.append", "Atom[].getSequenceIndexAt", "StringBuilder.append", "Atom[].getSubSequence", "StringBuilder.append", "Atom[].getSequenceIndexAt", "StringBuilder.append", "List<AlignedSequence<S, C>>.size", "StringBuilder.append", "Atom[].getAccession", "StringBuilder.append", "Atom[].getSequenceIndexAt", "StringBuilder.append", "Atom[].getSubSequence", "StringBuilder.append", "Atom[].getSequenceIndexAt", "StringBuilder.append", "List<AlignedSequence<S, C>>.size", "StringBuilder.append", "StringBuilder.toString"], "method_name": "SimpleProfile.toString", "method_implementation": "{\n    // TODO handle circular alignments\n    StringBuilder s = (header == null) ? new StringBuilder() : new StringBuilder(header);\n    if (webDisplay && list.size() == 2) {\n        s.append(\"<div><pre>\");\n    }\n    width = Math.max(1, width);\n    int seqIndexPad = (int) (Math.floor(Math.log10(getLength())) + 2);\n    String seqIndexFormatPre = \"%\" + seqIndexPad + \"d \", seqIndexFormatPost = \"%\" + seqIndexPad + \"d\";\n    if (interlaced) {\n        String aligIndFormat = \"%-\" + Math.max(1, width / 2) + \"d %\" + Math.max(1, width - (width / 2) - 1) + \"d%n\";\n        for (int i = 0; i < getLength(); i += width) {\n            int start = i + 1, end = Math.min(getLength(), i + width);\n            if (i > 0) {\n                s.append(String.format(\"%n\"));\n            }\n            if (aligIndices) {\n                if (end < i + width) {\n                    int line = end - start + 1;\n                    aligIndFormat = \"%-\" + Math.max(1, line / 2) + \"d %\" + Math.max(1, line - (line / 2) - 1) + \"d%n\";\n                }\n                if (idFormat != null) {\n                    s.append(String.format(idFormat, \"\"));\n                }\n                if (seqIndexPre) {\n                    s.append(String.format(\"%\" + (seqIndexPad + 1) + \"s\", \"\"));\n                }\n                s.append(String.format(aligIndFormat, start, end));\n            }\n            int counter = 0;\n            for (AlignedSequence<S, C> as : list) {\n                counter++;\n                if (webDisplay && list.size() == 2) {\n                    printSequenceAlignmentWeb(s, counter, idFormat, seqIndexPre, seqIndexFormatPre, seqIndexPost, seqIndexFormatPost, start, end);\n                } else {\n                    if (idFormat != null) {\n                        s.append(String.format(idFormat, as.getAccession()));\n                    }\n                    if (seqIndexPre) {\n                        s.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n                    }\n                    s.append(as.getSubSequence(start, end).getSequenceAsString());\n                    if (seqIndexPost) {\n                        s.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n                    }\n                    s.append(String.format(\"%n\"));\n                }\n                if (aligConservation && list.size() == 2 && counter == 1) {\n                    printConservation(s, idFormat, seqIndexPad, seqIndexPre, start, end, webDisplay);\n                }\n            }\n        }\n    } else {\n        for (AlignedSequence<S, C> as : list) {\n            if (idFormat != null) {\n                s.append(String.format(idFormat, as.getAccession()));\n            }\n            for (int i = 0; i < getLength(); i += width) {\n                int start = i + 1, end = Math.min(getLength(), i + width);\n                if (seqIndexPre) {\n                    s.append(String.format(seqIndexFormatPre, as.getSequenceIndexAt(start)));\n                }\n                s.append(as.getSubSequence(start, end).getSequenceAsString());\n                if (seqIndexPost) {\n                    s.append(String.format(seqIndexFormatPost, as.getSequenceIndexAt(end)));\n                }\n                s.append(String.format(\"%n\"));\n            }\n        }\n    }\n    if (webDisplay && aligConservation && list.size() == 2) {\n        s.append(IOUtils.getPDBLegend());\n    }\n    return s.toString();\n}", "repo_id": "9", "comment": "// creates formatted String\n", "repo_name": "biojava-master/", "id": 2506, "method_signature": "String toString(int, String, String, boolean, boolean, boolean, boolean, boolean, boolean)"}, "1832": {"callee_method_ids": [400, 404], "callee_method_names": ["Group.size", "GroupIterator.hasNext", "GroupIterator.next", "Group.getAtom", "Logger.error", "Group.size"], "method_name": "AtomIterator.next", "method_implementation": "{\n    current_atom_pos++;\n    if (current_atom_pos >= group.size()) {\n        if (groupiter == null) {\n            throw new NoSuchElementException(\"no more atoms found in group!\");\n        }\n        if (groupiter.hasNext()) {\n            group = groupiter.next();\n            current_atom_pos = -1;\n            return next();\n        } else {\n            throw new NoSuchElementException(\"no more atoms found in structure!\");\n        }\n    }\n    Atom a;\n    a = group.getAtom(current_atom_pos);\n    if (a == null) {\n        logger.error(\"current_atom_pos {} group {} size: {}\", current_atom_pos, group, group.size());\n        throw new NoSuchElementException(\"error wile trying to retrieve atom\");\n    }\n    return a;\n}", "repo_id": "9", "comment": "/**\n * Return next atom.\n *\n * @return the next Atom\n * @throws NoSuchElementException if there is no atom after the current one\n */\n", "repo_name": "biojava-master/", "id": 1832, "method_signature": "Atom next()"}, "2027": {"callee_method_names": [], "method_name": "RectangularPrism.getWidth", "method_implementation": "{\n    return width;\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of an inscribed sphere, that is tangent to each\n * of the octahedron's faces\n * @return the inscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2027, "method_signature": "double getWidth()"}, "538": {"callee_method_ids": [484, 487, 488, 496], "callee_method_names": ["AFPChain.isShortAlign", "AFPChain.getAfpSet", "AFPChain.getBlockNum", "AFPChain.getBlockResSize", "AFPChain.getBlockResList", "AFPChain.getAfpChainList", "AFPChain.getBlock2Afp", "AFPChain.getBlockSize", "AFPChain.getFocusAfpList", "AFPChain.getMinLen", "AFPChain.setFocusAfpList", "Logger.debug", "Logger.debug", "List<AFP>.get", "AFP.getP2", "List<AFP>.get", "AFP.getP2", "Logger.debug", "AFPChain.setTotalLenIni", "Logger.debug", "AFPChain.getFocusRes1", "AFPChain.getFocusRes2", "AFPChain.setTotalRmsdIni", "Logger.debug", "Logger.debug", "AFPChain.getAlnseq1", "Logger.debug", "AFPChain.getAlnsymb", "Logger.debug", "AFPChain.getAlnseq2", "AFPChain.setFocusAfpList", "AFPChain.setBlock2Afp", "AFPChain.setAfpChainList"], "method_name": "AFPTwister.twistPDB", "method_implementation": "{\n    // --------------------------------------------------------\n    if (afpChain.isShortAlign())\n        return new Group[0];\n    List<AFP> afpSet = afpChain.getAfpSet();\n    int blockNum = afpChain.getBlockNum();\n    int i, b2, e2;\n    // superimposing according to the initial AFP-chaining\n    Atom[] origCA = StructureTools.cloneAtomArray(ca2);\n    Atom[] iniTwistPdb = StructureTools.cloneAtomArray(ca2);\n    int[] blockResSize = afpChain.getBlockResSize();\n    int[][][] blockResList = afpChain.getBlockResList();\n    int[] afpChainList = afpChain.getAfpChainList();\n    int[] block2Afp = afpChain.getBlock2Afp();\n    int[] blockSize = afpChain.getBlockSize();\n    int[] focusAfpList = afpChain.getFocusAfpList();\n    if (focusAfpList == null) {\n        focusAfpList = new int[afpChain.getMinLen()];\n        afpChain.setFocusAfpList(focusAfpList);\n    }\n    int focusAfpn = 0;\n    e2 = 0;\n    b2 = 0;\n    logger.debug(\"blockNUm at twister: {}\", blockNum);\n    for (int bk = 0; bk < blockNum; bk++) {\n        // THIS IS TRANSFORMING THE ORIGINAL ca2 COORDINATES, NO CLONING...\n        // copies the atoms over to iniTwistPdb later on in modifyCod\n        transformOrigPDB(blockResSize[bk], blockResList[bk][0], blockResList[bk][1], ca1, ca2, null, -1);\n        // transform pro2 according to comparison of pro1 and pro2 at give\n        // residues\n        if (bk > 0) {\n            b2 = e2;\n        }\n        logger.debug(\"b2 is {} before  modifyCon\", b2);\n        if (bk < (blockNum - 1)) {\n            // bend at the middle of two consecutive AFPs\n            int afpPos = afpChainList[block2Afp[bk] + blockSize[bk] - 1];\n            AFP a1 = afpSet.get(afpPos);\n            e2 = a1.getP2();\n            int afpPos2 = afpChainList[block2Afp[bk + 1]];\n            AFP a2 = afpSet.get(afpPos2);\n            e2 = (a2.getP2() - e2) / 2 + e2;\n            logger.debug(\"e2 : {}\", e2);\n        } else {\n            // last one is until the end...\n            e2 = ca2.length;\n        }\n        // this copies the coordinates over into iniTwistPdb\n        cloneAtomRange(iniTwistPdb, ca2, b2, e2);\n        // bound[bk] = e2;\n        for (i = 0; i < blockSize[bk]; i++) {\n            focusAfpList[focusAfpn] = afpChainList[block2Afp[bk] + i];\n            focusAfpn++;\n        }\n    }\n    int focusResn = afp2Res(afpChain, focusAfpn, focusAfpList, 0);\n    afpChain.setTotalLenIni(focusResn);\n    logger.debug(String.format(\"calrmsdini for %d residues\", focusResn));\n    double totalRmsdIni = calCaRmsd(ca1, iniTwistPdb, focusResn, afpChain.getFocusRes1(), afpChain.getFocusRes2());\n    afpChain.setTotalRmsdIni(totalRmsdIni);\n    logger.debug(\"got iniRMSD: {}\", totalRmsdIni);\n    if (totalRmsdIni == 5.76611141613097) {\n        logger.debug(\"{}\", afpChain.getAlnseq1());\n        logger.debug(\"{}\", afpChain.getAlnsymb());\n        logger.debug(\"{}\", afpChain.getAlnseq2());\n    }\n    afpChain.setFocusAfpList(focusAfpList);\n    afpChain.setBlock2Afp(block2Afp);\n    afpChain.setAfpChainList(afpChainList);\n    return twistOptimized(afpChain, ca1, origCA);\n}", "repo_id": "9", "comment": "/**\n * calculate the total rmsd of the blocks output a merged pdb file for both\n * proteins protein 1, in chain A protein 2 is twisted according to the\n * twists detected, in chain B\n *\n * @return twisted Groups\n */\n", "repo_name": "biojava-master/", "id": 538, "method_signature": "Group[] twistPDB(AFPChain, Atom[], Atom[])"}, "1049": {"callee_method_ids": [929, 937], "callee_method_names": ["Grid.addAtoms", "Grid.getAtomContacts"], "method_name": "StructureTools.getAtomsCAInContact", "method_implementation": "{\n    Grid grid = new Grid(cutoff);\n    Atom[] atoms = getAtomCAArray(chain);\n    grid.addAtoms(atoms);\n    return grid.getAtomContacts();\n}", "repo_id": "9", "comment": "/**\n * Returns the set of intra-chain contacts for the given chain for C-alpha\n * atoms (including non-standard aminoacids appearing as HETATM groups),\n * i.e. the contact map. Uses a spatial hashing algorithm that speeds up\n * the calculation without need of full distance matrix. The parsing mode\n * {@link FileParsingParameters#setAlignSeqRes(boolean)} needs to be set to\n * true for this to work.\n *\n * @param chain\n * @param cutoff\n * @return\n * @see #getRepresentativeAtomsInContact(Chain, double)\n */\n", "repo_name": "biojava-master/", "id": 1049, "method_signature": "AtomContactSet getAtomsCAInContact(Chain, double)"}, "2177": {"callee_method_names": ["URL.getPath", "URL.getHost", "URL.getPath", "URL.getHost", "URL.getPath", "URL.getHost", "URL.getPath", "URL.getHost", "URL.getPath", "URL.getHost", "URL.getPath", "URL.getHost", "URL.getProtocol", "URL.getPath", "URL.getHost", "URL.getProtocol", "URL.getPath", "URL.getHost", "URL.getProtocol", "URL.getPath", "URL.getHost", "URL.getProtocol"], "method_name": "TestStructureName.testURLs", "method_implementation": "{\n    URL url;\n    // Tilde doesn't get expanded\n    url = new URL(\"file://~/1abc.pdb\");\n    assertEquals(\"/1abc.pdb\", url.getPath());\n    assertEquals(\"~\", url.getHost());\n    url = new URL(\"file:///~/1abc.pdb\");\n    assertEquals(\"/~/1abc.pdb\", url.getPath());\n    assertEquals(\"\", url.getHost());\n    // Supports omitting the initial slashes\n    url = new URL(\"file:~/1abc.pdb\");\n    assertEquals(\"~/1abc.pdb\", url.getPath());\n    assertEquals(\"\", url.getHost());\n    // proper case. Three slashes gives empty host\n    url = new URL(\"file:///1abc.pdb\");\n    assertEquals(\"/1abc.pdb\", url.getPath());\n    assertEquals(\"\", url.getHost());\n    // Two slashes triggers host\n    url = new URL(\"file://1abc.pdb\");\n    assertEquals(\"\", url.getPath());\n    assertEquals(\"1abc.pdb\", url.getHost());\n    // One slash treated like zero slashes\n    url = new URL(\"file:/1abc.pdb\");\n    assertEquals(\"/1abc.pdb\", url.getPath());\n    assertEquals(\"\", url.getHost());\n    assertEquals(\"file\", url.getProtocol());\n    // Surprise! url: prefix already works\n    url = new URL(\"url:file://localhost/1abc.pdb\");\n    assertEquals(\"/1abc.pdb\", url.getPath());\n    assertEquals(\"localhost\", url.getHost());\n    assertEquals(\"file\", url.getProtocol());\n    url = new URL(\"URL:file://localhost/1abc.pdb\");\n    assertEquals(\"/1abc.pdb\", url.getPath());\n    assertEquals(\"localhost\", url.getHost());\n    assertEquals(\"file\", url.getProtocol());\n    // But doubling the file prefix doesn't. Is that OK?\n    url = new URL(\"file:file://localhost/1abc.pdb\");\n    assertEquals(\"file://localhost/1abc.pdb\", url.getPath());\n    assertEquals(\"\", url.getHost());\n    assertEquals(\"file\", url.getProtocol());\n}", "repo_id": "9", "comment": "// Not really a test, but rather documenting Java's URL behavior\n", "repo_name": "biojava-master/", "id": 2177, "method_signature": "void testURLs()"}, "586": {"callee_method_ids": [489, 490, 487, 487], "callee_method_names": ["AFPChain.getOptAln", "AFPChain.getOptLen", "AFPChain.getBlockNum", "AFPChain.getBlockNum", "List<Integer>.add", "List<Integer>.add", "List<List<Integer>>.add", "List<List<Integer>>.add", "List<List<List<Integer>>>.add"], "method_name": "AlignmentTools.getOptAlnAsList", "method_implementation": "{\n    int[][][] optAln = afpChain.getOptAln();\n    int[] optLen = afpChain.getOptLen();\n    List<List<List<Integer>>> blocks = new ArrayList<List<List<Integer>>>(afpChain.getBlockNum());\n    for (int blockNum = 0; blockNum < afpChain.getBlockNum(); blockNum++) {\n        //TODO could improve speed an memory by wrapping the arrays with\n        // an unmodifiable list, similar to Arrays.asList(...) but with the\n        // correct size parameter.\n        List<Integer> align1 = new ArrayList<Integer>(optLen[blockNum]);\n        List<Integer> align2 = new ArrayList<Integer>(optLen[blockNum]);\n        for (int pos = 0; pos < optLen[blockNum]; pos++) {\n            align1.add(optAln[blockNum][0][pos]);\n            align2.add(optAln[blockNum][1][pos]);\n        }\n        List<List<Integer>> block = new ArrayList<List<Integer>>(2);\n        block.add(align1);\n        block.add(align2);\n        blocks.add(block);\n    }\n    return blocks;\n}", "repo_id": "9", "comment": "/**\n * Retrieves the optimum alignment from an AFPChain and returns it as a\n * java collection. The result is indexed in the same way as\n * {@link AFPChain#getOptAln()}, but has the correct size().\n * <pre>\n * List<List<List<Integer>>> aln = getOptAlnAsList(AFPChain afpChain);\n * aln.get(blockNum).get(structureNum={0,1}).get(pos)</pre>\n *\n * @param afpChain\n * @return\n */\n", "repo_name": "biojava-master/", "id": 586, "method_signature": "List<List<List<Integer>>> getOptAlnAsList(AFPChain)"}, "3220": {"callee_method_names": ["GenbankReader<DNASequence, NucleotideCompound>.process", "CheckableInputStream.isclosed", "LinkedHashMap<String, DNASequence>.size", "LinkedHashMap<String, DNASequence>.get", "GenbankReader<DNASequence, NucleotideCompound>.process", "CheckableInputStream.isclosed", "LinkedHashMap<String, DNASequence>.size", "LinkedHashMap<String, DNASequence>.get", "GenbankReader<DNASequence, NucleotideCompound>.isClosed", "GenbankReader<DNASequence, NucleotideCompound>.close", "GenbankReader<DNASequence, NucleotideCompound>.isClosed", "CheckableInputStream.isclosed"], "method_name": "GenbankReaderTest.testPartialProcess", "method_implementation": "{\n    CheckableInputStream inStream = new CheckableInputStream(this.getClass().getResourceAsStream(\"/two-dnaseqs.gb\"));\n    GenbankReader<DNASequence, NucleotideCompound> genbankDNA = new GenbankReader<>(inStream, new GenericGenbankHeaderParser<>(), new DNASequenceCreator(DNACompoundSet.getDNACompoundSet()));\n    // First call to process(1) returns the first sequence\n    LinkedHashMap<String, DNASequence> dnaSequences = genbankDNA.process(1);\n    assertFalse(inStream.isclosed());\n    assertNotNull(dnaSequences);\n    assertEquals(1, dnaSequences.size());\n    assertNotNull(dnaSequences.get(\"vPetite\"));\n    // Second call to process(1) returns the second sequence\n    dnaSequences = genbankDNA.process(1);\n    assertFalse(inStream.isclosed());\n    assertNotNull(dnaSequences);\n    assertEquals(1, dnaSequences.size());\n    assertNotNull(dnaSequences.get(\"sbFDR\"));\n    assertFalse(genbankDNA.isClosed());\n    genbankDNA.close();\n    assertTrue(genbankDNA.isClosed());\n    assertTrue(inStream.isclosed());\n}", "repo_id": "9", "comment": "/**\n * Test the process method with a number of sequences to be read at each call.\n * The underlying {@link InputStream} should remain open until the last call.\n */\n", "repo_name": "biojava-master/", "id": 3220, "method_signature": "void testPartialProcess()"}, "1286": {"callee_method_ids": [1351, 1351, 1348, 1577], "callee_method_names": ["EntityInfo.getDescription", "EntityInfo.getType", "EntityInfo.getType", "EntityInfo.getChains", "List<Chain>.isEmpty", "Logger.error", "StructureAdapterInterface.setEntityInfo", "List<Chain>.size", "List<Chain>.size", "List<Chain>.indexOf", "List<Chain>.get", "List<Chain>.get", "List<Chain>.get", "ChainImpl.getSeqResOneLetterSeq", "StructureAdapterInterface.setEntityInfo"], "method_name": "MmtfStructureWriter.storeEntityInformation", "method_implementation": "{\n    for (EntityInfo entityInfo : entityInfos) {\n        String description = entityInfo.getDescription();\n        String type;\n        if (entityInfo.getType() == null) {\n            type = null;\n        } else {\n            type = entityInfo.getType().getEntityType();\n        }\n        List<Chain> entityChains = entityInfo.getChains();\n        if (entityChains.isEmpty()) {\n            // Error mapping chain to entity\n            logger.error(\"ERROR MAPPING CHAIN TO ENTITY: \" + description);\n            mmtfDecoderInterface.setEntityInfo(new int[0], \"\", description, type);\n        } else {\n            int[] chainIndices = new int[entityChains.size()];\n            for (int i = 0; i < entityChains.size(); i++) {\n                chainIndices[i] = allChains.indexOf(entityChains.get(i));\n            }\n            Chain chain = entityChains.get(0);\n            ChainImpl chainImpl;\n            if (chain instanceof ChainImpl) {\n                chainImpl = (ChainImpl) entityChains.get(0);\n            } else {\n                throw new RuntimeException(\"Encountered Chain of unexpected type\");\n            }\n            String sequence = chainImpl.getSeqResOneLetterSeq();\n            mmtfDecoderInterface.setEntityInfo(chainIndices, sequence, description, type);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Store the entity information for a given structure.\n * @param allChains a list of all the chains in a structure\n * @param entityInfos a list of the entity information\n */\n", "repo_name": "biojava-master/", "id": 1286, "method_signature": "void storeEntityInformation(List, List)"}, "1319": {"callee_method_names": [], "method_name": "FileParsingParameters.isParseCAOnly", "method_implementation": "{\n    return parseCAOnly;\n}", "repo_id": "9", "comment": "/**\n * The flag if only the C-alpha atoms of the structure should be parsed.\n *\n * @return the flag\n */\n", "repo_name": "biojava-master/", "id": 1319, "method_signature": "boolean isParseCAOnly()"}, "670": {"callee_method_names": ["MultipleAlignment.size", "MultipleAlignment.getEnsemble", "List<String>.get"], "method_name": "MultipleAlignmentWriter.toFASTA", "method_implementation": "{\n    // Get the alignment sequences\n    List<String> alnSequences = MultipleAlignmentTools.getSequenceAlignment(alignment);\n    String fasta = \"\";\n    for (int st = 0; st < alignment.size(); st++) {\n        // Add the structure identifier as the head of the FASTA\n        fasta += \">\" + alignment.getEnsemble().getStructureIdentifiers().get(st).getIdentifier() + \"\\n\" + alnSequences.get(st) + \"\\n\";\n    }\n    return fasta;\n}", "repo_id": "9", "comment": "/**\n * Converts the {@link MultipleAlignment} into a multiple sequence alignment\n * String in FASTA format.\n *\n * @param alignment\n *            MultipleAlignment\n * @return String multiple sequence alignment in FASTA format\n * @see MultipleAlignmentTools#getSequenceAlignment(MultipleAlignment)\n */\n", "repo_name": "biojava-master/", "id": 670, "method_signature": "String toFASTA(MultipleAlignment)"}, "2355": {"callee_method_ids": [2342, 2343, 2344, 2341, 2345, 2346, 2349], "callee_method_names": ["FastqBuilder.withDescription", "FastqBuilder.withSequence", "FastqBuilder.appendSequence", "FastqBuilder.getDescription", "String.length", "String.equals", "String.length", "String.charAt", "FastqVariant.qualityScore", "FastqVariant.minimumQualityScore", "FastqVariant.maximumQualityScore", "FastqVariant.minimumQualityScore", "FastqVariant.maximumQualityScore", "FastqBuilder.withQuality", "FastqBuilder.appendQuality", "StreamListener.fastq", "FastqBuilder.build"], "method_name": "StreamingFastqParser.stream", "method_implementation": "{\n    if (readable == null) {\n        throw new IllegalArgumentException(\"readable must not be null\");\n    }\n    if (variant == null) {\n        throw new IllegalArgumentException(\"variant must not be null\");\n    }\n    if (listener == null) {\n        throw new IllegalArgumentException(\"listener must not be null\");\n    }\n    final FastqBuilder builder = new FastqBuilder().withVariant(variant);\n    FastqParser.parse(readable, new ParseListener() {\n\n        @Override\n        public void description(final String description) throws IOException {\n            builder.withDescription(description);\n        }\n\n        @Override\n        public void sequence(final String sequence) throws IOException {\n            builder.withSequence(sequence);\n        }\n\n        @Override\n        public void appendSequence(final String sequence) throws IOException {\n            builder.appendSequence(sequence);\n        }\n\n        @Override\n        public void repeatDescription(final String repeatDescription) throws IOException {\n            String description = builder.getDescription();\n            if ((description != null) && (description.length() > 0) && (repeatDescription.length() > 0)) {\n                if (!description.equals(repeatDescription)) {\n                    throw new IOException(\"repeat description must match description\");\n                }\n            }\n        }\n\n        /**\n         * Validate the specified quality line.\n         *\n         * @param quality quality line to validate\n         * @throws IOException if an I/O error occurs\n         */\n        private void validateQuality(final String quality) throws IOException {\n            for (int i = 0, size = quality.length(); i < size; i++) {\n                char c = quality.charAt(i);\n                int qualityScore = variant.qualityScore(c);\n                if (qualityScore < variant.minimumQualityScore() || qualityScore > variant.maximumQualityScore()) {\n                    throw new IOException(\"quality score must be between \" + variant.minimumQualityScore() + \" and \" + variant.maximumQualityScore() + \", was \" + qualityScore + \" for ASCII char '\" + c + \"'\");\n                }\n            }\n        }\n\n        @Override\n        public void quality(final String quality) throws IOException {\n            validateQuality(quality);\n            builder.withQuality(quality);\n        }\n\n        @Override\n        public void appendQuality(final String quality) throws IOException {\n            validateQuality(quality);\n            builder.appendQuality(quality);\n        }\n\n        @Override\n        public void complete() throws IOException {\n            try {\n                listener.fastq(builder.build());\n            } catch (IllegalStateException e) {\n                throw new IOException(\"caught an IllegalStateException\", e);\n            }\n        }\n    });\n}", "repo_id": "9", "comment": "/**\n * Stream the specified readable.\n *\n * @param readable readable, must not be null\n * @param variant FASTQ variant, must not be null\n * @param listener event based reader callback, must not be null\n * @throws IOException if an I/O error occurs\n */\n", "repo_name": "biojava-master/", "id": 2355, "method_signature": "void stream(Readable, FastqVariant, StreamListener)"}, "3335": {"callee_method_names": ["JTextField.getText", "JFileChooser.setCurrentDirectory", "JFileChooser.setDialogTitle", "JFileChooser.setFileSelectionMode", "JFileChooser.setAcceptAllFileFilterUsed", "JFileChooser.showOpenDialog", "JFileChooser.getSelectedFile", "JTextField.setText", "File.getAbsolutePath", "JTextField.repaint"], "method_name": "ChooseDirAction.actionPerformed", "method_implementation": "{\n    // Perform action...\n    JFileChooser chooser = new JFileChooser();\n    String txt = textField.getText();\n    if (txt != null) {\n        chooser.setCurrentDirectory(new java.io.File(txt));\n    }\n    chooser.setDialogTitle(\"Choose directory that contains your PDB files\");\n    chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);\n    //\n    // disable the \"All files\" option.\n    //\n    chooser.setAcceptAllFileFilterUsed(false);\n    //\n    //\t\tIn response to a button click:\n    int returnVal = chooser.showOpenDialog(null);\n    if (returnVal == JFileChooser.APPROVE_OPTION) {\n        File file = chooser.getSelectedFile();\n        textField.setText(file.getAbsolutePath());\n        textField.repaint();\n    }\n}", "repo_id": "9", "comment": "// This method is called when the button is pressed\n", "repo_name": "biojava-master/", "id": 3335, "method_signature": "void actionPerformed(ActionEvent)"}, "805": {"callee_method_names": ["FragmentPair.getPos1", "FragmentPair.getPos2", "List<FragmentPair>.size", "List<FragmentPair>.get", "FragmentPair.getPos1", "FragmentPair.getPos1", "FragmentPair.getPos2", "FragmentPair.getPos2", "Matrix.get", "FragmentPair.getPos1", "FragmentPair.getPos2", "Matrix.get", "List<FragmentPair>.remove", "List<FragmentPair>.add", "List<FragmentPair>.size"], "method_name": "FragmentJoiner.reduceFragments", "method_implementation": "{\n    boolean doNotAdd = false;\n    int i = f.getPos1();\n    int j = f.getPos2();\n    for (int p = 0; p < fragments.size(); p++) {\n        FragmentPair tmp = fragments.get(p);\n        int di1 = Math.abs(f.getPos1() - tmp.getPos1());\n        int di2 = Math.abs(f.getPos2() - tmp.getPos2());\n        if ((Math.abs(di1 - di2) == 2)) {\n            double rms1 = rmsmat.get(tmp.getPos1(), tmp.getPos2());\n            double rms2 = rmsmat.get(i, j);\n            doNotAdd = true;\n            if (rms2 < rms1) {\n                fragments.remove(p);\n                fragments.add(f);\n                break;\n            }\n            p = fragments.size();\n        }\n    }\n    return doNotAdd;\n}", "repo_id": "9", "comment": "/**\n *  In helices often many similar fragments can be found. To reduce these to a few\n *  representative ones this check can be used. It does a distance check between\n *  all known Fragments and a new one. If this one is on a similar diagonal and it\n *  has a lower rms, this one is a better representation. Note: shifts of one are\n *  not allowed.\n *\n * @param fragments\n * @param f\n * @param rmsmat\n * @return true - if this is a better representant for a group of locala fragments.\n */\n", "repo_name": "biojava-master/", "id": 805, "method_signature": "boolean reduceFragments(List, FragmentPair, Matrix)"}, "695": {"callee_method_names": ["MultipleAlignment.getBlocks", "String.length", "String.getAlignRes", "List<Integer>.add", "List<List<Integer>>.add", "List<List<Integer>>.get", "MultipleAlignment.getBlock", "Block.getAlignRes", "List<List<Integer>>.get", "Block.getAlignRes", "List<List<Integer>>.get", "List<SortedSet<Integer>>.get"], "method_name": "MultipleMcOptimizer.checkGaps", "method_implementation": "{\n    boolean shrinkedAny = false;\n    List<List<Integer>> shrinkColumns = new ArrayList<List<Integer>>();\n    // Loop for each Block\n    for (Block b : msa.getBlocks()) {\n        List<Integer> shrinkCol = new ArrayList<Integer>();\n        // Loop for each column in the Block\n        for (int res = 0; res < b.length(); res++) {\n            int gapCount = 0;\n            // count the gaps in the column\n            for (int su = 0; su < size; su++) {\n                if (b.getAlignRes().get(su).get(res) == null)\n                    gapCount++;\n            }\n            if ((size - gapCount) < Rmin) {\n                // Add the column to the shrink list\n                shrinkCol.add(res);\n            }\n        }\n        shrinkColumns.add(shrinkCol);\n    }\n    // Shrink columns that have more gaps than allowed\n    for (int b = 0; b < blockNr; b++) {\n        for (int col = shrinkColumns.get(b).size() - 1; col >= 0; col--) {\n            for (int str = 0; str < size; str++) {\n                Block bk = msa.getBlock(b);\n                Integer residue = bk.getAlignRes().get(str).get(shrinkColumns.get(b).get(col));\n                bk.getAlignRes().get(str).remove((int) shrinkColumns.get(b).get(col));\n                if (residue != null) {\n                    freePool.get(str).add(residue);\n                }\n            }\n            shrinkedAny = true;\n        }\n    }\n    return shrinkedAny;\n}", "repo_id": "9", "comment": "/**\n * Method that loops through all the alignment columns and checks that there\n * are no more gaps than the maximum allowed, Rmin.\n * <p>\n * There must be at least Rmin residues different than null in every\n * alignment column. In case there is a column with more gaps it will be\n * shrinked (moved to freePool).\n *\n * @return true if any columns has been shrinked and false otherwise\n */\n", "repo_name": "biojava-master/", "id": 695, "method_signature": "boolean checkGaps()"}, "1249": {"callee_method_names": ["Matrix4d.getElement"], "method_name": "MmtfUtils.convertToDoubleArray", "method_implementation": "{\n    // Initialise the output array\n    double[] outArray = new double[16];\n    // Iterate over the matrix\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            // Now set this element\n            outArray[i * 4 + j] = transformationMatrix.getElement(i, j);\n        }\n    }\n    return outArray;\n}", "repo_id": "9", "comment": "/**\n * Convert a four-d matrix to a double array. Row-packed.\n * @param transformationMatrix the input matrix4d object\n * @return the double array (16 long).\n */\n", "repo_name": "biojava-master/", "id": 1249, "method_signature": "double[] convertToDoubleArray(Matrix4d)"}, "3125": {"callee_method_names": [], "method_name": "UniprotProxySequenceReader.iterator", "method_implementation": "{\n    return this.parsedCompounds.iterator();\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3125, "method_signature": "Iterator<C> iterator()"}, "51": {"callee_method_names": ["int.getProfile", "List<GuideTreeNode<S, C>>.add", "List<GuideTreeNode<S, C>>.size", "int.getChild1", "int.getChild2", "int.getChild1", "int.getChild2", "int.setProfileFuture", "int.setProfile", "int.getProfileFuture", "Logger.error", "Logger.error", "GuideTree<S,C>.getRoot"], "method_name": "Alignments.getProgressiveAlignment", "method_implementation": "{\n    // find inner nodes in post-order traversal of tree (each leaf node has a single sequence profile)\n    List<GuideTreeNode<S, C>> innerNodes = new ArrayList<GuideTreeNode<S, C>>();\n    for (GuideTreeNode<S, C> n : tree) {\n        if (n.getProfile() == null) {\n            innerNodes.add(n);\n        }\n    }\n    // submit alignment tasks to the shared thread pool\n    int i = 1, all = innerNodes.size();\n    for (GuideTreeNode<S, C> n : innerNodes) {\n        Profile<S, C> p1 = n.getChild1().getProfile(), p2 = n.getChild2().getProfile();\n        Future<ProfilePair<S, C>> pf1 = n.getChild1().getProfileFuture(), pf2 = n.getChild2().getProfileFuture();\n        ProfileProfileAligner<S, C> aligner = (p1 != null) ? ((p2 != null) ? getProfileProfileAligner(p1, p2, type, gapPenalty, subMatrix) : getProfileProfileAligner(p1, pf2, type, gapPenalty, subMatrix)) : ((p2 != null) ? getProfileProfileAligner(pf1, p2, type, gapPenalty, subMatrix) : getProfileProfileAligner(pf1, pf2, type, gapPenalty, subMatrix));\n        n.setProfileFuture(ConcurrencyTools.submit(new CallableProfileProfileAligner<S, C>(aligner), String.format(\"Aligning pair %d of %d\", i++, all)));\n    }\n    // retrieve the alignment results\n    for (GuideTreeNode<S, C> n : innerNodes) {\n        // TODO when added to ConcurrencyTools, log completions and exceptions instead of printing stack traces\n        try {\n            n.setProfile(n.getProfileFuture().get());\n        } catch (InterruptedException e) {\n            logger.error(\"Interrupted Exception: \", e);\n        } catch (ExecutionException e) {\n            logger.error(\"Execution Exception: \", e);\n        }\n    }\n    // the alignment profile at the root of the tree is the full multiple sequence alignment\n    return tree.getRoot().getProfile();\n}", "repo_id": "9", "comment": "/**\n * Factory method to run the profile-profile alignments of a progressive multiple sequence alignment concurrently.\n * This method runs the alignments in parallel by submitting all of the alignment tasks to the shared thread pool\n * of the {@link ConcurrencyTools} utility.\n *\n * @param <S> each {@link Sequence} of the {@link Profile} pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param tree guide tree to follow aligning profiles from leaves to root\n * @param type chosen type from list of profile-profile alignment routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return multiple sequence alignment\n */\n", "repo_name": "biojava-master/", "id": 51, "method_signature": "Profile<S,C> getProgressiveAlignment(GuideTree, ProfileProfileAlignerType, GapPenalty, SubstitutionMatrix)"}, "3838": {"callee_method_names": [], "method_name": "PeptidePropertiesImpl.getWaterMoleculeWeight", "method_implementation": "{\n    final double hydrogenMW = 1.0079;\n    final double hydroxideMW = 17.0073;\n    //H\t1.0079\tOH\t17.0073\n    return hydrogenMW + hydroxideMW;\n}", "repo_id": "9", "comment": "/**\n * @return the molecular weight of water\n */\n", "repo_name": "biojava-master/", "id": 3838, "method_signature": "double getWaterMoleculeWeight()"}, "3485": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.getBlastDatabase", "method_implementation": "{\n    return getAlignmentOption(DATABASE);\n}", "repo_id": "9", "comment": "/**\n * @return name of database used with blastall\n */\n", "repo_name": "biojava-master/", "id": 3485, "method_signature": "String getBlastDatabase()"}, "1265": {"callee_method_names": ["Chain.getAtomGroups", "Group.getResidueNumber", "Group.getResidueNumber", "Group.getPDBName", "Group.getPDBName"], "method_name": "MmtfStructureReader.getGroupWithSameResNumButDiffPDBName", "method_implementation": "{\n    // If this chain already has this group number\n    for (Group g : chain.getAtomGroups()) {\n        if (g.getResidueNumber().equals(group.getResidueNumber())) {\n            if (!g.getPDBName().equals(group.getPDBName())) {\n                return g;\n            }\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1265, "method_signature": "Group getGroupWithSameResNumButDiffPDBName()"}, "2316": {"callee_method_ids": [1659, 1662, 1662, 1663, 1659, 1662, 1662, 1663], "callee_method_names": ["SubunitCluster.mergeIdentical", "SubunitCluster.size", "SubunitCluster.size", "SubunitCluster.length", "SubunitCluster.mergeIdentical", "SubunitCluster.size", "SubunitCluster.size", "SubunitCluster.length"], "method_name": "TestSubunitCluster.testMergeIdentical", "method_implementation": "{\n    // Create an Atom Array of poly-alanine\n    Atom[] reprAtoms = mockAtomArray(10, \"ALA\", -1, null);\n    // Create two identical SubunitCluster\n    SubunitCluster sc1 = new SubunitCluster(new Subunit(reprAtoms, \"subunit 1\", null, null));\n    SubunitCluster sc2 = new SubunitCluster(new Subunit(reprAtoms, \"subunit 2\", null, null));\n    boolean merged = sc1.mergeIdentical(sc2);\n    // Merged have to be true, and the merged SubunitCluster is sc1\n    assertTrue(merged);\n    assertEquals(2, sc1.size());\n    assertEquals(1, sc2.size());\n    assertEquals(10, sc1.length());\n    // Create an Atom Array of poly-glycine\n    Atom[] reprAtoms2 = mockAtomArray(10, \"GLY\", -1, null);\n    SubunitCluster sc3 = new SubunitCluster(new Subunit(reprAtoms2, \"subunit 1\", null, null));\n    merged = sc1.mergeIdentical(sc3);\n    // Merged have to be false, and Clusters result inmodified\n    assertFalse(merged);\n    assertEquals(2, sc1.size());\n    assertEquals(1, sc2.size());\n    assertEquals(10, sc1.length());\n}", "repo_id": "9", "comment": "/**\n * Test {@link SubunitCluster#mergeIdentical(SubunitCluster)}.\n */\n", "repo_name": "biojava-master/", "id": 2316, "method_signature": "void testMergeIdentical()"}, "944": {"callee_method_names": ["List<Chain>.size", "List<Chain>.size", "BoundingBox[].overlaps", "List<Chain>.get", "List<Chain>.get", "StructureInterfaceList.add"], "method_name": "InterfaceFinder.getAllInterfaces", "method_implementation": "{\n    initBoundingBoxes();\n    StructureInterfaceList list = new StructureInterfaceList();\n    for (int i = 0; i < polyChains.size(); i++) {\n        for (int j = i + 1; j < polyChains.size(); j++) {\n            if (!boundingBoxes[i].overlaps(boundingBoxes[j], cutoff)) {\n                continue;\n            }\n            StructureInterface interf = calcInterface(polyChains.get(i), polyChains.get(j));\n            if (interf != null) {\n                list.add(interf);\n            }\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Find all inter polymer-chain interfaces in the structure.\n * Two chains will be considered in contact if at least a pair of atoms (one from each chain) is within the\n * contact cutoff.\n * @return the list of all interfaces\n */\n", "repo_name": "biojava-master/", "id": 944, "method_signature": "StructureInterfaceList getAllInterfaces()"}, "3127": {"callee_method_names": ["Document.getDocumentElement", "Element.getTextContent", "Logger.error"], "method_name": "UniprotProxySequenceReader.getAccession", "method_implementation": "{\n    AccessionID accessionID = new AccessionID();\n    if (uniprotDoc == null) {\n        return accessionID;\n    }\n    try {\n        Element uniprotElement = uniprotDoc.getDocumentElement();\n        Element entryElement = XMLHelper.selectSingleElement(uniprotElement, \"entry\");\n        Element nameElement = XMLHelper.selectSingleElement(entryElement, \"name\");\n        accessionID = new AccessionID(nameElement.getTextContent(), DataSource.UNIPROT);\n    } catch (XPathExpressionException e) {\n        logger.error(\"Exception: \", e);\n    }\n    return accessionID;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3127, "method_signature": "AccessionID getAccession()"}, "3283": {"callee_method_names": [], "method_name": "AtomInfo.setResidueName", "method_implementation": "{\n    this.residueName = residueName;\n}", "repo_id": "9", "comment": "/**\n * Including insertion code\n *\n * @param residueName\n */\n", "repo_name": "biojava-master/", "id": 3283, "method_signature": "void setResidueName(String)"}, "534": {"callee_method_names": ["Logger.info"], "method_name": "AlignUtils.getCenter", "method_implementation": "{\n    Atom center = new AtomImpl();\n    if (pos + fragmentLength > ca.length) {\n        logger.info(\"pos (\" + pos + \"), fragL (\" + fragmentLength + \") > ca.length\" + ca.length);\n        return center;\n    }\n    Atom[] tmp = getFragmentNoClone(ca, pos, fragmentLength);\n    return Calc.getCentroid(tmp);\n}", "repo_id": "9", "comment": "/**\n * Get the centroid for the set of atoms starting from position pos, length fragmentLenght\n *\n * @param ca\n * @param pos\n * @param fragmentLength\n * @return an Atom\n */\n", "repo_name": "biojava-master/", "id": 534, "method_signature": "Atom getCenter(Atom[], int, int)"}, "1182": {"callee_method_ids": [1317], "callee_method_names": ["FileParsingParameters.isHeaderOnly"], "method_name": "PDBFileParser.pdb_MODEL_Handler", "method_implementation": "{\n    if (params.isHeaderOnly())\n        return;\n    // new model: we start a new molecule\n    startOfMolecule = true;\n    startOfModel = true;\n}", "repo_id": "9", "comment": "/**\n * Handler for MODEL Record Format\n * <pre>\n * COLUMNS       DATA TYPE      FIELD         DEFINITION\n * ----------------------------------------------------------------------\n * 1 -  6       Record name    \"MODEL \"\n * 11 - 14       Integer        serial        Model serial number.\n * </pre>\n */\n", "repo_name": "biojava-master/", "id": 1182, "method_signature": "void pdb_MODEL_Handler(String)"}, "162": {"callee_method_names": ["Structure.getPDBHeader"], "method_name": "TestNcsOpsParsing.test1auy", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    StructureIO.setAtomCache(cache);\n    Structure s = StructureIO.getStructure(\"1auy\");\n    Matrix4d[] ops = s.getPDBHeader().getCrystallographicInfo().getNcsOperators();\n    assertNotNull(ops);\n    // the given operator must not be in our list, only the \"generate\" operators\n    assertEquals(14, ops.length);\n    for (Matrix4d op : ops) {\n        assertEquals(0, op.m30, 0.000001);\n        assertEquals(0, op.m31, 0.000001);\n        assertEquals(0, op.m32, 0.000001);\n        assertEquals(1, op.m33, 0.000001);\n    }\n}", "repo_id": "9", "comment": "/**\n * A structure (viral capsid) with struct_ncs_ops\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 162, "method_signature": "void test1auy()"}, "1073": {"callee_method_names": ["Logger.info", "Path.toString", "Path.toFile", "File.exists", "Logger.info", "Path.toString"], "method_name": "ZipChemCompProvider.initializeZip", "method_implementation": "{\n    s_logger.info(\"Using chemical component dictionary: {}\", m_zipFile.toString());\n    final File f = m_zipFile.toFile();\n    if (!f.exists()) {\n        s_logger.info(\"Creating missing zip archive: {}\", m_zipFile.toString());\n        FileOutputStream fo = new FileOutputStream(f);\n        try (ZipOutputStream zip = new ZipOutputStream(new BufferedOutputStream(fo))) {\n            zip.putNextEntry(new ZipEntry(\"chemcomp/\"));\n            zip.closeEntry();\n        }\n    }\n}", "repo_id": "9", "comment": "// ZipFileSystems - due to URI issues in Java7.\n", "repo_name": "biojava-master/", "id": 1073, "method_signature": "void initializeZip()"}, "1030": {"callee_method_names": ["Chain.getAtomGroups", "Group.isWater", "Group.getAtoms", "Atom.getElement", "Group.getType", "List<Atom>.add", "List<Atom>.toArray"], "method_name": "StructureTools.getAllNonHAtomArray", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>();\n    for (Group g : c.getAtomGroups()) {\n        if (g.isWater())\n            continue;\n        for (Atom a : g.getAtoms()) {\n            if (a.getElement() == Element.H)\n                continue;\n            if (!hetAtoms && g.getType().equals(GroupType.HETATM))\n                continue;\n            atoms.add(a);\n        }\n    }\n    return atoms.toArray(new Atom[0]);\n}", "repo_id": "9", "comment": "/**\n * Returns and array of all non-Hydrogen atoms in the given Chain,\n * optionally including HET atoms or not Waters are not included.\n *\n * @param c\n * @param hetAtoms\n *            if true HET atoms are included in array, if false they are not\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1030, "method_signature": "Atom[] getAllNonHAtomArray(Chain, boolean)"}, "3203": {"callee_method_names": ["BlastXMLParser.setFile", "BlastXMLParser.createObjects", "List<Hsp>.add", "List<Hsp>.add", "List<Hit>.add", "List<Result>.get", "Result.iterator", "Hit.iterator"], "method_name": "BlastXMLParserTest.testCreateObjects", "method_implementation": "{\n    System.out.println(\"createObjects\");\n    String resource = \"/org/biojava/nbio/core/search/io/blast/small-blastreport.blastxml\";\n    File file = getFileForResource(resource);\n    BlastXMLParser instance = new BlastXMLParser();\n    instance.setFile(file);\n    //instance.setQueryReferences(null);\n    //instance.setDatabaseReferences(null);\n    List<Result> result = instance.createObjects(1e-10);\n    // test with random manual selected results\n    BlastHsp hsp1hit1res1 = new BlastHspBuilder().setHspNum(1).setHspBitScore(2894.82).setHspScore(1567).setHspEvalue(0).setHspQueryFrom(1).setHspQueryTo(1567).setHspHitFrom(616309).setHspHitTo(617875).setHspQueryFrame(1).setHspHitFrame(1).setHspIdentity(1567).setHspPositive(1567).setHspGaps(0).setHspAlignLen(1567).setHspQseq(\"TTAAATTGAGAGTTTGATCCTGGCTCAGGATGAACGCTGGTGGCGTGCCTAATACATGCAAGTCGTACGCTAGCCGCTGAATTGATCCTTCGGGTGAAGTGAGGCAATGACTAGAGTGGCGAACTGGTGAGTAACACGTAAGAAACCTGCCCTTTAGTGGGGGATAACATTTGGAAACAGATGCTAATACCGCGTAACAACAAATCACACATGTGATCTGTTTGAAAGGTCCTTTTGGATCGCTAGAGGATGGTCTTGCGGCGTATTAGCTTGTTGGTAGGGTAGAAGCCTACCAAGGCAATGATGCGTAGCCGAGTTGAGAGACTGGCCGGCCACATTGGGACTGAGACACTGCCCAAACTCCTACGGGAGGCTGCAGTAGGGAATTTTCCGCAATGCACGAAAGTGTGACGGAGCGACGCCGCGTGTGTGATGAAGGCTTTCGGGTCGTAAAGCACTGTTGTAAGGGAAGAATAACTGAATTCAGAGAAAGTTTTCAGCTTGACGGTACCTTACCAGAAAGGGATGGCTAAATACGTGCCAGCAGCCGCGGTAATACGTATGTCCCGAGCGTTATCCGGATTTATTGGGCGTAAAGCGAGCGCAGACGGTTTATTAAGTCTGATGTGAAATCCCGAGGCCCAACCTCGGAACTGCATTGGAAACTGATTTACTTGAGTGCGATAGAGGCAAGTGGAACTCCATGTGTAGCGGTGAAATGCGTAGATATGTGGAAGAACACCAGTGGCGAAAGCGGCTTGCTAGATCGTAACTGACGTTGAGGCTCGAAAGTATGGGTAGCAAACGGGATTAGATACCCCGGTAGTCCATACCGTAAACGATGGGTGCTAGTTGTTAAGAGGTTTCCGCCTCCTAGTGACGTAGCAAACGCATTAAGCACCCCGCCTGAGGAGTACGGCCGCAAGGCTAAAACTTAAAGGAATTGACGGGGACCCGCACAAGCGGTGGAGCATGTGGTTTAATTCGAAGATACGCGAAAAACCTTACCAGGTCTTGACATACCAATGATCGCTTTTGTAATGAAAGCTTTTCTTCGGAACATTGGATACAGGTGGTGCATGGTCGTCGTCAGCTCGTGTCGTGAGATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCTTGTTATTAGTTGCCAGCATTTAGTTGGGCACTCTAATGAGACTGCCGGTGATAAACCGGAGGAAGGTGGGGACGACGTCAGATCATCATGCCCCTTATGACCTGGGCAACACACGTGCTACAATGGGAAGTACAACGAGTCGCAAACCGGCGACGGTAAGCTAATCTCTTAAAACTTCTCTCAGTTCGGACTGGAGTCTGCAACTCGACTCCACGAAGGCGGAATCGCTAGTAATCGCGAATCAGCATGTCGCGGTGAATACGTTCCCGGGTCTTGTACACACCGCCCGTCAAATCATGGGAGTCGGAAGTACCCAAAGTCGCTTGGCTAACTTTTAGAGGCCGGTGCCTAAGGTAAAATCGATGACTGGGATTAAGTCGTAACAAGGTAGCCGTAGGAGAACCTGCGGCTGGATCACCTCCTTTCT\").setHspHseq(\"TTAAATTGAGAGTTTGATCCTGGCTCAGGATGAACGCTGGTGGCGTGCCTAATACATGCAAGTCGTACGCTAGCCGCTGAATTGATCCTTCGGGTGAAGTGAGGCAATGACTAGAGTGGCGAACTGGTGAGTAACACGTAAGAAACCTGCCCTTTAGTGGGGGATAACATTTGGAAACAGATGCTAATACCGCGTAACAACAAATCACACATGTGATCTGTTTGAAAGGTCCTTTTGGATCGCTAGAGGATGGTCTTGCGGCGTATTAGCTTGTTGGTAGGGTAGAAGCCTACCAAGGCAATGATGCGTAGCCGAGTTGAGAGACTGGCCGGCCACATTGGGACTGAGACACTGCCCAAACTCCTACGGGAGGCTGCAGTAGGGAATTTTCCGCAATGCACGAAAGTGTGACGGAGCGACGCCGCGTGTGTGATGAAGGCTTTCGGGTCGTAAAGCACTGTTGTAAGGGAAGAATAACTGAATTCAGAGAAAGTTTTCAGCTTGACGGTACCTTACCAGAAAGGGATGGCTAAATACGTGCCAGCAGCCGCGGTAATACGTATGTCCCGAGCGTTATCCGGATTTATTGGGCGTAAAGCGAGCGCAGACGGTTTATTAAGTCTGATGTGAAATCCCGAGGCCCAACCTCGGAACTGCATTGGAAACTGATTTACTTGAGTGCGATAGAGGCAAGTGGAACTCCATGTGTAGCGGTGAAATGCGTAGATATGTGGAAGAACACCAGTGGCGAAAGCGGCTTGCTAGATCGTAACTGACGTTGAGGCTCGAAAGTATGGGTAGCAAACGGGATTAGATACCCCGGTAGTCCATACCGTAAACGATGGGTGCTAGTTGTTAAGAGGTTTCCGCCTCCTAGTGACGTAGCAAACGCATTAAGCACCCCGCCTGAGGAGTACGGCCGCAAGGCTAAAACTTAAAGGAATTGACGGGGACCCGCACAAGCGGTGGAGCATGTGGTTTAATTCGAAGATACGCGAAAAACCTTACCAGGTCTTGACATACCAATGATCGCTTTTGTAATGAAAGCTTTTCTTCGGAACATTGGATACAGGTGGTGCATGGTCGTCGTCAGCTCGTGTCGTGAGATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCTTGTTATTAGTTGCCAGCATTTAGTTGGGCACTCTAATGAGACTGCCGGTGATAAACCGGAGGAAGGTGGGGACGACGTCAGATCATCATGCCCCTTATGACCTGGGCAACACACGTGCTACAATGGGAAGTACAACGAGTCGCAAACCGGCGACGGTAAGCTAATCTCTTAAAACTTCTCTCAGTTCGGACTGGAGTCTGCAACTCGACTCCACGAAGGCGGAATCGCTAGTAATCGCGAATCAGCATGTCGCGGTGAATACGTTCCCGGGTCTTGTACACACCGCCCGTCAAATCATGGGAGTCGGAAGTACCCAAAGTCGCTTGGCTAACTTTTAGAGGCCGGTGCCTAAGGTAAAATCGATGACTGGGATTAAGTCGTAACAAGGTAGCCGTAGGAGAACCTGCGGCTGGATCACCTCCTTTCT\").setHspIdentityString(\"|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\").createBlastHsp();\n    List<Hsp> hsplist = new ArrayList<Hsp>();\n    hsplist.add(hsp1hit1res1);\n    hsplist.add(hsp1hit1res1);\n    BlastHit hit1res1 = new BlastHitBuilder().setHitNum(1).setHitId(\"gnl|BL_ORD_ID|2006\").setHitDef(\"CP000411 Oenococcus oeni PSU-1, complete genome\").setHitAccession(\"0\").setHitLen(1780517).setHsps(hsplist).createBlastHit();\n    List<Hit> hitlist = new ArrayList<Hit>();\n    hitlist.add(hit1res1);\n    BlastResult res1 = new BlastResultBuilder().setProgram(\"blastn\").setVersion(\"BLASTN 2.2.29+\").setReference(\"Zheng Zhang, Scott Schwartz, Lukas Wagner, and Webb Miller (2000), &quot;A greedy algorithm for aligning DNA sequences&quot;, J Comput Biol 2000; 7(1-2):203-14.\").setQueryID(\"Query_1\").setQueryDef(\"CP000411_-_16S_rRNA Oenococcus oeni PSU-1, complete genome\").setQueryLength(1567).createBlastResult();\n    Result expRes1 = result.get(0);\n    Hit expHit1res1 = expRes1.iterator().next();\n    Hsp expHsp1hit1res1 = expHit1res1.iterator().next();\n    // result not testable without all hits and hsp\n    //assertEquals(expRes1, res1);\n    // hit test\n    assertEquals(expHit1res1, hit1res1);\n    // hsp test\n    assertEquals(expHsp1hit1res1, hsp1hit1res1);\n}", "repo_id": "9", "comment": "/**\n * Test of createObjects method, of class BlastXMLParser.\n */\n", "repo_name": "biojava-master/", "id": 3203, "method_signature": "void testCreateObjects()"}, "3202": {"callee_method_names": ["BlastXMLParser.setFile"], "method_name": "BlastXMLParserTest.testSetFile", "method_implementation": "{\n    System.out.println(\"setFile\");\n    File f = null;\n    BlastXMLParser instance = new BlastXMLParser();\n    instance.setFile(f);\n}", "repo_id": "9", "comment": "/**\n * Test of setFile method, of class BlastXMLParser.\n */\n", "repo_name": "biojava-master/", "id": 3202, "method_signature": "void testSetFile()"}, "1528": {"callee_method_names": [], "method_name": "JournalArticle.getPmid", "method_implementation": "{\n    return pmid;\n}", "repo_id": "9", "comment": "/**\n * Get the value of PMID field.\n * For example: 12005435\n *\n * @return the value of pmid\n */\n", "repo_name": "biojava-master/", "id": 1528, "method_signature": "String getPmid()"}, "829": {"callee_method_names": [], "method_name": "AlternativeAlignment.getDistanceMatrix", "method_implementation": "{\n    return distanceMatrix;\n}", "repo_id": "9", "comment": "/**\n * The distance matrix this alignment is based on\n *\n * @return a Matrix object.\n */\n", "repo_name": "biojava-master/", "id": 829, "method_signature": "Matrix getDistanceMatrix()"}, "564": {"callee_method_names": [], "method_name": "RotationAxis.getFullMatrix", "method_implementation": "{\n    // TODO, easy\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Returns a matrix that describes both rotation and translation.\n */\n", "repo_name": "biojava-master/", "id": 564, "method_signature": "Matrix getFullMatrix()"}, "1240": {"callee_method_names": [], "method_name": "FastaStructureParser.getResidues", "method_implementation": "{\n    return residues;\n}", "repo_id": "9", "comment": "/**\n * For each residue in the fasta file, return the ResidueNumber in the\n * corresponding structure. If the residue cannot be found in the structure,\n * that entry will be null. This can happen if that residue was not included\n * in the PDB file (eg disordered residues), if the fasta sequence does not\n * match the PDB sequence, or if errors occur during the matching process.\n * @return A 2D array of ResidueNumbers, or null if process() hasn't been called.\n * @see StructureSequenceMatcher#matchSequenceToStructure(ProteinSequence, Structure)\n */\n", "repo_name": "biojava-master/", "id": 1240, "method_signature": "ResidueNumber[][] getResidues()"}, "1542": {"callee_method_names": ["Map<Integer, ScopDescription>.keySet", "Map<Integer, ScopDescription>.get", "ScopDescription.getCategory", "List<ScopDescription>.add", "ScopDescription.clone"], "method_name": "ScopInstallation.getByCategory", "method_implementation": "{\n    try {\n        ensureDesInstalled();\n    } catch (IOException e) {\n        throw new ScopIOException(e);\n    }\n    List<ScopDescription> matches = new ArrayList<ScopDescription>();\n    for (Integer i : sunidMap.keySet()) {\n        ScopDescription sc = sunidMap.get(i);\n        if (sc.getCategory().equals(category))\n            try {\n                matches.add((ScopDescription) sc.clone());\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(\"Could not clone \" + ScopDescription.class + \" subclass\", e);\n            }\n    }\n    return matches;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getByCategory(org.biojava.nbio.structure.scop.ScopCategory)\n\t */\n", "repo_name": "biojava-master/", "id": 1542, "method_signature": "List<ScopDescription> getByCategory(ScopCategory)"}, "467": {"callee_method_names": [], "method_name": "StructureName.getIdentifier", "method_implementation": "{\n    return name;\n}", "repo_id": "9", "comment": "/**\n * Get the original form of the identifier\n */\n", "repo_name": "biojava-master/", "id": 467, "method_signature": "String getIdentifier()"}, "1732": {"callee_method_names": [], "method_name": "BasePairParameters.getTwist", "method_implementation": "{\n    if (bp < 0 || bp >= getStepParameters().length)\n        throw new IllegalArgumentException(\"Base pair number is out of range.\");\n    return stepParameters[bp][2];\n}", "repo_id": "9", "comment": "/**\n * This method returns the twist for the given base pair, relative to the one before it.\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in degrees)\n */\n", "repo_name": "biojava-master/", "id": 1732, "method_signature": "Double getTwist(int)"}, "78": {"callee_method_names": [], "method_name": "AlignerHelper.isStartAnchored", "method_implementation": "{\n    return isAnchored;\n}", "repo_id": "9", "comment": "/**\n * Indicates whether the start query and start target index compounds\n * are anchored to each other\n * @return true if the compounds are anchored in the alignment, false otherwise\n */\n", "repo_name": "biojava-master/", "id": 78, "method_signature": "boolean isStartAnchored()"}, "1590": {"callee_method_names": [], "method_name": "SecStrucCalc.detectStrands", "method_implementation": "{\n    //Find all the beta bridges of the structure\n    findBridges();\n    //Create Ladders\n    createLadders();\n    //Detect beta bulges between ladders\n    connectLadders();\n    //AND store SS assignments for Sheets, Strands and Bridges\n    updateSheets();\n}", "repo_id": "9", "comment": "/**\n * Updated code to detect strands\n */\n", "repo_name": "biojava-master/", "id": 1590, "method_signature": "void detectStrands()"}, "3495": {"callee_method_names": [], "method_name": "NCBIQBlastAlignmentProperties.getBlastMatrix", "method_implementation": "{\n    return getAlignmentOption(MATRIX_NAME);\n}", "repo_id": "9", "comment": "/**\n * Returns the value of the specified substitution matrix\n *\n * @return matrix: the name of the specified substitution matrix\n */\n", "repo_name": "biojava-master/", "id": 3495, "method_signature": "String getBlastMatrix()"}, "123": {"callee_method_names": ["List<DNASequence>.add", "List<DNASequence>.add"], "method_name": "TestDNAAlignment.testDNAMultipleAlignmentWithMixedCompoundSets", "method_implementation": "{\n    DNASequence target = new DNASequence(\"ACTGACGTGTAGCTGACTGA\", DNACompoundSet.getDNACompoundSet());\n    DNASequence query = new DNASequence(\"ACTGACGTGTAGCTGACTGTA\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    List<DNASequence> lst = new ArrayList<DNASequence>();\n    lst.add(target);\n    lst.add(query);\n    try {\n        @SuppressWarnings(\"unused\")\n        Profile<DNASequence, NucleotideCompound> profile = Alignments.getMultipleSequenceAlignment(lst);\n        Assert.fail(\"Alignments.getMultipleSequenceAlignment(lst) expected exception with differing compound sets\");\n    } catch (IllegalArgumentException ex) {\n        // expected exception\n    }\n}", "repo_id": "9", "comment": "/**\n * @author brandstaetter\n */\n", "repo_name": "biojava-master/", "id": 123, "method_signature": "void testDNAMultipleAlignmentWithMixedCompoundSets()"}, "1337": {"callee_method_names": ["String.equals", "String.compareTo"], "method_name": "ResidueNumber.compareTo", "method_implementation": "{\n    // chain id\n    if (chainName != null && other.chainName != null) {\n        if (!chainName.equals(other.chainName))\n            return chainName.compareTo(other.chainName);\n    }\n    if (chainName != null && other.chainName == null) {\n        return 1;\n    } else if (chainName == null && other.chainName != null) {\n        return -1;\n    }\n    return compareToPositional(other);\n}", "repo_id": "9", "comment": "/**\n * Compare residue numbers by chain, sequence number, and insertion code\n */\n", "repo_name": "biojava-master/", "id": 1337, "method_signature": "int compareTo(ResidueNumber)"}, "1383": {"callee_method_names": [], "method_name": "DBRef.setDbSeqBegin", "method_implementation": "{\n    this.dbSeqBegin = dbSeqBegin;\n}", "repo_id": "9", "comment": "/**\n *  Initial sequence number of the\n * \tdatabase seqment.\n *  @param dbSeqBegin a sequence position\n *  @see #getDbSeqBegin()\n */\n", "repo_name": "biojava-master/", "id": 1383, "method_signature": "void setDbSeqBegin(int)"}, "3234": {"callee_method_names": [], "method_name": "DNATest.getSeq", "method_implementation": "{\n    return getSeq(null);\n}", "repo_id": "9", "comment": "//  }\n", "repo_name": "biojava-master/", "id": 3234, "method_signature": "DNASequence getSeq()"}, "1748": {"callee_method_names": [], "method_name": "TertiaryBasePairParameters.setMaxStagger", "method_implementation": "{\n    this.maxStagger = maxStagger;\n}", "repo_id": "9", "comment": "/**\n * This method sets the maximum stagger allowed for a base pair, prior to analyze() call\n * @param maxStagger The maximum stagger (in \u00c5) allowed to consider two bases paired\n */\n", "repo_name": "biojava-master/", "id": 1748, "method_signature": "void setMaxStagger(double)"}, "3450": {"callee_method_names": ["HashMap.get"], "method_name": "NCBIQBlastOutputProperties.getOutputOption", "method_implementation": "{\n    return param.get(key);\n}", "repo_id": "9", "comment": "/**\n * Gets the value of specified parameter or {@code null} if it is not set\n */\n", "repo_name": "biojava-master/", "id": 3450, "method_signature": "String getOutputOption(BlastOutputParameterEnum)"}, "3708": {"callee_method_names": ["LinkedHashMap.containsKey", "ArrayList<String>.add"], "method_name": "WorkSheet.getDataColumns", "method_implementation": "{\n    ArrayList<String> dataColumns = new ArrayList<String>();\n    ArrayList<String> columns = this.getColumns();\n    for (String column : columns) {\n        if (!metaDataColumnsHashMap.containsKey(column)) {\n            dataColumns.add(column);\n        }\n    }\n    return dataColumns;\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3708, "method_signature": "ArrayList<String> getDataColumns()"}, "2300": {"callee_method_names": [], "method_name": "TestBond.testWeirdCase", "method_implementation": "{\n    assertEquals(6, countAtomsWithoutBonds(\"1IU6\"));\n}", "repo_id": "9", "comment": "/**\n * Test this weird case - with missing Oxygen atoms, alternate locations on Deuterium\n * and terminal hydrogens.\n * @throws IOException an error getting the required file\n * @throws StructureException an error parsing the required file\n */\n", "repo_name": "biojava-master/", "id": 2300, "method_signature": "void testWeirdCase()"}, "616": {"callee_method_names": ["URLConnection.setRequestProperty", "URLConnection.getContentEncoding", "URLConnection.getInputStream", "String.contains"], "method_name": "URLConnectionTools.getInputStream", "method_implementation": "{\n    InputStream inStream = null;\n    URLConnection huc = URLConnectionTools.openURLConnection(url, timeout);\n    if (acceptGzipEncoding)\n        huc.setRequestProperty(\"Accept-Encoding\", \"gzip\");\n    String contentEncoding = huc.getContentEncoding();\n    inStream = huc.getInputStream();\n    if (contentEncoding != null) {\n        if (contentEncoding.contains(\"gzip\")) {\n            inStream = new GZIPInputStream(inStream);\n        }\n    }\n    return inStream;\n}", "repo_id": "9", "comment": "/**\n * Open a URL and return an InputStream to it\n * if acceptGzipEncoding == true, use GZIPEncoding to\n * compress communication.\n * <p>\n * The caller is responsible to close the returned InputStream not to cause\n * resource leaks.\n * @param url the input URL to be read\n * @param acceptGzipEncoding whether to accept Gzip encoding\n * @param timeout\n * @return an {@link InputStream} of response\n * @throws IOException due to an error opening the URL\n */\n", "repo_name": "biojava-master/", "id": 616, "method_signature": "InputStream getInputStream(URL, boolean, int)"}, "1976": {"callee_method_names": ["QuatSymmetrySubunits.getTraces", "Point3d.set", "Matrix4d.transform"], "method_name": "HelixAxisAligner.calcBoundaries", "method_implementation": "{\n    minBoundary.x = Double.MAX_VALUE;\n    maxBoundary.x = Double.MIN_VALUE;\n    minBoundary.y = Double.MAX_VALUE;\n    maxBoundary.x = Double.MIN_VALUE;\n    minBoundary.z = Double.MAX_VALUE;\n    maxBoundary.z = Double.MIN_VALUE;\n    xzRadiusMax = Double.MIN_VALUE;\n    Point3d probe = new Point3d();\n    for (Point3d[] list : subunits.getTraces()) {\n        for (Point3d p : list) {\n            probe.set(p);\n            transformationMatrix.transform(probe);\n            minBoundary.x = Math.min(minBoundary.x, probe.x);\n            maxBoundary.x = Math.max(maxBoundary.x, probe.x);\n            minBoundary.y = Math.min(minBoundary.y, probe.y);\n            maxBoundary.y = Math.max(maxBoundary.y, probe.y);\n            minBoundary.z = Math.min(minBoundary.z, probe.z);\n            maxBoundary.z = Math.max(maxBoundary.z, probe.z);\n            xzRadiusMax = Math.max(xzRadiusMax, Math.sqrt(probe.x * probe.x + probe.z * probe.z));\n        }\n    }\n    //\t\tSystem.out.println(\"MinBoundary: \" + minBoundary);\n    //\t\tSystem.out.println(\"MaxBoundary: \" + maxBoundary);\n    //\t\tSystem.out.println(\"zxRadius: \" + xzRadiusMax);\n}", "repo_id": "9", "comment": "/**\n * Calculates the min and max boundaries of the structure after it has been\n * transformed into its canonical orientation.\n */\n", "repo_name": "biojava-master/", "id": 1976, "method_signature": "void calcBoundaries()"}, "2990": {"callee_method_names": [], "method_name": "BitSequenceReader.iterator", "method_implementation": "{\n    return SequenceMixin.createIterator(this);\n}", "repo_id": "9", "comment": "/**\n * Provides basic iterable access to this class\n */\n", "repo_name": "biojava-master/", "id": 2990, "method_signature": "Iterator<C> iterator()"}, "1738": {"callee_method_names": ["Map<String, Integer>.get", "Pair<Group>.getFirst", "Map<String, Integer>.get", "Pair<Group>.getSecond", "PDBFileReader.getStructure", "String[].getBytes", "PDBFileReader.getStructure", "String[].getBytes", "Element.printStackTrace", "Structure.getChain", "Structure.getChain", "Group.getAtoms", "Group.getAtoms", "Group.getAtoms", "Pair<Group>.getFirst", "Atom.getName", "Atom.getCoordsAsPoint3d", "Pair<Group>.getFirst", "Atom.getName", "Group.getAtoms", "SuperPosition.superposeAndTransform", "Group.getAtoms", "Group.getAtoms", "Group.getAtoms", "Pair<Group>.getSecond", "Atom.getName", "Atom.getCoordsAsPoint3d", "Pair<Group>.getSecond", "Atom.getName", "Group.getAtoms", "Matrix4d.clone", "Matrix4d.clone", "SuperPosition.superposeAndTransform", "Matrix4d.getColumn", "Matrix4d.getColumn", "Matrix4d.getColumn", "Matrix4d.setColumn", "Matrix4d.setColumn", "Matrix4d.add", "Matrix4d.mul", "Matrix4d.getColumn", "Matrix4d.getColumn", "Matrix4d.getColumn", "Matrix4d.setColumn", "Matrix4d.setColumn", "Matrix4d.setColumn", "Matrix4d.getColumn", "Matrix4d.setColumn", "Matrix4d.invert", "Matrix4d.mul"], "method_name": "BasePairParameters.basePairReferenceFrame", "method_implementation": "{\n    Integer type1 = BASE_MAP.get(pair.getFirst().getPDBName());\n    Integer type2 = BASE_MAP.get(pair.getSecond().getPDBName());\n    SuperPosition sp = new SuperPositionQCP(true);\n    if (type1 == null || type2 == null)\n        return null;\n    PDBFileReader pdbFileReader = new PDBFileReader();\n    Structure s1, s2;\n    try {\n        s1 = pdbFileReader.getStructure(new ByteArrayInputStream(STANDARD_BASES[type1].getBytes()));\n        s2 = pdbFileReader.getStructure(new ByteArrayInputStream(STANDARD_BASES[type2].getBytes()));\n    } catch (IOException e) {\n        e.printStackTrace();\n        return null;\n    }\n    Group std1 = s1.getChain(\"A\").getAtomGroup(0);\n    Group std2 = s2.getChain(\"A\").getAtomGroup(0);\n    Point3d[] pointref = new Point3d[std1.getAtoms().size()];\n    Point3d[] pointact = new Point3d[std1.getAtoms().size()];\n    int count = 0;\n    for (Atom a : std1.getAtoms()) {\n        if (pair.getFirst().getAtom(a.getName()) == null)\n            return null;\n        pointref[count] = a.getCoordsAsPoint3d();\n        pointact[count] = pair.getFirst().getAtom(a.getName()).getCoordsAsPoint3d();\n        count++;\n    }\n    assert count == std1.getAtoms().size();\n    Matrix4d ref1 = (Matrix4d) sp.superposeAndTransform(pointact, pointref).clone();\n    pointref = new Point3d[std2.getAtoms().size()];\n    pointact = new Point3d[std2.getAtoms().size()];\n    count = 0;\n    for (Atom a : std2.getAtoms()) {\n        if (pair.getSecond().getAtom(a.getName()) == null)\n            return null;\n        pointref[count] = a.getCoordsAsPoint3d();\n        pointact[count] = pair.getSecond().getAtom(a.getName()).getCoordsAsPoint3d();\n        count++;\n    }\n    assert count == std2.getAtoms().size();\n    Matrix4d temp = (Matrix4d) ref1.clone();\n    Matrix4d temp2 = (Matrix4d) temp.clone();\n    Matrix4d ref2 = sp.superposeAndTransform(pointact, pointref);\n    double[][] v = new double[3][4];\n    double[] y3 = new double[4];\n    double[] z3 = new double[4];\n    ref2.getColumn(1, y3);\n    ref2.getColumn(2, z3);\n    double[] z31 = new double[4];\n    ref1.getColumn(2, z31);\n    if (z3[0] * z31[0] + z3[1] * z31[1] + z3[2] * z31[2] < 0.0) {\n        for (int i = 0; i < 3; i++) {\n            y3[i] *= -1.0;\n            z3[i] *= -1.0;\n        }\n    }\n    ref2.setColumn(1, y3);\n    ref2.setColumn(2, z3);\n    temp.add(ref2);\n    temp.mul(0.5);\n    double[] x3 = new double[4];\n    temp.getColumn(0, x3);\n    temp.getColumn(1, y3);\n    temp.getColumn(2, z3);\n    x3 = removeComponent(x3, z3);\n    x3 = removeComponent(x3, y3);\n    y3 = removeComponent(y3, z3);\n    temp.setColumn(0, x3);\n    temp.setColumn(1, y3);\n    temp.setColumn(2, z3);\n    // normalize the short, long, and normal axes\n    for (int i = 0; i < 3; i++) {\n        temp.getColumn(i, v[i]);\n        double r = Math.sqrt(v[i][0] * v[i][0] + v[i][1] * v[i][1] + v[i][2] * v[i][2]);\n        for (int j = 0; j < 3; j++) {\n            v[i][j] /= r;\n        }\n        temp.setColumn(i, v[i]);\n    }\n    // calculate pairing parameters: buckle, propeller, opening, shear, stretch, stagger\n    temp2.invert();\n    temp2.mul(ref2);\n    pairParameters = calculateTp(temp2);\n    for (int i = 0; i < 6; i++) pairParameters[i] *= -1;\n    // return the central frame of the base pair\n    return temp;\n}", "repo_id": "9", "comment": "/**\n * This method calculates the central frame (4x4 transformation matrix) of a single base pair.\n * @param pair An array of the two groups that make a hypothetical pair\n * @return The middle frame of the center of the base-pair formed\n */\n", "repo_name": "biojava-master/", "id": 1738, "method_signature": "Matrix4d basePairReferenceFrame(Pair)"}, "2870": {"callee_method_names": ["DataInputStream.readShort", "DataInputStream.readShort", "DataInputStream.readShort", "DataInputStream.readShort"], "method_name": "ABITrace.setTraces", "method_implementation": "{\n    //alphabetical, 0=A, 1=C, 2=G, 3=T\n    int[] pointers = new int[4];\n    int[] datas = new int[4];\n    char[] order = new char[4];\n    datas[0] = DATA9;\n    datas[1] = DATA10;\n    datas[2] = DATA11;\n    datas[3] = DATA12;\n    for (int i = 0; i <= 3; i++) {\n        order[i] = (char) traceData[FWO + i];\n    }\n    for (int i = 0; i <= 3; i++) {\n        switch(order[i]) {\n            case 'A':\n            case 'a':\n                pointers[0] = datas[i];\n                break;\n            case 'C':\n            case 'c':\n                pointers[1] = datas[i];\n                break;\n            case 'G':\n            case 'g':\n                pointers[2] = datas[i];\n                break;\n            case 'T':\n            case 't':\n                pointers[3] = datas[i];\n                break;\n            default:\n                throw new IllegalArgumentException(\"Trace contains illegal values.\");\n        }\n    }\n    A = new int[traceLength];\n    C = new int[traceLength];\n    G = new int[traceLength];\n    T = new int[traceLength];\n    for (int i = 0; i <= 3; i++) {\n        byte[] qq = new byte[traceLength * 2];\n        getSubArray(qq, pointers[i]);\n        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(qq));\n        for (int x = 0; x <= traceLength - 1; x++) {\n            try {\n                if (i == 0)\n                    A[x] = (int) dis.readShort();\n                if (i == 1)\n                    C[x] = (int) dis.readShort();\n                if (i == 2)\n                    G[x] = (int) dis.readShort();\n                if (i == 3)\n                    T[x] = (int) dis.readShort();\n            } catch (//This shouldn't happen. If it does something must be seriously wrong.\n            IOException e) {\n                throw new IllegalStateException(\"Unexpected IOException encountered while manipulating internal streams.\");\n            }\n        }\n    }\n    return;\n}", "repo_id": "9", "comment": "/**\n * Shuffle the pointers to point to the proper spots in the trace, then load the\n * traces into their arrays.\n */\n", "repo_name": "biojava-master/", "id": 2870, "method_signature": "void setTraces()"}, "2148": {"callee_method_names": [], "method_name": "StructureImpl.getDBRefs", "method_implementation": "{\n    return dbrefs;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2148, "method_signature": "List<DBRef> getDBRefs()"}, "694": {"callee_method_names": ["MultipleAlignment.clone", "List<SortedSet<Integer>>.get", "double.add", "List<SortedSet<Integer>>.add", "Random.nextDouble", "Logger.debug", "Logger.debug", "Logger.debug", "Logger.debug", "MultipleAlignment.clear", "MultipleSuperimposer.superimpose", "Random.nextDouble", "Logger.debug", "List<Integer>.add", "MultipleAlignment.length", "List<Double>.add", "List<Double>.add", "MultipleSuperimposer.superimpose", "MultipleAlignment.putScore", "Logger.warn", "Object.getMessage"], "method_name": "MultipleMcOptimizer.optimize", "method_implementation": "{\n    initialize();\n    // Number of steps without an alignment improvement\n    int conv = 0;\n    int i = 1;\n    int maxIter = convergenceSteps * 100;\n    while (i < maxIter && conv < convergenceSteps) {\n        // Save the state of the system\n        MultipleAlignment lastMSA = msa.clone();\n        List<SortedSet<Integer>> lastFreePool = new ArrayList<SortedSet<Integer>>();\n        for (int k = 0; k < size; k++) {\n            SortedSet<Integer> p = new TreeSet<Integer>();\n            for (Integer l : freePool.get(k)) p.add(l);\n            lastFreePool.add(p);\n        }\n        double lastScore = mcScore;\n        boolean moved = false;\n        while (!moved) {\n            // Randomly select one of the steps to modify the alignment\n            double move = rnd.nextDouble();\n            if (move < 0.4) {\n                moved = shiftRow();\n                logger.debug(\"did shift\");\n            } else if (move < 0.7) {\n                moved = expandBlock();\n                logger.debug(\"did expand\");\n            } else if (move < 0.85) {\n                moved = shrinkBlock();\n                logger.debug(\"did shrink\");\n            } else {\n                moved = insertGap();\n                logger.debug(\"did insert gap\");\n            }\n        }\n        // Get the score of the new alignment\n        msa.clear();\n        imposer.superimpose(msa);\n        mcScore = MultipleAlignmentScorer.getMCScore(msa, Gopen, Gextend, dCutoff);\n        double AS = mcScore - lastScore;\n        double prob = 1.0;\n        if (AS < 0) {\n            // Probability of accepting the move\n            prob = probabilityFunction(AS, i, maxIter);\n            double p = rnd.nextDouble();\n            // Reject the move\n            if (p > prob) {\n                msa = lastMSA;\n                freePool = lastFreePool;\n                mcScore = lastScore;\n                conv++;\n            } else\n                conv = 0;\n        } else\n            conv = 0;\n        logger.debug(\"Step: \" + i + \": --prob: \" + prob + \", --score change: \" + AS + \", --conv: \" + conv);\n        if (history) {\n            if (i % 100 == 1) {\n                lengthHistory.add(msa.length());\n                rmsdHistory.add(MultipleAlignmentScorer.getRMSD(msa));\n                scoreHistory.add(mcScore);\n            }\n        }\n        i++;\n    }\n    // Return Multiple Alignment\n    imposer.superimpose(msa);\n    MultipleAlignmentScorer.calculateScores(msa);\n    msa.putScore(MultipleAlignmentScorer.MC_SCORE, mcScore);\n    if (history) {\n        try {\n            saveHistory(pathToHistory);\n        } catch (Exception e) {\n            logger.warn(\"Could not save history file: \" + e.getMessage());\n        }\n    }\n    return msa;\n}", "repo_id": "9", "comment": "/**\n * Optimization method based in a Monte-Carlo approach. Starting from the\n * refined alignment uses 4 types of moves:\n * <p>\n * <ul>\n * <li>Shift Row: if there are enough freePool residues available.\n * <li>Expand Block: add another alignment column.\n * <li>Shrink Block: move a block column to the freePool.\n * <li>Insert gap: insert a gap in a random position of the alignment.\n * </ul>\n * </li>\n */\n", "repo_name": "biojava-master/", "id": 694, "method_signature": "MultipleAlignment optimize()"}, "12": {"callee_method_names": [], "method_name": "GuideTree.iterator", "method_implementation": "{\n    return new PostOrderIterator();\n}", "repo_id": "9", "comment": "/**\n * Returns a post-order {@link Iterator} that traverses the tree from leaves to root.\n */\n", "repo_name": "biojava-master/", "id": 12, "method_signature": "Iterator<GuideTreeNode<S,C>> iterator()"}, "3216": {"callee_method_names": ["TranscriptSequence.equals"], "method_name": "TranscriptSequenceTest.equalsDoesntDependOnStrand", "method_implementation": "{\n    assertTrue(transcriptSeq.equals(transcriptNegativeSeq));\n}", "repo_id": "9", "comment": "// whether it's -ve or +ve doesn't affect equals?\n", "repo_name": "biojava-master/", "id": 3216, "method_signature": "void equalsDoesntDependOnStrand()"}, "2172": {"callee_method_ids": [619, 619], "callee_method_names": ["AtomCache.getAtoms", "List<ResidueRangeAndLength>.get", "List<ResidueRangeAndLength>.get", "List<ResidueRangeAndLength>.get", "AtomCache.getAtoms", "List<ResidueRangeAndLength>.get", "ResidueRangeAndLength.getChainName", "ResidueRangeAndLength.getStart", "ResidueRangeAndLength.getEnd", "List<ResidueRangeAndLength>.get", "ResidueRangeAndLength.getChainName", "ResidueRangeAndLength.getStart", "ResidueRangeAndLength.getEnd", "List<ResidueRangeAndLength>.get", "ResidueRangeAndLength.getChainName", "ResidueRangeAndLength.getStart", "ResidueRangeAndLength.getEnd", "ResidueRange.getChainName", "ResidueRange.getStart", "ResidueRange.getEnd"], "method_name": "ResidueRangeTest.testParseAndEqualWithLengths", "method_implementation": "{\n    String rangeStr;\n    List<ResidueRangeAndLength> ranges;\n    ResidueRangeAndLength range;\n    AtomPositionMap map;\n    String pdbId = \"2eke\";\n    map = new AtomPositionMap(cache.getAtoms(pdbId));\n    //C is 105-112,1013-1095\n    rangeStr = \"C_1023-1063,C_1064-1084,C\";\n    ranges = ResidueRangeAndLength.parseMultiple(rangeStr, map);\n    assertEquals(new ResidueRangeAndLength(\"C\", new ResidueNumber(\"C\", 1023, null), new ResidueNumber(\"C\", 1063, null), 1063 - 1023 + 1), ranges.get(0));\n    assertEquals(new ResidueRangeAndLength(\"C\", new ResidueNumber(\"C\", 1064, null), new ResidueNumber(\"C\", 1084, null), 1084 - 1064 + 1), ranges.get(1));\n    assertEquals(new ResidueRangeAndLength(\"C\", new ResidueNumber(\"C\", 105, null), new ResidueNumber(\"C\", 1095, null), 91), ranges.get(2));\n    // Wildcard chains\n    // A:8-52,58-109,119-161\n    pdbId = \"4r61\";\n    map = new AtomPositionMap(cache.getAtoms(pdbId));\n    rangeStr = \"_,__,_:52-58\";\n    ranges = ResidueRangeAndLength.parseMultiple(rangeStr, map);\n    range = ranges.get(0);\n    assertEquals(\"Error parsing \" + rangeStr, \"A\", range.getChainName());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\", 8, null), range.getStart());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\", 161, null), range.getEnd());\n    range = ranges.get(1);\n    assertEquals(\"Error parsing \" + rangeStr, \"A\", range.getChainName());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\", 8, null), range.getStart());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\", 161, null), range.getEnd());\n    range = ranges.get(2);\n    assertEquals(\"Error parsing \" + rangeStr, \"A\", range.getChainName());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\", 52, null), range.getStart());\n    assertEquals(\"Error parsing \" + rangeStr, new ResidueNumber(\"A\", 58, null), range.getEnd());\n    // wildcards not converted without the map\n    ResidueRange range2 = ResidueRange.parse(\"_\");\n    assertEquals(\"Error parsing \" + rangeStr, \"_\", range2.getChainName());\n    assertNull(\"Error parsing \" + rangeStr, range2.getStart());\n    assertNull(\"Error parsing \" + rangeStr, range2.getEnd());\n}", "repo_id": "9", "comment": "/**\n * Tests\n * {@link org.biojava.nbio.structure.ResidueRangeAndLength#parseMultiple(String, org.biojava.nbio.structure.AtomPositionMap)}\n * .\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2172, "method_signature": "void testParseAndEqualWithLengths()"}, "1803": {"callee_method_names": ["String.isEmpty", "Pattern.matcher", "Matcher.matches", "Matcher.group", "Logger.debug", "Logger.debug", "List<EcodDomain>.size", "String.equals", "double[].getDomainId"], "method_name": "EcodInstallation.getDomainsById", "method_implementation": "{\n    if (ecodId == null || ecodId.isEmpty()) {\n        return null;\n    }\n    Matcher match = ECOD_RE.matcher(ecodId);\n    String pdbId = null;\n    if (match.matches())\n        pdbId = match.group(1);\n    List<EcodDomain> doms = getDomainsForPdb(pdbId);\n    if (doms == null) {\n        logger.debug(\"Null domains for {} from {}\", pdbId, ecodId);\n        return null;\n    }\n    logger.debug(\"Got {} domains from {}\", doms.size(), pdbId);\n    for (EcodDomain d : doms) {\n        if (ecodId.equals(d.getDomainId())) {\n            return d;\n        }\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Get a particular ECOD domain by the domain ID (e.g. \"e4hhbA1\")\n * @param ecodId\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1803, "method_signature": "EcodDomain getDomainsById(String)"}, "252": {"callee_method_names": ["Map<String, Set<ProteinModification>>.get"], "method_name": "ProteinModificationRegistry.getByPdbccId", "method_implementation": "{\n    lazyInit();\n    return byPdbccId.get(pdbccId);\n}", "repo_id": "9", "comment": "/**\n * @param pdbccId Protein Data Bank Chemical Component ID.\n * @return a set of ProteinModifications that have the PDBCC ID.\n */\n", "repo_name": "biojava-master/", "id": 252, "method_signature": "Set<ProteinModification> getByPdbccId(String)"}, "35": {"callee_method_names": [], "method_name": "StockholmFileAnnotation.getTrustedCutoffs", "method_implementation": "{\n    return trustedCutoffs;\n}", "repo_id": "9", "comment": "/**\n * Not always 2.<br>\n *  It may undergo further change.\n *  @return\n */\n", "repo_name": "biojava-master/", "id": 35, "method_signature": "float[] getTrustedCutoffs()"}, "101": {"callee_method_names": ["String.length", "String.length", "String.charAt", "String.charAt"], "method_name": "Comparison.PID", "method_implementation": "{\n    int s1len = seq1.length();\n    int s2len = seq2.length();\n    int len = Math.min(s1len, s2len);\n    if (end < len) {\n        len = end;\n    }\n    if (len < start) {\n        // we just use a single residue for the difference\n        start = len - 1;\n    }\n    int bad = 0;\n    char chr1;\n    char chr2;\n    for (int i = start; i < len; i++) {\n        chr1 = seq1.charAt(i);\n        chr2 = seq2.charAt(i);\n        if ('a' <= chr1 && chr1 <= 'z') {\n            // TO UPPERCASE !!!\n            // Faster than toUpperCase\n            chr1 -= caseShift;\n        }\n        if ('a' <= chr2 && chr2 <= 'z') {\n            // TO UPPERCASE !!!\n            // Faster than toUpperCase\n            chr2 -= caseShift;\n        }\n        if (chr1 != chr2 && !isGap(chr1) && !isGap(chr2)) {\n            bad++;\n        }\n    }\n    return ((float) 100 * (len - bad)) / len;\n}", "repo_id": "9", "comment": "// Another pid with region specification\n", "repo_name": "biojava-master/", "id": 101, "method_signature": "float PID(String, String, int, int)"}, "1755": {"callee_method_names": [], "method_name": "MismatchedBasePairParameters.setMaxShear", "method_implementation": "{\n    this.maxShear = maxShear;\n}", "repo_id": "9", "comment": "/**\n * This method sets the maximum shear allowed for a base pair, prior to analyze() call\n * @param maxShear The maximum shear (in \u00c5) allowed to consider two bases paired\n */\n", "repo_name": "biojava-master/", "id": 1755, "method_signature": "void setMaxShear(double)"}, "606": {"callee_method_ids": [489], "callee_method_names": ["AFPChain.getOptAln", "AFPChain.getBlockRotationMatrix", "AFPChain.getBlockShiftVector"], "method_name": "AlignmentTools.deleteHighestDistanceColumn", "method_implementation": "{\n    int[][][] optAln = afpChain.getOptAln();\n    int maxBlock = 0;\n    int maxPos = 0;\n    double maxDistance = Double.MIN_VALUE;\n    for (int b = 0; b < optAln.length; b++) {\n        for (int p = 0; p < optAln[b][0].length; p++) {\n            Atom ca2clone = ca2[optAln[b][1][p]];\n            Calc.rotate(ca2clone, afpChain.getBlockRotationMatrix()[b]);\n            Calc.shift(ca2clone, afpChain.getBlockShiftVector()[b]);\n            double distance = Calc.getDistance(ca1[optAln[b][0][p]], ca2clone);\n            if (distance > maxDistance) {\n                maxBlock = b;\n                maxPos = p;\n                maxDistance = distance;\n            }\n        }\n    }\n    return deleteColumn(afpChain, ca1, ca2, maxBlock, maxPos);\n}", "repo_id": "9", "comment": "/**\n * Find the alignment position with the highest atomic distance between the\n * equivalent atomic positions of the arrays and remove it from the\n * alignment.\n *\n * @param afpChain\n *            original alignment, will be modified\n * @param ca1\n *            atom array, will not be modified\n * @param ca2\n *            atom array, will not be modified\n * @return the original alignment, with the alignment position at the\n *         highest distance removed\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 606, "method_signature": "AFPChain deleteHighestDistanceColumn(AFPChain, Atom[], Atom[])"}, "507": {"callee_method_names": [], "method_name": "AFPChain.getTMScore", "method_implementation": "{\n    return tmScore;\n}", "repo_id": "9", "comment": "/**\n * Returns the tmScore of the alignment. If the score has not been calcualted yet,\n * returns -1. To calculate it call AFPChainScorer.getTMScore(afpChain, ca1, ca2);\n *\n * @return -1, if not calculated, or the TM-score, a score between 0 and 1\n */\n", "repo_name": "biojava-master/", "id": 507, "method_signature": "double getTMScore()"}, "2203": {"callee_method_names": ["ResidueNumber.getInsCode"], "method_name": "ResidueNumberTest.testGetSetInsCode", "method_implementation": "{\n    //        System.out.println(\"getInsCode\");\n    ResidueNumber instance = new ResidueNumber(\"A\", 42, ' ');\n    Character expResult = ' ';\n    Character result = instance.getInsCode();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of getInsCode method, of class ResidueNumber.\n */\n", "repo_name": "biojava-master/", "id": 2203, "method_signature": "void testGetSetInsCode()"}, "752": {"callee_method_names": [], "method_name": "CeParameters.isShowAFPRanges", "method_implementation": "{\n    return showAFPRanges;\n}", "repo_id": "9", "comment": "/**\n * @return whether information about AFPs should be printed\n */\n", "repo_name": "biojava-master/", "id": 752, "method_signature": "boolean isShowAFPRanges()"}, "226": {"callee_method_names": [], "method_name": "ProteinModificationImpl.setPsimodName", "method_implementation": "{\n    this.psimodName = psimodName;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the PSI-MOD name.\n * @param psimodName PSI-MOD name.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 226, "method_signature": "Builder setPsimodName(String)"}, "1498": {"callee_method_names": ["SuperPositionQuat.setCentered", "SuperPositionQuat.superposeAndTransform"], "method_name": "SuperPositions.superposeAndTransform", "method_implementation": "{\n    superposer.setCentered(false);\n    return superposer.superposeAndTransform(fixed, moved);\n}", "repo_id": "9", "comment": "/**\n * Use the {@link SuperPosition#superposeAndTransform(Point3d[], Point3d[])}\n * method of the default static SuperPosition algorithm contained in this\n * Class.\n */\n", "repo_name": "biojava-master/", "id": 1498, "method_signature": "Matrix4d superposeAndTransform(Point3d[], Point3d[])"}, "3293": {"callee_method_names": [], "method_name": "MultipleAlignmentCoordManager.getAligSeq", "method_implementation": "{\n    for (int pos = 0; pos < alignmentSize; pos++) {\n        int i = getSeqPos(pos, point);\n        Point t = getPanelPos(pos, i);\n        if (Math.abs(t.x - point.x) <= DEFAULT_CHAR_SIZE && Math.abs(t.y - point.y) < DEFAULT_CHAR_SIZE)\n            return pos;\n    }\n    return -1;\n}", "repo_id": "9", "comment": "/**\n * Returns the index of the structure, for a given point in the Panel.\n * Returns -1 if not over a position in the sequence alignment.\n * @param point x and y coordinates in the panel\n * @return which structure a point on the panel corresponds to\n */\n", "repo_name": "biojava-master/", "id": 3293, "method_signature": "int getAligSeq(Point)"}, "1783": {"callee_method_names": [], "method_name": "PDBHeader.setJournalArticle", "method_implementation": "{\n    this.journalArticle = journalArticle;\n}", "repo_id": "9", "comment": "/**\n * Set the associated publication as defined by the JRNL records in a PDB\n * file.\n * @param journalArticle the article\n */\n", "repo_name": "biojava-master/", "id": 1783, "method_signature": "void setJournalArticle(JournalArticle)"}, "727": {"callee_method_names": [], "method_name": "CECalculator.getRotationMatrix", "method_implementation": "{\n    return r;\n}", "repo_id": "9", "comment": "/**\n * Gets the rotation matrix from the last call to\n * {@link #calc_rmsd(Atom[], Atom[], int, boolean) calc_rmsd}.\n * @return The rotatiokn matrix\n */\n", "repo_name": "biojava-master/", "id": 727, "method_signature": "Matrix getRotationMatrix()"}, "888": {"callee_method_ids": [840, 842, 843, 840, 842, 843], "callee_method_names": ["Map<ResidueNumber, GroupAsa>.values", "GroupAsa.getAsaU", "GroupAsa.getBsa", "GroupAsa.getBsaToAsaRatio", "List<Group>.add", "GroupAsa.getGroup", "Map<ResidueNumber, GroupAsa>.values", "GroupAsa.getAsaU", "GroupAsa.getBsa", "GroupAsa.getBsaToAsaRatio", "List<Group>.add", "GroupAsa.getGroup"], "method_name": "StructureInterface.getRimResidues", "method_implementation": "{\n    List<Group> rim1 = new ArrayList<>();\n    List<Group> rim2 = new ArrayList<>();\n    for (GroupAsa groupAsa : groupAsas1.values()) {\n        if (groupAsa.getAsaU() > minAsaForSurface && groupAsa.getBsa() > 0) {\n            if (groupAsa.getBsaToAsaRatio() < bsaToAsaCutoff) {\n                rim1.add(groupAsa.getGroup());\n            } else {\n                //core1.add(groupAsa.getGroup());\n            }\n        }\n    }\n    for (GroupAsa groupAsa : groupAsas2.values()) {\n        if (groupAsa.getAsaU() > minAsaForSurface && groupAsa.getBsa() > 0) {\n            if (groupAsa.getBsaToAsaRatio() < bsaToAsaCutoff) {\n                rim2.add(groupAsa.getGroup());\n            } else {\n                //core2.add(groupAsa.getGroup());\n            }\n        }\n    }\n    return new Pair<List<Group>>(rim1, rim2);\n}", "repo_id": "9", "comment": "/**\n * Returns the residues belonging to the interface rim, defined as those residues at\n * the interface (BSA>0) and for which the BSA/ASA ratio is below the given bsaToAsaCutoff\n * @param bsaToAsaCutoff\n * @param minAsaForSurface the minimum ASA to consider a residue on the surface\n * @return\n */\n", "repo_name": "biojava-master/", "id": 888, "method_signature": "Pair<List<Group>> getRimResidues(double, double)"}, "994": {"callee_method_names": ["Chain.getId"], "method_name": "HetatomImpl.getChainId", "method_implementation": "{\n    if (parent == null) {\n        return \"\";\n    }\n    return parent.getId();\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 994, "method_signature": "String getChainId()"}, "1914": {"callee_method_names": [], "method_name": "QuatSymmetryParameters.useLocalTimeLimit", "method_implementation": "{\n    this.localTimeStart = localTimeStart;\n}", "repo_id": "9", "comment": "/**\n * @param localTimeStart\n *            the time when local calculations started\n */\n", "repo_name": "biojava-master/", "id": 1914, "method_signature": "void useLocalTimeLimit(double)"}, "1848": {"callee_method_names": [], "method_name": "QuatSymmetryDetector.calcGlobalSymmetry", "method_implementation": "{\n    return calcQuatSymmetry(composition, symmParams);\n}", "repo_id": "9", "comment": "/**\n * Calculate GLOBAL symmetry results. This means that all {@link Subunit}\n * are included in the symmetry.\n *\n * @param composition\n *            {@link Stoichiometry} object that contains clustering results\n * @param symmParams\n *            quaternary symmetry parameters\n * @return GLOBAL quaternary structure symmetry results\n */\n", "repo_name": "biojava-master/", "id": 1848, "method_signature": "QuatSymmetryResults calcGlobalSymmetry(Stoichiometry, QuatSymmetryParameters)"}, "1302": {"callee_method_names": ["Logger.error"], "method_name": "EntityFinder.getDNASequence", "method_implementation": "{\n    try {\n        DNASequence s = new DNASequence(str);\n        return s;\n    } catch (CompoundNotFoundException e) {\n        logger.error(\"Unexpected error when creating DNASequence \", e);\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Returns the DNASequence or null if one can't be created\n * @param str\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1302, "method_signature": "DNASequence getDNASequence(String)"}, "2690": {"callee_method_names": ["Sequence<C>.getCompoundSet", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "AbstractEdit.getTargetSequence", "method_implementation": "{\n    if (sequence == null && stringSequence != null) {\n        try {\n            sequence = new BasicSequence<C>(stringSequence, editingSequence.getCompoundSet());\n        } catch (CompoundNotFoundException e) {\n            // TODO is there a better way to handle this exception?\n            logger.error(\"Problem setting sequence, some unrecognised compounds: {}\", e.getMessage());\n        }\n    }\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Returns the Sequence which is our edit.\n *\n * @param editingSequence Asked for in-case we need to do String to\n * Sequence conversion so we need a CompoundSet which is given\n * by the Sequence we are editing\n * @return The Sequence<C> object we wish to insert\n */\n", "repo_name": "biojava-master/", "id": 2690, "method_signature": "Sequence<C> getTargetSequence(Sequence)"}, "3649": {"callee_method_names": ["LinkedHashMap.put", "LinkedHashMap.put"], "method_name": "SurvivalInfo.addContinuousVariable", "method_implementation": "{\n    originalMetaData.put(variable, value + \"\");\n    data.put(variable, value);\n}", "repo_id": "9", "comment": "/**\n * @param variable\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 3649, "method_signature": "void addContinuousVariable(String, Double)"}, "3015": {"callee_method_names": [], "method_name": "AbstractReference.getTitle", "method_implementation": "{\n    return title;\n}", "repo_id": "9", "comment": "/**\n * The title that retrieved from the Reference section.\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3015, "method_signature": "String getTitle()"}, "909": {"callee_method_ids": [873], "callee_method_names": ["List<StructureInterface>.removeIf", "StructureInterface.getTotalArea", "List<StructureInterfaceCluster>.removeIf"], "method_name": "StructureInterfaceList.removeInterfacesBelowArea", "method_implementation": "{\n    list.removeIf(interf -> interf.getTotalArea() < area);\n    if (clustersNcs != null) {\n        clustersNcs.removeIf(ncsCluster -> ncsCluster.getMembers().get(0).getTotalArea() < area);\n    }\n}", "repo_id": "9", "comment": "/**\n * Removes from this interface list all interfaces with areas\n * below the given cutoff area.\n * Note that this must be called after {@link #calcAsas(int, int, int)}, otherwise all areas would\n * be 0 and thus all removed.\n * @param area the minimum interface buried surface area to keep. Interfaces below this value will be removed.\n */\n", "repo_name": "biojava-master/", "id": 909, "method_signature": "void removeInterfacesBelowArea(double)"}, "480": {"callee_method_names": [], "method_name": "AFPChain.invalidate", "method_implementation": "{\n    myResultsEQR = -1;\n    myResultsSimilarity1 = -1;\n    myResultsSimilarity2 = -1;\n    identity = -1;\n    similarity = -1;\n}", "repo_id": "9", "comment": "/**\n * Resets properties which can be calculated on the fly\n */\n", "repo_name": "biojava-master/", "id": 480, "method_signature": "void invalidate()"}, "1318": {"callee_method_names": [], "method_name": "FileParsingParameters.setHeaderOnly", "method_implementation": "{\n    this.headerOnly = headerOnly;\n}", "repo_id": "9", "comment": "/**\n * Parse only the PDB file header out of the files\n *\n * @param headerOnly flag\n */\n", "repo_name": "biojava-master/", "id": 1318, "method_signature": "void setHeaderOnly(boolean)"}, "2634": {"callee_method_names": [], "method_name": "ProteinSequence.setParentDNASequence", "method_implementation": "{\n    this.setParentSequence(parentDNASequence);\n    setBioBegin(begin);\n    setBioEnd(end);\n}", "repo_id": "9", "comment": "//However, due to the derivation of this class, this is the only possible type argument for this parameter...\n", "repo_name": "biojava-master/", "id": 2634, "method_signature": "void setParentDNASequence(AbstractSequence, Integer, Integer)"}, "3179": {"callee_method_names": [], "method_name": "ChromosomeSequence.setChromosomeNumber", "method_implementation": "{\n    this.chromosomeNumber = chromosomeNumber;\n}", "repo_id": "9", "comment": "/**\n * @param chromosomeNumber the chromosomeNumber to set\n */\n", "repo_name": "biojava-master/", "id": 3179, "method_signature": "void setChromosomeNumber(int)"}, "746": {"callee_method_names": [], "method_name": "CeParameters.getWinSize", "method_implementation": "{\n    return winSize;\n}", "repo_id": "9", "comment": "/**\n * The window size to look at\n *\n * @return window size\n */\n", "repo_name": "biojava-master/", "id": 746, "method_signature": "Integer getWinSize()"}, "3484": {"callee_method_names": ["BlastProgramEnum.name"], "method_name": "NCBIQBlastAlignmentProperties.setBlastProgram", "method_implementation": "{\n    if (BlastProgramEnum.megablast != program) {\n        setAlignmentOption(PROGRAM, program.name());\n        removeAlignmentOption(MEGABLAST);\n    } else {\n        setAlignmentOption(PROGRAM, BlastProgramEnum.blastn.name());\n        setAlignmentOption(MEGABLAST, \"on\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Sets the program to be used with blastall\n *\n * @param program : one of blastall programs\n */\n", "repo_name": "biojava-master/", "id": 3484, "method_signature": "void setBlastProgram(BlastProgramEnum)"}, "1540": {"callee_method_names": ["Logger.info", "BufferedReader.readLine", "String.startsWith", "String.split", "Set<String>.add", "Logger.debug", "LinkedHashMap<Integer, String>.put", "Logger.warn", "BufferedReader.close", "BufferedReader.close", "Logger.warn"], "method_name": "Astral.init", "method_implementation": "{\n    names = new TreeSet<String>();\n    failedLines = new LinkedHashMap<Integer, String>();\n    BufferedReader br = null;\n    try {\n        br = new BufferedReader(reader);\n        logger.info(\"Reading ASTRAL file...\");\n        String line = \"\";\n        int i = 0;\n        while ((line = br.readLine()) != null) {\n            if (line.startsWith(\">\")) {\n                try {\n                    String scopId = line.split(\"\\\\s\")[0].substring(1);\n                    names.add(scopId);\n                    if (i % 1000 == 0) {\n                        logger.debug(\"Reading ASTRAL line for {}\", scopId);\n                    }\n                    i++;\n                } catch (RuntimeException e) {\n                    failedLines.put(i, line);\n                    logger.warn(\"Couldn't read line \" + line, e);\n                }\n            }\n        }\n        br.close();\n    } catch (IOException e) {\n        throw new RuntimeException(\"Couldn't read the input stream \", e);\n    } finally {\n        if (br != null) {\n            try {\n                br.close();\n            } catch (IOException e) {\n                logger.warn(\"Could not close stream\", e);\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Parses the FASTA file opened by reader.\n */\n", "repo_name": "biojava-master/", "id": 1540, "method_signature": "void init(Reader)"}, "165": {"callee_method_ids": [1330], "callee_method_names": ["FileParsingParameters.setCreateAtomBonds", "PDBFileReader.setFileParsingParameters", "PDBFileReader.getStructureById", "Structure.getPolyChain", "Group.getAtom", "Atom.getBonds", "Structure.getNonPolyChain", "Group.getAtom"], "method_name": "TestBondParsing.testIssue943", "method_implementation": "{\n    PDBFileReader reader = new PDBFileReader();\n    FileParsingParameters params = new FileParsingParameters();\n    params.setCreateAtomBonds(true);\n    reader.setFileParsingParameters(params);\n    Structure s = reader.getStructureById(\"1v9i\");\n    Group his95 = s.getPolyChain(\"A\").getAtomGroup(94);\n    Atom ne2His95 = his95.getAtom(\"NE2\");\n    assertEquals(3, ne2His95.getBonds().size());\n    Group zn = s.getNonPolyChain(\"B\").getAtomGroup(0);\n    assertEquals(3, zn.getAtom(\"ZN\").getBonds().size());\n}", "repo_id": "9", "comment": "/**\n * Integration test for bond parsing in PDB-format, where author chain ids and asym ids differ and can cause\n * problems. See https://github.com/biojava/biojava/issues/943\n */\n", "repo_name": "biojava-master/", "id": 165, "method_signature": "void testIssue943()"}, "414": {"callee_method_ids": [431, 484], "callee_method_names": ["AFPChain.getConn", "AFPChain.getDVar", "FatCatParameters.getMisScore", "FatCatParameters.getMaxPenalty", "FatCatParameters.getDisCut", "FatCatParameters.getGapExtend", "FatCatParameters.getTorsionPenalty", "FatCatParameters.getDisSmooth", "AFPChain.getAfpSet", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "List<AFP>.get", "AFPChain.setConn", "AFPChain.setDVar"], "method_name": "AFPChainer.afpPairConn", "method_implementation": "{\n    Double conn = afpChain.getConn();\n    Double dvar = afpChain.getDVar();\n    double misScore = params.getMisScore();\n    double maxPenalty = params.getMaxPenalty();\n    double disCut = params.getDisCut();\n    double gapExtend = params.getGapExtend();\n    double torsionPenalty = params.getTorsionPenalty();\n    double disSmooth = params.getDisSmooth();\n    List<AFP> afpSet = afpChain.getAfpSet();\n    int m = calcGap(afpSet.get(afp2), afpSet.get(afp1));\n    int g = calcMismatch(afpSet.get(afp2), afpSet.get(afp1));\n    //on average, penalty for a mismatch is misScore, no modification on score\n    double gp = misScore * m;\n    if (g > 0) {\n        gp += gapExtend * g;\n    }\n    //penalty cut-off\n    if (gp < maxPenalty)\n        gp = maxPenalty;\n    //note: use < (smaller) instead of >, because maxPenalty is a negative number\n    double d;\n    d = calAfpDis(afp1, afp2, params, afpChain);\n    //note: the 'dis' value is numerically equivalent to the 'rms' with exceptions\n    boolean ch = false;\n    double tp = 0.0;\n    if (d >= disCut) {\n        tp = torsionPenalty;\n        ch = true;\n    } else //use the variation of the distances between AFPs\n    if (d > disCut - disSmooth) {\n        double wt = Math.sqrt((d - disCut + disSmooth) / disSmooth);\n        //using sqrt: penalty increase with dis more quicker than linear function\n        tp = torsionPenalty * wt;\n    }\n    dvar = d;\n    conn = tp + gp;\n    afpChain.setConn(conn);\n    afpChain.setDVar(dvar);\n    return ch;\n}", "repo_id": "9", "comment": "/**\n * \t//Key function: calculate the connectivity of AFP pairs\n * \t//no compatibility criteria is executed\n * \t//note: afp1 is previous to afp2 in terms of the position\n * \t\t //this module must be optimized\n *\n *  @param afp1\n *  @param afp2\n *  @return flag if they are connected\n */\n", "repo_name": "biojava-master/", "id": 414, "method_signature": "boolean afpPairConn(int, int, FatCatParameters, AFPChain)"}, "555": {"callee_method_names": ["Object.getClass"], "method_name": "AFPChainScorer.resizeArray", "method_implementation": "{\n    int oldSize = java.lang.reflect.Array.getLength(oldArray);\n    @SuppressWarnings(\"rawtypes\")\n    Class elementType = oldArray.getClass().getComponentType();\n    Object newArray = java.lang.reflect.Array.newInstance(elementType, newSize);\n    int preserveLength = Math.min(oldSize, newSize);\n    if (preserveLength > 0)\n        System.arraycopy(oldArray, 0, newArray, 0, preserveLength);\n    return newArray;\n}", "repo_id": "9", "comment": "/**\n * Reallocates an array with a new size, and copies the contents\n * of the old array to the new array.\n * @param oldArray  the old array, to be reallocated.\n * @param newSize   the new array size.\n * @return          A new array with the same contents.\n */\n", "repo_name": "biojava-master/", "id": 555, "method_signature": "Object resizeArray(Object, int)"}, "1571": {"callee_method_names": [], "method_name": "Site.getGroups", "method_implementation": "{\n    return groups;\n}", "repo_id": "9", "comment": "/**\n * @return the groups\n */\n", "repo_name": "biojava-master/", "id": 1571, "method_signature": "List<Group> getGroups()"}, "285": {"callee_method_names": [], "method_name": "ProteinModificationIdentifier.setbondLengthTolerance", "method_implementation": "{\n    if (bondLengthTolerance < 0) {\n        throw new IllegalArgumentException(\"bondLengthTolerance \" + \"must be positive.\");\n    }\n    this.bondLengthTolerance = bondLengthTolerance;\n}", "repo_id": "9", "comment": "/**\n * @param bondLengthTolerance tolerance of error (in Angstroms) of the\n *  covalent bond length, when calculating the atom distance threshold.\n */\n", "repo_name": "biojava-master/", "id": 285, "method_signature": "void setbondLengthTolerance(double)"}, "3555": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "CoxVariables.getCoxInfo", "method_implementation": "{\n    return coxInfoHashMap.get(name);\n}", "repo_id": "9", "comment": "/**\n * @param name\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3555, "method_signature": "CoxInfo getCoxInfo(String)"}, "2318": {"callee_method_ids": [1627, 1631, 1662, 1662, 1663, 1663, 1666, 1666, 1666, 1666, 1662, 1663, 1666, 1666], "callee_method_names": ["Structure.getChainByIndex", "Structure.getChainByIndex", "Structure.getChainByIndex", "Structure.getChainByIndex", "SubunitClustererParameters.setRMSDThreshold", "SubunitClustererParameters.setStructureCoverageThreshold", "SubunitCluster.mergeStructure", "SubunitCluster.mergeStructure", "SubunitCluster.size", "SubunitCluster.size", "SubunitCluster.length", "SubunitCluster.length", "SubunitCluster.getAlignedAtomsSubunit", "SubunitCluster.getAlignedAtomsSubunit", "SubunitCluster.getAlignedAtomsSubunit", "SubunitCluster.getAlignedAtomsSubunit", "SubunitCluster.mergeStructure", "SubunitCluster.size", "SubunitCluster.length", "SubunitCluster.getAlignedAtomsSubunit", "SubunitCluster.getAlignedAtomsSubunit"], "method_name": "TestSubunitCluster.testMergeStructure", "method_implementation": "{\n    Structure s = StructureIO.getStructure(\"4hhb\");\n    // Create one SubunitCluster for each chain\n    SubunitCluster sc1 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(0)), \"chain 0\", null, s));\n    SubunitCluster sc2 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(1)), \"chain 1\", null, s));\n    SubunitCluster sc3 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(2)), \"chain 2\", null, s));\n    SubunitCluster sc4 = new SubunitCluster(new Subunit(StructureTools.getRepresentativeAtomArray(s.getChainByIndex(3)), \"chain 3\", null, s));\n    // Clusters 1 and 3 and 2 and 4 are identical\n    SubunitClustererParameters clustererParameters = new SubunitClustererParameters();\n    clustererParameters.setRMSDThreshold(3.0);\n    clustererParameters.setStructureCoverageThreshold(0.9);\n    boolean merged13 = sc1.mergeStructure(sc3, clustererParameters);\n    boolean merged24 = sc2.mergeStructure(sc4, clustererParameters);\n    // Merged have to be true, and the merged SubunitCluster is sc1\n    assertTrue(merged13);\n    assertTrue(merged24);\n    assertEquals(2, sc1.size());\n    assertEquals(2, sc2.size());\n    assertEquals(141, sc1.length());\n    assertEquals(146, sc2.length());\n    assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(1).length);\n    assertEquals(sc2.getAlignedAtomsSubunit(0).length, sc2.getAlignedAtomsSubunit(1).length);\n    // Now test for pseudosymmetry\n    boolean merged = sc1.mergeStructure(sc2, clustererParameters);\n    assertTrue(merged);\n    assertEquals(4, sc1.size());\n    assertEquals(140, sc1.length(), 2);\n    assertEquals(sc1.getAlignedAtomsSubunit(0).length, sc1.getAlignedAtomsSubunit(2).length);\n}", "repo_id": "9", "comment": "/**\n * Test\n * {@link SubunitCluster#mergeStructure(SubunitCluster, SubunitClustererParameters)}\n *\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2318, "method_signature": "void testMergeStructure()"}, "2905": {"callee_method_names": [], "method_name": "AbstractSequence.setUserCollection", "method_implementation": "{\n    this.userCollection = userCollection;\n}", "repo_id": "9", "comment": "/**\n * @param userCollection\n */\n", "repo_name": "biojava-master/", "id": 2905, "method_signature": "void setUserCollection(Collection)"}, "844": {"callee_method_names": ["Group.getType", "HashMap<Character, Double>.get"], "method_name": "GroupAsa.getRelativeAsaU", "method_implementation": "{\n    if (!g.getType().equals(GroupType.AMINOACID))\n        throw new IllegalArgumentException(\"Can not calculate relative ASA for non amino-acid\");\n    char aa = ((AminoAcid) g).getAminoType();\n    return (asaU / tripeptAsa.get(aa));\n}", "repo_id": "9", "comment": "/**\n * Returns the relative (uncomplexed) ASA, i.e. the ASA of the residue\n * with respect to its ASA in an extended tri-peptide conformation (GLY-x-GLY)\n * @return\n */\n", "repo_name": "biojava-master/", "id": 844, "method_signature": "double getRelativeAsaU()"}, "3864": {"callee_method_names": ["Logger.error", "int.getMessage", "IPeptideProperties.getInstabilityIndex"], "method_name": "PeptideProperties.getInstabilityIndex", "method_implementation": "{\n    sequence = Utils.checkSequence(sequence);\n    ProteinSequence pSequence = null;\n    try {\n        pSequence = new ProteinSequence(sequence);\n    } catch (CompoundNotFoundException e) {\n        // the sequence was checked with Utils.checkSequence, this shouldn't happen\n        logger.error(\"The protein sequence contains invalid characters ({}), this should not happen. This is most likely a bug in Utils.checkSequence()\", e.getMessage());\n    }\n    IPeptideProperties pp = new PeptidePropertiesImpl();\n    return pp.getInstabilityIndex(pSequence);\n}", "repo_id": "9", "comment": "/**\n * An adaptor method to return the instability index of sequence. The sequence argument must be\n * a protein sequence consisting of only non-ambiguous characters.\n * The instability index provides an estimate of the stability of your\n * protein in a test tube. The computation of instability index follows the\n * documentation in <a href=\"http://web.expasy.org/protparam/protparam-doc.html\">here</a>.\n *\n * @param sequence\n * \t\ta protein sequence consisting of non-ambiguous characters only\n * @return the instability index of sequence\n */\n", "repo_name": "biojava-master/", "id": 3864, "method_signature": "double getInstabilityIndex(String)"}, "3790": {"callee_method_ids": [3605, 3515, 3520, 3524, 3520, 3615, 3535, 3536, 3537, 3538], "callee_method_names": ["CoxInfo.getSurvivalInfoList", "StrataInfo.getOriginalMetaData", "LinkedHashMap<String,String>.get", "LinkedHashMap<String, ArrayList<CensorStatus>>.get", "LinkedHashMap<String, ArrayList<CensorStatus>>.put", "StrataInfo.getTime", "StrataInfo.getStatus", "StrataInfo.getWeight", "ArrayList<CensorStatus>.add", "StrataInfo.getStatus", "CoxInfo.getCoefficient", "CoxCoefficient.getHazardRatio", "CoxCoefficient.getHazardRatioLoCI", "CoxCoefficient.getHazardRatioHiCI", "CoxCoefficient.getPvalue", "ArrayList<String>.add", "ArrayList<String>.add", "ArrayList<String>.add"], "method_name": "KaplanMeierFigure.setCoxInfo", "method_implementation": "{\n    LinkedHashMap<String, ArrayList<CensorStatus>> survivalData = new LinkedHashMap<String, ArrayList<CensorStatus>>();\n    ArrayList<SurvivalInfo> siList = ci.getSurvivalInfoList();\n    int n = 0;\n    int event = 0;\n    for (SurvivalInfo si : siList) {\n        String strata = si.getOriginalMetaData(strataVariable);\n        String legend = legendMap.get(strata);\n        if (legend == null) {\n            legend = strata;\n        }\n        ArrayList<CensorStatus> censorStatusList = survivalData.get(legend);\n        if (censorStatusList == null) {\n            censorStatusList = new ArrayList<CensorStatus>();\n            survivalData.put(legend, censorStatusList);\n        }\n        CensorStatus cs = new CensorStatus(strata, si.getTime(), si.getStatus() + \"\");\n        cs.weight = si.getWeight();\n        censorStatusList.add(cs);\n        n++;\n        if (si.getStatus() == 1) {\n            event++;\n        }\n    }\n    setSurvivalData(title, survivalData, useWeighted);\n    CoxCoefficient cc = ci.getCoefficient(strataVariable);\n    //DecimalFormat df = new DecimalFormat(\"#.##\");\n    String line1 = \"HR=\" + fmt(cc.getHazardRatio(), 2, 0) + \" (CI:\" + fmt(cc.getHazardRatioLoCI(), 2, 0) + \"-\" + fmt(cc.getHazardRatioHiCI(), 2, 0) + \")\";\n    String line2 = \"p=\" + fmt(cc.getPvalue(), 3, 0);\n    // String line2 = \"logrank P=\" + fmt(ci.getScoreLogrankTestpvalue(), 3, 0);\n    String line3 = \"n=\" + n + \" events=\" + event;\n    //        System.out.println(\"setCoxInfo=\" + cc.pvalue + \" \" + title);\n    ArrayList<String> lines = new ArrayList<String>();\n    lines.add(line1);\n    lines.add(line2);\n    lines.add(line3);\n    setFigureLineInfo(lines);\n}", "repo_id": "9", "comment": "/**\n * @param title Title of figures\n * @param ci\n * @param strataVariable The column that based on value will do a figure\n * line\n * @param legendMap Map the value in the column to something readable\n * @param useWeighted\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3790, "method_signature": "void setCoxInfo(ArrayList, CoxInfo, String, LinkedHashMap, Boolean)"}, "450": {"callee_method_names": ["MultipleAlignment.getBlockSet"], "method_name": "QsAlignResult.getTransform", "method_implementation": "{\n    if (alignment == null)\n        return null;\n    return alignment.getBlockSet(0).getTransformations().get(1);\n}", "repo_id": "9", "comment": "/**\n * The transformation 4D matrix that needs to be applied to the second group\n * of Subunits to superimpose them onto the first group of Subunits, given\n * the equivalent residues in the SubunitCluster and the Subunit\n * equivalencies.\n * <p>\n * This is equivalent to\n * multipleAlignment.getBlockSet(0).getTransformations().get(1).\n *\n * @return Matrix4d\n */\n", "repo_name": "biojava-master/", "id": 450, "method_signature": "Matrix4d getTransform()"}, "3457": {"callee_method_names": ["BlastOutputAlignmentFormatEnum.name"], "method_name": "NCBIQBlastOutputProperties.setAlignmentOutputFormat", "method_implementation": "{\n    setOutputOption(ALIGNMENT_VIEW, alignmentFormat.name());\n}", "repo_id": "9", "comment": "/**\n * Sets the alignment output format to get from the QBlast service\n *\n * @param alignmentFormat : one of available alignment types\n */\n", "repo_name": "biojava-master/", "id": 3457, "method_signature": "void setAlignmentOutputFormat(BlastOutputAlignmentFormatEnum)"}, "2280": {"callee_method_names": ["Group.getAtoms"], "method_name": "TestHeaderOnly.hasAtoms", "method_implementation": "{\n    if (g.getAtoms().size() > 0)\n        return true;\n    return false;\n}", "repo_id": "9", "comment": "/**\n * Does a group have any Atom(s)?\n *\n * @param g : a group\n * @return true if has any Atom(s)\n */\n", "repo_name": "biojava-master/", "id": 2280, "method_signature": "boolean hasAtoms(Group)"}, "350": {"callee_method_names": [], "method_name": "Calc.amount", "method_implementation": "{\n    return Math.sqrt(scalarProduct(a, a));\n}", "repo_id": "9", "comment": "/**\n * Gets the length of the vector (2-norm)\n *\n * @param a\n *            an Atom object\n * @return Square root of the sum of the squared elements\n */\n", "repo_name": "biojava-master/", "id": 350, "method_signature": "double amount(Atom)"}, "1128": {"callee_method_names": [], "method_name": "LocalPDBDirectory.getFetchBehavior", "method_implementation": "{\n    return fetchBehavior;\n}", "repo_id": "9", "comment": "/**\n * Get the behavior for fetching files from the server\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1128, "method_signature": "FetchBehavior getFetchBehavior()"}, "2163": {"callee_method_names": [], "method_name": "StructureImpl.setPDBCode", "method_implementation": "{\n    if (pdb_id == null) {\n        this.pdbId = null;\n    } else {\n        pdbId = new PdbId(pdb_id);\n    }\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n * @deprecated use {@link #setPDBCode(PdbId)}\n */\n", "repo_name": "biojava-master/", "id": 2163, "method_signature": "void setPDBCode(String)"}, "2927": {"callee_method_names": ["List<FeatureInterface<AbstractSequence<C>, C>>.add", "LinkedHashMap.get", "FeatureInterface<AbstractSequence<C>,C>.getType", "LinkedHashMap.put", "FeatureInterface<AbstractSequence<C>,C>.getType", "ArrayList<FeatureInterface<AbstractSequence<C>, C>>.add"], "method_name": "AbstractSequence.addFeature", "method_implementation": "{\n    features.add(feature);\n    ArrayList<FeatureInterface<AbstractSequence<C>, C>> featureList = groupedFeatures.get(feature.getType());\n    if (featureList == null) {\n        featureList = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n        groupedFeatures.put(feature.getType(), featureList);\n    }\n    featureList.add(feature);\n    Collections.sort(features, AbstractFeature.LOCATION_LENGTH);\n    Collections.sort(featureList, AbstractFeature.LOCATION_LENGTH);\n}", "repo_id": "9", "comment": "/**\n * Add a feature to this sequence. The feature will be added to the collection where the order is start position and if more than\n * one feature at the same start position then longest is added first. This helps on doing feature layout for displaying features\n * in SequenceFeaturePanel\n * @param feature\n */\n", "repo_name": "biojava-master/", "id": 2927, "method_signature": "void addFeature(FeatureInterface)"}, "2108": {"callee_method_names": [], "method_name": "Axis.getSymmType", "method_implementation": "{\n    return symmType;\n}", "repo_id": "9", "comment": "/**\n * @return the symmType (OPEN or CLOSED only)\n */\n", "repo_name": "biojava-master/", "id": 2108, "method_signature": "SymmetryType getSymmType()"}, "2661": {"callee_method_names": [], "method_name": "Builder.stopAtStopCodons", "method_implementation": "{\n    this.stopAtStopCodons = stopAtStopCodons;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * If set, then the last codon translated in the resulting peptide\n * sequence will be the stop codon\n */\n", "repo_name": "biojava-master/", "id": 2661, "method_signature": "Builder stopAtStopCodons(boolean)"}, "298": {"callee_method_names": ["Set<ProteinModification>.isEmpty", "Chain.getAtomGroups", "List<Group>.addAll", "List<Group>.removeAll", "List<Group>.addAll", "List<Group>.isEmpty", "List<Chain>.size", "List<Chain>.get", "Structure.getPDBCode", "Logger.warn", "ModificationCondition.getComponents", "Map<Component, Set<Group>>.keySet", "List<Component>.size", "Set<ModifiedCompound>.addAll"], "method_name": "ProteinModificationIdentifier.identify", "method_implementation": "{\n    if (chains == null) {\n        throw new IllegalArgumentException(\"Null structure.\");\n    }\n    if (potentialModifications == null) {\n        throw new IllegalArgumentException(\"Null potentialModifications.\");\n    }\n    reset();\n    if (potentialModifications.isEmpty()) {\n        return;\n    }\n    residues = new ArrayList<Group>();\n    List<Group> ligands = new ArrayList<Group>();\n    Map<Component, Set<Group>> mapCompGroups = new HashMap<Component, Set<Group>>();\n    for (Chain chain : chains) {\n        List<Group> ress = StructureUtil.getAminoAcids(chain);\n        //List<Group> ligs = chain.getAtomLigands();\n        List<Group> ligs = StructureTools.filterLigands(chain.getAtomGroups());\n        residues.addAll(ress);\n        residues.removeAll(ligs);\n        ligands.addAll(ligs);\n        addModificationGroups(potentialModifications, ress, ligs, mapCompGroups);\n    }\n    if (residues.isEmpty()) {\n        String pdbId = \"?\";\n        if (chains.size() > 0) {\n            Structure struc = chains.get(0).getStructure();\n            if (struc != null)\n                pdbId = struc.getPDBCode();\n        }\n        logger.warn(\"No amino acids found for {}. Either you did not parse the PDB file with alignSEQRES records, or this record does not contain any amino acids.\", pdbId);\n    }\n    List<ModifiedCompound> modComps = new ArrayList<ModifiedCompound>();\n    for (ProteinModification mod : potentialModifications) {\n        ModificationCondition condition = mod.getCondition();\n        List<Component> components = condition.getComponents();\n        if (!mapCompGroups.keySet().containsAll(components)) {\n            // not all components exist for this mod.\n            continue;\n        }\n        int sizeComps = components.size();\n        if (sizeComps == 1) {\n            processCrosslink1(mapCompGroups, modComps, mod, components);\n        } else {\n            processMultiCrosslink(mapCompGroups, modComps, mod, condition);\n        }\n    }\n    if (recordAdditionalAttachments) {\n        // identify additional groups that are not directly attached to amino acids.\n        for (ModifiedCompound mc : modComps) {\n            identifyAdditionalAttachments(mc, ligands, chains);\n        }\n    }\n    mergeModComps(modComps);\n    identifiedModifiedCompounds.addAll(modComps);\n    // record unidentifiable linkage\n    if (recordUnidentifiableModifiedCompounds) {\n        recordUnidentifiableAtomLinkages(modComps, ligands);\n        recordUnidentifiableModifiedResidues(modComps);\n    }\n}", "repo_id": "9", "comment": "/**\n * Identify a set of modifications in a a list of chains.\n * @param chains query {@link Chain}s.\n * @param potentialModifications query {@link ProteinModification}s.\n */\n", "repo_name": "biojava-master/", "id": 298, "method_signature": "void identify(List, Set)"}, "770": {"callee_method_names": [], "method_name": "StartupParameters.setPdbFilePath", "method_implementation": "{\n    this.pdbFilePath = pdbFilePath;\n}", "repo_id": "9", "comment": "/**\n * mandatory argument to set the location of PDB files.\n *\n * @param pdbFilePath\n */\n", "repo_name": "biojava-master/", "id": 770, "method_signature": "void setPdbFilePath(String)"}, "1487": {"callee_method_names": ["Matrix4d.transform"], "method_name": "CalcPoint.transform", "method_implementation": "{\n    for (Point3d p : x) {\n        rotTrans.transform(p);\n    }\n}", "repo_id": "9", "comment": "/**\n * Transform all points with a 4x4 transformation matrix.\n *\n * @param rotTrans\n *            4x4 transformation matrix\n * @param x\n *            array of points. Point objects will be modified\n */\n", "repo_name": "biojava-master/", "id": 1487, "method_signature": "void transform(Matrix4d, Point3d[])"}, "3289": {"callee_method_names": [], "method_name": "MultipleAlignmentCoordManager.getPreferredWidth", "method_implementation": "{\n    return alignmentSize * DEFAULT_X_SPACE + DEFAULT_LINE_LENGTH * DEFAULT_CHAR_SIZE + DEFAULT_LEGEND_SIZE + DEFAULT_RIGHT_SPACER + DEFAULT_LEGEND_SIZE;\n}", "repo_id": "9", "comment": "/**\n * X coordinate size\n *\n * @return the preferred width\n */\n", "repo_name": "biojava-master/", "id": 3289, "method_signature": "int getPreferredWidth()"}, "1382": {"callee_method_names": [], "method_name": "DBRef.getDbSeqBegin", "method_implementation": "{\n    return dbSeqBegin;\n}", "repo_id": "9", "comment": "/**\n *  Initial sequence number of the\n * \tdatabase seqment.\n *  @return position\n *  @see #setDbSeqBegin(int)\n */\n", "repo_name": "biojava-master/", "id": 1382, "method_signature": "int getDbSeqBegin()"}, "1747": {"callee_method_names": [], "method_name": "TertiaryBasePairParameters.getMaxStagger", "method_implementation": "{\n    return maxStagger;\n}", "repo_id": "9", "comment": "/**\n * This method returns the maximum stagger between bases used as criteria for the characterization of two bases as being paired.\n * @return the maximum stagger (in \u00c5) allowed.\n */\n", "repo_name": "biojava-master/", "id": 1747, "method_signature": "double getMaxStagger()"}, "3044": {"callee_method_names": [], "method_name": "LocationHelper.location", "method_implementation": "{\n    int min = Math.min(start, end);\n    //if this is true then we have a coord on the +ve strand even though Strand could be negative\n    boolean isReverse = (min != start);\n    if (isReverse) {\n        return new SimpleLocation(new SimplePoint(start).reverse(length), new SimplePoint(end).reverse(length), strand);\n    }\n    return new SimpleLocation(start, end, strand);\n}", "repo_id": "9", "comment": "/**\n * Returns a location object which unlike the location constructors\n * allows you to input reverse coordinates and will convert\n * these into the right location on the positive strand.\n */\n", "repo_name": "biojava-master/", "id": 3044, "method_signature": "Location location(int, int, Strand, int)"}, "3643": {"callee_method_names": ["LinkedHashMap.put"], "method_name": "SurvivalInfo.setResidualVariable", "method_implementation": "{\n    residualVariableMap.put(variable, value);\n}", "repo_id": "9", "comment": "/**\n * Set the residual value for the variable for this sample. Called from CoxScore.java\n * @param variable\n * @param value\n */\n", "repo_name": "biojava-master/", "id": 3643, "method_signature": "void setResidualVariable(String, Double)"}, "3544": {"callee_method_names": [], "method_name": "CoxCoefficient.setRobustStdError", "method_implementation": "{\n    this.robustStdError = robustStdError;\n}", "repo_id": "9", "comment": "/**\n * @param robustStdError the robustStdError to set\n */\n", "repo_name": "biojava-master/", "id": 3544, "method_signature": "void setRobustStdError(double)"}, "1325": {"callee_method_names": [], "method_name": "FileParsingParameters.setMaxAtoms", "method_implementation": "{\n    this.maxAtoms = maxAtoms;\n}", "repo_id": "9", "comment": "/**\n * The maximum numbers of atoms to load in a protein structure (prevents memory overflows)\n *\n * @param maxAtoms maximun nr of atoms to load\n */\n", "repo_name": "biojava-master/", "id": 1325, "method_signature": "void setMaxAtoms(int)"}, "535": {"callee_method_names": [], "method_name": "AlignUtils.getDiagonalAtK", "method_implementation": "{\n    int l = atoms.length;\n    double[] dk = new double[(l - k)];\n    for (int i = 0; i < (l - k); i++) {\n        double dist = Calc.getDistance(atoms[i], atoms[i + k]);\n        dk[i] = dist;\n    }\n    return dk;\n}", "repo_id": "9", "comment": "/**\n * Get distances along diagonal k from coordinate array coords.\n *\n * @param atoms set of atoms to be used\n * @param k number of diagonal to be used\n */\n", "repo_name": "biojava-master/", "id": 535, "method_signature": "double[] getDiagonalAtK(Atom[], int)"}, "62": {"callee_method_names": [], "method_name": "AbstractMatrixAligner.isLocal", "method_implementation": "{\n    return local;\n}", "repo_id": "9", "comment": "/**\n * Returns whether alignment finds a region of similarity rather than aligning every compound.\n *\n * @return true if alignment finds a region of similarity rather than aligning every compound\n */\n", "repo_name": "biojava-master/", "id": 62, "method_signature": "boolean isLocal()"}, "3198": {"callee_method_ids": [2545, 2546], "callee_method_names": ["Hsp.getAlignment", "StringBuilder.append", "Hsp.getHspQseq", "StringBuilder.append", "StringBuilder.append", "Hsp.getHspHseq", "StringBuilder.append", "StringBuilder.toString", "SequencePair<DNASequence, NucleotideCompound>.toString"], "method_name": "HspTest.testGetAlignment", "method_implementation": "{\n    System.out.println(\"getAlignment\");\n    SequencePair<DNASequence, NucleotideCompound> aln = hspImpl.getAlignment();\n    StringBuilder s = new StringBuilder();\n    s.append(hspImpl.getHspQseq());\n    s.append(String.format(\"%n\"));\n    s.append(hspImpl.getHspHseq());\n    s.append(String.format(\"%n\"));\n    String expResult = s.toString();\n    String result = aln.toString();\n    assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of getAlignment method, of class Hsp.\n */\n", "repo_name": "biojava-master/", "id": 3198, "method_signature": "void testGetAlignment()"}, "643": {"callee_method_ids": [467, 466, 466], "callee_method_names": ["CathDatabase.getDomainByCathId", "StructureName.getIdentifier", "CathDomain.getIdentifier", "CathDomain.reduce", "Structure.getPolyChainByPDB", "StructureName.getChainId", "Structure.getNonPolyChainsByPDB", "StructureName.getChainId", "Chain.getAtomGroups", "Chain.addGroup"], "method_name": "AtomCache.getStructureForCathDomain", "method_implementation": "{\n    CathDomain cathDomain = cathInstall.getDomainByCathId(structureName.getIdentifier());\n    Structure s = getStructureForPdbId(cathDomain.getIdentifier());\n    Structure n = cathDomain.reduce(s);\n    // add the ligands of the chain...\n    Chain newChain = n.getPolyChainByPDB(structureName.getChainId());\n    List<Chain> origChains = s.getNonPolyChainsByPDB(structureName.getChainId());\n    for (Chain origChain : origChains) {\n        List<Group> ligands = origChain.getAtomGroups();\n        for (Group g : ligands) {\n            if (!newChain.getAtomGroups().contains(g)) {\n                newChain.addGroup(g);\n            }\n        }\n    }\n    return n;\n}", "repo_id": "9", "comment": "/**\n * Returns a {@link Structure} corresponding to the CATH identifier supplied in {@code structureName}, using the specified {@link CathDatabase}.\n */\n", "repo_name": "biojava-master/", "id": 643, "method_signature": "Structure getStructureForCathDomain(StructureName, CathDatabase)"}, "1938": {"callee_method_names": [], "method_name": "QuatSymmetryScores.getMinRmsd", "method_implementation": "{\n    return minRmsd;\n}", "repo_id": "9", "comment": "/**\n * @return the minRmsd\n */\n", "repo_name": "biojava-master/", "id": 1938, "method_signature": "double getMinRmsd()"}, "2447": {"callee_method_names": ["StringBuilder.append", "FeatureI.seqname", "FeatureI.toString", "StringBuilder.append", "StringBuilder.toString"], "method_name": "FeatureList.toString", "method_implementation": "{\n    StringBuilder s = new StringBuilder(\"FeatureList: >>\\n\");\n    for (FeatureI f : this) {\n        s.append(f.seqname() + \":\" + f.toString() + \"\\n\");\n    }\n    s.append(\"\\n<<\\n\");\n    return s.toString();\n}", "repo_id": "9", "comment": "/**\n * Return a string representation of all features in this list.\n *\n * @return A string.\n */\n", "repo_name": "biojava-master/", "id": 2447, "method_signature": "String toString()"}, "1786": {"callee_method_names": [], "method_name": "PDBHeader.getRwork", "method_implementation": "{\n    return rWork;\n}", "repo_id": "9", "comment": "/**\n * @return the R-work for this structure.\n */\n", "repo_name": "biojava-master/", "id": 1786, "method_signature": "float getRwork()"}, "2991": {"callee_method_names": [], "method_name": "BitSequenceReader.bitsPerCompound", "method_implementation": "{\n    return BYTES_PER_INT / compoundsPerDatatype();\n}", "repo_id": "9", "comment": "/**\n * Returns how many bits are used to represent a compound e.g. 2 if using\n * 2bit encoding.\n */\n", "repo_name": "biojava-master/", "id": 2991, "method_signature": "int bitsPerCompound()"}, "456": {"callee_method_names": ["Map<Integer,Integer>.size", "Map<Integer,Integer>.keySet", "List<Subunit>.add", "List<Subunit>.get"], "method_name": "QsAlignResult.getAlignedSubunits1", "method_implementation": "{\n    List<Subunit> aligned = new ArrayList<>(subunitMap.size());\n    for (Integer key : subunitMap.keySet()) aligned.add(subunits1.get(key));\n    return aligned;\n}", "repo_id": "9", "comment": "/**\n * Return the aligned subunits of the first Subunit group, in the alignment\n * order.\n *\n * @return a List of Subunits in the alignment order\n */\n", "repo_name": "biojava-master/", "id": 456, "method_signature": "List<Subunit> getAlignedSubunits1()"}, "1558": {"callee_method_names": ["Object.getClass", "ScopCategory.equals", "String.equals", "String.equals"], "method_name": "ScopDescription.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null) {\n        return false;\n    }\n    if (getClass() != obj.getClass()) {\n        return false;\n    }\n    ScopDescription other = (ScopDescription) obj;\n    if (category == null) {\n        if (other.category != null) {\n            return false;\n        }\n    } else if (!category.equals(other.category)) {\n        return false;\n    }\n    if (classificationId == null) {\n        if (other.classificationId != null) {\n            return false;\n        }\n    } else if (!classificationId.equals(other.classificationId)) {\n        return false;\n    }\n    if (name == null) {\n        if (other.name != null) {\n            return false;\n        }\n    } else if (!name.equals(other.name)) {\n        return false;\n    }\n    return sunID == other.sunID;\n}", "repo_id": "9", "comment": "/**\n * Compares the fields sunID, category, classificationId, and name for equality\n *\n * @param obj\n * @return\n * @see java.lang.Object#equals(java.lang.Object)\n */\n", "repo_name": "biojava-master/", "id": 1558, "method_signature": "boolean equals(Object)"}, "2866": {"callee_method_names": [], "method_name": "ABITrace.transmute", "method_implementation": "{\n    return (height - 45 - (int) (ya * scale));\n}", "repo_id": "9", "comment": "/**\n * Utility method to translate y coordinates from graph space (where up is greater)\n * to image space (where down is greater).\n *\n * @param ya\n * @param height\n * @param scale\n * @return - translated y coordinates from graph space (where up is greater) to image space\n */\n", "repo_name": "biojava-master/", "id": 2866, "method_signature": "int transmute(int, int, double)"}, "3710": {"callee_method_names": ["HashMap.clear", "ArrayList<String>.size", "ArrayList<Integer>.add", "ArrayList<String>.size", "ArrayList<String>.get", "ArrayList<Integer>.get", "ArrayList<String>.get"], "method_name": "WorkSheet.shuffleColumnValues", "method_implementation": "{\n    doubleValues.clear();\n    ArrayList<String> rows = this.getDataRows();\n    for (String column : columns) {\n        //shuffle all values in the column\n        ArrayList<Integer> rowIndex = new ArrayList<Integer>();\n        for (int i = 0; i < rows.size(); i++) {\n            rowIndex.add(i);\n        }\n        Collections.shuffle(rowIndex);\n        for (int i = 0; i < rows.size(); i++) {\n            String row = rows.get(i);\n            int randomIndex = rowIndex.get(i);\n            String destinationRow = rows.get(randomIndex);\n            String temp = this.getCell(destinationRow, column);\n            String value = this.getCell(row, column);\n            this.addCell(destinationRow, column, value);\n            this.addCell(row, column, temp);\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Need to shuffle column values to allow for randomized testing. The\n * columns in the list will be shuffled together\n *\n * @param columns\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3710, "method_signature": "void shuffleColumnValues(ArrayList)"}, "3080": {"callee_method_names": [], "method_name": "AbstractFeature.setLocation", "method_implementation": "{\n    sequenceLocation = loc;\n}", "repo_id": "9", "comment": "/**\n *  A feature could be a single sequence position like a mutation or a post translational modification of an amino acid.\n * It could also be the docking interface of N number of amino acids on the surface. The location wold then be a collection\n * of sequence positions instead of a single sequence position or the begin and end of a sequence segment.\n * @param loc\n */\n", "repo_name": "biojava-master/", "id": 3080, "method_signature": "void setLocation(AbstractLocation)"}, "3204": {"callee_method_names": ["BlastXMLParser.getFileExtensions", "List<String>.contains"], "method_name": "BlastXMLParserTest.testGetFileExtensions", "method_implementation": "{\n    System.out.println(\"getFileExtensions\");\n    BlastXMLParser instance = new BlastXMLParser();\n    List<String> result = instance.getFileExtensions();\n    assertTrue(result.contains(\"blastxml\"));\n}", "repo_id": "9", "comment": "/**\n * Test of getFileExtensions method, of class BlastXMLParser.\n */\n", "repo_name": "biojava-master/", "id": 3204, "method_signature": "void testGetFileExtensions()"}, "2379": {"callee_method_ids": [2385, 2380], "callee_method_names": ["TwoBitParser.close", "TwoBitParser.setCurrentSequence", "TwoBitParser.loadFragment"], "method_name": "TwoBitFacade.getSequence", "method_implementation": "{\n    twoBitParser.close();\n    twoBitParser.setCurrentSequence(chromosomeName);\n    return twoBitParser.loadFragment(start, end - start);\n}", "repo_id": "9", "comment": "/**\n * Extract a sequence from a chromosome, using chromosomal coordinates\n *\n * @param chromosomeName\n * @param start\n * @param end\n * @return the DNASequence from the requested coordinates.\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 2379, "method_signature": "String getSequence(String, int, int)"}, "1391": {"callee_method_names": [], "method_name": "DBRef.setInsertEnd", "method_implementation": "{\n    this.insertEnd = insertEnd;\n}", "repo_id": "9", "comment": "/**\n * Ending insertion code of the PDB sequence segment.\n *\n * @param insertEnd insertEnd\n * @see #getInsertEnd()\n */\n", "repo_name": "biojava-master/", "id": 1391, "method_signature": "void setInsertEnd(char)"}, "736": {"callee_method_ids": [760], "callee_method_names": ["CeParameters.getSubstitutionMatrix", "ScaledSubstitutionMatrix.getScale", "Matrix.getRowDimension", "Matrix.getColumnDimension", "Matrix.get", "AminoAcidCompoundSet.getCompoundForString", "Atom.getGroup", "AminoAcidCompoundSet.getCompoundForString", "Atom.getGroup", "SubstitutionMatrix<AminoAcidCompound>.getValue", "CeParameters.getSeqWeight", "Matrix.set", "Matrix.getArray"], "method_name": "CeCalculatorEnhanced.updateMatrixWithSequenceConservation", "method_implementation": "{\n    Matrix origM = new Matrix(max);\n    SubstitutionMatrix<AminoAcidCompound> substMatrix = params.getSubstitutionMatrix();\n    int internalScale = 1;\n    if (substMatrix instanceof ScaledSubstitutionMatrix) {\n        ScaledSubstitutionMatrix scaledMatrix = (ScaledSubstitutionMatrix) substMatrix;\n        internalScale = scaledMatrix.getScale();\n    }\n    AminoAcidCompoundSet set = AminoAcidCompoundSet.getAminoAcidCompoundSet();\n    for (int i = 0; i < origM.getRowDimension(); i++) {\n        for (int j = 0; j < origM.getColumnDimension(); j++) {\n            double val = origM.get(i, j);\n            Atom a1 = ca1[i];\n            Atom a2 = ca2[j];\n            AminoAcidCompound ac1 = set.getCompoundForString(a1.getGroup().getChemComp().getOneLetterCode());\n            AminoAcidCompound ac2 = set.getCompoundForString(a2.getGroup().getChemComp().getOneLetterCode());\n            if (ac1 == null || ac2 == null)\n                continue;\n            short aaScore = substMatrix.getValue(ac1, ac2);\n            double weightedScore = (aaScore / internalScale) * params.getSeqWeight();\n            val += weightedScore;\n            origM.set(i, j, val);\n        }\n    }\n    max = origM.getArray();\n    //SymmetryTools.showMatrix((Matrix)origM.clone(), \"in optimizer \"  + loopCount  );\n    //SymmetryTools.showMatrix(origM, \"iteration  matrix \" + loopCount + \" after\");\n    return max;\n}", "repo_id": "9", "comment": "/**\n * Modifies an alignment matrix by favoring the alignment of similar and identical amino acids and penalizing the alignment of unrelated ones.\n *\n * @param max alignment matrix\n * @param ca1 Atoms for protein 1\n * @param ca2 Atoms for Protein 2\n * @param params alignment parameters\n * @return modified alignment matrix\n */\n", "repo_name": "biojava-master/", "id": 736, "method_signature": "double[][] updateMatrixWithSequenceConservation(double[][], Atom[], Atom[], CeParameters)"}, "1022": {"callee_method_names": ["Atom[].getGroup", "Group.getChain", "Chain.getStructure", "Set<Chain>.addAll", "Structure.getChains", "Atom.getGroup", "Set<Group>.add", "Group.getChain", "Set<Chain>.add", "Chain.getAtomGroups", "Set<Group>.contains", "List<Group>.add"], "method_name": "StructureTools.getUnalignedGroups", "method_implementation": "{\n    Set<Chain> chains = new HashSet<>();\n    Set<Group> caGroups = new HashSet<>();\n    // Create list of all chains in this structure\n    Structure s = null;\n    if (ca.length > 0) {\n        Group g = ca[0].getGroup();\n        if (g != null) {\n            Chain c = g.getChain();\n            if (c != null) {\n                s = c.getStructure();\n            }\n        }\n    }\n    if (s != null) {\n        // Add all chains from the structure\n        chains.addAll(s.getChains(0));\n    }\n    // Add groups and chains from ca\n    for (Atom a : ca) {\n        Group g = a.getGroup();\n        if (g != null) {\n            caGroups.add(g);\n            Chain c = g.getChain();\n            if (c != null) {\n                chains.add(c);\n            }\n        }\n    }\n    // Iterate through all chains, finding groups not in ca\n    List<Group> unadded = new ArrayList<>();\n    for (Chain c : chains) {\n        for (Group g : c.getAtomGroups()) {\n            if (!caGroups.contains(g)) {\n                unadded.add(g);\n            }\n        }\n    }\n    return unadded;\n}", "repo_id": "9", "comment": "/**\n * List of groups from the structure not included in ca (e.g. ligands).\n *\n * Unaligned groups are searched from all chains referenced in ca, as well\n * as any chains in the first model of the structure from ca[0], if any.\n *\n * @param ca an array of atoms\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1022, "method_signature": "List<Group> getUnalignedGroups(Atom[])"}, "2035": {"callee_method_names": [], "method_name": "Icosahedron.getMidRadius", "method_implementation": "{\n    double side = getSideLengthFromCircumscribedRadius(circumscribedRadius);\n    return getMiddleRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a sphere, that is tangent to each\n * of the icosahedron's edges\n *\n * @return the midRadius\n */\n", "repo_name": "biojava-master/", "id": 2035, "method_signature": "double getMidRadius()"}, "325": {"callee_method_names": ["File.exists", "Dataset.downloadFile"], "method_name": "TestAcetylation.setUp", "method_implementation": "{\n    Dataset ds = new Dataset();\n    String f = Dataset.ACETYLATION;\n    File localFile = getLocalFileName(f);\n    if (!localFile.exists()) {\n        ds.downloadFile(new URL(f), localFile);\n    }\n}", "repo_id": "9", "comment": "/**\n * Make sure an Acetylation file is available locally.\n * Downloads from Phosphosite if needed.\n */\n", "repo_name": "biojava-master/", "id": 325, "method_signature": "void setUp()"}, "2615": {"callee_method_names": ["ThreadPoolExecutor.awaitTermination", "ThreadPoolExecutor.shutdownNow", "ThreadPoolExecutor.awaitTermination", "Logger.warn", "ThreadPoolExecutor.shutdownNow"], "method_name": "ConcurrencyTools.shutdownAndAwaitTermination", "method_implementation": "{\n    shutdown();\n    if (pool != null) {\n        try {\n            // wait a while for existing tasks to terminate\n            if (!pool.awaitTermination(60L, TimeUnit.SECONDS)) {\n                // cancel currently executing tasks\n                pool.shutdownNow();\n                // wait a while for tasks to respond to being canceled\n                if (!pool.awaitTermination(60L, TimeUnit.SECONDS)) {\n                    logger.warn(\"BioJava ConcurrencyTools thread pool did not terminate\");\n                }\n            }\n        } catch (InterruptedException ie) {\n            // (re-)cancel if current thread also interrupted\n            pool.shutdownNow();\n            // preserve interrupt status\n            Thread.currentThread().interrupt();\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Closes the thread pool.  Waits 1 minute for a clean exit; if necessary, waits another minute for cancellation.\n */\n", "repo_name": "biojava-master/", "id": 2615, "method_signature": "void shutdownAndAwaitTermination()"}, "2477": {"callee_method_names": ["GeneChromosomePosition.getOrientation"], "method_name": "ChromosomeMappingTools.formatExonStructure", "method_implementation": "{\n    if (chromosomePosition.getOrientation() == '+')\n        return formatExonStructureForward(chromosomePosition);\n    return formatExonStructureReverse(chromosomePosition);\n}", "repo_id": "9", "comment": "/**\n * Pretty print the details of a GeneChromosomePosition to a String\n *\n * @param chromosomePosition\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2477, "method_signature": "String formatExonStructure(GeneChromosomePosition)"}, "3411": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGeneratorH.getOrientationName", "method_implementation": "{\n    switch(index) {\n        case 0:\n            return \"Side\";\n        case 1:\n            return \"Front\";\n        case 2:\n            return \"Other side\";\n        case 3:\n            return \"Back\";\n        default:\n            return \"\";\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the name of a specific orientation\n * @param index orientation index\n * @return name of orientation\n */\n", "repo_name": "biojava-master/", "id": 3411, "method_signature": "String getOrientationName(int)"}, "2303": {"callee_method_ids": [1322, 641, 1438, 911, 903, 905, 911, 909, 905, 905, 911, 883, 874], "callee_method_names": ["FileParsingParameters.setAlignSeqRes", "AtomCache.setFileParsingParams", "AtomCache.setFiletype", "CrystalBuilder.getUniqueInterfaces", "StructureInterfaceList.getClusters", "List<StructureInterfaceCluster>.size", "StructureInterfaceList.size", "StructureInterfaceList.calcAsas", "StructureInterface.getId", "StructureInterfaceList.getClustersNcs", "List<StructureInterfaceCluster>.add", "StructureInterfaceList.getClusters", "List<StructureInterfaceCluster>.size", "StructureInterfaceList.size", "StructureInterfaceList.removeInterfacesBelowArea", "StructureInterfaceList.getClustersNcs", "StructureInterfaceList.getClustersNcs", "StructureInterfaceList.size", "StructureInterfaceList.getClusters", "List<StructureInterfaceCluster>.size", "StructureInterfaceList.size", "StructureInterface.getFirstGroupAsas", "StructureInterface.getMoleculeIds", "GroupAsa.getGroup", "String.charAt", "String.charAt"], "method_name": "TestInterfaceClustering.test1AUY", "method_implementation": "{\n    // 1AUY is a viral capsid with NCS ops\n    AtomCache cache = new AtomCache();\n    FileParsingParameters params = new FileParsingParameters();\n    params.setAlignSeqRes(true);\n    cache.setFileParsingParams(params);\n    cache.setFiletype(StructureFiletype.CIF);\n    StructureIO.setAtomCache(cache);\n    // 3vbr would be an example of capsids with several chains\n    Structure s = StructureIO.getStructure(\"1auy\");\n    Map<String, String> chainOrigNames = new HashMap<>();\n    Map<String, Matrix4d> chainNcsOps = new HashMap<>();\n    CrystalBuilder.expandNcsOps(s, chainOrigNames, chainNcsOps);\n    CrystalBuilder cb = new CrystalBuilder(s, chainOrigNames, chainNcsOps);\n    StructureInterfaceList interfaces = cb.getUniqueInterfaces(5.5);\n    List<StructureInterfaceCluster> clusters = interfaces.getClusters();\n    assertNotNull(clusters);\n    assertTrue(clusters.size() <= interfaces.size());\n    interfaces.calcAsas(100, 1, 0);\n    // after calculating ASAs we should have ids for all interfaces\n    for (StructureInterface interf : interfaces) {\n        assertTrue(interf.getId() > 0);\n    }\n    int numInterfacesShouldbeKept = 0;\n    List<StructureInterfaceCluster> ncsClusterShouldbeKept = new ArrayList<>();\n    for (StructureInterfaceCluster ncsCluster : interfaces.getClustersNcs()) {\n        if (ncsCluster.getMembers().get(0).getTotalArea() >= StructureInterfaceList.DEFAULT_MINIMUM_INTERFACE_AREA) {\n            //System.out.println(\"NCS cluster is above cutoff area and has \"+ncsCluster.getMembers().size()+ \" members\");\n            ncsClusterShouldbeKept.add(ncsCluster);\n            numInterfacesShouldbeKept += ncsCluster.getMembers().size();\n        }\n    }\n    clusters = interfaces.getClusters();\n    assertNotNull(clusters);\n    assertTrue(clusters.size() <= interfaces.size());\n    interfaces.removeInterfacesBelowArea();\n    assertNotNull(interfaces.getClustersNcs());\n    // making sure that removeInterfacesBelowArea does not throw away the members for which area wasn't calculated\n    for (StructureInterfaceCluster ncsCluster : ncsClusterShouldbeKept) {\n        assertTrue(interfaces.getClustersNcs().contains(ncsCluster));\n    }\n    assertEquals(numInterfacesShouldbeKept, interfaces.size());\n    clusters = interfaces.getClusters();\n    assertNotNull(clusters);\n    assertTrue(clusters.size() <= interfaces.size());\n    for (StructureInterface interf : interfaces) {\n        GroupAsa groupAsa = interf.getFirstGroupAsas().values().iterator().next();\n        String expected = interf.getMoleculeIds().getFirst();\n        String actual = groupAsa.getGroup().getChain().getName();\n        // in 1auy this works always since there's only 1 chain. But it is useful in testing cases like 3vbr with serveral chains\n        assertEquals(expected.charAt(0), actual.charAt(0));\n    }\n}", "repo_id": "9", "comment": "/**\n * Test for NCS clustering in viral capsid structures that contain NCS operators.\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2303, "method_signature": "void test1AUY()"}, "2865": {"callee_method_names": ["BufferedImage.createGraphics", "String.toCharArray", "Graphics2D.setBackground", "Graphics2D.clearRect", "Graphics2D.setColor", "Graphics2D.drawLine", "Graphics2D.setColor", "Graphics2D.drawLine", "Graphics2D.setColor", "Graphics2D.drawLine", "Graphics2D.setColor", "Graphics2D.drawLine", "Graphics2D.drawLine", "Graphics2D.drawLine", "Graphics2D.drawString", "Graphics2D.setColor", "Graphics2D.setColor", "Graphics2D.setColor", "Graphics2D.setColor", "Graphics2D.setColor", "Graphics2D.drawChars", "Graphics2D.setColor"], "method_name": "ABITrace.getImage", "method_implementation": "{\n    BufferedImage out = new BufferedImage(traceLength * widthScale, imageHeight, BufferedImage.TYPE_BYTE_INDEXED);\n    Graphics2D g = out.createGraphics();\n    Color acolor = Color.green.darker();\n    Color ccolor = Color.blue;\n    Color gcolor = Color.black;\n    Color tcolor = Color.red;\n    Color ncolor = Color.pink;\n    double scale = calculateScale(imageHeight);\n    int[] bc = baseCalls;\n    char[] seq = sequence.toCharArray();\n    g.setBackground(Color.white);\n    g.clearRect(0, 0, traceLength * widthScale, imageHeight);\n    int here = 0;\n    int basenum = 0;\n    for (int q = 1; q <= 5; q++) {\n        for (int x = 0; x <= traceLength - 2; x++) {\n            if (q == 1) {\n                g.setColor(acolor);\n                g.drawLine(widthScale * x, transmute(A[x], imageHeight, scale), widthScale * (x + 1), transmute(A[x + 1], imageHeight, scale));\n            }\n            if (q == 2) {\n                g.setColor(ccolor);\n                g.drawLine(widthScale * x, transmute(C[x], imageHeight, scale), widthScale * (x + 1), transmute(C[x + 1], imageHeight, scale));\n            }\n            if (q == 3) {\n                g.setColor(tcolor);\n                g.drawLine(widthScale * x, transmute(T[x], imageHeight, scale), widthScale * (x + 1), transmute(T[x + 1], imageHeight, scale));\n            }\n            if (q == 4) {\n                g.setColor(gcolor);\n                g.drawLine(widthScale * x, transmute(G[x], imageHeight, scale), widthScale * (x + 1), transmute(G[x + 1], imageHeight, scale));\n            }\n            if (q == 5) {\n                if ((here > bc.length - 1) || (basenum > seq.length - 1))\n                    break;\n                if (bc[here] == x) {\n                    g.drawLine(widthScale * x, transmute(-2, imageHeight, 1.0), widthScale * x, transmute(-7, imageHeight, 1.0));\n                    if (//if the basecount is divisible by ten\n                    (basenum + 1) % 10 == 0) //add a number\n                    {\n                        g.drawLine(widthScale * x, transmute(-20, imageHeight, 1.0), widthScale * x, transmute(-25, imageHeight, 1.0));\n                        g.drawString(Integer.toString(basenum + 1), widthScale * x - 3, transmute(-36, imageHeight, 1.0));\n                    }\n                    switch(seq[basenum]) {\n                        case 'A':\n                        case 'a':\n                            g.setColor(acolor);\n                            break;\n                        case 'C':\n                        case 'c':\n                            g.setColor(ccolor);\n                            break;\n                        case 'G':\n                        case 'g':\n                            g.setColor(gcolor);\n                            break;\n                        case 'T':\n                        case 't':\n                            g.setColor(tcolor);\n                            break;\n                        default:\n                            g.setColor(ncolor);\n                    }\n                    g.drawChars(seq, basenum, 1, widthScale * x - 3, transmute(-18, imageHeight, 1.0));\n                    g.setColor(Color.black);\n                    here++;\n                    basenum++;\n                }\n            }\n        }\n    }\n    return out;\n}", "repo_id": "9", "comment": "/**\n * Returns a BufferedImage that represents the entire trace. The height can be set precisely in\n * pixels, the width in pixels is determined by the scaling factor times the number\n * of points in the trace (<code>getTraceLength()</code>). The entire trace is represented\n * in the returned image.\n *\n * @param imageHeight - desired height of the image in pixels.\n * @param widthScale - how many horizontal pixels to use to represent a single x-coordinate (try 2).\n * @return BufferedImage image\n */\n", "repo_name": "biojava-master/", "id": 2865, "method_signature": "BufferedImage getImage(int, int)"}, "2826": {"callee_method_names": ["AbstractSequence<AminoAcidCompound>.getLength", "AbstractSequence<AminoAcidCompound>.getLength", "Collection<Object>.add", "AbstractSequence<AminoAcidCompound>.setUserCollection"], "method_name": "CasePreservingProteinSequenceCreator.getSequence", "method_implementation": "{\n    AbstractSequence<AminoAcidCompound> seq = super.getSequence(list);\n    Collection<Object> strCase = new ArrayList<Object>(seq.getLength());\n    for (int i = 0; i < seq.getLength(); i++) {\n        strCase.add(true);\n    }\n    seq.setUserCollection(strCase);\n    return seq;\n}", "repo_id": "9", "comment": "/**\n * Assumes all compounds were uppercase\n * @see org.biojava.nbio.core.sequence.io.ProteinSequenceCreator#getSequence(java.util.List)\n */\n", "repo_name": "biojava-master/", "id": 2826, "method_signature": "AbstractSequence<AminoAcidCompound> getSequence(List)"}, "1496": {"callee_method_names": ["SuperPositionQuat.setCentered", "SuperPositionQuat.superpose"], "method_name": "SuperPositions.superpose", "method_implementation": "{\n    superposer.setCentered(false);\n    return superposer.superpose(fixed, moved);\n}", "repo_id": "9", "comment": "/**\n * Use the {@link SuperPosition#superpose(Point3d[], Point3d[])} method of\n * the default static SuperPosition algorithm contained in this Class.\n */\n", "repo_name": "biojava-master/", "id": 1496, "method_signature": "Matrix4d superpose(Point3d[], Point3d[])"}, "2929": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "AbstractSequence.getFeaturesByType", "method_implementation": "{\n    List<FeatureInterface<AbstractSequence<C>, C>> features = groupedFeatures.get(type);\n    if (features == null) {\n        features = new ArrayList<FeatureInterface<AbstractSequence<C>, C>>();\n    }\n    return features;\n}", "repo_id": "9", "comment": "/**\n * @param type\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2929, "method_signature": "List<FeatureInterface<AbstractSequence<C>,C>> getFeaturesByType(String)"}, "41": {"callee_method_names": [], "method_name": "Alignments.getAllPairsScores", "method_implementation": "{\n    return runPairwiseScorers(getAllPairsScorers(sequences, type, gapPenalty, subMatrix));\n}", "repo_id": "9", "comment": "/**\n * Factory method which computes a sequence pair score for all {@link Sequence} pairs in the given {@link List}.\n * This method runs the scorings in parallel by submitting all of the scorings to the shared thread pool of the\n * {@link ConcurrencyTools} utility.\n *\n * @param <S> each {@link Sequence} of a pair is of type S\n * @param <C> each element of a {@link Sequence} is a {@link Compound} of type C\n * @param sequences the {@link List} of {@link Sequence}s to align\n * @param type chosen type from list of pairwise sequence scoring routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return list of sequence pair scores\n */\n", "repo_name": "biojava-master/", "id": 41, "method_signature": "double[] getAllPairsScores(List, PairwiseSequenceScorerType, GapPenalty, SubstitutionMatrix)"}, "2484": {"callee_method_names": ["List<Integer>.size", "List<Integer>.get", "List<Integer>.get"], "method_name": "ChromosomeMappingTools.getCDSLengthForward", "method_implementation": "{\n    int codingLength = 0;\n    for (int i = 0; i < exonStarts.size(); i++) {\n        int start = exonStarts.get(i) + base;\n        int end = exonEnds.get(i);\n        if ((start < cdsStart + base && end < cdsStart) || (start > cdsEnd && end > cdsEnd))\n            continue;\n        if (start < cdsStart + base)\n            start = cdsStart + base;\n        if (end > cdsEnd)\n            end = cdsEnd;\n        codingLength += (end - start + 1);\n    }\n    return codingLength - 3;\n}", "repo_id": "9", "comment": "/**\n * Get the length of the coding sequence\n *\n * @param exonStarts\n * @param exonEnds\n * @param cdsStart\n * @param cdsEnd\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2484, "method_signature": "int getCDSLengthForward(List, List, int, int)"}, "1716": {"callee_method_names": [], "method_name": "ResidueRangeAndLength.getLength", "method_implementation": "{\n    return length;\n}", "repo_id": "9", "comment": "/**\n * @return The number of residues in this ResidueRange\n */\n", "repo_name": "biojava-master/", "id": 1716, "method_signature": "int getLength()"}, "2114": {"callee_method_ids": [1342, 1346, 1349], "callee_method_names": ["Structure.setPdbId", "Structure.setName", "Structure.setPDBHeader", "Structure.setDBRefs", "Structure.setSites", "Chain.setStructure", "List<Chain>.add", "Structure.addModel", "EntityInfo.getChainIds", "Structure.nrModels", "Structure.getChain", "Logger.warn", "EntityInfo.getMolId", "Chain.setEntityInfo", "EntityInfo.addChain", "List<EntityInfo>.add", "Structure.setEntityInfos"], "method_name": "StructureImpl.clone", "method_implementation": "{\n    // Note: structures are also cloned in SubstructureIdentifier.reduce().\n    // Changes might need to be made there as well\n    Structure n = new StructureImpl();\n    // go through whole substructure and clone ...\n    // copy structure data\n    n.setPdbId(getPdbId());\n    n.setName(getName());\n    //TODO the header data is not being deep-copied, that's a minor issue since it is just some static metadata, but we should recheck this if needed - JD 2014-12-11\n    n.setPDBHeader(pdbHeader);\n    n.setDBRefs(this.getDBRefs());\n    n.setSites(getSites());\n    // go through each chain and clone chain\n    for (int i = 0; i < nrModels(); i++) {\n        List<Chain> cloned_model = new ArrayList<Chain>();\n        for (int j = 0; j < size(i); j++) {\n            Chain cloned_chain = (Chain) getChainByIndex(i, j).clone();\n            // setting the parent: can only be done from the parent\n            cloned_chain.setStructure(n);\n            cloned_model.add(cloned_chain);\n        }\n        n.addModel(cloned_model);\n    }\n    // deep-copying of entityInfofos is tricky: there's cross references also in the Chains\n    // beware: if we copy the entityInfos we would also need to reset the references to entityInfos in the individual chains\n    List<EntityInfo> newEntityInfoList = new ArrayList<>();\n    for (EntityInfo entityInfo : this.entityInfos) {\n        // this sets everything but the chains\n        EntityInfo newEntityInfo = new EntityInfo(entityInfo);\n        for (String asymId : entityInfo.getChainIds()) {\n            for (int modelNr = 0; modelNr < n.nrModels(); modelNr++) {\n                Chain newChain = n.getChain(asymId, modelNr);\n                if (newChain == null) {\n                    // this actually happens for structure 1msh, which has no chain B for model 29 (clearly a deposition error)\n                    logger.warn(\"Could not find chain asymId \" + asymId + \" of model \" + modelNr + \" while cloning entityInfo \" + entityInfo.getMolId() + \". Something is wrong!\");\n                    continue;\n                }\n                newChain.setEntityInfo(newEntityInfo);\n                newEntityInfo.addChain(newChain);\n            }\n        }\n        newEntityInfoList.add(newEntityInfo);\n    }\n    n.setEntityInfos(newEntityInfoList);\n    // TODO ssbonds are complicated to clone: there are deep references inside Atom objects, how would we do it? - JD 2016-03-03\n    return n;\n}", "repo_id": "9", "comment": "/**\n * Returns an identical copy of this structure .\n * @return an identical Structure object\n */\n", "repo_name": "biojava-master/", "id": 2114, "method_signature": "Structure clone()"}, "2094": {"callee_method_names": ["List<Axis>.get"], "method_name": "SymmetryAxes.updateAxis", "method_implementation": "{\n    axes.get(index).setOperator(newAxis);\n}", "repo_id": "9", "comment": "/**\n * Updates an axis of symmetry, after the superposition changed.\n *\n * @param index old axis index\n * @param newAxis\n */\n", "repo_name": "biojava-master/", "id": 2094, "method_signature": "void updateAxis(Integer, Matrix4d)"}, "3420": {"callee_method_ids": [1971, 1885, 1884], "callee_method_names": ["HelixAxisAligner.getHelixLayers", "HelixAxisAligner.getSubunits", "QuatSymmetrySubunits.getModelNumbers", "QuatSymmetrySubunits.getChainIds", "QuatSymmetrySubunits.getClusterIds", "QuatSymmetrySubunits.getSubunitCount", "List<List<Integer>>.size", "List<List<Integer>>.get", "List<List<Integer>>.get", "List<Integer>.get", "Color4f.scale", "Map<Color4f, List<String>>.get", "Map<Color4f, List<String>>.put", "List<String>.add"], "method_name": "JmolSymmetryScriptGeneratorH.colorBySymmetry", "method_implementation": "{\n    List<List<Integer>> units = helixAxisAligner.getHelixLayers().getByLargestContacts().getLayerLines();\n    units = orientLayerLines(units);\n    QuatSymmetrySubunits subunits = helixAxisAligner.getSubunits();\n    List<Integer> modelNumbers = subunits.getModelNumbers();\n    List<String> chainIds = subunits.getChainIds();\n    List<Integer> clusterIds = subunits.getClusterIds();\n    int clusterCount = Collections.max(clusterIds) + 1;\n    Map<Color4f, List<String>> colorMap = new HashMap<Color4f, List<String>>();\n    int maxLen = 0;\n    for (List<Integer> unit : units) {\n        maxLen = Math.max(maxLen, unit.size());\n    }\n    //\t\tColor4f[] colors = getSymmetryColors(permutation.size());\n    Color4f[] colors = getSymmetryColors(subunits.getSubunitCount());\n    int count = 0;\n    for (int i = 0; i < maxLen; i++) {\n        for (int j = 0; j < units.size(); j++) {\n            int m = units.get(j).size();\n            if (i < m) {\n                int subunit = units.get(j).get(i);\n                int cluster = clusterIds.get(subunit);\n                float scale = 0.3f + 0.7f * (cluster + 1) / clusterCount;\n                Color4f c = new Color4f(colors[count]);\n                count++;\n                c.scale(scale);\n                List<String> ids = colorMap.get(c);\n                if (ids == null) {\n                    ids = new ArrayList<String>();\n                    colorMap.put(c, ids);\n                }\n                String id = getChainSpecification(modelNumbers, chainIds, subunit);\n                ids.add(id);\n            }\n        }\n    }\n    String coloring = defaultColoring + getJmolColorScript(colorMap);\n    return coloring;\n}", "repo_id": "9", "comment": "/**\n * Returns a Jmol script that colors subunits to highlight the symmetry within a structure\n * Different subunits should have a consistent color scheme or different shade of the same colors\n * @return Jmol script\n */\n", "repo_name": "biojava-master/", "id": 3420, "method_signature": "String colorBySymmetry()"}, "522": {"callee_method_ids": [502], "callee_method_names": ["AFPChain.getAlgorithmName", "AFPChain.setAlgorithmName"], "method_name": "AFPChainXMLParser.flipAlignment", "method_implementation": "{\n    AFPChain[] afps = parseMultiXML(xml);\n    if (afps.length < 1)\n        return null;\n    if (afps.length == 1) {\n        AFPChain newChain = AFPChainFlipper.flipChain(afps[0]);\n        if (newChain.getAlgorithmName() == null) {\n            newChain.setAlgorithmName(DEFAULT_ALGORITHM_NAME);\n        }\n        return AFPChainXMLConverter.toXML(newChain);\n    }\n    throw new StructureException(\"not Implemented yet!\");\n}", "repo_id": "9", "comment": "/**\n * Takes an XML representation of the alignment and flips the positions of name1 and name2\n *\n * @param xml String representing the alignment\n * @return XML representation of the flipped alignment\n */\n", "repo_name": "biojava-master/", "id": 522, "method_signature": "String flipAlignment(String)"}, "1339": {"callee_method_names": ["List<String>.add", "Chain.getId", "Chain.getId", "List<String>.get", "Logger.error"], "method_name": "EntityInfo.getRepresentative", "method_implementation": "{\n    List<String> chainIds = new ArrayList<>();\n    for (Chain chain : chains) {\n        chainIds.add(chain.getId());\n    }\n    Collections.sort(chainIds, String.CASE_INSENSITIVE_ORDER);\n    for (Chain chain : chains) {\n        if (chain.getId().equals(chainIds.get(0))) {\n            return chain;\n        }\n    }\n    logger.error(\"Could not find a representative chain for EntityInfo '{}'\", this.toString());\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Get the representative Chain for this EntityInfo.\n * We choose the Chain with the first asym_id chain identifier after\n * lexicographical sorting (case insensitive),\n * e.g. chain A if EntityInfo is composed of chains A,B,C,D,E\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1339, "method_signature": "Chain getRepresentative()"}, "3383": {"callee_method_names": ["StringBuilder.append", "Quat4d.set", "Polyhedron.getViewMatrix", "Quat4d.normalize", "Quat4d.set", "RotationAxisAligner.getRotationMatrix", "Quat4d.normalize", "Quat4d.mul", "Quat4d.normalize", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "JmolSymmetryScriptGeneratorPointGroup.getDefaultOrientation", "method_implementation": "{\n    StringBuilder s = new StringBuilder();\n    s.append(setCentroid());\n    // calculate  orientation\n    Quat4d q = new Quat4d();\n    q.set(polyhedron.getViewMatrix(0));\n    q.normalize();\n    Quat4d r = new Quat4d();\n    r.set(rotationAxisAligner.getRotationMatrix());\n    r.normalize();\n    q.mul(r);\n    q.normalize();\n    // set orientation\n    s.append(\"moveto 0 quaternion{\");\n    s.append(jMolFloat(q.x));\n    s.append(\",\");\n    s.append(jMolFloat(q.y));\n    s.append(\",\");\n    s.append(jMolFloat(q.z));\n    s.append(\",\");\n    s.append(jMolFloat(q.w));\n    s.append(\"};\");\n    return s.toString();\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#getDefaultOrientation()\n\t */\n", "repo_name": "biojava-master/", "id": 3383, "method_signature": "String getDefaultOrientation()"}, "3171": {"callee_method_ids": [3077], "callee_method_names": ["StringBuilder.append", "CDSSequence.getCodingSequence", "StringBuilder.toString", "Logger.error", "Enumeration<JarEntry>.getMessage", "DNASequence.setAccession"], "method_name": "TranscriptSequence.getDNACodingSequence", "method_implementation": "{\n    StringBuilder sb = new StringBuilder();\n    for (CDSSequence cdsSequence : cdsSequenceList) {\n        sb.append(cdsSequence.getCodingSequence());\n    }\n    DNASequence dnaSequence = null;\n    try {\n        dnaSequence = new DNASequence(sb.toString().toUpperCase());\n    } catch (CompoundNotFoundException e) {\n        // if I understand this should not happen, please correct if I'm wrong - JD 2014-10-24\n        logger.error(\"Could not create DNA coding sequence, {}. This is most likely a bug.\", e.getMessage());\n    }\n    dnaSequence.setAccession(new AccessionID(this.getAccession().getID()));\n    return dnaSequence;\n}", "repo_id": "9", "comment": "/**\n * Get the stitched together CDS sequences then maps to the cDNA\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3171, "method_signature": "DNASequence getDNACodingSequence()"}, "1550": {"callee_method_names": ["Map<Integer, ScopNode>.get"], "method_name": "ScopInstallation.getScopNode", "method_implementation": "{\n    try {\n        ensureHieInstalled();\n    } catch (IOException e) {\n        throw new ScopIOException(e);\n    }\n    return scopTree.get(sunid);\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.scop.ScopDatabase#getScopNode(int)\n\t */\n", "repo_name": "biojava-master/", "id": 1550, "method_signature": "ScopNode getScopNode(int)"}, "3841": {"callee_method_names": ["String.toUpperCase", "String.toCharArray", "Set<Character>.contains"], "method_name": "Utils.getNumberOfInvalidChar", "method_implementation": "{\n    char[] cArray = ignoreCase ? sequence.toUpperCase().toCharArray() : sequence.toCharArray();\n    final Set<Character> characterSet = cSet == null ? PeptideProperties.standardAASet : cSet;\n    int total = (int) CharBuffer.wrap(cArray).chars().filter(character -> !characterSet.contains((char) character)).count();\n    return total;\n}", "repo_id": "9", "comment": "/**\n * Return the number of invalid characters in sequence.\n *\n * @param sequence\n * \t\tprotein sequence to count for invalid characters.\n * @param cSet\n * \t\tthe set of characters that are deemed valid.\n * @param ignoreCase\n * \t\tindicates if cases should be ignored\n * @return\n * \t\tthe number of invalid characters in sequence.\n */\n", "repo_name": "biojava-master/", "id": 3841, "method_signature": "int getNumberOfInvalidChar(String, Set, boolean)"}, "3523": {"callee_method_names": [], "method_name": "StrataInfo.getNrisk", "method_implementation": "{\n    return nrisk;\n}", "repo_id": "9", "comment": "/**\n * @return the nrisk\n */\n", "repo_name": "biojava-master/", "id": 3523, "method_signature": "ArrayList<Double> getNrisk()"}, "1776": {"callee_method_names": [], "method_name": "PDBHeader.getRelDate", "method_implementation": "{\n    return relDate;\n}", "repo_id": "9", "comment": "/**\n * Return the release date of the structure in the PDB.\n *\n * @return the release date\n */\n", "repo_name": "biojava-master/", "id": 1776, "method_signature": "Date getRelDate()"}, "2873": {"callee_method_names": ["DataInputStream.readShort"], "method_name": "ABITrace.setBasecalls", "method_implementation": "{\n    baseCalls = new int[seqLength];\n    byte[] qq = new byte[seqLength * 2];\n    getSubArray(qq, PLOC);\n    DataInputStream dis = new DataInputStream(new ByteArrayInputStream(qq));\n    for (int i = 0; i <= seqLength - 1; ++i) {\n        try {\n            baseCalls[i] = (int) dis.readShort();\n        } catch (//This shouldn't happen. If it does something must be seriously wrong.\n        IOException e) {\n            throw new IllegalStateException(\"Unexpected IOException encountered while manipulating internal streams.\");\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Fetch the basecalls from the trace data.\n */\n", "repo_name": "biojava-master/", "id": 2873, "method_signature": "void setBasecalls()"}, "1859": {"callee_method_names": [], "method_name": "Rotation.getTransformation", "method_implementation": "{\n    return transformation;\n}", "repo_id": "9", "comment": "/**\n * @return the transformation\n */\n", "repo_name": "biojava-master/", "id": 1859, "method_signature": "Matrix4d getTransformation()"}, "1960": {"callee_method_names": [], "method_name": "HelixAxisAligner.getTransformation", "method_implementation": "{\n    run();\n    return transformationMatrix;\n}", "repo_id": "9", "comment": "/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.core.AxisAligner#getTransformation()\n\t */\n", "repo_name": "biojava-master/", "id": 1960, "method_signature": "Matrix4d getTransformation()"}, "1645": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setUseSequenceCoverage", "method_implementation": "{\n    this.useSequenceCoverage = useSequenceCoverage;\n}", "repo_id": "9", "comment": "/**\n * Use sequence coverage for evaluating sequence similarity\n *\n * @param useSequenceCoverage\n */\n", "repo_name": "biojava-master/", "id": 1645, "method_signature": "void setUseSequenceCoverage(boolean)"}, "3226": {"callee_method_ids": [2803, 2803, 2803, 2803], "callee_method_names": ["GenbankProxySequenceReader<AminoAcidCompound>.getHeaderParser", "GenbankProxySequenceReader<AminoAcidCompound>.getHeader", "GenbankProxySequenceReader<NucleotideCompound>.getHeaderParser", "GenbankProxySequenceReader<NucleotideCompound>.getHeader", "ClasspathResource.getInputStream", "LinkedHashMap<String, DNASequence>.values", "Logger.debug", "ProteinSequence.getSequenceAsString", "ClasspathResource.getInputStream", "LinkedHashMap<String, ProteinSequence>.values", "Logger.debug", "ProteinSequence.getSequenceAsString", "ClasspathResource.getInputStream", "GenbankReader<DNASequence, NucleotideCompound>.process", "Logger.debug", "ClasspathResource.getInputStream", "GenbankReader<ProteinSequence, AminoAcidCompound>.process", "Logger.debug"], "method_name": "GenbankCookbookTest.testProcess", "method_implementation": "{\n    /*\n\t\t * Method 1: With the GenbankProxySequenceReader\n\t\t */\n    //Try with the GenbankProxySequenceReader\n    GenbankProxySequenceReader<AminoAcidCompound> genbankProteinReader = new GenbankProxySequenceReader<AminoAcidCompound>(System.getProperty(\"java.io.tmpdir\"), \"NP_000257\", AminoAcidCompoundSet.getAminoAcidCompoundSet());\n    ProteinSequence proteinSequence = new ProteinSequence(genbankProteinReader);\n    genbankProteinReader.getHeaderParser().parseHeader(genbankProteinReader.getHeader(), proteinSequence);\n    //logger.info(\"Sequence({},{}) = {}...\", proteinSequence.getAccession(), proteinSequence.getLength(), proteinSequence.getSequenceAsString().substring(0, 10));\n    GenbankProxySequenceReader<NucleotideCompound> genbankDNAReader = new GenbankProxySequenceReader<NucleotideCompound>(System.getProperty(\"java.io.tmpdir\"), \"NM_001126\", DNACompoundSet.getDNACompoundSet());\n    DNASequence dnaSequence = new DNASequence(genbankDNAReader);\n    genbankDNAReader.getHeaderParser().parseHeader(genbankDNAReader.getHeader(), dnaSequence);\n    //logger.info(\"Sequence({},{}) = {}...\", dnaSequence.getAccession(), dnaSequence.getLength(), dnaSequence.getSequenceAsString().substring(0, 10));\n    /*\n\t\t * Method 2: With the GenbankReaderHelper\n\t\t */\n    //Try with the GenbankReaderHelper\n    ClasspathResource dnaResource = new ClasspathResource(\"NM_000266.gb\", true);\n    //File dnaFile = new File(\"src/test/resources/NM_000266.gb\");\n    //File protFile = new File(\"src/test/resources/BondFeature.gb\");\n    ClasspathResource protResource = new ClasspathResource(\"BondFeature.gb\");\n    LinkedHashMap<String, DNASequence> dnaSequences = GenbankReaderHelper.readGenbankDNASequence(dnaResource.getInputStream());\n    for (DNASequence sequence : dnaSequences.values()) {\n        logger.debug(\"DNA Sequence: {}\", sequence.getSequenceAsString());\n    }\n    LinkedHashMap<String, ProteinSequence> protSequences = GenbankReaderHelper.readGenbankProteinSequence(protResource.getInputStream());\n    for (ProteinSequence sequence : protSequences.values()) {\n        logger.debug(\"Protein Sequence: {}\", sequence.getSequenceAsString());\n    }\n    /*\n\t\t * Method 3: With the GenbankReader Object\n\t\t */\n    //Try reading with the GanbankReader\n    GenbankReader<DNASequence, NucleotideCompound> dnaReader = new GenbankReader<DNASequence, NucleotideCompound>(dnaResource.getInputStream(), new GenericGenbankHeaderParser<DNASequence, NucleotideCompound>(), new DNASequenceCreator(DNACompoundSet.getDNACompoundSet()));\n    dnaSequences = dnaReader.process();\n    logger.debug(\"DNA Sequence: {}\", dnaSequences);\n    GenbankReader<ProteinSequence, AminoAcidCompound> protReader = new GenbankReader<ProteinSequence, AminoAcidCompound>(protResource.getInputStream(), new GenericGenbankHeaderParser<ProteinSequence, AminoAcidCompound>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n    protSequences = protReader.process();\n    logger.debug(\"Protein Sequence: {}\", protSequences);\n}", "repo_id": "9", "comment": "/**\n * Test of process method, of class GenbankReader.\n */\n", "repo_name": "biojava-master/", "id": 3226, "method_signature": "void testProcess()"}, "1865": {"callee_method_names": [], "method_name": "Rotation.getDirection", "method_implementation": "{\n    return direction;\n}", "repo_id": "9", "comment": "/**\n * @return the direction\n */\n", "repo_name": "biojava-master/", "id": 1865, "method_signature": "int getDirection()"}, "2088": {"callee_method_names": [], "method_name": "SymmetryAxes.getLevel", "method_implementation": "{\n    return level;\n}", "repo_id": "9", "comment": "/**\n * @return The level of this axis within it's parent hierarchy, or -1 if unset\n */\n", "repo_name": "biojava-master/", "id": 2088, "method_signature": "int getLevel()"}, "2749": {"callee_method_names": [], "method_name": "EmblRecord.getAssemblyHeader", "method_implementation": "{\n    return assemblyHeader;\n}", "repo_id": "9", "comment": "/**\n * The AH (Assembly Header) line provides column headings for the assembly information.\n *\n * @return String\n */\n", "repo_name": "biojava-master/", "id": 2749, "method_signature": "String getAssemblyHeader()"}, "2440": {"callee_method_ids": [2431], "callee_method_names": ["HashMap.containsKey", "HashMap.get", "Map<String, List<FeatureI>>.values", "FeatureList.addAll", "FeatureI.hasAttribute", "FeatureList.add"], "method_name": "FeatureList.selectByAttribute", "method_implementation": "{\n    FeatureList list = new FeatureList();\n    if (featindex.containsKey(key)) {\n        Map<String, List<FeatureI>> featsmap = featindex.get(key);\n        if (null != featsmap) {\n            for (List<FeatureI> feats : featsmap.values()) {\n                list.addAll(Collections.unmodifiableCollection(feats));\n            }\n            return list;\n        }\n    }\n    for (FeatureI f : this) {\n        if (f.hasAttribute(key)) {\n            list.add(f);\n        }\n    }\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Create a list of all features that include the specified attribute key.\n *\n * @param key The key to consider.\n * @return A list of features that include the key.\n */\n", "repo_name": "biojava-master/", "id": 2440, "method_signature": "FeatureList selectByAttribute(String)"}, "2292": {"callee_method_ids": [1523, 1534, 1532, 1528, 1525], "callee_method_names": ["Structure.hasJournalArticle", "Structure.hasJournalArticle", "Structure.getJournalArticle", "JournalArticle.getAuthorList", "List<Author>.get", "List<Author>.size", "Author.getSurname", "Author.getInitials", "JournalArticle.getTitle", "JournalArticle.getJournalName", "JournalArticle.getPublicationDate", "JournalArticle.getVolume", "JournalArticle.getStartPage", "JournalArticle.getRefn", "JournalArticle.getPmid", "JournalArticle.getDoi"], "method_name": "SourceCompoundTest.testJournalRefs", "method_implementation": "{\n    //        JRNL        AUTH   M.HAMMEL,G.SFYROERA,D.RICKLIN,P.MAGOTTI,\n    //        JRNL        AUTH 2 J.D.LAMBRIS,B.V.GEISBRECHT\n    //        JRNL        TITL   A STRUCTURAL BASIS FOR COMPLEMENT INHIBITION BY\n    //        JRNL        TITL 2 STAPHYLOCOCCUS AUREUS.\n    //        JRNL        REF    NAT.IMMUNOL.                  V.   8   430 2007\n    //        JRNL        REFN                   ISSN 1529-2908\n    //        JRNL        PMID   17351618\n    //        JRNL        DOI    10.1038/NI1450\n    Structure structure = getStructure(\"/2gox_v315.pdb\");\n    //check that there really is an publication\n    Assert.assertTrue(structure.hasJournalArticle());\n    if (structure.hasJournalArticle()) {\n        JournalArticle journal = structure.getJournalArticle();\n        List<Author> authorList = journal.getAuthorList();\n        Author firstAuthor = authorList.get(0);\n        //check the authors\n        Assert.assertEquals(6, authorList.size());\n        Assert.assertEquals(\"HAMMEL\", firstAuthor.getSurname());\n        Assert.assertEquals(\"M.\", firstAuthor.getInitials());\n        //check the other publication details\n        Assert.assertEquals(\"A STRUCTURAL BASIS FOR COMPLEMENT INHIBITION BY STAPHYLOCOCCUS AUREUS.\", journal.getTitle());\n        Assert.assertEquals(\"NAT.IMMUNOL.\", journal.getJournalName());\n        Assert.assertEquals(2007, journal.getPublicationDate());\n        Assert.assertEquals(\"8\", journal.getVolume());\n        Assert.assertEquals(\"430\", journal.getStartPage());\n        Assert.assertEquals(\"ISSN 1529-2908\", journal.getRefn());\n        Assert.assertEquals(\"17351618\", journal.getPmid());\n        Assert.assertEquals(\"10.1038/NI1450\", journal.getDoi());\n    }\n}", "repo_id": "9", "comment": "/**\n * 3.2 format includes PMID and DOI in the JRNL section.\n */\n", "repo_name": "biojava-master/", "id": 2292, "method_signature": "void testJournalRefs()"}, "2371": {"callee_method_names": [], "method_name": "Fastq.getSequence", "method_implementation": "{\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Return the sequence for this FASTQ formatted sequence.\n * The sequence will not be null.\n *\n * @return the sequence for this FASTQ formatted sequence\n */\n", "repo_name": "biojava-master/", "id": 2371, "method_signature": "String getSequence()"}, "96": {"callee_method_names": ["PairwiseSequenceAligner<S, C>.getPair", "PairwiseSequenceAligner<S, C>.getPair"], "method_name": "FractionalIdentityScorer.align", "method_implementation": "{\n    max = aligner.getPair().getLength();\n    score = aligner.getPair().getNumIdenticals();\n    aligner = null;\n}", "repo_id": "9", "comment": "// helper method for initialization from an aligner\n", "repo_name": "biojava-master/", "id": 96, "method_signature": "void align()"}, "1586": {"callee_method_names": [], "method_name": "SecStrucState.setTurn", "method_implementation": "{\n    if (turn[t - 3] == 'X')\n        return;\n    else if (turn[t - 3] == '<' && c == '>' || turn[t - 3] == '>' && c == '<') {\n        turn[t - 3] = 'X';\n    } else if (turn[t - 3] == '<' || turn[t - 3] == '>')\n        return;\n    else\n        turn[t - 3] = c;\n}", "repo_id": "9", "comment": "/**\n * Set the turn column corresponding to 3,4 or 5 helix patterns. If starting\n * > or ending < was set and the opposite is being set, the value will be\n * converted to X. If a number was set, it will be overwritten by the new\n * character.\n *\n * @param c\n *            character in the column\n * @param t\n *            turn of the helix {3,4,5}\n */\n", "repo_name": "biojava-master/", "id": 1586, "method_signature": "void setTurn(char, int)"}, "1901": {"callee_method_ids": [1907, 1942, 1942, 1907, 1951], "callee_method_names": ["QuatSymmetrySubunits.getSubunitCount", "Point3d[].set", "List<Integer>.get", "Matrix4d.set", "AxisAngle4d.set", "Vector3d.lengthSquared", "Vector3d.normalize", "QuatSymmetryParameters.getRmsdThreshold", "QuatSymmetryScores.getRmsd", "QuatSymmetryScores.getRmsd", "QuatSymmetryParameters.getRmsdThreshold", "QuatSymmetryScores.setRmsdCenters"], "method_name": "RotationSolver.superimposePermutation", "method_implementation": "{\n    // permutate subunits\n    for (int j = 0, n = subunits.getSubunitCount(); j < n; j++) {\n        transformedCoords[j].set(originalCoords[permutation.get(j)]);\n    }\n    int fold = PermutationGroup.getOrder(permutation);\n    // get optimal transformation and axisangle by subunit superposition\n    // TODO implement this piece of code using at origin superposition\n    Quat4d quat = UnitQuaternions.relativeOrientation(originalCoords, transformedCoords);\n    AxisAngle4d axisAngle = new AxisAngle4d();\n    Matrix4d transformation = new Matrix4d();\n    transformation.set(quat);\n    axisAngle.set(quat);\n    Vector3d axis = new Vector3d(axisAngle.x, axisAngle.y, axisAngle.z);\n    if (axis.lengthSquared() < 1.0E-6) {\n        axisAngle.x = 0;\n        axisAngle.y = 0;\n        axisAngle.z = 1;\n        axisAngle.angle = 0;\n    } else {\n        axis.normalize();\n        axisAngle.x = axis.x;\n        axisAngle.y = axis.y;\n        axisAngle.z = axis.z;\n    }\n    CalcPoint.transform(transformation, transformedCoords);\n    double subunitRmsd = CalcPoint.rmsd(transformedCoords, originalCoords);\n    if (subunitRmsd < parameters.getRmsdThreshold()) {\n        combineWithTranslation(transformation);\n        // evaluate superposition of CA traces\n        QuatSymmetryScores scores = QuatSuperpositionScorer.calcScores(subunits, transformation, permutation);\n        if (scores.getRmsd() < 0.0 || scores.getRmsd() > parameters.getRmsdThreshold()) {\n            return null;\n        }\n        scores.setRmsdCenters(subunitRmsd);\n        Rotation symmetryOperation = createSymmetryOperation(permutation, transformation, axisAngle, fold, scores);\n        return symmetryOperation;\n    }\n    return null;\n}", "repo_id": "9", "comment": "/**\n * Superimpose subunits based on the given permutation. Then check whether\n * the superposition passes RMSD thresholds and create a Rotation to\n * represent it if so.\n * @param permutation A list specifying which subunits should be aligned by the current transformation\n * @return A Rotation representing the permutation, or null if the superposition did not meet thresholds.\n */\n", "repo_name": "biojava-master/", "id": 1901, "method_signature": "Rotation superimposePermutation(List)"}, "3645": {"callee_method_names": ["LinkedHashMap.get"], "method_name": "SurvivalInfo.getUnknownDataTypeVariable", "method_implementation": "{\n    return unknownDataType.get(variable);\n}", "repo_id": "9", "comment": "/**\n * @param variable\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3645, "method_signature": "String getUnknownDataTypeVariable(String)"}, "318": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Component.toString", "method_implementation": "{\n    StringBuilder sb = new StringBuilder();\n    sb.append(getPdbccIds());\n    if (isCTerminal()) {\n        sb.append(\"(C)\");\n    } else if (isNTerminal()) {\n        sb.append(\"(N)\");\n    }\n    return sb.toString();\n}", "repo_id": "9", "comment": "/**\n * @return informative description.\n */\n", "repo_name": "biojava-master/", "id": 318, "method_signature": "String toString()"}, "404": {"callee_method_names": [], "method_name": "GroupIterator.next", "method_implementation": "{\n    return getNextGroup(current_model_pos, current_chain_pos, current_group_pos + 1);\n}", "repo_id": "9", "comment": "/**\n * get next Group.\n * @return next Group\n * @throws NoSuchElementException ...\n */\n", "repo_name": "biojava-master/", "id": 404, "method_signature": "Group next()"}, "2460": {"callee_method_names": ["String.indexOf", "String.trim", "String.substring"], "method_name": "Feature.group", "method_implementation": "{\n    int i = mAttributes.indexOf(';');\n    return (i < 0) ? mAttributes.trim() : mAttributes.substring(0, i).trim();\n}", "repo_id": "9", "comment": "/**\n * Get the first item (everything before first semicolon, if it has one)\n * in the attribute field, which is assumed to\n * be a group identifer. This is appropriate for GFF1 files and variants. It is not\n * appropriate for GTF and GFF2 files, although they may use a named attribute key,\n * such as \"gene_id\" or \"transcript_id\", for grouping.\n *\n * @return The group id. Everything before the first semicolon in the attributes string (minus trailing whitespace).\n */\n", "repo_name": "biojava-master/", "id": 2460, "method_signature": "String group()"}, "3213": {"callee_method_names": ["Map<String, TestObject>.put", "TestObject.getName"], "method_name": "SoftHashMapTest.softMapRemovesRefsToSaveMemory", "method_implementation": "{\n    // Using a regular Map with hard references will probably\n    // cause an OOM error if running with -Xmx=5M. Uncomment this\n    // and comment out the next line to observe this.\n    // Map<String, TestObject> map =new HashMap<>(1);\n    // set the maximum number of hard references to 1 (minimum)\n    // to expose behaviour of soft references better.\n    Map<String, TestObject> map = new SoftHashMap<>(1);\n    int totalPuts = 5;\n    for (int i = 0; i < totalPuts; i++) {\n        TestObject myObject = TestObject.large(\"\" + i);\n        map.put(myObject.getName(), myObject);\n        //allocate a little slowly\n        // enables GC time to work\n        Thread.sleep(10);\n    }\n    int nonNullValues = countNonNullMapReferences(map, totalPuts);\n    // some but not all references should be removed.\n    assertTrue(nonNullValues > 0 && nonNullValues < totalPuts);\n}", "repo_id": "9", "comment": "// OOM errors during normal test execution so this is disabled\n", "repo_name": "biojava-master/", "id": 3213, "method_signature": "void softMapRemovesRefsToSaveMemory()"}, "3557": {"callee_method_names": ["DecimalFormat.format", "DecimalFormat.format", "String.length"], "method_name": "CoxVariables.fmt", "method_implementation": "{\n    String value = \"\";\n    DecimalFormat dfe = new DecimalFormat(\"0.00E0\");\n    String dpad = \"0.\";\n    double p = 1.0;\n    for (int i = 0; i < (precision); i++) {\n        dpad = dpad + \"0\";\n        p = p / 10.0;\n    }\n    DecimalFormat df = new DecimalFormat(dpad);\n    if (Math.abs(d) >= p) {\n        value = df.format(d);\n    } else {\n        value = dfe.format(d);\n    }\n    int length = value.length();\n    int extra = pad - length;\n    if (extra > 0) {\n        for (int i = 0; i < extra; i++) {\n            value = \" \" + value;\n        }\n    }\n    return value;\n}", "repo_id": "9", "comment": "/**\n * @param d\n * @param precision\n * @param pad\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3557, "method_signature": "String fmt(Double, int, int)"}, "1008": {"callee_method_names": ["TreeMap<ResidueNumber, Integer>.lastKey"], "method_name": "AtomPositionMap.getLast", "method_implementation": "{\n    return treeMap.lastKey();\n}", "repo_id": "9", "comment": "/**\n * @return The last {@link ResidueNumber} of any chain (the one farthest down in the PDB file)\n */\n", "repo_name": "biojava-master/", "id": 1008, "method_signature": "ResidueNumber getLast()"}, "1649": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setUseGlobalMetrics", "method_implementation": "{\n    this.useGlobalMetrics = useGlobalMetrics;\n}", "repo_id": "9", "comment": "/**\n * Use metrics calculated relative to the whole sequence or structure,\n * rather than the aligned part only\n *\n * @param useGlobalMetrics\n */\n", "repo_name": "biojava-master/", "id": 1649, "method_signature": "void setUseGlobalMetrics(boolean)"}, "575": {"callee_method_names": [], "method_name": "RotationAxis.isDefined", "method_implementation": "{\n    return rotationPos != null;\n}", "repo_id": "9", "comment": "/**\n * @return If the rotation axis is well defined, rather than purely translational\n */\n", "repo_name": "biojava-master/", "id": 575, "method_signature": "boolean isDefined()"}, "204": {"callee_method_names": [], "method_name": "FastaSequence.getSequence", "method_implementation": "{\n    return sequence;\n}", "repo_id": "9", "comment": "/**\n * Gets the value of sequence\n *\n * @return the value of sequence\n */\n", "repo_name": "biojava-master/", "id": 204, "method_signature": "String getSequence()"}, "1814": {"callee_method_names": [], "method_name": "EcodInstallation.getDomainFilename", "method_implementation": "{\n    return String.format(DOMAINS_FILENAME_FORMAT, requestedVersion);\n}", "repo_id": "9", "comment": "/**\n * Basename for the domains file with the current requestedVersion.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1814, "method_signature": "String getDomainFilename()"}, "3428": {"callee_method_names": ["MultipleAlignmentJmol.setTitle"], "method_name": "SymmetryDisplay.displayRepeats", "method_implementation": "{\n    MultipleAlignment repeats = SymmetryTools.toRepeatsAlignment(symm);\n    MultipleAlignmentJmol jmol = MultipleAlignmentJmolDisplay.display(repeats);\n    jmol.setTitle(getSymmTitle(symm));\n    return jmol;\n}", "repo_id": "9", "comment": "/**\n * Displays a multiple alignment of the symmetry repeats.\n *\n * * @param symm CeSymmResult\n *\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3428, "method_signature": "MultipleAlignmentJmol displayRepeats(CeSymmResult)"}, "443": {"callee_method_ids": [1666, 1666], "callee_method_names": ["Map<Integer,Map<Integer,Integer>>.keySet", "List<SubunitCluster>.get", "Map<Integer,Map<Integer,Integer>>.get", "SOPair.getKey", "SOPair.getValue", "List<Atom>.addAll", "SubunitCluster.getAlignedAtomsSubunit", "List<Atom>.addAll", "SubunitCluster.getAlignedAtomsSubunit", "List<Atom>.toArray", "List<Atom>.toArray"], "method_name": "QsAlign.getAlignedAtomsForClusterSubunitMap", "method_implementation": "{\n    List<Atom> atomArray1 = new ArrayList<>();\n    List<Atom> atomArray2 = new ArrayList<>();\n    // For each cluster of subunits\n    for (int key : clusterSubunitMap.keySet()) {\n        // Obtain the cluster and the alignment in it\n        SubunitCluster cluster = clusters.get(key);\n        // For each subunit matching in the cluster\n        for (Entry<Integer, Integer> pair : clusterSubunitMap.get(key).entrySet()) {\n            int i = pair.getKey();\n            int j = pair.getValue();\n            // Apend atoms to the arrays\n            atomArray1.addAll(Arrays.asList(cluster.getAlignedAtomsSubunit(i)));\n            atomArray2.addAll(Arrays.asList(cluster.getAlignedAtomsSubunit(j)));\n        }\n    }\n    return new Pair<>(atomArray1.toArray(new Atom[0]), atomArray2.toArray(new Atom[0]));\n}", "repo_id": "9", "comment": "/**\n * Returns a pair of Atom arrays corresponding to the alignment of subunit\n * matchings, in order of appearance. Superposition of the two Atom sets\n * gives the transformation of the complex.\n * <p>\n * Utility method to cumulative calculate the alignment Atoms.\n *\n * @param clusters\n *            List of SubunitClusters\n * @param clusterSubunitMap\n *            map from cluster id to subunit matching\n * @return pair of atom arrays to be superposed\n */\n", "repo_name": "biojava-master/", "id": 443, "method_signature": "Pair<Atom[]> getAlignedAtomsForClusterSubunitMap(List, Map)"}, "163": {"callee_method_names": ["Structure.getPDBHeader"], "method_name": "TestNcsOpsParsing.test1a37", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    StructureIO.setAtomCache(cache);\n    Structure s = StructureIO.getStructure(\"1a37\");\n    Matrix4d[] ops = s.getPDBHeader().getCrystallographicInfo().getNcsOperators();\n    assertNotNull(ops);\n    // the given operator must not be in our list, only the \"generate\" operators\n    assertEquals(1, ops.length);\n}", "repo_id": "9", "comment": "/**\n * A structure with struct_ncs_ops which is not a viral capsid\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 163, "method_signature": "void test1a37()"}, "240": {"callee_method_names": ["LinkedHashSet.add"], "method_name": "Builder.addKeyword", "method_implementation": "{\n    if (keyword == null)\n        throw new IllegalArgumentException(\"Keyword cannot be null.\");\n    keywords.add(keyword);\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Add a keyword associate with the PTM.\n * @param keyword a keyword.\n * @return the same Builder object so you can chain setters.\n * @throws IllegalArgumentException if the keyword is null.\n */\n", "repo_name": "biojava-master/", "id": 240, "method_signature": "Builder addKeyword(String)"}, "3635": {"callee_method_names": [], "method_name": "CoxInfo.getMetaDataFilter", "method_implementation": "{\n    return metaDataFilter;\n}", "repo_id": "9", "comment": "/**\n * @return the metaDataFilter\n */\n", "repo_name": "biojava-master/", "id": 3635, "method_signature": "LinkedHashMap<String,String> getMetaDataFilter()"}, "3032": {"callee_method_names": [], "method_name": "Location.modulateCircularIndex", "method_implementation": "{\n    // Dummy case\n    if (seqLength == 0) {\n        return index;\n    }\n    // Modulate\n    while (index > seqLength) {\n        index -= seqLength;\n    }\n    return index;\n}", "repo_id": "9", "comment": "/**\n * Takes a point on a circular location and moves it left until it falls\n * at the earliest possible point that represents the same base.\n *\n * @param index Index of the position to work with\n * @param seqLength Length of the Sequence\n * @return The shifted point\n */\n", "repo_name": "biojava-master/", "id": 3032, "method_signature": "int modulateCircularIndex(int, int)"}, "2478": {"callee_method_names": ["GeneChromosomePosition.getExonStarts", "GeneChromosomePosition.getExonEnds", "GeneChromosomePosition.getCdsStart", "GeneChromosomePosition.getCdsEnd", "GeneChromosomePosition.getOrientation"], "method_name": "ChromosomeMappingTools.getCDSLength", "method_implementation": "{\n    List<Integer> exonStarts = chromPos.getExonStarts();\n    List<Integer> exonEnds = chromPos.getExonEnds();\n    int cdsStart = chromPos.getCdsStart();\n    int cdsEnd = chromPos.getCdsEnd();\n    int codingLength;\n    if (chromPos.getOrientation().equals('+'))\n        codingLength = ChromosomeMappingTools.getCDSLengthForward(exonStarts, exonEnds, cdsStart, cdsEnd);\n    else\n        codingLength = ChromosomeMappingTools.getCDSLengthReverse(exonStarts, exonEnds, cdsStart, cdsEnd);\n    return codingLength;\n}", "repo_id": "9", "comment": "/**\n * Get the length of the CDS in nucleotides.\n *\n * @param chromPos\n * @return length of the CDS in nucleotides.\n */\n", "repo_name": "biojava-master/", "id": 2478, "method_signature": "int getCDSLength(GeneChromosomePosition)"}, "1870": {"callee_method_names": [], "method_name": "Helix.getScores", "method_implementation": "{\n    return scores;\n}", "repo_id": "9", "comment": "/**\n * @return the scores\n */\n", "repo_name": "biojava-master/", "id": 1870, "method_signature": "QuatSymmetryScores getScores()"}, "2879": {"callee_method_names": ["Sequence<NucleotideCompound>.getCompoundSet", "CompoundSet<NucleotideCompound>.getCompoundForString", "CompoundSet<NucleotideCompound>.getCompoundForString", "CompoundSet<NucleotideCompound>.getCompoundForString", "CompoundSet<NucleotideCompound>.getCompoundForString"], "method_name": "SequenceMixin.countGC", "method_implementation": "{\n    CompoundSet<NucleotideCompound> cs = sequence.getCompoundSet();\n    NucleotideCompound G = cs.getCompoundForString(\"G\");\n    NucleotideCompound C = cs.getCompoundForString(\"C\");\n    NucleotideCompound g = cs.getCompoundForString(\"g\");\n    NucleotideCompound c = cs.getCompoundForString(\"c\");\n    return countCompounds(sequence, G, C, g, c);\n}", "repo_id": "9", "comment": "/**\n * Returns the count of GC in the given sequence\n *\n * @param sequence The {@link NucleotideCompound} {@link Sequence} to perform\n * the GC analysis on\n * @return The number of GC compounds in the sequence\n */\n", "repo_name": "biojava-master/", "id": 2879, "method_signature": "int countGC(Sequence)"}, "1609": {"callee_method_names": ["List<ResidueRange>.isEmpty"], "method_name": "SubstructureIdentifier.getIdentifier", "method_implementation": "{\n    String pdbId = this.pdbId == null ? \"\" : this.pdbId.getId();\n    if (ranges.isEmpty())\n        return pdbId;\n    return pdbId + \".\" + ResidueRange.toString(ranges);\n}", "repo_id": "9", "comment": "/**\n * Get the String form of this identifier.\n *\n * This provides the canonical form for a StructureIdentifier and has\n * all the information needed to recreate a particular substructure.\n *\n * Example: 3iek.A_17-28,A_56-294\n * @return The String form of this identifier\n */\n", "repo_name": "biojava-master/", "id": 1609, "method_signature": "String getIdentifier()"}, "683": {"callee_method_names": ["List<Atom[]>.size", "List<Integer>.size", "List<Atom[]>.size", "List<Atom[]>.size", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.get", "List<Integer>.get", "List<Integer>.get"], "method_name": "MultipleAlignmentScorer.getAvgTMScore", "method_implementation": "{\n    if (transformed.size() != lengths.size())\n        throw new IllegalArgumentException(\"Input sizes differ.\");\n    double sumTM = 0;\n    int comparisons = 0;\n    for (int r1 = 0; r1 < transformed.size(); r1++) {\n        for (int r2 = r1 + 1; r2 < transformed.size(); r2++) {\n            int len = transformed.get(r1).length;\n            // Remove nulls from both arrays\n            Atom[] ref = new Atom[len];\n            Atom[] aln = new Atom[len];\n            int nonNullLen = 0;\n            for (int c = 0; c < len; c++) {\n                if (transformed.get(r1)[c] != null && transformed.get(r2)[c] != null) {\n                    ref[nonNullLen] = transformed.get(r1)[c];\n                    aln[nonNullLen] = transformed.get(r2)[c];\n                    nonNullLen++;\n                }\n            }\n            // Truncate nulls\n            if (nonNullLen < len) {\n                ref = Arrays.copyOf(ref, nonNullLen);\n                aln = Arrays.copyOf(aln, nonNullLen);\n            }\n            sumTM += Calc.getTMScore(ref, aln, lengths.get(r1), lengths.get(r2));\n            comparisons++;\n        }\n    }\n    return sumTM / comparisons;\n}", "repo_id": "9", "comment": "/**\n * Calculates the average TMScore all the possible pairwise structure\n * comparisons of the given a set of superimposed Atoms and the original\n * structure lengths.\n * <p>\n * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n * length.\n *\n * @param transformed\n *            aligned Atoms transformed\n * @param lengths\n *            lengths of the structures in residue number\n * @return double Average TMscore\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 683, "method_signature": "double getAvgTMScore(List, List)"}, "235": {"callee_method_names": [], "method_name": "Builder.setResidName", "method_implementation": "{\n    this.residName = residName;\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Set the RESID name.\n * @param residName RESID name.\n * @return the same Builder object so you can chain setters.\n */\n", "repo_name": "biojava-master/", "id": 235, "method_signature": "Builder setResidName(String)"}, "1225": {"callee_method_names": ["String.startsWith", "String.substring", "String.startsWith", "ArrayList.clear", "String.startsWith", "ArrayList.clear", "String.startsWith", "String.contains", "String.startsWith"], "method_name": "PDBBioAssemblyParser.pdb_REMARK_350_Handler", "method_implementation": "{\n    if (line.startsWith(\"REMARK 350 BIOMOLECULE:\")) {\n        initialize();\n        currentBioMolecule = Integer.parseInt(line.substring(24).trim());\n    } else // not parsing anymore the size (from biojava 5.0), thus this is not needed anymore\n    // eventually if needed this could be used to\n    // infer if bioassembly is author or software determined\n    //else if ( line.matches(\"REMARK 350 \\\\w+ DETERMINED BIOLOGICAL UNIT:.*\" ) ||\n    //\t\t\tline.matches(\"REMARK 350 \\\\w+ DETERMINED QUATERNARY STRUCTURE:.*\" )) {\n    // text can be :\n    // author determined biological unit\n    // software determined quaternary structure\n    //}\n    if (line.startsWith(\"REMARK 350 APPLY THE FOLLOWING TO CHAINS:\")) {\n        currentChainIDs.clear();\n        addToCurrentChainList(line);\n    } else if (line.startsWith(\"REMARK 350 IN ADDITION APPLY THE FOLLOWING TO CHAINS:\")) {\n        currentChainIDs.clear();\n        addToCurrentChainList(line);\n    } else if (line.startsWith(\"REMARK 350\") && line.contains(\"AND CHAINS:\")) {\n        addToCurrentChainList(line);\n    } else if (line.startsWith(\"REMARK 350   BIOMT\")) {\n        if (readMatrix(line)) {\n            saveMatrix();\n            modelNumber++;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Parses REMARK 350 line. See format description:\n * http://www.wwpdb.org/documentation/format33/remarks2.html\n *\n * @param line\n */\n", "repo_name": "biojava-master/", "id": 1225, "method_signature": "void pdb_REMARK_350_Handler(String)"}, "608": {"callee_method_names": [], "method_name": "IdentityMap.get", "method_implementation": "{\n    return (K) key;\n}", "repo_id": "9", "comment": "/**\n * @param key\n * @return the key\n * @throws ClassCastException if key is not of type K\n */\n", "repo_name": "biojava-master/", "id": 608, "method_signature": "K get(Object)"}, "880": {"callee_method_names": ["Pair<String>.getFirst", "Pair<String>.getSecond"], "method_name": "StructureInterface.isSymRelated", "method_implementation": "{\n    return moleculeIds.getFirst().equals(moleculeIds.getSecond());\n}", "repo_id": "9", "comment": "/**\n * Tells whether the interface corresponds to one mediated by crystallographic symmetry,\n * i.e. it is between symmetry-related molecules (with same chain identifier)\n * @return\n */\n", "repo_name": "biojava-master/", "id": 880, "method_signature": "boolean isSymRelated()"}, "3740": {"callee_method_names": ["HashMap.get", "HashMap.put"], "method_name": "WorkSheet.getCellDouble", "method_implementation": "{\n    if (cacheDoubleValues) {\n        String key = row + \":\" + col;\n        Double v = doubleValues.get(key);\n        if (v != null) {\n            return v;\n        }\n        String value = getCell(row, col);\n        try {\n            v = Double.parseDouble(value);\n        } catch (Exception e) {\n        }\n        doubleValues.put(key, v);\n        return v;\n    } else {\n        Double v = null;\n        String value = getCell(row, col);\n        try {\n            v = Double.parseDouble(value);\n        } catch (Exception e) {\n        }\n        return v;\n    }\n}", "repo_id": "9", "comment": "/**\n * @param row\n * @param col\n * @return\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3740, "method_signature": "Double getCellDouble(String, String)"}, "511": {"callee_method_names": ["Object.getClass"], "method_name": "AFPChain.equals", "method_implementation": "{\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (getClass() != obj.getClass())\n        return false;\n    AFPChain other = (AFPChain) obj;\n    if (blockNum != other.blockNum)\n        return false;\n    if (ca1Length != other.ca1Length)\n        return false;\n    if (ca2Length != other.ca2Length)\n        return false;\n    if (!Arrays.deepEquals(optAln, other.optAln))\n        return false;\n    if (!Arrays.equals(optLen, other.optLen))\n        return false;\n    if (optLength != other.optLength)\n        return false;\n    return true;\n}", "repo_id": "9", "comment": "/**\n * A week equality metric.\n *\n * Checks if the optAlign is the same, and if the objects being compared\n * seem to be the same (same names, lengths). Does not check properties\n * of the alignment such as scores or superposition matrices.\n * @see java.lang.Object#equals(java.lang.Object)\n */\n", "repo_name": "biojava-master/", "id": 511, "method_signature": "boolean equals(Object)"}, "3766": {"callee_method_names": ["File.getParentFile", "File.isDirectory", "File.mkdirs", "BufferedOutputStream.close", "FileOutputStream.close"], "method_name": "WorkSheet.saveCSV", "method_implementation": "{\n    File f = new File(fileName);\n    File parentFile = f.getParentFile();\n    if (!parentFile.isDirectory()) {\n        parentFile.mkdirs();\n    }\n    FileOutputStream file = new FileOutputStream(fileName);\n    BufferedOutputStream bs = new BufferedOutputStream(file);\n    save(bs, ',', false);\n    bs.close();\n    file.close();\n}", "repo_id": "9", "comment": "/**\n * Save the worksheet as a csv file\n *\n * @param fileName\n * @throws Exception\n */\n", "repo_name": "biojava-master/", "id": 3766, "method_signature": "void saveCSV(String)"}, "3357": {"callee_method_names": ["NavigableMap<Double, Color>.putAll"], "method_name": "GradientMapper.putAll", "method_implementation": "{\n    mapping.putAll(m);\n}", "repo_id": "9", "comment": "/**\n * @param m\n * @see java.util.Map#putAll(java.util.Map)\n */\n", "repo_name": "biojava-master/", "id": 3357, "method_signature": "void putAll(Map)"}, "175": {"callee_method_names": ["String.length", "String.charAt", "String.charAt", "String.charAt", "String.charAt", "String.charAt", "String.charAt"], "method_name": "StringManipulationTestsHelper.compareString", "method_implementation": "{\n    for (int i = 0; i < s.length(); i++) {\n        System.out.println(\"@\" + i + \"\\t>\" + s.charAt(i) + \":\" + pdb.charAt(i) + \"<\\t\" + Integer.toHexString(s.charAt(i)) + \":\" + Integer.toHexString(pdb.charAt(i)));\n        if (Character.toUpperCase(s.charAt(i)) != Character.toUpperCase(pdb.charAt(i))) {\n            break;\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * @param s\n * @param pdb\n */\n", "repo_name": "biojava-master/", "id": 175, "method_signature": "void compareString(String, String)"}, "482": {"callee_method_names": [], "method_name": "AFPChain.getMaxTra", "method_implementation": "{\n    return maxTra;\n}", "repo_id": "9", "comment": "/**\n * get the maximum nr of Twists that are allowed...\n *\n * @return maxTra, the max nr of twists\n */\n", "repo_name": "biojava-master/", "id": 482, "method_signature": "int getMaxTra()"}, "2600": {"callee_method_names": ["Object.equals"], "method_name": "Equals.equal", "method_implementation": "{\n    return one == null && two == null || !(one == null || two == null) && (one == two || one.equals(two));\n}", "repo_id": "9", "comment": "/**\n * Does not compare class types.\n * However, if the two arguments are non-null references to distinct objects,\n *  the object's equals() method is called - which may well compare class types.\n * @see #classEqual(Object, Object)\n */\n", "repo_name": "biojava-master/", "id": 2600, "method_signature": "boolean equal(Object, Object)"}, "1746": {"callee_method_names": ["List<Chain>.size", "List<Chain>.get", "Chain.getAtomSequence", "String.length", "String.length", "Chain.getAtomGroup", "Chain.getAtomGroup", "Map<String, Integer>.get", "Group.getPDBName", "Map<String, Integer>.get", "Group.getPDBName", "Group.getAtom", "Group.getAtom", "Atom.getCoordsAsPoint3d", "Atom.getCoordsAsPoint3d", "List<Pair<Group>>.add", "ArrayList.add", "String.length", "String.charAt", "String.length", "Chain.getAtomSequence", "List<Pair<Group>>.addAll"], "method_name": "TertiaryBasePairParameters.findPairs", "method_implementation": "{\n    List<Pair<Group>> result = new ArrayList<>();\n    boolean lastFoundPair = false;\n    for (int i = 0; i < chains.size(); i++) {\n        Chain c = chains.get(i);\n        String sequence = c.getAtomSequence();\n        Integer type1, type2;\n        for (int j = 0; j < sequence.length(); j++) {\n            boolean foundPair = false;\n            for (int k = sequence.length() - 1; k >= j + 3 && !foundPair; k--) {\n                Group g1 = c.getAtomGroup(j);\n                Group g2 = c.getAtomGroup(k);\n                type1 = BASE_MAP.get(g1.getPDBName());\n                type2 = BASE_MAP.get(g2.getPDBName());\n                if (type1 == null || type2 == null)\n                    continue;\n                Atom a1 = g1.getAtom(\"C1'\");\n                Atom a2 = g2.getAtom(\"C1'\");\n                if (a1 == null || a2 == null)\n                    continue;\n                // C1'-C1' distance is one useful criteria\n                if (Math.abs(a1.getCoordsAsPoint3d().distance(a2.getCoordsAsPoint3d()) - 10.0) > 4.0)\n                    continue;\n                Pair<Group> ga = new Pair<>(g1, g2);\n                // TODO is this call needed?? JD 2018-03-07\n                @SuppressWarnings(\"unused\")\n                Matrix4d data = basePairReferenceFrame(ga);\n                // if the stagger is greater than 2 \u00c5, it's not really paired.\n                if (Math.abs(pairParameters[5]) > maxStagger)\n                    continue;\n                // if the propeller is ridiculous it's also not that good of a pair.\n                if (Math.abs(pairParameters[1]) > maxPropeller) {\n                    continue;\n                }\n                result.add(ga);\n                pairingNames.add(useRNA ? BASE_LIST_RNA[type1] + BASE_LIST_RNA[type2] : BASE_LIST_DNA[type1] + BASE_LIST_DNA[type2]);\n                foundPair = true;\n            }\n            if (!foundPair && lastFoundPair) {\n                if (pairSequence.length() > 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                    pairSequence += ' ';\n            }\n            if (foundPair)\n                pairSequence += (c.getAtomSequence().charAt(j));\n            lastFoundPair = foundPair;\n        }\n    }\n    result.addAll(super.findPairs(chains));\n    return result;\n}", "repo_id": "9", "comment": "/**\n * This is an alternative implementation of findPair() that looks for anything that would fit the\n * criteria for a base-pair, useful for the context of tertiary structure of RNA.  Intra-strand base pairs\n * are found with this algorithm.\n * @param chains The list of chains already found to be nucleic acids\n * @return A list of the Pair of groups that match the base pair criteria, including intra-strand groups.\n */\n", "repo_name": "biojava-master/", "id": 1746, "method_signature": "List<Pair<Group>> findPairs(List)"}, "2032": {"callee_method_names": [], "method_name": "Icosahedron.setCirumscribedRadius", "method_implementation": "{\n    this.circumscribedRadius = cirumscribedRadius;\n}", "repo_id": "9", "comment": "/**\n * Set the radius of a circumscribed sphere, that goes\n * through all vertices\n * @param cirumscribedRadius the cirumscribedRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2032, "method_signature": "void setCirumscribedRadius(double)"}, "2537": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getPAM250", "method_implementation": "{\n    return getAminoAcidMatrix(\"pam250\");\n}", "repo_id": "9", "comment": "/**\n * Returns PAM 250 matrix by Dayhoff\n * @return PAM 250 matrix\n */\n", "repo_name": "biojava-master/", "id": 2537, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getPAM250()"}, "3693": {"callee_method_names": [], "method_name": "SurvFitInfo.getStrataInfoHashMap", "method_implementation": "{\n    return strataInfoHashMap;\n}", "repo_id": "9", "comment": "/**\n * @return the strataInfoHashMap\n */\n", "repo_name": "biojava-master/", "id": 3693, "method_signature": "LinkedHashMap<String,StrataInfo> getStrataInfoHashMap()"}, "1245": {"callee_method_ids": [1410], "callee_method_names": ["PDBCrystallographicInfo.getCrystalCell", "CrystalCell.getA", "CrystalCell.getB", "CrystalCell.getC", "CrystalCell.getAlpha", "CrystalCell.getBeta", "CrystalCell.getGamma"], "method_name": "MmtfUtils.getUnitCellAsArray", "method_implementation": "{\n    CrystalCell xtalCell = xtalInfo.getCrystalCell();\n    if (xtalCell == null) {\n        return null;\n    } else {\n        float[] inputUnitCell = new float[6];\n        inputUnitCell[0] = (float) xtalCell.getA();\n        inputUnitCell[1] = (float) xtalCell.getB();\n        inputUnitCell[2] = (float) xtalCell.getC();\n        inputUnitCell[3] = (float) xtalCell.getAlpha();\n        inputUnitCell[4] = (float) xtalCell.getBeta();\n        inputUnitCell[5] = (float) xtalCell.getGamma();\n        return inputUnitCell;\n    }\n}", "repo_id": "9", "comment": "/**\n * Get the length six array of the unit cell information.\n * @param xtalInfo the input PDBCrystallographicInfo object\n * @return the length six float array\n */\n", "repo_name": "biojava-master/", "id": 1245, "method_signature": "float[] getUnitCellAsArray(PDBCrystallographicInfo)"}, "2805": {"callee_method_names": [], "method_name": "ClasspathResource.getList", "method_implementation": "{\n    return IOUtils.getList(getBufferedReader());\n}", "repo_id": "9", "comment": "/**\n * Returns this resource as a list of Strings\n */\n", "repo_name": "biojava-master/", "id": 2805, "method_signature": "List<String> getList()"}, "469": {"callee_method_ids": [1400], "callee_method_names": ["PdbId.getId", "Logger.error", "String.split"], "method_name": "StructureName.getBaseIdentifier", "method_implementation": "{\n    if (base == null) {\n        switch(mySource) {\n            case CATH:\n                base = CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());\n                break;\n            case ECOD:\n                try {\n                    base = EcodFactory.getEcodDatabase().getDomainsById(name);\n                } catch (IOException e) {\n                    throw new StructureException(\"Unable to get ECOD domain \" + name, e);\n                }\n                break;\n            case SCOP:\n                // Fuzzy matching of the domain name to the current default factory\n                base = guessScopDomain(getIdentifier(), ScopFactory.getSCOP());\n                if (base == null) {\n                    // Guessing didn't work, so just use the PDBID and Chain from name\n                    // Guess that '_' means 'whole structure'\n                    if (\"_\".equals(chainName)) {\n                        base = new SubstructureIdentifier(pdbId.getId());\n                    } else {\n                        base = new SubstructureIdentifier(pdbId, ResidueRange.parseMultiple(chainName));\n                    }\n                    logger.error(\"Unable to find {}, so using {}\", name, base);\n                }\n                break;\n            case FILE:\n                try {\n                    String[] prefix = name.split(\":\", 2);\n                    String filename;\n                    if (prefix.length > 1) {\n                        filename = prefix[1];\n                    } else {\n                        filename = name;\n                    }\n                    filename = FileDownloadUtils.expandUserHome(filename);\n                    base = new URLIdentifier(new File(filename).toURI().toURL());\n                } catch (MalformedURLException e) {\n                    // Should never happen\n                    throw new StructureException(\"Unable to get URL for file: \" + name, e);\n                }\n                break;\n            case URL:\n                try {\n                    base = new URLIdentifier(name);\n                } catch (MalformedURLException e) {\n                    throw new StructureException(\"Invalid URL: \" + name, e);\n                }\n                break;\n            case BIO:\n                base = new BioAssemblyIdentifier(name);\n                break;\n            case PDB:\n                base = new SubstructureIdentifier(getIdentifier());\n                break;\n            default:\n                throw new IllegalStateException(\"Unimplemented source: \" + mySource);\n        }\n    }\n    return base;\n}", "repo_id": "9", "comment": "/**\n * StructureName wraps another StructureIdentifier. The type of the base\n * identifier depends on the {@link #getSource() source}. Most StructureName\n * methods deligate to the base identifier.\n *\n * <p>It is possible that future versions of StructureName might change the\n * return type. Except for some specialized uses, it is probably better\n * to create the correct type of identifier directly, rather than creating\n * a StructureName and casting the result of this method.\n * @return A Str\n * @throws StructureException Wraps exceptions that may be thrown by\n *  individual implementations. For example, a SCOP identifier may require\n *  that the domain definitions be available for download.\n */\n", "repo_name": "biojava-master/", "id": 469, "method_signature": "StructureIdentifier getBaseIdentifier()"}, "453": {"callee_method_names": [], "method_name": "QsAlignResult.setRelation", "method_implementation": "{\n    this.relation = relation;\n}", "repo_id": "9", "comment": "/**\n * The quaternary structure relation {@link QsRelation} between the two\n * groups of Subunits.\n *\n * @param relation\n */\n", "repo_name": "biojava-master/", "id": 453, "method_signature": "void setRelation(QsRelation)"}, "2250": {"callee_method_names": ["Set<ExperimentalTechnique>.add", "Set<ExperimentalTechnique>.add"], "method_name": "TestMmtfUtils.testGetExperimentalMethods", "method_implementation": "{\n    Set<ExperimentalTechnique> experimentalTechniques = new HashSet<>();\n    experimentalTechniques.add(ExperimentalTechnique.XRAY_DIFFRACTION);\n    experimentalTechniques.add(ExperimentalTechnique.ELECTRON_MICROSCOPY);\n    String[] techniques = MmtfUtils.techniquesToStringArray(experimentalTechniques);\n    String[] testTechniques = { \"X-RAY DIFFRACTION\", \"ELECTRON MICROSCOPY\" };\n    Arrays.sort(techniques);\n    Arrays.sort(testTechniques);\n    assertArrayEquals(testTechniques, techniques);\n}", "repo_id": "9", "comment": "/**\n * Test getting the list of experimental methods as string array.\n */\n", "repo_name": "biojava-master/", "id": 2250, "method_signature": "void testGetExperimentalMethods()"}, "1696": {"callee_method_names": [], "method_name": "AtomImpl.getZ", "method_implementation": "{\n    return coords.z;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 1696, "method_signature": "double getZ()"}, "2428": {"callee_method_ids": [2431], "callee_method_names": ["Logger.info", "BufferedReader.readLine", "BufferedReader.readLine", "String.trim", "String.length", "String.charAt", "FeatureList.add"], "method_name": "GeneMarkGTFReader.read", "method_implementation": "{\n    logger.info(\"Reading: {}\", filename);\n    FeatureList features = new FeatureList();\n    try (BufferedReader br = new BufferedReader(new FileReader(filename))) {\n        String s;\n        for (s = br.readLine(); null != s; s = br.readLine()) {\n            s = s.trim();\n            if (s.length() > 0) {\n                if (s.charAt(0) == '#') {\n                    //ignore comment lines\n                } else {\n                    FeatureI f = parseLine(s);\n                    if (f != null) {\n                        features.add(f);\n                    }\n                }\n            }\n        }\n    }\n    return features;\n}", "repo_id": "9", "comment": "/**\n * Read a file into a FeatureList. Each line of the file becomes one Feature object.\n *\n * @param filename The path to the GFF file.\n * @return A FeatureList.\n * @throws IOException Something went wrong -- check exception detail message.\n */\n", "repo_name": "biojava-master/", "id": 2428, "method_signature": "FeatureList read(String)"}, "3246": {"callee_method_names": ["String.toLowerCase", "Vector<String>.clear", "SuggestionFetcher.setStop", "SuggestionFetcher.execute"], "method_name": "JAutoSuggest.showSuggest", "method_implementation": "{\n    assert (getText() != null);\n    lastWord = getText().trim();\n    //autoSuggestProvider.getSuggestion(lastWord);\n    if (!getText().toLowerCase().contains(lastWord.toLowerCase())) {\n        suggestions.clear();\n    }\n    if (matcher != null) {\n        matcher.setStop();\n    }\n    matcher = new SuggestionFetcher();\n    //SwingUtilities.invokeLater(matcher);\n    matcher.execute();\n    lastWord = getText().trim();\n    updateLocation();\n}", "repo_id": "9", "comment": "/**\n * Force the suggestions to be displayed (Useful for buttons\n * e.g. for using JSuggestionField like a ComboBox)\n */\n", "repo_name": "biojava-master/", "id": 3246, "method_signature": "void showSuggest()"}, "3806": {"callee_method_names": ["RenderingHints.put", "RenderingHints.put", "RenderingHints.put", "Graphics2D.setRenderingHints"], "method_name": "KaplanMeierFigure.setRenderingHints", "method_implementation": "{\n    RenderingHints rh = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    rh.put(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);\n    rh.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_GASP);\n    rh.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n    g.setRenderingHints(rh);\n}", "repo_id": "9", "comment": "/**\n * Do higher quality rendering options\n *\n * @param g\n */\n", "repo_name": "biojava-master/", "id": 3806, "method_signature": "void setRenderingHints(Graphics2D)"}, "2714": {"callee_method_names": ["Reader.ready"], "method_name": "BufferedReaderBytesRead.read", "method_implementation": "{\n    synchronized (lock) {\n        ensureOpen();\n        if ((off < 0) || (off > cbuf.length) || (len < 0) || ((off + len) > cbuf.length) || ((off + len) < 0)) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n        int n = read1(cbuf, off, len);\n        if (n <= 0) {\n            return n;\n        }\n        while ((n < len) && in.ready()) {\n            int n1 = read1(cbuf, off + n, len - n);\n            if (n1 <= 0) {\n                break;\n            }\n            n += n1;\n        }\n        bytesRead = bytesRead + n;\n        return n;\n    }\n}", "repo_id": "9", "comment": "/**\n * Reads characters into a portion of an array.\n *\n * <p> This method implements the general contract of the corresponding\n * <code>{@link Reader#read(char[], int, int) read}</code> method of the\n * <code>{@link Reader}</code> class.  As an additional convenience, it\n * attempts to read as many characters as possible by repeatedly invoking\n * the <code>read</code> method of the underlying stream.  This iterated\n * <code>read</code> continues until one of the following conditions becomes\n * true: <ul>\n *\n *   <li> The specified number of characters have been read,\n *\n *   <li> The <code>read</code> method of the underlying stream returns\n *   <code>-1</code>, indicating end-of-file, or\n *\n *   <li> The <code>ready</code> method of the underlying stream\n *   returns <code>false</code>, indicating that further input requests\n *   would block.\n *\n * </ul> If the first <code>read</code> on the underlying stream returns\n * <code>-1</code> to indicate end-of-file then this method returns\n * <code>-1</code>.  Otherwise this method returns the number of characters\n * actually read.\n *\n * <p> Subclasses of this class are encouraged, but not required, to\n * attempt to read as many characters as possible in the same fashion.\n *\n * <p> Ordinarily this method takes characters from this stream's character\n * buffer, filling it from the underlying stream as necessary.  If,\n * however, the buffer is empty, the mark is not valid, and the requested\n * length is at least as large as the buffer, then this method will read\n * characters directly from the underlying stream into the given array.\n * Thus redundant <code>BufferedReaderBytesRead</code>s will not copy data\n * unnecessarily.\n *\n * @param      cbuf  Destination buffer\n * @param      off   Offset at which to start storing characters\n * @param      len   Maximum number of characters to read\n *\n * @return     The number of characters read, or -1 if the end of the\n *             stream has been reached\n *\n * @exception  IOException  If an I/O error occurs\n */\n", "repo_name": "biojava-master/", "id": 2714, "method_signature": "int read(char[], int, int)"}, "2688": {"callee_method_names": ["Sequence<C>.getCompoundSet", "Logger.error", "Enumeration<JarEntry>.getMessage"], "method_name": "Edit.getEmptySequence", "method_implementation": "{\n    Sequence<C> s = null;\n    try {\n        s = new BasicSequence<C>(\"\", editingSequence.getCompoundSet());\n    } catch (CompoundNotFoundException e) {\n        // should not happen\n        logger.error(\"Could not construct empty sequence. {}. This is most likely a bug.\", e.getMessage());\n    }\n    return s;\n}", "repo_id": "9", "comment": "/**\n * Returns an empty sequence with the given compound set of the editing\n * sequence\n */\n", "repo_name": "biojava-master/", "id": 2688, "method_signature": "Sequence<C> getEmptySequence(Sequence)"}, "1880": {"callee_method_names": ["QuatSymmetrySubunits.getOriginalCenters", "QuatSymmetrySubunits.getClusterIds", "List<Point3d>.size", "List<Point3d>.size", "List<Point3d>.size", "List<Point3d>.size", "List<Point3d>.get", "Matrix4d.transform", "List<Point3d>.size", "List<Integer>.get", "List<Integer>.get", "Point3d.distanceSquared", "List<Point3d>.get", "List<Integer>.size", "List<Integer>.add"], "method_name": "HelixSolver.getPermutation", "method_implementation": "{\n    double rmsdThresholdSq = Math.pow(this.parameters.getRmsdThreshold(), 2);\n    List<Point3d> centers = subunits.getOriginalCenters();\n    List<Integer> seqClusterId = subunits.getClusterIds();\n    List<Integer> permutations = new ArrayList<Integer>(centers.size());\n    double[] dSqs = new double[centers.size()];\n    boolean[] used = new boolean[centers.size()];\n    Arrays.fill(used, false);\n    for (int i = 0; i < centers.size(); i++) {\n        Point3d tCenter = new Point3d(centers.get(i));\n        transformation.transform(tCenter);\n        int permutation = -1;\n        double minDistSq = Double.MAX_VALUE;\n        for (int j = 0; j < centers.size(); j++) {\n            if (Objects.equals(seqClusterId.get(i), seqClusterId.get(j))) {\n                if (!used[j]) {\n                    double dSq = tCenter.distanceSquared(centers.get(j));\n                    if (dSq < minDistSq && dSq <= rmsdThresholdSq) {\n                        minDistSq = dSq;\n                        permutation = j;\n                        dSqs[j] = dSq;\n                    }\n                }\n            }\n        }\n        // can't map to itself\n        if (permutations.size() == permutation) {\n            permutation = -1;\n        }\n        if (permutation != -1) {\n            used[permutation] = true;\n        }\n        permutations.add(permutation);\n    }\n    return permutations;\n}", "repo_id": "9", "comment": "/**\n * Returns a permutation of subunit indices for the given helix\n * transformation. An index of -1 is used to indicate subunits that do not\n * superpose onto any other subunit.\n *\n * @param transformation\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1880, "method_signature": "List<Integer> getPermutation(Matrix4d)"}, "2061": {"callee_method_ids": [1581, 1585, 1585], "callee_method_names": ["SecStrucElement.getType", "SecStrucType.isBetaStrand", "SecStrucType.isHelixType", "SecStrucElement.getRange", "SecStrucElement.getRange"], "method_name": "CeSymmIterative.countHelixStrandSSE", "method_implementation": "{\n    List<SecStrucElement> sses = SecStrucTools.getSecStrucElements(SymmetryTools.getGroups(atoms));\n    int count = 0;\n    //keep track of different helix types\n    boolean helix = false;\n    int hEnd = 0;\n    for (SecStrucElement sse : sses) {\n        SecStrucType t = sse.getType();\n        if (t.isBetaStrand()) {\n            helix = false;\n            count++;\n        } else if (t.isHelixType()) {\n            if (helix) {\n                // If this helix is contiguous to the previous\n                if (sse.getRange().getStart().getSeqNum() + 1 == hEnd)\n                    hEnd = sse.getRange().getEnd().getSeqNum();\n                else\n                    count++;\n            } else\n                count++;\n        } else\n            helix = false;\n    }\n    return count;\n}", "repo_id": "9", "comment": "/**\n * Calculate the number of helix and strand SSE of a repeat.\n *\n * @param atoms\n *            Atom array of the repeat found\n * @return int number of helix or strand SSE\n */\n", "repo_name": "biojava-master/", "id": 2061, "method_signature": "int countHelixStrandSSE(Atom[])"}, "912": {"callee_method_ids": [1438, 903, 909, 911], "callee_method_names": ["CrystalBuilder.getUniqueInterfaces", "Logger.debug", "StructureInterfaceList.size", "StructureInterfaceList.calcAsas", "StructureInterfaceList.removeInterfacesBelowArea", "StructureInterfaceList.getClusters", "Logger.debug", "StructureInterfaceList.size"], "method_name": "StructureInterfaceList.calculateInterfaces", "method_implementation": "{\n    CrystalBuilder builder = new CrystalBuilder(struc);\n    StructureInterfaceList interfaces = builder.getUniqueInterfaces();\n    logger.debug(\"Calculating ASA for {} potential interfaces\", interfaces.size());\n    //fewer for performance\n    interfaces.//fewer for performance\n    calcAsas(//fewer for performance\n    StructureInterfaceList.DEFAULT_ASA_SPHERE_POINTS, Runtime.getRuntime().availableProcessors(), StructureInterfaceList.DEFAULT_MIN_COFACTOR_SIZE);\n    interfaces.removeInterfacesBelowArea();\n    interfaces.getClusters();\n    logger.debug(\"Found {} interfaces\", interfaces.size());\n    return interfaces;\n}", "repo_id": "9", "comment": "/**\n * Calculates the interfaces for a structure using default parameters\n * @param struc\n * @return\n */\n", "repo_name": "biojava-master/", "id": 912, "method_signature": "StructureInterfaceList calculateInterfaces(Structure)"}, "3552": {"callee_method_names": ["DecimalFormat.format", "DecimalFormat.format", "String.length"], "method_name": "CoxCoefficient.fmt", "method_implementation": "{\n    String value = \"\";\n    DecimalFormat dfe = new DecimalFormat(\"0.00E0\");\n    String dpad = \"0.\";\n    double p = 1.0;\n    for (int i = 0; i < (precision); i++) {\n        dpad = dpad + \"0\";\n        p = p / 10.0;\n    }\n    DecimalFormat df = new DecimalFormat(dpad);\n    if (Math.abs(d) >= p) {\n        value = df.format(d);\n    } else {\n        value = dfe.format(d);\n    }\n    int length = value.length();\n    int extra = pad - length;\n    if (extra > 0) {\n        for (int i = 0; i < extra; i++) {\n            value = \" \" + value;\n        }\n    }\n    return value;\n}", "repo_id": "9", "comment": "/**\n * @param d\n * @param precision\n * @param pad\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3552, "method_signature": "String fmt(Double, int, int)"}, "2513": {"callee_method_names": [], "method_name": "AAindexFactory.setAAIndexProvider", "method_implementation": "{\n    AAindexFactory.provider = provider;\n}", "repo_id": "9", "comment": "/**\n * Sets the singleton provider.\n * @param provider\n */\n", "repo_name": "biojava-master/", "id": 2513, "method_signature": "void setAAIndexProvider(AAIndexProvider)"}, "822": {"callee_method_names": [], "method_name": "AlternativeAlignment.rotateShiftAtoms", "method_implementation": "{\n    for (int i = 0; i < ca.length; i++) {\n        Atom c = ca[i];\n        Calc.rotate(c, currentRotMatrix);\n        Calc.shift(c, currentTranMatrix);\n        //System.out.println(\"after \" + c);\n        ca[i] = c;\n    }\n    //System.out.println(\"after \" + ca[0]);\n}", "repo_id": "9", "comment": "/**\n * rotate and shift atoms with currentRotMatrix and current Tranmatrix\n *\n * @param ca\n */\n", "repo_name": "biojava-master/", "id": 822, "method_signature": "void rotateShiftAtoms(Atom[])"}, "1884": {"callee_method_names": ["List<SubunitCluster>.size", "List<SubunitCluster>.get", "List<String>.add", "List<SubunitCluster>.get"], "method_name": "QuatSymmetrySubunits.getChainIds", "method_implementation": "{\n    List<String> chains = new ArrayList<String>(getSubunitCount());\n    // Loop through all subunits in the clusters and fill Lists\n    for (int c = 0; c < clusters.size(); c++) {\n        for (int s = 0; s < clusters.get(c).size(); s++) chains.add(clusters.get(c).getSubunits().get(s).getName());\n    }\n    return chains;\n}", "repo_id": "9", "comment": "/**\n * This method is provisional and should only be used for coloring Subunits.\n * A new coloring schema has to be implemented to allow the coloring of\n * Subunits, without implying one Subunit = one Chain.\n *\n * @return A List of the Chain Ids of each Subunit\n */\n", "repo_name": "biojava-master/", "id": 1884, "method_signature": "List<String> getChainIds()"}, "1812": {"callee_method_names": ["ReadWriteLock.readLock", "Logger.trace", "File.exists", "String.equals", "File.lastModified", "Calendar.setTime", "Calendar.add", "Calendar.getTimeInMillis", "Logger.info", "Logger.trace", "ReadWriteLock.readLock"], "method_name": "EcodInstallation.domainsAvailable", "method_implementation": "{\n    domainsFileLock.readLock().lock();\n    logger.trace(\"LOCK readlock\");\n    try {\n        File f = getDomainFile();\n        if (!(f.exists() && FileDownloadUtils.validateFile(f)))\n            return false;\n        // Re-download old copies of \"latest\"\n        if (updateFrequency != null && requestedVersion.equals(DEFAULT_VERSION)) {\n            long mod = f.lastModified();\n            // Time of last update\n            Date lastUpdate = new Date();\n            Calendar cal = Calendar.getInstance();\n            cal.setTime(lastUpdate);\n            cal.add(Calendar.DAY_OF_WEEK, -updateFrequency);\n            long updateTime = cal.getTimeInMillis();\n            // Check if file predates last update\n            if (mod < updateTime) {\n                logger.info(\"{} is out of date.\", f);\n                return false;\n            }\n        }\n        return true;\n    } finally {\n        logger.trace(\"UNLOCK readlock\");\n        domainsFileLock.readLock().unlock();\n    }\n}", "repo_id": "9", "comment": "/**\n * Checks that the domains file has been downloaded\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1812, "method_signature": "boolean domainsAvailable()"}, "2531": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum80", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum80\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 80 matrix by Henikoff & Henikoff\n * @return Blosum 80 matrix\n */\n", "repo_name": "biojava-master/", "id": 2531, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum80()"}, "1624": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getSequenceCoverageThreshold", "method_implementation": "{\n    return sequenceCoverageThreshold;\n}", "repo_id": "9", "comment": "/**\n * The minimum coverage of the sequence alignment between two subunits to be\n * clustered together.\n *\n * @return sequenceCoverageThreshold\n */\n", "repo_name": "biojava-master/", "id": 1624, "method_signature": "double getSequenceCoverageThreshold()"}, "2155": {"callee_method_names": [], "method_name": "StructureImpl.hasJournalArticle", "method_implementation": "{\n    return this.pdbHeader.hasJournalArticle();\n}", "repo_id": "9", "comment": "/**\n * Return whether or not the entry has an associated journal article\n * or publication. The JRNL section is not mandatory and thus may not be\n * present.\n * @return flag if a JournalArticle could be found.\n */\n", "repo_name": "biojava-master/", "id": 2155, "method_signature": "boolean hasJournalArticle()"}, "1637": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setSuperpositionAlgorithm", "method_implementation": "{\n    this.superpositionAlgorithm = superpositionAlgorithm;\n}", "repo_id": "9", "comment": "/**\n * Method to cluster subunits.\n *\n * @param superpositionAlgorithm\n */\n", "repo_name": "biojava-master/", "id": 1637, "method_signature": "void setSuperpositionAlgorithm(String)"}, "2817": {"callee_method_names": [], "method_name": "IOUtils.getGCGType", "method_implementation": "{\n    return (cs == DNACompoundSet.getDNACompoundSet() || cs == AmbiguityDNACompoundSet.getDNACompoundSet()) ? \"D\" : (cs == RNACompoundSet.getRNACompoundSet() || cs == AmbiguityRNACompoundSet.getRNACompoundSet()) ? \"R\" : \"P\";\n}", "repo_id": "9", "comment": "/**\n * Determines GCG type\n * @param cs compound set of sequences\n * @return GCG type\n */\n", "repo_name": "biojava-master/", "id": 2817, "method_signature": "String getGCGType(CompoundSet)"}, "687": {"callee_method_names": ["List<Atom[]>.size", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.get", "List<Atom[]>.get", "Matrix.get", "Matrix.set", "Matrix.set", "Matrix.get", "Matrix.get", "Matrix.set", "Matrix.set", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.set", "Matrix.get", "Matrix.get", "Matrix.get"], "method_name": "MultipleAlignmentScorer.getMCScore", "method_implementation": "{\n    int size = trans.size();\n    int length = trans.get(0).length;\n    Matrix residueDistances = new Matrix(size, length, -1);\n    double scoreMC = 0.0;\n    int openGaps = 0;\n    int extensionGaps = 0;\n    // Calculate the average residue distances\n    for (int r1 = 0; r1 < size; r1++) {\n        boolean gapped = false;\n        for (int c = 0; c < trans.get(r1).length; c++) {\n            Atom refAtom = trans.get(r1)[c];\n            // Calculate the gap extension and opening on the fly\n            if (refAtom == null) {\n                if (gapped)\n                    extensionGaps++;\n                else {\n                    gapped = true;\n                    openGaps++;\n                }\n                continue;\n            } else\n                gapped = false;\n            for (int r2 = r1 + 1; r2 < size; r2++) {\n                Atom atom = trans.get(r2)[c];\n                if (atom != null) {\n                    double distance = Calc.getDistance(refAtom, atom);\n                    if (residueDistances.get(r1, c) == -1) {\n                        residueDistances.set(r1, c, 1 + distance);\n                    } else {\n                        residueDistances.set(r1, c, residueDistances.get(r1, c) + distance);\n                    }\n                    if (residueDistances.get(r2, c) == -1) {\n                        residueDistances.set(r2, c, 1 + distance);\n                    } else {\n                        residueDistances.set(r2, c, residueDistances.get(r2, c) + distance);\n                    }\n                }\n            }\n        }\n    }\n    for (int c = 0; c < length; c++) {\n        int nonNullRes = 0;\n        for (int r = 0; r < size; r++) {\n            if (residueDistances.get(r, c) != -1)\n                nonNullRes++;\n        }\n        for (int r = 0; r < size; r++) {\n            if (residueDistances.get(r, c) != -1) {\n                residueDistances.set(r, c, residueDistances.get(r, c) / nonNullRes);\n            }\n        }\n    }\n    // Sum all the aligned residue scores\n    for (int row = 0; row < size; row++) {\n        for (int col = 0; col < length; col++) {\n            if (residueDistances.get(row, col) == -1)\n                continue;\n            double d1 = residueDistances.get(row, col);\n            double resScore = 20.0 / (1 + (d1 * d1) / (d0 * d0));\n            scoreMC += resScore - A;\n        }\n    }\n    // Apply the Gap penalty and return\n    return scoreMC - (openGaps * gapOpen + extensionGaps * gapExtension);\n}", "repo_id": "9", "comment": "/**\n * Calculates the MC score, specific for the MultipleAlignment algorithm.\n * The score function is modified from the original CEMC paper, making it\n * continuous and differentiable.\n * <p>\n * The maximum score of a match is 20, and the penalties for gaps are part\n * of the input.\n * <p>\n * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n * length.\n *\n * @param transformed\n *            List of transformed Atom arrays\n * @param d0\n *            parameter for the half-score distance\n * @param gapOpen\n *            penalty for gap opening (reasonable values are in the range\n *            (1.0-20.0)\n * @param gapExtension\n *            penalty for extending a gap (reasonable values are in the\n *            range (0.5-10.0)\n * @param A\n *            the distance cutoff penalization\n * @return the value of the score\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 687, "method_signature": "double getMCScore(List, double, double, double, double)"}, "625": {"callee_method_names": [], "method_name": "AtomCache.getCachePath", "method_implementation": "{\n    return cachePath;\n}", "repo_id": "9", "comment": "/**\n * Returns the path that contains the caching file for utility data, such as domain definitions.\n *\n * @return\n */\n", "repo_name": "biojava-master/", "id": 625, "method_signature": "String getCachePath()"}, "1509": {"callee_method_names": [], "method_name": "SuperPositionQCP.getWeightedRmsd", "method_implementation": "{\n    set(moved, fixed, weight);\n    return getRmsd();\n}", "repo_id": "9", "comment": "/**\n * @param fixed\n * @param moved\n * @param weight\n *            array of weigths for each equivalent point position\n * @return weighted RMSD.\n */\n", "repo_name": "biojava-master/", "id": 1509, "method_signature": "double getWeightedRmsd(Point3d[], Point3d[], double[])"}, "2640": {"callee_method_names": [], "method_name": "DNASequence.getComplement", "method_implementation": "{\n    return new ComplementSequenceView<NucleotideCompound>(this);\n}", "repo_id": "9", "comment": "/**\n * Returns a Sequence which will complement every base\n */\n", "repo_name": "biojava-master/", "id": 2640, "method_signature": "SequenceView<NucleotideCompound> getComplement()"}, "2010": {"callee_method_names": [], "method_name": "Tetrahedron.setInscribedRadius", "method_implementation": "{\n    double side = getSideLengthFromInscribedRadius(radius);\n    this.circumscribedRadius = getCircumscribedRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Sets the radius of an inscribed sphere, that is tangent to each\n * of the tetrahedron's faces\n * @param inscribedRadius the inscribedRadius to set\n */\n", "repo_name": "biojava-master/", "id": 2010, "method_signature": "void setInscribedRadius(double)"}, "1990": {"callee_method_names": ["Matrix4d.mul", "Matrix4d.set"], "method_name": "RotationAxisAligner.calcZDirection", "method_implementation": "{\n    calcBoundaries();\n    // if the longer part of the structure faces towards the back (-z direction),\n    // rotate around y-axis so the longer part faces the viewer (+z direction)\n    if (Math.abs(minBoundary.z) > Math.abs(maxBoundary.z)) {\n        Matrix4d rot = flipY();\n        rot.mul(transformationMatrix);\n        transformationMatrix.set(rot);\n    }\n}", "repo_id": "9", "comment": "/*\n\t * Modifies the rotation part of the transformation axis for\n\t * a Cn symmetric complex, so that the narrower end faces the\n\t * viewer, and the wider end faces away from the viewer. Example: 3LSV\n\t */\n", "repo_name": "biojava-master/", "id": 1990, "method_signature": "void calcZDirection()"}, "2030": {"callee_method_names": [], "method_name": "RectangularPrism.getVertices", "method_implementation": "{\n    double x = 0.5 * width;\n    double y = 0.5 * height;\n    double z = 0.5 * length;\n    Point3d[] vertices = new Point3d[8];\n    vertices[0] = new Point3d(-x, -y, z);\n    vertices[1] = new Point3d(-x, y, z);\n    vertices[2] = new Point3d(x, y, z);\n    vertices[3] = new Point3d(x, -y, z);\n    vertices[4] = new Point3d(-x, -y, -z);\n    vertices[5] = new Point3d(-x, y, -z);\n    vertices[6] = new Point3d(x, y, -z);\n    vertices[7] = new Point3d(x, -y, -z);\n    return vertices;\n}", "repo_id": "9", "comment": "/**\n * Returns the vertices of an n-fold polygon of given radius and center\n * @param n\n * @param radius\n * @param center\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2030, "method_signature": "Point3d[] getVertices()"}, "2417": {"callee_method_names": [], "method_name": "Location.endsAfter", "method_implementation": "{\n    if (isSameStrand(other)) {\n        return mEnd > other.mEnd;\n    } else {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    }\n}", "repo_id": "9", "comment": "/**\n * Check if this location ends after other location ends.\n * The locations may overlap.\n *\n * @param other The location to compare.\n * @return True if location ends after other.\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2417, "method_signature": "boolean endsAfter(Location)"}, "1995": {"callee_method_names": ["RotationGroup.getPointGroup", "RotationGroup.getPointGroup"], "method_name": "RotationAxisAligner.refineReferenceVector", "method_implementation": "{\n    referenceVector = new Vector3d(Y_AXIS);\n    if (rotationGroup.getPointGroup().startsWith(\"C\")) {\n        referenceVector = getReferenceAxisCylicWithSubunitAlignment();\n    } else if (rotationGroup.getPointGroup().startsWith(\"D\")) {\n        referenceVector = getReferenceAxisDihedralWithSubunitAlignment();\n    }\n    referenceVector = orthogonalize(principalRotationVector, referenceVector);\n}", "repo_id": "9", "comment": "/**\n * Returns a normalized vector that represents a minor rotation axis, except\n * for Cn, this represents an axis orthogonal to the principal axis.\n * @return minor rotation axis\n */\n", "repo_name": "biojava-master/", "id": 1995, "method_signature": "void refineReferenceVector()"}, "3791": {"callee_method_names": ["DecimalFormat.format", "DecimalFormat.format", "String.length"], "method_name": "KaplanMeierFigure.fmt", "method_implementation": "{\n    String value = \"\";\n    DecimalFormat dfe = new DecimalFormat(\"0.00E0\");\n    String dpad = \"0.\";\n    double p = 1.0;\n    for (int i = 0; i < (precision); i++) {\n        dpad = dpad + \"0\";\n        p = p / 10.0;\n    }\n    DecimalFormat df = new DecimalFormat(dpad);\n    if (Math.abs(d) >= p) {\n        value = df.format(d);\n    } else {\n        value = dfe.format(d);\n    }\n    int length = value.length();\n    int extra = pad - length;\n    if (extra > 0) {\n        for (int i = 0; i < extra; i++) {\n            value = \" \" + value;\n        }\n    }\n    return value;\n}", "repo_id": "9", "comment": "/**\n * @param d\n * @param precision\n * @param pad\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3791, "method_signature": "String fmt(Double, int, int)"}, "249": {"callee_method_names": ["Map<String, ProteinModification>.get"], "method_name": "ProteinModificationRegistry.getById", "method_implementation": "{\n    lazyInit();\n    return byId.get(id);\n}", "repo_id": "9", "comment": "/**\n * @param id modification ID.\n * @return ProteinModification that has the corresponding ID.\n */\n", "repo_name": "biojava-master/", "id": 249, "method_signature": "ProteinModification getById(String)"}, "3137": {"callee_method_names": ["File.exists", "File.length", "CifFileReader.read", "StringBuilder.append", "StringBuilder.indexOf", "StringBuilder.indexOf", "StringBuilder.replace"], "method_name": "UniprotProxySequenceReader.fetchFromCache", "method_implementation": "{\n    int index;\n    File f = new File(uniprotDirectoryCache + File.separatorChar + key + \".xml\");\n    StringBuilder sb = new StringBuilder();\n    if (f.exists()) {\n        char[] data;\n        try (FileReader fr = new FileReader(f)) {\n            int size = (int) f.length();\n            data = new char[size];\n            fr.read(data);\n        }\n        sb.append(data);\n        //strip out name space stuff to make it easier on xpath\n        index = sb.indexOf(\"xmlns=\");\n        if (index != -1) {\n            int lastIndex = sb.indexOf(\">\", index);\n            sb.replace(index, lastIndex, \"\");\n        }\n    }\n    return sb;\n}", "repo_id": "9", "comment": "/**\n * @param key\n * @return A string containing the contents of entry specified by key and if not found returns an empty string\n * @throws FileNotFoundException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 3137, "method_signature": "StringBuilder fetchFromCache(String)"}, "1842": {"callee_method_names": ["ArrayList<Chain>.addAll", "ArrayList<Chain>.addAll", "ArrayList<Chain>.addAll", "ArrayList<Chain>.trimToSize"], "method_name": "Model.getChains", "method_implementation": "{\n    ArrayList<Chain> chains = new ArrayList<>();\n    chains.addAll(polyChains);\n    chains.addAll(nonPolyChains);\n    chains.addAll(waterChains);\n    chains.trimToSize();\n    return chains;\n}", "repo_id": "9", "comment": "/**\n * Get all chains: polymeric, non-polymeric and water\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1842, "method_signature": "List<Chain> getChains()"}, "840": {"callee_method_names": [], "method_name": "GroupAsa.getAsaU", "method_implementation": "{\n    return asaU;\n}", "repo_id": "9", "comment": "/**\n * Returns the ASA of the residue in the uncomplexed state\n * @return\n */\n", "repo_name": "biojava-master/", "id": 840, "method_signature": "double getAsaU()"}, "3750": {"callee_method_names": ["HashMap<String, String>.size", "ArrayList<String>.size", "HashMap<String, String>.containsKey", "HashMap<String, String>.put", "ArrayList<String>.add", "ArrayList<String>.get"], "method_name": "WorkSheet.getRandomDataColumns", "method_implementation": "{\n    ArrayList<String> randomColumns = new ArrayList<String>();\n    HashMap<String, String> picked = new HashMap<String, String>();\n    while (picked.size() < number) {\n        double v = Math.random();\n        int index = (int) (v * columns.size());\n        if (picked.containsKey(String.valueOf(index))) {\n            continue;\n        }\n        picked.put(String.valueOf(index), String.valueOf(index));\n        randomColumns.add(columns.get(index));\n    }\n    return randomColumns;\n}", "repo_id": "9", "comment": "/**\n * @param number\n * @param columns\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3750, "method_signature": "ArrayList<String> getRandomDataColumns(int, ArrayList)"}, "1097": {"callee_method_names": ["String.toUpperCase", "ChemicalComponentDictionary.getChemComp", "Logger.warn", "int.getMessage", "Logger.warn", "ChemCompProvider.getChemComp"], "method_name": "DownloadChemCompProvider.getChemComp", "method_implementation": "{\n    // make sure we work with upper case records\n    recordName = recordName.toUpperCase().trim();\n    boolean haveFile = true;\n    if (\"?\".equals(recordName)) {\n        return null;\n    }\n    if (fileIsAbsent(recordName)) {\n        // check if we should install all components\n        checkDoFirstInstall();\n    }\n    if (fileIsAbsent(recordName)) {\n        // we previously have installed already the definitions,\n        // just do an incrememntal update\n        haveFile = downloadChemCompRecord(recordName);\n    }\n    // Added check that download was successful and chemical component is available.\n    if (haveFile) {\n        String filename = getLocalFileName(recordName);\n        try {\n            ChemComp chemComp;\n            try {\n                ChemicalComponentDictionary dict = ChemCompConverter.fromPath(Paths.get(filename));\n                chemComp = dict.getChemComp(recordName);\n            } catch (ParsingException e) {\n                // happens for corrupt files\n                chemComp = null;\n            }\n            // May be null if the file was corrupt. Fall back on ReducedChemCompProvider in that case\n            if (chemComp != null) {\n                return chemComp;\n            }\n        } catch (IOException e) {\n            logger.warn(\"Could not download chemical component file {} for {}. Error: {}. Now trying to use the \" + \"local chemical component definitions.\", filename, recordName, e.getMessage());\n        }\n    }\n    // see https://github.com/biojava/biojava/issues/315\n    // probably a network error happened. Try to use the ReducedChemCOmpProvider\n    if (fallback == null) {\n        fallback = new ReducedChemCompProvider();\n    }\n    logger.warn(\"Falling back to ReducedChemCompProvider for {}. This could indicate a network error.\", recordName);\n    return fallback.getChemComp(recordName);\n}", "repo_id": "9", "comment": "/**\n * Loads the definitions for this {@link ChemComp} from a local file and instantiates a new object.\n *\n * @param recordName the ID of the {@link ChemComp}\n * @return a new {@link ChemComp} definition.\n */\n", "repo_name": "biojava-master/", "id": 1097, "method_signature": "ChemComp getChemComp(String)"}, "2545": {"callee_method_names": [], "method_name": "Hsp.getHspQseq", "method_implementation": "{\n    return hspQseq;\n}", "repo_id": "9", "comment": "/**\n * HSP aligned query sequence string\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2545, "method_signature": "String getHspQseq()"}, "1792": {"callee_method_names": [], "method_name": "EcodDomain.getRange", "method_implementation": "{\n    return range;\n}", "repo_id": "9", "comment": "/**\n * Get the range of this domain, in PDB residue numbers (mmCif's\n * _pdbx_poly_seq_scheme.pdb_seq_num and pdb_ins_code).\n * @return The chain and residue range, e.g. \"A:1-100\"\n */\n", "repo_name": "biojava-master/", "id": 1792, "method_signature": "String getRange()"}, "923": {"callee_method_names": ["Grid.getIAtoms", "Grid.getJAtoms", "Grid.getCutoff", "Point3d[].distance", "List<Contact>.add", "Point3d[].distance", "List<Contact>.add"], "method_name": "GridCell.getContactsToOtherCell", "method_implementation": "{\n    List<Contact> contacts = new ArrayList<Contact>();\n    Point3d[] iAtoms = grid.getIAtoms();\n    Point3d[] jAtoms = grid.getJAtoms();\n    double cutoff = grid.getCutoff();\n    if (jAtoms == null) {\n        for (int i : iIndices) {\n            for (int j : otherCell.iIndices) {\n                if (j > i) {\n                    double distance = iAtoms[i].distance(iAtoms[j]);\n                    if (distance < cutoff)\n                        contacts.add(new Contact(i, j, distance));\n                }\n            }\n        }\n    } else {\n        for (int i : iIndices) {\n            for (int j : otherCell.jIndices) {\n                double distance = iAtoms[i].distance(jAtoms[j]);\n                if (distance < cutoff)\n                    contacts.add(new Contact(i, j, distance));\n            }\n        }\n    }\n    return contacts;\n}", "repo_id": "9", "comment": "/**\n * Calculates all distances of atoms between this cell and the given cell returning those that are\n * within the given cutoff as a list of Contacts containing the indices of the pair and the calculated distance.\n *\n * @param otherCell\n * @param iAtoms the first set of atom coordinates to which the iIndices correspond\n * @param jAtoms the second set of atom coordinates to which the jIndices correspond, if null distances are within the iAtoms only\n * @param cutoff\n * @return\n */\n", "repo_name": "biojava-master/", "id": 923, "method_signature": "List<Contact> getContactsToOtherCell(GridCell)"}, "2397": {"callee_method_names": [], "method_name": "Location.union", "method_implementation": "{\n    if (!isSameStrand(other)) {\n        throw new IllegalArgumentException(\"Locations are on opposite strands.\");\n    } else {\n        int start = (other.mStart < mStart) ? other.mStart : mStart;\n        int end = (other.mEnd > mEnd) ? other.mEnd : mEnd;\n        return new Location(start, end);\n    }\n}", "repo_id": "9", "comment": "/**\n *  Return the union.\n * <br>\n *\n * @param other The location to join.\n * @return The union is a range that starts at the lesser of the two starting indices and ends at the\n * greater of the two ends.\n * @throws IllegalArgumentException Locations are on opposite strands.\n */\n", "repo_name": "biojava-master/", "id": 2397, "method_signature": "Location union(Location)"}, "3695": {"callee_method_names": ["LinkedHashMap<String,StrataInfo>.keySet", "LinkedHashMap<String,StrataInfo>.get", "LinkedHashMap<String,StrataInfo>.put"], "method_name": "SurvFitInfo.addStrataInfoHashMap", "method_implementation": "{\n    for (String key : siHashMap.keySet()) {\n        StrataInfo si = siHashMap.get(key);\n        strataInfoHashMap.put(label + \" \" + key, si);\n    }\n}", "repo_id": "9", "comment": "/**\n * @param siHashMap\n * @param label\n */\n", "repo_name": "biojava-master/", "id": 3695, "method_signature": "void addStrataInfoHashMap(LinkedHashMap, String)"}, "1217": {"callee_method_names": ["Chain.getAtomGroups", "Group.getResidueNumber", "Group.getResidueNumber", "Group.getResidueNumber", "ResidueNumber.equals", "Chain.addGroup", "Logger.debug"], "method_name": "CifStructureConsumerImpl.removeSeqResHeterogeneity", "method_implementation": "{\n    Chain trimmedChain = new ChainImpl();\n    ResidueNumber lastResNum = null;\n    for (Group g : c.getAtomGroups()) {\n        // note we have to deep copy this, otherwise they stay linked and would get altered in addGroup(g)\n        ResidueNumber currentResNum = new ResidueNumber(g.getResidueNumber().getChainName(), g.getResidueNumber().getSeqNum(), g.getResidueNumber().getInsCode());\n        if (lastResNum == null || !lastResNum.equals(currentResNum)) {\n            trimmedChain.addGroup(g);\n        } else {\n            logger.debug(\"Removing seqres group because it seems to be repeated in entity_poly_seq, most likely has hetero='y': {}\", g);\n        }\n        lastResNum = currentResNum;\n    }\n    return trimmedChain;\n}", "repo_id": "9", "comment": "/**\n * The method will return a new reference to a Chain with any consecutive groups\n * having same residue numbers removed.\n * This is necessary to solve the microheterogeneity issue in entries like 3u7t (see github issue #160)\n */\n", "repo_name": "biojava-master/", "id": 1217, "method_signature": "Chain removeSeqResHeterogeneity(Chain)"}, "462": {"callee_method_names": [], "method_name": "QsAlignParameters.getMaxOrientationAngle", "method_implementation": "{\n    return maxOrientationAngle;\n}", "repo_id": "9", "comment": "/**\n * The maximum orientation angle between two equivalent Subunits, in\n * radians. Range [0, Pi].\n *\n * @return the maximum orientation angle\n */\n", "repo_name": "biojava-master/", "id": 462, "method_signature": "double getMaxOrientationAngle()"}, "389": {"callee_method_names": ["Atom.getY", "Atom.getY", "Atom.getX", "Atom.getX"], "method_name": "Calc.calcRotationAngleInDegrees", "method_implementation": "{\n    // calculate the angle theta from the deltaY and deltaX values\n    // (atan2 returns radians values from [-PI,PI])\n    // 0 currently points EAST.\n    // NOTE: By preserving Y and X param order to atan2,  we are expecting\n    // a CLOCKWISE angle direction.\n    double theta = Math.atan2(targetPt.getY() - centerPt.getY(), targetPt.getX() - centerPt.getX());\n    // rotate the theta angle clockwise by 90 degrees\n    // (this makes 0 point NORTH)\n    // NOTE: adding to an angle rotates it clockwise.\n    // subtracting would rotate it counter-clockwise\n    theta += Math.PI / 2.0;\n    // convert from radians to degrees\n    // this will give you an angle from [0->270],[-180,0]\n    double angle = Math.toDegrees(theta);\n    // convert to positive range [0-360)\n    // since we want to prevent negative angles, adjust them now.\n    // we can assume that atan2 will not return a negative value\n    // greater than one partial rotation\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}", "repo_id": "9", "comment": "/**\n * Calculates the angle from centerPt to targetPt in degrees. The return\n * should range from [0,360), rotating CLOCKWISE, 0 and 360 degrees\n * represents NORTH, 90 degrees represents EAST, etc...\n *\n * Assumes all points are in the same coordinate space. If they are not, you\n * will need to call SwingUtilities.convertPointToScreen or equivalent on\n * all arguments before passing them to this function.\n *\n * @param centerPt\n *            Point we are rotating around.\n * @param targetPt\n *            Point we want to calculate the angle to.\n * @return angle in degrees.  This is the angle from centerPt to targetPt.\n */\n", "repo_name": "biojava-master/", "id": 389, "method_signature": "double calcRotationAngleInDegrees(Atom, Atom)"}, "327": {"callee_method_names": ["List<Site>.size", "FastaSequence.getResidue"], "method_name": "TestAcetylation.testAcetylation", "method_implementation": "{\n    File localFile = getLocalFileName(Dataset.ACETYLATION);\n    List<Site> sites = Site.parseSites(localFile);\n    assertTrue(sites.size() > 0);\n    for (Site s : sites) {\n        assertTrue(s.getResidue() != null);\n    }\n}", "repo_id": "9", "comment": "/**\n * Tests that the acetylation file can get parsed without problems.\n */\n", "repo_name": "biojava-master/", "id": 327, "method_signature": "void testAcetylation()"}, "2274": {"callee_method_ids": [641], "callee_method_names": ["AtomCache.getFileParsingParams", "FileParsingParameters.setParseBioAssembly", "AtomCache.setFiletype", "Structure.getPDBHeader", "Structure.getPDBHeader"], "method_name": "TestDifficultMmCIFFiles.test2KLI", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    StructureIO.setAtomCache(cache);\n    FileParsingParameters params = cache.getFileParsingParams();\n    params.setParseBioAssembly(true);\n    StructureIO.setAtomCache(cache);\n    cache.setFiletype(StructureFiletype.CIF);\n    Structure sCif = StructureIO.getStructure(\"2KLI\");\n    assertNotNull(sCif);\n    assertNotNull(sCif.getPDBHeader().getBioAssemblies());\n    Map<Integer, BioAssemblyInfo> mapCif = sCif.getPDBHeader().getBioAssemblies();\n    assertNotNull(mapCif);\n}", "repo_id": "9", "comment": "/**\n * The last category in 2KLI mmCIF file is _pdbx_struct_oper_list, which is needed for\n * the biounit annotation.\n * This tests makes sure that the last category in a mmCIF file is not missed because\n * of its position as last one in file.\n * @throws IOException\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 2274, "method_signature": "void test2KLI()"}, "2065": {"callee_method_names": ["Map<Integer,Integer>.keySet", "List<Integer>.size", "List<Integer>.get", "Map<Integer,Integer>.get", "List<Integer>.set", "Integer.equals", "List<Integer>.get", "List<Integer>.remove", "List<Integer>.get", "Map<Integer,Integer>.size", "List<Integer>.size", "List<Integer>.get", "List<Integer>.get", "Map<Integer, Integer>.put"], "method_name": "SequenceFunctionRefiner.applyAlignmentAndCheckCycles", "method_implementation": "{\n    // Convert to lists to establish a fixed order (avoid concurrent modification)\n    // currently unmodified\n    List<Integer> preimage = new ArrayList<Integer>(alignmentMap.keySet());\n    List<Integer> image = new ArrayList<Integer>(preimage);\n    for (int n = 1; n <= k; n++) {\n        // apply alignment\n        for (int i = 0; i < image.size(); i++) {\n            final Integer pre = image.get(i);\n            final Integer post = (pre == null ? null : alignmentMap.get(pre));\n            image.set(i, post);\n            // Make cycles ineligible\n            if (post != null && post.equals(preimage.get(i))) {\n                // Could be O(n) with List impl\n                eligible.remove(preimage.get(i));\n            }\n        }\n    }\n    Map<Integer, Integer> imageMap = new HashMap<Integer, Integer>(alignmentMap.size());\n    // now populate with actual values\n    for (int i = 0; i < preimage.size(); i++) {\n        Integer pre = preimage.get(i);\n        Integer postK = image.get(i);\n        imageMap.put(pre, postK);\n    }\n    return imageMap;\n}", "repo_id": "9", "comment": "/**\n * Like {@link AlignmentTools#applyAlignment(Map, int)}, returns a map of k applications of alignmentMap. However,\n * it also sets loops of size less than k as ineligible.\n *\n * @param alignmentMap\n *            f(x)\n * @param k\n * @param eligible\n *            Eligible residues. Residues from small cycles are removed.\n * @return f^k(x)\n */\n", "repo_name": "biojava-master/", "id": 2065, "method_signature": "Map<Integer,Integer> applyAlignmentAndCheckCycles(Map, int, List)"}, "1630": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getStructureCoverageThreshold", "method_implementation": "{\n    return structureCoverageThreshold;\n}", "repo_id": "9", "comment": "/**\n * The minimum coverage of the structure alignment between two subunits to be\n * clustered together.\n *\n * @return structureCoverageThreshold\n */\n", "repo_name": "biojava-master/", "id": 1630, "method_signature": "double getStructureCoverageThreshold()"}, "3219": {"callee_method_names": ["Logger.info", "GenbankReader<ProteinSequence, AminoAcidCompound>.process", "LinkedHashMap<String, ProteinSequence>.get", "LinkedHashMap<String, ProteinSequence>.get", "LinkedHashMap<String, ProteinSequence>.get", "LinkedHashMap<String, ProteinSequence>.get", "LinkedHashMap<String, ProteinSequence>.get", "LinkedHashMap<String, ProteinSequence>.size", "LinkedHashMap<String, ProteinSequence>.get", "LinkedHashMap<String, ProteinSequence>.get", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "ProteinSequence.getAccession", "GenbankReader<ProteinSequence, AminoAcidCompound>.isClosed", "Logger.info", "GenbankReader<DNASequence, NucleotideCompound>.process", "LinkedHashMap<String, DNASequence>.size", "LinkedHashMap<String, DNASequence>.get", "LinkedHashMap<String, DNASequence>.get", "DNASequence.getAccession", "DNASequence.getAccession", "DNASequence.getAccession", "DNASequence.getAccession", "GenbankReader<DNASequence, NucleotideCompound>.isClosed"], "method_name": "GenbankReaderTest.testProcess", "method_implementation": "{\n    logger.info(\"process protein\");\n    InputStream inStream = this.getClass().getResourceAsStream(\"/BondFeature.gb\");\n    assertNotNull(inStream);\n    GenbankReader<ProteinSequence, AminoAcidCompound> genbankProtein = new GenbankReader<>(inStream, new GenericGenbankHeaderParser<>(), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet()));\n    LinkedHashMap<String, ProteinSequence> proteinSequences = genbankProtein.process();\n    assertThat(proteinSequences.get(\"NP_000257\").getComments().get(0), is(\"VALIDATED REFSEQ: This record has undergone validation or\\n\" + \"preliminary review. The reference sequence was derived from\\n\" + \"AL034370.1, X65882.1 and BE139596.1.\\n\" + \"Summary: NDP is the genetic locus identified as harboring mutations\\n\" + \"that result in Norrie disease. Norrie disease is a rare genetic\\n\" + \"disorder characterized by bilateral congenital blindness that is\\n\" + \"caused by a vascularized mass behind each lens due to a\\n\" + \"maldeveloped retina (pseudoglioma).\\n\" + \"Publication Note:  This RefSeq record includes a subset of the\\n\" + \"publications that are available for this gene. Please see the\\n\" + \"Entrez Gene record to access additional publications.\"));\n    assertThat(proteinSequences.get(\"NP_000257\").getReferences().size(), is(11));\n    assertThat(proteinSequences.get(\"NP_000257\").getReferences().get(0).getAuthors(), is(\"Lev,D., Weigl,Y., Hasan,M., Gak,E., Davidovich,M., Vinkler,C.,\\n\" + \"Leshinsky-Silver,E., Lerman-Sagie,T. and Watemberg,N.\"));\n    assertThat(proteinSequences.get(\"NP_000257\").getReferences().get(1).getTitle(), is(\"Novel mutations in Norrie disease gene in Japanese patients with\\n\" + \"Norrie disease and familial exudative vitreoretinopathy\"));\n    assertThat(proteinSequences.get(\"NP_000257\").getReferences().get(10).getJournal(), is(\"Nat. Genet. 1 (3), 199-203 (1992)\"));\n    assertNotNull(proteinSequences);\n    assertEquals(1, proteinSequences.size());\n    ProteinSequence proteinSequence = proteinSequences.get(\"NP_000257\");\n    assertNotNull(proteinSequences.get(\"NP_000257\"));\n    assertEquals(\"NP_000257\", proteinSequence.getAccession().getID());\n    assertEquals(\"4557789\", proteinSequence.getAccession().getIdentifier());\n    assertEquals(\"GENBANK\", proteinSequence.getAccession().getDataSource().name());\n    assertEquals(1, proteinSequence.getAccession().getVersion().intValue());\n    assertTrue(genbankProtein.isClosed());\n    logger.info(\"process DNA\");\n    inStream = this.getClass().getResourceAsStream(\"/NM_000266.gb\");\n    assertNotNull(inStream);\n    GenbankReader<DNASequence, NucleotideCompound> genbankDNA = new GenbankReader<>(inStream, new GenericGenbankHeaderParser<>(), new DNASequenceCreator(DNACompoundSet.getDNACompoundSet()));\n    LinkedHashMap<String, DNASequence> dnaSequences = genbankDNA.process();\n    assertNotNull(dnaSequences);\n    assertEquals(1, dnaSequences.size());\n    DNASequence dnaSequence = dnaSequences.get(\"NM_000266\");\n    assertNotNull(dnaSequences.get(\"NM_000266\"));\n    assertEquals(\"NM_000266\", dnaSequence.getAccession().getID());\n    assertEquals(\"223671892\", dnaSequence.getAccession().getIdentifier());\n    assertEquals(\"GENBANK\", dnaSequence.getAccession().getDataSource().name());\n    assertEquals(3, dnaSequence.getAccession().getVersion().intValue());\n    assertTrue(genbankDNA.isClosed());\n}", "repo_id": "9", "comment": "/**\n * Test of process method, of class GenbankReader.\n */\n", "repo_name": "biojava-master/", "id": 3219, "method_signature": "void testProcess()"}, "130": {"callee_method_names": ["GuanUberbacher<DNASequence, NucleotideCompound>.getPair"], "method_name": "GuanUberbacherTest.should_align_shorter_target", "method_implementation": "{\n    DNASequence query = new DNASequence(\"AT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"A\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    GuanUberbacher<DNASequence, NucleotideCompound> aligner = new GuanUberbacher<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 5, (short) 2), SubstitutionMatrixHelper.getNuc4_4());\n    assertEquals(String.format(\"AT%nA-%n\"), aligner.getPair().toString());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 130, "method_signature": "void should_align_shorter_target()"}, "2453": {"callee_method_names": [], "method_name": "Feature.type", "method_implementation": "{\n    return mType;\n}", "repo_id": "9", "comment": "/**\n * Get feature type, such as \"exon\" or \"CDS\". (GFF field 3).\n *\n * @return Feature type.\n */\n", "repo_name": "biojava-master/", "id": 2453, "method_signature": "String type()"}, "3205": {"callee_method_names": ["BlastXMLParser.setQueryReferences"], "method_name": "BlastXMLParserTest.testSetQueryReferences", "method_implementation": "{\n    System.out.println(\"setQueryReferences\");\n    List<org.biojava.nbio.core.sequence.template.Sequence> sequences = null;\n    BlastXMLParser instance = new BlastXMLParser();\n    instance.setQueryReferences(sequences);\n    // TODO review the generated test code and remove the default call to fail.\n    fail(\"The test case is a prototype.\");\n}", "repo_id": "9", "comment": "/**\n * Test of setQueryReferences method, of class BlastXMLParser.\n */\n", "repo_name": "biojava-master/", "id": 3205, "method_signature": "void testSetQueryReferences()"}, "159": {"callee_method_names": ["BufferedReader.readLine", "String.startsWith", "String.isEmpty", "String.matches", "List<String>.add", "BufferedReader.close"], "method_name": "TestLongPdbVsMmCifParsing.readTestSetFile", "method_implementation": "{\n    InputStream inStream = this.getClass().getResourceAsStream(testSetFile);\n    BufferedReader br = new BufferedReader(new InputStreamReader(inStream));\n    List<String> list = new ArrayList<String>();\n    String line;\n    while ((line = br.readLine()) != null) {\n        if (line.startsWith(\"#\"))\n            continue;\n        if (line.isEmpty())\n            break;\n        if (!line.matches(\"\\\\d\\\\w\\\\w\\\\w\"))\n            throw new IllegalArgumentException(\"The input test set \" + testSetFile + \" contains an invalid PDB code: \" + line);\n        list.add(line);\n    }\n    br.close();\n    return list;\n}", "repo_id": "9", "comment": "/**\n * Reads a file containing a list of PDB codes.\n * Lines starting with \"#\" will be treated as comments\n * Will stop reading after finding an empty line, this is useful to quickly test a modified list.\n * @param testSetFile\n * @return\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 159, "method_signature": "List<String> readTestSetFile(String)"}, "201": {"callee_method_names": [], "method_name": "Jronn.getDisorder", "method_implementation": "{\n    final List<FastaSequence> sequences = SequenceUtil.readFasta(new FileInputStream(fastaFile));\n    return getDisorder(sequences);\n}", "repo_id": "9", "comment": "/**\n * Calculates the disordered regions of the protein sequence.\n * @param fastaFile input file name containing the sequence in FASTA\n * @return the Map with key->FastaSequence, value->the list of disordered regions for each sequence\n * @throws FileNotFoundException if the input file cannot be found\n * @throws IOException of the system cannot access or read from the input file\n * @see #getDisorder(FastaSequence)\n * @see #Jronn.Range\n */\n", "repo_name": "biojava-master/", "id": 201, "method_signature": "Map<FastaSequence,Range[]> getDisorder(String)"}, "2681": {"callee_method_ids": [3056], "callee_method_names": ["ArrayList.get", "ArrayList.get", "ArrayList.get", "AccessionID.getID", "String.replaceAll", "StringBuilder.append", "S.getSubSequence", "S.getSubSequence", "String.length", "String.length", "String.charAt", "String.charAt", "StringBuilder.append", "CompoundSet<C>.compoundsEquivalent", "S.getCompoundAt", "S.getCompoundAt", "StringBuilder.append"], "method_name": "MultipleSequenceAlignment.printConservation", "method_implementation": "{\n    S seq1 = sequences.get(0), seq2 = sequences.get(1);\n    if (idFormat != null) {\n        AccessionID ac1 = sequences.get(0).getAccession();\n        String id1 = (ac1 == null) ? \"null\" : ac1.getID();\n        id1 = id1.replaceAll(\"\\\\.\", \" \");\n        s.append(String.format(idFormat, id1));\n    }\n    String s1 = seq1.getSubSequence(start, end).getSequenceAsString();\n    String s2 = seq2.getSubSequence(start, end).getSequenceAsString();\n    CompoundSet<C> cs = getCompoundSet();\n    for (int i = 0; i < s1.length(); i++) {\n        if (i >= s2.length())\n            break;\n        char c1 = s1.charAt(i);\n        char c2 = s2.charAt(i);\n        s.append(IOUtils.getPDBConservation(webDisplay, c1, c2, cs.compoundsEquivalent(seq1.getCompoundAt(i), seq2.getCompoundAt(i))));\n    }\n    s.append(String.format(\"%n\"));\n}", "repo_id": "9", "comment": "/**\n * @param s\n * @param idFormat\n * @param start\n * @param end\n * @param webDisplay\n */\n", "repo_name": "biojava-master/", "id": 2681, "method_signature": "void printConservation(StringBuilder, String, int, int, boolean)"}, "3773": {"callee_method_names": [], "method_name": "WorkSheet.setIndexColumnName", "method_implementation": "{\n    this.indexColumnName = indexColumnName;\n}", "repo_id": "9", "comment": "/**\n * @param indexColumnName the indexColumnName to set\n */\n", "repo_name": "biojava-master/", "id": 3773, "method_signature": "void setIndexColumnName(String)"}, "1343": {"callee_method_names": ["Chain.getId", "StructureInterface.getId", "Chain.getId", "Map<String, Map<ResidueNumber, Integer>>.containsKey", "Chain.getId", "Map<String, Map<ResidueNumber, Integer>>.get", "Chain.getId", "Group.getResidueNumber", "Chain.getSeqResGroups", "Chain.getSeqResGroups", "Chain.getSeqResGroups", "Map<ResidueNumber, Integer>.get", "Group.getResidueNumber"], "method_name": "EntityInfo.getAlignedResIndex", "method_implementation": "{\n    boolean contained = false;\n    for (Chain member : getChains()) {\n        if (c.getId().equals(member.getId())) {\n            contained = true;\n            break;\n        }\n    }\n    if (!contained)\n        throw new IllegalArgumentException(\"Given chain with asym_id \" + c.getId() + \" is not a member of this entity: \" + getChainIds().toString());\n    if (!chains2pdbResNums2ResSerials.containsKey(c.getId())) {\n        // we do lazy initialisation of the map\n        initResSerialsMap(c);\n    }\n    // if no seqres groups are available at all the map will be null\n    Map<ResidueNumber, Integer> map = chains2pdbResNums2ResSerials.get(c.getId());\n    int serial;\n    if (map != null) {\n        ResidueNumber resNum = g.getResidueNumber();\n        // the resNum will be null for groups that are SEQRES only and not in ATOM,\n        // still it can happen that a group is in ATOM in one chain but not in other of the same entity.\n        // This is what we try to find out here (analogously to what we do in initResSerialsMap() ):\n        if (resNum == null && c.getSeqResGroups() != null && !c.getSeqResGroups().isEmpty()) {\n            int index = c.getSeqResGroups().indexOf(g);\n            resNum = findResNumInOtherChains(index, c);\n        }\n        if (resNum == null) {\n            // still null, we really can't map\n            serial = -1;\n        } else {\n            Integer alignedSerial = map.get(resNum);\n            if (alignedSerial == null) {\n                // the map doesn't contain this group, something's wrong: return -1\n                serial = -1;\n            } else {\n                serial = alignedSerial;\n            }\n        }\n    } else {\n        // no seqres groups available we resort to using the pdb residue numbers are given\n        serial = g.getResidueNumber().getSeqNum();\n    }\n    return serial;\n}", "repo_id": "9", "comment": "/**\n * Given a Group g of Chain c (member of this EntityInfo) return the corresponding position in the\n * alignment of all member sequences (1-based numbering), i.e. the index (1-based) in the SEQRES sequence.\n * This allows for comparisons of residues belonging to different chains of the same EntityInfo (entity).\n * <p>\n * Note this method should only be used for entities of type {@link EntityType#POLYMER}\n * <p>\n * If {@link FileParsingParameters#setAlignSeqRes(boolean)} is not used or SEQRES not present, a mapping\n * will not be available and this method will return {@link ResidueNumber#getSeqNum()} for all residues, which\n * in some cases will be correctly aligned indices (when no insertion codes are\n * used and when all chains within the entity are numbered in the same way), but\n * in general they will be neither unique (because of insertion codes) nor aligned.\n * </p>\n * @param g the group\n * @param c the chain\n * @return the aligned residue index (1 to n), if no SEQRES groups are available at all then {@link ResidueNumber#getSeqNum()}\n * is returned as a fall-back, if the group is not found in the SEQRES groups then -1 is returned\n * for the given group and chain\n * @throws IllegalArgumentException if the given Chain is not a member of this EntityInfo\n * @see Chain#getSeqResGroup(int)\n */\n", "repo_name": "biojava-master/", "id": 1343, "method_signature": "int getAlignedResIndex(Group, Chain)"}, "2869": {"callee_method_names": [], "method_name": "ABITrace.initData", "method_implementation": "{\n    traceData = fileData;\n    if (isABI()) {\n        setIndex();\n        setBasecalls();\n        setQcalls();\n        setSeq();\n        setTraces();\n    } else\n        throw new IllegalArgumentException(\"Not a valid ABI file.\");\n}", "repo_id": "9", "comment": "/**\n * Initialize all of the data fields for this object.\n *\n * @param fileData - data for object\n * @throws IllegalArgumentException which will propagate to all of the constructors.\n */\n", "repo_name": "biojava-master/", "id": 2869, "method_signature": "void initData(byte[])"}, "3701": {"callee_method_names": [], "method_name": "HeaderInfo.setHide", "method_implementation": "{\n    this.hide = hide;\n}", "repo_id": "9", "comment": "/**\n * @param hide the hide to set\n */\n", "repo_name": "biojava-master/", "id": 3701, "method_signature": "void setHide(boolean)"}, "3822": {"callee_method_ids": [3649, 3819, 3818, 3821], "callee_method_names": ["JFrame.setDefaultCloseOperation", "JFrame.add", "ExpressionFigure.setSize", "JFrame.setSize", "JFrame.setVisible", "ArrayList<String>.add", "ArrayList<String>.add", "SurvivalInfo.addContinuousVariable", "ArrayList<SurvivalInfo>.add", "ExpressionFigure.setSurvivalInfo", "ExpressionFigure.setFigureLineInfo", "ExpressionFigure.savePNG", "int.printStackTrace"], "method_name": "ExpressionFigure.main", "method_implementation": "{\n    // TODO code application logic here\n    try {\n        ExpressionFigure expressionFigure = new ExpressionFigure();\n        JFrame application = new JFrame();\n        application.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        application.add(expressionFigure);\n        expressionFigure.setSize(500, 400);\n        // window is 500 pixels wide, 400 high\n        application.setSize(500, 400);\n        application.setVisible(true);\n        ArrayList<String> titles = new ArrayList<String>();\n        titles.add(\"Line 1\");\n        titles.add(\"line 2\");\n        ArrayList<String> figureInfo = new ArrayList<String>();\n        ArrayList<SurvivalInfo> survivalInfoList = new ArrayList<SurvivalInfo>();\n        for (int i = 0; i < 600; i++) {\n            double r = Math.random();\n            double v = r * 10000;\n            double t = Math.random() * 5.0;\n            r = Math.random();\n            int e = 0;\n            if (r < .3) {\n                e = 1;\n            }\n            SurvivalInfo si = new SurvivalInfo(t, e);\n            si.addContinuousVariable(\"META_GENE\", v);\n            survivalInfoList.add(si);\n        }\n        expressionFigure.setSurvivalInfo(titles, survivalInfoList, \"META_GENE\");\n        expressionFigure.setFigureLineInfo(figureInfo);\n        expressionFigure.savePNG(\"/Users/Scooter/Downloads/test.png\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}", "repo_id": "9", "comment": "/**\n * @param args the command line arguments\n */\n", "repo_name": "biojava-master/", "id": 3822, "method_signature": "void main(String[])"}, "3098": {"callee_method_names": [], "method_name": "Qualifier.setNeedsQuotes", "method_implementation": "{\n    this.needsQuotes = needsQuotes;\n}", "repo_id": "9", "comment": "/**\n * @param needsQuotes the needsQuotes to set\n */\n", "repo_name": "biojava-master/", "id": 3098, "method_signature": "void setNeedsQuotes(boolean)"}, "818": {"callee_method_names": [], "method_name": "AlternativeAlignment.getIdx2", "method_implementation": "{\n    return idx2;\n}", "repo_id": "9", "comment": "/**\n * the positions of the structure equivalent atoms in atom set 2\n *\n * @return the array of the positions\n */\n", "repo_name": "biojava-master/", "id": 818, "method_signature": "int[] getIdx2()"}, "334": {"callee_method_names": ["Object.hashCode", "Object[].hashCode", "Object.equals"], "method_name": "SmallMap.put", "method_implementation": "{\n    int keyHash = key.hashCode();\n    for (int i = 0; i < numMappings * 2; i += 2) {\n        if (keyHash == mappings[i].hashCode() && key.equals(mappings[i])) {\n            Object oldValue = mappings[i + 1];\n            mappings[i + 1] = value;\n            return oldValue;\n        }\n    }\n    int newPos = numMappings * 2;\n    int oldLength = 0;\n    if (mappings != null) {\n        oldLength = mappings.length;\n    }\n    if (newPos + 1 >= oldLength) {\n        Object[] newMappings = new Object[oldLength + 6];\n        if (oldLength > 0) {\n            System.arraycopy(mappings, 0, newMappings, 0, mappings.length);\n        }\n        mappings = newMappings;\n    }\n    mappings[newPos] = key;\n    mappings[newPos + 1] = value;\n    numMappings++;\n    return null;\n}", "repo_id": "9", "comment": "/**\n * @throws NullPointerException if key is null\n */\n", "repo_name": "biojava-master/", "id": 334, "method_signature": "Object put(Object, Object)"}, "284": {"callee_method_names": ["Chain.getAtomGroups", "Group.isAminoAcid", "List<Group>.add"], "method_name": "StructureUtil.getAminoAcids", "method_implementation": "{\n    List<Group> gs = new ArrayList<>();\n    for (Group g : chain.getAtomGroups()) {\n        if (g.isAminoAcid())\n            gs.add(g);\n    }\n    return gs;\n}", "repo_id": "9", "comment": "/**\n * Get all amino acids in a chain.\n * @param chain\n * @return\n */\n", "repo_name": "biojava-master/", "id": 284, "method_signature": "List<Group> getAminoAcids(Chain)"}, "554": {"callee_method_ids": [529, 808, 820, 830, 826], "callee_method_names": ["Logger.debug", "Logger.debug", "Logger.debug", "StrucAligParameters.getDiagonalDistance", "StrucAligParameters.getDiagonalDistance2", "StrucAligParameters.getFragmentLength", "Atom.setCoords", "Matrix.set", "StrucAligParameters.getFragmentMiniDistance", "JointFragments.setCenter1", "JointFragments.setCenter2", "JointFragments.setRot", "Atom.clone", "JointFragments.setUnitv", "StrucAligParameters.reduceInitialFragments", "List<FragmentPair>.add", "List<FragmentPair>.toArray", "Logger.debug", "Logger.debug", "StrucAligParameters.isJoinFast", "FragmentJoiner.approach_ap3", "FragmentJoiner.extendFragments", "StrucAligParameters.isJoinPlo", "FragmentJoiner.frag_pairwise_compat", "StrucAligParameters.getAngleDiff", "StrucAligParameters.getFragCompat", "StrucAligParameters.getMaxrefine", "FragmentJoiner.approach_ap3", "Logger.debug", "Logger.debug", "AlternativeAlignment.apairs_from_idxlst", "AlternativeAlignment.setAltAligNumber", "AlternativeAlignment.setDistanceMatrix", "StrucAligParameters.getMaxIter", "AlternativeAlignment.refine", "AlternativeAlignment.finish", "Logger.error", "AlternativeAlignment.calcScores", "List<AlternativeAlignment>.add", "List<AlternativeAlignment>.sort", "List<AlternativeAlignment>.toArray", "AlternativeAlignment.setAltAligNumber", "Logger.debug"], "method_name": "StructurePairAligner.align", "method_implementation": "{\n    reset();\n    this.params = params;\n    long timeStart = System.currentTimeMillis();\n    // step 1 get all Diagonals of length X that are similar between both\n    // structures\n    logger.debug(\" length atoms1:{}\", ca1.length);\n    logger.debug(\" length atoms2:{}\", ca2.length);\n    logger.debug(\"step 1 - get fragments with similar intramolecular distances \");\n    int k = params.getDiagonalDistance();\n    int k2 = params.getDiagonalDistance2();\n    int fragmentLength = params.getFragmentLength();\n    if (ca1.length < (fragmentLength + 1)) {\n        throw new StructureException(\"structure 1 too short (\" + ca1.length + \"), can not align\");\n    }\n    if (ca2.length < (fragmentLength + 1)) {\n        throw new StructureException(\"structure 2 too short (\" + ca2.length + \"), can not align\");\n    }\n    int rows = ca1.length - fragmentLength + 1;\n    int cols = ca2.length - fragmentLength + 1;\n    distanceMatrix = new Matrix(rows, cols, 0.0);\n    double[] dist1 = AlignUtils.getDiagonalAtK(ca1, k);\n    double[] dist2 = AlignUtils.getDiagonalAtK(ca2, k);\n    double[] dist3 = new double[0];\n    double[] dist4 = new double[0];\n    if (k2 > 0) {\n        dist3 = AlignUtils.getDiagonalAtK(ca1, k2);\n        dist4 = AlignUtils.getDiagonalAtK(ca2, k2);\n    }\n    double[][] utmp = new double[][] { { 0, 0, 1 } };\n    Atom unitvector = new AtomImpl();\n    unitvector.setCoords(utmp[0]);\n    List<FragmentPair> fragments = new ArrayList<>();\n    for (int i = 0; i < rows; i++) {\n        Atom[] catmp1 = AlignUtils.getFragment(ca1, i, fragmentLength);\n        Atom center1 = AlignUtils.getCenter(ca1, i, fragmentLength);\n        for (int j = 0; j < cols; j++) {\n            double rdd1 = AlignUtils.rms_dk_diag(dist1, dist2, i, j, fragmentLength, k);\n            double rdd2 = 0;\n            if (k2 > 0)\n                rdd2 = AlignUtils.rms_dk_diag(dist3, dist4, i, j, fragmentLength, k2);\n            double rdd = rdd1 + rdd2;\n            distanceMatrix.set(i, j, rdd);\n            if (rdd < params.getFragmentMiniDistance()) {\n                FragmentPair f = new FragmentPair(fragmentLength, i, j);\n                Atom[] catmp2 = AlignUtils.getFragment(ca2, j, fragmentLength);\n                Atom center2 = AlignUtils.getCenter(ca2, j, fragmentLength);\n                f.setCenter1(center1);\n                f.setCenter2(center2);\n                Matrix4d t = SuperPositions.superpose(Calc.atomsToPoints(catmp1), Calc.atomsToPoints(catmp2));\n                Matrix rotmat = Matrices.getRotationJAMA(t);\n                f.setRot(rotmat);\n                Atom aunitv = (Atom) unitvector.clone();\n                Calc.rotate(aunitv, rotmat);\n                f.setUnitv(aunitv);\n                boolean doNotAdd = false;\n                if (params.reduceInitialFragments()) {\n                    doNotAdd = FragmentJoiner.reduceFragments(fragments, f, distanceMatrix);\n                }\n                if (doNotAdd)\n                    continue;\n                fragments.add(f);\n            }\n        }\n    }\n    notifyFragmentListeners(fragments);\n    FragmentPair[] fp = fragments.toArray(new FragmentPair[0]);\n    setFragmentPairs(fp);\n    logger.debug(\" got # fragment pairs: {}\", fp.length);\n    logger.debug(\"step 2 - join fragments\");\n    // step 2 combine them to possible models\n    FragmentJoiner joiner = new FragmentJoiner();\n    JointFragments[] frags;\n    if (params.isJoinFast()) {\n        // apply the quick alignment procedure.\n        // less quality in alignments, better for DB searches...\n        frags = joiner.approach_ap3(ca1, ca2, fp, params);\n        joiner.extendFragments(ca1, ca2, frags, params);\n    } else if (params.isJoinPlo()) {\n        // this approach by StrComPy (peter lackner):\n        frags = joiner.frag_pairwise_compat(fp, params.getAngleDiff(), params.getFragCompat(), params.getMaxrefine());\n    } else {\n        // my first implementation\n        frags = joiner.approach_ap3(ca1, ca2, fp, params);\n    }\n    notifyJointFragments(frags);\n    logger.debug(\" number joint fragments: {}\", frags.length);\n    logger.debug(\"step 3 - refine alignments\");\n    List<AlternativeAlignment> aas = new ArrayList<>();\n    for (int i = 0; i < frags.length; i++) {\n        JointFragments f = frags[i];\n        AlternativeAlignment a = new AlternativeAlignment();\n        a.apairs_from_idxlst(f);\n        a.setAltAligNumber(i + 1);\n        a.setDistanceMatrix(distanceMatrix);\n        try {\n            if (params.getMaxIter() > 0) {\n                a.refine(params, ca1, ca2);\n            } else {\n                a.finish(params, ca1, ca2);\n            }\n        } catch (StructureException e) {\n            logger.error(\"Refinement of fragment {} failed\", i, e);\n        }\n        a.calcScores(ca1, ca2);\n        aas.add(a);\n    }\n    // sort the alternative alignments\n    Comparator<AlternativeAlignment> comp = new AltAligComparator();\n    aas.sort(comp);\n    Collections.reverse(aas);\n    alts = aas.toArray(new AlternativeAlignment[0]);\n    // do final numbering of alternative solutions\n    int aanbr = 0;\n    for (AlternativeAlignment a : alts) {\n        aanbr++;\n        a.setAltAligNumber(aanbr);\n    }\n    logger.debug(\"total calculation time: {} ms.\", (System.currentTimeMillis() - timeStart));\n}", "repo_id": "9", "comment": "/**\n * Calculate the protein structure superimposition, between two sets of\n * atoms.\n *\n * @param ca1\n *            set of Atoms of structure 1\n * @param ca2\n *            set of Atoms of structure 2\n * @param params\n *            the parameters to use for the alignment\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 554, "method_signature": "void align(Atom[], Atom[], StrucAligParameters)"}, "2291": {"callee_method_names": ["Structure.getEntityById", "EntityInfo.getOrganismTaxId", "EntityInfo.getExpressionSystemTaxId"], "method_name": "SourceCompoundTest.testSourceTaxIdVersion32File", "method_implementation": "{\n    Structure structure = getStructure(\"/3dl7_v32.pdb\");\n    EntityInfo comp = structure.getEntityById(1);\n    Assert.assertEquals(\"10090\", comp.getOrganismTaxId());\n    Assert.assertEquals(\"9606\", comp.getExpressionSystemTaxId());\n}", "repo_id": "9", "comment": "/**\n * There is a file format change in v3.2 of the PDB file format, adding the\n * tax id.\n * This test makes sure that the tax id for the organism and expression\n * systems is set correctly.\n */\n", "repo_name": "biojava-master/", "id": 2291, "method_signature": "void testSourceTaxIdVersion32File()"}, "978": {"callee_method_names": [], "method_name": "BioAssemblyInfo.getMacromolecularSize", "method_implementation": "{\n    return macromolecularSize;\n}", "repo_id": "9", "comment": "/**\n * Returns the macromolecular size of this biological assembly, i.e.\n * the number of polymeric chains (protein or nucleotide chains, not sugars)\n * in the biological assembly.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 978, "method_signature": "int getMacromolecularSize()"}, "3241": {"callee_method_ids": [3275], "callee_method_names": ["JFrame.setDefaultCloseOperation", "JFrame.setTitle", "AbstractAlignmentJmol.getTitle", "MultipleAligPanel.setPreferredSize", "MultipleAligPanel.getCoordManager", "MultipleAligPanel.getCoordManager", "JFrame.setJMenuBar", "JScrollPane.setAutoscrolls", "MultipleAligPanel.addAlignmentPositionListener", "Box.add", "Box.add", "JFrame.getContentPane", "JFrame.pack", "JFrame.setVisible", "JFrame.addWindowListener", "JFrame.addWindowListener"], "method_name": "MultipleAlignmentJmolDisplay.showMultipleAligmentPanel", "method_implementation": "{\n    MultipleAligPanel me = new MultipleAligPanel(multAln, jmol);\n    JFrame frame = new JFrame();\n    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n    frame.setTitle(jmol.getTitle());\n    me.setPreferredSize(new Dimension(me.getCoordManager().getPreferredWidth(), me.getCoordManager().getPreferredHeight()));\n    JMenuBar menu = MenuCreator.getAlignmentPanelMenu(frame, me, null, multAln);\n    frame.setJMenuBar(menu);\n    JScrollPane scroll = new JScrollPane(me);\n    scroll.setAutoscrolls(true);\n    MultipleStatusDisplay status = new MultipleStatusDisplay(me);\n    me.addAlignmentPositionListener(status);\n    Box vBox = Box.createVerticalBox();\n    vBox.add(scroll);\n    vBox.add(status);\n    frame.getContentPane().add(vBox);\n    frame.pack();\n    frame.setVisible(true);\n    frame.addWindowListener(me);\n    frame.addWindowListener(status);\n}", "repo_id": "9", "comment": "/**\n * Creates a new Frame with the MultipleAlignment Sequence Panel.\n * The panel can communicate with the Jmol 3D visualization by\n * selecting the aligned residues of every structure.\n *\n * @param multAln\n * @param jmol\n *\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 3241, "method_signature": "void showMultipleAligmentPanel(MultipleAlignment, AbstractAlignmentJmol)"}, "2167": {"callee_method_ids": [992, 993], "callee_method_names": ["Chain.setId", "HetatomImpl.setChain", "HetatomImpl.getChain"], "method_name": "HetatomImplTest.testSetGetChain", "method_implementation": "{\n    //        System.out.println(\"setGetChain\");\n    Chain chain = new ChainImpl();\n    chain.setId(\"A\");\n    HetatomImpl instance = new HetatomImpl();\n    instance.setChain(chain);\n    Chain expResult = chain;\n    Chain result = instance.getChain();\n    Assert.assertEquals(expResult, result);\n}", "repo_id": "9", "comment": "/**\n * Test of setChain method, of class HetatomImpl.\n */\n", "repo_name": "biojava-master/", "id": 2167, "method_signature": "void testSetGetChain()"}, "3360": {"callee_method_names": ["NavigableMap<Double, Color>.values"], "method_name": "GradientMapper.values", "method_implementation": "{\n    return mapping.values();\n}", "repo_id": "9", "comment": "/**\n * @return\n * @see java.util.Map#values()\n */\n", "repo_name": "biojava-master/", "id": 3360, "method_signature": "Collection<Color> values()"}, "2937": {"callee_method_names": [], "method_name": "AbstractSequence.setAccession", "method_implementation": "{\n    this.accession = accession;\n}", "repo_id": "9", "comment": "/**\n * @param accession the accession to set\n */\n", "repo_name": "biojava-master/", "id": 2937, "method_signature": "void setAccession(AccessionID)"}, "2972": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.getAccession", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported yet.\");\n}", "repo_id": "9", "comment": "/**\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2972, "method_signature": "AccessionID getAccession()"}, "3460": {"callee_method_names": [], "method_name": "NCBIQBlastOutputProperties.getAlignmentNumber", "method_implementation": "{\n    return Integer.parseInt(getOutputOption(ALIGNMENTS));\n}", "repo_id": "9", "comment": "/**\n * @return number of alignments fetched - an int with the value of the key ALIGNMENTS\n */\n", "repo_name": "biojava-master/", "id": 3460, "method_signature": "int getAlignmentNumber()"}, "1311": {"callee_method_names": ["SequencePair<Sequence<AminoAcidCompound>,AminoAcidCompound>.getAlignedSequences", "List<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>>.get", "StringBuilder.append", "Map<Integer, Atom>.getBase", "StringBuilder.toString", "List<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>>.get", "StringBuilder.append", "Map<Integer, Atom>.getBase", "StringBuilder.toString", "LinkedHashMap<String, ProteinSequence>.put", "Structure.getName", "LinkedHashMap<String, ProteinSequence>.put", "Structure.getName", "Logger.error", "Element.getMessage"], "method_name": "FastaAFPChainConverter.fastaToAfpChain", "method_implementation": "{\n    List<AlignedSequence<Sequence<AminoAcidCompound>, AminoAcidCompound>> seqs = alignment.getAlignedSequences();\n    StringBuilder sb1 = new StringBuilder();\n    for (AminoAcidCompound a : seqs.get(0)) {\n        sb1.append(a.getBase());\n    }\n    try {\n        ProteinSequence seq1 = new ProteinSequence(sb1.toString());\n        StringBuilder sb2 = new StringBuilder();\n        for (AminoAcidCompound a : seqs.get(1)) {\n            sb1.append(a.getBase());\n        }\n        ProteinSequence seq2 = new ProteinSequence(sb2.toString());\n        LinkedHashMap<String, ProteinSequence> map = new LinkedHashMap<String, ProteinSequence>();\n        map.put(structure1.getName(), seq1);\n        map.put(structure2.getName(), seq2);\n        return fastaToAfpChain(map, structure1, structure2);\n    } catch (CompoundNotFoundException e) {\n        logger.error(\"Unexpected error while creating protein sequences: {}. This is most likely a bug.\", e.getMessage());\n        return null;\n    }\n}", "repo_id": "9", "comment": "/**\n * Provided only for convenience.\n *\n * @see #fastaToAfpChain(ProteinSequence, ProteinSequence, Structure, Structure)\n * @throws StructureException\n */\n", "repo_name": "biojava-master/", "id": 1311, "method_signature": "AFPChain fastaToAfpChain(SequencePair, Structure, Structure)"}, "2962": {"callee_method_names": [], "method_name": "ArrayListSequenceReader.getCompoundAt", "method_implementation": "{\n    return this.parsedCompounds.get(position - 1);\n}", "repo_id": "9", "comment": "/**\n * @param position\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2962, "method_signature": "C getCompoundAt(int)"}, "2720": {"callee_method_names": [], "method_name": "BufferedReaderBytesRead.mark", "method_implementation": "{\n    if (readAheadLimit < 0) {\n        throw new IllegalArgumentException(\"Read-ahead limit < 0\");\n    }\n    synchronized (lock) {\n        ensureOpen();\n        this.readAheadLimit = readAheadLimit;\n        markedChar = nextChar;\n        markedSkipLF = skipLF;\n    }\n}", "repo_id": "9", "comment": "/**\n * Marks the present position in the stream.  Subsequent calls to reset()\n * will attempt to reposition the stream to this point.\n *\n * @param readAheadLimit   Limit on the number of characters that may be\n *                         read while still preserving the mark. An attempt\n *                         to reset the stream after reading characters\n *                         up to this limit or beyond may fail.\n *                         A limit value larger than the size of the input\n *                         buffer will cause a new buffer to be allocated\n *                         whose size is no smaller than limit.\n *                         Therefore large values should be used with care.\n *\n * @exception  IllegalArgumentException  If readAheadLimit is < 0\n * @exception  IOException  If an I/O error occurs\n */\n", "repo_name": "biojava-master/", "id": 2720, "method_signature": "void mark(int)"}, "2345": {"callee_method_names": ["String.length"], "method_name": "FastqBuilder.withQuality", "method_implementation": "{\n    if (quality == null) {\n        throw new IllegalArgumentException(\"quality must not be null\");\n    }\n    if (this.quality == null) {\n        this.quality = new StringBuilder(quality.length());\n    }\n    this.quality.replace(0, this.quality.length(), quality);\n    return this;\n}", "repo_id": "9", "comment": "/**\n * Return this FASTQ formatted sequence builder configured with the specified quality scores.\n *\n * @param quality quality scores for this FASTQ formatted sequence builder, must not be null\n * @return this FASTQ formatted sequence builder configured with the specified quality scores\n */\n", "repo_name": "biojava-master/", "id": 2345, "method_signature": "FastqBuilder withQuality(String)"}, "3778": {"callee_method_names": [], "method_name": "WorkSheet.getRowHeader", "method_implementation": "{\n    return rowHeader;\n}", "repo_id": "9", "comment": "/**\n * @return the rowHeader\n */\n", "repo_name": "biojava-master/", "id": 3778, "method_signature": "String getRowHeader()"}, "989": {"callee_method_names": ["HetatomImpl.setPDBFlag", "HetatomImpl.setResidueNumber", "HetatomImpl.setPDBName", "HetatomImpl.addAltLoc", "HetatomImpl.setChemComp"], "method_name": "HetatomImpl.clone", "method_implementation": "{\n    HetatomImpl n = new HetatomImpl();\n    n.setPDBFlag(has3D());\n    n.setResidueNumber(residueNumber);\n    n.setPDBName(getPDBName());\n    //clone atoms and bonds.\n    cloneAtomsAndBonds(n);\n    // copying the alt loc groups if present, otherwise they stay null\n    if (altLocs != null) {\n        for (Group altLocGroup : this.altLocs) {\n            Group nAltLocGroup = (Group) altLocGroup.clone();\n            n.addAltLoc(nAltLocGroup);\n        }\n    }\n    if (chemComp != null)\n        n.setChemComp(chemComp);\n    return n;\n}", "repo_id": "9", "comment": "/**\n * returns and identical copy of this Group object .\n * @return  and identical copy of this Group object\n */\n", "repo_name": "biojava-master/", "id": 989, "method_signature": "Object clone()"}, "1032": {"callee_method_names": ["Chain.getAtomGroups", "Group.getAtom", "List<Atom>.add", "List<Atom>.addAll"], "method_name": "StructureTools.extractAtoms", "method_implementation": "{\n    for (Chain c : chains) {\n        for (Group g : c.getAtomGroups()) {\n            // a temp container for the atoms of this group\n            List<Atom> thisGroupAtoms = new ArrayList<Atom>();\n            // flag to check if this group contains all the requested atoms.\n            boolean thisGroupAllAtoms = true;\n            for (String atomName : atomNames) {\n                Atom a = g.getAtom(atomName);\n                if (a == null) {\n                    // this group does not have a required atom, skip it...\n                    thisGroupAllAtoms = false;\n                    break;\n                }\n                thisGroupAtoms.add(a);\n            }\n            if (thisGroupAllAtoms) {\n                // add the atoms of this group to the array.\n                atoms.addAll(thisGroupAtoms);\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Adds to the given atoms list, all atoms of groups that contained all\n * requested atomNames, i.e. if a group does not contain all of the\n * requested atom names, its atoms won't be added.\n *\n * @param atomNames\n * @param chains\n * @param atoms\n */\n", "repo_name": "biojava-master/", "id": 1032, "method_signature": "void extractAtoms(String[], List, List)"}, "2134": {"callee_method_names": ["List<Model>.size"], "method_name": "StructureImpl.getChains", "method_implementation": "{\n    if (models.size() == 0) {\n        return new ArrayList<>(0);\n    }\n    return getChains(0);\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2134, "method_signature": "List<Chain> getChains()"}, "1819": {"callee_method_names": ["ReadWriteLock.writeLock", "Logger.trace", "double[].getPdbId", "double[].getDomainId", "String.isEmpty", "Pattern.matcher", "Matcher.group", "Map<PdbId, List<EcodDomain>>.containsKey", "Map<PdbId, List<EcodDomain>>.get", "Map<PdbId, List<EcodDomain>>.put", "List<EcodDomain>.add", "Logger.trace", "ReadWriteLock.writeLock"], "method_name": "EcodInstallation.indexDomains", "method_implementation": "{\n    domainsFileLock.writeLock().lock();\n    logger.trace(\"LOCK writelock\");\n    try {\n        if (allDomains == null) {\n            ensureDomainsFileInstalled();\n        }\n        // Leave enough space for all PDBs as of 2015\n        domainMap = new HashMap<PdbId, List<EcodDomain>>((int) (150000 / .85), .85f);\n        // Index with domainMap\n        for (EcodDomain d : allDomains) {\n            // Get the PDB ID, either directly or from the domain ID\n            PdbId pdbId = d.getPdbId();\n            if (pdbId == null) {\n                String ecodId = d.getDomainId();\n                if (ecodId != null && !ecodId.isEmpty()) {\n                    Matcher match = ECOD_RE.matcher(ecodId);\n                    pdbId = new PdbId(match.group(1));\n                }\n            }\n            // Add current domain to the map\n            List<EcodDomain> currDomains;\n            if (domainMap.containsKey(pdbId)) {\n                currDomains = domainMap.get(pdbId);\n            } else {\n                currDomains = new LinkedList<EcodDomain>();\n                domainMap.put(pdbId, currDomains);\n            }\n            currDomains.add(d);\n        }\n    } finally {\n        logger.trace(\"UNLOCK writelock\");\n        domainsFileLock.writeLock().unlock();\n    }\n}", "repo_id": "9", "comment": "/**\n * Populates domainMap from allDomains\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 1819, "method_signature": "void indexDomains()"}, "1798": {"callee_method_names": [], "method_name": "EcodFactory.getEcodDatabase", "method_implementation": "{\n    return getEcodDatabase(defaultVersion);\n}", "repo_id": "9", "comment": "/**\n * Returns the (singleton) database for the current default version\n */\n", "repo_name": "biojava-master/", "id": 1798, "method_signature": "EcodDatabase getEcodDatabase()"}, "2878": {"callee_method_names": ["Map<C, Integer>.containsKey", "Map<C, Integer>.get"], "method_name": "SequenceMixin.countCompounds", "method_implementation": "{\n    int count = 0;\n    Map<C, Integer> compositon = getComposition(sequence);\n    for (C compound : compounds) {\n        if (compositon.containsKey(compound)) {\n            count = compositon.get(compound) + count;\n        }\n    }\n    return count;\n}", "repo_id": "9", "comment": "/**\n * For the given vargs of compounds this method counts the number of\n * times those compounds appear in the given sequence\n *\n * @param sequence The {@link Sequence} to perform the count on\n * @param compounds The compounds to look for\n * @param <C> The type of compound we are looking for\n * @return The number of times the given compounds appear in this Sequence\n */\n", "repo_name": "biojava-master/", "id": 2878, "method_signature": "int countCompounds(Sequence, C[])"}, "1428": {"callee_method_names": [], "method_name": "CrystalTransform.isPureMatrixTranslation", "method_implementation": "{\n    return SpaceGroup.deltaComp(matTransform.m00, 1, SpaceGroup.DELTA) && SpaceGroup.deltaComp(matTransform.m01, 0, SpaceGroup.DELTA) && SpaceGroup.deltaComp(matTransform.m02, 0, SpaceGroup.DELTA) && SpaceGroup.deltaComp(matTransform.m10, 0, SpaceGroup.DELTA) && SpaceGroup.deltaComp(matTransform.m11, 1, SpaceGroup.DELTA) && SpaceGroup.deltaComp(matTransform.m12, 0, SpaceGroup.DELTA) && SpaceGroup.deltaComp(matTransform.m20, 0, SpaceGroup.DELTA) && SpaceGroup.deltaComp(matTransform.m21, 0, SpaceGroup.DELTA) && SpaceGroup.deltaComp(matTransform.m22, 1, SpaceGroup.DELTA) && (Math.abs(matTransform.m03 - 0.0) > SpaceGroup.DELTA || Math.abs(matTransform.m13 - 0.0) > SpaceGroup.DELTA || Math.abs(matTransform.m23 - 0.0) > SpaceGroup.DELTA);\n}", "repo_id": "9", "comment": "/**\n * This method will help check if the matrix translation is pure or not.\n * @return boolean\n */\n", "repo_name": "biojava-master/", "id": 1428, "method_signature": "boolean isPureMatrixTranslation()"}, "590": {"callee_method_ids": [489, 487, 490], "callee_method_names": ["AFPChain.getOptAln", "AFPChain.getBlockNum", "AFPChain.getOptLen", "List<Integer>.add", "List<Integer>.add", "List<Integer>.add", "List<Integer>.size", "List<int[][]>.add", "List<int[][]>.add", "List<int[][]>.toArray", "List<Integer>.size", "List<Integer>.size", "List<Integer>.get", "List<int[][]>.size"], "method_name": "AlignmentTools.splitBlocksByTopology", "method_implementation": "{\n    int[][][] optAln = a.getOptAln();\n    int blockNum = a.getBlockNum();\n    int[] optLen = a.getOptLen();\n    // Determine block lengths\n    // Split blocks if residue indices don't increase monotonically\n    List<Integer> newBlkLen = new ArrayList<Integer>();\n    boolean blockChanged = false;\n    for (int blk = 0; blk < blockNum; blk++) {\n        int currLen = 1;\n        for (int pos = 1; pos < optLen[blk]; pos++) {\n            if (optAln[blk][0][pos] <= optAln[blk][0][pos - 1] || optAln[blk][1][pos] <= optAln[blk][1][pos - 1]) {\n                //start a new block\n                newBlkLen.add(currLen);\n                currLen = 0;\n                blockChanged = true;\n            }\n            currLen++;\n        }\n        if (optLen[blk] < 2) {\n            newBlkLen.add(optLen[blk]);\n        } else {\n            newBlkLen.add(currLen);\n        }\n    }\n    // Check if anything needs to be split\n    if (!blockChanged) {\n        return a;\n    }\n    // Split blocks\n    List<int[][]> blocks = new ArrayList<int[][]>(newBlkLen.size());\n    int oldBlk = 0;\n    int pos = 0;\n    for (int blkLen : newBlkLen) {\n        if (blkLen == optLen[oldBlk]) {\n            //should be the whole block\n            assert (pos == 0);\n            // Use the old block\n            blocks.add(optAln[oldBlk]);\n        } else {\n            int[][] newBlock = new int[2][blkLen];\n            // don't overrun block\n            assert (pos + blkLen <= optLen[oldBlk]);\n            for (int i = 0; i < blkLen; i++) {\n                newBlock[0][i] = optAln[oldBlk][0][pos + i];\n                newBlock[1][i] = optAln[oldBlk][1][pos + i];\n            }\n            pos += blkLen;\n            blocks.add(newBlock);\n            if (pos == optLen[oldBlk]) {\n                // Finished this oldBlk, start the next\n                oldBlk++;\n                pos = 0;\n            }\n        }\n    }\n    // Store new blocks\n    int[][][] newOptAln = blocks.toArray(new int[0][][]);\n    int[] newBlockLens = new int[newBlkLen.size()];\n    for (int i = 0; i < newBlkLen.size(); i++) {\n        newBlockLens[i] = newBlkLen.get(i);\n    }\n    return replaceOptAln(a, ca1, ca2, blocks.size(), newBlockLens, newOptAln);\n}", "repo_id": "9", "comment": "/**\n * @param a\n * @param ca1\n * @param ca2\n * @return\n * @throws StructureException if an error occurred during superposition\n */\n", "repo_name": "biojava-master/", "id": 590, "method_signature": "AFPChain splitBlocksByTopology(AFPChain, Atom[], Atom[])"}, "2000": {"callee_method_names": [], "method_name": "Octahedron.getCirumscribedRadius", "method_implementation": "{\n    return cirumscribedRadius;\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a circumscribed sphere, that goes\n * through all vertices\n * @return the cirumscribedRadius\n */\n", "repo_name": "biojava-master/", "id": 2000, "method_signature": "double getCirumscribedRadius()"}, "2011": {"callee_method_names": [], "method_name": "Tetrahedron.getMidRadius", "method_implementation": "{\n    double side = getSideLengthFromCircumscribedRadius(circumscribedRadius);\n    return getMiddleRadiusFromSideLength(side);\n}", "repo_id": "9", "comment": "/**\n * Returns the radius of a sphere, that is tangent to each\n * of the tetrahedron's edges\n *\n * @return the midRadius\n */\n", "repo_name": "biojava-master/", "id": 2011, "method_signature": "double getMidRadius()"}, "2391": {"callee_method_names": [], "method_name": "Location.fromBioExt", "method_implementation": "{\n    int s = start;\n    int e = s + length;\n    if (!(strand == '-' || strand == '+' || strand == '.')) {\n        throw new IllegalArgumentException(\"Strand must be '+', '-', or '.'\");\n    }\n    if (strand == '-') {\n        s = s - totalLength;\n        e = e - totalLength;\n    }\n    return new Location(s, e);\n}", "repo_id": "9", "comment": "/**\n * Create a location from MAF file coordinates, which represent negative\n * strand locations as the distance from the end of the sequence.\n *\n * @param start Origin 1 index of first symbol.\n * @param length Number of symbols in range.\n * @param strand '+' or '-' or '.' ('.' is interpreted as '+').\n * @param totalLength Total number of symbols in sequence.\n * @throws IllegalArgumentException Strand must be '+', '-', '.'\n */\n", "repo_name": "biojava-master/", "id": 2391, "method_signature": "Location fromBioExt(int, int, char, int)"}, "2144": {"callee_method_names": [], "method_name": "StructureImpl.setEntityInfos", "method_implementation": "{\n    this.entityInfos = molList;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2144, "method_signature": "void setEntityInfos(List)"}, "1714": {"callee_method_ids": [1007, 1008, 1010], "callee_method_names": ["ResidueRange.getStart", "ResidueRange.getChainName", "AtomPositionMap.getNavMap", "ResidueNumber.getChainName", "AtomPositionMap.getNavMap", "Logger.warn", "AtomPositionMap.getFirst", "ResidueRange.getEnd", "AtomPositionMap.getLast", "ResidueNumber.setChainName", "ResidueNumber.setChainName", "AtomPositionMap.trimToValidResidues"], "method_name": "ResidueRangeAndLength.parse", "method_implementation": "{\n    ResidueRange rr = parse(s);\n    ResidueNumber start = rr.getStart();\n    String chain = rr.getChainName();\n    // handle special \"_\" chain\n    if (chain == null || \"_\".equals(chain)) {\n        ResidueNumber first = map.getNavMap().firstKey();\n        chain = first.getChainName();\n        // Quick check for additional chains. Not guaranteed if the atoms are out of order.\n        if (!map.getNavMap().lastKey().getChainName().equals(chain)) {\n            logger.warn(\"Multiple possible chains match '_'. Using chain {}\", chain);\n        }\n    }\n    // get a non-null start and end\n    // if it's the whole chain, choose the first and last residue numbers in the chain\n    if (start == null) {\n        start = map.getFirst(chain);\n    }\n    ResidueNumber end = rr.getEnd();\n    if (end == null) {\n        // should happen iff start==null\n        end = map.getLast(chain);\n    }\n    // Replace '_'\n    start.setChainName(chain);\n    end.setChainName(chain);\n    // Now fix any errors and calculate the length\n    return map.trimToValidResidues(new ResidueRange(chain, start, end));\n}", "repo_id": "9", "comment": "/**\n * Parses a residue range.\n *\n * The AtomPositionMap is used to calculate the length and fill in missing\n * information, such as for whole chains ('A:'). Supports the special chain\n * name '_' for single-chain structures.\n *\n * If residues are specified outside of the range given in the map,\n * attempts to decrease the input range to valid values. In extreme cases\n * where this process fails fails to find any valid indices, returns null.\n *\n * For a function which more conservatively represents the input range,\n * without chain inference and error fixes, use {@link ResidueRange#parse(String)}.\n * @param s\n *            A string of the form chain_start-end. For example: <code>A.5-100</code>.\n * @return The unique ResidueRange corresponding to {@code s}.\n */\n", "repo_name": "biojava-master/", "id": 1714, "method_signature": "ResidueRangeAndLength parse(String, AtomPositionMap)"}, "3802": {"callee_method_names": [], "method_name": "KaplanMeierFigure.getLeft", "method_implementation": "{\n    return left;\n}", "repo_id": "9", "comment": "/**\n * @return the left\n */\n", "repo_name": "biojava-master/", "id": 3802, "method_signature": "int getLeft()"}, "3382": {"callee_method_names": [], "method_name": "JmolSymmetryScriptGenerator.jMolFloat", "method_implementation": "{\n    return (float) f;\n}", "repo_id": "9", "comment": "/**\n * Returns a lower precision floating point number for Jmol\n * @param f\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3382, "method_signature": "float jMolFloat(double)"}, "116": {"callee_method_names": ["NeedlemanWunsch<DNASequence, NucleotideCompound>.setAnchors", "NeedlemanWunsch<DNASequence, NucleotideCompound>.getPair"], "method_name": "NeedlemanWunschTest.should_align_starting_anchor", "method_implementation": "{\n    DNASequence query = new DNASequence(\"AAT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    DNASequence target = new DNASequence(\"AATT\", AmbiguityDNACompoundSet.getDNACompoundSet());\n    NeedlemanWunsch<DNASequence, NucleotideCompound> aligner = new NeedlemanWunsch<DNASequence, NucleotideCompound>(query, target, new SimpleGapPenalty((short) 0, (short) 10), SubstitutionMatrixHelper.getNuc4_4());\n    aligner.setAnchors(new int[] { 1, -1, -1 });\n    assertEquals(String.format(\"-AAT%nAATT%n\"), aligner.getPair().toString());\n}", "repo_id": "9", "comment": "/**\n * @author Daniel Cameron\n */\n", "repo_name": "biojava-master/", "id": 116, "method_signature": "void should_align_starting_anchor()"}, "1986": {"callee_method_names": ["Matrix4d.get", "RotationGroup.getPointGroup", "Matrix4d.transform", "Point3d.set", "Point3d.add"], "method_name": "RotationAxisAligner.getGeometricCenter", "method_implementation": "{\n    run();\n    Point3d geometricCenter = new Point3d();\n    Vector3d translation = new Vector3d();\n    reverseTransformationMatrix.get(translation);\n    // calculate adjustment around z-axis and transform adjustment to\n    //  original coordinate frame with the reverse transformation\n    if (rotationGroup.getPointGroup().startsWith(\"C\")) {\n        Vector3d corr = new Vector3d(0, 0, minBoundary.z + getDimension().z);\n        reverseTransformationMatrix.transform(corr);\n        geometricCenter.set(corr);\n    }\n    geometricCenter.add(translation);\n    return geometricCenter;\n}", "repo_id": "9", "comment": "/**\n * Returns the geometric center of polyhedron. In the case of the Cn\n * point group, the centroid and geometric center are usually not\n * identical.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 1986, "method_signature": "Point3d getGeometricCenter()"}, "1887": {"callee_method_names": [], "method_name": "Stoichiometry.resetAlphas", "method_implementation": "{\n    doResetAlphas();\n}", "repo_id": "9", "comment": "/**\n * Reassign alpha-strings for each cluster according to the current strategy.\n * Has no effect if custom string generator is used.\n */\n", "repo_name": "biojava-master/", "id": 1887, "method_signature": "void resetAlphas()"}, "1105": {"callee_method_names": ["ChemComp.getId"], "method_name": "ChemicalComponentDictionary.getReplaced", "method_implementation": "{\n    return getReplaced(c.getId());\n}", "repo_id": "9", "comment": "/**\n * If ChemComp is replacing another one, get the old version otherwise return the same ChemComp again.\n * @param  c the ChemComp for which older versions should be looked up.\n */\n", "repo_name": "biojava-master/", "id": 1105, "method_signature": "ChemComp getReplaced(ChemComp)"}, "991": {"callee_method_names": [], "method_name": "HetatomImpl.setId", "method_implementation": "{\n    this.id = id;\n}", "repo_id": "9", "comment": "/**\n * the Hibernate database ID\n *\n * @param id the hibernate id\n */\n", "repo_name": "biojava-master/", "id": 991, "method_signature": "void setId(long)"}, "1725": {"callee_method_names": [], "method_name": "BasePairParameters.getPropeller", "method_implementation": "{\n    checkArgument(bp);\n    return pairingParameters[bp][1];\n}", "repo_id": "9", "comment": "/**\n * This method returns the propeller (\"propeller-twist\") in degrees for the given base pair\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in degrees)\n */\n", "repo_name": "biojava-master/", "id": 1725, "method_signature": "Double getPropeller(int)"}, "2702": {"callee_method_names": [], "method_name": "FileProxyDNASequenceCreator.getSequence", "method_implementation": "{\n    throw new UnsupportedOperationException(\"Not supported yet.\");\n}", "repo_id": "9", "comment": "/**\n * Not sure of use case and currently not supported\n * @param list\n * @return\n */\n", "repo_name": "biojava-master/", "id": 2702, "method_signature": "AbstractSequence<NucleotideCompound> getSequence(List)"}, "3489": {"callee_method_names": ["HashMap.containsKey", "BlastProgramEnum.name"], "method_name": "NCBIQBlastAlignmentProperties.getBlastWordSize", "method_implementation": "{\n    if (param.containsKey(WORD_SIZE)) {\n        return Integer.parseInt(getAlignmentOption(WORD_SIZE));\n    }\n    // return default word size value\n    try {\n        BlastProgramEnum programType = getBlastProgram();\n        switch(programType) {\n            case blastn:\n                return 11;\n            case megablast:\n                return 28;\n            case blastp:\n            case blastx:\n            case tblastn:\n            case tblastx:\n                return 3;\n            default:\n                throw new UnsupportedOperationException(\"Blast program \" + programType.name() + \" is not supported.\");\n        }\n    } catch (IllegalArgumentException e) {\n        throw new IllegalArgumentException(\"Blast program \" + getBlastProgram() + \" is not supported.\", e);\n    }\n}", "repo_id": "9", "comment": "/**\n * Returns the value of the WORD_SIZE parameter used for this blast run\n *\n * @return int value of WORD_SIZE used by this search\n * @throws IllegalArgumentException when program type is not set and program type is not supported\n */\n", "repo_name": "biojava-master/", "id": 3489, "method_signature": "int getBlastWordSize()"}, "274": {"callee_method_names": ["Node.getChildNodes", "NodeList.getLength", "NodeList.item", "Node.getNodeType", "Node.getNodeName", "Map<String, List<Node>>.get", "Map<String, List<Node>>.put", "List<Node>.add"], "method_name": "ProteinModificationXmlReader.getChildNodes", "method_implementation": "{\n    if (parent == null)\n        return Collections.emptyMap();\n    Map<String, List<Node>> children = new HashMap<String, List<Node>>();\n    NodeList nodes = parent.getChildNodes();\n    int nNodes = nodes.getLength();\n    for (int i = 0; i < nNodes; i++) {\n        Node node = nodes.item(i);\n        if (node.getNodeType() != Node.ELEMENT_NODE)\n            continue;\n        String name = node.getNodeName();\n        List<Node> namesakes = children.get(name);\n        if (namesakes == null) {\n            namesakes = new ArrayList<Node>();\n            children.put(name, namesakes);\n        }\n        namesakes.add(node);\n    }\n    return children;\n}", "repo_id": "9", "comment": "/**\n * Utility method to group child nodes by their names.\n * @param parent parent node.\n * @return Map from name to child nodes.\n */\n", "repo_name": "biojava-master/", "id": 274, "method_signature": "Map<String,List<Node>> getChildNodes(Node)"}, "2354": {"callee_method_names": [], "method_name": "FastqParserLineProcessor.setState", "method_implementation": "{\n    this.state = state;\n}", "repo_id": "9", "comment": "/**\n * Set the parser state to <code>state</code>.\n *\n * @param state parser state\n */\n", "repo_name": "biojava-master/", "id": 2354, "method_signature": "void setState(State)"}, "968": {"callee_method_names": ["Structure.setPDBHeader", "Structure.getPDBHeader", "Structure.getChains", "Chain.setId", "SparseVector.getId", "Chain.setName", "SparseVector.getName", "Chain.setEntityInfo", "SparseVector.getEntityInfo", "Structure.addChain", "SparseVector.getAtomGroups", "Group.getType", "Group.getAtom", "Group.getAtom", "Group.clone", "Group.clearAtoms", "Group.addAtom", "Chain.addGroup"], "method_name": "BioAssemblyTools.getReducedStructure", "method_implementation": "{\n    Structure s = new StructureImpl();\n    s.setPDBHeader(orig.getPDBHeader());\n    for (Chain c : orig.getChains()) {\n        Chain c1 = new ChainImpl();\n        c1.setId(c.getId());\n        c1.setName(c.getName());\n        c1.setEntityInfo(c.getEntityInfo());\n        s.addChain(c1);\n        for (Group g : c.getAtomGroups()) {\n            Atom a = null;\n            switch(g.getType()) {\n                case AMINOACID:\n                    a = g.getAtom(StructureTools.CA_ATOM_NAME);\n                    break;\n                case NUCLEOTIDE:\n                    a = g.getAtom(StructureTools.NUCLEOTIDE_REPRESENTATIVE);\n                    break;\n                default:\n            }\n            if (a != null) {\n                Group g1 = (Group) g.clone();\n                g1.clearAtoms();\n                g1.addAtom(a);\n                c1.addGroup(g1);\n            }\n        }\n    }\n    return s;\n}", "repo_id": "9", "comment": "/**\n * Reduce a structure to a single-atom representation (e.g. CA atoms)\n *\n * @param orig\n * @return\n * @since Biojava 4.1.0\n */\n", "repo_name": "biojava-master/", "id": 968, "method_signature": "Structure getReducedStructure(Structure)"}, "1274": {"callee_method_names": ["OutputStream.write"], "method_name": "MmtfActions.writeToOutputStream", "method_implementation": "{\n    // Set up this writer\n    AdapterToStructureData writerToEncoder = new AdapterToStructureData();\n    // Get the writer - this is what people implement\n    new MmtfStructureWriter(structure, writerToEncoder);\n    // Now write this data to file\n    byte[] outputBytes = WriterUtils.getDataAsByteArr(writerToEncoder);\n    outputStream.write(outputBytes, 0, outputBytes.length);\n}", "repo_id": "9", "comment": "/**\n * Write a Structure object to an {@link OutputStream}\n * @param structure the Structure to write\n * @param outputStream the {@link OutputStream} to write to\n * @throws IOException an error transferring the byte[]\n */\n", "repo_name": "biojava-master/", "id": 1274, "method_signature": "void writeToOutputStream(Structure, OutputStream)"}, "2320": {"callee_method_names": ["Group.setPDBName", "Atom.setName", "Group.addAtom", "List<Atom>.add", "Group.setPDBName", "Atom.setName", "Group.addAtom", "List<Atom>.add", "List<Atom>.toArray"], "method_name": "TestSubunitCluster.mockAtomArray", "method_implementation": "{\n    List<Atom> atoms = new ArrayList<>(size1 + size2);\n    for (int i = 0; i < size1; i++) {\n        Group g = new AminoAcidImpl();\n        g.setPDBName(type1);\n        Atom a = new AtomImpl();\n        a.setName(StructureTools.CA_ATOM_NAME);\n        g.addAtom(a);\n        atoms.add(a);\n    }\n    if (size2 >= 0 && type2 != null) {\n        for (int i = 0; i < size2; i++) {\n            Group g = new AminoAcidImpl();\n            g.setPDBName(type2);\n            Atom a = new AtomImpl();\n            a.setName(StructureTools.CA_ATOM_NAME);\n            g.addAtom(a);\n            atoms.add(a);\n        }\n    }\n    return atoms.toArray(new Atom[0]);\n}", "repo_id": "9", "comment": "/**\n * Create a mock atom array, with size1 residues of type1, followed by size2 residues of type2.\n *\n * @param size1 the number of residues of type1 to add\n * @param type1 the 3 letter code of residue\n * @param size2 the number of residues of type2 to add, if -1 none are added\n * @param type2 the 3 letter code of residue, if null none are added\n * @return the mock atom array\n */\n", "repo_name": "biojava-master/", "id": 2320, "method_signature": "Atom[] mockAtomArray(int, String, int, String)"}, "3626": {"callee_method_names": [], "method_name": "CoxInfo.getOverallModelFitPvalue", "method_implementation": "{\n    return scoreLogrankTestpvalue;\n}", "repo_id": "9", "comment": "/**\n * @return the scoreLogrankTestpvalue\n */\n", "repo_name": "biojava-master/", "id": 3626, "method_signature": "double getOverallModelFitPvalue()"}, "1726": {"callee_method_names": [], "method_name": "BasePairParameters.getOpening", "method_implementation": "{\n    checkArgument(bp);\n    return pairingParameters[bp][2];\n}", "repo_id": "9", "comment": "/**\n * This method returns the opening in degrees for the given base pair\n * @param bp the number of the base pair (starting with 0)\n * @return the value as a double (in degrees)\n */\n", "repo_name": "biojava-master/", "id": 1726, "method_signature": "Double getOpening(int)"}, "1257": {"callee_method_names": [], "method_name": "MmtfUtils.getNcsAsMatrix4d", "method_implementation": "{\n    if (ncsOperMatrixList == null) {\n        return null;\n    }\n    int numMats = ncsOperMatrixList.length;\n    if (numMats == 0) {\n        return null;\n    }\n    if (numMats == 1 && ncsOperMatrixList[0].length == 0) {\n        return null;\n    }\n    Matrix4d[] outList = new Matrix4d[numMats];\n    for (int i = 0; i < numMats; i++) {\n        outList[i] = new Matrix4d(ncsOperMatrixList[i]);\n    }\n    return outList;\n}", "repo_id": "9", "comment": "/**\n * Get a list of N 4*4 matrices from a single list of doubles of length 16*N.\n * @param ncsOperMatrixList the input list of doubles\n * @return the list of 4*4 matrics\n */\n", "repo_name": "biojava-master/", "id": 1257, "method_signature": "Matrix4d[] getNcsAsMatrix4d(double[][])"}, "1460": {"callee_method_names": ["Matrix3d.determinant", "Matrix.det", "EigenvalueDecomposition.getD", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.get", "EigenvalueDecomposition.getV", "AxisAngle4d.set", "Matrix.get", "Matrix.get", "Matrix.get", "Matrix.trace"], "method_name": "SpaceGroup.getRotAxisAndAngle", "method_implementation": "{\n    double determinant = m.determinant();\n    if (!(Math.abs(determinant) - 1.0 < DELTA))\n        throw new IllegalArgumentException(\"Given matrix is not a rotation matrix\");\n    AxisAngle4d axisAndAngle = new AxisAngle4d(new Vector3d(0, 0, 0), 0);\n    double[] d = { m.m00, m.m10, m.m20, m.m01, m.m11, m.m21, m.m02, m.m12, m.m22 };\n    Matrix r = new Matrix(d, 3);\n    if (!deltaComp(r.det(), 1.0, DELTA)) {\n        // improper rotation: we return axis 0,0,0 and angle 0\n        return axisAndAngle;\n    }\n    EigenvalueDecomposition evd = new EigenvalueDecomposition(r);\n    Matrix eval = evd.getD();\n    if (deltaComp(eval.get(0, 0), 1.0, DELTA) && deltaComp(eval.get(1, 1), 1.0, DELTA) && deltaComp(eval.get(2, 2), 1.0, DELTA)) {\n        // the rotation is an identity: we return axis 0,0,0 and angle 0\n        return axisAndAngle;\n    }\n    int indexOfEv1;\n    for (indexOfEv1 = 0; indexOfEv1 < 3; indexOfEv1++) {\n        if (deltaComp(eval.get(indexOfEv1, indexOfEv1), 1, DELTA))\n            break;\n    }\n    Matrix evec = evd.getV();\n    axisAndAngle.set(new Vector3d(evec.get(0, indexOfEv1), evec.get(1, indexOfEv1), evec.get(2, indexOfEv1)), Math.acos((eval.trace() - 1.0) / 2.0));\n    return axisAndAngle;\n}", "repo_id": "9", "comment": "/**\n * Given a rotation matrix calculates the rotation axis and angle for it.\n * The angle is calculated from the trace, the axis from the eigenvalue\n * decomposition.\n * If given matrix is improper rotation or identity matrix then\n * axis (0,0,0) and angle 0 are returned.\n * @param m\n * @return\n * @throws IllegalArgumentException if given matrix is not a rotation matrix (determinant not 1 or -1)\n */\n", "repo_name": "biojava-master/", "id": 1460, "method_signature": "AxisAngle4d getRotAxisAndAngle(Matrix3d)"}, "2347": {"callee_method_names": ["String.length", "String.length"], "method_name": "FastqBuilder.sequenceAndQualityLengthsMatch", "method_implementation": "{\n    if (sequence == null && quality == null) {\n        return true;\n    }\n    if ((sequence != null && quality == null) || (sequence == null && quality != null)) {\n        return false;\n    }\n    return sequence.length() == quality.length();\n}", "repo_id": "9", "comment": "/**\n * Return true if the sequence and quality scores for this FASTQ formatted sequence builder are equal in length.\n *\n * @return true if the sequence and quality scores for this FASTQ formatted sequence builder are equal in length\n */\n", "repo_name": "biojava-master/", "id": 2347, "method_signature": "boolean sequenceAndQualityLengthsMatch()"}, "3362": {"callee_method_names": [], "method_name": "GradientMapper.setInterpolator", "method_implementation": "{\n    this.interpolator = interpolator;\n}", "repo_id": "9", "comment": "/**\n * @param interpolator the interpolator to set\n */\n", "repo_name": "biojava-master/", "id": 3362, "method_signature": "void setInterpolator(ColorInterpolator)"}, "1043": {"callee_method_names": ["Map<String, Character>.get"], "method_name": "StructureTools.get1LetterCodeAmino", "method_implementation": "{\n    return aminoAcids.get(groupCode3);\n}", "repo_id": "9", "comment": "/**\n * Convert three character amino acid codes into single character e.g.\n * convert CYS to C. Valid 3-letter codes will be those of the standard 20\n * amino acids plus MSE, CSE, SEC, PYH, PYL (see the {@link #aminoAcids}\n * map)\n *\n * @return the 1 letter code, or null if the given 3 letter code does not\n *         correspond to an amino acid code\n * @param groupCode3\n *            a three character amino acid representation String\n * @see #get1LetterCode(String)\n */\n", "repo_name": "biojava-master/", "id": 1043, "method_signature": "Character get1LetterCodeAmino(String)"}, "2205": {"callee_method_names": ["ResidueNumber.equals", "Set<ResidueNumber>.add", "Set<ResidueNumber>.add", "Set<ResidueNumber>.size"], "method_name": "ResidueNumberTest.testEquals", "method_implementation": "{\n    //        System.out.println(\"equals\");\n    ResidueNumber number1 = new ResidueNumber(\"A\", 42, ' ');\n    ResidueNumber number2 = new ResidueNumber(\"A\", 42, ' ');\n    boolean expResult = true;\n    boolean result = number2.equals(number1);\n    Assert.assertEquals(expResult, result);\n    Set<ResidueNumber> numberSet = new HashSet<ResidueNumber>();\n    numberSet.add(number1);\n    numberSet.add(number2);\n    Assert.assertEquals(1, numberSet.size());\n}", "repo_id": "9", "comment": "/**\n * Test of equals method, of class ResidueNumber.\n */\n", "repo_name": "biojava-master/", "id": 2205, "method_signature": "void testEquals()"}, "1633": {"callee_method_names": [], "method_name": "SubunitClustererParameters.setClustererMethod", "method_implementation": "{\n    this.clustererMethod = method;\n}", "repo_id": "9", "comment": "/**\n * Method to cluster subunits.\n *\n * @param method\n */\n", "repo_name": "biojava-master/", "id": 1633, "method_signature": "void setClustererMethod(SubunitClustererMethod)"}, "3319": {"callee_method_ids": [3316], "callee_method_names": ["JMatrixPanel.setCellColor"], "method_name": "ScaleableMatrixPanel.setCellColor", "method_implementation": "{\n    mPanel.setCellColor(cellColor);\n}", "repo_id": "9", "comment": "/**\n * @param cellColor the color mapping of the JMatrixPanel\n */\n", "repo_name": "biojava-master/", "id": 3319, "method_signature": "void setCellColor(ContinuousColorMapper)"}, "113": {"callee_method_names": ["DistanceMatrix.setValue", "DistanceMatrix.setValue", "DistanceMatrix.setValue"], "method_name": "DistanceMatrixCalculator.structuralDistance", "method_implementation": "{\n    int n = rmsdMat.length;\n    DistanceMatrix DM = new BasicSymmetricalDistanceMatrix(n);\n    // Transform raw RMSD into distances and create matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            if (i == j)\n                DM.setValue(i, j, 0.0);\n            else {\n                double d = (rmsdMax * rmsdMax) / (alpha * alpha) * Math.log((rmsdMax * rmsdMax - rmsd0 * rmsd0) / (rmsdMax * rmsdMax - rmsdMat[i][j] * rmsdMat[i][j]));\n                d = Math.max(d, 0.0);\n                DM.setValue(i, j, d);\n                DM.setValue(j, i, d);\n            }\n        }\n    }\n    return DM;\n}", "repo_id": "9", "comment": "/**\n * The structural distance (d<sub>S</sub>) uses the structural similarity\n * (or dissimilarity) from a the structural alignment of two protein\n * strutures. It is based on the diffusive model for protein fold evolution\n * (Grishin 1995). The structural deviations are captured as RMS deviations.\n *\n * <pre>\n * d<sub>Sij</sub> = (rmsd<sub>max</sub><sup>2</sup> / alpha<sup>2</sup>) *\n *        ln( (rmsd<sub>max</sub><sup>2</sup> - rmsd<sub>0</sub><sup>2</sup>) /\n *        (rmsd<sub>max</sub><sup>2</sup> - (rmsd<sub>ij</sub><sup>2</sup>) )\n * </pre>\n *\n * @param rmsdMat\n *            RMSD matrix for all structure pairs (symmetric matrix)\n * @param alpha\n *            change in CA positions introduced by a single AA substitution\n *            (Grishin 1995: 1 A)\n * @param rmsdMax\n *            estimated RMSD between proteins of the same fold when the\n *            percentage of identity is infinitely low (the maximum allowed\n *            RMSD of proteins with the same fold). (Grishin 1995: 5 A)\n * @param rmsd0\n *            arithmetical mean of squares of the RMSD for identical\n *            proteins (Grishin 1995: 0.4 A)\n * @return DistanceMatrix\n */\n", "repo_name": "biojava-master/", "id": 113, "method_signature": "DistanceMatrix structuralDistance(double[][], double, double, double)"}, "2152": {"callee_method_names": [], "method_name": "StructureImpl.getSSBonds", "method_implementation": "{\n    return ssbonds;\n}", "repo_id": "9", "comment": "/**\n * {@inheritDoc}\n */\n", "repo_name": "biojava-master/", "id": 2152, "method_signature": "List<Bond> getSSBonds()"}, "3051": {"callee_method_names": ["Path.getEnd", "Path.getEnd"], "method_name": "LocationHelper.detectCicular", "method_implementation": "{\n    boolean isCircular = false;\n    if (!consistentAccessions(subLocations))\n        return isCircular;\n    int lastMax = 0;\n    for (Location sub : subLocations) {\n        if (sub.getEnd().getPosition() > lastMax) {\n            lastMax = sub.getEnd().getPosition();\n        } else {\n            isCircular = true;\n            break;\n        }\n    }\n    return isCircular;\n}", "repo_id": "9", "comment": "/**\n * Loops through the given list of locations and returns true if it looks\n * like they represent a circular location. Detection cannot happen if\n * we do not have consistent accessions\n */\n", "repo_name": "biojava-master/", "id": 3051, "method_signature": "boolean detectCicular(List)"}, "1295": {"callee_method_names": ["SequencePair<ProteinSequence, AminoAcidCompound>.getQuery", "SequencePair<ProteinSequence, AminoAcidCompound>.getTarget", "AlignedSequence<ProteinSequence, AminoAcidCompound>.getLength", "AlignedSequence<ProteinSequence, AminoAcidCompound>.getLength", "ProteinSequence.getLength", "AlignedSequence<ProteinSequence, AminoAcidCompound>.getStart", "AlignedSequence<ProteinSequence, AminoAcidCompound>.getEnd", "AlignedSequence<ProteinSequence, AminoAcidCompound>.isGap", "AlignedSequence<ProteinSequence, AminoAcidCompound>.getSequenceIndexAt", "Map<Integer, Group>.get", "Logger.warn", "Group.getChainId", "Group.getResidueNumber", "Group.getChain", "AlignedSequence<ProteinSequence, AminoAcidCompound>.isGap", "AlignedSequence<ProteinSequence, AminoAcidCompound>.getSequenceIndexAt", "AlignedSequence<ProteinSequence, AminoAcidCompound>.getSequenceIndexAt", "Map<Integer, Group>.get", "Group.getResidueNumber"], "method_name": "StructureSequenceMatcher.matchSequenceToStructure", "method_implementation": "{\n    //1. Create ProteinSequence for struct while remembering to which group each residue corresponds\n    Map<Integer, Group> atomIndexPosition = new HashMap<Integer, Group>();\n    ProteinSequence structSeq = getProteinSequenceForStructure(struct, atomIndexPosition);\n    // TODO This should really be semi-global alignment, though global for either sequence OR structure (we don't know which)\n    //2. Run Smith-Waterman to get the alignment\n    // Identity substitution matrix with +1 for match, -1 for mismatch\n    // TODO\n    SubstitutionMatrix<AminoAcidCompound> matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>(AminoAcidCompoundSet.getAminoAcidCompoundSet(), (short) 1, (short) -1);\n    matrix = new SimpleSubstitutionMatrix<AminoAcidCompound>(AminoAcidCompoundSet.getAminoAcidCompoundSet(), new InputStreamReader(SimpleSubstitutionMatrix.class.getResourceAsStream(\"/matrices/blosum100.txt\")), \"blosum100\");\n    SequencePair<ProteinSequence, AminoAcidCompound> pair = Alignments.getPairwiseAlignment(seq, structSeq, PairwiseSequenceAlignerType.GLOBAL, new SimpleGapPenalty(), matrix);\n    //System.out.print(pair.toString());\n    //3. Convert the alignment back to Atoms\n    AlignedSequence<ProteinSequence, AminoAcidCompound> alignedSeq = pair.getQuery();\n    AlignedSequence<ProteinSequence, AminoAcidCompound> alignedStruct = pair.getTarget();\n    assert (alignedSeq.getLength() == alignedStruct.getLength());\n    //\t\tSystem.out.println(pair.toString(80));\n    //\t\tSystem.out.format(\"%d/min{%d,%d}\\n\", pair.getNumIdenticals(),\n    //\t\t\t\talignedSeq.getLength()-alignedSeq.getNumGaps(),\n    //\t\t\t\talignedStruct.getLength()-alignedStruct.getNumGaps());\n    ResidueNumber[] ca = new ResidueNumber[seq.getLength()];\n    for (int pos = alignedSeq.getStart().getPosition(); pos <= alignedSeq.getEnd().getPosition(); pos++) {\n        // 1-indexed\n        //skip missing residues from sequence. These probably represent alignment errors\n        if (alignedSeq.isGap(pos)) {\n            int structIndex = alignedStruct.getSequenceIndexAt(pos) - 1;\n            //should be defined since seq gap\n            assert (structIndex > 0);\n            Group g = atomIndexPosition.get(structIndex);\n            logger.warn(\"Chain {} residue {} in the Structure {} has no corresponding amino acid in the sequence.\", g.getChainId(), g.getResidueNumber().toString(), g.getChain().getStructure().getPDBCode());\n            continue;\n        }\n        if (!alignedStruct.isGap(pos)) {\n            //1-indexed\n            int seqIndex = alignedSeq.getSequenceIndexAt(pos) - 1;\n            //1-indexed\n            int structIndex = alignedStruct.getSequenceIndexAt(pos) - 1;\n            Group g = atomIndexPosition.get(structIndex);\n            assert (0 <= seqIndex && seqIndex < ca.length);\n            //remains null for gaps\n            ca[seqIndex] = g.getResidueNumber();\n        }\n    }\n    return ca;\n}", "repo_id": "9", "comment": "/**\n * Given a sequence and the corresponding Structure, get the ResidueNumber\n * for each residue in the sequence.\n *\n * <p>Smith-Waterman alignment is used to match the sequences. Residues\n * in the sequence but not the structure or mismatched between sequence\n * and structure will have a null atom, while\n * residues in the structure but not the sequence are ignored with a warning.\n * @param seq The protein sequence. Should match the sequence of struct very\n * \tclosely.\n * @param struct The corresponding protein structure\n * @return A list of ResidueNumbers of the same length as seq, containing\n *  either the corresponding residue or null.\n */\n", "repo_name": "biojava-master/", "id": 1295, "method_signature": "ResidueNumber[] matchSequenceToStructure(ProteinSequence, Structure)"}, "2673": {"callee_method_names": ["List<C>.add", "Collection<String>.getCompoundAt"], "method_name": "MultipleSequenceAlignment.getCompoundsAt", "method_implementation": "{\n    List<C> column = new ArrayList<C>();\n    for (S s : sequences) {\n        column.add(s.getCompoundAt(alignmentIndex));\n    }\n    return Collections.unmodifiableList(column);\n}", "repo_id": "9", "comment": "/**\n * Get a list of compounds at a sequence position\n * @param alignmentIndex\n * @return compounds\n */\n", "repo_name": "biojava-master/", "id": 2673, "method_signature": "List<C> getCompoundsAt(int)"}, "728": {"callee_method_names": [], "method_name": "CECalculator.getShift", "method_implementation": "{\n    return t;\n}", "repo_id": "9", "comment": "/**\n * Gets the shift from the last call to\n * {@link #calc_rmsd(Atom[], Atom[], int, boolean) calc_rmsd}.\n * @return The shift\n */\n", "repo_name": "biojava-master/", "id": 728, "method_signature": "Atom getShift()"}, "1179": {"callee_method_ids": [1317, 1323, 1323, 1689, 1687, 1691, 1701, 1688], "callee_method_names": ["FileParsingParameters.isHeaderOnly", "String.substring", "Chain.getName", "List<Chain>.add", "Chain.addGroup", "Chain.setId", "Chain.setName", "List<List<Chain>>.add", "String.substring", "String.substring", "String.substring", "String.substring", "Character.equals", "Group.setPDBName", "Group.setResidueNumber", "Group.setHetAtomInFile", "String.substring", "ResidueNumber.equals", "Group.getResidueNumber", "Chain.addGroup", "Group.trimToSize", "Group.setPDBName", "Group.setResidueNumber", "Group.setHetAtomInFile", "Character.equals", "Logger.debug", "Group.getChain", "Group.setChain", "Logger.warn", "List<Chain>.clear", "Logger.warn", "String.substring", "FileParsingParameters.getAcceptedAtomNames", "FileParsingParameters.getAcceptedAtomNames", "String.trim", "String.substring", "AtomImpl.setPDBserial", "AtomImpl.setAltLoc", "AtomImpl.setName", "String.trim", "String.substring", "String.substring", "String.substring", "AtomImpl.setCoords", "String.length", "String.substring", "String.length", "String.substring", "AtomImpl.setOccupancy", "AtomImpl.setTempFactor", "String.length", "String.substring", "String.isEmpty", "Logger.info", "String.trim", "Logger.info", "String.trim", "Logger.info", "String.trim", "Group.getChemComp", "Group.getChemComp", "float.getAtomId", "String.trim", "float.getTypeSymbol", "Logger.info", "String.trim", "Group.getPDBName", "Logger.info", "String.trim", "Logger.warn", "String.trim", "AtomImpl.setElement", "Group.addAtom", "Group.addAtom", "Group.hasAtom", "AtomImpl.getName", "Group.addAtom"], "method_name": "PDBFileParser.pdb_ATOM_Handler", "method_implementation": "{\n    if (params.isHeaderOnly())\n        return;\n    // let's first get the chain name which will serve to identify if we are starting a new molecule\n    String chainName = line.substring(21, 22);\n    if (\" \".equals(chainName)) {\n        blankChainIdsPresent = true;\n    }\n    if (currentChain != null && !currentChain.getName().equals(chainName)) {\n        // new chain name: another molecule coming\n        startOfMolecule = true;\n    }\n    if (startOfMolecule) {\n        // we add last chain if there was one\n        if (currentChain != null) {\n            currentModel.add(currentChain);\n            // let's not forget adding the last group to the finishing chain\n            if (currentGroup != null) {\n                currentChain.addGroup(currentGroup);\n            }\n        }\n        // we initialise the new molecule to come\n        currentChain = new ChainImpl();\n        // note that the chainId (asym id) is set properly later in assignAsymIds\n        currentChain.setId(chainName);\n        currentChain.setName(chainName);\n    }\n    if (startOfModel) {\n        // we add last model if there was one\n        if (currentModel != null) {\n            allModels.add(currentModel);\n        }\n        // we initialise the model to come\n        currentModel = new ArrayList<>();\n    }\n    // let's get the residue number and see if we need to start a new group\n    String groupCode3 = line.substring(17, 20).trim();\n    String resNum = line.substring(22, 26).trim();\n    Character iCode = line.substring(26, 27).charAt(0);\n    if (iCode == ' ')\n        iCode = null;\n    ResidueNumber residueNumber = new ResidueNumber(chainName, Integer.valueOf(resNum), iCode);\n    //recordName      groupCode3\n    //|                |    resNum\n    //|                |    |   iCode\n    //|     |          | |  |   ||\n    //ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N\n    //ATOM   1964  N   ARG H 221A      5.963 -16.715  27.669  1.00 28.59           N\n    Character aminoCode1 = StructureTools.get1LetterCode(groupCode3);\n    String recordName = line.substring(0, 6).trim();\n    boolean isHetAtomInFile = false;\n    if (\"HETATM\".equals(recordName)) {\n        // HETATOM RECORDS are treated slightly differently\n        // some modified amino acids that we want to treat as amino acids\n        // can be found as HETATOM records\n        if (aminoCode1 != null && aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL))\n            aminoCode1 = null;\n        isHetAtomInFile = true;\n    }\n    if (startOfMolecule) {\n        currentGroup = getNewGroup(recordName, aminoCode1, groupCode3);\n        currentGroup.setPDBName(groupCode3);\n        currentGroup.setResidueNumber(residueNumber);\n        currentGroup.setHetAtomInFile(isHetAtomInFile);\n    }\n    // resetting states\n    startOfModel = false;\n    startOfMolecule = false;\n    Character altLoc = line.substring(16, 17).charAt(0);\n    Group altGroup = null;\n    // check if residue number is the same ...\n    if (!residueNumber.equals(currentGroup.getResidueNumber())) {\n        currentChain.addGroup(currentGroup);\n        currentGroup.trimToSize();\n        currentGroup = getNewGroup(recordName, aminoCode1, groupCode3);\n        currentGroup.setPDBName(groupCode3);\n        currentGroup.setResidueNumber(residueNumber);\n        currentGroup.setHetAtomInFile(isHetAtomInFile);\n    } else {\n        // same residueNumber, but altLocs...\n        // test altLoc\n        if (!altLoc.equals(' ')) {\n            logger.debug(\"found altLoc! \" + currentGroup + \" \" + altGroup);\n            altGroup = getCorrectAltLocGroup(altLoc, recordName, aminoCode1, groupCode3);\n            if (altGroup.getChain() == null) {\n                // need to set current chain\n                altGroup.setChain(currentChain);\n            }\n        }\n    }\n    atomCount++;\n    if (atomCount == atomCAThreshold) {\n        // throw away the SEQRES lines - too much to deal with...\n        logger.warn(\"more than \" + atomCAThreshold + \" atoms in this structure, ignoring the SEQRES lines\");\n        seqResChains.clear();\n        switchCAOnly();\n    }\n    if (atomCount == loadMaxAtoms) {\n        logger.warn(\"File has more atoms than max specified in parsing parameters ({}). Ignoring atoms after line: {}\", loadMaxAtoms, line);\n        return;\n    }\n    if (atomCount > loadMaxAtoms) {\n        return;\n    }\n    //          1         2         3         4         5         6\n    //012345678901234567890123456789012345678901234567890123456789\n    //ATOM      1  N   MET     1      20.154  29.699   5.276   1.0\n    //ATOM    112  CA  ASP   112      41.017  33.527  28.371  1.00  0.00\n    //ATOM     53  CA  MET     7      23.772  33.989 -21.600  1.00  0.00           C\n    //ATOM    112  CA  ASP   112      37.613  26.621  33.571     0     0\n    String fullname = line.substring(12, 16);\n    // check for CA only if requested\n    if (parseCAonly) {\n        // yes , user wants to get CA only\n        // only parse CA atoms...\n        if (!\" CA \".equals(fullname)) {\n            //System.out.println(\"ignoring \" + line);\n            atomCount--;\n            return;\n        }\n    }\n    if (params.getAcceptedAtomNames() != null) {\n        boolean found = false;\n        for (String ok : params.getAcceptedAtomNames()) {\n            //System.out.println(ok + \"< >\" + fullname +\"<\");\n            if (ok.equals(fullname.trim())) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            atomCount--;\n            return;\n        }\n    }\n    // create new atom\n    int pdbnumber = Integer.parseInt(line.substring(6, 11).trim());\n    AtomImpl atom = new AtomImpl();\n    atom.setPDBserial(pdbnumber);\n    atom.setAltLoc(altLoc);\n    atom.setName(fullname.trim());\n    double x = Double.parseDouble(line.substring(30, 38).trim());\n    double y = Double.parseDouble(line.substring(38, 46).trim());\n    double z = Double.parseDouble(line.substring(46, 54).trim());\n    double[] coords = new double[3];\n    coords[0] = x;\n    coords[1] = y;\n    coords[2] = z;\n    atom.setCoords(coords);\n    float occu = 1.0f;\n    if (line.length() > 59) {\n        try {\n            // occu and tempf are sometimes not used :-/\n            occu = Float.parseFloat(line.substring(54, 60).trim());\n        } catch (NumberFormatException e) {\n        }\n    }\n    float tempf = 0.0f;\n    if (line.length() > 65) {\n        try {\n            tempf = Float.parseFloat(line.substring(60, 66).trim());\n        } catch (NumberFormatException e) {\n        }\n    }\n    atom.setOccupancy(occu);\n    atom.setTempFactor(tempf);\n    // Parse element from the element field. If this field is\n    // missing (i.e. misformatted PDB file), then parse the\n    // element from the chemical component.\n    Element element = Element.R;\n    boolean guessElement = true;\n    if (line.length() > 77) {\n        // parse element from element field\n        String elementSymbol = line.substring(76, 78).trim();\n        if (elementSymbol.isEmpty()) {\n            logger.info(\"Element column was empty for atom {} {}. Assigning atom element \" + \"from Chemical Component Dictionary information\", fullname.trim(), pdbnumber);\n        } else {\n            try {\n                element = Element.valueOfIgnoreCase(elementSymbol);\n                guessElement = false;\n            } catch (IllegalArgumentException e) {\n                logger.info(\"Element {} of atom {} {} was not recognised. Assigning atom element \" + \"from Chemical Component Dictionary information\", elementSymbol, fullname.trim(), pdbnumber);\n            }\n        }\n    } else {\n        logger.info(\"Missformatted PDB file: element column of atom {} {} is not present. \" + \"Assigning atom element from Chemical Component Dictionary information\", fullname.trim(), pdbnumber);\n    }\n    if (guessElement) {\n        String elementSymbol = null;\n        if (currentGroup.getChemComp() != null) {\n            for (ChemCompAtom a : currentGroup.getChemComp().getAtoms()) {\n                if (a.getAtomId().equals(fullname.trim())) {\n                    elementSymbol = a.getTypeSymbol();\n                    break;\n                }\n            }\n            if (elementSymbol == null) {\n                logger.info(\"Atom name {} was not found in the Chemical Component Dictionary information of {}. \" + \"Assigning generic element R to it\", fullname.trim(), currentGroup.getPDBName());\n            } else {\n                try {\n                    element = Element.valueOfIgnoreCase(elementSymbol);\n                } catch (IllegalArgumentException e) {\n                    // this can still happen for cases like UNK\n                    logger.info(\"Element symbol {} found in chemical component dictionary for Atom {} {} could not be recognised as a known element. \" + \"Assigning generic element R to it\", elementSymbol, fullname.trim(), pdbnumber);\n                }\n            }\n        } else {\n            logger.warn(\"Chemical Component Dictionary information was not found for Atom name {}. \" + \"Assigning generic element R to it\", fullname.trim());\n        }\n    }\n    atom.setElement(element);\n    //see if chain_id is one of the previous chains ...\n    if (altGroup != null) {\n        altGroup.addAtom(atom);\n        altGroup = null;\n    } else {\n        currentGroup.addAtom(atom);\n    }\n    // make sure that main group has all atoms\n    // GitHub issue: #76\n    if (!currentGroup.hasAtom(atom.getName())) {\n        currentGroup.addAtom(atom);\n    }\n}", "repo_id": "9", "comment": "/**\n * Handler for ATOM.\n * Record Format:\n *\n * <pre>\n * ATOM      1  N   ASP A  15     110.964  24.941  59.191  1.00 83.44           N\n *\n * COLUMNS        DATA TYPE       FIELD         DEFINITION\n * ---------------------------------------------------------------------------------\n * 1 -  6        Record name     \"ATOM  \"\n * 7 - 11        Integer         serial        Atom serial number.\n * 13 - 16        Atom            name          Atom name.\n * 17             Character       altLoc        Alternate location indicator.\n * 18 - 20        Residue name    resName       Residue name.\n * 22             Character       chainID       Chain identifier.\n * 23 - 26        Integer         resSeq        Residue sequence number.\n * 27             AChar           iCode         Code for insertion of residues.\n * 31 - 38        Real(8.3)       x             Orthogonal coordinates for X in Angstroms.\n * 39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in Angstroms.\n * 47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in Angstroms.\n * 55 - 60        Real(6.2)       occupancy     Occupancy.\n * 61 - 66        Real(6.2)       tempFactor    Temperature factor.\n * 73 - 76        LString(4)      segID         Segment identifier, left-justified.\n * 77 - 78        LString(2)      element       Element symbol, right-justified.\n * 79 - 80        LString(2)      charge        Charge on the atom.\n * </pre>\n */\n", "repo_name": "biojava-master/", "id": 1179, "method_signature": "void pdb_ATOM_Handler(String)"}, "255": {"callee_method_names": [], "method_name": "ProteinModificationRegistry.allModifications", "method_implementation": "{\n    lazyInit();\n    return Collections.unmodifiableSet(registry);\n}", "repo_id": "9", "comment": "/**\n * @return set of all registered ProteinModifications.\n */\n", "repo_name": "biojava-master/", "id": 255, "method_signature": "Set<ProteinModification> allModifications()"}, "667": {"callee_method_names": ["Phylogeny.setName"], "method_name": "MultipleAlignmentTools.getKimuraTree", "method_implementation": "{\n    MultipleSequenceAlignment<ProteinSequence, AminoAcidCompound> msa = MultipleAlignmentTools.toProteinMSA(msta);\n    BasicSymmetricalDistanceMatrix distmat = (BasicSymmetricalDistanceMatrix) DistanceMatrixCalculator.kimuraDistance(msa);\n    Phylogeny tree = TreeConstructor.distanceTree(distmat, TreeConstructorType.NJ);\n    tree.setName(\"Kimura Tree\");\n    return tree;\n}", "repo_id": "9", "comment": "/**\n * Calculate a phylogenetic tree of the MultipleAlignment using Kimura\n * distances and the Neighbor Joining algorithm from forester.\n *\n * @param msta\n *            MultipleAlignment of protein structures\n * @return Phylogeny phylogenetic tree\n * @throws CompoundNotFoundException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 667, "method_signature": "Phylogeny getKimuraTree(MultipleAlignment)"}, "1788": {"callee_method_names": [], "method_name": "PDBHeader.getKeywords", "method_implementation": "{\n    return keywords;\n}", "repo_id": "9", "comment": "/**\n * Gets the keywords (KEYWODS) record of the structure\n * @return The keywords in a <code>List&lt;String&gt;</code>\n * @since 6.0.0\n */\n", "repo_name": "biojava-master/", "id": 1788, "method_signature": "List<String> getKeywords()"}, "2915": {"callee_method_names": [], "method_name": "AbstractSequence.setSource", "method_implementation": "{\n    this.source = source;\n}", "repo_id": "9", "comment": "/**\n * Added support for the source of this sequence for GFF3 export\n * @param source the source to set\n */\n", "repo_name": "biojava-master/", "id": 2915, "method_signature": "void setSource(String)"}, "3066": {"callee_method_names": ["LinkedHashMap.remove"], "method_name": "GeneSequence.removeTranscript", "method_implementation": "{\n    return transcriptSequenceHashMap.remove(accession);\n}", "repo_id": "9", "comment": "/**\n * Remove the transcript sequence from the gene\n * @param accession\n * @return transcriptsequence\n */\n", "repo_name": "biojava-master/", "id": 3066, "method_signature": "TranscriptSequence removeTranscript(String)"}, "1187": {"callee_method_ids": [1317], "callee_method_names": ["FileParsingParameters.isHeaderOnly", "Logger.debug", "String.substring", "LinkedHashMap.get", "LinkedHashMap.containsKey", "String.trim", "LinkedHashMap.put", "String.trim", "Logger.debug", "Logger.debug", "LinkedHashMap.size", "Logger.debug", "String.substring", "String.substring", "Logger.debug", "String.substring", "Character.equals", "String.substring", "String.substring", "String.substring", "Logger.debug", "Logger.debug", "ResidueNumber.setChainName", "ResidueNumber.setSeqNum", "ResidueNumber.setInsCode", "List<ResidueNumber>.add", "Logger.debug", "String.substring", "Logger.debug", "LinkedHashMap.keySet", "LinkedHashMap.keySet", "Logger.debug", "LinkedHashMap.get"], "method_name": "PDBFileParser.pdb_SITE_Handler", "method_implementation": "{\n    if (params.isHeaderOnly())\n        return;\n    //  make a map of: SiteId to List<ResidueNumber>\n    logger.debug(\"Site Line:{}\", line);\n    String siteID = line.substring(11, 14);\n    //fetch the siteResidues from the map\n    List<ResidueNumber> siteResidues = siteToResidueMap.get(siteID);\n    //if the siteResidues doesn't yet exist, make a new one.\n    if (siteResidues == null || !siteToResidueMap.containsKey(siteID.trim())) {\n        siteResidues = new ArrayList<ResidueNumber>();\n        siteToResidueMap.put(siteID.trim(), siteResidues);\n        logger.debug(String.format(\"New Site made: %s %s\", siteID, siteResidues));\n        logger.debug(\"Now made {} sites\", siteMap.size());\n    }\n    logger.debug(String.format(\"SiteId: %s\", siteID));\n    //line = 'SITE     1 AC1  6 ARG H 221A LYS H 224  HOH H 403  HOH H 460'\n    //line.substring(18) = 'ARG H 221A LYS H 224  HOH H 403  HOH H 460'\n    line = line.substring(18);\n    String groupString = null;\n    //groupString = 'ARG H 221A'\n    //keep iterating through chunks of 10 characters - these are the groups in the siteResidues\n    while (!\"          \".equals((groupString = line.substring(0, 10)))) {\n        //groupstring: 'ARG H 221A'\n        logger.debug(\"groupString: '{}'\", groupString);\n        //set the residue name\n        //residueName = 'ARG'\n        String residueName = groupString.substring(0, 3);\n        Character aminoCode1 = StructureTools.get1LetterCode(residueName);\n        if (aminoCode1 != null) {\n            if (aminoCode1.equals(StructureTools.UNKNOWN_GROUP_LABEL)) {\n                aminoCode1 = null;\n            }\n        }\n        //this is already in the right format, so no need to fiddle with it...\n        //pdbCode = 'H 221A'\n        //                    String pdbCode = groupString.substring(4, 10).trim();\n        String chainId = groupString.substring(4, 5);\n        Integer resNum = Integer.valueOf(groupString.substring(5, 9).trim());\n        Character insCode = groupString.substring(9, 10).charAt(0);\n        //set insCode to null as a measure to prevent storing thousands of empty Strings\n        //- the empty value is returned using Group.getInsCode()\n        //                    if (insCode.equals(\" \")) {\n        //                        insCode = null;\n        //                    }\n        logger.debug(String.format(\"Site: %s: 'resName:%s resNum:%s insCode:%s'\", siteID, residueName, resNum, insCode));\n        //make a new resNum with the data - this will be linked up with a site later\n        ResidueNumber residueNumber = new ResidueNumber();\n        logger.debug(\"pdbCode: '{}{}'\", resNum, insCode);\n        residueNumber.setChainName(chainId);\n        residueNumber.setSeqNum(resNum);\n        residueNumber.setInsCode(insCode);\n        //add the resNum to the groups\n        siteResidues.add(residueNumber);\n        logger.debug(\"Adding residueNumber \" + residueNumber + \" to site \" + siteID);\n        line = line.substring(11);\n    }\n    logger.debug(\"Current SiteMap (contains {} sites):\", siteToResidueMap.keySet().size());\n    for (String key : siteToResidueMap.keySet()) {\n        logger.debug(key + \" : \" + siteToResidueMap.get(key));\n    }\n}", "repo_id": "9", "comment": "/**\n * Handler for the SITE records. <br>\n *\n * <pre>\n *\n * COLUMNS\tDATA TYPE \t\tFIELD \t\tDEFINITION\n * ---------------------------------------------------------------------------------\n * 1 - 6\tRecord name \t\"SITE \"\n * 8 - 10 \tInteger \t\tseqNum \t\tSequence number.\n * 12 - 14 \tLString(3)\t\tsiteID \t\tSite name.\n * 16 - 17 \tInteger \t\tnumRes \t\tNumber of residues that compose the siteResidues.\n * 19 - 21 \tResidue name\tresName1\tResidue name for first residue that\n * \t\t\t\t\t\t\t\t\t\tcreates the siteResidues.\n * 23 \t\tCharacter \t\tchainID1 \tChain identifier for first residue of siteResidues.\n * 24 - 27 \tInteger \t\tseq1 \t\tResidue sequence number for first residue\n * \t\t\t\t\t\t\t\t\t\tof the siteResidues.\n * 28 \t\tAChar \t\t\tiCode1 \t\tInsertion code for first residue of the siteResidues.\n *\n * example:\n *          1         2         3         4         5         6         7         8\n * 12345678901234567890123456789012345678901234567890123456789012345678901234567890\n * SITE     1 AC1  3 HIS A  94 HIS A   96  HIS A 119\n * SITE     1 AC2  5 ASN A  62 GLY A   63  HIS A  64  HOH A 328\n * SITE     2 AC2  5 HOH A 634\n * SITE     1 AC3  5 GLN A 136 GLN A  137  PRO A 138  GLU A 205\n * SITE     2 AC3  5 CYS A 206\n * SITE     1 AC4 11 HIS A  64 HIS A   94  HIS A  96  HIS A 119\n * SITE     2 AC4 11 LEU A 198 THR A  199  THR A 200  TRP A 209\n * SITE     3 AC4 11 HOH A 572 HOH A  582  HOH A 635\n * </pre>\n * @param line the SITE line record being currently read\n * @author Amr ALHOSSARY\n * @author Jules Jacobsen\n */\n", "repo_name": "biojava-master/", "id": 1187, "method_signature": "void pdb_SITE_Handler(String)"}, "1010": {"callee_method_names": ["ResidueRange.getStart", "ResidueRange.getEnd", "ResidueRange.getChainName", "ResidueNumber.getChainName", "ResidueNumber.getSeqNum", "ResidueNumber.getInsCode", "ResidueNumber.getChainName", "ResidueNumber.getSeqNum", "ResidueNumber.getInsCode", "TreeMap<ResidueNumber, Integer>.keySet", "Key.getChainName", "ResidueNumber.getSeqNum", "Key.getSeqNum", "Logger.error", "Logger.warn", "ResidueRange.getStart", "TreeMap<ResidueNumber, Integer>.descendingKeySet", "Key.getChainName", "ResidueNumber.getSeqNum", "Key.getSeqNum", "Logger.error", "Logger.warn", "ResidueRange.getEnd"], "method_name": "AtomPositionMap.trimToValidResidues", "method_implementation": "{\n    ResidueNumber start = rr.getStart();\n    ResidueNumber end = rr.getEnd();\n    String chain = rr.getChainName();\n    // Add chainName\n    if (start.getChainName() == null) {\n        start = new ResidueNumber(chain, start.getSeqNum(), start.getInsCode());\n    }\n    if (end.getChainName() == null) {\n        end = new ResidueNumber(chain, end.getSeqNum(), end.getInsCode());\n    }\n    // Check that start and end are present in the map.\n    // If not, try to find the next valid residue\n    // (terminal residues sometimes lack CA atoms, so they don't appear)\n    Integer startIndex = getPosition(start);\n    if (startIndex == null) {\n        // Assume that the residue numbers are sequential\n        // Find startIndex such that the SeqNum is bigger than start's seqNum\n        for (ResidueNumber key : treeMap.keySet()) {\n            if (!key.getChainName().equals(chain))\n                continue;\n            if (start.getSeqNum() <= key.getSeqNum()) {\n                start = key;\n                startIndex = getPosition(key);\n                break;\n            }\n        }\n        if (startIndex == null) {\n            logger.error(\"Unable to find Residue {} in AtomPositionMap, and no plausible substitute.\", start);\n            return null;\n        } else {\n            logger.warn(\"Unable to find Residue {}, so substituting {}.\", rr.getStart(), start);\n        }\n    }\n    Integer endIndex = getPosition(end);\n    if (endIndex == null) {\n        // Assume that the residue numbers are sequential\n        // Find startIndex such that the SeqNum is bigger than start's seqNum\n        for (ResidueNumber key : treeMap.descendingKeySet()) {\n            if (!key.getChainName().equals(chain))\n                continue;\n            Integer value = getPosition(key);\n            if (value < startIndex) {\n                // start is before the end!\n                break;\n            }\n            if (end.getSeqNum() >= key.getSeqNum()) {\n                end = key;\n                endIndex = value;\n                break;\n            }\n        }\n        if (endIndex == null) {\n            logger.error(\"Unable to find Residue {} in AtomPositionMap, and no plausible substitute.\", end);\n            return null;\n        } else {\n            logger.warn(\"Unable to find Residue {}, so substituting {}.\", rr.getEnd(), end);\n        }\n    }\n    // now use those to calculate the length\n    // if start or end is null, will throw NPE\n    int length = getLength(startIndex, endIndex, chain);\n    return new ResidueRangeAndLength(chain, start, end, length);\n}", "repo_id": "9", "comment": "/**\n * Trims a residue range so that both endpoints are contained in this map.\n * @param rr residue range\n * @return residue range and length\n */\n", "repo_name": "biojava-master/", "id": 1010, "method_signature": "ResidueRangeAndLength trimToValidResidues(ResidueRange)"}, "1628": {"callee_method_names": [], "method_name": "SubunitClustererParameters.getTMThreshold", "method_implementation": "{\n    return tmThreshold;\n}", "repo_id": "9", "comment": "/**\n * Structure similarity threshold (measured with TMScore) to consider for the\n * structural subunit clustering.\n *\n * @return tmThreshold\n */\n", "repo_name": "biojava-master/", "id": 1628, "method_signature": "double getTMThreshold()"}, "2525": {"callee_method_names": [], "method_name": "SubstitutionMatrixHelper.getBlosum55", "method_implementation": "{\n    return getAminoAcidMatrix(\"blosum55\");\n}", "repo_id": "9", "comment": "/**\n * Returns Blosum 55 matrix by Henikoff & Henikoff\n * @return Blosum 55 matrix\n */\n", "repo_name": "biojava-master/", "id": 2525, "method_signature": "SubstitutionMatrix<AminoAcidCompound> getBlosum55()"}, "8": {"callee_method_names": ["BasicSymmetricalDistanceMatrix.getSize", "BasicSymmetricalDistanceMatrix.getSize", "BasicSymmetricalDistanceMatrix.getValue"], "method_name": "GuideTree.getDistanceMatrix", "method_implementation": "{\n    double[][] matrix = new double[distances.getSize()][distances.getSize()];\n    for (int i = 0; i < matrix.length; i++) {\n        for (int j = i + 1; j < matrix.length; j++) {\n            matrix[i][j] = matrix[j][i] = distances.getValue(i, j);\n        }\n    }\n    return matrix;\n}", "repo_id": "9", "comment": "/**\n * Returns the distance matrix used to construct this guide tree.  The scores have been normalized.\n *\n * @return the distance matrix used to construct this guide tree\n */\n", "repo_name": "biojava-master/", "id": 8, "method_signature": "double[][] getDistanceMatrix()"}, "3151": {"callee_method_names": [], "method_name": "SequenceFileProxyLoader.getCompoundAt", "method_implementation": "{\n    return this.parsedCompounds.get(position - 1);\n}", "repo_id": "9", "comment": "/**\n * @param position\n * @return\n */\n", "repo_name": "biojava-master/", "id": 3151, "method_signature": "C getCompoundAt(int)"}, "2902": {"callee_method_names": [], "method_name": "AbstractSequence.getBioEnd", "method_implementation": "{\n    if (bioEnd == null) {\n        return this.getLength();\n    } else {\n        return bioEnd;\n    }\n}", "repo_id": "9", "comment": "/**\n * @return the bioEnd\n */\n", "repo_name": "biojava-master/", "id": 2902, "method_signature": "Integer getBioEnd()"}, "1771": {"callee_method_names": [], "method_name": "PDBHeader.getExperimentalTechniques", "method_implementation": "{\n    return techniques;\n}", "repo_id": "9", "comment": "/**\n * Return the Set of ExperimentalTechniques, usually the set is of size 1 except for hybrid\n * experimental techniques when the Set will contain 2 or more values\n * @return the Set of ExperimentalTechniques or null if not set\n */\n", "repo_name": "biojava-master/", "id": 1771, "method_signature": "Set<ExperimentalTechnique> getExperimentalTechniques()"}, "1644": {"callee_method_names": [], "method_name": "SubunitClustererParameters.isUseSequenceCoverage", "method_implementation": "{\n    return useSequenceCoverage;\n}", "repo_id": "9", "comment": "/**\n * Use sequence coverage for evaluating sequence similarity\n *\n * @return useSequenceCoverage\n */\n", "repo_name": "biojava-master/", "id": 1644, "method_signature": "boolean isUseSequenceCoverage()"}, "2212": {"callee_method_names": [], "method_name": "TestAltLocs.testAllAltLocsSameAtomsMainGroup", "method_implementation": "{\n    doTestAllAltLocsSamAtomsMainGroup(\"3nu4\");\n    doTestAllAltLocsSamAtomsMainGroup(\"3nvd\");\n    doTestAllAltLocsSamAtomsMainGroup(\"4txr\");\n    doTestAllAltLocsSamAtomsMainGroup(\"3nvd\");\n    doTestAllAltLocsSamAtomsMainGroup(\"4cup\");\n}", "repo_id": "9", "comment": "/**\n * A test that all alternate location groups have the same number of atoms as the main group\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2212, "method_signature": "void testAllAltLocsSameAtomsMainGroup()"}, "2610": {"callee_method_names": [], "method_name": "ConcurrencyTools.setThreadPoolDefault", "method_implementation": "{\n    setThreadPoolCPUsAvailable(0);\n}", "repo_id": "9", "comment": "/**\n * Sets thread pool to default of 1 background thread for each processor core.\n */\n", "repo_name": "biojava-master/", "id": 2610, "method_signature": "void setThreadPoolDefault()"}, "1535": {"callee_method_names": [], "method_name": "JournalArticle.setTitle", "method_implementation": "{\n    this.title = title;\n}", "repo_id": "9", "comment": "/**\n * Set the value of title\n *\n * @param title new value of title\n */\n", "repo_name": "biojava-master/", "id": 1535, "method_signature": "void setTitle(String)"}, "468": {"callee_method_names": [], "method_name": "StructureName.isFile", "method_implementation": "{\n    return mySource == Source.FILE;\n}", "repo_id": "9", "comment": "/**\n * Indicates that the identifier was determined to correspond to a file.\n * Note that some file identifiers may also be valid URLs; in that case,\n * the URL source is preferred.\n * @return\n */\n", "repo_name": "biojava-master/", "id": 468, "method_signature": "boolean isFile()"}, "2773": {"callee_method_names": ["Sequence<?>.getAccession", "FastaWriter<Sequence<?>, Compound>.process"], "method_name": "FastaWriterHelper.writeSequences", "method_implementation": "{\n    FastaHeaderFormatInterface<Sequence<?>, Compound> fhfi = new FastaHeaderFormatInterface<Sequence<?>, Compound>() {\n\n        @Override\n        public String getHeader(Sequence<?> sequence) {\n            return sequence.getAccession().toString();\n        }\n    };\n    FastaWriter<Sequence<?>, Compound> fastaWriter = new FastaWriter<Sequence<?>, Compound>(outputStream, sequences, fhfi);\n    fastaWriter.process();\n}", "repo_id": "9", "comment": "/**\n * Method which will write your given Sequences to the specified\n * {@link OutputStream}. This is a very generic method which writes just the\n * AccessionID of the Sequence as the FASTA header.\n *\n * @param outputStream Stream to write to; can be System.out\n * @param sequences The sequences to write out\n * @throws Exception Thrown normally thanks to IO problems\n */\n", "repo_name": "biojava-master/", "id": 2773, "method_signature": "void writeSequences(OutputStream, Collection)"}, "2213": {"callee_method_ids": [1322, 1330], "callee_method_names": ["FileParsingParameters.setAlignSeqRes", "FileParsingParameters.setCreateAtomBonds", "AtomCache.setFileParsingParams", "Structure.getChains", "Chain.getAtomGroups", "Group.getAltLocs", "Group.size"], "method_name": "TestAltLocs.doTestAllAltLocsSamAtomsMainGroup", "method_implementation": "{\n    AtomCache cache = new AtomCache();\n    FileParsingParameters params = new FileParsingParameters();\n    params.setAlignSeqRes(true);\n    params.setCreateAtomBonds(true);\n    cache.setFileParsingParams(params);\n    StructureIO.setAtomCache(cache);\n    Structure structure = StructureIO.getStructure(pdbId);\n    // Loop through the atoms\n    for (Chain c : structure.getChains()) {\n        for (Group g : c.getAtomGroups()) {\n            for (Group altLocGroup : g.getAltLocs()) {\n                assertEquals(g.size(), altLocGroup.size());\n            }\n        }\n    }\n}", "repo_id": "9", "comment": "/**\n * Actually perform the test to see all alt locs are the same size as the main group\n * @throws StructureException\n * @throws IOException\n */\n", "repo_name": "biojava-master/", "id": 2213, "method_signature": "void doTestAllAltLocsSamAtomsMainGroup(String)"}, "1092": {"callee_method_names": ["String.endsWith"], "method_name": "DownloadChemCompProvider.setServerBaseUrl", "method_implementation": "{\n    if (!serverBaseUrl.endsWith(\"/\")) {\n        serverBaseUrl = serverBaseUrl + \"/\";\n    }\n    DownloadChemCompProvider.serverBaseUrl = serverBaseUrl;\n}", "repo_id": "9", "comment": "/**\n * Set the base URL for the location of all chemical component CIF files, to which the chemCompPathUrlTemplate\n * is appended, settable in {@link #setChemCompPathUrlTemplate(String)}. A trailing slash is appended\n * if not present.\n */\n", "repo_name": "biojava-master/", "id": 1092, "method_signature": "void setServerBaseUrl(String)"}}