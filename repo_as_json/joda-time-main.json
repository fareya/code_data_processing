{"AbstractDateTime.get": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "AbstractDateTime.get", "method_implementation": "{\n    if (type == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    return type.getField(getChronology()).get(getMillis());\n}", "repo_id": "7", "comment": "/**\n * Get the value of one of the fields of a datetime.\n * <p>\n * This method uses the chronology of the datetime to obtain the value.\n * It is essentially a generic way of calling one of the get methods.\n *\n * @param type  a field type, usually obtained from DateTimeFieldType\n * @return the value of that field\n * @throws IllegalArgumentException if the field type is null\n */\n", "repo_name": "joda-time-main/", "id": 520, "method_signature": "int get(DateTimeFieldType)"}, "AbstractDateTime.toCalendar": {"callee_method_names": ["DateTimeZone.toTimeZone", "Calendar.setTime"], "method_name": "AbstractDateTime.toCalendar", "method_implementation": "{\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    DateTimeZone zone = getZone();\n    Calendar cal = Calendar.getInstance(zone.toTimeZone(), locale);\n    cal.setTime(toDate());\n    return cal;\n}", "repo_id": "7", "comment": "/**\n * Get the date time as a <code>java.util.Calendar</code>, assigning\n * exactly the same millisecond instant.\n * The locale is passed in, enabling Calendar to select the correct\n * localized subclass.\n * <p>\n * The JDK and Joda-Time both have time zone implementations and these\n * differ in accuracy. Joda-Time's implementation is generally more up to\n * date and thus more accurate - for example JDK1.3 has no historical data.\n * The effect of this is that the field values of the <code>Calendar</code>\n * may differ from those of this object, even though the millisecond value\n * is the same. Most of the time this just means that the JDK field values\n * are wrong, as our time zone information is more up to date.\n *\n * @param locale  the locale to get the Calendar for, or default if null\n * @return a localized Calendar initialised with this datetime\n */\n", "repo_name": "joda-time-main/", "id": 521, "method_signature": "Calendar toCalendar(Locale)"}, "AbstractDateTime.toGregorianCalendar": {"callee_method_names": ["DateTimeZone.toTimeZone", "GregorianCalendar.setTime"], "method_name": "AbstractDateTime.toGregorianCalendar", "method_implementation": "{\n    DateTimeZone zone = getZone();\n    GregorianCalendar cal = new GregorianCalendar(zone.toTimeZone());\n    cal.setTime(toDate());\n    return cal;\n}", "repo_id": "7", "comment": "/**\n * Get the date time as a <code>java.util.GregorianCalendar</code>,\n * assigning exactly the same millisecond instant.\n * <p>\n * The JDK and Joda-Time both have time zone implementations and these\n * differ in accuracy. Joda-Time's implementation is generally more up to\n * date and thus more accurate - for example JDK1.3 has no historical data.\n * The effect of this is that the field values of the <code>Calendar</code>\n * may differ from those of this object, even though the millisecond value\n * is the same. Most of the time this just means that the JDK field values\n * are wrong, as our time zone information is more up to date.\n *\n * @return a GregorianCalendar initialised with this datetime\n */\n", "repo_name": "joda-time-main/", "id": 522, "method_signature": "GregorianCalendar toGregorianCalendar()"}, "AbstractDateTime.toString": {"callee_method_names": [], "method_name": "AbstractDateTime.toString", "method_implementation": "{\n    if (pattern == null) {\n        return toString();\n    }\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n}", "repo_id": "7", "comment": "/**\n * Output the instant using the specified format pattern.\n *\n * @param pattern  the pattern specification, null means use <code>toString</code>\n * @param locale  Locale to use, null means default\n * @return the formatted string, not null\n * @see  org.joda.time.format.DateTimeFormat\n */\n", "repo_name": "joda-time-main/", "id": 525, "method_signature": "String toString(String, Locale)"}, "AbstractDuration.compareTo": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "AbstractDuration.compareTo", "method_implementation": "{\n    long thisMillis = this.getMillis();\n    long otherMillis = other.getMillis();\n    // cannot do (thisMillis - otherMillis) as it can overflow\n    if (thisMillis < otherMillis) {\n        return -1;\n    }\n    if (thisMillis > otherMillis) {\n        return 1;\n    }\n    return 0;\n}", "repo_id": "7", "comment": "/**\n * Compares this duration with the specified duration based on length and direction.\n * <p>\n * The comparison takes into account the sign.\n * As such, a duration of 5 seconds is longer than a duration of <i>minus</i> 7 seconds.\n *\n * @param other  a duration to check against\n * @return negative value if this is less, 0 if equal, or positive value if greater\n * @throws NullPointerException if the object is null\n * @throws ClassCastException if the given object is not supported\n */\n", "repo_name": "joda-time-main/", "id": 527, "method_signature": "int compareTo(ReadableDuration)"}, "AbstractDuration.equals": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "AbstractDuration.equals", "method_implementation": "{\n    if (this == duration) {\n        return true;\n    }\n    if (duration instanceof ReadableDuration == false) {\n        return false;\n    }\n    ReadableDuration other = (ReadableDuration) duration;\n    return (getMillis() == other.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Compares this object with the specified object for equality based\n * on the millisecond length. All ReadableDuration instances are accepted.\n * <p>\n * The comparison takes into account the sign.\n * As such, a duration of 5 seconds is not equal to a duration of <i>minus</i> 5 seconds.\n *\n * @param duration  a readable duration to check against\n * @return true if the length of the duration is equal\n */\n", "repo_name": "joda-time-main/", "id": 531, "method_signature": "boolean equals(Object)"}, "AbstractDuration.hashCode": {"callee_method_names": [], "method_name": "AbstractDuration.hashCode", "method_implementation": "{\n    long len = getMillis();\n    return (int) (len ^ (len >>> 32));\n}", "repo_id": "7", "comment": "/**\n * Gets a hash code for the duration that is compatible with the\n * equals method.\n *\n * @return a hash code\n */\n", "repo_name": "joda-time-main/", "id": 532, "method_signature": "int hashCode()"}, "AbstractDuration.isEqual": {"callee_method_names": [], "method_name": "AbstractDuration.isEqual", "method_implementation": "{\n    if (duration == null) {\n        duration = Duration.ZERO;\n    }\n    return compareTo(duration) == 0;\n}", "repo_id": "7", "comment": "/**\n * Is the length of this duration equal to the duration passed in.\n * <p>\n * The comparison takes into account the sign.\n * As such, a duration of 5 seconds is not equal to a duration of <i>minus</i> 5 seconds.\n *\n * @param duration  another duration to compare to, null means zero milliseconds\n * @return true if this duration is equal to than the duration passed in\n */\n", "repo_name": "joda-time-main/", "id": 528, "method_signature": "boolean isEqual(ReadableDuration)"}, "AbstractDuration.isLongerThan": {"callee_method_names": [], "method_name": "AbstractDuration.isLongerThan", "method_implementation": "{\n    if (duration == null) {\n        duration = Duration.ZERO;\n    }\n    return compareTo(duration) > 0;\n}", "repo_id": "7", "comment": "/**\n * Is the length of this duration longer than the duration passed in.\n * <p>\n * The comparison takes into account the sign.\n * As such, a duration of 5 seconds is longer than a duration of <i>minus</i> 7 seconds.\n *\n * @param duration  another duration to compare to, null means zero milliseconds\n * @return true if this duration is strictly longer than the duration passed in\n */\n", "repo_name": "joda-time-main/", "id": 529, "method_signature": "boolean isLongerThan(ReadableDuration)"}, "AbstractDuration.isShorterThan": {"callee_method_names": [], "method_name": "AbstractDuration.isShorterThan", "method_implementation": "{\n    if (duration == null) {\n        duration = Duration.ZERO;\n    }\n    return compareTo(duration) < 0;\n}", "repo_id": "7", "comment": "/**\n * Is the length of this duration shorter than the duration passed in.\n * <p>\n * The comparison takes into account the sign.\n * As such, a duration of <i>minus</i> 5 seconds is shorter than a duration of 3 seconds.\n *\n * @param duration  another duration to compare to, null means zero milliseconds\n * @return true if this duration is strictly shorter than the duration passed in\n */\n", "repo_name": "joda-time-main/", "id": 530, "method_signature": "boolean isShorterThan(ReadableDuration)"}, "AbstractDuration.toString": {"callee_method_names": ["StringBuffer.append", "StringBuffer.length", "StringBuffer.insert", "StringBuffer.setLength", "StringBuffer.length", "StringBuffer.insert", "StringBuffer.length", "StringBuffer.append", "StringBuffer.toString"], "method_name": "AbstractDuration.toString", "method_implementation": "{\n    long millis = getMillis();\n    StringBuffer buf = new StringBuffer();\n    buf.append(\"PT\");\n    boolean negative = (millis < 0);\n    FormatUtils.appendUnpaddedInteger(buf, millis);\n    while (buf.length() < (negative ? 7 : 6)) {\n        buf.insert(negative ? 3 : 2, \"0\");\n    }\n    if ((millis / 1000) * 1000 == millis) {\n        buf.setLength(buf.length() - 3);\n    } else {\n        buf.insert(buf.length() - 3, \".\");\n    }\n    buf.append('S');\n    return buf.toString();\n}", "repo_id": "7", "comment": "/**\n * Gets the value as a String in the ISO8601 duration format including\n * only seconds and milliseconds.\n * <p>\n * For example, \"PT72.345S\" represents 1 minute, 12 seconds and 345 milliseconds.\n * <p>\n * For more control over the output, see\n * {@link org.joda.time.format.PeriodFormatterBuilder PeriodFormatterBuilder}.\n *\n * @return the value as an ISO8601 string\n */\n", "repo_name": "joda-time-main/", "id": 533, "method_signature": "String toString()"}, "AbstractInstant.compareTo": {"callee_method_names": ["ReadableInstant.getMillis"], "method_name": "AbstractInstant.compareTo", "method_implementation": "{\n    if (this == other) {\n        return 0;\n    }\n    long otherMillis = other.getMillis();\n    long thisMillis = getMillis();\n    // cannot do (thisMillis - otherMillis) as can overflow\n    if (thisMillis == otherMillis) {\n        return 0;\n    }\n    if (thisMillis < otherMillis) {\n        return -1;\n    } else {\n        return 1;\n    }\n}", "repo_id": "7", "comment": "/**\n * Compares this object with the specified object for ascending\n * millisecond instant order. This ordering is inconsistent with\n * equals, as it ignores the Chronology.\n * <p>\n * All ReadableInstant instances are accepted.\n *\n * @param other  a readable instant to check against\n * @return negative value if this is less, 0 if equal, or positive value if greater\n * @throws NullPointerException if the object is null\n * @throws ClassCastException if the object type is not supported\n */\n", "repo_name": "joda-time-main/", "id": 469, "method_signature": "int compareTo(ReadableInstant)"}, "AbstractInstant.equals": {"callee_method_names": ["ReadableInstant.getMillis", "ReadableInstant.getChronology"], "method_name": "AbstractInstant.equals", "method_implementation": "{\n    // must be to fulfil ReadableInstant contract\n    if (this == readableInstant) {\n        return true;\n    }\n    if (readableInstant instanceof ReadableInstant == false) {\n        return false;\n    }\n    ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n    return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Compares this object with the specified object for equality based\n * on the millisecond instant, chronology and time zone.\n * <p>\n * Two objects which represent the same instant in time, but are in\n * different time zones (based on time zone id), will be considered to\n * be different. Only two objects with the same {@link DateTimeZone},\n * {@link Chronology} and instant are equal.\n * <p>\n * See {@link #isEqual(ReadableInstant)} for an equals method that\n * ignores the Chronology and time zone.\n * <p>\n * All ReadableInstant instances are accepted.\n *\n * @param readableInstant  a readable instant to check against\n * @return true if millisecond and chronology are equal, false if\n *  not or the instant is null or of an incorrect type\n */\n", "repo_name": "joda-time-main/", "id": 467, "method_signature": "boolean equals(Object)"}, "AbstractInstant.get": {"callee_method_names": ["DateTimeField.get"], "method_name": "AbstractInstant.get", "method_implementation": "{\n    if (field == null) {\n        throw new IllegalArgumentException(\"The DateTimeField must not be null\");\n    }\n    return field.get(getMillis());\n}", "repo_id": "7", "comment": "/**\n * Get the value of one of the fields of a datetime.\n * <p>\n * This could be used to get a field using a different Chronology.\n * For example:\n * <pre>\n * Instant dt = new Instant();\n * int gjYear = dt.get(Chronology.getCoptic().year());\n * </pre>\n *\n * @param field  the DateTimeField to use, not null\n * @return the value\n * @throws IllegalArgumentException if the field is null\n */\n", "repo_name": "joda-time-main/", "id": 464, "method_signature": "int get(DateTimeField)"}, "AbstractInstant.hashCode": {"callee_method_names": [], "method_name": "AbstractInstant.hashCode", "method_implementation": "{\n    // must be to fulfil ReadableInstant contract\n    return ((int) (getMillis() ^ (getMillis() >>> 32))) + (getChronology().hashCode());\n}", "repo_id": "7", "comment": "/**\n * Gets a hash code for the instant as defined in <code>ReadableInstant</code>.\n *\n * @return a suitable hash code\n */\n", "repo_name": "joda-time-main/", "id": 468, "method_signature": "int hashCode()"}, "AbstractInstant.isSupported": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "AbstractInstant.isSupported", "method_implementation": "{\n    if (type == null) {\n        return false;\n    }\n    return type.getField(getChronology()).isSupported();\n}", "repo_id": "7", "comment": "/**\n * Checks if the field type specified is supported by this instant and chronology.\n * This can be used to avoid exceptions in {@link #get(DateTimeFieldType)}.\n *\n * @param type  a field type, usually obtained from DateTimeFieldType\n * @return true if the field type is supported\n */\n", "repo_name": "joda-time-main/", "id": 463, "method_signature": "boolean isSupported(DateTimeFieldType)"}, "AbstractInstant.toDateTime": {"callee_method_names": ["Chronology.withZone"], "method_name": "AbstractInstant.toDateTime", "method_implementation": "{\n    Chronology chrono = DateTimeUtils.getChronology(getChronology());\n    chrono = chrono.withZone(zone);\n    return new DateTime(getMillis(), chrono);\n}", "repo_id": "7", "comment": "/**\n * Get this object as a DateTime using the same chronology but a different zone.\n *\n * @param zone time zone to apply, or default if null\n * @return a DateTime using the same millis\n */\n", "repo_name": "joda-time-main/", "id": 465, "method_signature": "DateTime toDateTime(DateTimeZone)"}, "AbstractInstant.toMutableDateTime": {"callee_method_names": ["Chronology.withZone"], "method_name": "AbstractInstant.toMutableDateTime", "method_implementation": "{\n    Chronology chrono = DateTimeUtils.getChronology(getChronology());\n    chrono = chrono.withZone(zone);\n    return new MutableDateTime(getMillis(), chrono);\n}", "repo_id": "7", "comment": "/**\n * Get this object as a MutableDateTime using the same chronology but a different zone.\n *\n * @param zone time zone to apply, or default if null\n * @return a MutableDateTime using the same millis\n */\n", "repo_name": "joda-time-main/", "id": 466, "method_signature": "MutableDateTime toMutableDateTime(DateTimeZone)"}, "AbstractInstant.toString": {"callee_method_ids": [855], "callee_method_names": ["DateTimeFormatter.print"], "method_name": "AbstractInstant.toString", "method_implementation": "{\n    if (formatter == null) {\n        return toString();\n    }\n    return formatter.print(this);\n}", "repo_id": "7", "comment": "/**\n * Uses the specified formatter to convert this partial to a String.\n *\n * @param formatter  the formatter to use, null means use <code>toString()</code>.\n * @return the formatted string, not null\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 471, "method_signature": "String toString(DateTimeFormatter)"}, "AbstractInterval.checkInterval": {"callee_method_names": [], "method_name": "AbstractInterval.checkInterval", "method_implementation": "{\n    if (end < start) {\n        throw new IllegalArgumentException(\"The end instant must be greater than the start instant\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Validates an interval.\n *\n * @param start  the start instant in milliseconds\n * @param end  the end instant in milliseconds\n * @throws IllegalArgumentException if the interval is invalid\n */\n", "repo_name": "joda-time-main/", "id": 534, "method_signature": "void checkInterval(long, long)"}, "AbstractInterval.contains": {"callee_method_names": ["ReadableInterval.getStartMillis", "ReadableInterval.getEndMillis"], "method_name": "AbstractInterval.contains", "method_implementation": "{\n    if (interval == null) {\n        return containsNow();\n    }\n    long otherStart = interval.getStartMillis();\n    long otherEnd = interval.getEndMillis();\n    long thisStart = getStartMillis();\n    long thisEnd = getEndMillis();\n    return (thisStart <= otherStart && otherStart < thisEnd && otherEnd <= thisEnd);\n}", "repo_id": "7", "comment": "/**\n * Does this time interval contain the specified time interval.\n * <p>\n * Non-zero duration intervals are inclusive of the start instant and\n * exclusive of the end. The other interval is contained if this interval\n * wholly contains, starts, finishes or equals it.\n * A zero duration interval cannot contain anything.\n * <p>\n * When two intervals are compared the result is one of three states:\n * (a) they abut, (b) there is a gap between them, (c) they overlap.\n * The <code>contains</code> method is not related to these states.\n * In particular, a zero duration interval is contained at the start of\n * a larger interval, but does not overlap (it abuts instead).\n * <p>\n * For example:\n * <pre>\n * [09:00 to 10:00) contains [09:00 to 10:00)  = true\n * [09:00 to 10:00) contains [09:00 to 09:30)  = true\n * [09:00 to 10:00) contains [09:30 to 10:00)  = true\n * [09:00 to 10:00) contains [09:15 to 09:45)  = true\n * [09:00 to 10:00) contains [09:00 to 09:00)  = true\n *\n * [09:00 to 10:00) contains [08:59 to 10:00)  = false (otherStart before thisStart)\n * [09:00 to 10:00) contains [09:00 to 10:01)  = false (otherEnd after thisEnd)\n * [09:00 to 10:00) contains [10:00 to 10:00)  = false (otherStart equals thisEnd)\n *\n * [14:00 to 14:00) contains [14:00 to 14:00)  = false (zero duration contains nothing)\n * </pre>\n * Passing in a <code>null</code> parameter will have the same effect as\n * calling {@link #containsNow()}.\n *\n * @param interval  the time interval to compare to, null means a zero duration interval now\n * @return true if this time interval contains the time interval\n */\n", "repo_name": "joda-time-main/", "id": 537, "method_signature": "boolean contains(ReadableInterval)"}, "AbstractInterval.equals": {"callee_method_names": ["ReadableInterval.getStartMillis", "ReadableInterval.getEndMillis", "ReadableInterval.getChronology"], "method_name": "AbstractInterval.equals", "method_implementation": "{\n    if (this == readableInterval) {\n        return true;\n    }\n    if (readableInterval instanceof ReadableInterval == false) {\n        return false;\n    }\n    ReadableInterval other = (ReadableInterval) readableInterval;\n    return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Compares this object with the specified object for equality based\n * on start and end millis plus the chronology.\n * All ReadableInterval instances are accepted.\n * <p>\n * To compare the duration of two time intervals, use {@link #toDuration()}\n * to get the durations and compare those.\n *\n * @param readableInterval  a readable interval to check against\n * @return true if the intervals are equal comparing the start millis,\n *  end millis and chronology\n */\n", "repo_name": "joda-time-main/", "id": 544, "method_signature": "boolean equals(Object)"}, "AbstractInterval.hashCode": {"callee_method_names": [], "method_name": "AbstractInterval.hashCode", "method_implementation": "{\n    long start = getStartMillis();\n    long end = getEndMillis();\n    int result = 97;\n    result = 31 * result + ((int) (start ^ (start >>> 32)));\n    result = 31 * result + ((int) (end ^ (end >>> 32)));\n    result = 31 * result + getChronology().hashCode();\n    return result;\n}", "repo_id": "7", "comment": "/**\n * Hashcode compatible with equals method.\n *\n * @return suitable hashcode\n */\n", "repo_name": "joda-time-main/", "id": 545, "method_signature": "int hashCode()"}, "AbstractInterval.isAfter": {"callee_method_names": ["ReadableInterval.getEndMillis"], "method_name": "AbstractInterval.isAfter", "method_implementation": "{\n    long endMillis;\n    if (interval == null) {\n        endMillis = DateTimeUtils.currentTimeMillis();\n    } else {\n        endMillis = interval.getEndMillis();\n    }\n    return (getStartMillis() >= endMillis);\n}", "repo_id": "7", "comment": "/**\n * Is this time interval entirely after the specified interval.\n * <p>\n * Intervals are inclusive of the start instant and exclusive of the end.\n * Only the end time of the specified interval is used in the comparison.\n *\n * @param interval  the interval to compare to, null means now\n * @return true if this time interval is after the interval specified\n */\n", "repo_name": "joda-time-main/", "id": 542, "method_signature": "boolean isAfter(ReadableInterval)"}, "AbstractInterval.isBefore": {"callee_method_names": ["ReadableInterval.getStartMillis"], "method_name": "AbstractInterval.isBefore", "method_implementation": "{\n    if (interval == null) {\n        return isBeforeNow();\n    }\n    return isBefore(interval.getStartMillis());\n}", "repo_id": "7", "comment": "/**\n * Is this time interval entirely before the specified instant.\n * <p>\n * Intervals are inclusive of the start instant and exclusive of the end.\n *\n * @param interval  the interval to compare to, null means now\n * @return true if this time interval is before the interval specified\n */\n", "repo_name": "joda-time-main/", "id": 540, "method_signature": "boolean isBefore(ReadableInterval)"}, "AbstractInterval.overlaps": {"callee_method_names": ["ReadableInterval.getStartMillis", "ReadableInterval.getEndMillis"], "method_name": "AbstractInterval.overlaps", "method_implementation": "{\n    long thisStart = getStartMillis();\n    long thisEnd = getEndMillis();\n    if (interval == null) {\n        long now = DateTimeUtils.currentTimeMillis();\n        return (thisStart < now && now < thisEnd);\n    } else {\n        long otherStart = interval.getStartMillis();\n        long otherEnd = interval.getEndMillis();\n        return (thisStart < otherEnd && otherStart < thisEnd);\n    }\n}", "repo_id": "7", "comment": "/**\n * Does this time interval overlap the specified time interval.\n * <p>\n * Intervals are inclusive of the start instant and exclusive of the end.\n * An interval overlaps another if it shares some common part of the\n * datetime continuum.\n * <p>\n * When two intervals are compared the result is one of three states:\n * (a) they abut, (b) there is a gap between them, (c) they overlap.\n * The abuts state takes precedence over the other two, thus a zero duration\n * interval at the start of a larger interval abuts and does not overlap.\n * <p>\n * For example:\n * <pre>\n * [09:00 to 10:00) overlaps [08:00 to 08:30)  = false (completely before)\n * [09:00 to 10:00) overlaps [08:00 to 09:00)  = false (abuts before)\n * [09:00 to 10:00) overlaps [08:00 to 09:30)  = true\n * [09:00 to 10:00) overlaps [08:00 to 10:00)  = true\n * [09:00 to 10:00) overlaps [08:00 to 11:00)  = true\n *\n * [09:00 to 10:00) overlaps [09:00 to 09:00)  = false (abuts before)\n * [09:00 to 10:00) overlaps [09:00 to 09:30)  = true\n * [09:00 to 10:00) overlaps [09:00 to 10:00)  = true\n * [09:00 to 10:00) overlaps [09:00 to 11:00)  = true\n *\n * [09:00 to 10:00) overlaps [09:30 to 09:30)  = true\n * [09:00 to 10:00) overlaps [09:30 to 10:00)  = true\n * [09:00 to 10:00) overlaps [09:30 to 11:00)  = true\n *\n * [09:00 to 10:00) overlaps [10:00 to 10:00)  = false (abuts after)\n * [09:00 to 10:00) overlaps [10:00 to 11:00)  = false (abuts after)\n *\n * [09:00 to 10:00) overlaps [10:30 to 11:00)  = false (completely after)\n *\n * [14:00 to 14:00) overlaps [14:00 to 14:00)  = false (abuts before and after)\n * [14:00 to 14:00) overlaps [13:00 to 15:00)  = true\n * </pre>\n *\n * @param interval  the time interval to compare to, null means a zero length interval now\n * @return true if the time intervals overlap\n */\n", "repo_name": "joda-time-main/", "id": 538, "method_signature": "boolean overlaps(ReadableInterval)"}, "AbstractInterval.toDuration": {"callee_method_names": [], "method_name": "AbstractInterval.toDuration", "method_implementation": "{\n    long durMillis = toDurationMillis();\n    if (durMillis == 0) {\n        return Duration.ZERO;\n    } else {\n        return new Duration(durMillis);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the duration of this time interval.\n * <p>\n * The duration is equal to the end millis minus the start millis.\n *\n * @return the duration of the time interval\n * @throws ArithmeticException if the duration exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 543, "method_signature": "Duration toDuration()"}, "AbstractInterval.toString": {"callee_method_ids": [842, 852, 852], "callee_method_names": ["DateTimeFormatter.withChronology", "DateTimeFormatter.printTo", "StringBuffer.append", "DateTimeFormatter.printTo", "StringBuffer.toString"], "method_name": "AbstractInterval.toString", "method_implementation": "{\n    DateTimeFormatter printer = ISODateTimeFormat.dateTime();\n    printer = printer.withChronology(getChronology());\n    StringBuffer buf = new StringBuffer(48);\n    printer.printTo(buf, getStartMillis());\n    buf.append('/');\n    printer.printTo(buf, getEndMillis());\n    return buf.toString();\n}", "repo_id": "7", "comment": "/**\n * Output a string in ISO8601 interval format.\n * <p>\n * From version 2.1, the string includes the time zone offset.\n *\n * @return re-parsable string (in the default zone)\n */\n", "repo_name": "joda-time-main/", "id": 546, "method_signature": "String toString()"}, "AbstractPartial.compareTo": {"callee_method_names": ["ReadablePartial.size", "ReadablePartial.getFieldType", "ReadablePartial.getValue", "ReadablePartial.getValue"], "method_name": "AbstractPartial.compareTo", "method_implementation": "{\n    if (this == other) {\n        return 0;\n    }\n    if (size() != other.size()) {\n        throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n    }\n    for (int i = 0, isize = size(); i < isize; i++) {\n        if (getFieldType(i) != other.getFieldType(i)) {\n            throw new ClassCastException(\"ReadablePartial objects must have matching field types\");\n        }\n    }\n    // fields are ordered largest first\n    for (int i = 0, isize = size(); i < isize; i++) {\n        if (getValue(i) > other.getValue(i)) {\n            return 1;\n        }\n        if (getValue(i) < other.getValue(i)) {\n            return -1;\n        }\n    }\n    return 0;\n}", "repo_id": "7", "comment": "/**\n * Compares this partial with another returning an integer\n * indicating the order.\n * <p>\n * The fields are compared in order, from largest to smallest.\n * The first field that is non-equal is used to determine the result.\n * <p>\n * The specified object must be a partial instance whose field types\n * match those of this partial.\n * <p>\n * NOTE: Prior to v2.0, the {@code Comparable} interface was only implemented\n * in this class and not in the {@code ReadablePartial} interface.\n *\n * @param other  an object to check against\n * @return negative if this is less, zero if equal, positive if greater\n * @throws ClassCastException if the partial is the wrong class\n *  or if it has field types that don't match\n * @throws NullPointerException if the partial is null\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 492, "method_signature": "int compareTo(ReadablePartial)"}, "AbstractPartial.equals": {"callee_method_names": ["ReadablePartial.size", "ReadablePartial.getValue", "ReadablePartial.getFieldType", "ReadablePartial.getChronology"], "method_name": "AbstractPartial.equals", "method_implementation": "{\n    if (this == partial) {\n        return true;\n    }\n    if (partial instanceof ReadablePartial == false) {\n        return false;\n    }\n    ReadablePartial other = (ReadablePartial) partial;\n    if (size() != other.size()) {\n        return false;\n    }\n    for (int i = 0, isize = size(); i < isize; i++) {\n        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n            return false;\n        }\n    }\n    return FieldUtils.equals(getChronology(), other.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Compares this ReadablePartial with another returning true if the chronology,\n * field types and values are equal.\n *\n * @param partial  an object to check against\n * @return true if fields and values are equal\n */\n", "repo_name": "joda-time-main/", "id": 490, "method_signature": "boolean equals(Object)"}, "AbstractPartial.getFieldTypes": {"callee_method_names": [], "method_name": "AbstractPartial.getFieldTypes", "method_implementation": "{\n    DateTimeFieldType[] result = new DateTimeFieldType[size()];\n    for (int i = 0; i < result.length; i++) {\n        result[i] = getFieldType(i);\n    }\n    return result;\n}", "repo_id": "7", "comment": "/**\n * Gets an array of the field types that this partial supports.\n * <p>\n * The fields are returned largest to smallest, for example Hour, Minute, Second.\n *\n * @return the fields supported in an array that may be altered, largest to smallest\n */\n", "repo_name": "joda-time-main/", "id": 482, "method_signature": "DateTimeFieldType[] getFieldTypes()"}, "AbstractPartial.getFields": {"callee_method_names": [], "method_name": "AbstractPartial.getFields", "method_implementation": "{\n    DateTimeField[] result = new DateTimeField[size()];\n    for (int i = 0; i < result.length; i++) {\n        result[i] = getField(i);\n    }\n    return result;\n}", "repo_id": "7", "comment": "/**\n * Gets an array of the fields that this partial supports.\n * <p>\n * The fields are returned largest to smallest, for example Hour, Minute, Second.\n *\n * @return the fields supported in an array that may be altered, largest to smallest\n */\n", "repo_name": "joda-time-main/", "id": 483, "method_signature": "DateTimeField[] getFields()"}, "AbstractPartial.getValues": {"callee_method_names": [], "method_name": "AbstractPartial.getValues", "method_implementation": "{\n    int[] result = new int[size()];\n    for (int i = 0; i < result.length; i++) {\n        result[i] = getValue(i);\n    }\n    return result;\n}", "repo_id": "7", "comment": "/**\n * Gets an array of the value of each of the fields that this partial supports.\n * <p>\n * The fields are returned largest to smallest, for example Hour, Minute, Second.\n * Each value corresponds to the same array index as <code>getFields()</code>\n *\n * @return the current values of each field in an array that may be altered, largest to smallest\n */\n", "repo_name": "joda-time-main/", "id": 484, "method_signature": "int[] getValues()"}, "AbstractPartial.hashCode": {"callee_method_names": [], "method_name": "AbstractPartial.hashCode", "method_implementation": "{\n    int total = 157;\n    for (int i = 0, isize = size(); i < isize; i++) {\n        total = 23 * total + getValue(i);\n        total = 23 * total + getFieldType(i).hashCode();\n    }\n    total += getChronology().hashCode();\n    return total;\n}", "repo_id": "7", "comment": "/**\n * Gets a hash code for the ReadablePartial that is compatible with the\n * equals method.\n *\n * @return a suitable hash code\n */\n", "repo_name": "joda-time-main/", "id": 491, "method_signature": "int hashCode()"}, "AbstractPartial.indexOf": {"callee_method_names": [], "method_name": "AbstractPartial.indexOf", "method_implementation": "{\n    for (int i = 0, isize = size(); i < isize; i++) {\n        if (getFieldType(i).getDurationType() == type) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "7", "comment": "/**\n * Gets the index of the first fields to have the specified duration,\n * or -1 if the field is unsupported.\n *\n * @param type  the type to check, may be null which returns -1\n * @return the index of the field, -1 if unsupported\n */\n", "repo_name": "joda-time-main/", "id": 487, "method_signature": "int indexOf(DurationFieldType)"}, "AbstractPartial.indexOfSupported": {"callee_method_names": [], "method_name": "AbstractPartial.indexOfSupported", "method_implementation": "{\n    int index = indexOf(type);\n    if (index == -1) {\n        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n    }\n    return index;\n}", "repo_id": "7", "comment": "/**\n * Gets the index of the first fields to have the specified duration,\n * throwing an exception if the field is unsupported.\n *\n * @param type  the type to check, not null\n * @return the index of the field\n * @throws IllegalArgumentException if the field is null or not supported\n */\n", "repo_name": "joda-time-main/", "id": 488, "method_signature": "int indexOfSupported(DurationFieldType)"}, "AbstractPartial.isAfter": {"callee_method_names": [], "method_name": "AbstractPartial.isAfter", "method_implementation": "{\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    return compareTo(partial) > 0;\n}", "repo_id": "7", "comment": "/**\n * Is this partial later than the specified partial.\n * <p>\n * The fields are compared in order, from largest to smallest.\n * The first field that is non-equal is used to determine the result.\n * <p>\n * You may not pass null into this method. This is because you need\n * a time zone to accurately determine the current date.\n *\n * @param partial  a partial to check against, must not be null\n * @return true if this date is strictly after the date passed in\n * @throws IllegalArgumentException if the specified partial is null\n * @throws ClassCastException if the partial has field types that don't match\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 493, "method_signature": "boolean isAfter(ReadablePartial)"}, "AbstractPartial.isBefore": {"callee_method_names": [], "method_name": "AbstractPartial.isBefore", "method_implementation": "{\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    return compareTo(partial) < 0;\n}", "repo_id": "7", "comment": "/**\n * Is this partial earlier than the specified partial.\n * <p>\n * The fields are compared in order, from largest to smallest.\n * The first field that is non-equal is used to determine the result.\n * <p>\n * You may not pass null into this method. This is because you need\n * a time zone to accurately determine the current date.\n *\n * @param partial  a partial to check against, must not be null\n * @return true if this date is strictly before the date passed in\n * @throws IllegalArgumentException if the specified partial is null\n * @throws ClassCastException if the partial has field types that don't match\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 494, "method_signature": "boolean isBefore(ReadablePartial)"}, "AbstractPartial.isEqual": {"callee_method_names": [], "method_name": "AbstractPartial.isEqual", "method_implementation": "{\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    return compareTo(partial) == 0;\n}", "repo_id": "7", "comment": "/**\n * Is this partial the same as the specified partial.\n * <p>\n * The fields are compared in order, from largest to smallest.\n * If all fields are equal, the result is true.\n * <p>\n * You may not pass null into this method. This is because you need\n * a time zone to accurately determine the current date.\n *\n * @param partial  a partial to check against, must not be null\n * @return true if this date is the same as the date passed in\n * @throws IllegalArgumentException if the specified partial is null\n * @throws ClassCastException if the partial has field types that don't match\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 495, "method_signature": "boolean isEqual(ReadablePartial)"}, "AbstractPartial.toDateTime": {"callee_method_names": ["Chronology.set"], "method_name": "AbstractPartial.toDateTime", "method_implementation": "{\n    Chronology chrono = DateTimeUtils.getInstantChronology(baseInstant);\n    long instantMillis = DateTimeUtils.getInstantMillis(baseInstant);\n    long resolved = chrono.set(this, instantMillis);\n    return new DateTime(resolved, chrono);\n}", "repo_id": "7", "comment": "/**\n * Resolves this partial against another complete instant to create a new\n * full instant. The combination is performed using the chronology of the\n * specified instant.\n * <p>\n * For example, if this partial represents a time, then the result of this\n * method will be the datetime from the specified base instant plus the\n * time from this partial.\n *\n * @param baseInstant  the instant that provides the missing fields, null means now\n * @return the combined datetime\n */\n", "repo_name": "joda-time-main/", "id": 489, "method_signature": "DateTime toDateTime(ReadableInstant)"}, "AbstractPartial.toString": {"callee_method_ids": [855], "callee_method_names": ["DateTimeFormatter.print"], "method_name": "AbstractPartial.toString", "method_implementation": "{\n    if (formatter == null) {\n        return toString();\n    }\n    return formatter.print(this);\n}", "repo_id": "7", "comment": "/**\n * Uses the specified formatter to convert this partial to a String.\n *\n * @param formatter  the formatter to use, null means use <code>toString()</code>.\n * @return the formatted string\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 496, "method_signature": "String toString(DateTimeFormatter)"}, "AbstractPartialFieldProperty.compareTo": {"callee_method_names": ["ReadablePartial.get"], "method_name": "AbstractPartialFieldProperty.compareTo", "method_implementation": "{\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The instant must not be null\");\n    }\n    int thisValue = get();\n    int otherValue = partial.get(getFieldType());\n    if (thisValue < otherValue) {\n        return -1;\n    } else if (thisValue > otherValue) {\n        return 1;\n    } else {\n        return 0;\n    }\n}", "repo_id": "7", "comment": "/**\n * Compare this field to the same field on another partial instant.\n * <p>\n * The comparison is based on the value of the same field type, irrespective\n * of any difference in chronology. Thus, if this property represents the\n * hourOfDay field, then the hourOfDay field of the other partial will be queried\n * whether in the same chronology or not.\n *\n * @param partial  the partial to compare to\n * @return negative value if this is less, 0 if equal, or positive value if greater\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if the field of this property cannot be queried\n *  on the specified instant\n */\n", "repo_name": "joda-time-main/", "id": 63, "method_signature": "int compareTo(ReadablePartial)"}, "AbstractPartialFieldProperty.equals": {"callee_method_names": ["AbstractPartialFieldProperty.get", "AbstractPartialFieldProperty.getFieldType", "AbstractPartialFieldProperty.getReadablePartial"], "method_name": "AbstractPartialFieldProperty.equals", "method_implementation": "{\n    if (this == object) {\n        return true;\n    }\n    if (object instanceof AbstractPartialFieldProperty == false) {\n        return false;\n    }\n    AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object;\n    return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology());\n}", "repo_id": "7", "comment": "/**\n * Compares this property to another.\n *\n * @param object  the object to compare to\n * @return true if equal\n */\n", "repo_name": "joda-time-main/", "id": 64, "method_signature": "boolean equals(Object)"}, "AbstractPartialFieldProperty.hashCode": {"callee_method_names": [], "method_name": "AbstractPartialFieldProperty.hashCode", "method_implementation": "{\n    int hash = 19;\n    hash = 13 * hash + get();\n    hash = 13 * hash + getFieldType().hashCode();\n    hash = 13 * hash + getReadablePartial().getChronology().hashCode();\n    return hash;\n}", "repo_id": "7", "comment": "/**\n * Gets a suitable hashcode for the object.\n *\n * @return the hashcode\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 65, "method_signature": "int hashCode()"}, "AbstractPeriod.equals": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getValue", "ReadablePeriod.getFieldType"], "method_name": "AbstractPeriod.equals", "method_implementation": "{\n    if (this == period) {\n        return true;\n    }\n    if (period instanceof ReadablePeriod == false) {\n        return false;\n    }\n    ReadablePeriod other = (ReadablePeriod) period;\n    if (size() != other.size()) {\n        return false;\n    }\n    for (int i = 0, isize = size(); i < isize; i++) {\n        if (getValue(i) != other.getValue(i) || getFieldType(i) != other.getFieldType(i)) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "7", "comment": "/**\n * Compares this object with the specified object for equality based\n * on the value of each field. All ReadablePeriod instances are accepted.\n * <p>\n * Note that a period of 1 day is not equal to a period of 24 hours,\n * nor is 1 hour equal to 60 minutes. Only periods with the same amount\n * in each field are equal.\n * <p>\n * This is because periods represent an abstracted definition of a time\n * period (eg. a day may not actually be 24 hours, it might be 23 or 25\n * at daylight savings boundary).\n * <p>\n * To compare the actual duration of two periods, convert both to\n * {@link org.joda.time.Duration Duration}s, an operation that emphasises\n * that the result may differ according to the date you choose.\n *\n * @param period  a readable period to check against\n * @return true if all the field values are equal, false if\n *  not or the period is null or of an incorrect type\n */\n", "repo_name": "joda-time-main/", "id": 500, "method_signature": "boolean equals(Object)"}, "AbstractPeriod.get": {"callee_method_names": [], "method_name": "AbstractPeriod.get", "method_implementation": "{\n    int index = indexOf(type);\n    if (index == -1) {\n        return 0;\n    }\n    return getValue(index);\n}", "repo_id": "7", "comment": "/**\n * Gets the value of one of the fields.\n * <p>\n * If the field type specified is not supported by the period then zero\n * is returned.\n *\n * @param type  the field type to query, null returns zero\n * @return the value of that field, zero if field not supported\n */\n", "repo_name": "joda-time-main/", "id": 499, "method_signature": "int get(DurationFieldType)"}, "AbstractPeriod.getFieldTypes": {"callee_method_names": [], "method_name": "AbstractPeriod.getFieldTypes", "method_implementation": "{\n    DurationFieldType[] result = new DurationFieldType[size()];\n    for (int i = 0; i < result.length; i++) {\n        result[i] = getFieldType(i);\n    }\n    return result;\n}", "repo_id": "7", "comment": "/**\n * Gets an array of the field types that this period supports.\n * <p>\n * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.\n *\n * @return the fields supported in an array that may be altered, largest to smallest\n */\n", "repo_name": "joda-time-main/", "id": 497, "method_signature": "DurationFieldType[] getFieldTypes()"}, "AbstractPeriod.getValues": {"callee_method_names": [], "method_name": "AbstractPeriod.getValues", "method_implementation": "{\n    int[] result = new int[size()];\n    for (int i = 0; i < result.length; i++) {\n        result[i] = getValue(i);\n    }\n    return result;\n}", "repo_id": "7", "comment": "/**\n * Gets an array of the value of each of the fields that this period supports.\n * <p>\n * The fields are returned largest to smallest, for example Hours, Minutes, Seconds.\n * Each value corresponds to the same array index as <code>getFields()</code>\n *\n * @return the current values of each field in an array that may be altered, largest to smallest\n */\n", "repo_name": "joda-time-main/", "id": 498, "method_signature": "int[] getValues()"}, "AbstractPeriod.hashCode": {"callee_method_names": [], "method_name": "AbstractPeriod.hashCode", "method_implementation": "{\n    int total = 17;\n    for (int i = 0, isize = size(); i < isize; i++) {\n        total = 27 * total + getValue(i);\n        total = 27 * total + getFieldType(i).hashCode();\n    }\n    return total;\n}", "repo_id": "7", "comment": "/**\n * Gets a hash code for the period as defined by ReadablePeriod.\n *\n * @return a hash code\n */\n", "repo_name": "joda-time-main/", "id": 501, "method_signature": "int hashCode()"}, "AbstractPeriod.toString": {"callee_method_ids": [904], "callee_method_names": ["PeriodFormatter.print"], "method_name": "AbstractPeriod.toString", "method_implementation": "{\n    if (formatter == null) {\n        return toString();\n    }\n    return formatter.print(this);\n}", "repo_id": "7", "comment": "/**\n * Uses the specified formatter to convert this period to a String.\n *\n * @param formatter  the formatter to use, null means use <code>toString()</code>.\n * @return the formatted string\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 503, "method_signature": "String toString(PeriodFormatter)"}, "AbstractReadableInstantFieldProperty.compareTo": {"callee_method_names": ["ReadablePartial.get"], "method_name": "AbstractReadableInstantFieldProperty.compareTo", "method_implementation": "{\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    int thisValue = get();\n    int otherValue = partial.get(getFieldType());\n    if (thisValue < otherValue) {\n        return -1;\n    } else if (thisValue > otherValue) {\n        return 1;\n    } else {\n        return 0;\n    }\n}", "repo_id": "7", "comment": "/**\n * Compare this field to the same field on another partial instant.\n * <p>\n * The comparison is based on the value of the same field type, irrespective\n * of any difference in chronology. Thus, if this property represents the\n * hourOfDay field, then the hourOfDay field of the other partial will be queried\n * whether in the same chronology or not.\n *\n * @param partial  the partial to compare to\n * @return negative value if this is less, 0 if equal, or positive value if greater\n * @throws IllegalArgumentException if the partial is null\n * @throws IllegalArgumentException if the partial doesn't support this field\n */\n", "repo_name": "joda-time-main/", "id": 18, "method_signature": "int compareTo(ReadablePartial)"}, "AbstractReadableInstantFieldProperty.equals": {"callee_method_ids": [13], "callee_method_names": ["AbstractReadableInstantFieldProperty.get", "AbstractReadableInstantFieldProperty.getFieldType", "AbstractReadableInstantFieldProperty.getChronology"], "method_name": "AbstractReadableInstantFieldProperty.equals", "method_implementation": "{\n    if (this == object) {\n        return true;\n    }\n    if (object instanceof AbstractReadableInstantFieldProperty == false) {\n        return false;\n    }\n    AbstractReadableInstantFieldProperty other = (AbstractReadableInstantFieldProperty) object;\n    return get() == other.get() && getFieldType().equals(other.getFieldType()) && FieldUtils.equals(getChronology(), other.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Compares this property to another.\n *\n * @param object  the object to compare to\n * @return true if equal\n */\n", "repo_name": "joda-time-main/", "id": 19, "method_signature": "boolean equals(Object)"}, "AbstractReadableInstantFieldProperty.getChronology": {"callee_method_names": [], "method_name": "AbstractReadableInstantFieldProperty.getChronology", "method_implementation": "{\n    throw new UnsupportedOperationException(\"The method getChronology() was added in v1.4 and needs \" + \"to be implemented by subclasses of AbstractReadableInstantFieldProperty\");\n}", "repo_id": "7", "comment": "/**\n * Gets the chronology of the datetime that this property is linked to.\n * <p>\n * This implementation throws UnsupportedOperationException, and must be\n * implemented by subclasses to enable the equals() and hashCode() methods.\n *\n * @return the chronology\n * @since 1.4\n */\n", "repo_name": "joda-time-main/", "id": 13, "method_signature": "Chronology getChronology()"}, "AbstractReadableInstantFieldProperty.getDifference": {"callee_method_names": ["ReadableInstant.getMillis"], "method_name": "AbstractReadableInstantFieldProperty.getDifference", "method_implementation": "{\n    if (instant == null) {\n        return getField().getDifference(getMillis(), DateTimeUtils.currentTimeMillis());\n    }\n    return getField().getDifference(getMillis(), instant.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Returns the difference between this field property instant and the one\n * passed in, in the units of this field. The sign of the difference\n * matches that of compareTo. In other words, this field property's instant\n * is the minuend.\n *\n * @param instant  the subtrahend, null means now\n * @return the difference in the units of this field\n * @see DateTimeField#getDifference\n */\n", "repo_name": "joda-time-main/", "id": 14, "method_signature": "int getDifference(ReadableInstant)"}, "AbstractReadableInstantFieldProperty.getDifferenceAsLong": {"callee_method_names": ["ReadableInstant.getMillis"], "method_name": "AbstractReadableInstantFieldProperty.getDifferenceAsLong", "method_implementation": "{\n    if (instant == null) {\n        return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis());\n    }\n    return getField().getDifferenceAsLong(getMillis(), instant.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Returns the difference between this field property instant and the one\n * passed in, in the units of this field. The sign of the difference\n * matches that of compareTo. In other words, this field property's instant\n * is the minuend.\n *\n * @param instant  the subtrahend, null means now\n * @return the difference in the units of this field\n * @see DateTimeField#getDifference\n */\n", "repo_name": "joda-time-main/", "id": 15, "method_signature": "long getDifferenceAsLong(ReadableInstant)"}, "AbstractReadableInstantFieldProperty.toInterval": {"callee_method_names": ["DateTimeField.roundFloor", "DateTimeField.add"], "method_name": "AbstractReadableInstantFieldProperty.toInterval", "method_implementation": "{\n    DateTimeField field = getField();\n    long start = field.roundFloor(getMillis());\n    long end = field.add(start, 1);\n    Interval interval = new Interval(start, end, getChronology());\n    return interval;\n}", "repo_id": "7", "comment": "/**\n * Returns the interval that represents the range of the minimum\n * and maximum values of this field.\n * <p>\n * For example, <code>datetime.monthOfYear().toInterval()</code>\n * will return an interval over the whole month.\n *\n * @return the interval of this field\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 16, "method_signature": "Interval toInterval()"}, "AssembledChronology.copyFieldsFrom": {"callee_method_names": ["Chronology.millis", "Chronology.seconds", "Chronology.minutes", "Chronology.hours", "Chronology.halfdays", "Chronology.days", "Chronology.weeks", "Chronology.weekyears", "Chronology.months", "Chronology.years", "Chronology.centuries", "Chronology.eras", "Chronology.millisOfSecond", "Chronology.millisOfDay", "Chronology.secondOfMinute", "Chronology.secondOfDay", "Chronology.minuteOfHour", "Chronology.minuteOfDay", "Chronology.hourOfDay", "Chronology.clockhourOfDay", "Chronology.hourOfHalfday", "Chronology.clockhourOfHalfday", "Chronology.halfdayOfDay", "Chronology.dayOfWeek", "Chronology.dayOfMonth", "Chronology.dayOfYear", "Chronology.weekOfWeekyear", "Chronology.weekyear", "Chronology.weekyearOfCentury", "Chronology.monthOfYear", "Chronology.year", "Chronology.yearOfEra", "Chronology.yearOfCentury", "Chronology.centuryOfEra", "Chronology.era"], "method_name": "AssembledChronology.copyFieldsFrom", "method_implementation": "{\n    {\n        DurationField f;\n        if (isSupported(f = chrono.millis())) {\n            millis = f;\n        }\n        if (isSupported(f = chrono.seconds())) {\n            seconds = f;\n        }\n        if (isSupported(f = chrono.minutes())) {\n            minutes = f;\n        }\n        if (isSupported(f = chrono.hours())) {\n            hours = f;\n        }\n        if (isSupported(f = chrono.halfdays())) {\n            halfdays = f;\n        }\n        if (isSupported(f = chrono.days())) {\n            days = f;\n        }\n        if (isSupported(f = chrono.weeks())) {\n            weeks = f;\n        }\n        if (isSupported(f = chrono.weekyears())) {\n            weekyears = f;\n        }\n        if (isSupported(f = chrono.months())) {\n            months = f;\n        }\n        if (isSupported(f = chrono.years())) {\n            years = f;\n        }\n        if (isSupported(f = chrono.centuries())) {\n            centuries = f;\n        }\n        if (isSupported(f = chrono.eras())) {\n            eras = f;\n        }\n    }\n    {\n        DateTimeField f;\n        if (isSupported(f = chrono.millisOfSecond())) {\n            millisOfSecond = f;\n        }\n        if (isSupported(f = chrono.millisOfDay())) {\n            millisOfDay = f;\n        }\n        if (isSupported(f = chrono.secondOfMinute())) {\n            secondOfMinute = f;\n        }\n        if (isSupported(f = chrono.secondOfDay())) {\n            secondOfDay = f;\n        }\n        if (isSupported(f = chrono.minuteOfHour())) {\n            minuteOfHour = f;\n        }\n        if (isSupported(f = chrono.minuteOfDay())) {\n            minuteOfDay = f;\n        }\n        if (isSupported(f = chrono.hourOfDay())) {\n            hourOfDay = f;\n        }\n        if (isSupported(f = chrono.clockhourOfDay())) {\n            clockhourOfDay = f;\n        }\n        if (isSupported(f = chrono.hourOfHalfday())) {\n            hourOfHalfday = f;\n        }\n        if (isSupported(f = chrono.clockhourOfHalfday())) {\n            clockhourOfHalfday = f;\n        }\n        if (isSupported(f = chrono.halfdayOfDay())) {\n            halfdayOfDay = f;\n        }\n        if (isSupported(f = chrono.dayOfWeek())) {\n            dayOfWeek = f;\n        }\n        if (isSupported(f = chrono.dayOfMonth())) {\n            dayOfMonth = f;\n        }\n        if (isSupported(f = chrono.dayOfYear())) {\n            dayOfYear = f;\n        }\n        if (isSupported(f = chrono.weekOfWeekyear())) {\n            weekOfWeekyear = f;\n        }\n        if (isSupported(f = chrono.weekyear())) {\n            weekyear = f;\n        }\n        if (isSupported(f = chrono.weekyearOfCentury())) {\n            weekyearOfCentury = f;\n        }\n        if (isSupported(f = chrono.monthOfYear())) {\n            monthOfYear = f;\n        }\n        if (isSupported(f = chrono.year())) {\n            year = f;\n        }\n        if (isSupported(f = chrono.yearOfEra())) {\n            yearOfEra = f;\n        }\n        if (isSupported(f = chrono.yearOfCentury())) {\n            yearOfCentury = f;\n        }\n        if (isSupported(f = chrono.centuryOfEra())) {\n            centuryOfEra = f;\n        }\n        if (isSupported(f = chrono.era())) {\n            era = f;\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Copy the supported fields from a chronology into this container.\n *\n * @param chrono  the chronology to copy from, not null\n */\n", "repo_name": "joda-time-main/", "id": 278, "method_signature": "void copyFieldsFrom(Chronology)"}, "BaseChronology.add": {"callee_method_names": [], "method_name": "BaseChronology.add", "method_implementation": "{\n    if (duration == 0 || scalar == 0) {\n        return instant;\n    }\n    long add = FieldUtils.safeMultiply(duration, scalar);\n    return FieldUtils.safeAdd(instant, add);\n}", "repo_id": "7", "comment": "/**\n * Adds the duration to the instant, specifying the number of times to add.\n *\n * @param instant  the instant to add to\n * @param duration  the duration to add\n * @param scalar  the number of times to add\n * @return the updated instant\n */\n", "repo_name": "joda-time-main/", "id": 307, "method_signature": "long add(long, long, int)"}, "BaseChronology.get": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getFieldType", "DurationField.isPrecise", "DurationField.getDifference", "DurationField.add"], "method_name": "BaseChronology.get", "method_implementation": "{\n    int size = period.size();\n    int[] values = new int[size];\n    if (duration != 0) {\n        long current = 0;\n        for (int i = 0; i < size; i++) {\n            DurationField field = period.getFieldType(i).getField(this);\n            if (field.isPrecise()) {\n                int value = field.getDifference(duration, current);\n                current = field.add(current, value);\n                values[i] = value;\n            }\n        }\n    }\n    return values;\n}", "repo_id": "7", "comment": "/**\n * Gets the values of a period from an interval.\n *\n * @param period  the period instant to use\n * @param duration  the duration to query\n * @return the values of the period extracted from the duration\n */\n", "repo_name": "joda-time-main/", "id": 305, "method_signature": "int[] get(ReadablePeriod, long)"}, "BaseChronology.getDateTimeMillis": {"callee_method_names": [], "method_name": "BaseChronology.getDateTimeMillis", "method_implementation": "{\n    instant = hourOfDay().set(instant, hourOfDay);\n    instant = minuteOfHour().set(instant, minuteOfHour);\n    instant = secondOfMinute().set(instant, secondOfMinute);\n    return millisOfSecond().set(instant, millisOfSecond);\n}", "repo_id": "7", "comment": "/**\n * Returns a datetime millisecond instant, from from the given instant,\n * hour, minute, second, and millisecond values. The set of given values\n * must refer to a valid datetime, or else an IllegalArgumentException is\n * thrown.\n * <p>\n * The default implementation calls upon separate DateTimeFields to\n * determine the result. Subclasses are encouraged to provide a more\n * efficient implementation.\n *\n * @param instant instant to start from\n * @param hourOfDay hour to use\n * @param minuteOfHour minute to use\n * @param secondOfMinute second to use\n * @param millisOfSecond millisecond to use\n * @return millisecond instant from 1970-01-01T00:00:00Z\n */\n", "repo_name": "joda-time-main/", "id": 300, "method_signature": "long getDateTimeMillis(long, int, int, int, int)"}, "BaseChronology.set": {"callee_method_names": ["ReadablePartial.size", "ReadablePartial.getFieldType", "ReadablePartial.getValue"], "method_name": "BaseChronology.set", "method_implementation": "{\n    for (int i = 0, isize = partial.size(); i < isize; i++) {\n        instant = partial.getFieldType(i).getField(this).set(instant, partial.getValue(i));\n    }\n    return instant;\n}", "repo_id": "7", "comment": "/**\n * Sets the partial into the instant.\n *\n * @param partial  the partial instant to use\n * @param instant  the instant to update\n * @return the updated instant\n */\n", "repo_name": "joda-time-main/", "id": 303, "method_signature": "long set(ReadablePartial, long)"}, "BaseChronology.validate": {"callee_method_names": ["ReadablePartial.size", "ReadablePartial.getField", "DateTimeField.getMinimumValue", "DateTimeField.getType", "DateTimeField.getMinimumValue", "DateTimeField.getMaximumValue", "DateTimeField.getType", "DateTimeField.getMaximumValue", "ReadablePartial.getField", "DateTimeField.getMinimumValue", "DateTimeField.getType", "DateTimeField.getMinimumValue", "DateTimeField.getMaximumValue", "DateTimeField.getType", "DateTimeField.getMaximumValue"], "method_name": "BaseChronology.validate", "method_implementation": "{\n    // check values in standard range, catching really stupid cases like -1\n    // this means that the second check will not hit trouble\n    int size = partial.size();\n    for (int i = 0; i < size; i++) {\n        int value = values[i];\n        DateTimeField field = partial.getField(i);\n        if (value < field.getMinimumValue()) {\n            throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue()), null);\n        }\n        if (value > field.getMaximumValue()) {\n            throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue()));\n        }\n    }\n    // check values in specific range, catching really odd cases like 30th Feb\n    for (int i = 0; i < size; i++) {\n        int value = values[i];\n        DateTimeField field = partial.getField(i);\n        if (value < field.getMinimumValue(partial, values)) {\n            throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(field.getMinimumValue(partial, values)), null);\n        }\n        if (value > field.getMaximumValue(partial, values)) {\n            throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), null, Integer.valueOf(field.getMaximumValue(partial, values)));\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Validates whether the fields stored in a partial instant are valid.\n * <p>\n * This implementation uses {@link DateTimeField#getMinimumValue(ReadablePartial, int[])}\n * and {@link DateTimeField#getMaximumValue(ReadablePartial, int[])}.\n *\n * @param partial  the partial instant to validate\n * @param values  the values to validate, not null unless the partial is empty\n * @throws IllegalArgumentException if the instant is invalid\n */\n", "repo_name": "joda-time-main/", "id": 301, "method_signature": "void validate(ReadablePartial, int[])"}, "BaseDateTimeField.add": {"callee_method_names": ["ReadablePartial.getField", "DateTimeField.getDurationField", "DateTimeField.add", "ReadablePartial.getField", "DateTimeField.getDurationField", "DateTimeField.add"], "method_name": "BaseDateTimeField.add", "method_implementation": "{\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // there are more efficient algorithms than this (especially for time only fields)\n    // trouble is when dealing with days and months, so we use this technique of\n    // adding/removing one from the larger field at a time\n    DateTimeField nextField = null;\n    while (valueToAdd > 0) {\n        int max = getMaximumValue(instant, values);\n        long proposed = values[fieldIndex] + valueToAdd;\n        if (proposed <= max) {\n            values[fieldIndex] = (int) proposed;\n            break;\n        }\n        if (nextField == null) {\n            if (fieldIndex == 0) {\n                throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n            }\n            nextField = instant.getField(fieldIndex - 1);\n            // test only works if this field is UTC (ie. local)\n            if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                throw new IllegalArgumentException(\"Fields invalid for add\");\n            }\n        }\n        // reduce the amount to add\n        valueToAdd -= (max + 1) - values[fieldIndex];\n        // add 1 to next bigger field\n        values = nextField.add(instant, fieldIndex - 1, values, 1);\n        // reset this field to zero\n        values[fieldIndex] = getMinimumValue(instant, values);\n    }\n    while (valueToAdd < 0) {\n        int min = getMinimumValue(instant, values);\n        long proposed = values[fieldIndex] + valueToAdd;\n        if (proposed >= min) {\n            values[fieldIndex] = (int) proposed;\n            break;\n        }\n        if (nextField == null) {\n            if (fieldIndex == 0) {\n                throw new IllegalArgumentException(\"Maximum value exceeded for add\");\n            }\n            nextField = instant.getField(fieldIndex - 1);\n            if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                throw new IllegalArgumentException(\"Fields invalid for add\");\n            }\n        }\n        // reduce the amount to add\n        valueToAdd -= (min - 1) - values[fieldIndex];\n        // subtract 1 from next bigger field\n        values = nextField.add(instant, fieldIndex - 1, values, -1);\n        // reset this field to max value\n        values[fieldIndex] = getMaximumValue(instant, values);\n    }\n    // adjusts smaller fields\n    return set(instant, fieldIndex, values, values[fieldIndex]);\n}", "repo_id": "7", "comment": "/**\n * Adds a value (which may be negative) to the partial instant,\n * throwing an exception if the maximum size of the instant is reached.\n * <p>\n * The value will be added to this field, overflowing into larger fields\n * if necessary. Smaller fields should be unaffected, except where the\n * result would be an invalid value for a smaller field. In this case the\n * smaller field is adjusted to be in range.\n * <p>\n * Partial instants only contain some fields. This may result in a maximum\n * possible value, such as TimeOfDay being limited to 23:59:59:999. If this\n * limit is breached by the add an exception is thrown.\n * <p>\n * For example, in the ISO chronology:<br>\n * 2000-08-20 add six months is 2000-02-20<br>\n * 2000-08-20 add twenty months is 2000-04-20<br>\n * 2000-08-20 add minus nine months is 2000-11-20<br>\n * 2001-01-31 add one month  is 2001-02-28<br>\n * 2001-01-31 add two months is 2001-03-31<br>\n *\n * @param instant  the partial instant\n * @param fieldIndex  the index of this field in the partial\n * @param values  the values of the partial instant which should be updated\n * @param valueToAdd  the value to add, in the units of the field\n * @return the passed in values\n * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n */\n", "repo_name": "joda-time-main/", "id": 0, "method_signature": "int[] add(ReadablePartial, int, int[], int)"}, "BaseDateTimeField.addWrapField": {"callee_method_names": [], "method_name": "BaseDateTimeField.addWrapField", "method_implementation": "{\n    int current = values[fieldIndex];\n    int wrapped = FieldUtils.getWrappedValue(current, valueToAdd, getMinimumValue(instant), getMaximumValue(instant));\n    // adjusts smaller fields\n    return set(instant, fieldIndex, values, wrapped);\n}", "repo_id": "7", "comment": "/**\n * Adds a value (which may be negative) to the partial instant,\n * wrapping within this field.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it wraps. Larger fields are always\n * unaffected. Smaller fields should be unaffected, except where the\n * result would be an invalid value for a smaller field. In this case the\n * smaller field is adjusted to be in range.\n * <p>\n * For example, in the ISO chronology:<br>\n * 2000-08-20 addWrapField six months is 2000-02-20<br>\n * 2000-08-20 addWrapField twenty months is 2000-04-20<br>\n * 2000-08-20 addWrapField minus nine months is 2000-11-20<br>\n * 2001-01-31 addWrapField one month  is 2001-02-28<br>\n * 2001-01-31 addWrapField two months is 2001-03-31<br>\n * <p>\n * The default implementation internally calls set. Subclasses are\n * encouraged to provide a more efficient implementation.\n *\n * @param instant  the partial instant\n * @param fieldIndex  the index of this field in the instant\n * @param values  the values of the partial instant which should be updated\n * @param valueToAdd  the value to add, in the units of the field\n * @return the passed in values\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 3, "method_signature": "int[] addWrapField(ReadablePartial, int, int[], int)"}, "BaseDateTimeField.addWrapPartial": {"callee_method_names": ["ReadablePartial.getField", "DateTimeField.getDurationField", "DateTimeField.addWrapPartial", "ReadablePartial.getField", "DateTimeField.getDurationField", "DateTimeField.addWrapPartial"], "method_name": "BaseDateTimeField.addWrapPartial", "method_implementation": "{\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // there are more efficient algorithms than this (especially for time only fields)\n    // trouble is when dealing with days and months, so we use this technique of\n    // adding/removing one from the larger field at a time\n    DateTimeField nextField = null;\n    while (valueToAdd > 0) {\n        int max = getMaximumValue(instant, values);\n        long proposed = values[fieldIndex] + valueToAdd;\n        if (proposed <= max) {\n            values[fieldIndex] = (int) proposed;\n            break;\n        }\n        if (nextField == null) {\n            if (fieldIndex == 0) {\n                valueToAdd -= (max + 1) - values[fieldIndex];\n                values[fieldIndex] = getMinimumValue(instant, values);\n                continue;\n            }\n            nextField = instant.getField(fieldIndex - 1);\n            // test only works if this field is UTC (ie. local)\n            if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                throw new IllegalArgumentException(\"Fields invalid for add\");\n            }\n        }\n        // reduce the amount to add\n        valueToAdd -= (max + 1) - values[fieldIndex];\n        // add 1 to next bigger field\n        values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1);\n        // reset this field to zero\n        values[fieldIndex] = getMinimumValue(instant, values);\n    }\n    while (valueToAdd < 0) {\n        int min = getMinimumValue(instant, values);\n        long proposed = values[fieldIndex] + valueToAdd;\n        if (proposed >= min) {\n            values[fieldIndex] = (int) proposed;\n            break;\n        }\n        if (nextField == null) {\n            if (fieldIndex == 0) {\n                valueToAdd -= (min - 1) - values[fieldIndex];\n                values[fieldIndex] = getMaximumValue(instant, values);\n                continue;\n            }\n            nextField = instant.getField(fieldIndex - 1);\n            if (getRangeDurationField().getType() != nextField.getDurationField().getType()) {\n                throw new IllegalArgumentException(\"Fields invalid for add\");\n            }\n        }\n        // reduce the amount to add\n        valueToAdd -= (min - 1) - values[fieldIndex];\n        // subtract 1 from next bigger field\n        values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1);\n        // reset this field to max value\n        values[fieldIndex] = getMaximumValue(instant, values);\n    }\n    // adjusts smaller fields\n    return set(instant, fieldIndex, values, values[fieldIndex]);\n}", "repo_id": "7", "comment": "/**\n * Adds a value (which may be negative) to the partial instant,\n * wrapping the whole partial if the maximum size of the partial is reached.\n * <p>\n * The value will be added to this field, overflowing into larger fields\n * if necessary. Smaller fields should be unaffected, except where the\n * result would be an invalid value for a smaller field. In this case the\n * smaller field is adjusted to be in range.\n * <p>\n * Partial instants only contain some fields. This may result in a maximum\n * possible value, such as TimeOfDay normally being limited to 23:59:59:999.\n * If this limit is reached by the addition, this method will wrap back to\n * 00:00:00.000. In fact, you would generally only use this method for\n * classes that have a limitation such as this.\n * <p>\n * For example, in the ISO chronology:<br>\n * 10:20:30 add 20 minutes is 10:40:30<br>\n * 10:20:30 add 45 minutes is 11:05:30<br>\n * 10:20:30 add 16 hours is 02:20:30<br>\n *\n * @param instant  the partial instant\n * @param fieldIndex  the index of this field in the partial\n * @param values  the values of the partial instant which should be updated\n * @param valueToAdd  the value to add, in the units of the field\n * @return the passed in values\n * @throws IllegalArgumentException if the value is invalid or the maximum instant is reached\n */\n", "repo_name": "joda-time-main/", "id": 1, "method_signature": "int[] addWrapPartial(ReadablePartial, int, int[], int)"}, "BaseDateTimeField.convertText": {"callee_method_names": [], "method_name": "BaseDateTimeField.convertText", "method_implementation": "{\n    try {\n        return Integer.parseInt(text);\n    } catch (NumberFormatException ex) {\n        throw new IllegalFieldValueException(getType(), text);\n    }\n}", "repo_id": "7", "comment": "/**\n * Convert the specified text and locale into a value.\n *\n * @param text  the text to convert\n * @param locale  the locale to convert using\n * @return the value extracted from the text\n * @throws IllegalArgumentException if the text is invalid\n */\n", "repo_name": "joda-time-main/", "id": 7, "method_signature": "int convertText(String, Locale)"}, "BaseDateTimeField.getMaximumTextLength": {"callee_method_names": [], "method_name": "BaseDateTimeField.getMaximumTextLength", "method_implementation": "{\n    int max = getMaximumValue();\n    if (max >= 0) {\n        if (max < 10) {\n            return 1;\n        } else if (max < 100) {\n            return 2;\n        } else if (max < 1000) {\n            return 3;\n        }\n    }\n    return Integer.toString(max).length();\n}", "repo_id": "7", "comment": "/**\n * Get the maximum text value for this field. The default implementation\n * returns the equivalent of Integer.toString(getMaximumValue()).length().\n *\n * @param locale  the locale to use for selecting a text symbol\n * @return the maximum text length\n */\n", "repo_name": "joda-time-main/", "id": 8, "method_signature": "int getMaximumTextLength(Locale)"}, "BaseDateTimeField.roundCeiling": {"callee_method_names": [], "method_name": "BaseDateTimeField.roundCeiling", "method_implementation": "{\n    long newInstant = roundFloor(instant);\n    if (newInstant != instant) {\n        instant = add(newInstant, 1);\n    }\n    return instant;\n}", "repo_id": "7", "comment": "/**\n * Round to the highest whole unit of this field. The value of this field\n * and all fields of a higher magnitude may be incremented in order to\n * achieve this result. The fractional millis that cannot be expressed in\n * whole increments of this field are set to minimum.\n * <p>\n * For example, a datetime of 2002-11-02T23:34:56.789, rounded to the\n * highest whole hour is 2002-11-03T00:00:00.000.\n * <p>\n * The default implementation calls roundFloor, and if the instant is\n * modified as a result, adds one field unit. Subclasses are encouraged to\n * provide a more efficient implementation.\n *\n * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n * @return rounded milliseconds\n */\n", "repo_name": "joda-time-main/", "id": 9, "method_signature": "long roundCeiling(long)"}, "BaseDateTimeField.roundHalfCeiling": {"callee_method_names": [], "method_name": "BaseDateTimeField.roundHalfCeiling", "method_implementation": "{\n    long floor = roundFloor(instant);\n    long ceiling = roundCeiling(instant);\n    long diffFromFloor = instant - floor;\n    long diffToCeiling = ceiling - instant;\n    if (diffToCeiling <= diffFromFloor) {\n        // Closer to the ceiling, or halfway - round ceiling\n        return ceiling;\n    } else {\n        return floor;\n    }\n}", "repo_id": "7", "comment": "/**\n * Round to the nearest whole unit of this field. If the given millisecond\n * value is closer to the floor, this function behaves like roundFloor. If\n * the millisecond value is closer to the ceiling or is exactly halfway,\n * this function behaves like roundCeiling.\n *\n * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n * @return rounded milliseconds\n */\n", "repo_name": "joda-time-main/", "id": 11, "method_signature": "long roundHalfCeiling(long)"}, "BaseDateTimeField.roundHalfEven": {"callee_method_names": [], "method_name": "BaseDateTimeField.roundHalfEven", "method_implementation": "{\n    long floor = roundFloor(instant);\n    long ceiling = roundCeiling(instant);\n    long diffFromFloor = instant - floor;\n    long diffToCeiling = ceiling - instant;\n    if (diffFromFloor < diffToCeiling) {\n        // Closer to the floor - round floor\n        return floor;\n    } else if (diffToCeiling < diffFromFloor) {\n        // Closer to the ceiling - round ceiling\n        return ceiling;\n    } else {\n        // Round to the instant that makes this field even. If both values\n        // make this field even (unlikely), favor the ceiling.\n        if ((get(ceiling) & 1) == 0) {\n            return ceiling;\n        }\n        return floor;\n    }\n}", "repo_id": "7", "comment": "/**\n * Round to the nearest whole unit of this field. If the given millisecond\n * value is closer to the floor, this function behaves like roundFloor. If\n * the millisecond value is closer to the ceiling, this function behaves\n * like roundCeiling.\n * <p>\n * If the millisecond value is exactly halfway between the floor and\n * ceiling, the ceiling is chosen over the floor only if it makes this\n * field's value even.\n *\n * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n * @return rounded milliseconds\n */\n", "repo_name": "joda-time-main/", "id": 12, "method_signature": "long roundHalfEven(long)"}, "BaseDateTimeField.roundHalfFloor": {"callee_method_names": [], "method_name": "BaseDateTimeField.roundHalfFloor", "method_implementation": "{\n    long floor = roundFloor(instant);\n    long ceiling = roundCeiling(instant);\n    long diffFromFloor = instant - floor;\n    long diffToCeiling = ceiling - instant;\n    if (diffFromFloor <= diffToCeiling) {\n        // Closer to the floor, or halfway - round floor\n        return floor;\n    } else {\n        return ceiling;\n    }\n}", "repo_id": "7", "comment": "/**\n * Round to the nearest whole unit of this field. If the given millisecond\n * value is closer to the floor or is exactly halfway, this function\n * behaves like roundFloor. If the millisecond value is closer to the\n * ceiling, this function behaves like roundCeiling.\n *\n * @param instant  the milliseconds from 1970-01-01T00:00:00Z to round\n * @return rounded milliseconds\n */\n", "repo_name": "joda-time-main/", "id": 10, "method_signature": "long roundHalfFloor(long)"}, "BaseDateTimeField.set": {"callee_method_names": [], "method_name": "BaseDateTimeField.set", "method_implementation": "{\n    int value = convertText(text, locale);\n    return set(instant, fieldIndex, values, value);\n}", "repo_id": "7", "comment": "/**\n * Sets a value in the milliseconds supplied from a human-readable, text value.\n * If the specified locale is null, the default locale is used.\n * <p>\n * This implementation uses <code>convertText(String, Locale)</code> and\n * {@link #set(ReadablePartial, int, int[], int)}.\n *\n * @param instant  the partial instant\n * @param fieldIndex  the index of this field in the instant\n * @param values  the values of the partial instant which should be updated\n * @param text  the text value to set\n * @param locale the locale to use for selecting a text symbol, null for default\n * @return the passed in values\n * @throws IllegalArgumentException if the text value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 6, "method_signature": "int[] set(ReadablePartial, int, int[], String, Locale)"}, "BaseDurationField.compareTo": {"callee_method_names": ["DurationField.getUnitMillis"], "method_name": "BaseDurationField.compareTo", "method_implementation": "{\n    long otherMillis = otherField.getUnitMillis();\n    long thisMillis = getUnitMillis();\n    // cannot do (thisMillis - otherMillis) as can overflow\n    if (thisMillis == otherMillis) {\n        return 0;\n    }\n    if (thisMillis < otherMillis) {\n        return -1;\n    } else {\n        return 1;\n    }\n}", "repo_id": "7", "comment": "//------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 54, "method_signature": "int compareTo(DurationField)"}, "BaseInterval.setInterval": {"callee_method_names": [], "method_name": "BaseInterval.setInterval", "method_implementation": "{\n    checkInterval(startInstant, endInstant);\n    iStartMillis = startInstant;\n    iEndMillis = endInstant;\n    iChronology = DateTimeUtils.getChronology(chrono);\n}", "repo_id": "7", "comment": "/**\n * Sets this interval from two millisecond instants and a chronology.\n *\n * @param startInstant  the start of the time interval\n * @param endInstant  the start of the time interval\n * @param chrono  the chronology, not null\n * @throws IllegalArgumentException if the end is before the start\n */\n", "repo_name": "joda-time-main/", "id": 526, "method_signature": "void setInterval(long, long, Chronology)"}, "BasePartial.setValue": {"callee_method_names": ["DateTimeField.set"], "method_name": "BasePartial.setValue", "method_implementation": "{\n    DateTimeField field = getField(index);\n    int[] values = field.set(this, index, iValues, value);\n    System.arraycopy(values, 0, iValues, 0, iValues.length);\n}", "repo_id": "7", "comment": "/**\n * Sets the value of the field at the specified index.\n * <p>\n * In version 2.0 and later, this method copies the array into the original.\n * This is because the instance variable has been changed to be final to satisfy the Java Memory Model.\n * This only impacts subclasses that are mutable.\n *\n * @param index  the index\n * @param value  the value to set\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "joda-time-main/", "id": 517, "method_signature": "void setValue(int, int)"}, "BasePartial.toString": {"callee_method_names": [], "method_name": "BasePartial.toString", "method_implementation": "{\n    if (pattern == null) {\n        return toString();\n    }\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n}", "repo_id": "7", "comment": "/**\n * Output the date using the specified format pattern.\n *\n * @param pattern  the pattern specification, null means use <code>toString</code>\n * @param locale  Locale to use, null means default\n * @return the formatted output, not null\n * @throws IllegalArgumentException if the pattern is invalid\n * @see org.joda.time.format.DateTimeFormat\n */\n", "repo_name": "joda-time-main/", "id": 519, "method_signature": "String toString(String, Locale)"}, "BasePeriod.addFieldInto": {"callee_method_names": [], "method_name": "BasePeriod.addFieldInto", "method_implementation": "{\n    int index = indexOf(field);\n    if (index == -1) {\n        if (value != 0 || field == null) {\n            throw new IllegalArgumentException(\"Period does not support field '\" + field + \"'\");\n        }\n    } else {\n        values[index] = FieldUtils.safeAdd(values[index], value);\n    }\n}", "repo_id": "7", "comment": "/**\n * Adds the value of a field in this period.\n *\n * @param values  the array of values to update\n * @param field  the field to set\n * @param value  the value to set\n * @throws IllegalArgumentException if field is is null or not supported.\n */\n", "repo_name": "joda-time-main/", "id": 512, "method_signature": "void addFieldInto(int[], DurationFieldType, int)"}, "BasePeriod.addPeriod": {"callee_method_names": [], "method_name": "BasePeriod.addPeriod", "method_implementation": "{\n    if (period != null) {\n        setValues(addPeriodInto(getValues(), period));\n    }\n}", "repo_id": "7", "comment": "/**\n * Adds the fields from another period.\n *\n * @param period  the period to add from, not null\n * @throws IllegalArgumentException if an unsupported field's value is non-zero\n */\n", "repo_name": "joda-time-main/", "id": 515, "method_signature": "void addPeriod(ReadablePeriod)"}, "BasePeriod.addPeriodInto": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getFieldType", "ReadablePeriod.getValue", "DurationFieldType.getName"], "method_name": "BasePeriod.addPeriodInto", "method_implementation": "{\n    for (int i = 0, isize = period.size(); i < isize; i++) {\n        DurationFieldType type = period.getFieldType(i);\n        int value = period.getValue(i);\n        if (value != 0) {\n            int index = indexOf(type);\n            if (index == -1) {\n                throw new IllegalArgumentException(\"Period does not support field '\" + type.getName() + \"'\");\n            } else {\n                values[index] = FieldUtils.safeAdd(getValue(index), value);\n            }\n        }\n    }\n    return values;\n}", "repo_id": "7", "comment": "/**\n * Adds the fields from another period.\n *\n * @param values  the array of values to update\n * @param period  the period to add from, not null\n * @return the updated values\n * @throws IllegalArgumentException if an unsupported field's value is non-zero\n */\n", "repo_name": "joda-time-main/", "id": 516, "method_signature": "int[] addPeriodInto(int[], ReadablePeriod)"}, "BasePeriod.checkAndUpdate": {"callee_method_names": ["DurationFieldType.getName"], "method_name": "BasePeriod.checkAndUpdate", "method_implementation": "{\n    int index = indexOf(type);\n    if (index == -1) {\n        if (newValue != 0) {\n            throw new IllegalArgumentException(\"Period does not support field '\" + type.getName() + \"'\");\n        }\n    } else {\n        values[index] = newValue;\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether a field type is supported, and if so adds the new value\n * to the relevant index in the specified array.\n *\n * @param type  the field type\n * @param values  the array to update\n * @param newValue  the new value to store if successful\n */\n", "repo_name": "joda-time-main/", "id": 506, "method_signature": "void checkAndUpdate(DurationFieldType, int[], int)"}, "BasePeriod.mergePeriod": {"callee_method_names": [], "method_name": "BasePeriod.mergePeriod", "method_implementation": "{\n    if (period != null) {\n        setValues(mergePeriodInto(getValues(), period));\n    }\n}", "repo_id": "7", "comment": "/**\n * Merges the fields from another period.\n *\n * @param period  the period to add from, not null\n * @throws IllegalArgumentException if an unsupported field's value is non-zero\n */\n", "repo_name": "joda-time-main/", "id": 513, "method_signature": "void mergePeriod(ReadablePeriod)"}, "BasePeriod.mergePeriodInto": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getFieldType", "ReadablePeriod.getValue"], "method_name": "BasePeriod.mergePeriodInto", "method_implementation": "{\n    for (int i = 0, isize = period.size(); i < isize; i++) {\n        DurationFieldType type = period.getFieldType(i);\n        int value = period.getValue(i);\n        checkAndUpdate(type, values, value);\n    }\n    return values;\n}", "repo_id": "7", "comment": "/**\n * Merges the fields from another period.\n *\n * @param values  the array of values to update\n * @param period  the period to add from, not null\n * @return the updated values\n * @throws IllegalArgumentException if an unsupported field's value is non-zero\n */\n", "repo_name": "joda-time-main/", "id": 514, "method_signature": "int[] mergePeriodInto(int[], ReadablePeriod)"}, "BasePeriod.setFieldInto": {"callee_method_names": [], "method_name": "BasePeriod.setFieldInto", "method_implementation": "{\n    int index = indexOf(field);\n    if (index == -1) {\n        if (value != 0 || field == null) {\n            throw new IllegalArgumentException(\"Period does not support field '\" + field + \"'\");\n        }\n    } else {\n        values[index] = value;\n    }\n}", "repo_id": "7", "comment": "/**\n * Sets the value of a field in this period.\n *\n * @param values  the array of values to update\n * @param field  the field to set\n * @param value  the value to set\n * @throws IllegalArgumentException if field is null or not supported.\n */\n", "repo_name": "joda-time-main/", "id": 511, "method_signature": "void setFieldInto(int[], DurationFieldType, int)"}, "BasePeriod.setPeriod": {"callee_method_names": [], "method_name": "BasePeriod.setPeriod", "method_implementation": "{\n    int[] newValues = setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis);\n    setValues(newValues);\n}", "repo_id": "7", "comment": "/**\n * Sets the eight standard the fields in one go.\n *\n * @param years  amount of years in this period, which must be zero if unsupported\n * @param months  amount of months in this period, which must be zero if unsupported\n * @param weeks  amount of weeks in this period, which must be zero if unsupported\n * @param days  amount of days in this period, which must be zero if unsupported\n * @param hours  amount of hours in this period, which must be zero if unsupported\n * @param minutes  amount of minutes in this period, which must be zero if unsupported\n * @param seconds  amount of seconds in this period, which must be zero if unsupported\n * @param millis  amount of milliseconds in this period, which must be zero if unsupported\n * @throws IllegalArgumentException if an unsupported field's value is non-zero\n */\n", "repo_name": "joda-time-main/", "id": 509, "method_signature": "void setPeriod(int, int, int, int, int, int, int, int)"}, "BasePeriod.setPeriodInternal": {"callee_method_names": [], "method_name": "BasePeriod.setPeriodInternal", "method_implementation": "{\n    int[] newValues = new int[size()];\n    checkAndUpdate(DurationFieldType.years(), newValues, years);\n    checkAndUpdate(DurationFieldType.months(), newValues, months);\n    checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n    checkAndUpdate(DurationFieldType.days(), newValues, days);\n    checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n    checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n    checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n    checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n    return newValues;\n}", "repo_id": "7", "comment": "/**\n * Private method called from constructor.\n */\n", "repo_name": "joda-time-main/", "id": 510, "method_signature": "int[] setPeriodInternal(int, int, int, int, int, int, int, int)"}, "BasePeriod.toDurationFrom": {"callee_method_names": ["Chronology.add"], "method_name": "BasePeriod.toDurationFrom", "method_implementation": "{\n    long startMillis = DateTimeUtils.getInstantMillis(startInstant);\n    Chronology chrono = DateTimeUtils.getInstantChronology(startInstant);\n    long endMillis = chrono.add(this, startMillis, 1);\n    return new Duration(startMillis, endMillis);\n}", "repo_id": "7", "comment": "/**\n * Gets the total millisecond duration of this period relative to a start instant.\n * <p>\n * This method adds the period to the specified instant in order to\n * calculate the duration.\n * <p>\n * An instant must be supplied as the duration of a period varies.\n * For example, a period of 1 month could vary between the equivalent of\n * 28 and 31 days in milliseconds due to different length months.\n * Similarly, a day can vary at Daylight Savings cutover, typically between\n * 23 and 25 hours.\n *\n * @param startInstant  the instant to add the period to, thus obtaining the duration\n * @return the total length of the period as a duration relative to the start instant\n * @throws ArithmeticException if the millis exceeds the capacity of the duration\n */\n", "repo_name": "joda-time-main/", "id": 504, "method_signature": "Duration toDurationFrom(ReadableInstant)"}, "BasePeriod.toDurationTo": {"callee_method_names": ["Chronology.add"], "method_name": "BasePeriod.toDurationTo", "method_implementation": "{\n    long endMillis = DateTimeUtils.getInstantMillis(endInstant);\n    Chronology chrono = DateTimeUtils.getInstantChronology(endInstant);\n    long startMillis = chrono.add(this, endMillis, -1);\n    return new Duration(startMillis, endMillis);\n}", "repo_id": "7", "comment": "/**\n * Gets the total millisecond duration of this period relative to an\n * end instant.\n * <p>\n * This method subtracts the period from the specified instant in order\n * to calculate the duration.\n * <p>\n * An instant must be supplied as the duration of a period varies.\n * For example, a period of 1 month could vary between the equivalent of\n * 28 and 31 days in milliseconds due to different length months.\n * Similarly, a day can vary at Daylight Savings cutover, typically between\n * 23 and 25 hours.\n *\n * @param endInstant  the instant to subtract the period from, thus obtaining the duration\n * @return the total length of the period as a duration relative to the end instant\n * @throws ArithmeticException if the millis exceeds the capacity of the duration\n */\n", "repo_name": "joda-time-main/", "id": 505, "method_signature": "Duration toDurationTo(ReadableInstant)"}, "BaseSingleFieldPeriod.between": {"callee_method_names": ["ReadablePartial.size", "ReadablePartial.size", "ReadablePartial.size", "ReadablePartial.getFieldType", "ReadablePartial.getFieldType", "ReadablePartial.getChronology", "Chronology.get", "Chronology.set", "Chronology.set"], "method_name": "BaseSingleFieldPeriod.between", "method_implementation": "{\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    if (DateTimeUtils.isContiguous(start) == false) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n    int[] values = chrono.get(zeroInstance, chrono.set(start, START_1972), chrono.set(end, START_1972));\n    return values[0];\n}", "repo_id": "7", "comment": "/**\n * Calculates the number of whole units between the two specified partial datetimes.\n * <p>\n * The two partials must contain the same fields, for example you can specify\n * two <code>LocalDate</code> objects.\n *\n * @param start  the start partial date, validated to not be null\n * @param end  the end partial date, validated to not be null\n * @param zeroInstance  the zero instance constant, must not be null\n * @return the period\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 473, "method_signature": "int between(ReadablePartial, ReadablePartial, ReadablePeriod)"}, "BaseSingleFieldPeriod.compareTo": {"callee_method_ids": [476], "callee_method_names": ["BaseSingleFieldPeriod.getClass", "BaseSingleFieldPeriod.getClass", "BaseSingleFieldPeriod.getValue"], "method_name": "BaseSingleFieldPeriod.compareTo", "method_implementation": "{\n    if (other.getClass() != getClass()) {\n        throw new ClassCastException(getClass() + \" cannot be compared to \" + other.getClass());\n    }\n    int otherValue = other.getValue();\n    int thisValue = getValue();\n    if (thisValue > otherValue) {\n        return 1;\n    }\n    if (thisValue < otherValue) {\n        return -1;\n    }\n    return 0;\n}", "repo_id": "7", "comment": "/**\n * Compares this period to another object of the same class.\n *\n * @param other  the other period, must not be null\n * @return zero if equal, positive if greater, negative if less\n * @throws NullPointerException if the other period is null\n * @throws ClassCastException if the other period is of a different type\n */\n", "repo_name": "joda-time-main/", "id": 481, "method_signature": "int compareTo(BaseSingleFieldPeriod)"}, "BaseSingleFieldPeriod.equals": {"callee_method_names": ["ReadablePeriod.getPeriodType", "ReadablePeriod.getValue"], "method_name": "BaseSingleFieldPeriod.equals", "method_implementation": "{\n    if (this == period) {\n        return true;\n    }\n    if (period instanceof ReadablePeriod == false) {\n        return false;\n    }\n    ReadablePeriod other = (ReadablePeriod) period;\n    return (other.getPeriodType() == getPeriodType() && other.getValue(0) == getValue());\n}", "repo_id": "7", "comment": "/**\n * Compares this object with the specified object for equality based on the\n * value of each field. All ReadablePeriod instances are accepted, but only\n * those with a matching <code>PeriodType</code> can return true.\n *\n * @param period  a readable period to check against\n * @return true if all the field values are equal, false if\n *  not or the period is null or of an incorrect type\n */\n", "repo_name": "joda-time-main/", "id": 479, "method_signature": "boolean equals(Object)"}, "BaseSingleFieldPeriod.get": {"callee_method_names": [], "method_name": "BaseSingleFieldPeriod.get", "method_implementation": "{\n    if (type == getFieldType()) {\n        return getValue();\n    }\n    return 0;\n}", "repo_id": "7", "comment": "/**\n * Gets the value of a duration field represented by this period.\n * <p>\n * If the field type specified does not match the type used by this class\n * then zero is returned.\n *\n * @param type  the field type to query, null returns zero\n * @return the value of that field, zero if field not supported\n */\n", "repo_name": "joda-time-main/", "id": 477, "method_signature": "int get(DurationFieldType)"}, "BaseSingleFieldPeriod.getFieldType": {"callee_method_names": [], "method_name": "BaseSingleFieldPeriod.getFieldType", "method_implementation": "{\n    if (index != 0) {\n        throw new IndexOutOfBoundsException(String.valueOf(index));\n    }\n    return getFieldType();\n}", "repo_id": "7", "comment": "/**\n * Gets the field type at the specified index.\n * <p>\n * The only index supported by this period is zero which returns the\n * field type of this class.\n *\n * @param index  the index to retrieve, which must be zero\n * @return the field at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "joda-time-main/", "id": 475, "method_signature": "DurationFieldType getFieldType(int)"}, "BaseSingleFieldPeriod.getValue": {"callee_method_names": [], "method_name": "BaseSingleFieldPeriod.getValue", "method_implementation": "{\n    if (index != 0) {\n        throw new IndexOutOfBoundsException(String.valueOf(index));\n    }\n    return getValue();\n}", "repo_id": "7", "comment": "/**\n * Gets the value at the specified index.\n * <p>\n * The only index supported by this period is zero.\n *\n * @param index  the index to retrieve, which must be zero\n * @return the value of the field at the specified index\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "joda-time-main/", "id": 476, "method_signature": "int getValue(int)"}, "BaseSingleFieldPeriod.hashCode": {"callee_method_names": [], "method_name": "BaseSingleFieldPeriod.hashCode", "method_implementation": "{\n    int total = 17;\n    total = 27 * total + getValue();\n    total = 27 * total + getFieldType().hashCode();\n    return total;\n}", "repo_id": "7", "comment": "/**\n * Gets a hash code for the period as defined by ReadablePeriod.\n *\n * @return a hash code\n */\n", "repo_name": "joda-time-main/", "id": 480, "method_signature": "int hashCode()"}, "BaseSingleFieldPeriod.standardPeriodIn": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getValue", "ReadablePeriod.getFieldType", "DurationField.isPrecise", "DurationField.getName", "DurationField.getUnitMillis"], "method_name": "BaseSingleFieldPeriod.standardPeriodIn", "method_implementation": "{\n    if (period == null) {\n        return 0;\n    }\n    Chronology iso = ISOChronology.getInstanceUTC();\n    long duration = 0L;\n    for (int i = 0; i < period.size(); i++) {\n        int value = period.getValue(i);\n        if (value != 0) {\n            DurationField field = period.getFieldType(i).getField(iso);\n            if (field.isPrecise() == false) {\n                throw new IllegalArgumentException(\"Cannot convert period to duration as \" + field.getName() + \" is not precise in the period \" + period);\n            }\n            duration = FieldUtils.safeAdd(duration, FieldUtils.safeMultiply(field.getUnitMillis(), value));\n        }\n    }\n    return FieldUtils.safeToInt(duration / millisPerUnit);\n}", "repo_id": "7", "comment": "/**\n * Creates a new instance representing the number of complete standard length units\n * in the specified period.\n * <p>\n * This factory method converts all fields from the period to hours using standardised\n * durations for each field. Only those fields which have a precise duration in\n * the ISO UTC chronology can be converted.\n * <ul>\n * <li>One week consists of 7 days.\n * <li>One day consists of 24 hours.\n * <li>One hour consists of 60 minutes.\n * <li>One minute consists of 60 seconds.\n * <li>One second consists of 1000 milliseconds.\n * </ul>\n * Months and Years are imprecise and periods containing these values cannot be converted.\n *\n * @param period  the period to get the number of hours from, must not be null\n * @param millisPerUnit  the number of milliseconds in one standard unit of this period\n * @return the int value\n * @throws IllegalArgumentException if the period contains imprecise duration values\n */\n", "repo_name": "joda-time-main/", "id": 474, "method_signature": "int standardPeriodIn(ReadablePeriod, long)"}, "BaseSingleFieldPeriod.toMutablePeriod": {"callee_method_ids": [794], "callee_method_names": ["MutablePeriod.add"], "method_name": "BaseSingleFieldPeriod.toMutablePeriod", "method_implementation": "{\n    MutablePeriod period = new MutablePeriod();\n    period.add(this);\n    return period;\n}", "repo_id": "7", "comment": "/**\n * Get this object as a <code>MutablePeriod</code>.\n * <p>\n * This will always return a new <code>MutablePeriod</code> with the same fields.\n * The period will use <code>PeriodType.standard()</code>.\n *\n * @return a MutablePeriod using the same field set and values\n */\n", "repo_name": "joda-time-main/", "id": 478, "method_signature": "MutablePeriod toMutablePeriod()"}, "BasicChronology.equals": {"callee_method_names": ["Object.getClass", "BasicChronology.getMinimumDaysInFirstWeek", "BasicChronology.getZone"], "method_name": "BasicChronology.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj != null && getClass() == obj.getClass()) {\n        BasicChronology chrono = (BasicChronology) obj;\n        return getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone());\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if this chronology instance equals another.\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 315, "method_signature": "boolean equals(Object)"}, "BasicChronology.getDateMidnightMillis": {"callee_method_names": [], "method_name": "BasicChronology.getDateMidnightMillis", "method_implementation": "{\n    FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear() - 1, getMaxYear() + 1);\n    FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\n    // avoid FieldUtils to get better error message\n    int upperBound = getDaysInYearMonth(year, monthOfYear);\n    if ((dayOfMonth < 1) || (dayOfMonth > upperBound)) {\n        throw new IllegalFieldValueException(DateTimeFieldType.dayOfMonth(), Integer.valueOf(dayOfMonth), Integer.valueOf(1), Integer.valueOf(upperBound), \"year: \" + year + \" month: \" + monthOfYear);\n    }\n    long instant = getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n    // check for limit caused by min/max year +1/-1\n    if (instant < 0 && year == getMaxYear() + 1) {\n        return Long.MAX_VALUE;\n    } else if (instant > 0 && year == getMinYear() - 1) {\n        return Long.MIN_VALUE;\n    }\n    return instant;\n}", "repo_id": "7", "comment": "/**\n * Gets the milliseconds for a date at midnight.\n *\n * @param year  the year\n * @param monthOfYear  the month\n * @param dayOfMonth  the day\n * @return the milliseconds\n */\n", "repo_name": "joda-time-main/", "id": 329, "method_signature": "long getDateMidnightMillis(int, int, int)"}, "BasicChronology.getDayOfMonth": {"callee_method_names": [], "method_name": "BasicChronology.getDayOfMonth", "method_implementation": "{\n    long dateMillis = getYearMillis(year);\n    dateMillis += getTotalMillisByYearMonth(year, month);\n    return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n}", "repo_id": "7", "comment": "/**\n * @param millis from 1970-01-01T00:00:00Z\n * @param year precalculated year of millis\n * @param month precalculated month of millis\n */\n", "repo_name": "joda-time-main/", "id": 323, "method_signature": "int getDayOfMonth(long, int, int)"}, "BasicChronology.getDayOfWeek": {"callee_method_names": [], "method_name": "BasicChronology.getDayOfWeek", "method_implementation": "{\n    // 1970-01-01 is day of week 4, Thursday.\n    long daysSince19700101;\n    if (instant >= 0) {\n        daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n    } else {\n        daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1)) / DateTimeConstants.MILLIS_PER_DAY;\n        if (daysSince19700101 < -3) {\n            return 7 + (int) ((daysSince19700101 + 4) % 7);\n        }\n    }\n    return 1 + (int) ((daysSince19700101 + 3) % 7);\n}", "repo_id": "7", "comment": "/**\n * @param instant millis from 1970-01-01T00:00:00Z\n */\n", "repo_name": "joda-time-main/", "id": 326, "method_signature": "int getDayOfWeek(long)"}, "BasicChronology.getDaysInMonthMax": {"callee_method_names": [], "method_name": "BasicChronology.getDaysInMonthMax", "method_implementation": "{\n    int thisYear = getYear(instant);\n    int thisMonth = getMonthOfYear(instant, thisYear);\n    return getDaysInYearMonth(thisYear, thisMonth);\n}", "repo_id": "7", "comment": "/**\n * Gets the maximum number of days in the month specified by the instant.\n *\n * @param instant  millis from 1970-01-01T00:00:00Z\n * @return the maximum number of days in the month\n */\n", "repo_name": "joda-time-main/", "id": 328, "method_signature": "int getDaysInMonthMax(long)"}, "BasicChronology.getFirstWeekOfYearMillis": {"callee_method_names": [], "method_name": "BasicChronology.getFirstWeekOfYearMillis", "method_implementation": "{\n    long jan1millis = getYearMillis(year);\n    int jan1dayOfWeek = getDayOfWeek(jan1millis);\n    if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n        // First week is end of previous year because it doesn't have enough days.\n        return jan1millis + (8 - jan1dayOfWeek) * (long) DateTimeConstants.MILLIS_PER_DAY;\n    } else {\n        // First week is start of this year because it has enough days.\n        return jan1millis - (jan1dayOfWeek - 1) * (long) DateTimeConstants.MILLIS_PER_DAY;\n    }\n}", "repo_id": "7", "comment": "/**\n * Get the millis for the first week of a year.\n *\n * @param year  the year to use\n * @return millis\n */\n", "repo_name": "joda-time-main/", "id": 318, "method_signature": "long getFirstWeekOfYearMillis(int)"}, "BasicChronology.getMillisOfDay": {"callee_method_names": [], "method_name": "BasicChronology.getMillisOfDay", "method_implementation": "{\n    if (instant >= 0) {\n        return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n    } else {\n        return (DateTimeConstants.MILLIS_PER_DAY - 1) + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n    }\n}", "repo_id": "7", "comment": "/**\n * @param instant millis from 1970-01-01T00:00:00Z\n */\n", "repo_name": "joda-time-main/", "id": 327, "method_signature": "int getMillisOfDay(long)"}, "BasicChronology.getWeekOfWeekyear": {"callee_method_names": [], "method_name": "BasicChronology.getWeekOfWeekyear", "method_implementation": "{\n    long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n    if (instant < firstWeekMillis1) {\n        return getWeeksInYear(year - 1);\n    }\n    long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n    if (instant >= firstWeekMillis2) {\n        return 1;\n    }\n    return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n}", "repo_id": "7", "comment": "/**\n * @param instant millis from 1970-01-01T00:00:00Z\n * @param year precalculated year of millis\n */\n", "repo_name": "joda-time-main/", "id": 325, "method_signature": "int getWeekOfWeekyear(long, int)"}, "BasicChronology.getWeeksInYear": {"callee_method_names": [], "method_name": "BasicChronology.getWeeksInYear", "method_implementation": "{\n    long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n    long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n    return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n}", "repo_id": "7", "comment": "/**\n * Get the number of weeks in the year.\n *\n * @param year  the year to use\n * @return number of weeks in the year\n */\n", "repo_name": "joda-time-main/", "id": 317, "method_signature": "int getWeeksInYear(int)"}, "BasicChronology.getWeekyear": {"callee_method_names": [], "method_name": "BasicChronology.getWeekyear", "method_implementation": "{\n    int year = getYear(instant);\n    int week = getWeekOfWeekyear(instant, year);\n    if (week == 1) {\n        return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);\n    } else if (week > 51) {\n        return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n    } else {\n        return year;\n    }\n}", "repo_id": "7", "comment": "/**\n * @param instant millis from 1970-01-01T00:00:00Z\n */\n", "repo_name": "joda-time-main/", "id": 324, "method_signature": "int getWeekyear(long)"}, "BasicChronology.getYear": {"callee_method_names": [], "method_name": "BasicChronology.getYear", "method_implementation": "{\n    // Get an initial estimate of the year, and the millis value that\n    // represents the start of that year. Then verify estimate and fix if\n    // necessary.\n    // Initial estimate uses values divided by two to avoid overflow.\n    long unitMillis = getAverageMillisPerYearDividedByTwo();\n    long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\n    if (i2 < 0) {\n        i2 = i2 - unitMillis + 1;\n    }\n    int year = (int) (i2 / unitMillis);\n    long yearStart = getYearMillis(year);\n    long diff = instant - yearStart;\n    if (diff < 0) {\n        year--;\n    } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n        // One year may need to be added to fix estimate.\n        long oneYear;\n        if (isLeapYear(year)) {\n            oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n        } else {\n            oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n        }\n        yearStart += oneYear;\n        if (yearStart <= instant) {\n            // Didn't go too far, so actually add one year.\n            year++;\n        }\n    }\n    return year;\n}", "repo_id": "7", "comment": "/**\n * @param instant millis from 1970-01-01T00:00:00Z\n */\n", "repo_name": "joda-time-main/", "id": 321, "method_signature": "int getYear(long)"}, "BasicChronology.getYearInfo": {"callee_method_names": [], "method_name": "BasicChronology.getYearInfo", "method_implementation": "{\n    YearInfo info = iYearInfoCache[year & CACHE_MASK];\n    if (info == null || info.iYear != year) {\n        info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n        iYearInfoCache[year & CACHE_MASK] = info;\n    }\n    return info;\n}", "repo_id": "7", "comment": "// Although accessed by multiple threads, this method doesn't need to be synchronized.\n", "repo_name": "joda-time-main/", "id": 330, "method_signature": "YearInfo getYearInfo(int)"}, "BasicChronology.getYearMonthDayMillis": {"callee_method_names": [], "method_name": "BasicChronology.getYearMonthDayMillis", "method_implementation": "{\n    long millis = getYearMillis(year);\n    millis += getTotalMillisByYearMonth(year, month);\n    return millis + (dayOfMonth - 1) * (long) DateTimeConstants.MILLIS_PER_DAY;\n}", "repo_id": "7", "comment": "/**\n * Get the milliseconds for a particular date.\n *\n * @param year The year to use.\n * @param month The month to use\n * @param dayOfMonth The day of the month to use\n * @return millis from 1970-01-01T00:00:00Z\n */\n", "repo_name": "joda-time-main/", "id": 320, "method_signature": "long getYearMonthDayMillis(int, int, int)"}, "BasicChronology.getYearMonthMillis": {"callee_method_names": [], "method_name": "BasicChronology.getYearMonthMillis", "method_implementation": "{\n    long millis = getYearMillis(year);\n    millis += getTotalMillisByYearMonth(year, month);\n    return millis;\n}", "repo_id": "7", "comment": "/**\n * Get the milliseconds for the start of a month.\n *\n * @param year The year to use.\n * @param month The month to use\n * @return millis from 1970-01-01T00:00:00Z\n */\n", "repo_name": "joda-time-main/", "id": 319, "method_signature": "long getYearMonthMillis(int, int)"}, "BasicChronology.toString": {"callee_method_names": ["String.lastIndexOf", "String.substring", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "DateTimeZone.getID", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "BasicChronology.toString", "method_implementation": "{\n    StringBuilder sb = new StringBuilder(60);\n    String name = getClass().getName();\n    int index = name.lastIndexOf('.');\n    if (index >= 0) {\n        name = name.substring(index + 1);\n    }\n    sb.append(name);\n    sb.append('[');\n    DateTimeZone zone = getZone();\n    if (zone != null) {\n        sb.append(zone.getID());\n    }\n    if (getMinimumDaysInFirstWeek() != 4) {\n        sb.append(\",mdfw=\");\n        sb.append(getMinimumDaysInFirstWeek());\n    }\n    sb.append(']');\n    return sb.toString();\n}", "repo_id": "7", "comment": "/**\n * Gets a debugging toString.\n *\n * @return a debugging string\n */\n", "repo_name": "joda-time-main/", "id": 316, "method_signature": "String toString()"}, "BasicFixedMonthChronology.getDayOfMonth": {"callee_method_names": [], "method_name": "BasicFixedMonthChronology.getDayOfMonth", "method_implementation": "{\n    // optimised for fixed months\n    return (getDayOfYear(millis) - 1) % MONTH_LENGTH + 1;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 282, "method_signature": "int getDayOfMonth(long)"}, "BasicFixedMonthChronology.getMonthOfYear": {"callee_method_names": [], "method_name": "BasicFixedMonthChronology.getMonthOfYear", "method_implementation": "{\n    long monthZeroBased = (millis - getYearMillis(year)) / MILLIS_PER_MONTH;\n    return ((int) monthZeroBased) + 1;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 283, "method_signature": "int getMonthOfYear(long, int)"}, "BasicFixedMonthChronology.getYearDifference": {"callee_method_names": [], "method_name": "BasicFixedMonthChronology.getYearDifference", "method_implementation": "{\n    // optimsed implementation of getDifference, due to fixed months\n    int minuendYear = getYear(minuendInstant);\n    int subtrahendYear = getYear(subtrahendInstant);\n    // Inlined remainder method to avoid duplicate calls to get.\n    long minuendRem = minuendInstant - getYearMillis(minuendYear);\n    long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n    int difference = minuendYear - subtrahendYear;\n    if (minuendRem < subtrahendRem) {\n        difference--;\n    }\n    return difference;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 281, "method_signature": "long getYearDifference(long, long)"}, "BasicFixedMonthChronology.setYear": {"callee_method_names": [], "method_name": "BasicFixedMonthChronology.setYear", "method_implementation": "{\n    // optimsed implementation of set, due to fixed months\n    int thisYear = getYear(instant);\n    int dayOfYear = getDayOfYear(instant, thisYear);\n    int millisOfDay = getMillisOfDay(instant);\n    if (dayOfYear > 365) {\n        // Current year is leap, and day is leap.\n        if (!isLeapYear(year)) {\n            // Moving to a non-leap year, leap day doesn't exist.\n            dayOfYear--;\n        }\n    }\n    instant = getYearMonthDayMillis(year, 1, dayOfYear);\n    instant += millisOfDay;\n    return instant;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 280, "method_signature": "long setYear(long, int)"}, "BasicGJChronology.getDaysInYearMonth": {"callee_method_names": [], "method_name": "BasicGJChronology.getDaysInYearMonth", "method_implementation": "{\n    if (isLeapYear(year)) {\n        return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n    } else {\n        return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the number of days in the specified month and year.\n *\n * @param year  the year\n * @param month  the month\n * @return the number of days\n */\n", "repo_name": "joda-time-main/", "id": 272, "method_signature": "int getDaysInYearMonth(int, int)"}, "BasicGJChronology.getTotalMillisByYearMonth": {"callee_method_names": [], "method_name": "BasicGJChronology.getTotalMillisByYearMonth", "method_implementation": "{\n    if (isLeapYear(year)) {\n        return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n    } else {\n        return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 273, "method_signature": "long getTotalMillisByYearMonth(int, int)"}, "BasicGJChronology.getYearDifference": {"callee_method_names": [], "method_name": "BasicGJChronology.getYearDifference", "method_implementation": "{\n    int minuendYear = getYear(minuendInstant);\n    int subtrahendYear = getYear(subtrahendInstant);\n    // Inlined remainder method to avoid duplicate calls to get.\n    long minuendRem = minuendInstant - getYearMillis(minuendYear);\n    long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n    // Balance leap year differences on remainders.\n    if (subtrahendRem >= FEB_29) {\n        if (isLeapYear(subtrahendYear)) {\n            if (!isLeapYear(minuendYear)) {\n                subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n            }\n        } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) {\n            minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n        }\n    }\n    int difference = minuendYear - subtrahendYear;\n    if (minuendRem < subtrahendRem) {\n        difference--;\n    }\n    return difference;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 274, "method_signature": "long getYearDifference(long, long)"}, "BasicGJChronology.setYear": {"callee_method_names": [], "method_name": "BasicGJChronology.setYear", "method_implementation": "{\n    int thisYear = getYear(instant);\n    int dayOfYear = getDayOfYear(instant, thisYear);\n    int millisOfDay = getMillisOfDay(instant);\n    if (dayOfYear > (31 + 28)) {\n        // after Feb 28\n        if (isLeapYear(thisYear)) {\n            // Current date is Feb 29 or later.\n            if (!isLeapYear(year)) {\n                // Moving to a non-leap year, Feb 29 does not exist.\n                dayOfYear--;\n            }\n        } else {\n            // Current date is Mar 01 or later.\n            if (isLeapYear(year)) {\n                // Moving to a leap year, account for Feb 29.\n                dayOfYear++;\n            }\n        }\n    }\n    instant = getYearMonthDayMillis(year, 1, dayOfYear);\n    instant += millisOfDay;\n    return instant;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 275, "method_signature": "long setYear(long, int)"}, "BasicMonthOfYearDateTimeField.add": {"callee_method_names": ["ReadablePartial.size", "ReadablePartial.getFieldType", "ReadablePartial.size", "ReadablePartial.getFieldType", "BasicChronology.get"], "method_name": "BasicMonthOfYearDateTimeField.add", "method_implementation": "{\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) {\n        // month is largest field and being added to, such as month-day\n        int curMonth0 = values[0] - 1;\n        int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1;\n        return set(partial, 0, values, newMonth);\n    }\n    if (DateTimeUtils.isContiguous(partial)) {\n        long instant = 0L;\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n        }\n        instant = add(instant, valueToAdd);\n        return iChronology.get(partial, instant);\n    } else {\n        return super.add(partial, fieldIndex, values, valueToAdd);\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 346, "method_signature": "int[] add(ReadablePartial, int, int[], int)"}, "BasicMonthOfYearDateTimeField.getDifferenceAsLong": {"callee_method_ids": [321, 321, 323, 323, 319, 319], "callee_method_names": ["BasicChronology.getYear", "BasicChronology.getMonthOfYear", "BasicChronology.getYear", "BasicChronology.getMonthOfYear", "BasicChronology.getDayOfMonth", "BasicChronology.getDaysInYearMonth", "BasicChronology.getDayOfMonth", "BasicChronology.dayOfMonth", "BasicChronology.getYearMonthMillis", "BasicChronology.getYearMonthMillis"], "method_name": "BasicMonthOfYearDateTimeField.getDifferenceAsLong", "method_implementation": "{\n    if (minuendInstant < subtrahendInstant) {\n        return -getDifference(subtrahendInstant, minuendInstant);\n    }\n    int minuendYear = iChronology.getYear(minuendInstant);\n    int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n    int subtrahendYear = iChronology.getYear(subtrahendInstant);\n    int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n    long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth;\n    // Before adjusting for remainder, account for special case of add\n    // where the day-of-month is forced to the nearest sane value.\n    int minuendDom = iChronology.getDayOfMonth(minuendInstant, minuendYear, minuendMonth);\n    if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n        // Last day of the minuend month...\n        int subtrahendDom = iChronology.getDayOfMonth(subtrahendInstant, subtrahendYear, subtrahendMonth);\n        if (subtrahendDom > minuendDom) {\n            // ...and day of subtrahend month is larger.\n            // Note: This works fine, but it ideally shouldn't invoke other\n            // fields from within a field.\n            subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n        }\n    }\n    // Inlined remainder method to avoid duplicate calls.\n    long minuendRem = minuendInstant - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n    long subtrahendRem = subtrahendInstant - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n    if (minuendRem < subtrahendRem) {\n        difference--;\n    }\n    return difference;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 347, "method_signature": "long getDifferenceAsLong(long, long)"}, "BasicMonthOfYearDateTimeField.isLeap": {"callee_method_ids": [321], "callee_method_names": ["BasicChronology.getYear", "BasicChronology.isLeapYear", "BasicChronology.getMonthOfYear"], "method_name": "BasicMonthOfYearDateTimeField.isLeap", "method_implementation": "{\n    int thisYear = iChronology.getYear(instant);\n    if (iChronology.isLeapYear(thisYear)) {\n        return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth);\n    }\n    return false;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 349, "method_signature": "boolean isLeap(long)"}, "BasicMonthOfYearDateTimeField.roundFloor": {"callee_method_ids": [321, 319], "callee_method_names": ["BasicChronology.getYear", "BasicChronology.getMonthOfYear", "BasicChronology.getYearMonthMillis"], "method_name": "BasicMonthOfYearDateTimeField.roundFloor", "method_implementation": "{\n    int year = iChronology.getYear(instant);\n    int month = iChronology.getMonthOfYear(instant, year);\n    return iChronology.getYearMonthMillis(year, month);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 350, "method_signature": "long roundFloor(long)"}, "BasicMonthOfYearDateTimeField.set": {"callee_method_ids": [321, 323, 320, 327], "callee_method_names": ["BasicChronology.getYear", "BasicChronology.getDayOfMonth", "BasicChronology.getDaysInYearMonth", "BasicChronology.getYearMonthDayMillis", "BasicChronology.getMillisOfDay"], "method_name": "BasicMonthOfYearDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n    //\n    int thisYear = iChronology.getYear(instant);\n    //\n    int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n    int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n    if (thisDom > maxDom) {\n        // Quietly force DOM to nearest sane value.\n        thisDom = maxDom;\n    }\n    // Return newly calculated millis value\n    return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) + iChronology.getMillisOfDay(instant);\n}", "repo_id": "7", "comment": "/**\n * Set the Month component of the specified time instant.<p>\n * If the new month has less total days than the specified\n * day of the month, this value is coerced to the nearest\n * sane value. e.g.<p>\n * 07-31 to month 6 = 06-30<p>\n * 03-31 to month 2 = 02-28 or 02-29 depending<p>\n *\n * @param instant  the time instant in millis to update.\n * @param month  the month (1,12) to update the time to.\n * @return the updated time instant.\n * @throws IllegalArgumentException  if month is invalid\n */\n", "repo_name": "joda-time-main/", "id": 348, "method_signature": "long set(long, int)"}, "BasicWeekyearDateTimeField.add": {"callee_method_names": [], "method_name": "BasicWeekyearDateTimeField.add", "method_implementation": "{\n    if (years == 0) {\n        return instant;\n    }\n    return set(instant, get(instant) + years);\n}", "repo_id": "7", "comment": "/**\n * Add the specified years to the specified time instant.\n *\n * @see org.joda.time.DateTimeField#add\n * @param instant  the time instant in millis to update.\n * @param years  the years to add (can be negative).\n * @return the updated time instant.\n */\n", "repo_name": "joda-time-main/", "id": 313, "method_signature": "long add(long, int)"}, "BasicWeekyearDateTimeField.set": {"callee_method_ids": [326, 317, 317, 325, 325], "callee_method_names": ["BasicChronology.getMinYear", "BasicChronology.getMaxYear", "BasicChronology.getDayOfWeek", "BasicChronology.getWeeksInYear", "BasicChronology.getWeeksInYear", "BasicChronology.getWeekOfWeekyear", "BasicChronology.setYear", "BasicChronology.getWeekOfWeekyear", "BasicChronology.dayOfWeek"], "method_name": "BasicWeekyearDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear());\n    //\n    // Do nothing if no real change is requested.\n    //\n    int thisWeekyear = get(instant);\n    if (thisWeekyear == year) {\n        return instant;\n    }\n    //\n    // Calculate the DayOfWeek (to be preserved).\n    //\n    int thisDow = iChronology.getDayOfWeek(instant);\n    //\n    // Calculate the maximum weeks in the target year.\n    //\n    int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear);\n    int weeksInToYear = iChronology.getWeeksInYear(year);\n    int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear;\n    //\n    // Get the current week of the year. This will be preserved in\n    // the output unless it is greater than the maximum possible\n    // for the target weekyear.  In that case it is adjusted\n    // to the maximum possible.\n    //\n    int setToWeek = iChronology.getWeekOfWeekyear(instant);\n    if (setToWeek > maxOutWeeks) {\n        setToWeek = maxOutWeeks;\n    }\n    //\n    // Get a wroking copy of the current date-time.\n    // This can be a convenience for debugging.\n    //\n    // Get a copy\n    long workInstant = instant;\n    //\n    // Attempt to get close to the proper weekyear.\n    // Note - we cannot currently call ourself, so we just call\n    // set for the year.  This at least gets us close.\n    //\n    workInstant = iChronology.setYear(workInstant, year);\n    //\n    // Calculate the weekyear number for the get close to value\n    // (which might not be equal to the year just set).\n    //\n    int workWoyYear = get(workInstant);\n    //\n    // At most we are off by one year, which can be \"fixed\" by\n    // adding/subtracting a week.\n    //\n    if (workWoyYear < year) {\n        workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n    } else if (workWoyYear > year) {\n        workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n    }\n    //\n    // Set the proper week in the current weekyear.\n    //\n    // BEGIN: possible set WeekOfWeekyear logic.\n    int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);\n    // No range check required (we already know it is OK).\n    workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK;\n    // END: possible set WeekOfWeekyear logic.\n    //\n    // Reset DayOfWeek to previous value.\n    //\n    // Note: This works fine, but it ideally shouldn't invoke other\n    // fields from within a field.\n    workInstant = iChronology.dayOfWeek().set(workInstant, thisDow);\n    //\n    // Return result.\n    //\n    return workInstant;\n}", "repo_id": "7", "comment": "/**\n * Set the Year of a week based year component of the specified time instant.\n *\n * @see org.joda.time.DateTimeField#set\n * @param instant  the time instant in millis to update.\n * @param year  the year (-9999,9999) to set the date to.\n * @return the updated DateTime.\n * @throws IllegalArgumentException  if year is invalid.\n */\n", "repo_name": "joda-time-main/", "id": 314, "method_signature": "long set(long, int)"}, "BuddhistChronology.equals": {"callee_method_names": ["BuddhistChronology.getZone"], "method_name": "BuddhistChronology.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof BuddhistChronology) {\n        BuddhistChronology chrono = (BuddhistChronology) obj;\n        return getZone().equals(chrono.getZone());\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if this chronology instance equals another.\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 355, "method_signature": "boolean equals(Object)"}, "BuddhistChronology.getInstance": {"callee_method_names": ["ConcurrentHashMap.get", "ConcurrentHashMap.putIfAbsent"], "method_name": "BuddhistChronology.getInstance", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    BuddhistChronology chrono = cCache.get(zone);\n    if (chrono == null) {\n        // First create without a lower limit.\n        chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);\n        // Impose lower limit and make another BuddhistChronology.\n        DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n        chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), \"\");\n        BuddhistChronology oldChrono = cCache.putIfAbsent(zone, chrono);\n        if (oldChrono != null) {\n            chrono = oldChrono;\n        }\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Standard instance of a Buddhist Chronology, that matches\n * Sun's BuddhistCalendar class. This means that it follows the\n * GregorianJulian calendar rules with a cutover date.\n *\n * @param zone  the time zone to use, null is default\n * @return the chronology, not null\n */\n", "repo_name": "joda-time-main/", "id": 353, "method_signature": "BuddhistChronology getInstance(DateTimeZone)"}, "BuddhistChronology.toString": {"callee_method_names": ["DateTimeZone.getID"], "method_name": "BuddhistChronology.toString", "method_implementation": "{\n    String str = \"BuddhistChronology\";\n    DateTimeZone zone = getZone();\n    if (zone != null) {\n        str = str + '[' + zone.getID() + ']';\n    }\n    return str;\n}", "repo_id": "7", "comment": "/**\n * Gets a debugging toString.\n *\n * @return a debugging string\n */\n", "repo_name": "joda-time-main/", "id": 356, "method_signature": "String toString()"}, "BuddhistChronology.withZone": {"callee_method_names": [], "method_name": "BuddhistChronology.withZone", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    if (zone == getZone()) {\n        return this;\n    }\n    return getInstance(zone);\n}", "repo_id": "7", "comment": "/**\n * Gets the Chronology in a specific time zone.\n *\n * @param zone  the zone to get the chronology in, null is default\n * @return the chronology\n */\n", "repo_name": "joda-time-main/", "id": 354, "method_signature": "Chronology withZone(DateTimeZone)"}, "CachedDateTimeZone.forZone": {"callee_method_names": [], "method_name": "CachedDateTimeZone.forZone", "method_implementation": "{\n    if (zone instanceof CachedDateTimeZone) {\n        return (CachedDateTimeZone) zone;\n    }\n    return new CachedDateTimeZone(zone);\n}", "repo_id": "7", "comment": "/**\n * Returns a new CachedDateTimeZone unless given zone is already cached.\n */\n", "repo_name": "joda-time-main/", "id": 740, "method_signature": "CachedDateTimeZone forZone(DateTimeZone)"}, "CalAction.actionPerformed": {"callee_method_names": ["JMenuItem.setEnabled"], "method_name": "CalAction.actionPerformed", "method_implementation": "{\n    TableView tView = new CalTableView(currFile);\n    resetDefaults(tView);\n    enableAllViews();\n    jmiCal.setEnabled(false);\n}", "repo_id": "7", "comment": "/*\n         * actionPerformed\n         */\n", "repo_name": "joda-time-main/", "id": 1113, "method_signature": "void actionPerformed(ActionEvent)"}, "CalTableView.genCalcdValues": {"callee_method_names": ["LoadedFile.getFileStrings", "LoadedFile.getDtObjects", "ArrayList.size", "ArrayList.size", "ArrayList.get", "ArrayList.get", "DateTime.toString", "DateTime.getMillis", "GregorianCalendar.setTime", "GregorianCalendar.setMinimalDaysInFirstWeek", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get"], "method_name": "CalTableView.genCalcdValues", "method_implementation": "{\n    Object[][] retValues = null;\n    /*\n             * Create an array of Objects that will contain\n             * other arrays of Objects. (This is the 'column'\n             * array).\n             */\n    ArrayList fileStrings = lddFile.getFileStrings();\n    ArrayList dtObjects = lddFile.getDtObjects();\n    int numRows = fileStrings.size();\n    retValues = new Object[numRows][];\n    int numCols = colNames.length;\n    // System.err.println(\"NumCols : \" + numCols);\n    /*\n             * Prime the array of arrays of Objects, allocating a new\n             * secondary array for each of the primary array's\n             * elements.\n             */\n    for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++nextStrNum) {\n        // get the 'col' array\n        retValues[nextStrNum] = new Object[numCols];\n        //****\n        //* This needs to be sync'd with the colNames array.\n        //****\n        // Current row, 1st column\n        int column = 0;\n        String fileString = (String) fileStrings.get(nextStrNum);\n        retValues[nextStrNum][column++] = fileString;\n        // Current row, 2nd column\n        DateTime adt = (DateTime) dtObjects.get(nextStrNum);\n        String adtStr = adt.toString();\n        retValues[nextStrNum][column++] = adtStr;\n        // Current row, other columns.\n        // Order here must match that specified in the colNames\n        // array.\n        long lVal = adt.getMillis();\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(new Date(lVal));\n        cal.setMinimalDaysInFirstWeek(4);\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.MILLISECOND));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.SECOND));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.MINUTE));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.HOUR_OF_DAY));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.DAY_OF_WEEK));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.DAY_OF_MONTH));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.DAY_OF_YEAR));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.WEEK_OF_YEAR));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.MONTH));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.YEAR));\n        //\n    }\n    // the for\n    if (debugf)\n        dumpObjs(retValues, System.err);\n    return retValues;\n}", "repo_id": "7", "comment": "/*\n         * genCalcdValues is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1104, "method_signature": "Object[][] genCalcdValues()"}, "CalTableView.genColNames": {"callee_method_names": [], "method_name": "CalTableView.genColNames", "method_implementation": "{\n    Object[] retVal = { // 0\n    \"FileString\", // 1\n    \"toString()\", // 2\n    \"Millis\", // 3\n    \"Sec\", // 4\n    \"Min\", // 5\n    \"HrOfDay\", // 6\n    \"DayOfWeek\", // 7\n    \"DayOfMon\", // 8\n    \"DayOfYr\", // 9\n    \"WkofYr\", // 10\n    \"MonOfYr\", // 11\n    \"Year\" };\n    return retVal;\n}", "repo_id": "7", "comment": "/*\n         * genColNames is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1105, "method_signature": "Object[] genColNames()"}, "CalTableView.getViewTitle": {"callee_method_names": ["LoadedFile.getLoadedFileSize"], "method_name": "CalTableView.getViewTitle", "method_implementation": "{\n    return \"java.util.Calendar.get(int)\" + \" : \" + TimeZone.getDefault().getDisplayName() + \" : \" + \" Record Count \" + currFile.getLoadedFileSize();\n}", "repo_id": "7", "comment": "/*\n         * getViewTitle\n         */\n", "repo_name": "joda-time-main/", "id": 1106, "method_signature": "String getViewTitle()"}, "CalTableView.setViewColumnsWidth": {"callee_method_names": ["JTable.getColumnModel", "TableColumnModel.getColumn", "TableColumn.setPreferredWidth", "TableColumnModel.getColumn", "TableColumn.setPreferredWidth"], "method_name": "CalTableView.setViewColumnsWidth", "method_implementation": "{\n    /*\n             * Resize column 0, 1\n             */\n    TableColumnModel colmodel = jt.getColumnModel();\n    TableColumn col0 = colmodel.getColumn(0);\n    col0.setPreferredWidth(175);\n    TableColumn col1 = colmodel.getColumn(1);\n    col1.setPreferredWidth(175);\n    return;\n}", "repo_id": "7", "comment": "/*\n         * setViewColumnLengths\n         */\n", "repo_name": "joda-time-main/", "id": 1107, "method_signature": "void setViewColumnsWidth(JTable)"}, "CalendarConverter.getChronology": {"callee_method_names": ["Object.getClass", "GregorianCalendar.getGregorianChange"], "method_name": "CalendarConverter.getChronology", "method_implementation": "{\n    if (object.getClass().getName().endsWith(\".BuddhistCalendar\")) {\n        return BuddhistChronology.getInstance(zone);\n    } else if (object instanceof GregorianCalendar) {\n        GregorianCalendar gc = (GregorianCalendar) object;\n        long cutover = gc.getGregorianChange().getTime();\n        if (cutover == Long.MIN_VALUE) {\n            return GregorianChronology.getInstance(zone);\n        } else if (cutover == Long.MAX_VALUE) {\n            return JulianChronology.getInstance(zone);\n        } else {\n            return GJChronology.getInstance(zone, cutover, 4);\n        }\n    } else {\n        return ISOChronology.getInstance(zone);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the chronology, which is the GJChronology if a GregorianCalendar is used,\n * BuddhistChronology if a BuddhistCalendar is used or ISOChronology otherwise.\n * The time zone specified is used in preference to that on the calendar.\n *\n * @param object  the Calendar to convert, must not be null\n * @param zone  the specified zone to use, null means default zone\n * @return the chronology, never null\n * @throws NullPointerException if the object is null\n * @throws ClassCastException if the object is an invalid type\n */\n", "repo_name": "joda-time-main/", "id": 585, "method_signature": "Chronology getChronology(Object, DateTimeZone)"}, "CalendarConverter.getInstantMillis": {"callee_method_names": ["Calendar.getTime"], "method_name": "CalendarConverter.getInstantMillis", "method_implementation": "{\n    Calendar calendar = (Calendar) object;\n    return calendar.getTime().getTime();\n}", "repo_id": "7", "comment": "/**\n * Gets the millis, which is the Calendar millis value.\n *\n * @param object  the Calendar to convert, must not be null\n * @param chrono  the chronology result from getChronology, non-null\n * @return the millisecond value\n * @throws NullPointerException if the object is null\n * @throws ClassCastException if the object is an invalid type\n */\n", "repo_name": "joda-time-main/", "id": 586, "method_signature": "long getInstantMillis(Object, Chronology)"}, "ClassLoadTest.main": {"callee_method_names": [], "method_name": "ClassLoadTest.main", "method_implementation": "{\n    System.out.println(\"-----------------------------------------------\");\n    System.out.println(\"-----------AbstractInstant---------------------\");\n    Class cls = AbstractInstant.class;\n    System.out.println(\"-----------ReadableDateTime--------------------\");\n    cls = ReadableDateTime.class;\n    System.out.println(\"-----------AbstractDateTime--------------------\");\n    cls = AbstractDateTime.class;\n    System.out.println(\"-----------DateTime----------------------------\");\n    cls = DateTime.class;\n    System.out.println(\"-----------DateTimeZone------------------------\");\n    cls = DateTimeZone.class;\n    System.out.println(\"-----------new DateTime()----------------------\");\n    DateTime dt = new DateTime();\n    System.out.println(\"-----------new DateTime(ReadableInstant)-------\");\n    dt = new DateTime(dt);\n    System.out.println(\"-----------new DateTime(Long)------------------\");\n    dt = new DateTime(new Long(0));\n    System.out.println(\"-----------------------------------------------\");\n}", "repo_id": "7", "comment": "// run using JVM -verbose:class\n", "repo_name": "joda-time-main/", "id": 2030, "method_signature": "void main(String[])"}, "Composite.decompose": {"callee_method_names": ["List<Object>.size", "List<Object>.get", "List<Object>.add", "List<Object>.get", "List<Object>.add"], "method_name": "Composite.decompose", "method_implementation": "{\n    int size = elementPairs.size();\n    for (int i = 0; i < size; i += 2) {\n        Object element = elementPairs.get(i);\n        if (element instanceof Composite) {\n            addArrayToList(printerList, ((Composite) element).iPrinters);\n        } else {\n            printerList.add(element);\n        }\n        element = elementPairs.get(i + 1);\n        if (element instanceof Composite) {\n            addArrayToList(parserList, ((Composite) element).iParsers);\n        } else {\n            parserList.add(element);\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Processes the element pairs, putting results into the given printer\n * and parser lists.\n */\n", "repo_name": "joda-time-main/", "id": 934, "method_signature": "void decompose(List, List, List)"}, "Constants.basicDate": {"callee_method_names": [], "method_name": "Constants.basicDate", "method_implementation": "{\n    if (bd == null) {\n        return new DateTimeFormatterBuilder().appendYear(4, 4).appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2).appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2).toFormatter();\n    }\n    return bd;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 824, "method_signature": "DateTimeFormatter basicDate()"}, "Constants.dateParser": {"callee_method_names": [], "method_name": "Constants.dateParser", "method_implementation": "{\n    if (dp == null) {\n        DateTimeParser tOffset = new DateTimeFormatterBuilder().appendLiteral('T').append(offsetElement()).toParser();\n        return new DateTimeFormatterBuilder().append(dateElementParser()).appendOptional(tOffset).toFormatter();\n    }\n    return dp;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 822, "method_signature": "DateTimeFormatter dateParser()"}, "Constants.time": {"callee_method_names": [], "method_name": "Constants.time", "method_implementation": "{\n    if (t == null) {\n        return new DateTimeFormatterBuilder().append(hourMinuteSecondFraction()).append(offsetElement()).toFormatter();\n    }\n    return t;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 823, "method_signature": "DateTimeFormatter time()"}, "Constants.yearElement": {"callee_method_names": [], "method_name": "Constants.yearElement", "method_implementation": "{\n    if (ye == null) {\n        return new DateTimeFormatterBuilder().appendYear(4, 9).toFormatter();\n    }\n    return ye;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 826, "method_signature": "DateTimeFormatter yearElement()"}, "Constants.yearMonth": {"callee_method_names": [], "method_name": "Constants.yearMonth", "method_implementation": "{\n    if (ym == null) {\n        return new DateTimeFormatterBuilder().append(yearElement()).append(monthElement()).toFormatter();\n    }\n    return ym;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 825, "method_signature": "DateTimeFormatter yearMonth()"}, "ConverterManager.addDurationConverter": {"callee_method_ids": [577], "callee_method_names": ["ConverterSet.add"], "method_name": "ConverterManager.addDurationConverter", "method_implementation": "{\n    checkAlterDurationConverters();\n    if (converter == null) {\n        return null;\n    }\n    DurationConverter[] removed = new DurationConverter[1];\n    iDurationConverters = iDurationConverters.add(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Adds a converter to the set of converters. If a matching converter is\n * already in the set, the given converter replaces it. If the converter is\n * exactly the same as one already in the set, no changes are made.\n * <p>\n * The order in which converters are added is not relevant. The best\n * converter is selected by examining the object hierarchy.\n *\n * @param converter  the converter to add, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 605, "method_signature": "DurationConverter addDurationConverter(DurationConverter)"}, "ConverterManager.addInstantConverter": {"callee_method_ids": [577], "callee_method_names": ["ConverterSet.add"], "method_name": "ConverterManager.addInstantConverter", "method_implementation": "{\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.add(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Adds a converter to the set of converters. If a matching converter is\n * already in the set, the given converter replaces it. If the converter is\n * exactly the same as one already in the set, no changes are made.\n * <p>\n * The order in which converters are added is not relevant. The best\n * converter is selected by examining the object hierarchy.\n *\n * @param converter  the converter to add, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 595, "method_signature": "InstantConverter addInstantConverter(InstantConverter)"}, "ConverterManager.addIntervalConverter": {"callee_method_ids": [577], "callee_method_names": ["ConverterSet.add"], "method_name": "ConverterManager.addIntervalConverter", "method_implementation": "{\n    checkAlterIntervalConverters();\n    if (converter == null) {\n        return null;\n    }\n    IntervalConverter[] removed = new IntervalConverter[1];\n    iIntervalConverters = iIntervalConverters.add(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Adds a converter to the set of converters. If a matching converter is\n * already in the set, the given converter replaces it. If the converter is\n * exactly the same as one already in the set, no changes are made.\n * <p>\n * The order in which converters are added is not relevant. The best\n * converter is selected by examining the object hierarchy.\n *\n * @param converter  the converter to add, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 615, "method_signature": "IntervalConverter addIntervalConverter(IntervalConverter)"}, "ConverterManager.addPartialConverter": {"callee_method_ids": [577], "callee_method_names": ["ConverterSet.add"], "method_name": "ConverterManager.addPartialConverter", "method_implementation": "{\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Adds a converter to the set of converters. If a matching converter is\n * already in the set, the given converter replaces it. If the converter is\n * exactly the same as one already in the set, no changes are made.\n * <p>\n * The order in which converters are added is not relevant. The best\n * converter is selected by examining the object hierarchy.\n *\n * @param converter  the converter to add, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 600, "method_signature": "PartialConverter addPartialConverter(PartialConverter)"}, "ConverterManager.addPeriodConverter": {"callee_method_ids": [577], "callee_method_names": ["ConverterSet.add"], "method_name": "ConverterManager.addPeriodConverter", "method_implementation": "{\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.add(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Adds a converter to the set of converters. If a matching converter is\n * already in the set, the given converter replaces it. If the converter is\n * exactly the same as one already in the set, no changes are made.\n * <p>\n * The order in which converters are added is not relevant. The best\n * converter is selected by examining the object hierarchy.\n *\n * @param converter  the converter to add, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 610, "method_signature": "PeriodConverter addPeriodConverter(PeriodConverter)"}, "ConverterManager.checkAlterDurationConverters": {"callee_method_names": ["SecurityManager.checkPermission"], "method_name": "ConverterManager.checkAlterDurationConverters", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterDurationConverters\"));\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether the user has permission 'ConverterManager.alterDurationConverters'.\n *\n * @throws SecurityException if the user does not have the permission\n */\n", "repo_name": "joda-time-main/", "id": 607, "method_signature": "void checkAlterDurationConverters()"}, "ConverterManager.checkAlterInstantConverters": {"callee_method_names": ["SecurityManager.checkPermission"], "method_name": "ConverterManager.checkAlterInstantConverters", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterInstantConverters\"));\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether the user has permission 'ConverterManager.alterInstantConverters'.\n *\n * @throws SecurityException if the user does not have the permission\n */\n", "repo_name": "joda-time-main/", "id": 597, "method_signature": "void checkAlterInstantConverters()"}, "ConverterManager.checkAlterIntervalConverters": {"callee_method_names": ["SecurityManager.checkPermission"], "method_name": "ConverterManager.checkAlterIntervalConverters", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterIntervalConverters\"));\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether the user has permission 'ConverterManager.alterIntervalConverters'.\n *\n * @throws SecurityException if the user does not have the permission\n */\n", "repo_name": "joda-time-main/", "id": 617, "method_signature": "void checkAlterIntervalConverters()"}, "ConverterManager.checkAlterPartialConverters": {"callee_method_names": ["SecurityManager.checkPermission"], "method_name": "ConverterManager.checkAlterPartialConverters", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPartialConverters\"));\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether the user has permission 'ConverterManager.alterPartialConverters'.\n *\n * @throws SecurityException if the user does not have the permission\n */\n", "repo_name": "joda-time-main/", "id": 602, "method_signature": "void checkAlterPartialConverters()"}, "ConverterManager.checkAlterPeriodConverters": {"callee_method_names": ["SecurityManager.checkPermission"], "method_name": "ConverterManager.checkAlterPeriodConverters", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        sm.checkPermission(new JodaTimePermission(\"ConverterManager.alterPeriodConverters\"));\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether the user has permission 'ConverterManager.alterPeriodConverters'.\n *\n * @throws SecurityException if the user does not have the permission\n */\n", "repo_name": "joda-time-main/", "id": 612, "method_signature": "void checkAlterPeriodConverters()"}, "ConverterManager.getDurationConverter": {"callee_method_ids": [576], "callee_method_names": ["ConverterSet.select", "Object.getClass", "Object.getClass"], "method_name": "ConverterManager.getDurationConverter", "method_implementation": "{\n    DurationConverter converter = (DurationConverter) iDurationConverters.select(object == null ? null : object.getClass());\n    if (converter != null) {\n        return converter;\n    }\n    throw new IllegalArgumentException(\"No duration converter found for type: \" + (object == null ? \"null\" : object.getClass().getName()));\n}", "repo_id": "7", "comment": "/**\n * Gets the best converter for the object specified.\n *\n * @param object  the object to convert\n * @return the converter to use\n * @throws IllegalArgumentException if no suitable converter\n * @throws IllegalStateException if multiple converters match the type\n * equally well\n */\n", "repo_name": "joda-time-main/", "id": 603, "method_signature": "DurationConverter getDurationConverter(Object)"}, "ConverterManager.getDurationConverters": {"callee_method_names": ["ConverterSet.size", "ConverterSet.copyInto"], "method_name": "ConverterManager.getDurationConverters", "method_implementation": "{\n    ConverterSet set = iDurationConverters;\n    DurationConverter[] converters = new DurationConverter[set.size()];\n    set.copyInto(converters);\n    return converters;\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of the list of converters.\n *\n * @return the converters, a copy of the real data, never null\n */\n", "repo_name": "joda-time-main/", "id": 604, "method_signature": "DurationConverter[] getDurationConverters()"}, "ConverterManager.getInstantConverter": {"callee_method_ids": [576], "callee_method_names": ["ConverterSet.select", "Object.getClass", "Object.getClass"], "method_name": "ConverterManager.getInstantConverter", "method_implementation": "{\n    InstantConverter converter = (InstantConverter) iInstantConverters.select(object == null ? null : object.getClass());\n    if (converter != null) {\n        return converter;\n    }\n    throw new IllegalArgumentException(\"No instant converter found for type: \" + (object == null ? \"null\" : object.getClass().getName()));\n}", "repo_id": "7", "comment": "/**\n * Gets the best converter for the object specified.\n *\n * @param object  the object to convert\n * @return the converter to use\n * @throws IllegalArgumentException if no suitable converter\n * @throws IllegalStateException if multiple converters match the type\n * equally well\n */\n", "repo_name": "joda-time-main/", "id": 593, "method_signature": "InstantConverter getInstantConverter(Object)"}, "ConverterManager.getInstantConverters": {"callee_method_names": ["ConverterSet.size", "ConverterSet.copyInto"], "method_name": "ConverterManager.getInstantConverters", "method_implementation": "{\n    ConverterSet set = iInstantConverters;\n    InstantConverter[] converters = new InstantConverter[set.size()];\n    set.copyInto(converters);\n    return converters;\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of the set of converters.\n *\n * @return the converters, a copy of the real data, never null\n */\n", "repo_name": "joda-time-main/", "id": 594, "method_signature": "InstantConverter[] getInstantConverters()"}, "ConverterManager.getIntervalConverter": {"callee_method_ids": [576], "callee_method_names": ["ConverterSet.select", "Object.getClass", "Object.getClass"], "method_name": "ConverterManager.getIntervalConverter", "method_implementation": "{\n    IntervalConverter converter = (IntervalConverter) iIntervalConverters.select(object == null ? null : object.getClass());\n    if (converter != null) {\n        return converter;\n    }\n    throw new IllegalArgumentException(\"No interval converter found for type: \" + (object == null ? \"null\" : object.getClass().getName()));\n}", "repo_id": "7", "comment": "/**\n * Gets the best converter for the object specified.\n *\n * @param object  the object to convert\n * @return the converter to use\n * @throws IllegalArgumentException if no suitable converter\n * @throws IllegalStateException if multiple converters match the type\n * equally well\n */\n", "repo_name": "joda-time-main/", "id": 613, "method_signature": "IntervalConverter getIntervalConverter(Object)"}, "ConverterManager.getIntervalConverters": {"callee_method_names": ["ConverterSet.size", "ConverterSet.copyInto"], "method_name": "ConverterManager.getIntervalConverters", "method_implementation": "{\n    ConverterSet set = iIntervalConverters;\n    IntervalConverter[] converters = new IntervalConverter[set.size()];\n    set.copyInto(converters);\n    return converters;\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of the list of converters.\n *\n * @return the converters, a copy of the real data, never null\n */\n", "repo_name": "joda-time-main/", "id": 614, "method_signature": "IntervalConverter[] getIntervalConverters()"}, "ConverterManager.getPartialConverter": {"callee_method_ids": [576], "callee_method_names": ["ConverterSet.select", "Object.getClass", "Object.getClass"], "method_name": "ConverterManager.getPartialConverter", "method_implementation": "{\n    PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass());\n    if (converter != null) {\n        return converter;\n    }\n    throw new IllegalArgumentException(\"No partial converter found for type: \" + (object == null ? \"null\" : object.getClass().getName()));\n}", "repo_id": "7", "comment": "/**\n * Gets the best converter for the object specified.\n *\n * @param object  the object to convert\n * @return the converter to use\n * @throws IllegalArgumentException if no suitable converter\n * @throws IllegalStateException if multiple converters match the type\n * equally well\n */\n", "repo_name": "joda-time-main/", "id": 598, "method_signature": "PartialConverter getPartialConverter(Object)"}, "ConverterManager.getPartialConverters": {"callee_method_names": ["ConverterSet.size", "ConverterSet.copyInto"], "method_name": "ConverterManager.getPartialConverters", "method_implementation": "{\n    ConverterSet set = iPartialConverters;\n    PartialConverter[] converters = new PartialConverter[set.size()];\n    set.copyInto(converters);\n    return converters;\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of the set of converters.\n *\n * @return the converters, a copy of the real data, never null\n */\n", "repo_name": "joda-time-main/", "id": 599, "method_signature": "PartialConverter[] getPartialConverters()"}, "ConverterManager.getPeriodConverter": {"callee_method_ids": [576], "callee_method_names": ["ConverterSet.select", "Object.getClass", "Object.getClass"], "method_name": "ConverterManager.getPeriodConverter", "method_implementation": "{\n    PeriodConverter converter = (PeriodConverter) iPeriodConverters.select(object == null ? null : object.getClass());\n    if (converter != null) {\n        return converter;\n    }\n    throw new IllegalArgumentException(\"No period converter found for type: \" + (object == null ? \"null\" : object.getClass().getName()));\n}", "repo_id": "7", "comment": "/**\n * Gets the best converter for the object specified.\n *\n * @param object  the object to convert\n * @return the converter to use\n * @throws IllegalArgumentException if no suitable converter\n * @throws IllegalStateException if multiple converters match the type\n * equally well\n */\n", "repo_name": "joda-time-main/", "id": 608, "method_signature": "PeriodConverter getPeriodConverter(Object)"}, "ConverterManager.getPeriodConverters": {"callee_method_names": ["ConverterSet.size", "ConverterSet.copyInto"], "method_name": "ConverterManager.getPeriodConverters", "method_implementation": "{\n    ConverterSet set = iPeriodConverters;\n    PeriodConverter[] converters = new PeriodConverter[set.size()];\n    set.copyInto(converters);\n    return converters;\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of the list of converters.\n *\n * @return the converters, a copy of the real data, never null\n */\n", "repo_name": "joda-time-main/", "id": 609, "method_signature": "PeriodConverter[] getPeriodConverters()"}, "ConverterManager.removeDurationConverter": {"callee_method_ids": [579], "callee_method_names": ["ConverterSet.remove"], "method_name": "ConverterManager.removeDurationConverter", "method_implementation": "{\n    checkAlterDurationConverters();\n    if (converter == null) {\n        return null;\n    }\n    DurationConverter[] removed = new DurationConverter[1];\n    iDurationConverters = iDurationConverters.remove(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Removes a converter from the set of converters. If the converter was\n * not in the set, no changes are made.\n *\n * @param converter  the converter to remove, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 606, "method_signature": "DurationConverter removeDurationConverter(DurationConverter)"}, "ConverterManager.removeInstantConverter": {"callee_method_ids": [579], "callee_method_names": ["ConverterSet.remove"], "method_name": "ConverterManager.removeInstantConverter", "method_implementation": "{\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Removes a converter from the set of converters. If the converter was\n * not in the set, no changes are made.\n *\n * @param converter  the converter to remove, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 596, "method_signature": "InstantConverter removeInstantConverter(InstantConverter)"}, "ConverterManager.removeIntervalConverter": {"callee_method_ids": [579], "callee_method_names": ["ConverterSet.remove"], "method_name": "ConverterManager.removeIntervalConverter", "method_implementation": "{\n    checkAlterIntervalConverters();\n    if (converter == null) {\n        return null;\n    }\n    IntervalConverter[] removed = new IntervalConverter[1];\n    iIntervalConverters = iIntervalConverters.remove(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Removes a converter from the set of converters. If the converter was\n * not in the set, no changes are made.\n *\n * @param converter  the converter to remove, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 616, "method_signature": "IntervalConverter removeIntervalConverter(IntervalConverter)"}, "ConverterManager.removePartialConverter": {"callee_method_ids": [579], "callee_method_names": ["ConverterSet.remove"], "method_name": "ConverterManager.removePartialConverter", "method_implementation": "{\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Removes a converter from the set of converters. If the converter was\n * not in the set, no changes are made.\n *\n * @param converter  the converter to remove, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 601, "method_signature": "PartialConverter removePartialConverter(PartialConverter)"}, "ConverterManager.removePeriodConverter": {"callee_method_ids": [579], "callee_method_names": ["ConverterSet.remove"], "method_name": "ConverterManager.removePeriodConverter", "method_implementation": "{\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}", "repo_id": "7", "comment": "/**\n * Removes a converter from the set of converters. If the converter was\n * not in the set, no changes are made.\n *\n * @param converter  the converter to remove, null ignored\n * @return replaced converter, or null\n * @throws SecurityException if the security manager rejects the change\n */\n", "repo_name": "joda-time-main/", "id": 611, "method_signature": "PeriodConverter removePeriodConverter(PeriodConverter)"}, "ConverterManager.toString": {"callee_method_names": ["ConverterSet.size", "ConverterSet.size", "ConverterSet.size", "ConverterSet.size", "ConverterSet.size"], "method_name": "ConverterManager.toString", "method_implementation": "{\n    return \"ConverterManager[\" + iInstantConverters.size() + \" instant,\" + iPartialConverters.size() + \" partial,\" + iDurationConverters.size() + \" duration,\" + iPeriodConverters.size() + \" period,\" + iIntervalConverters.size() + \" interval]\";\n}", "repo_id": "7", "comment": "/**\n * Gets a debug representation of the object.\n */\n", "repo_name": "joda-time-main/", "id": 618, "method_signature": "String toString()"}, "ConverterSet.add": {"callee_method_names": ["Converter.equals", "Converter.getSupportedType", "Converter.getSupportedType"], "method_name": "ConverterSet.add", "method_implementation": "{\n    Converter[] converters = iConverters;\n    int length = converters.length;\n    for (int i = 0; i < length; i++) {\n        Converter existing = converters[i];\n        if (converter.equals(existing)) {\n            // Already in the set.\n            if (removed != null) {\n                removed[0] = null;\n            }\n            return this;\n        }\n        if (converter.getSupportedType() == existing.getSupportedType()) {\n            // Replace the converter.\n            Converter[] copy = new Converter[length];\n            for (int j = 0; j < length; j++) {\n                if (j != i) {\n                    copy[j] = converters[j];\n                } else {\n                    copy[j] = converter;\n                }\n            }\n            if (removed != null) {\n                removed[0] = existing;\n            }\n            return new ConverterSet(copy);\n        }\n    }\n    // Not found, so add it.\n    Converter[] copy = new Converter[length + 1];\n    System.arraycopy(converters, 0, copy, 0, length);\n    copy[length] = converter;\n    if (removed != null) {\n        removed[0] = null;\n    }\n    return new ConverterSet(copy);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this set, with the given converter added. If a\n * matching converter is already in the set, the given converter replaces\n * it. If the converter is exactly the same as one already in the set, the\n * original set is returned.\n *\n * @param converter  converter to add, must not be null\n * @param removed  if not null, element 0 is set to the removed converter\n * @throws NullPointerException if converter is null\n */\n", "repo_name": "joda-time-main/", "id": 577, "method_signature": "ConverterSet add(Converter, Converter[])"}, "ConverterSet.remove": {"callee_method_names": [], "method_name": "ConverterSet.remove", "method_implementation": "{\n    Converter[] converters = iConverters;\n    int length = converters.length;\n    if (index >= length) {\n        throw new IndexOutOfBoundsException();\n    }\n    if (removed != null) {\n        removed[0] = converters[index];\n    }\n    Converter[] copy = new Converter[length - 1];\n    int j = 0;\n    for (int i = 0; i < length; i++) {\n        if (i != index) {\n            copy[j++] = converters[i];\n        }\n    }\n    return new ConverterSet(copy);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this set, with the converter at the given index\n * removed.\n *\n * @param index index of converter to remove\n * @param removed if not null, element 0 is set to the removed converter\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "joda-time-main/", "id": 579, "method_signature": "ConverterSet remove(int, Converter[])"}, "ConverterSet.select": {"callee_method_names": ["Class<?>.hashCode", "Entry[].clone", "Class<?>.hashCode"], "method_name": "ConverterSet.select", "method_implementation": "{\n    // Check the hashtable first.\n    Entry[] entries = iSelectEntries;\n    int length = entries.length;\n    int index = type == null ? 0 : type.hashCode() & (length - 1);\n    Entry e;\n    // This loop depends on there being at least one null slot.\n    while ((e = entries[index]) != null) {\n        if (e.iType == type) {\n            return e.iConverter;\n        }\n        if (++index >= length) {\n            index = 0;\n        }\n    }\n    // Not found in the hashtable, so do actual work.\n    Converter converter = selectSlow(this, type);\n    e = new Entry(type, converter);\n    // Save the entry for future selects. This class must be threadsafe,\n    // but there is no synchronization. Since the hashtable is being used\n    // as a cache, it is okay to destroy existing entries. This isn't\n    // likely to occur unless there is a high amount of concurrency. As\n    // time goes on, cache updates will occur less often, and the cache\n    // will fill with all the necessary entries.\n    // Do all updates on a copy: slots in iSelectEntries must not be\n    // updated by multiple threads as this can allow all null slots to be\n    // consumed.\n    entries = (Entry[]) entries.clone();\n    // Add new entry.\n    entries[index] = e;\n    // Verify that at least one null slot exists!\n    for (int i = 0; i < length; i++) {\n        if (entries[i] == null) {\n            // Found a null slot, swap in new hashtable.\n            iSelectEntries = entries;\n            return converter;\n        }\n    }\n    // Double capacity and re-hash.\n    int newLength = length << 1;\n    Entry[] newEntries = new Entry[newLength];\n    for (int i = 0; i < length; i++) {\n        e = entries[i];\n        type = e.iType;\n        index = type == null ? 0 : type.hashCode() & (newLength - 1);\n        while (newEntries[index] != null) {\n            if (++index >= newLength) {\n                index = 0;\n            }\n        }\n        newEntries[index] = e;\n    }\n    // Swap in new hashtable.\n    iSelectEntries = newEntries;\n    return converter;\n}", "repo_id": "7", "comment": "/**\n * Returns the closest matching converter for the given type, or null if\n * none found.\n *\n * @param type type to select, which may be null\n * @throws IllegalStateException if multiple converters match the type\n * equally well\n */\n", "repo_name": "joda-time-main/", "id": 576, "method_signature": "Converter select(Class)"}, "ConverterSet.selectSlow": {"callee_method_ids": [579, 579], "callee_method_names": ["Converter.getSupportedType", "Class<?>.isAssignableFrom", "ConverterSet.remove", "Converter.getSupportedType", "Converter[].getSupportedType", "ConverterSet.remove", "StringBuilder.append", "StringBuilder.append", "Class<?>.getName", "StringBuilder.append", "Converter.getSupportedType", "StringBuilder.append", "Converter.getClass", "StringBuilder.append", "StringBuilder.append", "Class<?>.getName", "StringBuilder.append", "StringBuilder.toString"], "method_name": "ConverterSet.selectSlow", "method_implementation": "{\n    Converter[] converters = set.iConverters;\n    int length = converters.length;\n    Converter converter;\n    for (int i = length; --i >= 0; ) {\n        converter = converters[i];\n        Class<?> supportedType = converter.getSupportedType();\n        if (supportedType == type) {\n            // Exact match.\n            return converter;\n        }\n        if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {\n            // Eliminate the impossible.\n            set = set.remove(i, null);\n            converters = set.iConverters;\n            length = converters.length;\n        }\n    }\n    // Haven't found exact match, so check what remains in the set.\n    if (type == null || length == 0) {\n        return null;\n    }\n    if (length == 1) {\n        // Found the one best match.\n        return converters[0];\n    }\n    // At this point, there exist multiple potential converters.\n    // Eliminate supertypes.\n    for (int i = length; --i >= 0; ) {\n        converter = converters[i];\n        Class<?> supportedType = converter.getSupportedType();\n        for (int j = length; --j >= 0; ) {\n            if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {\n                // Eliminate supertype.\n                set = set.remove(j, null);\n                converters = set.iConverters;\n                length = converters.length;\n                i = length - 1;\n            }\n        }\n    }\n    // Check what remains in the set.\n    if (length == 1) {\n        // Found the one best match.\n        return converters[0];\n    }\n    // Class c implements a, b {}\n    // Converters exist only for a and b. Which is better? Neither.\n    StringBuilder msg = new StringBuilder();\n    msg.append(\"Unable to find best converter for type \\\"\");\n    msg.append(type.getName());\n    msg.append(\"\\\" from remaining set: \");\n    for (int i = 0; i < length; i++) {\n        converter = converters[i];\n        Class<?> supportedType = converter.getSupportedType();\n        msg.append(converter.getClass().getName());\n        msg.append('[');\n        msg.append(supportedType == null ? null : supportedType.getName());\n        msg.append(\"], \");\n    }\n    throw new IllegalStateException(msg.toString());\n}", "repo_id": "7", "comment": "/**\n * Returns the closest matching converter for the given type, but not very\n * efficiently.\n */\n", "repo_name": "joda-time-main/", "id": 580, "method_signature": "Converter selectSlow(ConverterSet, Class)"}, "CopticChronology.assemble": {"callee_method_names": ["Fields.getDurationField"], "method_name": "CopticChronology.assemble", "method_implementation": "{\n    if (getBase() == null) {\n        super.assemble(fields);\n        // Coptic, like Julian, has no year zero.\n        fields.year = new SkipDateTimeField(this, fields.year);\n        fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n        fields.era = ERA_FIELD;\n        fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13);\n        fields.months = fields.monthOfYear.getDurationField();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 365, "method_signature": "void assemble(Fields)"}, "CopticChronology.calculateFirstDayOfYearMillis": {"callee_method_names": [], "method_name": "CopticChronology.calculateFirstDayOfYearMillis", "method_implementation": "{\n    // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.\n    // Calculate relative to the nearest leap year and account for the\n    // difference later.\n    int relativeYear = year - 1687;\n    int leapYears;\n    if (relativeYear <= 0) {\n        // Add 3 before shifting right since /4 and >>2 behave differently\n        // on negative numbers.\n        leapYears = (relativeYear + 3) >> 2;\n    } else {\n        leapYears = relativeYear >> 2;\n        // For post 1687 an adjustment is needed as jan1st is before leap day\n        if (!isLeapYear(year)) {\n            leapYears++;\n        }\n    }\n    long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY;\n    // Adjust to account for difference between 1687-01-01 and 1686-04-23.\n    return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 364, "method_signature": "long calculateFirstDayOfYearMillis(int)"}, "CopticChronology.getInstance": {"callee_method_names": ["ConcurrentHashMap.get", "ConcurrentHashMap.putIfAbsent"], "method_name": "CopticChronology.getInstance", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    CopticChronology chrono;\n    CopticChronology[] chronos = cCache.get(zone);\n    if (chronos == null) {\n        chronos = new CopticChronology[7];\n        CopticChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\n        if (oldChronos != null) {\n            chronos = oldChronos;\n        }\n    }\n    try {\n        chrono = chronos[minDaysInFirstWeek - 1];\n    } catch (ArrayIndexOutOfBoundsException e) {\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\n    }\n    if (chrono == null) {\n        synchronized (chronos) {\n            chrono = chronos[minDaysInFirstWeek - 1];\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    // First create without a lower limit.\n                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);\n                    // Impose lower limit and make another CopticChronology.\n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n                    chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets an instance of the CopticChronology in the given time zone.\n *\n * @param zone  the time zone to get the chronology in, null is default\n * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n * @return a chronology in the specified time zone\n */\n", "repo_name": "joda-time-main/", "id": 361, "method_signature": "CopticChronology getInstance(DateTimeZone, int)"}, "CopticChronology.readResolve": {"callee_method_names": ["Chronology.getZone"], "method_name": "CopticChronology.readResolve", "method_implementation": "{\n    Chronology base = getBase();\n    int minDays = getMinimumDaysInFirstWeek();\n    // handle rename of BaseGJChronology\n    minDays = (minDays == 0 ? 4 : minDays);\n    return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays);\n}", "repo_id": "7", "comment": "/**\n * Serialization singleton.\n */\n", "repo_name": "joda-time-main/", "id": 362, "method_signature": "Object readResolve()"}, "CopticChronology.withZone": {"callee_method_names": [], "method_name": "CopticChronology.withZone", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    if (zone == getZone()) {\n        return this;\n    }\n    return getInstance(zone);\n}", "repo_id": "7", "comment": "/**\n * Gets the Chronology in a specific time zone.\n *\n * @param zone  the zone to get the chronology in, null is default\n * @return the chronology\n */\n", "repo_name": "joda-time-main/", "id": 363, "method_signature": "Chronology withZone(DateTimeZone)"}, "DateAction.actionPerformed": {"callee_method_names": ["JMenuItem.setEnabled"], "method_name": "DateAction.actionPerformed", "method_implementation": "{\n    TableView tView = new DateTableView(currFile);\n    resetDefaults(tView);\n    enableAllViews();\n    jmiDate.setEnabled(false);\n}", "repo_id": "7", "comment": "/*\n         * actionPerformed\n         */\n", "repo_name": "joda-time-main/", "id": 1112, "method_signature": "void actionPerformed(ActionEvent)"}, "DateConverter.getInstantMillis": {"callee_method_names": ["Date.getTime"], "method_name": "DateConverter.getInstantMillis", "method_implementation": "{\n    Date date = (Date) object;\n    return date.getTime();\n}", "repo_id": "7", "comment": "/**\n * Gets the millis, which is the Date millis value.\n *\n * @param object  the Date to convert, must not be null\n * @param chrono  the non-null result of getChronology\n * @return the millisecond value\n * @throws NullPointerException if the object is null\n * @throws ClassCastException if the object is an invalid type\n */\n", "repo_name": "joda-time-main/", "id": 575, "method_signature": "long getInstantMillis(Object, Chronology)"}, "DateMidnight.minusDays": {"callee_method_names": [], "method_name": "DateMidnight.minusDays", "method_implementation": "{\n    if (days == 0) {\n        return this;\n    }\n    long instant = getChronology().days().subtract(getMillis(), days);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date minus the specified number of days.\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateMidnight subtracted = dt.minusDays(6);\n * DateMidnight subtracted = dt.minus(Period.days(6));\n * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n * </pre>\n *\n * @param days  the amount of days to subtract, may be negative\n * @return the new datetime minus the increased days\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 267, "method_signature": "DateMidnight minusDays(int)"}, "DateMidnight.minusMonths": {"callee_method_names": [], "method_name": "DateMidnight.minusMonths", "method_implementation": "{\n    if (months == 0) {\n        return this;\n    }\n    long instant = getChronology().months().subtract(getMillis(), months);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date minus the specified number of months.\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateMidnight subtracted = dt.minusMonths(6);\n * DateMidnight subtracted = dt.minus(Period.months(6));\n * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n * </pre>\n *\n * @param months  the amount of months to subtract, may be negative\n * @return the new datetime minus the increased months\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 265, "method_signature": "DateMidnight minusMonths(int)"}, "DateMidnight.minusWeeks": {"callee_method_names": [], "method_name": "DateMidnight.minusWeeks", "method_implementation": "{\n    if (weeks == 0) {\n        return this;\n    }\n    long instant = getChronology().weeks().subtract(getMillis(), weeks);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date minus the specified number of weeks.\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateMidnight subtracted = dt.minusWeeks(6);\n * DateMidnight subtracted = dt.minus(Period.weeks(6));\n * DateMidnight subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n * </pre>\n *\n * @param weeks  the amount of weeks to subtract, may be negative\n * @return the new datetime minus the increased weeks\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 266, "method_signature": "DateMidnight minusWeeks(int)"}, "DateMidnight.minusYears": {"callee_method_names": [], "method_name": "DateMidnight.minusYears", "method_implementation": "{\n    if (years == 0) {\n        return this;\n    }\n    long instant = getChronology().years().subtract(getMillis(), years);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date minus the specified number of years.\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime subtracted = dt.minusYears(6);\n * DateTime subtracted = dt.minus(Period.years(6));\n * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n * </pre>\n *\n * @param years  the amount of years to subtract, may be negative\n * @return the new datetime minus the increased years\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 264, "method_signature": "DateMidnight minusYears(int)"}, "DateMidnight.now": {"callee_method_names": [], "method_name": "DateMidnight.now", "method_implementation": "{\n    if (chronology == null) {\n        throw new NullPointerException(\"Chronology must not be null\");\n    }\n    return new DateMidnight(chronology);\n}", "repo_id": "7", "comment": "/**\n * Obtains a {@code DateMidnight} set to the current system millisecond time\n * using the specified chronology.\n * The constructed object will have a local time of midnight.\n *\n * @param chronology  the chronology, not null\n * @return the current date, not null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 251, "method_signature": "DateMidnight now(Chronology)"}, "DateMidnight.plusDays": {"callee_method_names": [], "method_name": "DateMidnight.plusDays", "method_implementation": "{\n    if (days == 0) {\n        return this;\n    }\n    long instant = getChronology().days().add(getMillis(), days);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date plus the specified number of days.\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateMidnight added = dt.plusDays(6);\n * DateMidnight added = dt.plus(Period.days(6));\n * DateMidnight added = dt.withFieldAdded(DurationFieldType.days(), 6);\n * </pre>\n *\n * @param days  the amount of days to add, may be negative\n * @return the new datetime plus the increased days\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 263, "method_signature": "DateMidnight plusDays(int)"}, "DateMidnight.plusMonths": {"callee_method_names": [], "method_name": "DateMidnight.plusMonths", "method_implementation": "{\n    if (months == 0) {\n        return this;\n    }\n    long instant = getChronology().months().add(getMillis(), months);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date plus the specified number of months.\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateMidnight added = dt.plusMonths(6);\n * DateMidnight added = dt.plus(Period.months(6));\n * DateMidnight added = dt.withFieldAdded(DurationFieldType.months(), 6);\n * </pre>\n *\n * @param months  the amount of months to add, may be negative\n * @return the new datetime plus the increased months\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 261, "method_signature": "DateMidnight plusMonths(int)"}, "DateMidnight.plusWeeks": {"callee_method_names": [], "method_name": "DateMidnight.plusWeeks", "method_implementation": "{\n    if (weeks == 0) {\n        return this;\n    }\n    long instant = getChronology().weeks().add(getMillis(), weeks);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date plus the specified number of weeks.\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateMidnight added = dt.plusWeeks(6);\n * DateMidnight added = dt.plus(Period.weeks(6));\n * DateMidnight added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n * </pre>\n *\n * @param weeks  the amount of weeks to add, may be negative\n * @return the new datetime plus the increased weeks\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 262, "method_signature": "DateMidnight plusWeeks(int)"}, "DateMidnight.plusYears": {"callee_method_names": [], "method_name": "DateMidnight.plusYears", "method_implementation": "{\n    if (years == 0) {\n        return this;\n    }\n    long instant = getChronology().years().add(getMillis(), years);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date plus the specified number of years.\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateMidnight added = dt.plusYears(6);\n * DateMidnight added = dt.plus(Period.years(6));\n * DateMidnight added = dt.withFieldAdded(DurationFieldType.years(), 6);\n * </pre>\n *\n * @param years  the amount of years to add, may be negative\n * @return the new datetime plus the increased years\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 260, "method_signature": "DateMidnight plusYears(int)"}, "DateMidnight.property": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField", "DateTimeField.isSupported"], "method_name": "DateMidnight.property", "method_implementation": "{\n    if (type == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    DateTimeField field = type.getField(getChronology());\n    if (field.isSupported() == false) {\n        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n    }\n    return new Property(this, field);\n}", "repo_id": "7", "comment": "/**\n * Gets the property object for the specified type, which contains many useful methods.\n *\n * @param type  the field type to get the chronology for\n * @return the property object\n * @throws IllegalArgumentException if the field is null or unsupported\n */\n", "repo_name": "joda-time-main/", "id": 268, "method_signature": "Property property(DateTimeFieldType)"}, "DateMidnight.readObject": {"callee_method_ids": [70], "callee_method_names": ["ObjectInputStream.readObject", "ObjectInputStream.readObject", "DateTimeFieldType.getField", "DateMidnight.getChronology"], "method_name": "DateMidnight.readObject", "method_implementation": "{\n    iInstant = (DateMidnight) oos.readObject();\n    DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n    iField = type.getField(iInstant.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Reads the property from a safe serialization format.\n */\n", "repo_name": "joda-time-main/", "id": 270, "method_signature": "void readObject(ObjectInputStream)"}, "DateMidnight.toInterval": {"callee_method_names": [], "method_name": "DateMidnight.toInterval", "method_implementation": "{\n    Chronology chrono = getChronology();\n    long start = getMillis();\n    long end = DurationFieldType.days().getField(chrono).add(start, 1);\n    return new Interval(start, end, chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this object to an <code>Interval</code> encompassing\n * the whole of this day.\n * <p>\n * The interval starts at midnight 00:00 and ends at 00:00 the following day,\n * (which is not included in the interval, as intervals are half-open).\n *\n * @return an interval over the day\n */\n", "repo_name": "joda-time-main/", "id": 269, "method_signature": "Interval toInterval()"}, "DateMidnight.withDurationAdded": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "DateMidnight.withDurationAdded", "method_implementation": "{\n    if (durationToAdd == null || scalar == 0) {\n        return this;\n    }\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the specified duration added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n *\n * @param durationToAdd  the duration to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this datetime with the duration added\n * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 258, "method_signature": "DateMidnight withDurationAdded(ReadableDuration, int)"}, "DateMidnight.withField": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "DateMidnight.withField", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the specified field set to a new value.\n * <p>\n * For example, if the field type is <code>dayOfMonth</code> then the day of month\n * field would be changed in the returned instance.\n * If the field type is null, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n * DateTime updated = dt.dayOfMonth().setCopy(6);\n * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this datetime with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 255, "method_signature": "DateMidnight withField(DateTimeFieldType, int)"}, "DateMidnight.withFieldAdded": {"callee_method_names": ["DurationFieldType.getField"], "method_name": "DateMidnight.withFieldAdded", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (amount == 0) {\n        return this;\n    }\n    long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the value of the specified field increased.\n * <p>\n * If the addition is zero or the field is null, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * DateMidnight added = dt.withFieldAdded(DateTimeFieldType.year(), 6);\n * DateMidnight added = dt.plusYears(6);\n * DateMidnight added = dt.year().addToCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this datetime with the field updated\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 256, "method_signature": "DateMidnight withFieldAdded(DurationFieldType, int)"}, "DateMidnight.withFields": {"callee_method_names": [], "method_name": "DateMidnight.withFields", "method_implementation": "{\n    if (partial == null) {\n        return this;\n    }\n    return withMillis(getChronology().set(partial, getMillis()));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the partial set of fields replacing those\n * from this instance.\n * <p>\n * For example, if the partial is a <code>LocalDate</code> then the date fields\n * would be changed in the returned instance.\n * If the partial is null, then <code>this</code> is returned.\n *\n * @param partial  the partial set of fields to apply to this datetime, null ignored\n * @return a copy of this datetime with a different set of fields\n * @throws IllegalArgumentException if any value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 254, "method_signature": "DateMidnight withFields(ReadablePartial)"}, "DateMidnight.withMillis": {"callee_method_names": [], "method_name": "DateMidnight.withMillis", "method_implementation": "{\n    Chronology chrono = getChronology();\n    newMillis = checkInstant(newMillis, chrono);\n    return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with a different millisecond instant.\n * The returned object will have a local time of midnight.\n * <p>\n * Only the millis will change, the chronology and time zone are kept.\n * The returned object will be either be a new instance or <code>this</code>.\n *\n * @param newMillis  the new millis, from 1970-01-01T00:00:00Z\n * @return a copy of this instant with different millis\n */\n", "repo_name": "joda-time-main/", "id": 252, "method_signature": "DateMidnight withMillis(long)"}, "DateMidnight.withPeriodAdded": {"callee_method_names": [], "method_name": "DateMidnight.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    long instant = getChronology().add(period, getMillis(), scalar);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the specified period added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using methods\n * like {@link #withFieldAdded(DurationFieldType, int)}\n * or {@link #plusYears(int)}.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this datetime with the period added\n * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 259, "method_signature": "DateMidnight withPeriodAdded(ReadablePeriod, int)"}, "DateMidnight.withZoneRetainFields": {"callee_method_ids": [119], "callee_method_names": ["DateTimeZone.getMillisKeepLocal"], "method_name": "DateMidnight.withZoneRetainFields", "method_implementation": "{\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return this;\n    }\n    long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n    return new DateMidnight(millis, getChronology().withZone(newZone));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with a different time zone, preserving the day\n * The returned object will have a local time of midnight in the new zone on\n * the same day as the original instant.\n *\n * @param newZone  the new time zone, null means default\n * @return a copy of this instant with a different time zone\n */\n", "repo_name": "joda-time-main/", "id": 253, "method_signature": "DateMidnight withZoneRetainFields(DateTimeZone)"}, "DateTableView.genCalcdValues": {"callee_method_names": ["LoadedFile.getFileStrings", "LoadedFile.getDtObjects", "ArrayList.size", "ArrayList.size", "ArrayList.get", "ArrayList.get", "DateTime.toString", "DateTime.getMillis", "java.util.Date.getSeconds", "java.util.Date.getMinutes", "java.util.Date.getHours", "java.util.Date.getDay", "java.util.Date.getDate", "java.util.Date.getMonth", "java.util.Date.getYear"], "method_name": "DateTableView.genCalcdValues", "method_implementation": "{\n    Object[][] retValues = null;\n    /*\n             * Create an array of Objects that will contain\n             * other arrays of Objects. (This is the 'column'\n             * array).\n             */\n    ArrayList fileStrings = lddFile.getFileStrings();\n    ArrayList dtObjects = lddFile.getDtObjects();\n    int numRows = fileStrings.size();\n    retValues = new Object[numRows][];\n    int numCols = colNames.length;\n    // System.err.println(\"NumCols : \" + numCols);\n    /*\n             * Prime the array of arrays of Objects, allocating a new\n             * secondary array for each of the primary array's\n             * elements.\n             */\n    for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++nextStrNum) {\n        // get the 'col' array\n        retValues[nextStrNum] = new Object[numCols];\n        //****\n        //* This needs to be sync'd with the colNames array.\n        //****\n        // Current row, 1st column\n        int column = 0;\n        String fileString = (String) fileStrings.get(nextStrNum);\n        retValues[nextStrNum][column++] = fileString;\n        // Current row, 2nd column\n        DateTime adt = (DateTime) dtObjects.get(nextStrNum);\n        String adtStr = adt.toString();\n        retValues[nextStrNum][column++] = adtStr;\n        // Current row, other columns.\n        // Order here must match that specified in the colNames\n        // array.\n        long lVal = adt.getMillis();\n        java.util.Date jDate = new java.util.Date(lVal);\n        retValues[nextStrNum][column++] = new Integer(jDate.getSeconds());\n        retValues[nextStrNum][column++] = new Integer(jDate.getMinutes());\n        retValues[nextStrNum][column++] = new Integer(jDate.getHours());\n        retValues[nextStrNum][column++] = new Integer(jDate.getDay());\n        retValues[nextStrNum][column++] = new Integer(jDate.getDate());\n        retValues[nextStrNum][column++] = new Integer(jDate.getMonth());\n        retValues[nextStrNum][column++] = new Integer(jDate.getYear());\n        //\n    }\n    // the for\n    if (debugf)\n        dumpObjs(retValues, System.err);\n    return retValues;\n}", "repo_id": "7", "comment": "/*\n         * genCalcdValues is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1100, "method_signature": "Object[][] genCalcdValues()"}, "DateTableView.genColNames": {"callee_method_names": [], "method_name": "DateTableView.genColNames", "method_implementation": "{\n    Object[] retVal = { // 0\n    \"FileString\", // 1\n    \"toString()\", // 2\n    \"Seconds\", // 3\n    \"Minutes\", // 4\n    \"Hours\", // 5\n    \"Day Of Week\", // 6\n    \"Day Of Month\", // 7\n    \"Month\", // 8\n    \"Year\" };\n    return retVal;\n}", "repo_id": "7", "comment": "/*\n         * genColNames is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1101, "method_signature": "Object[] genColNames()"}, "DateTableView.getViewTitle": {"callee_method_names": ["LoadedFile.getLoadedFileSize"], "method_name": "DateTableView.getViewTitle", "method_implementation": "{\n    return \"java.util.Date getXXX\" + \" : \" + TimeZone.getDefault().getDisplayName() + \" : \" + \" Record Count \" + currFile.getLoadedFileSize();\n}", "repo_id": "7", "comment": "/*\n         * getViewTitle\n         */\n", "repo_name": "joda-time-main/", "id": 1102, "method_signature": "String getViewTitle()"}, "DateTableView.setViewColumnsWidth": {"callee_method_names": ["JTable.getColumnModel", "TableColumnModel.getColumn", "TableColumn.setPreferredWidth", "TableColumnModel.getColumn", "TableColumn.setPreferredWidth"], "method_name": "DateTableView.setViewColumnsWidth", "method_implementation": "{\n    /*\n             * Resize column 0, 1\n             */\n    TableColumnModel colmodel = jt.getColumnModel();\n    TableColumn col0 = colmodel.getColumn(0);\n    col0.setPreferredWidth(150);\n    TableColumn col1 = colmodel.getColumn(1);\n    col1.setPreferredWidth(150);\n    return;\n}", "repo_id": "7", "comment": "/*\n         * setViewColumnLengths\n         */\n", "repo_name": "joda-time-main/", "id": 1103, "method_signature": "void setViewColumnsWidth(JTable)"}, "DateTime.minusDays": {"callee_method_names": [], "method_name": "DateTime.minusDays", "method_implementation": "{\n    if (days == 0) {\n        return this;\n    }\n    long instant = getChronology().days().subtract(getMillis(), days);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of days.\n * <p>\n * The calculation will do its best to only change the day field\n * retaining the same time of day.\n * However, in certain circumstances, typically daylight savings cutover,\n * it may be necessary to alter the time fields.\n * <p>\n * In spring an hour is typically removed. If subtracting one day results\n * in the time being within the cutover then the time is adjusted to be\n * within summer time. For example, if the cutover is from 01:59 to 03:00\n * and the result of this method would have been 02:30, then the result\n * will be adjusted to 03:30.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime subtracted = dt.minusDays(6);\n * DateTime subtracted = dt.minus(Period.days(6));\n * DateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param days  the amount of days to subtract, may be negative\n * @return the new datetime minus the increased days\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 450, "method_signature": "DateTime minusDays(int)"}, "DateTime.minusHours": {"callee_method_names": [], "method_name": "DateTime.minusHours", "method_implementation": "{\n    if (hours == 0) {\n        return this;\n    }\n    long instant = getChronology().hours().subtract(getMillis(), hours);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of hours.\n * <p>\n * The calculation will subtract a duration equivalent to the number of\n * hours expressed in milliseconds.\n * <p>\n * For example, if a spring daylight savings cutover is from 01:59 to 03:00\n * then subtracting one hour from 03:30 will result in 01:30. This is a\n * duration of one hour earlier, even though the hour field value changed\n * from 3 to 1.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime subtracted = dt.minusHours(6);\n * DateTime subtracted = dt.minus(Period.hours(6));\n * DateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param hours  the amount of hours to subtract, may be negative\n * @return the new datetime minus the increased hours\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 451, "method_signature": "DateTime minusHours(int)"}, "DateTime.minusMillis": {"callee_method_names": [], "method_name": "DateTime.minusMillis", "method_implementation": "{\n    if (millis == 0) {\n        return this;\n    }\n    long instant = getChronology().millis().subtract(getMillis(), millis);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of millis.\n * <p>\n * The calculation will subtract a duration equivalent to the number of\n * milliseconds.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime subtracted = dt.minusMillis(6);\n * DateTime subtracted = dt.minus(Period.millis(6));\n * DateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param millis  the amount of millis to subtract, may be negative\n * @return the new datetime minus the increased millis\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 454, "method_signature": "DateTime minusMillis(int)"}, "DateTime.minusMinutes": {"callee_method_names": [], "method_name": "DateTime.minusMinutes", "method_implementation": "{\n    if (minutes == 0) {\n        return this;\n    }\n    long instant = getChronology().minutes().subtract(getMillis(), minutes);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of minutes.\n * <p>\n * The calculation will subtract a duration equivalent to the number of\n * minutes expressed in milliseconds.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime subtracted = dt.minusMinutes(6);\n * DateTime subtracted = dt.minus(Period.minutes(6));\n * DateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param minutes  the amount of minutes to subtract, may be negative\n * @return the new datetime minus the increased minutes\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 452, "method_signature": "DateTime minusMinutes(int)"}, "DateTime.minusMonths": {"callee_method_names": [], "method_name": "DateTime.minusMonths", "method_implementation": "{\n    if (months == 0) {\n        return this;\n    }\n    long instant = getChronology().months().subtract(getMillis(), months);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of months.\n * <p>\n * The calculation will do its best to only change the month field\n * retaining the same day of month.\n * However, in certain circumstances, it may be necessary to alter\n * smaller fields. For example, 2007-05-31 minus one month cannot result\n * in 2007-04-31, so the day of month is adjusted to 2007-04-30.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime subtracted = dt.minusMonths(6);\n * DateTime subtracted = dt.minus(Period.months(6));\n * DateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param months  the amount of months to subtract, may be negative\n * @return the new datetime minus the increased months\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 448, "method_signature": "DateTime minusMonths(int)"}, "DateTime.minusSeconds": {"callee_method_names": [], "method_name": "DateTime.minusSeconds", "method_implementation": "{\n    if (seconds == 0) {\n        return this;\n    }\n    long instant = getChronology().seconds().subtract(getMillis(), seconds);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of seconds.\n * <p>\n * The calculation will subtract a duration equivalent to the number of\n * seconds expressed in milliseconds.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime subtracted = dt.minusSeconds(6);\n * DateTime subtracted = dt.minus(Period.seconds(6));\n * DateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param seconds  the amount of seconds to subtract, may be negative\n * @return the new datetime minus the increased seconds\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 453, "method_signature": "DateTime minusSeconds(int)"}, "DateTime.minusWeeks": {"callee_method_names": [], "method_name": "DateTime.minusWeeks", "method_implementation": "{\n    if (weeks == 0) {\n        return this;\n    }\n    long instant = getChronology().weeks().subtract(getMillis(), weeks);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of weeks.\n * <p>\n * The calculation operates as if it were subtracting the equivalent in days.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime subtracted = dt.minusWeeks(6);\n * DateTime subtracted = dt.minus(Period.weeks(6));\n * DateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param weeks  the amount of weeks to subtract, may be negative\n * @return the new datetime minus the increased weeks\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 449, "method_signature": "DateTime minusWeeks(int)"}, "DateTime.minusYears": {"callee_method_names": [], "method_name": "DateTime.minusYears", "method_implementation": "{\n    if (years == 0) {\n        return this;\n    }\n    long instant = getChronology().years().subtract(getMillis(), years);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of years.\n * <p>\n * The calculation will do its best to only change the year field\n * retaining the same month of year.\n * However, in certain circumstances, it may be necessary to alter\n * smaller fields. For example, 2008-02-29 minus one year cannot result\n * in 2007-02-29, so the day of month is adjusted to 2007-02-28.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime subtracted = dt.minusYears(6);\n * DateTime subtracted = dt.minus(Period.years(6));\n * DateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param years  the amount of years to subtract, may be negative\n * @return the new datetime minus the increased years\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 447, "method_signature": "DateTime minusYears(int)"}, "DateTime.now": {"callee_method_names": [], "method_name": "DateTime.now", "method_implementation": "{\n    if (chronology == null) {\n        throw new NullPointerException(\"Chronology must not be null\");\n    }\n    return new DateTime(chronology);\n}", "repo_id": "7", "comment": "/**\n * Obtains a {@code DateTime} set to the current system millisecond time\n * using the specified chronology.\n *\n * @param chronology  the chronology, not null\n * @return the current date-time, not null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 426, "method_signature": "DateTime now(Chronology)"}, "DateTime.plusDays": {"callee_method_names": [], "method_name": "DateTime.plusDays", "method_implementation": "{\n    if (days == 0) {\n        return this;\n    }\n    long instant = getChronology().days().add(getMillis(), days);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of days.\n * <p>\n * The calculation will do its best to only change the day field\n * retaining the same time of day.\n * However, in certain circumstances, typically daylight savings cutover,\n * it may be necessary to alter the time fields.\n * <p>\n * In spring an hour is typically removed. If adding one day results in\n * the time being within the cutover then the time is adjusted to be\n * within summer time. For example, if the cutover is from 01:59 to 03:00\n * and the result of this method would have been 02:30, then the result\n * will be adjusted to 03:30.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime added = dt.plusDays(6);\n * DateTime added = dt.plus(Period.days(6));\n * DateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param days  the amount of days to add, may be negative\n * @return the new datetime plus the increased days\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 442, "method_signature": "DateTime plusDays(int)"}, "DateTime.plusHours": {"callee_method_names": [], "method_name": "DateTime.plusHours", "method_implementation": "{\n    if (hours == 0) {\n        return this;\n    }\n    long instant = getChronology().hours().add(getMillis(), hours);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of hours.\n * <p>\n * The calculation will add a duration equivalent to the number of hours\n * expressed in milliseconds.\n * <p>\n * For example, if a spring daylight savings cutover is from 01:59 to 03:00\n * then adding one hour to 01:30 will result in 03:30. This is a duration\n * of one hour later, even though the hour field value changed from 1 to 3.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime added = dt.plusHours(6);\n * DateTime added = dt.plus(Period.hours(6));\n * DateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param hours  the amount of hours to add, may be negative\n * @return the new datetime plus the increased hours\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 443, "method_signature": "DateTime plusHours(int)"}, "DateTime.plusMillis": {"callee_method_names": [], "method_name": "DateTime.plusMillis", "method_implementation": "{\n    if (millis == 0) {\n        return this;\n    }\n    long instant = getChronology().millis().add(getMillis(), millis);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of millis.\n * <p>\n * The calculation will add a duration equivalent to the number of milliseconds.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime added = dt.plusMillis(6);\n * DateTime added = dt.plus(Period.millis(6));\n * DateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param millis  the amount of millis to add, may be negative\n * @return the new datetime plus the increased millis\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 446, "method_signature": "DateTime plusMillis(int)"}, "DateTime.plusMinutes": {"callee_method_names": [], "method_name": "DateTime.plusMinutes", "method_implementation": "{\n    if (minutes == 0) {\n        return this;\n    }\n    long instant = getChronology().minutes().add(getMillis(), minutes);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of minutes.\n * <p>\n * The calculation will add a duration equivalent to the number of minutes\n * expressed in milliseconds.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime added = dt.plusMinutes(6);\n * DateTime added = dt.plus(Period.minutes(6));\n * DateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param minutes  the amount of minutes to add, may be negative\n * @return the new datetime plus the increased minutes\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 444, "method_signature": "DateTime plusMinutes(int)"}, "DateTime.plusMonths": {"callee_method_names": [], "method_name": "DateTime.plusMonths", "method_implementation": "{\n    if (months == 0) {\n        return this;\n    }\n    long instant = getChronology().months().add(getMillis(), months);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of months.\n * <p>\n * The calculation will do its best to only change the month field\n * retaining the same day of month.\n * However, in certain circumstances, it may be necessary to alter\n * smaller fields. For example, 2007-03-31 plus one month cannot result\n * in 2007-04-31, so the day of month is adjusted to 2007-04-30.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime added = dt.plusMonths(6);\n * DateTime added = dt.plus(Period.months(6));\n * DateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param months  the amount of months to add, may be negative\n * @return the new datetime plus the increased months\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 440, "method_signature": "DateTime plusMonths(int)"}, "DateTime.plusSeconds": {"callee_method_names": [], "method_name": "DateTime.plusSeconds", "method_implementation": "{\n    if (seconds == 0) {\n        return this;\n    }\n    long instant = getChronology().seconds().add(getMillis(), seconds);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of seconds.\n * <p>\n * The calculation will add a duration equivalent to the number of seconds\n * expressed in milliseconds.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime added = dt.plusSeconds(6);\n * DateTime added = dt.plus(Period.seconds(6));\n * DateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param seconds  the amount of seconds to add, may be negative\n * @return the new datetime plus the increased seconds\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 445, "method_signature": "DateTime plusSeconds(int)"}, "DateTime.plusWeeks": {"callee_method_names": [], "method_name": "DateTime.plusWeeks", "method_implementation": "{\n    if (weeks == 0) {\n        return this;\n    }\n    long instant = getChronology().weeks().add(getMillis(), weeks);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of weeks.\n * <p>\n * The calculation operates as if it were adding the equivalent in days.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime added = dt.plusWeeks(6);\n * DateTime added = dt.plus(Period.weeks(6));\n * DateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param weeks  the amount of weeks to add, may be negative\n * @return the new datetime plus the increased weeks\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 441, "method_signature": "DateTime plusWeeks(int)"}, "DateTime.plusYears": {"callee_method_names": [], "method_name": "DateTime.plusYears", "method_implementation": "{\n    if (years == 0) {\n        return this;\n    }\n    long instant = getChronology().years().add(getMillis(), years);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of years.\n * <p>\n * The calculation will do its best to only change the year field\n * retaining the same month of year.\n * However, in certain circumstances, it may be necessary to alter\n * smaller fields. For example, 2008-02-29 plus one year cannot result\n * in 2009-02-29, so the day of month is adjusted to 2009-02-28.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * DateTime added = dt.plusYears(6);\n * DateTime added = dt.plus(Period.years(6));\n * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n * </pre>\n * <p>\n * This datetime instance is immutable and unaffected by this method call.\n *\n * @param years  the amount of years to add, may be negative\n * @return the new datetime plus the increased years\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 439, "method_signature": "DateTime plusYears(int)"}, "DateTime.property": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField", "DateTimeField.isSupported"], "method_name": "DateTime.property", "method_implementation": "{\n    if (type == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    DateTimeField field = type.getField(getChronology());\n    if (field.isSupported() == false) {\n        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n    }\n    return new Property(this, field);\n}", "repo_id": "7", "comment": "/**\n * Gets the property object for the specified type, which contains many useful methods.\n *\n * @param type  the field type to get the chronology for\n * @return the property object\n * @throws IllegalArgumentException if the field is null or unsupported\n */\n", "repo_name": "joda-time-main/", "id": 455, "method_signature": "Property property(DateTimeFieldType)"}, "DateTime.readObject": {"callee_method_ids": [70], "callee_method_names": ["ObjectInputStream.readObject", "ObjectInputStream.readObject", "DateTimeFieldType.getField", "DateTime.getChronology"], "method_name": "DateTime.readObject", "method_implementation": "{\n    iInstant = (DateTime) oos.readObject();\n    DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n    iField = type.getField(iInstant.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Reads the property from a safe serialization format.\n */\n", "repo_name": "joda-time-main/", "id": 456, "method_signature": "void readObject(ObjectInputStream)"}, "DateTime.toDateTime": {"callee_method_names": [], "method_name": "DateTime.toDateTime", "method_implementation": "{\n    chronology = DateTimeUtils.getChronology(chronology);\n    if (getChronology() == chronology) {\n        return this;\n    }\n    return super.toDateTime(chronology);\n}", "repo_id": "7", "comment": "/**\n * Get this object as a DateTime, returning <code>this</code> if possible.\n *\n * @param chronology chronology to apply, or ISOChronology if null\n * @return a DateTime using the same millis\n */\n", "repo_name": "joda-time-main/", "id": 429, "method_signature": "DateTime toDateTime(Chronology)"}, "DateTime.toDateTimeISO": {"callee_method_names": [], "method_name": "DateTime.toDateTimeISO", "method_implementation": "{\n    if (getChronology() == ISOChronology.getInstance()) {\n        return this;\n    }\n    return super.toDateTimeISO();\n}", "repo_id": "7", "comment": "/**\n * Get this object as a DateTime using ISOChronology in the default zone,\n * returning <code>this</code> if possible.\n *\n * @return a DateTime using the same millis\n */\n", "repo_name": "joda-time-main/", "id": 427, "method_signature": "DateTime toDateTimeISO()"}, "DateTime.withDate": {"callee_method_names": ["Chronology.withUTC", "Chronology.getZone"], "method_name": "DateTime.withDate", "method_implementation": "{\n    Chronology chrono = getChronology();\n    long localInstant = chrono.withUTC().getDateTimeMillis(year, monthOfYear, dayOfMonth, getMillisOfDay());\n    return withMillis(chrono.getZone().convertLocalToUTC(localInstant, false, getMillis()));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified date, retaining the time fields.\n * <p>\n * If the date is already the date passed in, then <code>this</code> is returned.\n * <p>\n * To set a single field use the properties, for example:\n * <pre>\n * DateTime set = monthOfYear().setCopy(6);\n * </pre>\n * <p>\n * If the time is invalid on the new date due to the time-zone, the time will be adjusted.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param year  the new year value\n * @param monthOfYear  the new monthOfYear value\n * @param dayOfMonth  the new dayOfMonth value\n * @return a copy of this datetime with a different date\n * @throws IllegalArgumentException if any value if invalid\n */\n", "repo_name": "joda-time-main/", "id": 431, "method_signature": "DateTime withDate(int, int, int)"}, "DateTime.withDurationAdded": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "DateTime.withDurationAdded", "method_implementation": "{\n    if (durationToAdd == null || scalar == 0) {\n        return this;\n    }\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified duration added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n *\n * @param durationToAdd  the duration to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this datetime with the duration added\n * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 437, "method_signature": "DateTime withDurationAdded(ReadableDuration, int)"}, "DateTime.withField": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "DateTime.withField", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    long instant = fieldType.getField(getChronology()).set(getMillis(), value);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified field set to a new value.\n * <p>\n * For example, if the field type is <code>hourOfDay</code> then the hour of day\n * field would be changed in the returned instance.\n * If the field type is null, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * DateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n * DateTime updated = dt.dayOfMonth().setCopy(6);\n * DateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this datetime with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 434, "method_signature": "DateTime withField(DateTimeFieldType, int)"}, "DateTime.withFieldAdded": {"callee_method_names": ["DurationFieldType.getField"], "method_name": "DateTime.withFieldAdded", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (amount == 0) {\n        return this;\n    }\n    long instant = fieldType.getField(getChronology()).add(getMillis(), amount);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the value of the specified field increased.\n * <p>\n * If the addition is zero or the field is null, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * DateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n * DateTime added = dt.plusYears(6);\n * DateTime added = dt.plus(Period.years(6));\n * </pre>\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this datetime with the field updated\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 435, "method_signature": "DateTime withFieldAdded(DurationFieldType, int)"}, "DateTime.withFields": {"callee_method_names": [], "method_name": "DateTime.withFields", "method_implementation": "{\n    if (partial == null) {\n        return this;\n    }\n    return withMillis(getChronology().set(partial, getMillis()));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the partial set of fields replacing those\n * from this instance.\n * <p>\n * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n * would be changed in the returned instance.\n * If the partial is null, then <code>this</code> is returned.\n *\n * @param partial  the partial set of fields to apply to this datetime, null ignored\n * @return a copy of this datetime with a different set of fields\n * @throws IllegalArgumentException if any value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 433, "method_signature": "DateTime withFields(ReadablePartial)"}, "DateTime.withMaximumValue": {"callee_method_names": [], "method_name": "DateTime.withMaximumValue", "method_implementation": "{\n    try {\n        return setCopy(getMaximumValue());\n    } catch (RuntimeException ex) {\n        if (IllegalInstantException.isIllegalInstant(ex)) {\n            // adding MILLIS_PER_DAY is not perfect, but will work in almost all situations\n            long beforeGap = getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY);\n            return new DateTime(beforeGap, getChronology());\n        }\n        throw ex;\n    }\n}", "repo_id": "7", "comment": "/**\n * Returns a new DateTime with this field set to the maximum value\n * for this field.\n * <p>\n * This operation is useful for obtaining a DateTime on the last day\n * of the month, as month lengths vary.\n * <pre>\n * DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n * </pre>\n * <p>\n * Where possible, the offset from UTC will be retained, thus applications\n * may need to call {@link DateTime#withLaterOffsetAtOverlap()} on the result\n * to force the later time during a DST overlap if desired.\n * <p>\n * From v2.2, this method handles a daylight savings time gap, setting the\n * time to the last instant before the gap.\n * <p>\n * The DateTime attached to this property is unchanged by this call.\n *\n * @return a copy of the DateTime with this field set to its maximum\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 457, "method_signature": "DateTime withMaximumValue()"}, "DateTime.withMinimumValue": {"callee_method_names": [], "method_name": "DateTime.withMinimumValue", "method_implementation": "{\n    try {\n        return setCopy(getMinimumValue());\n    } catch (RuntimeException ex) {\n        if (IllegalInstantException.isIllegalInstant(ex)) {\n            // subtracting MILLIS_PER_DAY is not perfect, but will work in almost all situations\n            long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY);\n            return new DateTime(afterGap, getChronology());\n        }\n        throw ex;\n    }\n}", "repo_id": "7", "comment": "/**\n * Returns a new DateTime with this field set to the minimum value\n * for this field.\n * <p>\n * Where possible, the offset from UTC will be retained, thus applications\n * may need to call {@link DateTime#withEarlierOffsetAtOverlap()} on the result\n * to force the earlier time during a DST overlap if desired.\n * <p>\n * From v2.2, this method handles a daylight savings time gap, setting the\n * time to the first instant after the gap.\n * <p>\n * The DateTime attached to this property is unchanged by this call.\n *\n * @return a copy of the DateTime with this field set to its minimum\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 458, "method_signature": "DateTime withMinimumValue()"}, "DateTime.withPeriodAdded": {"callee_method_names": [], "method_name": "DateTime.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    long instant = getChronology().add(period, getMillis(), scalar);\n    return withMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified period added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using methods\n * like {@link #withFieldAdded(DurationFieldType, int)}\n * or {@link #plusYears(int)}.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this datetime with the period added\n * @throws ArithmeticException if the new datetime exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 438, "method_signature": "DateTime withPeriodAdded(ReadablePeriod, int)"}, "DateTime.withTime": {"callee_method_names": ["Chronology.withUTC", "Chronology.getZone"], "method_name": "DateTime.withTime", "method_implementation": "{\n    Chronology chrono = getChronology();\n    long localInstant = chrono.withUTC().getDateTimeMillis(getYear(), getMonthOfYear(), getDayOfMonth(), hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    return withMillis(chrono.getZone().convertLocalToUTC(localInstant, false, getMillis()));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified time, retaining the date fields.\n * <p>\n * If the time is already the time passed in, then <code>this</code> is returned.\n * <p>\n * To set a single field use the properties, for example:\n * <pre>\n * DateTime set = dt.hourOfDay().setCopy(6);\n * </pre>\n * <p>\n * If the new time is invalid due to the time-zone, the time will be adjusted.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param hourOfDay  the hour of the day\n * @param minuteOfHour  the minute of the hour\n * @param secondOfMinute  the second of the minute\n * @param millisOfSecond  the millisecond of the second\n * @return a copy of this datetime with a different time\n * @throws IllegalArgumentException if any value if invalid\n */\n", "repo_name": "joda-time-main/", "id": 432, "method_signature": "DateTime withTime(int, int, int, int)"}, "DateTime.withZoneRetainFields": {"callee_method_ids": [119], "callee_method_names": ["DateTimeZone.getMillisKeepLocal"], "method_name": "DateTime.withZoneRetainFields", "method_implementation": "{\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return this;\n    }\n    long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n    return new DateTime(millis, getChronology().withZone(newZone));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with a different time zone, preserving the\n * field values.\n * <p>\n * This method is useful for finding the millisecond time in another timezone.\n * For example, if this instant holds 12:30 in Europe/London (ie. 12:30Z),\n * the result from this method with Europe/Paris would be 12:30 (ie. 11:30Z).\n * <p>\n * The returned object will be a new instance of the same implementation type.\n * This method changes the time zone and the millisecond instant to keep\n * the field values the same.\n * The returned object will be either be a new instance or <code>this</code>.\n *\n * @param newZone  the new time zone, null means default\n * @return a copy of this datetime with a different time zone\n * @see #withZone\n */\n", "repo_name": "joda-time-main/", "id": 430, "method_signature": "DateTime withZoneRetainFields(DateTimeZone)"}, "DateTimeBrowser.LPad": {"callee_method_names": ["String.length", "String.toUpperCase", "String.substring", "String.length", "String.toUpperCase"], "method_name": "DateTimeBrowser.LPad", "method_implementation": "{\n    if (inStr.length() >= maxLen)\n        return inStr.toUpperCase();\n    String zeroes = PADCHARS.substring(0, maxLen - inStr.length());\n    String retVal = zeroes + inStr;\n    return retVal.toUpperCase();\n}", "repo_id": "7", "comment": "/*\n     * LPad Return a String, left padded with '0's as specified\n     * by the caller.\n     */\n", "repo_name": "joda-time-main/", "id": 1068, "method_signature": "String LPad(String, int)"}, "DateTimeBrowser.actionPerformed": {"callee_method_names": ["JMenuItem.setEnabled"], "method_name": "DateTimeBrowser.actionPerformed", "method_implementation": "{\n    TableView tView = new CalTableView(currFile);\n    resetDefaults(tView);\n    enableAllViews();\n    jmiCal.setEnabled(false);\n}", "repo_id": "7", "comment": "/*\n         * actionPerformed\n         */\n", "repo_name": "joda-time-main/", "id": 1091, "method_signature": "void actionPerformed(ActionEvent)"}, "DateTimeBrowser.addMenus": {"callee_method_names": ["JMenuBar.add", "JMenuBar.add", "Action.setEnabled", "Action.setEnabled", "Action.setEnabled", "Action.setEnabled", "JMenu.add", "JMenu.addSeparator", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.add", "JMenu.add"], "method_name": "DateTimeBrowser.addMenus", "method_implementation": "{\n    //\n    // Create all the menus.\n    //\n    JMenu fileMenu = new JMenu(\"File\");\n    JMenu viewMenu = new JMenu(\"View\");\n    //\n    // Add them to the menubar in order.\n    //\n    menuBar.add(fileMenu);\n    menuBar.add(viewMenu);\n    //\n    // Create action objects and menu items.\n    //\n    Action open = new OpenAction();\n    JMenuItem jmiOpen = new JMenuItem(open);\n    Action exit = new ExitAction();\n    JMenuItem jmiExit = new JMenuItem(exit);\n    //\n    // Next Menu\n    //\n    Action getter = new GetterAction();\n    jmiGetter = new JMenuItem(getter);\n    getter.setEnabled(true);\n    //\n    Action hex = new HexAction();\n    jmiHex = new JMenuItem(hex);\n    hex.setEnabled(true);\n    //\n    Action date = new DateAction();\n    jmiDate = new JMenuItem(date);\n    date.setEnabled(true);\n    //\n    Action cal = new CalAction();\n    jmiCal = new JMenuItem(cal);\n    cal.setEnabled(true);\n    //\n    // Build the file menu.\n    //\n    fileMenu.add(jmiOpen);\n    fileMenu.addSeparator();\n    fileMenu.add(jmiExit);\n    //\n    // Build the view menu.\n    //\n    viewMenu.add(jmiGetter);\n    viewMenu.add(jmiHex);\n    viewMenu.add(jmiDate);\n    viewMenu.add(jmiCal);\n    //\n    // *temp Developer's code\n    //\n    // jmiGetter.setEnabled( false );\n    //\n    // JMenuItem getter2 = new JMenuItem( \"getter2\" );\n    // getter2.addActionListener( new myMouseListener() );\n    // viewMenu.add( getter2 );\n}", "repo_id": "7", "comment": "/*\n     * addMenus\n     */\n", "repo_name": "joda-time-main/", "id": 1064, "method_signature": "void addMenus(JMenuBar)"}, "DateTimeBrowser.dumpObjs": {"callee_method_names": ["PrintStream.println"], "method_name": "DateTimeBrowser.dumpObjs", "method_implementation": "{\n    for (int i = 0; i < objs.length; ++i) {\n        for (int j = 0; j < objs[i].length; ++j) {\n            out.println(i + \" \" + j + \" \" + objs[i][j]);\n        }\n        // for j\n    }\n    // for i\n}", "repo_id": "7", "comment": "/*\n     * A private method to dump the arrays of Object[][]\n     * if desired by the developer\n     * @param objs The array of arrays to be dumped.\n     */\n", "repo_name": "joda-time-main/", "id": 1065, "method_signature": "void dumpObjs(Object[][], PrintStream)"}, "DateTimeBrowser.enableAllViews": {"callee_method_names": ["JMenuItem.setEnabled", "JMenuItem.setEnabled", "JMenuItem.setEnabled", "JMenuItem.setEnabled"], "method_name": "DateTimeBrowser.enableAllViews", "method_implementation": "{\n    jmiGetter.setEnabled(true);\n    jmiHex.setEnabled(true);\n    jmiDate.setEnabled(true);\n    jmiCal.setEnabled(true);\n}", "repo_id": "7", "comment": "/*\n     * enableAll\n     */\n", "repo_name": "joda-time-main/", "id": 1066, "method_signature": "void enableAllViews()"}, "DateTimeBrowser.genCalcdValues": {"callee_method_names": ["LoadedFile.getFileStrings", "LoadedFile.getDtObjects", "ArrayList.size", "ArrayList.size", "ArrayList.get", "ArrayList.get", "DateTime.toString", "DateTime.getMillis", "GregorianCalendar.setTime", "GregorianCalendar.setMinimalDaysInFirstWeek", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get", "GregorianCalendar.get"], "method_name": "DateTimeBrowser.genCalcdValues", "method_implementation": "{\n    Object[][] retValues = null;\n    /*\n             * Create an array of Objects that will contain\n             * other arrays of Objects. (This is the 'column'\n             * array).\n             */\n    ArrayList fileStrings = lddFile.getFileStrings();\n    ArrayList dtObjects = lddFile.getDtObjects();\n    int numRows = fileStrings.size();\n    retValues = new Object[numRows][];\n    int numCols = colNames.length;\n    // System.err.println(\"NumCols : \" + numCols);\n    /*\n             * Prime the array of arrays of Objects, allocating a new\n             * secondary array for each of the primary array's\n             * elements.\n             */\n    for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++nextStrNum) {\n        // get the 'col' array\n        retValues[nextStrNum] = new Object[numCols];\n        //****\n        //* This needs to be sync'd with the colNames array.\n        //****\n        // Current row, 1st column\n        int column = 0;\n        String fileString = (String) fileStrings.get(nextStrNum);\n        retValues[nextStrNum][column++] = fileString;\n        // Current row, 2nd column\n        DateTime adt = (DateTime) dtObjects.get(nextStrNum);\n        String adtStr = adt.toString();\n        retValues[nextStrNum][column++] = adtStr;\n        // Current row, other columns.\n        // Order here must match that specified in the colNames\n        // array.\n        long lVal = adt.getMillis();\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(new Date(lVal));\n        cal.setMinimalDaysInFirstWeek(4);\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.MILLISECOND));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.SECOND));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.MINUTE));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.HOUR_OF_DAY));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.DAY_OF_WEEK));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.DAY_OF_MONTH));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.DAY_OF_YEAR));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.WEEK_OF_YEAR));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.MONTH));\n        retValues[nextStrNum][column++] = new Integer(cal.get(Calendar.YEAR));\n        //\n    }\n    // the for\n    if (debugf)\n        dumpObjs(retValues, System.err);\n    return retValues;\n}", "repo_id": "7", "comment": "/*\n         * genCalcdValues is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1082, "method_signature": "Object[][] genCalcdValues()"}, "DateTimeBrowser.genColNames": {"callee_method_names": [], "method_name": "DateTimeBrowser.genColNames", "method_implementation": "{\n    Object[] retVal = { // 0\n    \"FileString\", // 1\n    \"toString()\", // 2\n    \"Millis\", // 3\n    \"Sec\", // 4\n    \"Min\", // 5\n    \"HrOfDay\", // 6\n    \"DayOfWeek\", // 7\n    \"DayOfMon\", // 8\n    \"DayOfYr\", // 9\n    \"WkofYr\", // 10\n    \"MonOfYr\", // 11\n    \"Year\" };\n    return retVal;\n}", "repo_id": "7", "comment": "/*\n         * genColNames is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1083, "method_signature": "Object[] genColNames()"}, "DateTimeBrowser.getADate": {"callee_method_names": [], "method_name": "DateTimeBrowser.getADate", "method_implementation": "{\n    DateTime retDT = null;\n    try {\n        retDT = new DateTime(s);\n    }// the try\n     catch (IllegalArgumentException pe) {\n        // ignore it here, caller sees null\n    }\n    // the catch\n    return retDT;\n}", "repo_id": "7", "comment": "/*\n     * getADate Returns a new DateTime object reference if possible,\n     * otherwise null.\n     * @return retDT A DateTime object reference.\n     */\n", "repo_name": "joda-time-main/", "id": 1067, "method_signature": "DateTime getADate(String)"}, "DateTimeBrowser.getDefaultTableView": {"callee_method_names": ["JMenuItem.setEnabled", "String.equalsIgnoreCase", "JMenuItem.setEnabled", "String.equalsIgnoreCase", "JMenuItem.setEnabled", "String.equalsIgnoreCase", "JMenuItem.setEnabled", "String.equalsIgnoreCase", "JMenuItem.setEnabled", "JMenuItem.setEnabled"], "method_name": "DateTimeBrowser.getDefaultTableView", "method_implementation": "{\n    // No user input.\n    String viewStr = System.getProperty(\"use.view\");\n    if (viewStr == null) {\n        jmiGetter.setEnabled(false);\n        return new GetterTableView(currFile);\n    }\n    // Valid user input.\n    if (viewStr.equalsIgnoreCase(\"hex\")) {\n        jmiHex.setEnabled(false);\n        return new HexTableView(currFile);\n    } else if (viewStr.equalsIgnoreCase(\"date\")) {\n        jmiDate.setEnabled(false);\n        return new DateTableView(currFile);\n    } else if (viewStr.equalsIgnoreCase(\"cal\")) {\n        jmiCal.setEnabled(false);\n        return new CalTableView(currFile);\n    } else if (viewStr.equalsIgnoreCase(\"getter\")) {\n        jmiGetter.setEnabled(false);\n        return new GetterTableView(currFile);\n    } else {\n        // error by user\n        System.err.println(\"View name: \" + viewStr + \" invalid.\");\n        jmiGetter.setEnabled(false);\n        return new GetterTableView(currFile);\n    }\n}", "repo_id": "7", "comment": "/*\n     * getDefaultTableView\n     */\n", "repo_name": "joda-time-main/", "id": 1062, "method_signature": "TableView getDefaultTableView()"}, "DateTimeBrowser.getViewTitle": {"callee_method_names": ["LoadedFile.getLoadedFileSize"], "method_name": "DateTimeBrowser.getViewTitle", "method_implementation": "{\n    return \"java.util.Calendar.get(int)\" + \" : \" + TimeZone.getDefault().getDisplayName() + \" : \" + \" Record Count \" + currFile.getLoadedFileSize();\n}", "repo_id": "7", "comment": "/*\n         * getViewTitle\n         */\n", "repo_name": "joda-time-main/", "id": 1084, "method_signature": "String getViewTitle()"}, "DateTimeBrowser.go": {"callee_method_names": [], "method_name": "DateTimeBrowser.go", "method_implementation": "{\n    mainArgs = args;\n    // let user override if needed\n    setDefaultTimeZone();\n    // setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n    //\n    JMenuBar menuBar = new JMenuBar();\n    setJMenuBar(menuBar);\n    addMenus(menuBar);\n    /*\n         * Add a fast close listener\n         */\n    addWindowListener(new WindowAdapter() {\n\n        public void windowClosing(WindowEvent e) {\n            setVisible(false);\n            dispose();\n            System.exit(0);\n        }\n    });\n    //\n    // Load current file, prime tables and JFrame.\n    //\n    currFile = new LoadedFile(mainArgs[0]);\n    TableView tView = getDefaultTableView();\n    resetDefaults(tView);\n    //\n    // Set max size at start, and display the window.\n    //\n    Dimension screenMax = Toolkit.getDefaultToolkit().getScreenSize();\n    setSize(screenMax);\n    setVisible(true);\n}", "repo_id": "7", "comment": "/*\n     * go This method reads the file, creates the table to display,\n     * the window to display it in, and displays the window.\n     * @param fileName the name of the file to read.\n     * @param tryLines An estimate of the number of lines in\n     * the file.\n     */\n", "repo_name": "joda-time-main/", "id": 1061, "method_signature": "void go(String[])"}, "DateTimeBrowser.main": {"callee_method_names": [], "method_name": "DateTimeBrowser.main", "method_implementation": "{\n    /*\n         * Developers Notes:\n         *\n         * -No corresponding Junit test class currently\n         * provided.  Test by eyeball of the output.\n         *\n         * -Add a menu with Help(About)\n         * --> TBD.\n         *\n         * -Figure out some sane way to set initial default\n         * column sizes.\n         *\n         * -Lots of inner classes here, done in order to keep\n         * all the .class files easily identifiable.  Some of\n         * this code is pretty ugly, very procedural in nature.\n         * Lots of very tight coupling between all the classes,\n         * thinly disguised switch statements, etc ..... This\n         * code written on the fly, with almost no thought given\n         * to OO design.\n         *\n         * -Also, I'm not really a GUI guy, so forgive any\n         * transgressions.\n         *\n         */\n    if (args.length < 1) {\n        System.err.println(\"File name is required!\");\n        usage();\n        System.exit(1);\n    }\n    /*\n         * Instantiate a DateTimeBrowser and invoke it's go method,\n         * passing the input argument list.\n         */\n    new DateTimeBrowser().go(args);\n}", "repo_id": "7", "comment": "/**\n * This is the main swing application method.   It sets up and displays the\n * initial GUI, and controls execution thereafter.  Everything else in\n * this class is 'private', please read the code.\n */\n", "repo_name": "joda-time-main/", "id": 1059, "method_signature": "void main(String[])"}, "DateTimeBrowser.resetDefaults": {"callee_method_names": ["TableView.getColNames", "TableView.getCalcdValues", "TableView.setViewColumnsWidth", "TableView.getViewTitle"], "method_name": "DateTimeBrowser.resetDefaults", "method_implementation": "{\n    Object[] colNames = tView.getColNames();\n    Object[][] tableValues = tView.getCalcdValues();\n    // dumpObjs( tableValues, System.out);\n    JTable table = new JTable(tableValues, colNames);\n    tView.setViewColumnsWidth(table);\n    setTitle(tView.getViewTitle());\n    //\n    if (mainSP != null)\n        getContentPane().remove(mainSP);\n    mainSP = new JScrollPane(table);\n    getContentPane().add(mainSP, \"Center\");\n    validate();\n}", "repo_id": "7", "comment": "/*\n     * resetDefaults\n     */\n", "repo_name": "joda-time-main/", "id": 1069, "method_signature": "void resetDefaults(TableView)"}, "DateTimeBrowser.setDefaultTimeZone": {"callee_method_names": [], "method_name": "DateTimeBrowser.setDefaultTimeZone", "method_implementation": "{\n    String tzName = System.getProperty(\"use.time.zone\");\n    // Use OS/user default.\n    if (tzName == null)\n        return;\n    //\n    // If tzName is bogus, not understood by the JRE,\n    // 'getTimeZone' returns GMT.\n    //\n    TimeZone toSet = TimeZone.getTimeZone(tzName);\n    //\n    // Set default to whatever was returned.\n    //\n    TimeZone.setDefault(toSet);\n}", "repo_id": "7", "comment": "/*\n     * setDefaultTimeZone\n     */\n", "repo_name": "joda-time-main/", "id": 1063, "method_signature": "void setDefaultTimeZone()"}, "DateTimeBrowser.setViewColumnsWidth": {"callee_method_names": ["JTable.getColumnModel", "TableColumnModel.getColumn", "TableColumn.setPreferredWidth", "TableColumnModel.getColumn", "TableColumn.setPreferredWidth"], "method_name": "DateTimeBrowser.setViewColumnsWidth", "method_implementation": "{\n    /*\n             * Resize column 0, 1\n             */\n    TableColumnModel colmodel = jt.getColumnModel();\n    TableColumn col0 = colmodel.getColumn(0);\n    col0.setPreferredWidth(175);\n    TableColumn col1 = colmodel.getColumn(1);\n    col1.setPreferredWidth(175);\n    return;\n}", "repo_id": "7", "comment": "/*\n         * setViewColumnLengths\n         */\n", "repo_name": "joda-time-main/", "id": 1085, "method_signature": "void setViewColumnsWidth(JTable)"}, "DateTimeBrowser.usage": {"callee_method_names": [], "method_name": "DateTimeBrowser.usage", "method_implementation": "{\n    System.err.println(\"Usage:\");\n    System.err.print(\"java <options> \");\n    System.err.print(DateTimeBrowser.class.getName());\n    System.err.println(\" <filename>\");\n    System.err.println(\"<filename> contains a list of Strings\");\n    System.err.println(\"\\twhich are valid for DateTime instantiation.\");\n    System.err.println(\"<optons>\");\n    System.err.println(\"\\t-Duse.time.zone=\");\n    System.err.println(\"\\t\\tA valid timezone name.  If not specified\");\n    System.err.println(\"\\t\\tthe OS/user default is used.  If sepcified\");\n    System.err.println(\"\\t\\tincorrectly, GMT is quietly used.\");\n    System.err.println(\"\\t-Duse.view=\");\n    System.err.println(\"\\t\\tAn initial view to be displayed.\");\n    System.err.println(\"\\t\\tValid names are: getter, hex, date, cal\");\n    System.err.println(\"\\t\\tIf incorrectly specified, getter is used.\");\n    System.err.println(\"\\t\\tThis becomes the default view.\");\n}", "repo_id": "7", "comment": "/*\n     * usage A private static method to display usage information to\n     * the user before an error exit.\n     */\n", "repo_name": "joda-time-main/", "id": 1060, "method_signature": "void usage()"}, "DateTimeBrowser.validateFile": {"callee_method_names": ["File.exists", "File.canRead", "File.length"], "method_name": "DateTimeBrowser.validateFile", "method_implementation": "{\n    /*\n             * Verify the user specified file exists and can\n             * be read.\n             */\n    File f = new File(fileName);\n    if (!f.exists() || !f.canRead()) {\n        System.err.println(\"File: \" + mainArgs[0] + \" does not exist or cannot be read!\");\n        usage();\n        System.exit(2);\n    }\n    /*\n             * Try to get a reasonable estimate of the number of lines\n             * in the file.\n             */\n    // Java does not do this right IMO.  The number of bytes in a\n    // file is a\n    // long, but the length of a string is an int.  Why?\n    lineGuess = (int) (f.length() / (long) \"YYYY-MM-DDTHH:MM:SS\".length());\n    lineGuess += (lineGuess / 10);\n    //\n    // Debugging\n    //\n    if (false) {\n        System.out.println(\"Line guess is: \" + lineGuess);\n    }\n}", "repo_id": "7", "comment": "/*\n         * validateFile\n         */\n", "repo_name": "joda-time-main/", "id": 1070, "method_signature": "void validateFile(String)"}, "DateTimeComparator.compare": {"callee_method_ids": [70, 70, 70, 70], "callee_method_names": ["InstantConverter.getChronology", "InstantConverter.getInstantMillis", "InstantConverter.getChronology", "InstantConverter.getInstantMillis", "DateTimeFieldType.getField", "DateTimeFieldType.getField", "DateTimeFieldType.getField", "DateTimeFieldType.getField"], "method_name": "DateTimeComparator.compare", "method_implementation": "{\n    InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj);\n    Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null);\n    long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono);\n    // handle null==null and other cases where objects are the same\n    // but only do this after checking the input is valid\n    if (lhsObj == rhsObj) {\n        return 0;\n    }\n    conv = ConverterManager.getInstance().getInstantConverter(rhsObj);\n    Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null);\n    long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono);\n    if (iLowerLimit != null) {\n        lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis);\n        rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis);\n    }\n    if (iUpperLimit != null) {\n        lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis);\n        rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis);\n    }\n    if (lhsMillis < rhsMillis) {\n        return -1;\n    } else if (lhsMillis > rhsMillis) {\n        return 1;\n    } else {\n        return 0;\n    }\n}", "repo_id": "7", "comment": "/**\n * Compare two objects against only the range of date time fields as\n * specified in the constructor.\n *\n * @param lhsObj  the first object,\n *      logically on the left of a &lt; comparison, null means now\n * @param rhsObj  the second object,\n *      logically on the right of a &lt; comparison, null means now\n * @return zero if order does not matter,\n *      negative value if lhsObj &lt; rhsObj, positive value otherwise.\n * @throws IllegalArgumentException if either argument is not supported\n */\n", "repo_name": "joda-time-main/", "id": 234, "method_signature": "int compare(Object, Object)"}, "DateTimeComparator.equals": {"callee_method_ids": [69, 69], "callee_method_names": ["DateTimeComparator.getLowerLimit", "DateTimeFieldType.equals", "DateTimeComparator.getLowerLimit", "DateTimeComparator.getUpperLimit", "DateTimeFieldType.equals", "DateTimeComparator.getUpperLimit"], "method_name": "DateTimeComparator.equals", "method_implementation": "{\n    if (object instanceof DateTimeComparator) {\n        DateTimeComparator other = (DateTimeComparator) object;\n        return (iLowerLimit == other.getLowerLimit() || (iLowerLimit != null && iLowerLimit.equals(other.getLowerLimit()))) && (iUpperLimit == other.getUpperLimit() || (iUpperLimit != null && iUpperLimit.equals(other.getUpperLimit())));\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Compares this comparator to another.\n *\n * @param object  the object to compare to\n * @return true if equal\n */\n", "repo_name": "joda-time-main/", "id": 235, "method_signature": "boolean equals(Object)"}, "DateTimeComparator.getInstance": {"callee_method_names": [], "method_name": "DateTimeComparator.getInstance", "method_implementation": "{\n    if (lowerLimit == null && upperLimit == null) {\n        return ALL_INSTANCE;\n    }\n    if (lowerLimit == DateTimeFieldType.dayOfYear() && upperLimit == null) {\n        return DATE_INSTANCE;\n    }\n    if (lowerLimit == null && upperLimit == DateTimeFieldType.dayOfYear()) {\n        return TIME_INSTANCE;\n    }\n    return new DateTimeComparator(lowerLimit, upperLimit);\n}", "repo_id": "7", "comment": "/**\n * Returns a DateTimeComparator with a lower and upper limit. Fields of a\n * magnitude less than the lower limit are excluded from comparisons.\n * Fields of a magnitude greater than or equal to the upper limit are also\n * excluded from comparisons. Either limit may be specified as null, which\n * indicates an unbounded limit.\n * <p>\n * The time-zone is considered when using this comparator unless both limits are null.\n * The input millis are rounded/truncated using the time-zone of that input value.\n * Thus, two inputs with different time-zones will typically not be equal\n *\n * @param lowerLimit  inclusive lower limit for fields to be compared, null means no limit\n * @param upperLimit  exclusive upper limit for fields to be compared, null means no limit\n * @return a comparator over all fields between the limits\n */\n", "repo_name": "joda-time-main/", "id": 233, "method_signature": "DateTimeComparator getInstance(DateTimeFieldType, DateTimeFieldType)"}, "DateTimeComparator.hashCode": {"callee_method_names": ["DateTimeFieldType.hashCode", "DateTimeFieldType.hashCode"], "method_name": "DateTimeComparator.hashCode", "method_implementation": "{\n    return (iLowerLimit == null ? 0 : iLowerLimit.hashCode()) + (123 * (iUpperLimit == null ? 0 : iUpperLimit.hashCode()));\n}", "repo_id": "7", "comment": "/**\n * Gets a suitable hashcode.\n *\n * @return the hashcode\n */\n", "repo_name": "joda-time-main/", "id": 236, "method_signature": "int hashCode()"}, "DateTimeComparator.toString": {"callee_method_names": ["DateTimeFieldType.getName", "DateTimeFieldType.getName", "DateTimeFieldType.getName"], "method_name": "DateTimeComparator.toString", "method_implementation": "{\n    if (iLowerLimit == iUpperLimit) {\n        return \"DateTimeComparator[\" + (iLowerLimit == null ? \"\" : iLowerLimit.getName()) + \"]\";\n    } else {\n        return \"DateTimeComparator[\" + (iLowerLimit == null ? \"\" : iLowerLimit.getName()) + \"-\" + (iUpperLimit == null ? \"\" : iUpperLimit.getName()) + \"]\";\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets a debugging string.\n *\n * @return a debugging string\n */\n", "repo_name": "joda-time-main/", "id": 237, "method_signature": "String toString()"}, "DateTimeFieldType.equals": {"callee_method_names": [], "method_name": "DateTimeFieldType.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof StandardDateTimeFieldType) {\n        return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal;\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * @inheritdoc\n */\n", "repo_name": "joda-time-main/", "id": 69, "method_signature": "boolean equals(Object)"}, "DateTimeFieldType.getField": {"callee_method_names": ["Chronology.era", "Chronology.yearOfEra", "Chronology.centuryOfEra", "Chronology.yearOfCentury", "Chronology.year", "Chronology.dayOfYear", "Chronology.monthOfYear", "Chronology.dayOfMonth", "Chronology.weekyearOfCentury", "Chronology.weekyear", "Chronology.weekOfWeekyear", "Chronology.dayOfWeek", "Chronology.halfdayOfDay", "Chronology.hourOfHalfday", "Chronology.clockhourOfHalfday", "Chronology.clockhourOfDay", "Chronology.hourOfDay", "Chronology.minuteOfDay", "Chronology.minuteOfHour", "Chronology.secondOfDay", "Chronology.secondOfMinute", "Chronology.millisOfDay", "Chronology.millisOfSecond"], "method_name": "DateTimeFieldType.getField", "method_implementation": "{\n    chronology = DateTimeUtils.getChronology(chronology);\n    switch(iOrdinal) {\n        case ERA:\n            return chronology.era();\n        case YEAR_OF_ERA:\n            return chronology.yearOfEra();\n        case CENTURY_OF_ERA:\n            return chronology.centuryOfEra();\n        case YEAR_OF_CENTURY:\n            return chronology.yearOfCentury();\n        case YEAR:\n            return chronology.year();\n        case DAY_OF_YEAR:\n            return chronology.dayOfYear();\n        case MONTH_OF_YEAR:\n            return chronology.monthOfYear();\n        case DAY_OF_MONTH:\n            return chronology.dayOfMonth();\n        case WEEKYEAR_OF_CENTURY:\n            return chronology.weekyearOfCentury();\n        case WEEKYEAR:\n            return chronology.weekyear();\n        case WEEK_OF_WEEKYEAR:\n            return chronology.weekOfWeekyear();\n        case DAY_OF_WEEK:\n            return chronology.dayOfWeek();\n        case HALFDAY_OF_DAY:\n            return chronology.halfdayOfDay();\n        case HOUR_OF_HALFDAY:\n            return chronology.hourOfHalfday();\n        case CLOCKHOUR_OF_HALFDAY:\n            return chronology.clockhourOfHalfday();\n        case CLOCKHOUR_OF_DAY:\n            return chronology.clockhourOfDay();\n        case HOUR_OF_DAY:\n            return chronology.hourOfDay();\n        case MINUTE_OF_DAY:\n            return chronology.minuteOfDay();\n        case MINUTE_OF_HOUR:\n            return chronology.minuteOfHour();\n        case SECOND_OF_DAY:\n            return chronology.secondOfDay();\n        case SECOND_OF_MINUTE:\n            return chronology.secondOfMinute();\n        case MILLIS_OF_DAY:\n            return chronology.millisOfDay();\n        case MILLIS_OF_SECOND:\n            return chronology.millisOfSecond();\n        default:\n            // Shouldn't happen.\n            throw new InternalError();\n    }\n}", "repo_id": "7", "comment": "/**\n * @inheritdoc\n */\n", "repo_name": "joda-time-main/", "id": 70, "method_signature": "DateTimeField getField(Chronology)"}, "DateTimeFieldType.readResolve": {"callee_method_names": [], "method_name": "DateTimeFieldType.readResolve", "method_implementation": "{\n    switch(iOrdinal) {\n        case ERA:\n            return ERA_TYPE;\n        case YEAR_OF_ERA:\n            return YEAR_OF_ERA_TYPE;\n        case CENTURY_OF_ERA:\n            return CENTURY_OF_ERA_TYPE;\n        case YEAR_OF_CENTURY:\n            return YEAR_OF_CENTURY_TYPE;\n        case YEAR:\n            return YEAR_TYPE;\n        case DAY_OF_YEAR:\n            return DAY_OF_YEAR_TYPE;\n        case MONTH_OF_YEAR:\n            return MONTH_OF_YEAR_TYPE;\n        case DAY_OF_MONTH:\n            return DAY_OF_MONTH_TYPE;\n        case WEEKYEAR_OF_CENTURY:\n            return WEEKYEAR_OF_CENTURY_TYPE;\n        case WEEKYEAR:\n            return WEEKYEAR_TYPE;\n        case WEEK_OF_WEEKYEAR:\n            return WEEK_OF_WEEKYEAR_TYPE;\n        case DAY_OF_WEEK:\n            return DAY_OF_WEEK_TYPE;\n        case HALFDAY_OF_DAY:\n            return HALFDAY_OF_DAY_TYPE;\n        case HOUR_OF_HALFDAY:\n            return HOUR_OF_HALFDAY_TYPE;\n        case CLOCKHOUR_OF_HALFDAY:\n            return CLOCKHOUR_OF_HALFDAY_TYPE;\n        case CLOCKHOUR_OF_DAY:\n            return CLOCKHOUR_OF_DAY_TYPE;\n        case HOUR_OF_DAY:\n            return HOUR_OF_DAY_TYPE;\n        case MINUTE_OF_DAY:\n            return MINUTE_OF_DAY_TYPE;\n        case MINUTE_OF_HOUR:\n            return MINUTE_OF_HOUR_TYPE;\n        case SECOND_OF_DAY:\n            return SECOND_OF_DAY_TYPE;\n        case SECOND_OF_MINUTE:\n            return SECOND_OF_MINUTE_TYPE;\n        case MILLIS_OF_DAY:\n            return MILLIS_OF_DAY_TYPE;\n        case MILLIS_OF_SECOND:\n            return MILLIS_OF_SECOND_TYPE;\n        default:\n            // Shouldn't happen.\n            return this;\n    }\n}", "repo_id": "7", "comment": "/**\n * Ensure a singleton is returned.\n *\n * @return the singleton type\n */\n", "repo_name": "joda-time-main/", "id": 71, "method_signature": "Object readResolve()"}, "DateTimeFormat.createDateTimeFormatter": {"callee_method_names": [], "method_name": "DateTimeFormat.createDateTimeFormatter", "method_implementation": "{\n    int type = DATETIME;\n    if (dateStyle == NONE) {\n        type = TIME;\n    } else if (timeStyle == NONE) {\n        type = DATE;\n    }\n    StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type);\n    return new DateTimeFormatter(llf, llf);\n}", "repo_id": "7", "comment": "/**\n * Creates a formatter for the specified style.\n *\n * @param dateStyle  the date style\n * @param timeStyle  the time style\n * @return the formatter\n */\n", "repo_name": "joda-time-main/", "id": 898, "method_signature": "DateTimeFormatter createDateTimeFormatter(int, int)"}, "DateTimeFormat.createFormatterForPattern": {"callee_method_ids": [911], "callee_method_names": ["String.length", "ConcurrentHashMap.get", "DateTimeFormatterBuilder.toFormatter", "ConcurrentHashMap.size", "ConcurrentHashMap.putIfAbsent"], "method_name": "DateTimeFormat.createFormatterForPattern", "method_implementation": "{\n    if (pattern == null || pattern.length() == 0) {\n        throw new IllegalArgumentException(\"Invalid pattern specification: Pattern is null or empty\");\n    }\n    DateTimeFormatter formatter = cPatternCache.get(pattern);\n    if (formatter == null) {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        parsePatternTo(builder, pattern);\n        formatter = builder.toFormatter();\n        if (cPatternCache.size() < PATTERN_CACHE_SIZE) {\n            // the size check is not locked against concurrent access,\n            // but is accepted to be slightly off in contention scenarios.\n            DateTimeFormatter oldFormatter = cPatternCache.putIfAbsent(pattern, formatter);\n            if (oldFormatter != null) {\n                formatter = oldFormatter;\n            }\n        }\n    }\n    return formatter;\n}", "repo_id": "7", "comment": "/**\n * Select a format from a custom pattern.\n *\n * @param pattern  pattern specification\n * @throws IllegalArgumentException if the pattern is invalid\n * @see #appendPatternTo\n */\n", "repo_name": "joda-time-main/", "id": 895, "method_signature": "DateTimeFormatter createFormatterForPattern(String)"}, "DateTimeFormat.createFormatterForStyle": {"callee_method_names": ["String.length", "String.charAt", "String.charAt"], "method_name": "DateTimeFormat.createFormatterForStyle", "method_implementation": "{\n    if (style == null || style.length() != 2) {\n        throw new IllegalArgumentException(\"Invalid style specification: \" + style);\n    }\n    int dateStyle = selectStyle(style.charAt(0));\n    int timeStyle = selectStyle(style.charAt(1));\n    if (dateStyle == NONE && timeStyle == NONE) {\n        throw new IllegalArgumentException(\"Style '--' is invalid\");\n    }\n    return createFormatterForStyleIndex(dateStyle, timeStyle);\n}", "repo_id": "7", "comment": "/**\n * Select a format from a two character style pattern. The first character\n * is the date style, and the second character is the time style. Specify a\n * character of 'S' for short style, 'M' for medium, 'L' for long, and 'F'\n * for full. A date or time may be omitted by specifying a style character '-'.\n *\n * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n * @throws IllegalArgumentException if the style is invalid\n */\n", "repo_name": "joda-time-main/", "id": 896, "method_signature": "DateTimeFormatter createFormatterForStyle(String)"}, "DateTimeFormat.createFormatterForStyleIndex": {"callee_method_names": ["AtomicReferenceArray.length", "AtomicReferenceArray.get", "AtomicReferenceArray.compareAndSet", "AtomicReferenceArray.get"], "method_name": "DateTimeFormat.createFormatterForStyleIndex", "method_implementation": "{\n    // (dateStyle * 5 + timeStyle);\n    int index = ((dateStyle << 2) + dateStyle) + timeStyle;\n    // Should never happen but do a double check...\n    if (index >= cStyleCache.length()) {\n        return createDateTimeFormatter(dateStyle, timeStyle);\n    }\n    DateTimeFormatter f = cStyleCache.get(index);\n    if (f == null) {\n        f = createDateTimeFormatter(dateStyle, timeStyle);\n        if (cStyleCache.compareAndSet(index, null, f) == false) {\n            f = cStyleCache.get(index);\n        }\n    }\n    return f;\n}", "repo_id": "7", "comment": "/**\n * Gets the formatter for the specified style.\n *\n * @param dateStyle  the date style\n * @param timeStyle  the time style\n * @return the formatter\n */\n", "repo_name": "joda-time-main/", "id": 897, "method_signature": "DateTimeFormatter createFormatterForStyleIndex(int, int)"}, "DateTimeFormat.isNumericToken": {"callee_method_names": ["String.length", "String.charAt"], "method_name": "DateTimeFormat.isNumericToken", "method_implementation": "{\n    int tokenLen = token.length();\n    if (tokenLen > 0) {\n        char c = token.charAt(0);\n        switch(c) {\n            // century (number)\n            case 'c':\n            // century of era (number)\n            case 'C':\n            // weekyear (number)\n            case 'x':\n            // year (number)\n            case 'y':\n            // year of era (number)\n            case 'Y':\n            // day of month (number)\n            case 'd':\n            // hour of day (number, 1..12)\n            case 'h':\n            // hour of day (number, 0..23)\n            case 'H':\n            // minute of hour (number)\n            case 'm':\n            // second of minute (number)\n            case 's':\n            // fraction of second (number)\n            case 'S':\n            // day of week (number)\n            case 'e':\n            // day of year (number)\n            case 'D':\n            // day of week in month (number)\n            case 'F':\n            // week of year (number)\n            case 'w':\n            // week of month (number)\n            case 'W':\n            // hour of day (1..24)\n            case 'k':\n            case // hour of day (0..11)\n            'K':\n                return true;\n            case // month of year (text and number)\n            'M':\n                if (tokenLen <= 2) {\n                    return true;\n                }\n        }\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Returns true if token should be parsed as a numeric field.\n *\n * @param token  the token to parse\n * @return true if numeric field\n */\n", "repo_name": "joda-time-main/", "id": 894, "method_signature": "boolean isNumericToken(String)"}, "DateTimeFormat.parsePatternTo": {"callee_method_ids": [929, 929, 920, 920], "callee_method_names": ["String.length", "String.length", "String.charAt", "DateTimeFormatterBuilder.appendEraText", "DateTimeFormatterBuilder.appendCenturyOfEra", "DateTimeFormatterBuilder.appendTwoDigitWeekyear", "DateTimeFormatterBuilder.appendTwoDigitYear", "DateTimeFormatterBuilder.appendWeekyear", "DateTimeFormatterBuilder.appendYear", "DateTimeFormatterBuilder.appendYearOfEra", "DateTimeFormatterBuilder.appendMonthOfYearText", "DateTimeFormatterBuilder.appendMonthOfYearShortText", "DateTimeFormatterBuilder.appendMonthOfYear", "DateTimeFormatterBuilder.appendDayOfMonth", "DateTimeFormatterBuilder.appendHalfdayOfDayText", "DateTimeFormatterBuilder.appendClockhourOfHalfday", "DateTimeFormatterBuilder.appendHourOfDay", "DateTimeFormatterBuilder.appendClockhourOfDay", "DateTimeFormatterBuilder.appendHourOfHalfday", "DateTimeFormatterBuilder.appendMinuteOfHour", "DateTimeFormatterBuilder.appendSecondOfMinute", "DateTimeFormatterBuilder.appendFractionOfSecond", "DateTimeFormatterBuilder.appendDayOfWeek", "DateTimeFormatterBuilder.appendDayOfWeekText", "DateTimeFormatterBuilder.appendDayOfWeekShortText", "DateTimeFormatterBuilder.appendDayOfYear", "DateTimeFormatterBuilder.appendWeekOfWeekyear", "DateTimeFormatterBuilder.appendTimeZoneName", "DateTimeFormatterBuilder.appendTimeZoneShortName", "DateTimeFormatterBuilder.appendTimeZoneOffset", "DateTimeFormatterBuilder.appendTimeZoneOffset", "DateTimeFormatterBuilder.appendTimeZoneId", "String.substring", "String.length", "DateTimeFormatterBuilder.appendLiteral", "String.charAt", "DateTimeFormatterBuilder.appendLiteral"], "method_name": "DateTimeFormat.parsePatternTo", "method_implementation": "{\n    int length = pattern.length();\n    int[] indexRef = new int[1];\n    for (int i = 0; i < length; i++) {\n        indexRef[0] = i;\n        String token = parseToken(pattern, indexRef);\n        i = indexRef[0];\n        int tokenLen = token.length();\n        if (tokenLen == 0) {\n            break;\n        }\n        char c = token.charAt(0);\n        switch(c) {\n            case // era designator (text)\n            'G':\n                builder.appendEraText();\n                break;\n            case // century of era (number)\n            'C':\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            // weekyear (number)\n            case 'x':\n            // year (number)\n            case 'y':\n            case // year of era (number)\n            'Y':\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch(c) {\n                        case 'x':\n                            builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse);\n                            break;\n                        case 'y':\n                        case 'Y':\n                        default:\n                            builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                            break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n                    switch(c) {\n                        case 'x':\n                            builder.appendWeekyear(tokenLen, maxDigits);\n                            break;\n                        case 'y':\n                            builder.appendYear(tokenLen, maxDigits);\n                            break;\n                        case 'Y':\n                            builder.appendYearOfEra(tokenLen, maxDigits);\n                            break;\n                    }\n                }\n                break;\n            case // month of year (text and number)\n            'M':\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case // day of month (number)\n            'd':\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case // am/pm marker (text)\n            'a':\n                builder.appendHalfdayOfDayText();\n                break;\n            case // clockhour of halfday (number, 1..12)\n            'h':\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case // hour of day (number, 0..23)\n            'H':\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case // clockhour of day (1..24)\n            'k':\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case // hour of halfday (0..11)\n            'K':\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case // minute of hour (number)\n            'm':\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case // second of minute (number)\n            's':\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case // fraction of second (number)\n            'S':\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case // day of week (number)\n            'e':\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case // dayOfWeek (text)\n            'E':\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case // day of year (number)\n            'D':\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case // week of weekyear (number)\n            'w':\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case // time zone (text)\n            'z':\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName(null);\n                }\n                break;\n            case // time zone offset\n            'Z':\n                if (tokenLen == 1) {\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case // literal text\n            '\\'':\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Parses the given pattern and appends the rules to the given\n * DateTimeFormatterBuilder.\n *\n * @param pattern  pattern specification\n * @throws IllegalArgumentException if the pattern is invalid\n * @see #forPattern\n */\n", "repo_name": "joda-time-main/", "id": 892, "method_signature": "void parsePatternTo(DateTimeFormatterBuilder, String)"}, "DateTimeFormat.parseToken": {"callee_method_names": ["String.length", "String.charAt", "StringBuilder.append", "String.charAt", "StringBuilder.append", "StringBuilder.append", "String.charAt", "String.charAt", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "DateTimeFormat.parseToken", "method_implementation": "{\n    StringBuilder buf = new StringBuilder();\n    int i = indexRef[0];\n    int length = pattern.length();\n    char c = pattern.charAt(i);\n    if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n        // Scan a run of the same character, which indicates a time\n        // pattern.\n        buf.append(c);\n        while (i + 1 < length) {\n            char peek = pattern.charAt(i + 1);\n            if (peek == c) {\n                buf.append(c);\n                i++;\n            } else {\n                break;\n            }\n        }\n    } else {\n        // This will identify token as text.\n        buf.append('\\'');\n        boolean inLiteral = false;\n        for (; i < length; i++) {\n            c = pattern.charAt(i);\n            if (c == '\\'') {\n                if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                    // '' is treated as escaped '\n                    i++;\n                    buf.append(c);\n                } else {\n                    inLiteral = !inLiteral;\n                }\n            } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                i--;\n                break;\n            } else {\n                buf.append(c);\n            }\n        }\n    }\n    indexRef[0] = i;\n    return buf.toString();\n}", "repo_id": "7", "comment": "/**\n * Parses an individual token.\n *\n * @param pattern  the pattern string\n * @param indexRef  a single element array, where the input is the start\n *  location and the output is the location after parsing the token\n * @return the parsed token\n */\n", "repo_name": "joda-time-main/", "id": 893, "method_signature": "String parseToken(String, int[])"}, "DateTimeFormat.patternForStyle": {"callee_method_names": ["DateTimeFormatter.getPrinter0"], "method_name": "DateTimeFormat.patternForStyle", "method_implementation": "{\n    DateTimeFormatter formatter = createFormatterForStyle(style);\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    // Not pretty, but it works.\n    return ((StyleFormatter) formatter.getPrinter0()).getPattern(locale);\n}", "repo_id": "7", "comment": "/**\n * Returns the pattern used by a particular style and locale.\n * <p>\n * The first character is the date style, and the second character is the\n * time style. Specify a character of 'S' for short style, 'M' for medium,\n * 'L' for long, and 'F' for full.\n * A date or time may be omitted by specifying a style character '-'.\n *\n * @param style  two characters from the set {\"S\", \"M\", \"L\", \"F\", \"-\"}\n * @param locale  locale to use, null means default\n * @return the formatter\n * @throws IllegalArgumentException if the style is invalid\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 891, "method_signature": "String patternForStyle(String, Locale)"}, "DateTimeFormat.selectStyle": {"callee_method_names": [], "method_name": "DateTimeFormat.selectStyle", "method_implementation": "{\n    switch(ch) {\n        case 'S':\n            return SHORT;\n        case 'M':\n            return MEDIUM;\n        case 'L':\n            return LONG;\n        case 'F':\n            return FULL;\n        case '-':\n            return NONE;\n        default:\n            throw new IllegalArgumentException(\"Invalid style character: \" + ch);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the JDK style code from the Joda code.\n *\n * @param ch  the Joda style code\n * @return the JDK style code\n */\n", "repo_name": "joda-time-main/", "id": 899, "method_signature": "int selectStyle(char)"}, "DateTimeFormatter.parseDateTime": {"callee_method_ids": [806], "callee_method_names": ["InternalParser.parseInto", "String.length", "DateTimeParserBucket.computeMillis", "DateTimeParserBucket.getOffsetInteger", "DateTimeParserBucket.getOffsetInteger", "Chronology.withZone", "DateTimeParserBucket.getZone", "Chronology.withZone", "DateTimeParserBucket.getZone", "DateTime.withZone"], "method_name": "DateTimeFormatter.parseDateTime", "method_implementation": "{\n    InternalParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            DateTime dt = new DateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}", "repo_id": "7", "comment": "/**\n * Parses a date-time from the given text, returning a new DateTime.\n * <p>\n * The parse will use the zone and chronology specified on this formatter.\n * <p>\n * If the text contains a time zone string then that will be taken into\n * account in adjusting the time of day as follows.\n * If the {@link #withOffsetParsed()} has been called, then the resulting\n * DateTime will have a fixed offset based on the parsed time zone.\n * Otherwise the resulting DateTime will have the zone of this formatter,\n * but the parsed zone may have caused the time to be adjusted.\n *\n * @param text  the text to parse, not null\n * @return the parsed date-time, never null\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the text to parse is invalid\n */\n", "repo_name": "joda-time-main/", "id": 860, "method_signature": "DateTime parseDateTime(String)"}, "DateTimeFormatter.parseInto": {"callee_method_ids": [806], "callee_method_names": ["ReadWritableInstant.getMillis", "ReadWritableInstant.getChronology", "Chronology.getZone", "InternalParser.parseInto", "ReadWritableInstant.setMillis", "DateTimeParserBucket.computeMillis", "DateTimeParserBucket.getOffsetInteger", "DateTimeParserBucket.getOffsetInteger", "Chronology.withZone", "DateTimeParserBucket.getZone", "Chronology.withZone", "DateTimeParserBucket.getZone", "ReadWritableInstant.setChronology", "ReadWritableInstant.setZone"], "method_name": "DateTimeFormatter.parseInto", "method_implementation": "{\n    InternalParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } else if (bucket.getZone() != null) {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}", "repo_id": "7", "comment": "/**\n * Parses a datetime from the given text, at the given position, saving the\n * result into the fields of the given ReadWritableInstant. If the parse\n * succeeds, the return value is the new text position. Note that the parse\n * may succeed without fully reading the text and in this case those fields\n * that were read will be set.\n * <p>\n * Only those fields present in the string will be changed in the specified\n * instant. All other fields will remain unaltered. Thus if the string only\n * contains a year and a month, then the day and time will be retained from\n * the input instant. If this is not the behaviour you want, then reset the\n * fields before calling this method, or use {@link #parseDateTime(String)}\n * or {@link #parseMutableDateTime(String)}.\n * <p>\n * If it fails, the return value is negative, but the instant may still be\n * modified. To determine the position where the parse failed, apply the\n * one's complement operator (~) on the return value.\n * <p>\n * This parse method ignores the {@link #getDefaultYear() default year} and\n * parses using the year from the supplied instant based on the chronology\n * and time-zone of the supplied instant.\n * <p>\n * The parse will use the chronology of the instant.\n *\n * @param instant  an instant that will be modified, not null\n * @param text  the text to parse\n * @param position  position to start parsing from\n * @return new position, negative value means parse failed -\n *  apply complement operator (~) to get position of failure\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the instant is null\n * @throws IllegalArgumentException if any field is out of range\n */\n", "repo_name": "joda-time-main/", "id": 857, "method_signature": "int parseInto(ReadWritableInstant, String, int)"}, "DateTimeFormatter.parseLocalDateTime": {"callee_method_ids": [806], "callee_method_names": ["InternalParser.parseInto", "String.length", "DateTimeParserBucket.computeMillis", "DateTimeParserBucket.getOffsetInteger", "DateTimeParserBucket.getOffsetInteger", "Chronology.withZone", "DateTimeParserBucket.getZone", "Chronology.withZone", "DateTimeParserBucket.getZone"], "method_name": "DateTimeFormatter.parseLocalDateTime", "method_implementation": "{\n    InternalParser parser = requireParser();\n    // always use UTC, avoiding DST gaps\n    Chronology chrono = selectChronology(null).withUTC();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (bucket.getOffsetInteger() != null) {\n                // treat withOffsetParsed() as being true\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new LocalDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}", "repo_id": "7", "comment": "/**\n * Parses only the local date-time from the given text, returning a new LocalDateTime.\n * <p>\n * This will parse the text fully according to the formatter, using the UTC zone.\n * Once parsed, only the local date-time will be used.\n * This means that any parsed time-zone or offset field is completely ignored.\n * It also means that the zone and offset-parsed settings are ignored.\n *\n * @param text  the text to parse, not null\n * @return the parsed date-time, never null\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the text to parse is invalid\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 859, "method_signature": "LocalDateTime parseLocalDateTime(String)"}, "DateTimeFormatter.parseMillis": {"callee_method_names": ["DateTimeParserBucket.doParseMillis"], "method_name": "DateTimeFormatter.parseMillis", "method_implementation": "{\n    InternalParser parser = requireParser();\n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    return bucket.doParseMillis(parser, text);\n}", "repo_id": "7", "comment": "/**\n * Parses a datetime from the given text, returning the number of\n * milliseconds since the epoch, 1970-01-01T00:00:00Z.\n * <p>\n * The parse will use the ISO chronology, and the default time zone.\n * If the text contains a time zone string then that will be taken into account.\n *\n * @param text  the text to parse, not null\n * @return parsed value expressed in milliseconds since the epoch\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the text to parse is invalid\n */\n", "repo_name": "joda-time-main/", "id": 858, "method_signature": "long parseMillis(String)"}, "DateTimeFormatter.parseMutableDateTime": {"callee_method_ids": [806, 662], "callee_method_names": ["InternalParser.parseInto", "String.length", "DateTimeParserBucket.computeMillis", "DateTimeParserBucket.getOffsetInteger", "DateTimeParserBucket.getOffsetInteger", "Chronology.withZone", "DateTimeParserBucket.getZone", "Chronology.withZone", "DateTimeParserBucket.getZone", "MutableDateTime.setZone"], "method_name": "DateTimeFormatter.parseMutableDateTime", "method_implementation": "{\n    InternalParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}", "repo_id": "7", "comment": "/**\n * Parses a date-time from the given text, returning a new MutableDateTime.\n * <p>\n * The parse will use the zone and chronology specified on this formatter.\n * <p>\n * If the text contains a time zone string then that will be taken into\n * account in adjusting the time of day as follows.\n * If the {@link #withOffsetParsed()} has been called, then the resulting\n * DateTime will have a fixed offset based on the parsed time zone.\n * Otherwise the resulting DateTime will have the zone of this formatter,\n * but the parsed zone may have caused the time to be adjusted.\n *\n * @param text  the text to parse, not null\n * @return the parsed date-time, never null\n * @throws UnsupportedOperationException if parsing is not supported\n * @throws IllegalArgumentException if the text to parse is invalid\n */\n", "repo_name": "joda-time-main/", "id": 861, "method_signature": "MutableDateTime parseMutableDateTime(String)"}, "DateTimeFormatter.print": {"callee_method_names": ["StringBuilder.toString"], "method_name": "DateTimeFormatter.print", "method_implementation": "{\n    StringBuilder buf = new StringBuilder(requirePrinter().estimatePrintedLength());\n    try {\n        printTo((Appendable) buf, partial);\n    } catch (IOException ex) {\n        // StringBuilder does not throw IOException\n    }\n    return buf.toString();\n}", "repo_id": "7", "comment": "/**\n * Prints a ReadablePartial to a new String.\n * <p>\n * Neither the override chronology nor the override zone are used\n * by this method.\n *\n * @param partial  partial to format\n * @return the printed result\n */\n", "repo_name": "joda-time-main/", "id": 855, "method_signature": "String print(ReadablePartial)"}, "DateTimeFormatter.printTo": {"callee_method_names": ["InternalPrinter.printTo"], "method_name": "DateTimeFormatter.printTo", "method_implementation": "{\n    InternalPrinter printer = requirePrinter();\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    printer.printTo(appendable, partial, iLocale);\n}", "repo_id": "7", "comment": "/**\n * Prints a ReadablePartial.\n * <p>\n * Neither the override chronology nor the override zone are used\n * by this method.\n *\n * @param appendable  the destination to format to, not null\n * @param partial  partial to format\n * @throws IOException if an IO error occurs\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 852, "method_signature": "void printTo(Appendable, ReadablePartial)"}, "DateTimeFormatter.requireParser": {"callee_method_names": [], "method_name": "DateTimeFormatter.requireParser", "method_implementation": "{\n    InternalParser parser = iParser;\n    if (parser == null) {\n        throw new UnsupportedOperationException(\"Parsing not supported\");\n    }\n    return parser;\n}", "repo_id": "7", "comment": "/**\n * Checks whether parsing is supported.\n *\n * @throws UnsupportedOperationException if parsing is not supported\n */\n", "repo_name": "joda-time-main/", "id": 862, "method_signature": "InternalParser requireParser()"}, "DateTimeFormatter.requirePrinter": {"callee_method_names": [], "method_name": "DateTimeFormatter.requirePrinter", "method_implementation": "{\n    InternalPrinter printer = iPrinter;\n    if (printer == null) {\n        throw new UnsupportedOperationException(\"Printing not supported\");\n    }\n    return printer;\n}", "repo_id": "7", "comment": "/**\n * Checks whether printing is supported.\n *\n * @throws UnsupportedOperationException if printing is not supported\n */\n", "repo_name": "joda-time-main/", "id": 856, "method_signature": "InternalPrinter requirePrinter()"}, "DateTimeFormatter.selectChronology": {"callee_method_names": ["Chronology.withZone"], "method_name": "DateTimeFormatter.selectChronology", "method_implementation": "{\n    chrono = DateTimeUtils.getChronology(chrono);\n    if (iChrono != null) {\n        chrono = iChrono;\n    }\n    if (iZone != null) {\n        chrono = chrono.withZone(iZone);\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Determines the correct chronology to use.\n *\n * @param chrono  the proposed chronology\n * @return the actual chronology\n */\n", "repo_name": "joda-time-main/", "id": 863, "method_signature": "Chronology selectChronology(Chronology)"}, "DateTimeFormatter.withChronology": {"callee_method_names": [], "method_name": "DateTimeFormatter.withChronology", "method_implementation": "{\n    if (iChrono == chrono) {\n        return this;\n    }\n    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n}", "repo_id": "7", "comment": "/**\n * Returns a new formatter that will use the specified chronology in\n * preference to that of the printed object, or ISO on a parse.\n * <p>\n * When printing, this chronology will be used in preference to the chronology\n * from the datetime that would otherwise be used.\n * <p>\n * When parsing, this chronology will be set on the parsed datetime.\n * <p>\n * A null chronology means no-override.\n * If both an override chronology and an override zone are set, the\n * override zone will take precedence over the zone in the chronology.\n *\n * @param chrono  the chronology to use as an override\n * @return the new formatter\n */\n", "repo_name": "joda-time-main/", "id": 842, "method_signature": "DateTimeFormatter withChronology(Chronology)"}, "DateTimeFormatter.withLocale": {"callee_method_names": ["Locale.equals"], "method_name": "DateTimeFormatter.withLocale", "method_implementation": "{\n    if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n        return this;\n    }\n    return new DateTimeFormatter(iPrinter, iParser, locale, iOffsetParsed, iChrono, iZone, iPivotYear, iDefaultYear);\n}", "repo_id": "7", "comment": "/**\n * Returns a new formatter with a different locale that will be used\n * for printing and parsing.\n * <p>\n * A DateTimeFormatter is immutable, so a new instance is returned,\n * and the original is unaltered and still usable.\n *\n * @param locale the locale to use; if null, formatter uses default locale\n * at invocation time\n * @return the new formatter\n */\n", "repo_name": "joda-time-main/", "id": 840, "method_signature": "DateTimeFormatter withLocale(Locale)"}, "DateTimeFormatter.withOffsetParsed": {"callee_method_names": [], "method_name": "DateTimeFormatter.withOffsetParsed", "method_implementation": "{\n    if (iOffsetParsed == true) {\n        return this;\n    }\n    return new DateTimeFormatter(iPrinter, iParser, iLocale, true, iChrono, null, iPivotYear, iDefaultYear);\n}", "repo_id": "7", "comment": "/**\n * Returns a new formatter that will create a datetime with a time zone\n * equal to that of the offset of the parsed string.\n * <p>\n * After calling this method, a string '2004-06-09T10:20:30-08:00' will\n * create a datetime with a zone of -08:00 (a fixed zone, with no daylight\n * savings rules). If the parsed string represents a local time (no zone\n * offset) the parsed datetime will be in the default zone.\n * <p>\n * Calling this method sets the override zone to null.\n * Calling the override zone method sets this flag off.\n *\n * @return the new formatter\n */\n", "repo_name": "joda-time-main/", "id": 841, "method_signature": "DateTimeFormatter withOffsetParsed()"}, "DateTimeFormatter.withPivotYear": {"callee_method_names": [], "method_name": "DateTimeFormatter.withPivotYear", "method_implementation": "{\n    long oldVal = iPivotYear == null ? Long.MIN_VALUE : iPivotYear;\n    long newVal = pivotYear == null ? Long.MIN_VALUE : pivotYear;\n    if (oldVal == newVal) {\n        return this;\n    }\n    return new DateTimeFormatter(iPrinter, iParser, iLocale, iOffsetParsed, iChrono, iZone, pivotYear, iDefaultYear);\n}", "repo_id": "7", "comment": "/**\n * Returns a new formatter that will use the specified pivot year for two\n * digit year parsing in preference to that stored in the parser.\n * <p>\n * This setting is useful for changing the pivot year of formats built\n * using a pattern - {@link DateTimeFormat#forPattern(String)}.\n * <p>\n * When parsing, this pivot year is used. Null means no-override.\n * There is no effect when printing.\n * <p>\n * The pivot year enables a two digit year to be converted to a four\n * digit year. The pivot represents the year in the middle of the\n * supported range of years. Thus the full range of years that will\n * be built is <code>(pivot - 50) .. (pivot + 49)</code>.\n *\n * <pre>\n * pivot   supported range   00 is   20 is   40 is   60 is   80 is\n * ---------------------------------------------------------------\n * 1950      1900..1999      1900    1920    1940    1960    1980\n * 1975      1925..2024      2000    2020    1940    1960    1980\n * 2000      1950..2049      2000    2020    2040    1960    1980\n * 2025      1975..2074      2000    2020    2040    2060    1980\n * 2050      2000..2099      2000    2020    2040    2060    2080\n * </pre>\n *\n * @param pivotYear  the pivot year to use as an override when parsing\n * @return the new formatter\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 844, "method_signature": "DateTimeFormatter withPivotYear(Integer)"}, "DateTimeFormatter.withZone": {"callee_method_names": [], "method_name": "DateTimeFormatter.withZone", "method_implementation": "{\n    if (iZone == zone) {\n        return this;\n    }\n    return new DateTimeFormatter(iPrinter, iParser, iLocale, false, iChrono, zone, iPivotYear, iDefaultYear);\n}", "repo_id": "7", "comment": "/**\n * Returns a new formatter that will use the specified zone in preference\n * to the zone of the printed object, or default zone on a parse.\n * <p>\n * When printing, this zone will be used in preference to the zone\n * from the datetime that would otherwise be used.\n * <p>\n * When parsing, this zone will be set on the parsed datetime.\n * <p>\n * A null zone means of no-override.\n * If both an override chronology and an override zone are set, the\n * override zone will take precedence over the zone in the chronology.\n *\n * @param zone  the zone to use as an override\n * @return the new formatter\n */\n", "repo_name": "joda-time-main/", "id": 843, "method_signature": "DateTimeFormatter withZone(DateTimeZone)"}, "DateTimeFormatterBuilder.append": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.append", "method_implementation": "{\n    if (printer != null) {\n        checkPrinter(printer);\n    }\n    if (parsers == null) {\n        throw new IllegalArgumentException(\"No parsers supplied\");\n    }\n    int length = parsers.length;\n    if (length == 1) {\n        if (parsers[0] == null) {\n            throw new IllegalArgumentException(\"No parser supplied\");\n        }\n        return append0(DateTimePrinterInternalPrinter.of(printer), DateTimeParserInternalParser.of(parsers[0]));\n    }\n    InternalParser[] copyOfParsers = new InternalParser[length];\n    int i;\n    for (i = 0; i < length - 1; i++) {\n        if ((copyOfParsers[i] = DateTimeParserInternalParser.of(parsers[i])) == null) {\n            throw new IllegalArgumentException(\"Incomplete parser array\");\n        }\n    }\n    copyOfParsers[i] = DateTimeParserInternalParser.of(parsers[i]);\n    return append0(DateTimePrinterInternalPrinter.of(printer), new MatchingParser(copyOfParsers));\n}", "repo_id": "7", "comment": "/**\n * Appends a printer and a set of matching parsers. When parsing, the first\n * parser in the list is selected for parsing. If it fails, the next is\n * chosen, and so on. If none of these parsers succeeds, then the failed\n * position of the parser that made the greatest progress is returned.\n * <p>\n * Only the printer is optional. In addition, it is illegal for any but the\n * last of the parser array elements to be null. If the last element is\n * null, this represents the empty parser. The presence of an empty parser\n * indicates that the entire array of parse formats is optional.\n * <p>\n * The printer and parser interfaces are the low-level part of the formatting API.\n * Normally, instances are extracted from another formatter.\n * Note however that any formatter specific information, such as the locale,\n * time-zone, chronology, offset parsing or pivot/default year, will not be\n * extracted by this method.\n *\n * @param printer  the printer to add\n * @param parsers  the parsers to add\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if any printer or parser is of an invalid type\n * @throws IllegalArgumentException if any parser element but the last is null\n */\n", "repo_name": "joda-time-main/", "id": 916, "method_signature": "DateTimeFormatterBuilder append(DateTimePrinter, DateTimeParser[])"}, "DateTimeFormatterBuilder.appendDecimal": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.appendDecimal", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field type must not be null\");\n    }\n    if (maxDigits < minDigits) {\n        maxDigits = minDigits;\n    }\n    if (minDigits < 0 || maxDigits <= 0) {\n        throw new IllegalArgumentException();\n    }\n    if (minDigits <= 1) {\n        return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n    } else {\n        return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n    }\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit a field value as a decimal number, and the\n * parser to expect an unsigned decimal number.\n *\n * @param fieldType  type of field to append\n * @param minDigits  minimum number of digits to <i>print</i>\n * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n * maximum number of digits to print\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if field type is null\n */\n", "repo_name": "joda-time-main/", "id": 921, "method_signature": "DateTimeFormatterBuilder appendDecimal(DateTimeFieldType, int, int)"}, "DateTimeFormatterBuilder.appendFixedDecimal": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.appendFixedDecimal", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field type must not be null\");\n    }\n    if (numDigits <= 0) {\n        throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n    }\n    return append0(new FixedNumber(fieldType, numDigits, false));\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit a field value as a fixed-width decimal\n * number (smaller numbers will be left-padded with zeros), and the parser\n * to expect an unsigned decimal number with the same fixed width.\n *\n * @param fieldType  type of field to append\n * @param numDigits  the exact number of digits to parse or print, except if\n * printed value requires more digits\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 922, "method_signature": "DateTimeFormatterBuilder appendFixedDecimal(DateTimeFieldType, int)"}, "DateTimeFormatterBuilder.appendFixedSignedDecimal": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.appendFixedSignedDecimal", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field type must not be null\");\n    }\n    if (numDigits <= 0) {\n        throw new IllegalArgumentException(\"Illegal number of digits: \" + numDigits);\n    }\n    return append0(new FixedNumber(fieldType, numDigits, true));\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit a field value as a fixed-width decimal\n * number (smaller numbers will be left-padded with zeros), and the parser\n * to expect an signed decimal number with the same fixed width.\n *\n * @param fieldType  type of field to append\n * @param numDigits  the exact number of digits to parse or print, except if\n * printed value requires more digits\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if field type is null or if <code>numDigits <= 0</code>\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 924, "method_signature": "DateTimeFormatterBuilder appendFixedSignedDecimal(DateTimeFieldType, int)"}, "DateTimeFormatterBuilder.appendFraction": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.appendFraction", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field type must not be null\");\n    }\n    if (maxDigits < minDigits) {\n        maxDigits = minDigits;\n    }\n    if (minDigits < 0 || maxDigits <= 0) {\n        throw new IllegalArgumentException();\n    }\n    return append0(new Fraction(fieldType, minDigits, maxDigits));\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit a remainder of time as a decimal fraction,\n * without decimal point. For example, if the field is specified as\n * minuteOfHour and the time is 12:30:45, the value printed is 75. A\n * decimal point is implied, so the fraction is 0.75, or three-quarters of\n * a minute.\n *\n * @param fieldType  type of field to append\n * @param minDigits  minimum number of digits to print.\n * @param maxDigits  maximum number of digits to print or parse.\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if field type is null\n */\n", "repo_name": "joda-time-main/", "id": 927, "method_signature": "DateTimeFormatterBuilder appendFraction(DateTimeFieldType, int, int)"}, "DateTimeFormatterBuilder.appendLiteral": {"callee_method_names": ["String.length", "String.charAt"], "method_name": "DateTimeFormatterBuilder.appendLiteral", "method_implementation": "{\n    if (text == null) {\n        throw new IllegalArgumentException(\"Literal must not be null\");\n    }\n    switch(text.length()) {\n        case 0:\n            return this;\n        case 1:\n            return append0(new CharacterLiteral(text.charAt(0)));\n        default:\n            return append0(new StringLiteral(text));\n    }\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit specific text, and the parser to expect\n * it. The parser is case-insensitive.\n *\n * @param text the text\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if text is null\n */\n", "repo_name": "joda-time-main/", "id": 920, "method_signature": "DateTimeFormatterBuilder appendLiteral(String)"}, "DateTimeFormatterBuilder.appendOptional": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.appendOptional", "method_implementation": "{\n    checkParser(parser);\n    InternalParser[] parsers = new InternalParser[] { DateTimeParserInternalParser.of(parser), null };\n    return append0(null, new MatchingParser(parsers));\n}", "repo_id": "7", "comment": "/**\n * Appends just a parser element which is optional. With no matching\n * printer, a printer cannot be built from this DateTimeFormatterBuilder.\n * <p>\n * The parser interface is part of the low-level part of the formatting API.\n * Normally, instances are extracted from another formatter.\n * Note however that any formatter specific information, such as the locale,\n * time-zone, chronology, offset parsing or pivot/default year, will not be\n * extracted by this method.\n *\n * @param parser the parser\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if parser is null or of an invalid type\n */\n", "repo_name": "joda-time-main/", "id": 917, "method_signature": "DateTimeFormatterBuilder appendOptional(DateTimeParser)"}, "DateTimeFormatterBuilder.appendShortText": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.appendShortText", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field type must not be null\");\n    }\n    return append0(new TextField(fieldType, true));\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit a field value as short text, and the\n * parser to expect text.\n *\n * @param fieldType  type of field to append\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if field type is null\n */\n", "repo_name": "joda-time-main/", "id": 926, "method_signature": "DateTimeFormatterBuilder appendShortText(DateTimeFieldType)"}, "DateTimeFormatterBuilder.appendSignedDecimal": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.appendSignedDecimal", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field type must not be null\");\n    }\n    if (maxDigits < minDigits) {\n        maxDigits = minDigits;\n    }\n    if (minDigits < 0 || maxDigits <= 0) {\n        throw new IllegalArgumentException();\n    }\n    if (minDigits <= 1) {\n        return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n    } else {\n        return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n    }\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit a field value as a decimal number, and the\n * parser to expect a signed decimal number.\n *\n * @param fieldType  type of field to append\n * @param minDigits  minimum number of digits to <i>print</i>\n * @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated\n * maximum number of digits to print\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if field type is null\n */\n", "repo_name": "joda-time-main/", "id": 923, "method_signature": "DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType, int, int)"}, "DateTimeFormatterBuilder.appendText": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.appendText", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field type must not be null\");\n    }\n    return append0(new TextField(fieldType, false));\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit a field value as text, and the\n * parser to expect text.\n *\n * @param fieldType  type of field to append\n * @return this DateTimeFormatterBuilder, for chaining\n * @throws IllegalArgumentException if field type is null\n */\n", "repo_name": "joda-time-main/", "id": 925, "method_signature": "DateTimeFormatterBuilder appendText(DateTimeFieldType)"}, "DateTimeFormatterBuilder.appendTimeZoneOffset": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.appendTimeZoneOffset", "method_implementation": "{\n    return append0(new TimeZoneOffset(zeroOffsetPrintText, zeroOffsetParseText, showSeparators, minFields, maxFields));\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit text and numbers to display time zone\n * offset from UTC. A parser will use the parsed time zone offset to adjust\n * the datetime.\n * <p>\n * If zero offset print text is supplied, then it will be printed when the zone is zero.\n * If zero offset parse text is supplied, then either it or the offset will be parsed.\n *\n * @param zeroOffsetPrintText  the text to print if time zone offset is zero. If\n * null, offset is always shown.\n * @param zeroOffsetParseText  the text to optionally parse to indicate that the time\n * zone offset is zero. If null, then always use the offset.\n * @param showSeparators  if true, prints ':' separator before minute and\n * second field and prints '.' separator before fraction field.\n * @param minFields  minimum number of fields to print, stopping when no\n * more precision is required. 1=hours, 2=minutes, 3=seconds, 4=fraction\n * @param maxFields  maximum number of fields to print\n * @return this DateTimeFormatterBuilder, for chaining\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 929, "method_signature": "DateTimeFormatterBuilder appendTimeZoneOffset(String, String, boolean, int, int)"}, "DateTimeFormatterBuilder.checkParser": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.checkParser", "method_implementation": "{\n    if (parser == null) {\n        throw new IllegalArgumentException(\"No parser supplied\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks if the parser is non null and a provider.\n *\n * @param parser  the parser to check\n */\n", "repo_name": "joda-time-main/", "id": 918, "method_signature": "void checkParser(DateTimeParser)"}, "DateTimeFormatterBuilder.checkPrinter": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.checkPrinter", "method_implementation": "{\n    if (printer == null) {\n        throw new IllegalArgumentException(\"No printer supplied\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks if the printer is non null and a provider.\n *\n * @param printer  the printer to check\n */\n", "repo_name": "joda-time-main/", "id": 919, "method_signature": "void checkPrinter(DateTimePrinter)"}, "DateTimeFormatterBuilder.decompose": {"callee_method_names": ["List<Object>.size", "List<Object>.get", "List<Object>.add", "List<Object>.get", "List<Object>.add"], "method_name": "DateTimeFormatterBuilder.decompose", "method_implementation": "{\n    int size = elementPairs.size();\n    for (int i = 0; i < size; i += 2) {\n        Object element = elementPairs.get(i);\n        if (element instanceof Composite) {\n            addArrayToList(printerList, ((Composite) element).iPrinters);\n        } else {\n            printerList.add(element);\n        }\n        element = elementPairs.get(i + 1);\n        if (element instanceof Composite) {\n            addArrayToList(parserList, ((Composite) element).iParsers);\n        } else {\n            parserList.add(element);\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Processes the element pairs, putting results into the given printer\n * and parser lists.\n */\n", "repo_name": "joda-time-main/", "id": 932, "method_signature": "void decompose(List, List, List)"}, "DateTimeFormatterBuilder.digitCount": {"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "DateTimeFormatterBuilder.digitCount", "method_implementation": "{\n    int limit = Math.min(text.length() - position, amount);\n    amount = 0;\n    for (; limit > 0; limit--) {\n        char c = text.charAt(position + amount);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        amount++;\n    }\n    return amount;\n}", "repo_id": "7", "comment": "/**\n * Returns actual amount of digits to parse, but no more than original\n * 'amount' parameter.\n */\n", "repo_name": "joda-time-main/", "id": 931, "method_signature": "int digitCount(CharSequence, int, int)"}, "DateTimeFormatterBuilder.getFormatter": {"callee_method_names": ["ArrayList<Object>.size", "ArrayList<Object>.get", "ArrayList<Object>.get"], "method_name": "DateTimeFormatterBuilder.getFormatter", "method_implementation": "{\n    Object f = iFormatter;\n    if (f == null) {\n        if (iElementPairs.size() == 2) {\n            Object printer = iElementPairs.get(0);\n            Object parser = iElementPairs.get(1);\n            if (printer != null) {\n                if (printer == parser || parser == null) {\n                    f = printer;\n                }\n            } else {\n                f = parser;\n            }\n        }\n        if (f == null) {\n            f = new Composite(iElementPairs);\n        }\n        iFormatter = f;\n    }\n    return f;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 930, "method_signature": "Object getFormatter()"}, "DateTimeFormatterBuilder.toFormatter": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.toFormatter", "method_implementation": "{\n    Object f = getFormatter();\n    InternalPrinter printer = null;\n    if (isPrinter(f)) {\n        printer = (InternalPrinter) f;\n    }\n    InternalParser parser = null;\n    if (isParser(f)) {\n        parser = (InternalParser) f;\n    }\n    if (printer != null || parser != null) {\n        return new DateTimeFormatter(printer, parser);\n    }\n    throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n}", "repo_id": "7", "comment": "/**\n * Constructs a DateTimeFormatter using all the appended elements.\n * <p>\n * This is the main method used by applications at the end of the build\n * process to create a usable formatter.\n * <p>\n * Subsequent changes to this builder do not affect the returned formatter.\n * <p>\n * The returned formatter may not support both printing and parsing.\n * The methods {@link DateTimeFormatter#isPrinter()} and\n * {@link DateTimeFormatter#isParser()} will help you determine the state\n * of the formatter.\n *\n * @return the formatter\n * @throws UnsupportedOperationException if neither printing nor parsing is supported\n */\n", "repo_name": "joda-time-main/", "id": 911, "method_signature": "DateTimeFormatter toFormatter()"}, "DateTimeFormatterBuilder.toParser": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.toParser", "method_implementation": "{\n    Object f = getFormatter();\n    if (isParser(f)) {\n        InternalParser ip = (InternalParser) f;\n        return InternalParserDateTimeParser.of(ip);\n    }\n    throw new UnsupportedOperationException(\"Parsing is not supported\");\n}", "repo_id": "7", "comment": "/**\n * Internal method to create a DateTimeParser instance using all the\n * appended elements.\n * <p>\n * Most applications will not use this method.\n * If you want a parser in an application, call {@link #toFormatter()}\n * and just use the parsing API.\n * <p>\n * Subsequent changes to this builder do not affect the returned parser.\n *\n * @return the parser\n * @throws UnsupportedOperationException if parsing is not supported\n */\n", "repo_name": "joda-time-main/", "id": 913, "method_signature": "DateTimeParser toParser()"}, "DateTimeFormatterBuilder.toPrinter": {"callee_method_names": [], "method_name": "DateTimeFormatterBuilder.toPrinter", "method_implementation": "{\n    Object f = getFormatter();\n    if (isPrinter(f)) {\n        InternalPrinter ip = (InternalPrinter) f;\n        return InternalPrinterDateTimePrinter.of(ip);\n    }\n    throw new UnsupportedOperationException(\"Printing is not supported\");\n}", "repo_id": "7", "comment": "/**\n * Internal method to create a DateTimePrinter instance using all the\n * appended elements.\n * <p>\n * Most applications will not use this method.\n * If you want a printer in an application, call {@link #toFormatter()}\n * and just use the printing API.\n * <p>\n * Subsequent changes to this builder do not affect the returned printer.\n *\n * @return the printer\n * @throws UnsupportedOperationException if printing is not supported\n */\n", "repo_name": "joda-time-main/", "id": 912, "method_signature": "DateTimePrinter toPrinter()"}, "DateTimeOfYear.addCutover": {"callee_method_ids": [745], "callee_method_names": ["DateTimeZoneBuilder.addCutover"], "method_name": "DateTimeOfYear.addCutover", "method_implementation": "{\n    builder.addCutover(year, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay);\n}", "repo_id": "7", "comment": "/**\n * Adds a cutover to the builder.\n *\n * @param builder  the builder\n * @param year  the year\n */\n", "repo_name": "joda-time-main/", "id": 737, "method_signature": "void addCutover(DateTimeZoneBuilder, int)"}, "DateTimeOfYear.addRecurring": {"callee_method_ids": [746], "callee_method_names": ["DateTimeZoneBuilder.addRecurringSavings"], "method_name": "DateTimeOfYear.addRecurring", "method_implementation": "{\n    builder.addRecurringSavings(nameKey, saveMillis, fromYear, toYear, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay);\n}", "repo_id": "7", "comment": "/**\n * Adds a recurring savings rule to the builder.\n *\n * @param builder  the builder\n * @param nameKey  the name key\n * @param saveMillis  the save in millis\n * @param fromYear  the from year\n * @param toYear  the to year\n */\n", "repo_name": "joda-time-main/", "id": 736, "method_signature": "void addRecurring(DateTimeZoneBuilder, String, int, int, int)"}, "DateTimeParserBucket.compareTo": {"callee_method_names": ["DateTimeField.getRangeDurationField", "DateTimeField.getRangeDurationField", "DateTimeField.getDurationField", "DateTimeField.getDurationField"], "method_name": "DateTimeParserBucket.compareTo", "method_implementation": "{\n    DateTimeField other = obj.iField;\n    int result = compareReverse(iField.getRangeDurationField(), other.getRangeDurationField());\n    if (result != 0) {\n        return result;\n    }\n    return compareReverse(iField.getDurationField(), other.getDurationField());\n}", "repo_id": "7", "comment": "/**\n * The field with the longer range duration is ordered first, where\n * null is considered infinite. If the ranges match, then the field\n * with the longer duration is ordered first.\n */\n", "repo_name": "joda-time-main/", "id": 808, "method_signature": "int compareTo(SavedField)"}, "DateTimeParserBucket.computeMillis": {"callee_method_ids": [115, 114], "callee_method_names": ["SavedField[].clone", "SavedField[].set", "SavedField[].set", "Entry.prependMessage", "DateTimeZone.getOffsetFromLocal", "DateTimeZone.getOffset"], "method_name": "DateTimeParserBucket.computeMillis", "method_implementation": "{\n    SavedField[] savedFields = iSavedFields;\n    int count = iSavedFieldsCount;\n    if (iSavedFieldsShared) {\n        // clone so that sort does not affect saved state\n        iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();\n        iSavedFieldsShared = false;\n    }\n    sort(savedFields, count);\n    if (count > 0) {\n        // alter base year for parsing if first field is month or day\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n    long millis = iMillis;\n    try {\n        for (int i = 0; i < count; i++) {\n            millis = savedFields[i].set(millis, resetFields);\n        }\n        if (resetFields) {\n            for (int i = 0; i < count; i++) {\n                if (!savedFields[i].iField.isLenient()) {\n                    millis = savedFields[i].set(millis, i == (count - 1));\n                }\n            }\n        }\n    } catch (IllegalFieldValueException e) {\n        if (text != null) {\n            e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        }\n        throw e;\n    }\n    if (iOffset != null) {\n        millis -= iOffset;\n    } else if (iZone != null) {\n        int offset = iZone.getOffsetFromLocal(millis);\n        millis -= offset;\n        if (offset != iZone.getOffset(millis)) {\n            String message = \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n            if (text != null) {\n                message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n            }\n            throw new IllegalInstantException(message);\n        }\n    }\n    return millis;\n}", "repo_id": "7", "comment": "/**\n * Computes the parsed datetime by setting the saved fields.\n * This method is idempotent, but it is not thread-safe.\n *\n * @param resetFields false by default, but when true, unsaved field values are cleared\n * @param text optional text being parsed, to be included in any error message\n * @return milliseconds since 1970-01-01T00:00:00Z\n * @throws IllegalArgumentException if any field is out of range\n * @since 2.4\n */\n", "repo_name": "joda-time-main/", "id": 806, "method_signature": "long computeMillis(boolean, CharSequence)"}, "DateTimeParserBucket.reset": {"callee_method_names": [], "method_name": "DateTimeParserBucket.reset", "method_implementation": "{\n    iZone = iDefaultZone;\n    iOffset = null;\n    iPivotYear = iDefaultPivotYear;\n    iSavedFieldsCount = 0;\n    iSavedFieldsShared = false;\n    iSavedState = null;\n}", "repo_id": "7", "comment": "/**\n * Resets the state back to that when the object was constructed.\n * <p>\n * This resets the state of the bucket, allowing a single bucket to be re-used\n * for many parses. The bucket must not be shared between threads.\n *\n * @since 2.4\n */\n", "repo_name": "joda-time-main/", "id": 802, "method_signature": "void reset()"}, "DateTimeParserBucket.restoreState": {"callee_method_names": [], "method_name": "DateTimeParserBucket.restoreState", "method_implementation": "{\n    if (savedState instanceof SavedState) {\n        if (((SavedState) savedState).restoreState(this)) {\n            iSavedState = savedState;\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Restores the state of this bucket from a previously saved state. The\n * state object passed into this method is not consumed, and it can be used\n * later to restore to that state again.\n *\n * @param savedState opaque saved state, returned from saveState\n * @return true state object is valid and state restored\n */\n", "repo_name": "joda-time-main/", "id": 805, "method_signature": "boolean restoreState(Object)"}, "DateTimeParserBucket.saveState": {"callee_method_names": [], "method_name": "DateTimeParserBucket.saveState", "method_implementation": "{\n    if (iSavedState == null) {\n        iSavedState = new SavedState();\n    }\n    return iSavedState;\n}", "repo_id": "7", "comment": "/**\n * Saves the state of this bucket, returning it in an opaque object. Call\n * restoreState to undo any changes that were made since the state was\n * saved. Calls to saveState may be nested.\n *\n * @return opaque saved state, which may be passed to restoreState\n */\n", "repo_name": "joda-time-main/", "id": 804, "method_signature": "Object saveState()"}, "DateTimeParserBucket.setOffset": {"callee_method_names": [], "method_name": "DateTimeParserBucket.setOffset", "method_implementation": "{\n    iSavedState = null;\n    iOffset = offset;\n}", "repo_id": "7", "comment": "/**\n * Set a time zone offset to be used when computeMillis is called.\n *\n * @param offset the offset\n * @deprecated use Integer version\n */\n", "repo_name": "joda-time-main/", "id": 803, "method_signature": "void setOffset(int)"}, "DateTimeParserBucket.sort": {"callee_method_names": [], "method_name": "DateTimeParserBucket.sort", "method_implementation": "{\n    if (high > 10) {\n        Arrays.sort(array, 0, high);\n    } else {\n        for (int i = 0; i < high; i++) {\n            for (int j = i; j > 0 && (array[j - 1]).compareTo(array[j]) > 0; j--) {\n                SavedField t = array[j];\n                array[j] = array[j - 1];\n                array[j - 1] = t;\n            }\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Sorts elements [0,high). Calling java.util.Arrays isn't always the right\n * choice since it always creates an internal copy of the array, even if it\n * doesn't need to. If the array slice is small enough, an insertion sort\n * is chosen instead, but it doesn't need a copy!\n * <p>\n * This method has a modified version of that insertion sort, except it\n * doesn't create an unnecessary array copy. If high is over 10, then\n * java.util.Arrays is called, which will perform a merge sort, which is\n * faster than insertion sort on large lists.\n * <p>\n * The end result is much greater performance when computeMillis is called.\n * Since the amount of saved fields is small, the insertion sort is a\n * better choice. Additional performance is gained since there is no extra\n * array allocation and copying. Also, the insertion sort here does not\n * perform any casting operations. The version in java.util.Arrays performs\n * casts within the insertion sort loop.\n */\n", "repo_name": "joda-time-main/", "id": 807, "method_signature": "void sort(SavedField[], int)"}, "DateTimePerformance.end": {"callee_method_names": [], "method_name": "DateTimePerformance.end", "method_implementation": "{\n    end = System.currentTimeMillis();\n    long time = (end - start);\n    result.time = result.time + time;\n    result.runs = result.runs + count;\n    result.avg = (result.time * 1000000) / result.runs;\n    System.out.print(\".\");\n}", "repo_id": "7", "comment": "/**\n * End the stopwatch and print the result.\n */\n", "repo_name": "joda-time-main/", "id": 1058, "method_signature": "void end(int)"}, "DateTimePerformance.main": {"callee_method_names": [], "method_name": "DateTimePerformance.main", "method_implementation": "{\n    try {\n        new DateTimePerformance();\n    } catch (Throwable th) {\n        th.printStackTrace();\n    }\n}", "repo_id": "7", "comment": "/**\n * Constructor\n */\n", "repo_name": "joda-time-main/", "id": 1056, "method_signature": "void main(String[])"}, "DateTimePerformance.start": {"callee_method_names": ["HashMap.get", "HashMap.put", "ArrayList.add"], "method_name": "DateTimePerformance.start", "method_implementation": "{\n    result = (Result) results.get(str1 + str2);\n    if (result == null) {\n        result = new Result();\n        result.object = str1;\n        result.name = str2;\n        results.put(str1 + str2, result);\n        resultList.add(result);\n    }\n    start = System.currentTimeMillis();\n}", "repo_id": "7", "comment": "/**\n * Start the stopwatch.\n */\n", "repo_name": "joda-time-main/", "id": 1057, "method_signature": "void start(String, String)"}, "DateTimeUtils.checkPermission": {"callee_method_names": ["SecurityManager.checkPermission"], "method_name": "DateTimeUtils.checkPermission", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.\n *\n * @throws SecurityException if the provider may not be changed\n */\n", "repo_name": "joda-time-main/", "id": 383, "method_signature": "void checkPermission()"}, "DateTimeUtils.getChronology": {"callee_method_names": [], "method_name": "DateTimeUtils.getChronology", "method_implementation": "{\n    if (chrono == null) {\n        return ISOChronology.getInstance();\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets the chronology handling null.\n * <p>\n * If the chronology is <code>null</code>, {@link ISOChronology#getInstance()}\n * will be returned. Otherwise, the chronology is returned.\n *\n * @param chrono  the chronology to use, null means ISO in the default zone\n * @return the chronology, never null\n */\n", "repo_name": "joda-time-main/", "id": 389, "method_signature": "Chronology getChronology(Chronology)"}, "DateTimeUtils.getDateFormatSymbols": {"callee_method_names": ["Method.invoke"], "method_name": "DateTimeUtils.getDateFormatSymbols", "method_implementation": "{\n    try {\n        Method method = DateFormatSymbols.class.getMethod(\"getInstance\", new Class[] { Locale.class });\n        return (DateFormatSymbols) method.invoke(null, new Object[] { locale });\n    } catch (Exception ex) {\n        return new DateFormatSymbols(locale);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the {@link DateFormatSymbols} based on the given locale.\n * <p>\n * If JDK 6 or newer is being used, DateFormatSymbols.getInstance(locale) will\n * be used in order to allow the use of locales defined as extensions.\n * Otherwise, new DateFormatSymbols(locale) will be used.\n * See JDK 6 {@link DateFormatSymbols} for further information.\n *\n * @param locale  the {@link Locale} used to get the correct {@link DateFormatSymbols}\n * @return the symbols\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 394, "method_signature": "DateFormatSymbols getDateFormatSymbols(Locale)"}, "DateTimeUtils.getDefaultTimeZoneNames": {"callee_method_names": ["AtomicReference.get", "AtomicReference.compareAndSet", "AtomicReference.get"], "method_name": "DateTimeUtils.getDefaultTimeZoneNames", "method_implementation": "{\n    Map<String, DateTimeZone> names = cZoneNames.get();\n    if (names == null) {\n        names = buildDefaultTimeZoneNames();\n        if (!cZoneNames.compareAndSet(null, names)) {\n            names = cZoneNames.get();\n        }\n    }\n    return names;\n}", "repo_id": "7", "comment": "/**\n * Gets the default map of time zone names.\n * <p>\n * This can be changed by {@link #setDefaultTimeZoneNames}.\n * <p>\n * The default set of short time zone names is as follows:\n * <ul>\n * <li>UT - UTC\n * <li>UTC - UTC\n * <li>GMT - UTC\n * <li>EST - America/New_York\n * <li>EDT - America/New_York\n * <li>CST - America/Chicago\n * <li>CDT - America/Chicago\n * <li>MST - America/Denver\n * <li>MDT - America/Denver\n * <li>PST - America/Los_Angeles\n * <li>PDT - America/Los_Angeles\n * </ul>\n *\n * @return the unmodifiable map of abbreviations to zones, not null\n * @since 2.2\n */\n", "repo_name": "joda-time-main/", "id": 395, "method_signature": "Map<String,DateTimeZone> getDefaultTimeZoneNames()"}, "DateTimeUtils.getDurationMillis": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "DateTimeUtils.getDurationMillis", "method_implementation": "{\n    if (duration == null) {\n        return 0L;\n    }\n    return duration.getMillis();\n}", "repo_id": "7", "comment": "/**\n * Gets the millisecond duration from the specified duration object handling null.\n * <p>\n * If the duration object is <code>null</code>, zero will be returned.\n * Otherwise, the millis from the object are returned.\n *\n * @param duration  the duration to examine, null means zero\n * @return the duration in milliseconds\n */\n", "repo_name": "joda-time-main/", "id": 392, "method_signature": "long getDurationMillis(ReadableDuration)"}, "DateTimeUtils.getInstantChronology": {"callee_method_names": ["ReadableInstant.getChronology"], "method_name": "DateTimeUtils.getInstantChronology", "method_implementation": "{\n    if (instant == null) {\n        return ISOChronology.getInstance();\n    }\n    Chronology chrono = instant.getChronology();\n    if (chrono == null) {\n        return ISOChronology.getInstance();\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets the chronology from the specified instant object handling null.\n * <p>\n * If the instant object is <code>null</code>, or the instant's chronology is\n * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n * Otherwise, the chronology from the object is returned.\n *\n * @param instant  the instant to examine, null means ISO in the default zone\n * @return the chronology, never null\n */\n", "repo_name": "joda-time-main/", "id": 385, "method_signature": "Chronology getInstantChronology(ReadableInstant)"}, "DateTimeUtils.getInstantMillis": {"callee_method_names": ["ReadableInstant.getMillis"], "method_name": "DateTimeUtils.getInstantMillis", "method_implementation": "{\n    if (instant == null) {\n        return DateTimeUtils.currentTimeMillis();\n    }\n    return instant.getMillis();\n}", "repo_id": "7", "comment": "/**\n * Gets the millisecond instant from the specified instant object handling null.\n * <p>\n * If the instant object is <code>null</code>, the {@link #currentTimeMillis()}\n * will be returned. Otherwise, the millis from the object are returned.\n *\n * @param instant  the instant to examine, null means now\n * @return the time in milliseconds from 1970-01-01T00:00:00Z\n */\n", "repo_name": "joda-time-main/", "id": 384, "method_signature": "long getInstantMillis(ReadableInstant)"}, "DateTimeUtils.getIntervalChronology": {"callee_method_names": ["ReadableInterval.getChronology"], "method_name": "DateTimeUtils.getIntervalChronology", "method_implementation": "{\n    if (interval == null) {\n        return ISOChronology.getInstance();\n    }\n    Chronology chrono = interval.getChronology();\n    if (chrono == null) {\n        return ISOChronology.getInstance();\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets the chronology from the specified interval object handling null.\n * <p>\n * If the interval object is <code>null</code>, or the interval's chronology is\n * <code>null</code>, {@link ISOChronology#getInstance()} will be returned.\n * Otherwise, the chronology from the object is returned.\n *\n * @param interval  the interval to examine, null means ISO in the default zone\n * @return the chronology, never null\n */\n", "repo_name": "joda-time-main/", "id": 387, "method_signature": "Chronology getIntervalChronology(ReadableInterval)"}, "DateTimeUtils.getPeriodType": {"callee_method_names": [], "method_name": "DateTimeUtils.getPeriodType", "method_implementation": "{\n    if (type == null) {\n        return PeriodType.standard();\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets the period type handling null.\n * <p>\n * If the zone is <code>null</code>, {@link PeriodType#standard()}\n * will be returned. Otherwise, the type specified is returned.\n *\n * @param type  the time zone to use, null means the standard type\n * @return the type to use, never null\n */\n", "repo_name": "joda-time-main/", "id": 391, "method_signature": "PeriodType getPeriodType(PeriodType)"}, "DateTimeUtils.getReadableInterval": {"callee_method_names": [], "method_name": "DateTimeUtils.getReadableInterval", "method_implementation": "{\n    if (interval == null) {\n        long now = DateTimeUtils.currentTimeMillis();\n        interval = new Interval(now, now);\n    }\n    return interval;\n}", "repo_id": "7", "comment": "/**\n * Gets the interval handling null.\n * <p>\n * If the interval is <code>null</code>, an interval representing now\n * to now in the {@link ISOChronology#getInstance() ISOChronology}\n * will be returned. Otherwise, the interval specified is returned.\n *\n * @param interval  the interval to use, null means now to now\n * @return the interval, never null\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 388, "method_signature": "ReadableInterval getReadableInterval(ReadableInterval)"}, "DateTimeUtils.getZone": {"callee_method_names": [], "method_name": "DateTimeUtils.getZone", "method_implementation": "{\n    if (zone == null) {\n        return DateTimeZone.getDefault();\n    }\n    return zone;\n}", "repo_id": "7", "comment": "/**\n * Gets the zone handling null.\n * <p>\n * If the zone is <code>null</code>, {@link DateTimeZone#getDefault()}\n * will be returned. Otherwise, the zone specified is returned.\n *\n * @param zone  the time zone to use, null means the default zone\n * @return the time zone, never null\n */\n", "repo_name": "joda-time-main/", "id": 390, "method_signature": "DateTimeZone getZone(DateTimeZone)"}, "DateTimeUtils.isContiguous": {"callee_method_names": ["ReadablePartial.size", "ReadablePartial.getField", "DateTimeField.getRangeDurationField", "DateTimeField.getRangeDurationField", "DateTimeField.getDurationField"], "method_name": "DateTimeUtils.isContiguous", "method_implementation": "{\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    DurationFieldType lastType = null;\n    for (int i = 0; i < partial.size(); i++) {\n        DateTimeField loopField = partial.getField(i);\n        if (i > 0) {\n            if (loopField.getRangeDurationField() == null || loopField.getRangeDurationField().getType() != lastType) {\n                return false;\n            }\n        }\n        lastType = loopField.getDurationField().getType();\n    }\n    return true;\n}", "repo_id": "7", "comment": "/**\n * Checks whether the partial is contiguous.\n * <p>\n * A partial is contiguous if one field starts where another ends.\n * <p>\n * For example <code>LocalDate</code> is contiguous because DayOfMonth has\n * the same range (Month) as the unit of the next field (MonthOfYear), and\n * MonthOfYear has the same range (Year) as the unit of the next field (Year).\n * <p>\n * Similarly, <code>LocalTime</code> is contiguous, as it consists of\n * MillisOfSecond, SecondOfMinute, MinuteOfHour and HourOfDay (note how\n * the names of each field 'join up').\n * <p>\n * However, a Year/HourOfDay partial is not contiguous because the range\n * field Day is not equal to the next field Year.\n * Similarly, a DayOfWeek/DayOfMonth partial is not contiguous because\n * the range Month is not equal to the next field Day.\n *\n * @param partial  the partial to check\n * @return true if the partial is contiguous\n * @throws IllegalArgumentException if the partial is null\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 393, "method_signature": "boolean isContiguous(ReadablePartial)"}, "DateTimeUtils.setCurrentMillisOffset": {"callee_method_names": [], "method_name": "DateTimeUtils.setCurrentMillisOffset", "method_implementation": "{\n    checkPermission();\n    if (offsetMillis == 0) {\n        cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n    } else {\n        cMillisProvider = new OffsetMillisProvider(offsetMillis);\n    }\n}", "repo_id": "7", "comment": "/**\n * Sets the current time to return the system time plus an offset.\n * <p>\n * This method changes the behaviour of {@link #currentTimeMillis()}.\n * Whenever the current time is queried, {@link System#currentTimeMillis()} is used\n * and then offset by adding the millisecond value specified here.\n *\n * @param offsetMillis  the fixed millisecond time to use\n * @throws SecurityException if the application does not have sufficient security rights\n */\n", "repo_name": "joda-time-main/", "id": 381, "method_signature": "void setCurrentMillisOffset(long)"}, "DateTimeUtils.setCurrentMillisProvider": {"callee_method_names": [], "method_name": "DateTimeUtils.setCurrentMillisProvider", "method_implementation": "{\n    if (millisProvider == null) {\n        throw new IllegalArgumentException(\"The MillisProvider must not be null\");\n    }\n    checkPermission();\n    cMillisProvider = millisProvider;\n}", "repo_id": "7", "comment": "/**\n * Sets the provider of the current time to class specified.\n * <p>\n * This method changes the behaviour of {@link #currentTimeMillis()}.\n * Whenever the current time is queried, the specified class will be called.\n *\n * @param millisProvider  the provider of the current time to use, not null\n * @throws SecurityException if the application does not have sufficient security rights\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 382, "method_signature": "void setCurrentMillisProvider(MillisProvider)"}, "DateTimeUtils.toJulianDay": {"callee_method_names": [], "method_name": "DateTimeUtils.toJulianDay", "method_implementation": "{\n    // useful links\n    // https://en.wikipedia.org/wiki/Julian_day#cite_note-13 - Wikipedia\n    // http://aa.usno.navy.mil/data/docs/JulianDate.php\" - USNO\n    // http://users.zoominternet.net/~matto/Java/Julian%20Date%20Converter.htm - Julian Date Converter by Matt Oltersdorf\n    // http://ssd.jpl.nasa.gov/tc.cgi#top - CalTech\n    double epochDay = epochMillis / 86400000d;\n    return epochDay + 2440587.5d;\n}", "repo_id": "7", "comment": "/**\n * Calculates the astronomical Julian Day for an instant.\n * <p>\n * The <a href=\"https://en.wikipedia.org/wiki/Julian_day\">Julian day</a> is a well-known\n * system of time measurement for scientific use by the astronomy community.\n * It expresses the interval of time in days and fractions of a day since\n * January 1, 4713 BC (Julian) Greenwich noon.\n * <p>\n * Each day starts at midday (not midnight) and time is expressed as a fraction.\n * Thus the fraction 0.25 is 18:00. equal to one quarter of the day from midday to midday.\n * <p>\n * Note that this method has nothing to do with the day-of-year.\n *\n * @param epochMillis  the epoch millis from 1970-01-01Z\n * @return the astronomical Julian Day represented by the specified instant\n * @since 2.2\n */\n", "repo_name": "joda-time-main/", "id": 396, "method_signature": "double toJulianDay(long)"}, "DateTimeZone.adjustOffset": {"callee_method_names": [], "method_name": "DateTimeZone.adjustOffset", "method_implementation": "{\n    // a bit messy, but will work in all non-pathological cases\n    // evaluate 3 hours before and after to work out if anything is happening\n    long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n    long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR;\n    long offsetBefore = getOffset(instantBefore);\n    long offsetAfter = getOffset(instantAfter);\n    if (offsetBefore <= offsetAfter) {\n        // not an overlap (less than is a gap, equal is normal case)\n        return instant;\n    }\n    // work out range of instants that have duplicate local times\n    long diff = offsetBefore - offsetAfter;\n    long transition = nextTransition(instantBefore);\n    long overlapStart = transition - diff;\n    long overlapEnd = transition + diff;\n    if (instant < overlapStart || instant >= overlapEnd) {\n        // not an overlap\n        return instant;\n    }\n    // calculate result\n    long afterStart = instant - overlapStart;\n    if (afterStart >= diff) {\n        // currently in later offset\n        return earlierOrLater ? instant : instant - diff;\n    } else {\n        // currently in earlier offset\n        return earlierOrLater ? instant + diff : instant;\n    }\n}", "repo_id": "7", "comment": "/**\n * Adjusts the offset to be the earlier or later one during an overlap.\n *\n * @param instant  the instant to adjust\n * @param earlierOrLater  false for earlier, true for later\n * @return the adjusted instant millis\n */\n", "repo_name": "joda-time-main/", "id": 121, "method_signature": "long adjustOffset(long, boolean)"}, "DateTimeZone.convertLocalToUTC": {"callee_method_names": [], "method_name": "DateTimeZone.convertLocalToUTC", "method_implementation": "{\n    // get the offset at instantLocal (first estimate)\n    int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    int offset = getOffset(instantLocal - offsetLocal);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offset) {\n        // if strict then always check if in DST gap\n        // otherwise only check if zone in Western hemisphere (as the\n        // value of offset is already correct for Eastern hemisphere)\n        if (strict || offsetLocal < 0) {\n            // determine if we are in the DST gap\n            long nextLocal = nextTransition(instantLocal - offsetLocal);\n            if (nextLocal == (instantLocal - offsetLocal)) {\n                nextLocal = Long.MAX_VALUE;\n            }\n            long nextAdjusted = nextTransition(instantLocal - offset);\n            if (nextAdjusted == (instantLocal - offset)) {\n                nextAdjusted = Long.MAX_VALUE;\n            }\n            if (nextLocal != nextAdjusted) {\n                // yes we are in the DST gap\n                if (strict) {\n                    // DST gap is not acceptable\n                    throw new IllegalInstantException(instantLocal, getID());\n                } else {\n                    // DST gap is acceptable, but for the Western hemisphere\n                    // the offset is wrong and will result in local times\n                    // before the cutover so use the offsetLocal instead\n                    offset = offsetLocal;\n                }\n            }\n        }\n    }\n    // check for overflow\n    long instantUTC = instantLocal - offset;\n    // If there is a sign change, but the two values have different signs...\n    if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n        throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n    }\n    return instantUTC;\n}", "repo_id": "7", "comment": "/**\n * Converts a local instant to an actual UTC instant with the same\n * local time. This conversion is used after performing a calculation\n * where the calculation was done using a simple local zone.\n *\n * @param instantLocal  the local instant to convert to UTC\n * @param strict  whether the conversion should reject non-existent local times\n * @return the UTC instant with the same local time,\n * @throws ArithmeticException if the result overflows a long\n * @throws IllegalInstantException if the zone has no equivalent local time\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 118, "method_signature": "long convertLocalToUTC(long, boolean)"}, "DateTimeZone.convertUTCToLocal": {"callee_method_names": [], "method_name": "DateTimeZone.convertUTCToLocal", "method_implementation": "{\n    int offset = getOffset(instantUTC);\n    long instantLocal = instantUTC + offset;\n    // If there is a sign change, but the two values have the same sign...\n    if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n        throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n    }\n    return instantLocal;\n}", "repo_id": "7", "comment": "/**\n * Converts an actual UTC instant to a local instant with the same\n * local time. This conversion is used before performing a calculation\n * so that the calculation can be done using a simple local zone.\n *\n * @param instantUTC  the UTC instant to convert to local\n * @return the local instant with the same local time\n * @throws ArithmeticException if the result overflows a long\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 116, "method_signature": "long convertUTCToLocal(long)"}, "DateTimeZone.fixedOffsetZone": {"callee_method_names": [], "method_name": "DateTimeZone.fixedOffsetZone", "method_implementation": "{\n    if (offset == 0) {\n        return DateTimeZone.UTC;\n    }\n    return new FixedDateTimeZone(id, null, offset, offset);\n}", "repo_id": "7", "comment": "/**\n * Gets the zone using a fixed offset amount.\n *\n * @param id  the zone id\n * @param offset  the offset in millis\n * @return the zone\n */\n", "repo_name": "joda-time-main/", "id": 103, "method_signature": "DateTimeZone fixedOffsetZone(String, int)"}, "DateTimeZone.forID": {"callee_method_names": ["String.equals", "String.equals", "String.equals", "String.equals", "String.startsWith", "String.startsWith", "String.startsWith", "String.startsWith", "String.substring", "String.startsWith", "String.startsWith", "String.substring", "String.startsWith", "String.startsWith"], "method_name": "DateTimeZone.forID", "method_implementation": "{\n    if (id == null) {\n        return getDefault();\n    }\n    if (id.equals(\"UTC\")) {\n        return DateTimeZone.UTC;\n    }\n    DateTimeZone zone = getProvider().getZone(id);\n    if (zone != null) {\n        return zone;\n    }\n    // compatibility with more ZoneId values\n    // note that GMT normally matches to Etc/GMT in the block above, but if the\n    // time-zone provider has been replaced and does not match GMT then this line will\n    if (id.equals(\"UT\") || id.equals(\"GMT\") || id.equals(\"Z\")) {\n        return DateTimeZone.UTC;\n    }\n    String idToParse = id;\n    if (id.startsWith(\"UTC+\") || id.startsWith(\"UTC-\") || id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n        idToParse = id.substring(3);\n    } else if (id.startsWith(\"UT+\") || id.startsWith(\"UT-\")) {\n        idToParse = id.substring(2);\n    }\n    if (idToParse.startsWith(\"+\") || idToParse.startsWith(\"-\")) {\n        int offset = parseOffset(idToParse);\n        if (offset == 0L) {\n            return DateTimeZone.UTC;\n        } else {\n            idToParse = printOffset(offset);\n            return fixedOffsetZone(idToParse, offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}", "repo_id": "7", "comment": "/**\n * Gets a time zone instance for the specified time zone id.\n * <p>\n * The time zone id may be one of those returned by getAvailableIDs.\n * Short ids, as accepted by {@link java.util.TimeZone}, are not accepted.\n * All IDs must be specified in the long format unless detailed below.\n * <p>\n * A locale independent, fixed offset, datetime zone can be specified\n * using the form <code>[+-]hh:mm</code>.\n * The offset may be prefixed by 'UTC', 'GMT' or 'UT'.\n * In addition, the IDs 'Z', 'UTC', 'GMT' and 'UT' will return a UTC\n * equivalent time-zone.\n *\n * @param id  the ID of the datetime zone, null means default\n * @return the DateTimeZone object for the ID\n * @throws IllegalArgumentException if the ID is not recognised\n */\n", "repo_name": "joda-time-main/", "id": 99, "method_signature": "DateTimeZone forID(String)"}, "DateTimeZone.forOffsetHoursMinutes": {"callee_method_names": [], "method_name": "DateTimeZone.forOffsetHoursMinutes", "method_implementation": "{\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}", "repo_id": "7", "comment": "/**\n * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n * This method assumes 60 minutes in an hour, and standard length minutes.\n * <p>\n * This factory is a convenient way of constructing zones with a fixed offset.\n * The hours value must be in the range -23 to +23.\n * The minutes value must be in the range -59 to +59.\n * The following combinations of sign for the hour and minute are possible:\n * <pre>\n *  Hour    Minute    Example    Result\n *\n *  +ve     +ve       (2, 15)    +02:15\n *  +ve     zero      (2, 0)     +02:00\n *  +ve     -ve       (2, -15)   IllegalArgumentException\n *\n *  zero    +ve       (0, 15)    +00:15\n *  zero    zero      (0, 0)     +00:00\n *  zero    -ve       (0, -15)   -00:15\n *\n *  -ve     +ve       (-2, 15)   -02:15\n *  -ve     zero      (-2, 0)    -02:00\n *  -ve     -ve       (-2, -15)  -02:15\n * </pre>\n * Note that in versions before 2.3, the minutes had to be zero or positive.\n *\n * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n * @return the DateTimeZone object for the offset\n * @throws IllegalArgumentException if any value is out of range, the minutes are negative\n *  when the hours are positive, or the resulting offset exceeds +/- 23:59:59.000\n */\n", "repo_name": "joda-time-main/", "id": 100, "method_signature": "DateTimeZone forOffsetHoursMinutes(int, int)"}, "DateTimeZone.forOffsetMillis": {"callee_method_names": [], "method_name": "DateTimeZone.forOffsetMillis", "method_implementation": "{\n    if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\n        throw new IllegalArgumentException(\"Millis out of range: \" + millisOffset);\n    }\n    String id = printOffset(millisOffset);\n    return fixedOffsetZone(id, millisOffset);\n}", "repo_id": "7", "comment": "/**\n * Gets a time zone instance for the specified offset to UTC in milliseconds.\n *\n * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n * @return the DateTimeZone object for the offset\n */\n", "repo_name": "joda-time-main/", "id": 101, "method_signature": "DateTimeZone forOffsetMillis(int)"}, "DateTimeZone.forTimeZone": {"callee_method_names": ["TimeZone.getID", "String.equals", "Provider.getZone", "Provider.getZone", "String.startsWith", "String.startsWith", "String.substring", "String.length", "String.charAt"], "method_name": "DateTimeZone.forTimeZone", "method_implementation": "{\n    if (zone == null) {\n        return getDefault();\n    }\n    final String id = zone.getID();\n    if (id == null) {\n        throw new IllegalArgumentException(\"The TimeZone id must not be null\");\n    }\n    if (id.equals(\"UTC\")) {\n        return DateTimeZone.UTC;\n    }\n    // Convert from old alias before consulting provider since they may differ.\n    DateTimeZone dtz = null;\n    String convId = getConvertedId(id);\n    Provider provider = getProvider();\n    if (convId != null) {\n        dtz = provider.getZone(convId);\n    }\n    if (dtz == null) {\n        dtz = provider.getZone(id);\n    }\n    if (dtz != null) {\n        return dtz;\n    }\n    // Support GMT+/-hh:mm formats\n    if (convId == null) {\n        convId = id;\n        if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n            convId = convId.substring(3);\n            if (convId.length() > 2) {\n                char firstDigit = convId.charAt(1);\n                if (firstDigit > '9' && Character.isDigit(firstDigit)) {\n                    convId = convertToAsciiNumber(convId);\n                }\n            }\n            int offset = parseOffset(convId);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                convId = printOffset(offset);\n                return fixedOffsetZone(convId, offset);\n            }\n        }\n    }\n    throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}", "repo_id": "7", "comment": "/**\n * Gets a time zone instance for a JDK TimeZone.\n * <p>\n * DateTimeZone only accepts a subset of the IDs from TimeZone. The\n * excluded IDs are the short three letter form (except UTC). This\n * method will attempt to convert between time zones created using the\n * short IDs and the full version.\n * <p>\n * This method is not designed to parse time zones with rules created by\n * applications using <code>SimpleTimeZone</code> directly.\n *\n * @param zone  the zone to convert, null means default\n * @return the DateTimeZone object for the zone\n * @throws IllegalArgumentException if the zone is not recognised\n */\n", "repo_name": "joda-time-main/", "id": 102, "method_signature": "DateTimeZone forTimeZone(TimeZone)"}, "DateTimeZone.getDefault": {"callee_method_names": ["AtomicReference.get", "AtomicReference.compareAndSet", "AtomicReference.get"], "method_name": "DateTimeZone.getDefault", "method_implementation": "{\n    DateTimeZone zone = cDefault.get();\n    if (zone == null) {\n        try {\n            try {\n                String id = System.getProperty(\"org.joda.time.DateTimeZone.Timezone\");\n                if (id != null) {\n                    // null check avoids stack overflow\n                    zone = forID(id);\n                }\n            } catch (RuntimeException ex) {\n                // ignored\n            }\n            if (zone == null) {\n                zone = forTimeZone(TimeZone.getDefault());\n            }\n        } catch (IllegalArgumentException ex) {\n            // ignored\n        }\n        if (zone == null) {\n            zone = UTC;\n        }\n        if (!cDefault.compareAndSet(null, zone)) {\n            zone = cDefault.get();\n        }\n    }\n    return zone;\n}", "repo_id": "7", "comment": "/**\n * Gets the default time zone.\n * <p>\n * The default time zone is derived from the system property {@code org.joda.time.DateTimeZone.Timezone}.\n * If that is {@code null} or is not a valid identifier, then the value of the\n * JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used.\n * <p>\n * NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this\n * method, then the change will not be picked up here.\n * <p>\n * NOTE: This previously checked the {@code user.timezone} property, see issue #587.\n *\n * @return the default datetime zone object\n */\n", "repo_name": "joda-time-main/", "id": 97, "method_signature": "DateTimeZone getDefault()"}, "DateTimeZone.getDefaultNameProvider": {"callee_method_names": ["Class<?>.asSubclass"], "method_name": "DateTimeZone.getDefaultNameProvider", "method_implementation": "{\n    NameProvider nameProvider = null;\n    try {\n        String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n        if (providerClass != null) {\n            try {\n                // do not initialize the class until the type has been checked\n                Class<?> cls = Class.forName(providerClass, false, DateTimeZone.class.getClassLoader());\n                if (!NameProvider.class.isAssignableFrom(cls)) {\n                    throw new IllegalArgumentException(\"System property referred to class that does not implement \" + NameProvider.class);\n                }\n                nameProvider = cls.asSubclass(NameProvider.class).getConstructor().newInstance();\n            } catch (Exception ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n    } catch (SecurityException ex) {\n        // ignore\n    }\n    if (nameProvider == null) {\n        nameProvider = new DefaultNameProvider();\n    }\n    return nameProvider;\n}", "repo_id": "7", "comment": "/**\n * Gets the default name provider.\n * <p>\n * Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>.\n * Then uses <code>DefaultNameProvider</code>.\n *\n * @return the default name provider\n */\n", "repo_name": "joda-time-main/", "id": 110, "method_signature": "NameProvider getDefaultNameProvider()"}, "DateTimeZone.getDefaultProvider": {"callee_method_names": ["Class<?>.asSubclass"], "method_name": "DateTimeZone.getDefaultProvider", "method_implementation": "{\n    // approach 1\n    try {\n        String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n        if (providerClass != null) {\n            try {\n                // do not initialize the class until the type has been checked\n                Class<?> cls = Class.forName(providerClass, false, DateTimeZone.class.getClassLoader());\n                if (!Provider.class.isAssignableFrom(cls)) {\n                    throw new IllegalArgumentException(\"System property referred to class that does not implement \" + Provider.class);\n                }\n                Provider provider = cls.asSubclass(Provider.class).getConstructor().newInstance();\n                return validateProvider(provider);\n            } catch (Exception ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n    } catch (SecurityException ex) {\n        // ignored\n    }\n    // approach 2\n    try {\n        String dataFolder = System.getProperty(\"org.joda.time.DateTimeZone.Folder\");\n        if (dataFolder != null) {\n            try {\n                Provider provider = new ZoneInfoProvider(new File(dataFolder));\n                return validateProvider(provider);\n            } catch (Exception ex) {\n                throw new RuntimeException(ex);\n            }\n        }\n    } catch (SecurityException ex) {\n        // ignored\n    }\n    // approach 3\n    try {\n        Provider provider = new ZoneInfoProvider(DEFAULT_TZ_DATA_PATH);\n        return validateProvider(provider);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    // approach 4\n    return new UTCProvider();\n}", "repo_id": "7", "comment": "/**\n * Gets the default zone provider.\n * <p>\n * This tries four approaches to loading data:\n * <ol>\n * <li>loads the provider identifier by the system property\n *   <code>org.joda.time.DateTimeZone.Provider</code>.\n * <li>load <code>ZoneInfoProvider</code> using the data in the filing system folder\n *   pointed to by system property <code>org.joda.time.DateTimeZone.Folder</code>.\n * <li>loads <code>ZoneInfoProvider</code> using the data in the classpath location\n *   <code>org/joda/time/tz/data</code>.\n * <li>loads <code>UTCProvider</code>.\n * </ol>\n * <p>\n * Unless you override the standard behaviour, the default if the third approach.\n *\n * @return the default name provider\n */\n", "repo_name": "joda-time-main/", "id": 107, "method_signature": "Provider getDefaultProvider()"}, "DateTimeZone.getMillisKeepLocal": {"callee_method_ids": [118], "callee_method_names": ["DateTimeZone.convertLocalToUTC"], "method_name": "DateTimeZone.getMillisKeepLocal", "method_implementation": "{\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    if (newZone == this) {\n        return oldInstant;\n    }\n    long instantLocal = convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n}", "repo_id": "7", "comment": "/**\n * Gets the millisecond instant in another zone keeping the same local time.\n * <p>\n * The conversion is performed by converting the specified UTC millis to local\n * millis in this zone, then converting back to UTC millis in the new zone.\n *\n * @param newZone  the new zone, null means default\n * @param oldInstant  the UTC millisecond instant to convert\n * @return the UTC millisecond instant with the same local time in the new zone\n */\n", "repo_name": "joda-time-main/", "id": 119, "method_signature": "long getMillisKeepLocal(DateTimeZone, long)"}, "DateTimeZone.getName": {"callee_method_names": ["NameProvider.getName"], "method_name": "DateTimeZone.getName", "method_implementation": "{\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    String nameKey = getNameKey(instant);\n    if (nameKey == null) {\n        return iID;\n    }\n    String name;\n    NameProvider np = getNameProvider();\n    if (np instanceof DefaultNameProvider) {\n        name = ((DefaultNameProvider) np).getName(locale, iID, nameKey, isStandardOffset(instant));\n    } else {\n        name = np.getName(locale, iID, nameKey);\n    }\n    if (name != null) {\n        return name;\n    }\n    return printOffset(getOffset(instant));\n}", "repo_id": "7", "comment": "/**\n * Gets the long name of this datetime zone suitable for display using\n * the specified locale.\n * <p>\n * If the name is not available for the locale, then this method returns a\n * string in the format <code>[+-]hh:mm</code>.\n *\n * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n * @param locale  the locale to get the name for\n * @return the human-readable long name in the specified locale\n */\n", "repo_name": "joda-time-main/", "id": 113, "method_signature": "String getName(long, Locale)"}, "DateTimeZone.getNameProvider": {"callee_method_names": ["AtomicReference.get", "AtomicReference.compareAndSet", "AtomicReference.get"], "method_name": "DateTimeZone.getNameProvider", "method_implementation": "{\n    NameProvider nameProvider = cNameProvider.get();\n    if (nameProvider == null) {\n        nameProvider = getDefaultNameProvider();\n        if (!cNameProvider.compareAndSet(null, nameProvider)) {\n            nameProvider = cNameProvider.get();\n        }\n    }\n    return nameProvider;\n}", "repo_id": "7", "comment": "/**\n * Gets the name provider factory.\n * <p>\n * The name provider is a pluggable instance factory that supplies the\n * names of each DateTimeZone.\n *\n * @return the provider\n */\n", "repo_name": "joda-time-main/", "id": 108, "method_signature": "NameProvider getNameProvider()"}, "DateTimeZone.getOffset": {"callee_method_names": ["ReadableInstant.getMillis"], "method_name": "DateTimeZone.getOffset", "method_implementation": "{\n    if (instant == null) {\n        return getOffset(DateTimeUtils.currentTimeMillis());\n    }\n    return getOffset(instant.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Gets the millisecond offset to add to UTC to get local time.\n * <p>\n * This returns the actual offset from UTC for the zone at the specified instant.\n * If the method is called with a different instant, the offset returned may be different\n * as a result of daylight saving or other government rule changes.\n *\n * @param instant  instant to get the offset for, null means now\n * @return the millisecond offset to add to UTC to get local time\n */\n", "repo_name": "joda-time-main/", "id": 114, "method_signature": "int getOffset(ReadableInstant)"}, "DateTimeZone.getOffsetFromLocal": {"callee_method_names": [], "method_name": "DateTimeZone.getOffsetFromLocal", "method_implementation": "{\n    // get the offset at instantLocal (first estimate)\n    final int offsetLocal = getOffset(instantLocal);\n    // adjust instantLocal using the estimate and recalc the offset\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offsetAdjusted) {\n        // we need to ensure that time is always after the DST gap\n        // this happens naturally for positive offsets, but not for negative\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            // if we just return offsetAdjusted then the time is pushed\n            // back before the transition, whereas it should be\n            // on or after the transition\n            long nextLocal = nextTransition(instantAdjusted);\n            if (nextLocal == (instantLocal - offsetLocal)) {\n                nextLocal = Long.MAX_VALUE;\n            }\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextAdjusted == (instantLocal - offsetAdjusted)) {\n                nextAdjusted = Long.MAX_VALUE;\n            }\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n    } else if (offsetLocal >= 0) {\n        long prev = previousTransition(instantAdjusted);\n        if (prev < instantAdjusted) {\n            int offsetPrev = getOffset(prev);\n            int diff = offsetPrev - offsetLocal;\n            if (instantAdjusted - prev <= diff) {\n                return offsetPrev;\n            }\n        }\n    }\n    return offsetAdjusted;\n}", "repo_id": "7", "comment": "/**\n * Gets the millisecond offset to subtract from local time to get UTC time.\n * This offset can be used to undo adding the offset obtained by getOffset.\n *\n * <pre>\n * millisLocal == millisUTC   + getOffset(millisUTC)\n * millisUTC   == millisLocal - getOffsetFromLocal(millisLocal)\n * </pre>\n *\n * NOTE: After calculating millisLocal, some error may be introduced. At\n * offset transitions (due to DST or other historical changes), ranges of\n * local times may map to different UTC times.\n * <p>\n * For overlaps (where the local time is ambiguous), this method returns the\n * offset applicable before the gap. The effect of this is that any instant\n * calculated using the offset from an overlap will be in \"summer\" time.\n * <p>\n * For gaps, this method returns the offset applicable before the gap, ie \"winter\" offset.\n * However, the effect of this is that any instant calculated using the offset\n * from a gap will be after the gap, in \"summer\" time.\n * <p>\n * For example, consider a zone with a gap from 01:00 to 01:59:<br />\n * Input: 00:00 (before gap) Output: Offset applicable before gap  DateTime: 00:00<br />\n * Input: 00:30 (before gap) Output: Offset applicable before gap  DateTime: 00:30<br />\n * Input: 01:00 (in gap)     Output: Offset applicable before gap  DateTime: 02:00<br />\n * Input: 01:30 (in gap)     Output: Offset applicable before gap  DateTime: 02:30<br />\n * Input: 02:00 (after gap)  Output: Offset applicable after gap   DateTime: 02:00<br />\n * Input: 02:30 (after gap)  Output: Offset applicable after gap   DateTime: 02:30<br />\n * <p>\n * NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere.\n * Prior to v1.5, the DST gap behaviour was also not defined.\n * In v2.4, the documentation was clarified again.\n *\n * @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for\n * @return the millisecond offset to subtract from local time to get UTC time\n */\n", "repo_name": "joda-time-main/", "id": 115, "method_signature": "int getOffsetFromLocal(long)"}, "DateTimeZone.getProvider": {"callee_method_names": ["AtomicReference.get", "AtomicReference.compareAndSet", "AtomicReference.get"], "method_name": "DateTimeZone.getProvider", "method_implementation": "{\n    Provider provider = cProvider.get();\n    if (provider == null) {\n        provider = getDefaultProvider();\n        if (!cProvider.compareAndSet(null, provider)) {\n            provider = cProvider.get();\n        }\n    }\n    return provider;\n}", "repo_id": "7", "comment": "/**\n * Gets the zone provider factory.\n * <p>\n * The zone provider is a pluggable instance factory that supplies the\n * actual instances of DateTimeZone.\n *\n * @return the provider\n */\n", "repo_name": "joda-time-main/", "id": 104, "method_signature": "Provider getProvider()"}, "DateTimeZone.getShortName": {"callee_method_names": ["NameProvider.getShortName"], "method_name": "DateTimeZone.getShortName", "method_implementation": "{\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    String nameKey = getNameKey(instant);\n    if (nameKey == null) {\n        return iID;\n    }\n    String name;\n    NameProvider np = getNameProvider();\n    if (np instanceof DefaultNameProvider) {\n        name = ((DefaultNameProvider) np).getShortName(locale, iID, nameKey, isStandardOffset(instant));\n    } else {\n        name = np.getShortName(locale, iID, nameKey);\n    }\n    if (name != null) {\n        return name;\n    }\n    return printOffset(getOffset(instant));\n}", "repo_id": "7", "comment": "/**\n * Gets the short name of this datetime zone suitable for display using\n * the specified locale.\n * <p>\n * If the name is not available for the locale, then this method returns a\n * string in the format <code>[+-]hh:mm</code>.\n *\n * @param instant  milliseconds from 1970-01-01T00:00:00Z to get the name for\n * @param locale  the locale to get the name for\n * @return the human-readable short name in the specified locale\n */\n", "repo_name": "joda-time-main/", "id": 112, "method_signature": "String getShortName(long, Locale)"}, "DateTimeZone.isLocalDateTimeGap": {"callee_method_ids": [958], "callee_method_names": ["LocalDateTime.toDateTime"], "method_name": "DateTimeZone.isLocalDateTimeGap", "method_implementation": "{\n    if (isFixed()) {\n        return false;\n    }\n    try {\n        localDateTime.toDateTime(this);\n        return false;\n    } catch (IllegalInstantException ex) {\n        return true;\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks if the given {@link LocalDateTime} is within a gap.\n * <p>\n * When switching into Daylight Savings Time there is typically a gap where a clock hour is missing.\n * This method identifies whether the local datetime refers to such a gap.\n *\n * @param localDateTime  the time to check, not null\n * @return true if the given datetime refers to a gap\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 120, "method_signature": "boolean isLocalDateTimeGap(LocalDateTime)"}, "DateTimeZone.printOffset": {"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.toString", "StringBuffer.append", "StringBuffer.toString", "StringBuffer.append", "StringBuffer.toString"], "method_name": "DateTimeZone.printOffset", "method_implementation": "{\n    StringBuffer buf = new StringBuffer();\n    if (offset >= 0) {\n        buf.append('+');\n    } else {\n        buf.append('-');\n        offset = -offset;\n    }\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    FormatUtils.appendPaddedInteger(buf, hours, 2);\n    offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\n    buf.append(':');\n    FormatUtils.appendPaddedInteger(buf, minutes, 2);\n    offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\n    if (offset == 0) {\n        return buf.toString();\n    }\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n    buf.append(':');\n    FormatUtils.appendPaddedInteger(buf, seconds, 2);\n    offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n    if (offset == 0) {\n        return buf.toString();\n    }\n    buf.append('.');\n    FormatUtils.appendPaddedInteger(buf, offset, 3);\n    return buf.toString();\n}", "repo_id": "7", "comment": "/**\n * Formats a timezone offset string.\n * <p>\n * This method is kept separate from the formatting classes to speed and\n * simplify startup and classloading.\n *\n * @param offset  the offset in milliseconds\n * @return the time zone string\n */\n", "repo_name": "joda-time-main/", "id": 111, "method_signature": "String printOffset(int)"}, "DateTimeZone.setDefault": {"callee_method_names": ["SecurityManager.checkPermission", "AtomicReference.set"], "method_name": "DateTimeZone.setDefault", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n    }\n    if (zone == null) {\n        throw new IllegalArgumentException(\"The datetime zone must not be null\");\n    }\n    cDefault.set(zone);\n}", "repo_id": "7", "comment": "/**\n * Sets the default time zone.\n * <p>\n * NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.\n *\n * @param zone  the default datetime zone object, must not be null\n * @throws IllegalArgumentException if the zone is null\n * @throws SecurityException if the application has insufficient security rights\n */\n", "repo_name": "joda-time-main/", "id": 98, "method_signature": "void setDefault(DateTimeZone)"}, "DateTimeZone.setNameProvider": {"callee_method_names": ["SecurityManager.checkPermission", "AtomicReference.set"], "method_name": "DateTimeZone.setNameProvider", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setNameProvider\"));\n    }\n    if (nameProvider == null) {\n        nameProvider = getDefaultNameProvider();\n    }\n    cNameProvider.set(nameProvider);\n}", "repo_id": "7", "comment": "/**\n * Sets the name provider factory.\n * <p>\n * The name provider is a pluggable instance factory that supplies the\n * names of each DateTimeZone.\n *\n * @param nameProvider  provider to use, or null for default\n * @throws SecurityException if you do not have the permission DateTimeZone.setNameProvider\n * @throws IllegalArgumentException if the provider is invalid\n */\n", "repo_name": "joda-time-main/", "id": 109, "method_signature": "void setNameProvider(NameProvider)"}, "DateTimeZone.setProvider": {"callee_method_names": ["SecurityManager.checkPermission", "AtomicReference.set"], "method_name": "DateTimeZone.setProvider", "method_implementation": "{\n    SecurityManager sm = System.getSecurityManager();\n    if (sm != null) {\n        sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setProvider\"));\n    }\n    if (provider == null) {\n        provider = getDefaultProvider();\n    } else {\n        validateProvider(provider);\n    }\n    cProvider.set(provider);\n}", "repo_id": "7", "comment": "/**\n * Sets the zone provider factory.\n * <p>\n * The zone provider is a pluggable instance factory that supplies the\n * actual instances of DateTimeZone.\n *\n * @param provider  provider to use, or null for default\n * @throws SecurityException if you do not have the permission DateTimeZone.setProvider\n * @throws IllegalArgumentException if the provider is invalid\n */\n", "repo_name": "joda-time-main/", "id": 105, "method_signature": "void setProvider(Provider)"}, "DateTimeZone.validateProvider": {"callee_method_names": ["Provider.getAvailableIDs", "Set<String>.size", "Set<String>.contains", "DateTimeZone.equals", "Provider.getZone"], "method_name": "DateTimeZone.validateProvider", "method_implementation": "{\n    Set<String> ids = provider.getAvailableIDs();\n    if (ids == null || ids.size() == 0) {\n        throw new IllegalArgumentException(\"The provider doesn't have any available ids\");\n    }\n    if (!ids.contains(\"UTC\")) {\n        throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n    }\n    if (!UTC.equals(provider.getZone(\"UTC\"))) {\n        throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n    }\n    return provider;\n}", "repo_id": "7", "comment": "/**\n * Sets the zone provider factory without performing the security check.\n *\n * @param provider  provider to use, or null for default\n * @return the provider\n * @throws IllegalArgumentException if the provider is invalid\n */\n", "repo_name": "joda-time-main/", "id": 106, "method_signature": "Provider validateProvider(Provider)"}, "DateTimeZoneBuilder.addCutover": {"callee_method_names": ["ArrayList<RuleSet>.size", "ArrayList<RuleSet>.get", "ArrayList<RuleSet>.size", "RuleSet.setUpperLimit", "ArrayList<RuleSet>.add"], "method_name": "DateTimeZoneBuilder.addCutover", "method_implementation": "{\n    if (iRuleSets.size() > 0) {\n        OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n        RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);\n        lastRuleSet.setUpperLimit(year, ofYear);\n    }\n    iRuleSets.add(new RuleSet());\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Adds a cutover for added rules. The standard offset at the cutover\n * defaults to 0. Call setStandardOffset afterwards to change it.\n *\n * @param year  the year of cutover\n * @param mode 'u' - cutover is measured against UTC, 'w' - against wall\n *  offset, 's' - against standard offset\n * @param monthOfYear  the month from 1 (January) to 12 (December)\n * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).\n *  For example, if -1, set to last day of month\n * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore\n * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to\n *  dayOfWeek when true, retreat when false.\n * @param millisOfDay  additional precision for specifying time of day of cutover\n */\n", "repo_name": "joda-time-main/", "id": 745, "method_signature": "DateTimeZoneBuilder addCutover(int, char, int, int, int, boolean, int)"}, "DateTimeZoneBuilder.addRecurringSavings": {"callee_method_names": [], "method_name": "DateTimeZoneBuilder.addRecurringSavings", "method_implementation": "{\n    if (fromYear <= toYear) {\n        OfYear ofYear = new OfYear(mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n        Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n        Rule rule = new Rule(recurrence, fromYear, toYear);\n        getLastRuleSet().addRule(rule);\n    }\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Add a recurring daylight saving time rule.\n *\n * @param nameKey  the name key of new rule\n * @param saveMillis  the milliseconds to add to standard offset\n * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates\n * beginning of time\n * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE\n *  indicates end of time\n * @param mode  'u' - transitions are calculated against UTC, 'w' -\n *  transitions are calculated against wall offset, 's' - transitions are\n *  calculated against standard offset\n * @param monthOfYear  the month from 1 (January) to 12 (December)\n * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).\n *  For example, if -1, set to last day of month\n * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore\n * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to\n *  dayOfWeek when true, retreat when false.\n * @param millisOfDay  additional precision for specifying time of day of transitions\n */\n", "repo_name": "joda-time-main/", "id": 746, "method_signature": "DateTimeZoneBuilder addRecurringSavings(String, int, int, int, char, int, int, int, boolean, int)"}, "DateTimeZoneBuilder.buildTailZone": {"callee_method_names": ["ArrayList<Rule>.size", "ArrayList<Rule>.get", "ArrayList<Rule>.get", "Rule.getToYear", "Rule.getToYear"], "method_name": "DateTimeZoneBuilder.buildTailZone", "method_implementation": "{\n    if (iRules.size() == 2) {\n        Rule startRule = iRules.get(0);\n        Rule endRule = iRules.get(1);\n        if (startRule.getToYear() == Integer.MAX_VALUE && endRule.getToYear() == Integer.MAX_VALUE) {\n            // With exactly two infinitely recurring rules left, a\n            // simple DSTZone can be formed.\n            // The order of rules can come in any order, and it doesn't\n            // really matter which rule was chosen the 'start' and\n            // which is chosen the 'end'. DSTZone works properly either\n            // way.\n            return new DSTZone(id, iStandardOffset, startRule.iRecurrence, endRule.iRecurrence);\n        }\n    }\n    return null;\n}", "repo_id": "7", "comment": "/**\n * Returns null if none can be built.\n */\n", "repo_name": "joda-time-main/", "id": 759, "method_signature": "DSTZone buildTailZone(String)"}, "DateTimeZoneBuilder.create": {"callee_method_ids": [766], "callee_method_names": ["ArrayList<Transition>.size", "ArrayList<Transition>.get", "Transition.isTransitionFrom", "Transition.getMillis", "Transition.getWallOffset", "Transition.getStandardOffset", "Transition.getNameKey", "String.equals", "String.equals", "Period.getYears", "Period.getMonths", "Period.getMonths", "String.equals", "String.equals", "DSTZone.getNameKey", "DSTZone.getNameKey", "DSTZone.getNameKey", "DSTZone.getSaveMillis", "DSTZone.getID", "DSTZone.renameAppend", "DSTZone.getID", "DSTZone.renameAppend"], "method_name": "DateTimeZoneBuilder.create", "method_implementation": "{\n    int size = transitions.size();\n    if (size == 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans = new long[size];\n    int[] wallOffsets = new int[size];\n    int[] standardOffsets = new int[size];\n    String[] nameKeys = new String[size];\n    Transition last = null;\n    for (int i = 0; i < size; i++) {\n        Transition tr = transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] = tr.getMillis();\n        wallOffsets[i] = tr.getWallOffset();\n        standardOffsets[i] = tr.getStandardOffset();\n        nameKeys[i] = tr.getNameKey();\n        last = tr;\n    }\n    // Some timezones (Australia) have the same name key for\n    // summer and winter which messes everything up. Fix it here.\n    String[] zoneNameData = new String[5];\n    String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j = 0; j < zoneStrings.length; j++) {\n        String[] set = zoneStrings[j];\n        if (set != null && set.length == 5 && id.equals(set[0])) {\n            zoneNameData = set;\n        }\n    }\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    for (int i = 0; i < nameKeys.length - 1; i++) {\n        String curNameKey = nameKeys[i];\n        String nextNameKey = nameKeys[i + 1];\n        long curOffset = wallOffsets[i];\n        long nextOffset = wallOffsets[i + 1];\n        long curStdOffset = standardOffsets[i];\n        long nextStdOffset = standardOffsets[i + 1];\n        Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n        if (curOffset != nextOffset && curStdOffset == nextStdOffset && curNameKey.equals(nextNameKey) && p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 && curNameKey.equals(zoneNameData[2]) && curNameKey.equals(zoneNameData[4])) {\n            if (ZoneInfoLogger.verbose()) {\n                System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n                System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n            }\n            if (curOffset > nextOffset) {\n                nameKeys[i] = (curNameKey + \"-Summer\").intern();\n            } else {\n                nameKeys[i + 1] = (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone != null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            if (ZoneInfoLogger.verbose()) {\n                System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            }\n            if (tailZone.iStartRecurrence.getSaveMillis() > 0) {\n                tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n            } else {\n                tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}", "repo_id": "7", "comment": "/**\n * Factory to create instance from builder.\n *\n * @param id  the zone id\n * @param outputID  true if the zone id should be output\n * @param transitions  the list of Transition objects\n * @param tailZone  optional zone for getting info beyond precalculated tables\n */\n", "repo_name": "joda-time-main/", "id": 760, "method_signature": "PrecalculatedZone create(String, boolean, ArrayList, DSTZone)"}, "DateTimeZoneBuilder.firstTransition": {"callee_method_names": ["Transition.getMillis", "Rule.getSaveMillis", "Transition.getNameKey", "Transition.getSaveMillis"], "method_name": "DateTimeZoneBuilder.firstTransition", "method_implementation": "{\n    if (iInitialNameKey != null) {\n        // Initial zone info explicitly set, so don't search the rules.\n        return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset);\n    }\n    // Make a copy before we destroy the rules.\n    ArrayList<Rule> copy = new ArrayList<Rule>(iRules);\n    // Iterate through all the transitions until firstMillis is\n    // reached. Use the name key and savings for whatever rule reaches\n    // the limit.\n    long millis = Long.MIN_VALUE;\n    int saveMillis = 0;\n    Transition first = null;\n    Transition next;\n    while ((next = nextTransition(millis, saveMillis)) != null) {\n        millis = next.getMillis();\n        if (millis == firstMillis) {\n            first = new Transition(firstMillis, next);\n            break;\n        }\n        if (millis > firstMillis) {\n            if (first == null) {\n                // Find first rule without savings. This way a more\n                // accurate nameKey is found even though no rule\n                // extends to the RuleSet's lower limit.\n                for (Rule rule : copy) {\n                    if (rule.getSaveMillis() == 0) {\n                        first = new Transition(firstMillis, rule, iStandardOffset);\n                        break;\n                    }\n                }\n            }\n            if (first == null) {\n                // Found no rule without savings. Create a transition\n                // with no savings anyhow, and use the best available\n                // name key.\n                first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset);\n            }\n            break;\n        }\n        // Set first to the best transition found so far, but next\n        // iteration may find something closer to lower limit.\n        first = new Transition(firstMillis, next);\n        saveMillis = next.getSaveMillis();\n    }\n    iRules = copy;\n    return first;\n}", "repo_id": "7", "comment": "/**\n * Returns a transition at firstMillis with the first name key and\n * offsets for this rule set. This method may return null.\n *\n * @param firstMillis millis of first transition\n */\n", "repo_name": "joda-time-main/", "id": 756, "method_signature": "Transition firstTransition(long)"}, "DateTimeZoneBuilder.getUpperLimit": {"callee_method_ids": [761], "callee_method_names": ["OfYear.setInstant"], "method_name": "DateTimeZoneBuilder.getUpperLimit", "method_implementation": "{\n    if (iUpperYear == Integer.MAX_VALUE) {\n        return Long.MAX_VALUE;\n    }\n    return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n}", "repo_id": "7", "comment": "/**\n * @param saveMillis savings before upper limit\n */\n", "repo_name": "joda-time-main/", "id": 758, "method_signature": "long getUpperLimit(int)"}, "DateTimeZoneBuilder.isTransitionFrom": {"callee_method_names": ["String.equals"], "method_name": "DateTimeZoneBuilder.isTransitionFrom", "method_implementation": "{\n    if (other == null) {\n        return true;\n    }\n    return iMillis > other.iMillis && (iWallOffset != other.iWallOffset || iStandardOffset != other.iStandardOffset || !(iNameKey.equals(other.iNameKey)));\n}", "repo_id": "7", "comment": "/**\n * There must be a change in the millis, wall offsets or name keys.\n */\n", "repo_name": "joda-time-main/", "id": 755, "method_signature": "boolean isTransitionFrom(Transition)"}, "DateTimeZoneBuilder.next": {"callee_method_names": ["Chronology.monthOfYear", "Chronology.millisOfDay", "Chronology.millisOfDay", "Chronology.year", "Chronology.year", "Chronology.monthOfYear", "Chronology.millisOfDay", "Chronology.millisOfDay"], "method_name": "DateTimeZoneBuilder.next", "method_implementation": "{\n    int offset;\n    if (iMode == 'w') {\n        offset = standardOffset + saveMillis;\n    } else if (iMode == 's') {\n        offset = standardOffset;\n    } else {\n        offset = 0;\n    }\n    // Convert from UTC to local time.\n    instant += offset;\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    long next = chrono.monthOfYear().set(instant, iMonthOfYear);\n    // Be lenient with millisOfDay.\n    next = chrono.millisOfDay().set(next, 0);\n    // avoid going into the next day, as that can change the month and cause setDayOfMonthNext to fail\n    // this is not a particularly good solution to the problem (it is vital to use iMillisOfDay\n    // as otherwise the logic doesn't find the correct *next* occurrence)\n    next = chrono.millisOfDay().add(next, Math.min(iMillisOfDay, DateTimeConstants.MILLIS_PER_DAY - 1));\n    next = setDayOfMonthNext(chrono, next);\n    if (iDayOfWeek == 0) {\n        if (next <= instant) {\n            next = chrono.year().add(next, 1);\n            next = setDayOfMonthNext(chrono, next);\n        }\n    } else {\n        next = setDayOfWeek(chrono, next);\n        if (next <= instant) {\n            next = chrono.year().add(next, 1);\n            next = chrono.monthOfYear().set(next, iMonthOfYear);\n            next = setDayOfMonthNext(chrono, next);\n            next = setDayOfWeek(chrono, next);\n        }\n    }\n    next = chrono.millisOfDay().set(next, 0);\n    next = chrono.millisOfDay().add(next, iMillisOfDay);\n    // Convert from local time to UTC.\n    return next - offset;\n}", "repo_id": "7", "comment": "/**\n * @param standardOffset standard offset just before next recurrence\n */\n", "repo_name": "joda-time-main/", "id": 751, "method_signature": "long next(long, int, int)"}, "DateTimeZoneBuilder.nextTransition": {"callee_method_ids": [761], "callee_method_names": ["ArrayList<Rule>.iterator", "Iterator<Rule>.hasNext", "Iterator<Rule>.next", "Rule.next", "Iterator<Rule>.remove", "Chronology.year", "OfYear.setInstant"], "method_name": "DateTimeZoneBuilder.nextTransition", "method_implementation": "{\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    // Find next matching rule.\n    Rule nextRule = null;\n    long nextMillis = Long.MAX_VALUE;\n    Iterator<Rule> it = iRules.iterator();\n    while (it.hasNext()) {\n        Rule rule = it.next();\n        long next = rule.next(instant, iStandardOffset, saveMillis);\n        if (next <= instant) {\n            it.remove();\n            continue;\n        }\n        // Even if next is same as previous next, choose the rule\n        // in order for more recently added rules to override.\n        if (next <= nextMillis) {\n            // Found a better match.\n            nextRule = rule;\n            nextMillis = next;\n        }\n    }\n    if (nextRule == null) {\n        return null;\n    }\n    // Stop precalculating if year reaches some arbitrary limit.\n    if (chrono.year().get(nextMillis) >= YEAR_LIMIT) {\n        return null;\n    }\n    // Check if upper limit reached or passed.\n    if (iUpperYear < Integer.MAX_VALUE) {\n        long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        if (nextMillis >= upperMillis) {\n            // At or after upper limit.\n            return null;\n        }\n    }\n    return new Transition(nextMillis, nextRule, iStandardOffset);\n}", "repo_id": "7", "comment": "/**\n * Returns null if RuleSet is exhausted or upper limit reached. Calling\n * this method will throw away rules as they each become\n * exhausted. Copy the RuleSet before using it to compute transitions.\n *\n * Returned transition may be a duplicate from previous\n * transition. Caller must call isTransitionFrom to filter out\n * duplicates.\n *\n * @param saveMillis savings before next transition\n */\n", "repo_name": "joda-time-main/", "id": 757, "method_signature": "Transition nextTransition(long, int)"}, "DateTimeZoneBuilder.previous": {"callee_method_names": ["Chronology.monthOfYear", "Chronology.millisOfDay", "Chronology.millisOfDay", "Chronology.year", "Chronology.year", "Chronology.monthOfYear", "Chronology.millisOfDay", "Chronology.millisOfDay"], "method_name": "DateTimeZoneBuilder.previous", "method_implementation": "{\n    int offset;\n    if (iMode == 'w') {\n        offset = standardOffset + saveMillis;\n    } else if (iMode == 's') {\n        offset = standardOffset;\n    } else {\n        offset = 0;\n    }\n    // Convert from UTC to local time.\n    instant += offset;\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    long prev = chrono.monthOfYear().set(instant, iMonthOfYear);\n    // Be lenient with millisOfDay.\n    prev = chrono.millisOfDay().set(prev, 0);\n    prev = chrono.millisOfDay().add(prev, iMillisOfDay);\n    prev = setDayOfMonthPrevious(chrono, prev);\n    if (iDayOfWeek == 0) {\n        if (prev >= instant) {\n            prev = chrono.year().add(prev, -1);\n            prev = setDayOfMonthPrevious(chrono, prev);\n        }\n    } else {\n        prev = setDayOfWeek(chrono, prev);\n        if (prev >= instant) {\n            prev = chrono.year().add(prev, -1);\n            prev = chrono.monthOfYear().set(prev, iMonthOfYear);\n            prev = setDayOfMonthPrevious(chrono, prev);\n            prev = setDayOfWeek(chrono, prev);\n        }\n    }\n    prev = chrono.millisOfDay().set(prev, 0);\n    prev = chrono.millisOfDay().add(prev, iMillisOfDay);\n    // Convert from local time to UTC.\n    return prev - offset;\n}", "repo_id": "7", "comment": "/**\n * @param standardOffset standard offset just before previous recurrence\n */\n", "repo_name": "joda-time-main/", "id": 752, "method_signature": "long previous(long, int, int)"}, "DateTimeZoneBuilder.readFrom": {"callee_method_names": ["DataInput.readUnsignedByte", "DataInput.readUTF", "DateTimeZone.equals"], "method_name": "DateTimeZoneBuilder.readFrom", "method_implementation": "{\n    switch(in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone(id, in.readUTF(), (int) readMillis(in), (int) readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Decodes a built DateTimeZone from the given stream, as encoded by\n * writeTo.\n *\n * @param in input stream to read encoded DateTimeZone from.\n * @param id time zone id to assign\n */\n", "repo_name": "joda-time-main/", "id": 742, "method_signature": "DateTimeZone readFrom(DataInput, String)"}, "DateTimeZoneBuilder.readMillis": {"callee_method_names": ["DataInput.readUnsignedByte", "DataInput.readUnsignedByte", "DataInput.readUnsignedByte", "DataInput.readUnsignedByte", "DataInput.readUnsignedByte", "DataInput.readUnsignedByte", "DataInput.readUnsignedByte", "DataInput.readUnsignedByte", "DataInput.readLong"], "method_name": "DateTimeZoneBuilder.readMillis", "method_implementation": "{\n    int v = in.readUnsignedByte();\n    switch(v >> 6) {\n        case 0:\n        default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long) v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n        case 3:\n            // Form 11 (64-bits effective precision)\n            return in.readLong();\n    }\n}", "repo_id": "7", "comment": "/**\n * Reads encoding generated by writeMillis.\n */\n", "repo_name": "joda-time-main/", "id": 744, "method_signature": "long readMillis(DataInput)"}, "DateTimeZoneBuilder.setDayOfMonthNext": {"callee_method_names": ["Chronology.year", "Chronology.year"], "method_name": "DateTimeZoneBuilder.setDayOfMonthNext", "method_implementation": "{\n    try {\n        next = setDayOfMonth(chrono, next);\n    } catch (IllegalArgumentException e) {\n        if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n            while (chrono.year().isLeap(next) == false) {\n                next = chrono.year().add(next, 1);\n            }\n            next = setDayOfMonth(chrono, next);\n        } else {\n            throw e;\n        }\n    }\n    return next;\n}", "repo_id": "7", "comment": "/**\n * If month-day is 02-29 and year isn't leap, advances to next leap year.\n */\n", "repo_name": "joda-time-main/", "id": 753, "method_signature": "long setDayOfMonthNext(Chronology, long)"}, "DateTimeZoneBuilder.setDayOfMonthPrevious": {"callee_method_names": ["Chronology.year", "Chronology.year"], "method_name": "DateTimeZoneBuilder.setDayOfMonthPrevious", "method_implementation": "{\n    try {\n        prev = setDayOfMonth(chrono, prev);\n    } catch (IllegalArgumentException e) {\n        if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n            while (chrono.year().isLeap(prev) == false) {\n                prev = chrono.year().add(prev, -1);\n            }\n            prev = setDayOfMonth(chrono, prev);\n        } else {\n            throw e;\n        }\n    }\n    return prev;\n}", "repo_id": "7", "comment": "/**\n * If month-day is 02-29 and year isn't leap, retreats to previous leap year.\n */\n", "repo_name": "joda-time-main/", "id": 754, "method_signature": "long setDayOfMonthPrevious(Chronology, long)"}, "DateTimeZoneBuilder.setInstant": {"callee_method_names": ["Chronology.year", "Chronology.monthOfYear", "Chronology.millisOfDay"], "method_name": "DateTimeZoneBuilder.setInstant", "method_implementation": "{\n    int offset;\n    if (iMode == 'w') {\n        offset = standardOffset + saveMillis;\n    } else if (iMode == 's') {\n        offset = standardOffset;\n    } else {\n        offset = 0;\n    }\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    long millis = chrono.year().set(0, year);\n    millis = chrono.monthOfYear().set(millis, iMonthOfYear);\n    millis = chrono.millisOfDay().set(millis, iMillisOfDay);\n    millis = setDayOfMonth(chrono, millis);\n    if (iDayOfWeek != 0) {\n        millis = setDayOfWeek(chrono, millis);\n    }\n    // Convert from local time to UTC.\n    return millis - offset;\n}", "repo_id": "7", "comment": "/**\n * @param standardOffset standard offset just before instant\n */\n", "repo_name": "joda-time-main/", "id": 750, "method_signature": "long setInstant(int, int, int)"}, "DateTimeZoneBuilder.toDateTimeZone": {"callee_method_ids": [767, 768, 770, 769], "callee_method_names": ["ArrayList<RuleSet>.size", "ArrayList<RuleSet>.get", "RuleSet.firstTransition", "Transition.getMillis", "Transition.getSaveMillis", "RuleSet.nextTransition", "Transition.getMillis", "Transition.getSaveMillis", "RuleSet.buildTailZone", "RuleSet.getUpperLimit", "ArrayList<Transition>.size", "ArrayList<Transition>.size", "ArrayList<Transition>.get", "Transition.getNameKey", "Transition.getWallOffset", "Transition.getStandardOffset", "PrecalculatedZone.isCachable"], "method_name": "DateTimeZoneBuilder.toDateTimeZone", "method_implementation": "{\n    if (id == null) {\n        throw new IllegalArgumentException();\n    }\n    // Discover where all the transitions occur and store the results in\n    // these lists.\n    ArrayList<Transition> transitions = new ArrayList<Transition>();\n    // Tail zone picks up remaining transitions in the form of an endless\n    // DST cycle.\n    DSTZone tailZone = null;\n    long millis = Long.MIN_VALUE;\n    int saveMillis = 0;\n    int ruleSetCount = iRuleSets.size();\n    for (int i = 0; i < ruleSetCount; i++) {\n        RuleSet rs = iRuleSets.get(i);\n        Transition next = rs.firstTransition(millis);\n        if (next == null) {\n            continue;\n        }\n        addTransition(transitions, next);\n        millis = next.getMillis();\n        saveMillis = next.getSaveMillis();\n        // Copy it since we're going to destroy it.\n        rs = new RuleSet(rs);\n        while ((next = rs.nextTransition(millis, saveMillis)) != null) {\n            if (addTransition(transitions, next) && tailZone != null) {\n                // Got the extra transition before DSTZone.\n                break;\n            }\n            millis = next.getMillis();\n            saveMillis = next.getSaveMillis();\n            if (tailZone == null && i == ruleSetCount - 1) {\n                tailZone = rs.buildTailZone(id);\n                // If tailZone is not null, don't break out of main loop until\n                // at least one more transition is calculated. This ensures a\n                // correct 'seam' to the DSTZone.\n            }\n        }\n        millis = rs.getUpperLimit(saveMillis);\n    }\n    // Check if a simpler zone implementation can be returned.\n    if (transitions.size() == 0) {\n        if (tailZone != null) {\n            // This shouldn't happen, but handle just in case.\n            return tailZone;\n        }\n        return buildFixedZone(id, \"UTC\", 0, 0);\n    }\n    if (transitions.size() == 1 && tailZone == null) {\n        Transition tr = transitions.get(0);\n        return buildFixedZone(id, tr.getNameKey(), tr.getWallOffset(), tr.getStandardOffset());\n    }\n    PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);\n    if (zone.isCachable()) {\n        return CachedDateTimeZone.forZone(zone);\n    }\n    return zone;\n}", "repo_id": "7", "comment": "/**\n * Processes all the rules and builds a DateTimeZone.\n *\n * @param id  time zone id to assign\n * @param outputID  true if the zone id should be output\n */\n", "repo_name": "joda-time-main/", "id": 747, "method_signature": "DateTimeZone toDateTimeZone(String, boolean)"}, "DateTimeZoneBuilder.writeMillis": {"callee_method_names": ["DataOutput.writeByte", "DataOutput.writeInt", "DataOutput.writeByte", "DataOutput.writeInt", "DataOutput.writeByte", "DataOutput.writeLong"], "method_name": "DateTimeZoneBuilder.writeMillis", "method_implementation": "{\n    if (millis % (30 * 60000L) == 0) {\n        // Try to write in 30 minute units.\n        long units = millis / (30 * 60000L);\n        if (((units << (64 - 6)) >> (64 - 6)) == units) {\n            // Form 00 (6 bits effective precision)\n            out.writeByte((int) (units & 0x3f));\n            return;\n        }\n    }\n    if (millis % 60000L == 0) {\n        // Try to write minutes.\n        long minutes = millis / 60000L;\n        if (((minutes << (64 - 30)) >> (64 - 30)) == minutes) {\n            // Form 01 (30 bits effective precision)\n            out.writeInt(0x40000000 | (int) (minutes & 0x3fffffff));\n            return;\n        }\n    }\n    if (millis % 1000L == 0) {\n        // Try to write seconds.\n        long seconds = millis / 1000L;\n        if (((seconds << (64 - 38)) >> (64 - 38)) == seconds) {\n            // Form 10 (38 bits effective precision)\n            out.writeByte(0x80 | (int) ((seconds >> 32) & 0x3f));\n            out.writeInt((int) (seconds & 0xffffffff));\n            return;\n        }\n    }\n    // Write milliseconds either because the additional precision is\n    // required or the minutes didn't fit in the field.\n    // Form 11 (64-bits effective precision, but write as if 70 bits)\n    out.writeByte(millis < 0 ? 0xff : 0xc0);\n    out.writeLong(millis);\n}", "repo_id": "7", "comment": "/**\n * Millisecond encoding formats:\n *\n * upper two bits  units       field length  approximate range\n * ---------------------------------------------------------------\n * 00              30 minutes  1 byte        +/- 16 hours\n * 01              minutes     4 bytes       +/- 1020 years\n * 10              seconds     5 bytes       +/- 4355 years\n * 11              millis      9 bytes       +/- 292,000,000 years\n *\n * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.\n */\n", "repo_name": "joda-time-main/", "id": 743, "method_signature": "void writeMillis(DataOutput, long)"}, "DateTimeZoneBuilder.writeTo": {"callee_method_ids": [114], "callee_method_names": ["DataOutput.writeByte", "DataOutput.writeUTF", "DateTimeZone.getNameKey", "DateTimeZone.getOffset", "DateTimeZone.getStandardOffset", "DataOutput.writeByte", "DataOutput.writeByte"], "method_name": "DateTimeZoneBuilder.writeTo", "method_implementation": "{\n    // pass false so zone id is not written out\n    DateTimeZone zone = toDateTimeZone(zoneID, false);\n    if (zone instanceof FixedDateTimeZone) {\n        // 'F' for fixed\n        out.writeByte('F');\n        out.writeUTF(zone.getNameKey(0));\n        writeMillis(out, zone.getOffset(0));\n        writeMillis(out, zone.getStandardOffset(0));\n    } else {\n        if (zone instanceof CachedDateTimeZone) {\n            // 'C' for cached, precalculated\n            out.writeByte('C');\n            zone = ((CachedDateTimeZone) zone).getUncachedZone();\n        } else {\n            // 'P' for precalculated, uncached\n            out.writeByte('P');\n        }\n        ((PrecalculatedZone) zone).writeTo(out);\n    }\n}", "repo_id": "7", "comment": "/**\n * Encodes a built DateTimeZone to the given stream. Call readFrom to\n * decode the data into a DateTimeZone object.\n *\n * @param out  the output stream to receive the encoded DateTimeZone\n * @since 1.5 (parameter added)\n */\n", "repo_name": "joda-time-main/", "id": 749, "method_signature": "void writeTo(String, DataOutput)"}, "Days.days": {"callee_method_names": [], "method_name": "Days.days", "method_implementation": "{\n    switch(days) {\n        case 0:\n            return ZERO;\n        case 1:\n            return ONE;\n        case 2:\n            return TWO;\n        case 3:\n            return THREE;\n        case 4:\n            return FOUR;\n        case 5:\n            return FIVE;\n        case 6:\n            return SIX;\n        case 7:\n            return SEVEN;\n        case Integer.MAX_VALUE:\n            return MAX_VALUE;\n        case Integer.MIN_VALUE:\n            return MIN_VALUE;\n        default:\n            return new Days(days);\n    }\n}", "repo_id": "7", "comment": "/**\n * Obtains an instance of <code>Days</code> that may be cached.\n * <code>Days</code> is immutable, so instances can be cached and shared.\n * This factory method provides access to shared instances.\n *\n * @param days  the number of days to obtain an instance for\n * @return the instance of Days\n */\n", "repo_name": "joda-time-main/", "id": 935, "method_signature": "Days days(int)"}, "Days.daysBetween": {"callee_method_names": ["ReadablePartial.getChronology", "Chronology.days"], "method_name": "Days.daysBetween", "method_implementation": "{\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int days = chrono.days().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return Days.days(days);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return Days.days(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Days</code> representing the number of whole days\n * between the two specified partial datetimes.\n * <p>\n * The two partials must contain the same fields, for example you can specify\n * two <code>LocalDate</code> objects.\n *\n * @param start  the start partial date, must not be null\n * @param end  the end partial date, must not be null\n * @return the period in days\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 936, "method_signature": "Days daysBetween(ReadablePartial, ReadablePartial)"}, "Days.daysIn": {"callee_method_names": ["ReadableInterval.getStart", "ReadableInterval.getEnd"], "method_name": "Days.daysIn", "method_implementation": "{\n    if (interval == null) {\n        return Days.ZERO;\n    }\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.days());\n    return Days.days(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Days</code> representing the number of whole days\n * in the specified interval. This method correctly handles any daylight\n * savings time changes that may occur during the interval.\n *\n * @param interval  the interval to extract days from, null returns zero\n * @return the period in days\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 937, "method_signature": "Days daysIn(ReadableInterval)"}, "Days.dividedBy": {"callee_method_names": [], "method_name": "Days.dividedBy", "method_implementation": "{\n    if (divisor == 1) {\n        return this;\n    }\n    return Days.days(getValue() / divisor);\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the days divided by the specified divisor.\n * The calculation uses integer division, thus 3 divided by 2 is 1.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param divisor  the amount to divide by, may be negative\n * @return the new period divided by the specified divisor\n * @throws ArithmeticException if the divisor is zero\n */\n", "repo_name": "joda-time-main/", "id": 942, "method_signature": "Days dividedBy(int)"}, "Days.isGreaterThan": {"callee_method_names": ["Days.getValue"], "method_name": "Days.isGreaterThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() > 0;\n    }\n    return getValue() > other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this days instance greater than the specified number of days.\n *\n * @param other  the other period, null means zero\n * @return true if this days instance is greater than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 943, "method_signature": "boolean isGreaterThan(Days)"}, "Days.isLessThan": {"callee_method_names": ["Days.getValue"], "method_name": "Days.isLessThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() < 0;\n    }\n    return getValue() < other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this days instance less than the specified number of days.\n *\n * @param other  the other period, null means zero\n * @return true if this days instance is less than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 944, "method_signature": "boolean isLessThan(Days)"}, "Days.minus": {"callee_method_names": ["Days.getValue"], "method_name": "Days.minus", "method_implementation": "{\n    if (days == null) {\n        return this;\n    }\n    return minus(days.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of days taken away.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param days  the amount of days to take away, may be negative, null means zero\n * @return the new period minus the specified number of days\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 941, "method_signature": "Days minus(Days)"}, "Days.parseDays": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod", "Period.getDays"], "method_name": "Days.parseDays", "method_implementation": "{\n    if (periodStr == null) {\n        return Days.ZERO;\n    }\n    Period p = PARSER.parsePeriod(periodStr);\n    return Days.days(p.getDays());\n}", "repo_id": "7", "comment": "/**\n * Creates a new <code>Days</code> by parsing a string in the ISO8601 format 'PnD'.\n * <p>\n * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n * days component may be non-zero. If any other component is non-zero, an exception\n * will be thrown.\n *\n * @param periodStr  the period string, null returns zero\n * @return the period in days\n * @throws IllegalArgumentException if the string format is invalid\n */\n", "repo_name": "joda-time-main/", "id": 938, "method_signature": "Days parseDays(String)"}, "Days.plus": {"callee_method_names": ["Days.getValue"], "method_name": "Days.plus", "method_implementation": "{\n    if (days == null) {\n        return this;\n    }\n    return plus(days.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of days added.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param days  the amount of days to add, may be negative, null means zero\n * @return the new period plus the specified number of days\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 940, "method_signature": "Days plus(Days)"}, "Days.toString": {"callee_method_names": [], "method_name": "Days.toString", "method_implementation": "{\n    return \"P\" + String.valueOf(getValue()) + \"D\";\n}", "repo_id": "7", "comment": "/**\n * Gets this instance as a String in the ISO8601 duration format.\n * <p>\n * For example, \"P4D\" represents 4 days.\n *\n * @return the value as an ISO8601 string\n */\n", "repo_name": "joda-time-main/", "id": 945, "method_signature": "String toString()"}, "DividedDateTimeField.get": {"callee_method_names": [], "method_name": "DividedDateTimeField.get", "method_implementation": "{\n    int value = getWrappedField().get(instant);\n    if (value >= 0) {\n        return value / iDivisor;\n    } else {\n        return ((value + 1) / iDivisor) - 1;\n    }\n}", "repo_id": "7", "comment": "/**\n * Get the amount of scaled units from the specified time instant.\n *\n * @param instant  the time instant in millis to query.\n * @return the amount of scaled units extracted from the input.\n */\n", "repo_name": "joda-time-main/", "id": 55, "method_signature": "int get(long)"}, "DividedDateTimeField.set": {"callee_method_names": [], "method_name": "DividedDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n    int remainder = getRemainder(getWrappedField().get(instant));\n    return getWrappedField().set(instant, value * iDivisor + remainder);\n}", "repo_id": "7", "comment": "/**\n * Set the specified amount of scaled units to the specified time instant.\n *\n * @param instant  the time instant in millis to update.\n * @param value  value of scaled units to set.\n * @return the updated time instant.\n * @throws IllegalArgumentException if value is too large or too small.\n */\n", "repo_name": "joda-time-main/", "id": 56, "method_signature": "long set(long, int)"}, "Duration.abs": {"callee_method_names": [], "method_name": "Duration.abs", "method_implementation": "{\n    if (getMillis() < 0) {\n        return negated();\n    }\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Returns a duration that has a positive or zero number of milliseconds.\n * <p>\n * This instance is immutable and is not altered.\n *\n * @return the absolute duration instance\n * @since 2.10\n */\n", "repo_name": "joda-time-main/", "id": 572, "method_signature": "Duration abs()"}, "Duration.dividedBy": {"callee_method_names": [], "method_name": "Duration.dividedBy", "method_implementation": "{\n    if (divisor == 1) {\n        return this;\n    }\n    return new Duration(FieldUtils.safeDivide(getMillis(), divisor, roundingMode));\n}", "repo_id": "7", "comment": "/**\n * Returns a new duration with its length divided by the\n * specified divisor. {@code RoundingMode} can be specified.\n * This instance is immutable and is not altered.\n * <p>\n * If the divisor is one, this instance is returned.\n *\n * @param divisor  the divisor to divide this one by\n * @param roundingMode  the type of rounding desired\n * @return the new duration instance\n */\n", "repo_name": "joda-time-main/", "id": 570, "method_signature": "Duration dividedBy(long, RoundingMode)"}, "Duration.millis": {"callee_method_names": [], "method_name": "Duration.millis", "method_implementation": "{\n    if (millis == 0) {\n        return ZERO;\n    }\n    return new Duration(millis);\n}", "repo_id": "7", "comment": "/**\n * Create a duration with the specified number of milliseconds.\n *\n * @param millis  the number of standard milliseconds in this duration\n * @return the duration, never null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 562, "method_signature": "Duration millis(long)"}, "Duration.minus": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "Duration.minus", "method_implementation": "{\n    if (amount == null) {\n        return this;\n    }\n    return withDurationAdded(amount.getMillis(), -1);\n}", "repo_id": "7", "comment": "/**\n * Returns a new duration with this length minus that specified.\n * This instance is immutable and is not altered.\n * <p>\n * If the amount is zero, this instance is returned.\n *\n * @param amount  the duration to take away from this one, null means zero\n * @return the new duration instance\n */\n", "repo_name": "joda-time-main/", "id": 567, "method_signature": "Duration minus(ReadableDuration)"}, "Duration.multipliedBy": {"callee_method_names": [], "method_name": "Duration.multipliedBy", "method_implementation": "{\n    if (multiplicand == 1) {\n        return this;\n    }\n    return new Duration(FieldUtils.safeMultiply(getMillis(), multiplicand));\n}", "repo_id": "7", "comment": "/**\n * Returns a new duration with this length multiplied by the\n * specified multiplicand.\n * This instance is immutable and is not altered.\n * <p>\n * If the multiplicand is one, this instance is returned.\n *\n * @param multiplicand  the multiplicand to multiply this one by\n * @return the new duration instance\n */\n", "repo_name": "joda-time-main/", "id": 568, "method_signature": "Duration multipliedBy(long)"}, "Duration.negated": {"callee_method_names": [], "method_name": "Duration.negated", "method_implementation": "{\n    if (getMillis() == Long.MIN_VALUE) {\n        throw new ArithmeticException(\"Negation of this duration would overflow\");\n    }\n    return new Duration(-getMillis());\n}", "repo_id": "7", "comment": "/**\n * Returns a new duration with this length negated.\n * This instance is immutable and is not altered.\n *\n * @return the new duration instance\n */\n", "repo_name": "joda-time-main/", "id": 571, "method_signature": "Duration negated()"}, "Duration.plus": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "Duration.plus", "method_implementation": "{\n    if (amount == null) {\n        return this;\n    }\n    return withDurationAdded(amount.getMillis(), 1);\n}", "repo_id": "7", "comment": "/**\n * Returns a new duration with this length plus that specified.\n * This instance is immutable and is not altered.\n * <p>\n * If the amount is zero, this instance is returned.\n *\n * @param amount  the duration to add to this one, null means zero\n * @return the new duration instance\n */\n", "repo_name": "joda-time-main/", "id": 566, "method_signature": "Duration plus(ReadableDuration)"}, "Duration.standardDays": {"callee_method_names": [], "method_name": "Duration.standardDays", "method_implementation": "{\n    if (days == 0) {\n        return ZERO;\n    }\n    return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY));\n}", "repo_id": "7", "comment": "/**\n * Create a duration with the specified number of days assuming that\n * there are the standard number of milliseconds in a day.\n * <p>\n * This method assumes that there are 24 hours in a day,\n * 60 minutes in an hour, 60 seconds in a minute and 1000 milliseconds in\n * a second. This will be true for most days, however days with Daylight\n * Savings changes will not have 24 hours, so use this method with care.\n * <p>\n * A Duration is a representation of an amount of time. If you want to express\n * the concept of 'days' you should consider using the {@link Days} class.\n *\n * @param days  the number of standard days in this duration\n * @return the duration, never null\n * @throws ArithmeticException if the days value is too large\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 558, "method_signature": "Duration standardDays(long)"}, "Duration.standardHours": {"callee_method_names": [], "method_name": "Duration.standardHours", "method_implementation": "{\n    if (hours == 0) {\n        return ZERO;\n    }\n    return new Duration(FieldUtils.safeMultiply(hours, DateTimeConstants.MILLIS_PER_HOUR));\n}", "repo_id": "7", "comment": "/**\n * Create a duration with the specified number of hours assuming that\n * there are the standard number of milliseconds in an hour.\n * <p>\n * This method assumes that there are 60 minutes in an hour,\n * 60 seconds in a minute and 1000 milliseconds in a second.\n * All currently supplied chronologies use this definition.\n * <p>\n * A Duration is a representation of an amount of time. If you want to express\n * the concept of 'hours' you should consider using the {@link Hours} class.\n *\n * @param hours  the number of standard hours in this duration\n * @return the duration, never null\n * @throws ArithmeticException if the hours value is too large\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 559, "method_signature": "Duration standardHours(long)"}, "Duration.standardMinutes": {"callee_method_names": [], "method_name": "Duration.standardMinutes", "method_implementation": "{\n    if (minutes == 0) {\n        return ZERO;\n    }\n    return new Duration(FieldUtils.safeMultiply(minutes, DateTimeConstants.MILLIS_PER_MINUTE));\n}", "repo_id": "7", "comment": "/**\n * Create a duration with the specified number of minutes assuming that\n * there are the standard number of milliseconds in a minute.\n * <p>\n * This method assumes that there are 60 seconds in a minute and\n * 1000 milliseconds in a second.\n * All currently supplied chronologies use this definition.\n * <p>\n * A Duration is a representation of an amount of time. If you want to express\n * the concept of 'minutes' you should consider using the {@link Minutes} class.\n *\n * @param minutes  the number of standard minutes in this duration\n * @return the duration, never null\n * @throws ArithmeticException if the minutes value is too large\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 560, "method_signature": "Duration standardMinutes(long)"}, "Duration.standardSeconds": {"callee_method_names": [], "method_name": "Duration.standardSeconds", "method_implementation": "{\n    if (seconds == 0) {\n        return ZERO;\n    }\n    return new Duration(FieldUtils.safeMultiply(seconds, DateTimeConstants.MILLIS_PER_SECOND));\n}", "repo_id": "7", "comment": "/**\n * Create a duration with the specified number of seconds assuming that\n * there are the standard number of milliseconds in a second.\n * <p>\n * This method assumes that there are 1000 milliseconds in a second.\n * All currently supplied chronologies use this definition.\n * <p>\n * A Duration is a representation of an amount of time. If you want to express\n * the concept of 'seconds' you should consider using the {@link Seconds} class.\n *\n * @param seconds  the number of standard seconds in this duration\n * @return the duration, never null\n * @throws ArithmeticException if the seconds value is too large\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 561, "method_signature": "Duration standardSeconds(long)"}, "Duration.withDurationAdded": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "Duration.withDurationAdded", "method_implementation": "{\n    if (durationToAdd == null || scalar == 0) {\n        return this;\n    }\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\n}", "repo_id": "7", "comment": "/**\n * Returns a new duration with this length plus that specified multiplied by the scalar.\n * This instance is immutable and is not altered.\n * <p>\n * If the addition is zero, this instance is returned.\n *\n * @param durationToAdd  the duration to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return the new duration instance\n */\n", "repo_name": "joda-time-main/", "id": 565, "method_signature": "Duration withDurationAdded(ReadableDuration, int)"}, "Duration.withMillis": {"callee_method_names": [], "method_name": "Duration.withMillis", "method_implementation": "{\n    if (duration == getMillis()) {\n        return this;\n    }\n    return new Duration(duration);\n}", "repo_id": "7", "comment": "/**\n * Creates a new Duration instance with a different millisecond length.\n *\n * @param duration  the new length of the duration\n * @return the new duration instance\n */\n", "repo_name": "joda-time-main/", "id": 563, "method_signature": "Duration withMillis(long)"}, "DurationField.subtract": {"callee_method_names": [], "method_name": "DurationField.subtract", "method_implementation": "{\n    if (value == Long.MIN_VALUE) {\n        throw new ArithmeticException(\"Long.MIN_VALUE cannot be negated\");\n    }\n    return add(instant, -value);\n}", "repo_id": "7", "comment": "/**\n * Subtracts a duration value (which may be negative) from the instant.\n *\n * @param instant  the milliseconds from 1970-01-01T00:00:00Z to subtract from\n * @param value  the value to subtract, in the units of the field\n * @return the updated milliseconds\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 127, "method_signature": "long subtract(long, long)"}, "DurationFieldType.equals": {"callee_method_names": [], "method_name": "DurationFieldType.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof StandardDurationFieldType) {\n        return iOrdinal == ((StandardDurationFieldType) obj).iOrdinal;\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * @inheritdoc\n */\n", "repo_name": "joda-time-main/", "id": 785, "method_signature": "boolean equals(Object)"}, "DurationFieldType.readResolve": {"callee_method_names": [], "method_name": "DurationFieldType.readResolve", "method_implementation": "{\n    switch(iOrdinal) {\n        case ERAS:\n            return ERAS_TYPE;\n        case CENTURIES:\n            return CENTURIES_TYPE;\n        case WEEKYEARS:\n            return WEEKYEARS_TYPE;\n        case YEARS:\n            return YEARS_TYPE;\n        case MONTHS:\n            return MONTHS_TYPE;\n        case WEEKS:\n            return WEEKS_TYPE;\n        case DAYS:\n            return DAYS_TYPE;\n        case HALFDAYS:\n            return HALFDAYS_TYPE;\n        case HOURS:\n            return HOURS_TYPE;\n        case MINUTES:\n            return MINUTES_TYPE;\n        case SECONDS:\n            return SECONDS_TYPE;\n        case MILLIS:\n            return MILLIS_TYPE;\n        default:\n            // Shouldn't happen.\n            return this;\n    }\n}", "repo_id": "7", "comment": "/**\n * Ensure a singleton is returned.\n *\n * @return the singleton type\n */\n", "repo_name": "joda-time-main/", "id": 786, "method_signature": "Object readResolve()"}, "EthiopicChronology.assemble": {"callee_method_names": ["Fields.getDurationField"], "method_name": "EthiopicChronology.assemble", "method_implementation": "{\n    if (getBase() == null) {\n        super.assemble(fields);\n        // Ethiopic, like Julian, has no year zero.\n        fields.year = new SkipDateTimeField(this, fields.year);\n        fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n        fields.era = ERA_FIELD;\n        fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13);\n        fields.months = fields.monthOfYear.getDurationField();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 312, "method_signature": "void assemble(Fields)"}, "EthiopicChronology.calculateFirstDayOfYearMillis": {"callee_method_names": [], "method_name": "EthiopicChronology.calculateFirstDayOfYearMillis", "method_implementation": "{\n    // Java epoch is 1970-01-01 Gregorian which is 1962-04-23 Ethiopic.\n    // Calculate relative to the nearest leap year and account for the\n    // difference later.\n    int relativeYear = year - 1963;\n    int leapYears;\n    if (relativeYear <= 0) {\n        // Add 3 before shifting right since /4 and >>2 behave differently\n        // on negative numbers.\n        leapYears = (relativeYear + 3) >> 2;\n    } else {\n        leapYears = relativeYear >> 2;\n        // For post 1963 an adjustment is needed as jan1st is before leap day\n        if (!isLeapYear(year)) {\n            leapYears++;\n        }\n    }\n    long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY;\n    // Adjust to account for difference between 1963-01-01 and 1962-04-23.\n    return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 311, "method_signature": "long calculateFirstDayOfYearMillis(int)"}, "EthiopicChronology.getInstance": {"callee_method_names": ["ConcurrentHashMap.get", "ConcurrentHashMap.putIfAbsent"], "method_name": "EthiopicChronology.getInstance", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    EthiopicChronology chrono;\n    EthiopicChronology[] chronos = cCache.get(zone);\n    if (chronos == null) {\n        chronos = new EthiopicChronology[7];\n        EthiopicChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\n        if (oldChronos != null) {\n            chronos = oldChronos;\n        }\n    }\n    try {\n        chrono = chronos[minDaysInFirstWeek - 1];\n    } catch (ArrayIndexOutOfBoundsException e) {\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\n    }\n    if (chrono == null) {\n        synchronized (chronos) {\n            chrono = chronos[minDaysInFirstWeek - 1];\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    // First create without a lower limit.\n                    chrono = new EthiopicChronology(null, null, minDaysInFirstWeek);\n                    // Impose lower limit and make another EthiopicChronology.\n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n                    chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets an instance of the EthiopicChronology in the given time zone.\n *\n * @param zone  the time zone to get the chronology in, null is default\n * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n * @return a chronology in the specified time zone\n */\n", "repo_name": "joda-time-main/", "id": 308, "method_signature": "EthiopicChronology getInstance(DateTimeZone, int)"}, "EthiopicChronology.readResolve": {"callee_method_names": ["Chronology.getZone"], "method_name": "EthiopicChronology.readResolve", "method_implementation": "{\n    Chronology base = getBase();\n    return base == null ? getInstance(DateTimeZone.UTC, getMinimumDaysInFirstWeek()) : getInstance(base.getZone(), getMinimumDaysInFirstWeek());\n}", "repo_id": "7", "comment": "/**\n * Serialization singleton.\n */\n", "repo_name": "joda-time-main/", "id": 309, "method_signature": "Object readResolve()"}, "EthiopicChronology.withZone": {"callee_method_names": [], "method_name": "EthiopicChronology.withZone", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    if (zone == getZone()) {\n        return this;\n    }\n    return getInstance(zone);\n}", "repo_id": "7", "comment": "/**\n * Gets the Chronology in a specific time zone.\n *\n * @param zone  the zone to get the chronology in, null is default\n * @return the chronology\n */\n", "repo_name": "joda-time-main/", "id": 310, "method_signature": "Chronology withZone(DateTimeZone)"}, "ExitAction.actionPerformed": {"callee_method_names": [], "method_name": "ExitAction.actionPerformed", "method_implementation": "{\n    DateTimeBrowser.this.setVisible(false);\n    DateTimeBrowser.this.dispose();\n    System.exit(0);\n}", "repo_id": "7", "comment": "/*\n         * actionPerformed\n         */\n", "repo_name": "joda-time-main/", "id": 1109, "method_signature": "void actionPerformed(ActionEvent)"}, "FieldFormatter.getFieldValue": {"callee_method_names": ["ReadablePeriod.getPeriodType", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get"], "method_name": "FieldFormatter.getFieldValue", "method_implementation": "{\n    PeriodType type;\n    if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n        // Don't need to check if supported.\n        type = null;\n    } else {\n        type = period.getPeriodType();\n    }\n    if (type != null && isSupported(type, iFieldType) == false) {\n        return Long.MAX_VALUE;\n    }\n    long value;\n    switch(iFieldType) {\n        default:\n            return Long.MAX_VALUE;\n        case YEARS:\n            value = period.get(DurationFieldType.years());\n            break;\n        case MONTHS:\n            value = period.get(DurationFieldType.months());\n            break;\n        case WEEKS:\n            value = period.get(DurationFieldType.weeks());\n            break;\n        case DAYS:\n            value = period.get(DurationFieldType.days());\n            break;\n        case HOURS:\n            value = period.get(DurationFieldType.hours());\n            break;\n        case MINUTES:\n            value = period.get(DurationFieldType.minutes());\n            break;\n        case SECONDS:\n            value = period.get(DurationFieldType.seconds());\n            break;\n        case MILLIS:\n            value = period.get(DurationFieldType.millis());\n            break;\n        // drop through\n        case SECONDS_MILLIS:\n        case SECONDS_OPTIONAL_MILLIS:\n            int seconds = period.get(DurationFieldType.seconds());\n            int millis = period.get(DurationFieldType.millis());\n            value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n            break;\n    }\n    // determine if period is zero and this is the last field\n    if (value == 0) {\n        switch(iPrintZeroSetting) {\n            case PRINT_ZERO_NEVER:\n                return Long.MAX_VALUE;\n            case PRINT_ZERO_RARELY_LAST:\n                if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                    for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                        if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                            return Long.MAX_VALUE;\n                        }\n                    }\n                } else {\n                    return Long.MAX_VALUE;\n                }\n                break;\n            case PRINT_ZERO_RARELY_FIRST:\n                if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                    // line split out for IBM JDK\n                    int i = Math.min(iFieldType, 8);\n                    // see bug 1660490\n                    i--;\n                    for (; i >= 0; i--) {\n                        if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                            return Long.MAX_VALUE;\n                        }\n                    }\n                } else {\n                    return Long.MAX_VALUE;\n                }\n                break;\n        }\n    }\n    return value;\n}", "repo_id": "7", "comment": "/**\n * @return Long.MAX_VALUE if nothing to print, otherwise value\n */\n", "repo_name": "joda-time-main/", "id": 886, "method_signature": "long getFieldValue(ReadablePeriod)"}, "FieldFormatter.parseInt": {"callee_method_names": ["String.substring", "String.charAt", "String.charAt", "String.charAt"], "method_name": "FieldFormatter.parseInt", "method_implementation": "{\n    if (length >= 10) {\n        // Since value may exceed max, use stock parser which checks for this.\n        return Integer.parseInt(text.substring(position, position + length));\n    }\n    if (length <= 0) {\n        return 0;\n    }\n    int value = text.charAt(position++);\n    length--;\n    boolean negative;\n    if (value == '-') {\n        if (--length < 0) {\n            return 0;\n        }\n        negative = true;\n        value = text.charAt(position++);\n    } else {\n        negative = false;\n    }\n    value -= '0';\n    while (length-- > 0) {\n        value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n    }\n    return negative ? -value : value;\n}", "repo_id": "7", "comment": "/**\n * @param text text to parse\n * @param position position in text\n * @param length exact count of characters to parse\n * @return parsed int value\n */\n", "repo_name": "joda-time-main/", "id": 885, "method_signature": "int parseInt(String, int, int)"}, "FieldUtils.equals": {"callee_method_names": ["Object.equals"], "method_name": "FieldUtils.equals", "method_implementation": "{\n    if (object1 == object2) {\n        return true;\n    }\n    if (object1 == null || object2 == null) {\n        return false;\n    }\n    return object1.equals(object2);\n}", "repo_id": "7", "comment": "/**\n * Compares two objects as equals handling null.\n *\n * @param object1  the first object\n * @param object2  the second object\n * @return true if equal\n * @since 1.4\n */\n", "repo_name": "joda-time-main/", "id": 42, "method_signature": "boolean equals(Object, Object)"}, "FieldUtils.getWrappedValue": {"callee_method_names": [], "method_name": "FieldUtils.getWrappedValue", "method_implementation": "{\n    if (minValue >= maxValue) {\n        throw new IllegalArgumentException(\"MIN > MAX\");\n    }\n    int wrapRange = maxValue - minValue + 1;\n    value -= minValue;\n    if (value >= 0) {\n        return (value % wrapRange) + minValue;\n    }\n    int remByRange = (-value) % wrapRange;\n    if (remByRange == 0) {\n        return 0 + minValue;\n    }\n    return (wrapRange - remByRange) + minValue;\n}", "repo_id": "7", "comment": "/**\n * Utility method that ensures the given value lies within the field's\n * legal value range.\n *\n * @param value  the value to fit into the wrapped value range\n * @param minValue the wrap range minimum value.\n * @param maxValue the wrap range maximum value.  This must be\n *  greater than minValue (checked by the method).\n * @return the wrapped value\n * @throws IllegalArgumentException if minValue is greater\n *  than or equal to maxValue\n */\n", "repo_name": "joda-time-main/", "id": 41, "method_signature": "int getWrappedValue(int, int, int)"}, "FieldUtils.safeAdd": {"callee_method_names": [], "method_name": "FieldUtils.safeAdd", "method_implementation": "{\n    long sum = val1 + val2;\n    // If there is a sign change, but the two values have the same sign...\n    if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n        throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n    }\n    return sum;\n}", "repo_id": "7", "comment": "/**\n * Add two values throwing an exception if overflow occurs.\n *\n * @param val1  the first value\n * @param val2  the second value\n * @return the new total\n * @throws ArithmeticException if the value is too big or too small\n */\n", "repo_name": "joda-time-main/", "id": 30, "method_signature": "long safeAdd(long, long)"}, "FieldUtils.safeDivide": {"callee_method_names": ["BigDecimal.divide"], "method_name": "FieldUtils.safeDivide", "method_implementation": "{\n    if (dividend == Long.MIN_VALUE && divisor == -1L) {\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + dividend + \" / \" + divisor);\n    }\n    BigDecimal dividendBigDecimal = new BigDecimal(dividend);\n    BigDecimal divisorBigDecimal = new BigDecimal(divisor);\n    return dividendBigDecimal.divide(divisorBigDecimal, roundingMode).longValue();\n}", "repo_id": "7", "comment": "/**\n * Divides the dividend by divisor. Rounding of result occurs\n * as per the roundingMode.\n *\n * @param dividend  the dividend\n * @param divisor  the divisor\n * @param roundingMode  the desired rounding mode\n * @return the division result as per the specified rounding mode\n * @throws ArithmeticException if the operation overflows or the divisor is zero\n */\n", "repo_name": "joda-time-main/", "id": 36, "method_signature": "long safeDivide(long, long, RoundingMode)"}, "FieldUtils.safeMultiply": {"callee_method_names": [], "method_name": "FieldUtils.safeMultiply", "method_implementation": "{\n    if (val2 == 1) {\n        return val1;\n    }\n    if (val1 == 1) {\n        return val2;\n    }\n    if (val1 == 0 || val2 == 0) {\n        return 0;\n    }\n    long total = val1 * val2;\n    if (total / val2 != val1 || val1 == Long.MIN_VALUE && val2 == -1 || val2 == Long.MIN_VALUE && val1 == -1) {\n        throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n    }\n    return total;\n}", "repo_id": "7", "comment": "/**\n * Multiply two values throwing an exception if overflow occurs.\n *\n * @param val1  the first value\n * @param val2  the second value\n * @return the new total\n * @throws ArithmeticException if the value is too big or too small\n */\n", "repo_name": "joda-time-main/", "id": 34, "method_signature": "long safeMultiply(long, long)"}, "FieldUtils.safeNegate": {"callee_method_names": [], "method_name": "FieldUtils.safeNegate", "method_implementation": "{\n    if (value == Integer.MIN_VALUE) {\n        throw new ArithmeticException(\"Integer.MIN_VALUE cannot be negated\");\n    }\n    return -value;\n}", "repo_id": "7", "comment": "/**\n * Negates the input throwing an exception if it can't negate it.\n *\n * @param value  the value to negate\n * @return the negated value\n * @throws ArithmeticException if the value is Integer.MIN_VALUE\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 28, "method_signature": "int safeNegate(int)"}, "FieldUtils.safeSubtract": {"callee_method_names": [], "method_name": "FieldUtils.safeSubtract", "method_implementation": "{\n    long diff = val1 - val2;\n    // If there is a sign change, but the two values have different signs...\n    if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n        throw new ArithmeticException(\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n    }\n    return diff;\n}", "repo_id": "7", "comment": "/**\n * Subtracts two values throwing an exception if overflow occurs.\n *\n * @param val1  the first value, to be taken away from\n * @param val2  the second value, the amount to take away\n * @return the new total\n * @throws ArithmeticException if the value is too big or too small\n */\n", "repo_name": "joda-time-main/", "id": 31, "method_signature": "long safeSubtract(long, long)"}, "FieldUtils.safeToInt": {"callee_method_names": [], "method_name": "FieldUtils.safeToInt", "method_implementation": "{\n    if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n        return (int) value;\n    }\n    throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n}", "repo_id": "7", "comment": "/**\n * Casts to an int throwing an exception if overflow occurs.\n *\n * @param value  the value\n * @return the value as an int\n * @throws ArithmeticException if the value is too big or too small\n */\n", "repo_name": "joda-time-main/", "id": 37, "method_signature": "int safeToInt(long)"}, "FieldUtils.verifyValueBounds": {"callee_method_names": [], "method_name": "FieldUtils.verifyValueBounds", "method_implementation": "{\n    if ((value < lowerBound) || (value > upperBound)) {\n        throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n    }\n}", "repo_id": "7", "comment": "/**\n * Verify that input values are within specified bounds.\n *\n * @param fieldName  the field name to check\n * @param value  the value to check\n * @param lowerBound  the lower bound allowed for value\n * @param upperBound  the upper bound allowed for value\n * @throws IllegalFieldValueException if value is not in the specified bounds\n */\n", "repo_name": "joda-time-main/", "id": 40, "method_signature": "void verifyValueBounds(String, int, int, int)"}, "Fields.copyFieldsFrom": {"callee_method_names": ["Chronology.millis", "Chronology.seconds", "Chronology.minutes", "Chronology.hours", "Chronology.halfdays", "Chronology.days", "Chronology.weeks", "Chronology.weekyears", "Chronology.months", "Chronology.years", "Chronology.centuries", "Chronology.eras", "Chronology.millisOfSecond", "Chronology.millisOfDay", "Chronology.secondOfMinute", "Chronology.secondOfDay", "Chronology.minuteOfHour", "Chronology.minuteOfDay", "Chronology.hourOfDay", "Chronology.clockhourOfDay", "Chronology.hourOfHalfday", "Chronology.clockhourOfHalfday", "Chronology.halfdayOfDay", "Chronology.dayOfWeek", "Chronology.dayOfMonth", "Chronology.dayOfYear", "Chronology.weekOfWeekyear", "Chronology.weekyear", "Chronology.weekyearOfCentury", "Chronology.monthOfYear", "Chronology.year", "Chronology.yearOfEra", "Chronology.yearOfCentury", "Chronology.centuryOfEra", "Chronology.era"], "method_name": "Fields.copyFieldsFrom", "method_implementation": "{\n    {\n        DurationField f;\n        if (isSupported(f = chrono.millis())) {\n            millis = f;\n        }\n        if (isSupported(f = chrono.seconds())) {\n            seconds = f;\n        }\n        if (isSupported(f = chrono.minutes())) {\n            minutes = f;\n        }\n        if (isSupported(f = chrono.hours())) {\n            hours = f;\n        }\n        if (isSupported(f = chrono.halfdays())) {\n            halfdays = f;\n        }\n        if (isSupported(f = chrono.days())) {\n            days = f;\n        }\n        if (isSupported(f = chrono.weeks())) {\n            weeks = f;\n        }\n        if (isSupported(f = chrono.weekyears())) {\n            weekyears = f;\n        }\n        if (isSupported(f = chrono.months())) {\n            months = f;\n        }\n        if (isSupported(f = chrono.years())) {\n            years = f;\n        }\n        if (isSupported(f = chrono.centuries())) {\n            centuries = f;\n        }\n        if (isSupported(f = chrono.eras())) {\n            eras = f;\n        }\n    }\n    {\n        DateTimeField f;\n        if (isSupported(f = chrono.millisOfSecond())) {\n            millisOfSecond = f;\n        }\n        if (isSupported(f = chrono.millisOfDay())) {\n            millisOfDay = f;\n        }\n        if (isSupported(f = chrono.secondOfMinute())) {\n            secondOfMinute = f;\n        }\n        if (isSupported(f = chrono.secondOfDay())) {\n            secondOfDay = f;\n        }\n        if (isSupported(f = chrono.minuteOfHour())) {\n            minuteOfHour = f;\n        }\n        if (isSupported(f = chrono.minuteOfDay())) {\n            minuteOfDay = f;\n        }\n        if (isSupported(f = chrono.hourOfDay())) {\n            hourOfDay = f;\n        }\n        if (isSupported(f = chrono.clockhourOfDay())) {\n            clockhourOfDay = f;\n        }\n        if (isSupported(f = chrono.hourOfHalfday())) {\n            hourOfHalfday = f;\n        }\n        if (isSupported(f = chrono.clockhourOfHalfday())) {\n            clockhourOfHalfday = f;\n        }\n        if (isSupported(f = chrono.halfdayOfDay())) {\n            halfdayOfDay = f;\n        }\n        if (isSupported(f = chrono.dayOfWeek())) {\n            dayOfWeek = f;\n        }\n        if (isSupported(f = chrono.dayOfMonth())) {\n            dayOfMonth = f;\n        }\n        if (isSupported(f = chrono.dayOfYear())) {\n            dayOfYear = f;\n        }\n        if (isSupported(f = chrono.weekOfWeekyear())) {\n            weekOfWeekyear = f;\n        }\n        if (isSupported(f = chrono.weekyear())) {\n            weekyear = f;\n        }\n        if (isSupported(f = chrono.weekyearOfCentury())) {\n            weekyearOfCentury = f;\n        }\n        if (isSupported(f = chrono.monthOfYear())) {\n            monthOfYear = f;\n        }\n        if (isSupported(f = chrono.year())) {\n            year = f;\n        }\n        if (isSupported(f = chrono.yearOfEra())) {\n            yearOfEra = f;\n        }\n        if (isSupported(f = chrono.yearOfCentury())) {\n            yearOfCentury = f;\n        }\n        if (isSupported(f = chrono.centuryOfEra())) {\n            centuryOfEra = f;\n        }\n        if (isSupported(f = chrono.era())) {\n            era = f;\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Copy the supported fields from a chronology into this container.\n *\n * @param chrono  the chronology to copy from, not null\n */\n", "repo_name": "joda-time-main/", "id": 279, "method_signature": "void copyFieldsFrom(Chronology)"}, "FixedDateTimeZone.toTimeZone": {"callee_method_names": ["String.length", "String.startsWith", "String.startsWith"], "method_name": "FixedDateTimeZone.toTimeZone", "method_implementation": "{\n    String id = getID();\n    if (id.length() == 6 && (id.startsWith(\"+\") || id.startsWith(\"-\"))) {\n        // standard format offset [+-]hh:mm\n        // our ID is without any prefix, so we need to add the GMT back\n        return java.util.TimeZone.getTimeZone(\"GMT\" + getID());\n    }\n    // unusual offset, so setup a SimpleTimeZone as best we can\n    return new java.util.SimpleTimeZone(iWallOffset, getID());\n}", "repo_id": "7", "comment": "/**\n * Override to return the correct timezone instance.\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 773, "method_signature": "java.util.TimeZone toTimeZone()"}, "FormatUtils.appendPaddedInteger": {"callee_method_names": ["Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append", "Appendable.append"], "method_name": "FormatUtils.appendPaddedInteger", "method_implementation": "{\n    int intValue = (int) value;\n    if (intValue == value) {\n        appendPaddedInteger(appendable, intValue, size);\n    } else if (size <= 19) {\n        appendable.append(Long.toString(value));\n    } else {\n        if (value < 0) {\n            appendable.append('-');\n            if (value != Long.MIN_VALUE) {\n                value = -value;\n            } else {\n                for (; size > 19; size--) {\n                    appendable.append('0');\n                }\n                appendable.append(\"9223372036854775808\");\n                return;\n            }\n        }\n        int digits = (int) (Math.log(value) / LOG_10) + 1;\n        for (; size > digits; size--) {\n            appendable.append('0');\n        }\n        appendable.append(Long.toString(value));\n    }\n}", "repo_id": "7", "comment": "/**\n * Converts an integer to a string, prepended with a variable amount of '0'\n * pad characters, and appends it to the given buffer.\n *\n * <p>This method is optimized for converting small values to strings.\n *\n * @param appendable receives integer converted to a string\n * @param value value to convert to a string\n * @param size minimum amount of digits to append\n * @throws IOException if an IO error occurs\n * @since 2.4\n */\n", "repo_name": "joda-time-main/", "id": 830, "method_signature": "void appendPaddedInteger(Appendable, long, int)"}, "FormatUtils.appendUnpaddedInteger": {"callee_method_names": ["Appendable.append"], "method_name": "FormatUtils.appendUnpaddedInteger", "method_implementation": "{\n    int intValue = (int) value;\n    if (intValue == value) {\n        appendUnpaddedInteger(appendable, intValue);\n    } else {\n        appendable.append(Long.toString(value));\n    }\n}", "repo_id": "7", "comment": "/**\n * Converts an integer to a string, and appends it to the given appendable.\n *\n * <p>This method is optimized for converting small values to strings.\n *\n * @param appendable receives integer converted to a string\n * @param value value to convert to a string\n * @throws IOException if an IO error occurs\n */\n", "repo_name": "joda-time-main/", "id": 836, "method_signature": "void appendUnpaddedInteger(Appendable, long)"}, "FormatUtils.calculateDigitCount": {"callee_method_names": [], "method_name": "FormatUtils.calculateDigitCount", "method_implementation": "{\n    if (value < 0) {\n        if (value != Long.MIN_VALUE) {\n            return calculateDigitCount(-value) + 1;\n        } else {\n            return 20;\n        }\n    }\n    return (value < 10 ? 1 : (value < 100 ? 2 : (value < 1000 ? 3 : (value < 10000 ? 4 : ((int) (Math.log(value) / LOG_10) + 1)))));\n}", "repo_id": "7", "comment": "/**\n * Calculates the number of decimal digits for the given value,\n * including the sign.\n *\n * @param value the value\n * @return the digit count\n */\n", "repo_name": "joda-time-main/", "id": 839, "method_signature": "int calculateDigitCount(long)"}, "FormatUtils.writePaddedInteger": {"callee_method_names": ["Writer.write", "Writer.write", "Writer.write", "Writer.write", "Writer.write", "Writer.write"], "method_name": "FormatUtils.writePaddedInteger", "method_implementation": "{\n    int intValue = (int) value;\n    if (intValue == value) {\n        writePaddedInteger(out, intValue, size);\n    } else if (size <= 19) {\n        out.write(Long.toString(value));\n    } else {\n        if (value < 0) {\n            out.write('-');\n            if (value != Long.MIN_VALUE) {\n                value = -value;\n            } else {\n                for (; size > 19; size--) {\n                    out.write('0');\n                }\n                out.write(\"9223372036854775808\");\n                return;\n            }\n        }\n        int digits = (int) (Math.log(value) / LOG_10) + 1;\n        for (; size > digits; size--) {\n            out.write('0');\n        }\n        out.write(Long.toString(value));\n    }\n}", "repo_id": "7", "comment": "/**\n * Converts an integer to a string, prepended with a variable amount of '0'\n * pad characters, and writes it to the given writer.\n *\n * <p>This method is optimized for converting small values to strings.\n *\n * @param out receives integer converted to a string\n * @param value value to convert to a string\n * @param size minimum amount of digits to append\n * @throws IOException if an IO error occurs\n */\n", "repo_name": "joda-time-main/", "id": 832, "method_signature": "void writePaddedInteger(Writer, long, int)"}, "FormatUtils.writeUnpaddedInteger": {"callee_method_names": ["Writer.write"], "method_name": "FormatUtils.writeUnpaddedInteger", "method_implementation": "{\n    int intValue = (int) value;\n    if (intValue == value) {\n        writeUnpaddedInteger(out, intValue);\n    } else {\n        out.write(Long.toString(value));\n    }\n}", "repo_id": "7", "comment": "/**\n * Converts an integer to a string, and writes it to the given writer.\n *\n * <p>This method is optimized for converting small values to strings.\n *\n * @param out receives integer converted to a string\n * @param value value to convert to a string\n * @throws IOException if an IO error occurs\n */\n", "repo_name": "joda-time-main/", "id": 838, "method_signature": "void writeUnpaddedInteger(Writer, long)"}, "GJChronology.convertByWeekyear": {"callee_method_names": ["Chronology.weekyear", "Chronology.weekyear", "Chronology.weekOfWeekyear", "Chronology.weekOfWeekyear", "Chronology.dayOfWeek", "Chronology.dayOfWeek", "Chronology.millisOfDay", "Chronology.millisOfDay"], "method_name": "GJChronology.convertByWeekyear", "method_implementation": "{\n    long newInstant;\n    newInstant = to.weekyear().set(0, from.weekyear().get(instant));\n    newInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\n    newInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\n    newInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\n    return newInstant;\n}", "repo_id": "7", "comment": "/**\n * Convert a datetime from one chronology to another.\n */\n", "repo_name": "joda-time-main/", "id": 285, "method_signature": "long convertByWeekyear(long, Chronology, Chronology)"}, "GJChronology.convertByYear": {"callee_method_names": ["Chronology.getDateTimeMillis", "Chronology.year", "Chronology.monthOfYear", "Chronology.dayOfMonth", "Chronology.millisOfDay"], "method_name": "GJChronology.convertByYear", "method_implementation": "{\n    return to.getDateTimeMillis(from.year().get(instant), from.monthOfYear().get(instant), from.dayOfMonth().get(instant), from.millisOfDay().get(instant));\n}", "repo_id": "7", "comment": "/**\n * Convert a datetime from one chronology to another.\n */\n", "repo_name": "joda-time-main/", "id": 284, "method_signature": "long convertByYear(long, Chronology, Chronology)"}, "GJChronology.equals": {"callee_method_names": ["GJChronology.getMinimumDaysInFirstWeek", "GJChronology.getZone"], "method_name": "GJChronology.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof GJChronology) {\n        GJChronology chrono = (GJChronology) obj;\n        return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone());\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if this chronology instance equals another.\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 290, "method_signature": "boolean equals(Object)"}, "GJChronology.getInstance": {"callee_method_names": ["Instant.getMillis"], "method_name": "GJChronology.getInstance", "method_implementation": "{\n    Instant cutoverInstant;\n    if (gregorianCutover == DEFAULT_CUTOVER.getMillis()) {\n        cutoverInstant = null;\n    } else {\n        cutoverInstant = new Instant(gregorianCutover);\n    }\n    return getInstance(zone, cutoverInstant, minDaysInFirstWeek);\n}", "repo_id": "7", "comment": "/**\n * Factory method returns instances of the GJ cutover chronology. Any\n * cutover date may be specified.\n *\n * @param zone  the time zone to use, null is default\n * @param gregorianCutover  the cutover to use\n * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n * @return the chronology, not null\n */\n", "repo_name": "joda-time-main/", "id": 288, "method_signature": "GJChronology getInstance(DateTimeZone, long, int)"}, "GJChronology.hashCode": {"callee_method_names": ["Instant.hashCode"], "method_name": "GJChronology.hashCode", "method_implementation": "{\n    return \"GJ\".hashCode() * 11 + getZone().hashCode() + getMinimumDaysInFirstWeek() + iCutoverInstant.hashCode();\n}", "repo_id": "7", "comment": "/**\n * A suitable hash code for the chronology.\n *\n * @return the hash code\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 291, "method_signature": "int hashCode()"}, "GJChronology.toString": {"callee_method_ids": [842], "callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "Instant.getMillis", "StringBuffer.append", "DateTimeFormatter.withChronology", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.toString"], "method_name": "GJChronology.toString", "method_implementation": "{\n    StringBuffer sb = new StringBuffer(60);\n    sb.append(\"GJChronology\");\n    sb.append('[');\n    sb.append(getZone().getID());\n    if (iCutoverMillis != DEFAULT_CUTOVER.getMillis()) {\n        sb.append(\",cutover=\");\n        DateTimeFormatter printer;\n        if (withUTC().dayOfYear().remainder(iCutoverMillis) == 0) {\n            printer = ISODateTimeFormat.date();\n        } else {\n            printer = ISODateTimeFormat.dateTime();\n        }\n        printer.withChronology(withUTC()).printTo(sb, iCutoverMillis);\n    }\n    if (getMinimumDaysInFirstWeek() != 4) {\n        sb.append(\",mdfw=\");\n        sb.append(getMinimumDaysInFirstWeek());\n    }\n    sb.append(']');\n    return sb.toString();\n}", "repo_id": "7", "comment": "/**\n * Gets a debugging toString.\n *\n * @return a debugging string\n */\n", "repo_name": "joda-time-main/", "id": 292, "method_signature": "String toString()"}, "GJChronology.withZone": {"callee_method_names": [], "method_name": "GJChronology.withZone", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    if (zone == getZone()) {\n        return this;\n    }\n    return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n}", "repo_id": "7", "comment": "/**\n * Gets the Chronology in a specific time zone.\n *\n * @param zone  the zone to get the chronology in, null is default\n * @return the chronology\n */\n", "repo_name": "joda-time-main/", "id": 289, "method_signature": "Chronology withZone(DateTimeZone)"}, "GJEraDateTimeField.get": {"callee_method_ids": [321], "callee_method_names": ["BasicChronology.getYear"], "method_name": "GJEraDateTimeField.get", "method_implementation": "{\n    if (iChronology.getYear(instant) <= 0) {\n        return DateTimeConstants.BCE;\n    } else {\n        return DateTimeConstants.CE;\n    }\n}", "repo_id": "7", "comment": "/**\n * Get the Era component of the specified time instant.\n *\n * @param instant  the time instant in millis to query.\n */\n", "repo_name": "joda-time-main/", "id": 276, "method_signature": "int get(long)"}, "GJEraDateTimeField.set": {"callee_method_ids": [321], "callee_method_names": ["BasicChronology.getYear", "BasicChronology.setYear"], "method_name": "GJEraDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE);\n    int oldEra = get(instant);\n    if (oldEra != era) {\n        int year = iChronology.getYear(instant);\n        return iChronology.setYear(instant, -year);\n    } else {\n        return instant;\n    }\n}", "repo_id": "7", "comment": "/**\n * Set the Era component of the specified time instant.\n *\n * @param instant  the time instant in millis to update.\n * @param era  the era to update the time to.\n * @return the updated time instant.\n * @throws IllegalArgumentException  if era is invalid.\n */\n", "repo_name": "joda-time-main/", "id": 277, "method_signature": "long set(long, int)"}, "GJLocaleSymbols.forLocale": {"callee_method_names": ["ConcurrentHashMap.get", "ConcurrentHashMap.putIfAbsent"], "method_name": "GJLocaleSymbols.forLocale", "method_implementation": "{\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    GJLocaleSymbols symbols = cCache.get(locale);\n    if (symbols == null) {\n        symbols = new GJLocaleSymbols(locale);\n        GJLocaleSymbols oldSymbols = cCache.putIfAbsent(locale, symbols);\n        if (oldSymbols != null) {\n            symbols = oldSymbols;\n        }\n    }\n    return symbols;\n}", "repo_id": "7", "comment": "/**\n * Obtains the symbols for a locale.\n *\n * @param locale  the locale, null returns default\n * @return the symbols, not null\n */\n", "repo_name": "joda-time-main/", "id": 360, "method_signature": "GJLocaleSymbols forLocale(Locale)"}, "GJYearOfEraDateTimeField.set": {"callee_method_ids": [321], "callee_method_names": ["BasicChronology.getYear"], "method_name": "GJYearOfEraDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, year, 1, getMaximumValue());\n    if (iChronology.getYear(instant) <= 0) {\n        year = 1 - year;\n    }\n    return super.set(instant, year);\n}", "repo_id": "7", "comment": "/**\n * Set the year component of the specified time instant.\n *\n * @param instant  the time instant in millis to update.\n * @param year  the year (0,292278994) to update the time to.\n * @return the updated time instant.\n * @throws IllegalArgumentException  if year is invalid.\n */\n", "repo_name": "joda-time-main/", "id": 338, "method_signature": "long set(long, int)"}, "GetterAction.actionPerformed": {"callee_method_names": ["JMenuItem.setEnabled"], "method_name": "GetterAction.actionPerformed", "method_implementation": "{\n    TableView tView = new GetterTableView(currFile);\n    resetDefaults(tView);\n    enableAllViews();\n    jmiGetter.setEnabled(false);\n}", "repo_id": "7", "comment": "/*\n         * actionPerformed\n         */\n", "repo_name": "joda-time-main/", "id": 1110, "method_signature": "void actionPerformed(ActionEvent)"}, "GetterTableView.genCalcdValues": {"callee_method_names": ["LoadedFile.getFileStrings", "LoadedFile.getDtObjects", "ArrayList.size", "ArrayList.size", "ArrayList.get", "ArrayList.get", "DateTime.toString", "DateTime.getMillisOfSecond", "DateTime.getSecondOfMinute", "DateTime.getMinuteOfHour", "DateTime.getHourOfDay", "DateTime.getDayOfWeek", "DateTime.getDayOfMonth", "DateTime.getDayOfYear", "DateTime.getWeekOfWeekyear", "DateTime.getWeekyear", "DateTime.getMonthOfYear", "DateTime.getYear"], "method_name": "GetterTableView.genCalcdValues", "method_implementation": "{\n    Object[][] retValues = null;\n    /*\n             * Create an array of Objects that will contain\n             * other arrays of Objects. (This is the 'column'\n             * array).\n             */\n    ArrayList fileStrings = lddFile.getFileStrings();\n    ArrayList dtObjects = lddFile.getDtObjects();\n    int numRows = fileStrings.size();\n    retValues = new Object[numRows][];\n    int numCols = colNames.length;\n    // System.err.println(\"NumCols : \" + numCols);\n    /*\n             * Prime the array of arrays of Objects, allocating a new\n             * secondary array for each of the primary array's\n             * elements.\n             */\n    for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++nextStrNum) {\n        // get the 'col' array\n        retValues[nextStrNum] = new Object[numCols];\n        //****\n        //* This needs to be sync'd with the colNames array.\n        //****\n        // Current row, 1st column\n        // working row value\n        int column = 0;\n        String fileString = (String) fileStrings.get(nextStrNum);\n        retValues[nextStrNum][column++] = fileString;\n        // Current row, 2nd column\n        DateTime adt = (DateTime) dtObjects.get(nextStrNum);\n        String adtStr = adt.toString();\n        retValues[nextStrNum][column++] = adtStr;\n        // Current row, other columns.\n        // Order here must match that specified in the colNames\n        // array.\n        retValues[nextStrNum][column++] = new Integer(adt.getMillisOfSecond());\n        retValues[nextStrNum][column++] = new Integer(adt.getSecondOfMinute());\n        retValues[nextStrNum][column++] = new Integer(adt.getMinuteOfHour());\n        retValues[nextStrNum][column++] = new Integer(adt.getHourOfDay());\n        retValues[nextStrNum][column++] = new Integer(adt.getDayOfWeek());\n        retValues[nextStrNum][column++] = new Integer(adt.getDayOfMonth());\n        retValues[nextStrNum][column++] = new Integer(adt.getDayOfYear());\n        retValues[nextStrNum][column++] = new Integer(adt.getWeekOfWeekyear());\n        retValues[nextStrNum][column++] = new Integer(adt.getWeekyear());\n        retValues[nextStrNum][column++] = new Integer(adt.getMonthOfYear());\n        retValues[nextStrNum][column++] = new Integer(adt.getYear());\n        //\n    }\n    // the for\n    if (debugf)\n        dumpObjs(retValues, System.err);\n    return retValues;\n}", "repo_id": "7", "comment": "/*\n         * genCalcdValues is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1093, "method_signature": "Object[][] genCalcdValues()"}, "GetterTableView.genColNames": {"callee_method_names": [], "method_name": "GetterTableView.genColNames", "method_implementation": "{\n    Object[] retVal = { \"FileString\", \"toString()\", \"MillisOfSec\", \"SecOfMin\", \"MinOfHr\", \"HrOfDay\", \"DayOfWk\", \"DayOfMon\", \"DayOfYr\", \"WeekOfWY\", \"Weekyear\", \"MonOfYr\", \"Year\" };\n    return retVal;\n}", "repo_id": "7", "comment": "/*\n         * genColNames is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1094, "method_signature": "Object[] genColNames()"}, "GetterTableView.getViewTitle": {"callee_method_names": ["LoadedFile.getLoadedFileSize"], "method_name": "GetterTableView.getViewTitle", "method_implementation": "{\n    return \"DateTime.getXXX() Method Calculations\" + \" : \" + TimeZone.getDefault().getDisplayName() + \" : \" + \" Record Count \" + currFile.getLoadedFileSize();\n}", "repo_id": "7", "comment": "/*\n         * getViewTitle\n         */\n", "repo_name": "joda-time-main/", "id": 1095, "method_signature": "String getViewTitle()"}, "GetterTableView.setViewColumnsWidth": {"callee_method_names": ["JTable.getColumnModel", "TableColumnModel.getColumn", "TableColumn.setPreferredWidth", "TableColumnModel.getColumn", "TableColumn.setPreferredWidth"], "method_name": "GetterTableView.setViewColumnsWidth", "method_implementation": "{\n    /*\n             * Resize column 0, 1\n             */\n    TableColumnModel colmodel = jt.getColumnModel();\n    TableColumn col0 = colmodel.getColumn(0);\n    col0.setPreferredWidth(200);\n    TableColumn col1 = colmodel.getColumn(1);\n    col1.setPreferredWidth(200);\n    return;\n}", "repo_id": "7", "comment": "/*\n         * setViewColumnLengths\n         */\n", "repo_name": "joda-time-main/", "id": 1096, "method_signature": "void setViewColumnsWidth(JTable)"}, "GregorianChronology.getInstance": {"callee_method_names": ["ConcurrentHashMap.get", "ConcurrentHashMap.putIfAbsent"], "method_name": "GregorianChronology.getInstance", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    GregorianChronology chrono;\n    GregorianChronology[] chronos = cCache.get(zone);\n    if (chronos == null) {\n        chronos = new GregorianChronology[7];\n        GregorianChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\n        if (oldChronos != null) {\n            chronos = oldChronos;\n        }\n    }\n    try {\n        chrono = chronos[minDaysInFirstWeek - 1];\n    } catch (ArrayIndexOutOfBoundsException e) {\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\n    }\n    if (chrono == null) {\n        synchronized (chronos) {\n            chrono = chronos[minDaysInFirstWeek - 1];\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets an instance of the GregorianChronology in the given time zone.\n *\n * @param zone  the time zone to get the chronology in, null is default\n * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n * @return a chronology in the specified time zone\n */\n", "repo_name": "joda-time-main/", "id": 335, "method_signature": "GregorianChronology getInstance(DateTimeZone, int)"}, "GregorianChronology.readResolve": {"callee_method_names": ["Chronology.getZone"], "method_name": "GregorianChronology.readResolve", "method_implementation": "{\n    Chronology base = getBase();\n    int minDays = getMinimumDaysInFirstWeek();\n    // handle rename of BaseGJChronology\n    minDays = (minDays == 0 ? 4 : minDays);\n    return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays);\n}", "repo_id": "7", "comment": "/**\n * Serialization singleton\n */\n", "repo_name": "joda-time-main/", "id": 336, "method_signature": "Object readResolve()"}, "GregorianChronology.withZone": {"callee_method_names": [], "method_name": "GregorianChronology.withZone", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    if (zone == getZone()) {\n        return this;\n    }\n    return getInstance(zone);\n}", "repo_id": "7", "comment": "/**\n * Gets the Chronology in a specific time zone.\n *\n * @param zone  the zone to get the chronology in, null is default\n * @return the chronology\n */\n", "repo_name": "joda-time-main/", "id": 337, "method_signature": "Chronology withZone(DateTimeZone)"}, "HexAction.actionPerformed": {"callee_method_names": ["JMenuItem.setEnabled"], "method_name": "HexAction.actionPerformed", "method_implementation": "{\n    TableView tView = new HexTableView(currFile);\n    resetDefaults(tView);\n    enableAllViews();\n    jmiHex.setEnabled(false);\n}", "repo_id": "7", "comment": "/*\n         * actionPerformed\n         */\n", "repo_name": "joda-time-main/", "id": 1111, "method_signature": "void actionPerformed(ActionEvent)"}, "HexTableView.genCalcdValues": {"callee_method_names": ["LoadedFile.getFileStrings", "LoadedFile.getDtObjects", "ArrayList.size", "ArrayList.size", "ArrayList.get", "ArrayList.get", "DateTime.toString", "DateTime.getMillis", "DateFormat.parse", "Date.getTime"], "method_name": "HexTableView.genCalcdValues", "method_implementation": "{\n    Object[][] retValues = null;\n    /*\n             * Create an array of Objects that will contain\n             * other arrays of Objects. (This is the 'column'\n             * array).\n             */\n    ArrayList fileStrings = lddFile.getFileStrings();\n    ArrayList dtObjects = lddFile.getDtObjects();\n    int numRows = fileStrings.size();\n    retValues = new Object[numRows][];\n    int numCols = colNames.length;\n    // System.err.println(\"NumCols : \" + numCols);\n    String fs = \"yyyy-MM-dd'T'HH:mm:ss\";\n    DateFormat df = new SimpleDateFormat(fs);\n    /*\n             * Prime the array of arrays of Objects, allocating a new\n             * secondary array for each of the primary array's\n             * elements.\n             */\n    for (int nextStrNum = 0; nextStrNum < fileStrings.size(); ++nextStrNum) {\n        // get the 'col' array\n        retValues[nextStrNum] = new Object[numCols];\n        //****\n        //* This needs to be sync'd with the colNames array.\n        //****\n        // Current row, 1st column\n        int column = 0;\n        String fileString = (String) fileStrings.get(nextStrNum);\n        retValues[nextStrNum][column++] = fileString;\n        // Current row, 2nd column\n        DateTime adt = (DateTime) dtObjects.get(nextStrNum);\n        String adtStr = adt.toString();\n        retValues[nextStrNum][column++] = adtStr;\n        // Current row, other columns.\n        // Order here must match that specified in the colNames\n        // array.\n        long lVal = adt.getMillis();\n        Long millis = new Long(lVal);\n        retValues[nextStrNum][column++] = millis;\n        String hexVal = Long.toHexString(lVal);\n        String octalVal = Long.toOctalString(lVal);\n        retValues[nextStrNum][column++] = \"0\" + LPad(octalVal, 22);\n        retValues[nextStrNum][column++] = \"0x\" + LPad(hexVal, 16);\n        //\n        Date javaDate = null;\n        try {\n            javaDate = df.parse(fileString);\n        } catch (ParseException e) {\n            System.err.println(\"Parse failed for : \" + fileString);\n            // pe.printStackTrace();\n        }\n        //\n        lVal = javaDate.getTime();\n        millis = new Long(lVal);\n        hexVal = Long.toHexString(lVal);\n        octalVal = Long.toOctalString(lVal);\n        retValues[nextStrNum][column++] = millis;\n        retValues[nextStrNum][column++] = \"0\" + LPad(octalVal, 22);\n        retValues[nextStrNum][column++] = \"0x\" + LPad(hexVal, 16);\n        //\n    }\n    // the for\n    if (debugf)\n        dumpObjs(retValues, System.err);\n    return retValues;\n}", "repo_id": "7", "comment": "/*\n         * genCalcdValues is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1097, "method_signature": "Object[][] genCalcdValues()"}, "HexTableView.genColNames": {"callee_method_names": [], "method_name": "HexTableView.genColNames", "method_implementation": "{\n    Object[] retVal = { \"FileString\", \"toString()\", \"JDT-millis\", \"JDT-Oct\", \"JDT-Hex\", \"Date-millis\", \"Date-Oct\", \"Date-Hex\" };\n    return retVal;\n}", "repo_id": "7", "comment": "/*\n         * genColNames is required by the base class.\n         */\n", "repo_name": "joda-time-main/", "id": 1098, "method_signature": "Object[] genColNames()"}, "HexTableView.getViewTitle": {"callee_method_names": ["LoadedFile.getLoadedFileSize"], "method_name": "HexTableView.getViewTitle", "method_implementation": "{\n    return \"View the long values\" + \" : \" + TimeZone.getDefault().getDisplayName() + \" : \" + \" Record Count \" + currFile.getLoadedFileSize();\n}", "repo_id": "7", "comment": "/*\n         * getViewTitle\n         */\n", "repo_name": "joda-time-main/", "id": 1099, "method_signature": "String getViewTitle()"}, "Hours.dividedBy": {"callee_method_names": [], "method_name": "Hours.dividedBy", "method_implementation": "{\n    if (divisor == 1) {\n        return this;\n    }\n    return Hours.hours(getValue() / divisor);\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the hours divided by the specified divisor.\n * The calculation uses integer division, thus 3 divided by 2 is 1.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param divisor  the amount to divide by, may be negative\n * @return the new period divided by the specified divisor\n * @throws ArithmeticException if the divisor is zero\n */\n", "repo_name": "joda-time-main/", "id": 93, "method_signature": "Hours dividedBy(int)"}, "Hours.hours": {"callee_method_names": [], "method_name": "Hours.hours", "method_implementation": "{\n    switch(hours) {\n        case 0:\n            return ZERO;\n        case 1:\n            return ONE;\n        case 2:\n            return TWO;\n        case 3:\n            return THREE;\n        case 4:\n            return FOUR;\n        case 5:\n            return FIVE;\n        case 6:\n            return SIX;\n        case 7:\n            return SEVEN;\n        case 8:\n            return EIGHT;\n        case Integer.MAX_VALUE:\n            return MAX_VALUE;\n        case Integer.MIN_VALUE:\n            return MIN_VALUE;\n        default:\n            return new Hours(hours);\n    }\n}", "repo_id": "7", "comment": "/**\n * Obtains an instance of <code>Hours</code> that may be cached.\n * <code>Hours</code> is immutable, so instances can be cached and shared.\n * This factory method provides access to shared instances.\n *\n * @param hours  the number of hours to obtain an instance for\n * @return the instance of Hours\n */\n", "repo_name": "joda-time-main/", "id": 86, "method_signature": "Hours hours(int)"}, "Hours.hoursBetween": {"callee_method_names": ["ReadablePartial.getChronology", "Chronology.hours"], "method_name": "Hours.hoursBetween", "method_implementation": "{\n    if (start instanceof LocalTime && end instanceof LocalTime) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int hours = chrono.hours().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n        return Hours.hours(hours);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return Hours.hours(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Hours</code> representing the number of whole hours\n * between the two specified partial datetimes.\n * <p>\n * The two partials must contain the same fields, for example you can specify\n * two <code>LocalTime</code> objects.\n *\n * @param start  the start partial date, must not be null\n * @param end  the end partial date, must not be null\n * @return the period in hours\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 87, "method_signature": "Hours hoursBetween(ReadablePartial, ReadablePartial)"}, "Hours.hoursIn": {"callee_method_names": ["ReadableInterval.getStart", "ReadableInterval.getEnd"], "method_name": "Hours.hoursIn", "method_implementation": "{\n    if (interval == null) {\n        return Hours.ZERO;\n    }\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.hours());\n    return Hours.hours(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Hours</code> representing the number of whole hours\n * in the specified interval.\n *\n * @param interval  the interval to extract hours from, null returns zero\n * @return the period in hours\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 88, "method_signature": "Hours hoursIn(ReadableInterval)"}, "Hours.isGreaterThan": {"callee_method_names": ["Hours.getValue"], "method_name": "Hours.isGreaterThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() > 0;\n    }\n    return getValue() > other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this hours instance greater than the specified number of hours.\n *\n * @param other  the other period, null means zero\n * @return true if this hours instance is greater than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 94, "method_signature": "boolean isGreaterThan(Hours)"}, "Hours.isLessThan": {"callee_method_names": ["Hours.getValue"], "method_name": "Hours.isLessThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() < 0;\n    }\n    return getValue() < other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this hours instance less than the specified number of hours.\n *\n * @param other  the other period, null means zero\n * @return true if this hours instance is less than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 95, "method_signature": "boolean isLessThan(Hours)"}, "Hours.minus": {"callee_method_names": ["Hours.getValue"], "method_name": "Hours.minus", "method_implementation": "{\n    if (hours == null) {\n        return this;\n    }\n    return minus(hours.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of hours taken away.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param hours  the amount of hours to take away, may be negative, null means zero\n * @return the new period minus the specified number of hours\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 92, "method_signature": "Hours minus(Hours)"}, "Hours.parseHours": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod", "Period.getHours"], "method_name": "Hours.parseHours", "method_implementation": "{\n    if (periodStr == null) {\n        return Hours.ZERO;\n    }\n    Period p = PARSER.parsePeriod(periodStr);\n    return Hours.hours(p.getHours());\n}", "repo_id": "7", "comment": "/**\n * Creates a new <code>Hours</code> by parsing a string in the ISO8601 format 'PTnH'.\n * <p>\n * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n * hours component may be non-zero. If any other component is non-zero, an exception\n * will be thrown.\n *\n * @param periodStr  the period string, null returns zero\n * @return the period in hours\n * @throws IllegalArgumentException if the string format is invalid\n */\n", "repo_name": "joda-time-main/", "id": 89, "method_signature": "Hours parseHours(String)"}, "Hours.plus": {"callee_method_names": ["Hours.getValue"], "method_name": "Hours.plus", "method_implementation": "{\n    if (hours == null) {\n        return this;\n    }\n    return plus(hours.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of hours added.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param hours  the amount of hours to add, may be negative, null means zero\n * @return the new period plus the specified number of hours\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 91, "method_signature": "Hours plus(Hours)"}, "Hours.toString": {"callee_method_names": [], "method_name": "Hours.toString", "method_implementation": "{\n    return \"PT\" + String.valueOf(getValue()) + \"H\";\n}", "repo_id": "7", "comment": "/**\n * Gets this instance as a String in the ISO8601 duration format.\n * <p>\n * For example, \"PT4H\" represents 4 hours.\n *\n * @return the value as an ISO8601 string\n */\n", "repo_name": "joda-time-main/", "id": 96, "method_signature": "String toString()"}, "ISOChronology.equals": {"callee_method_names": ["ISOChronology.getZone"], "method_name": "ISOChronology.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof ISOChronology) {\n        ISOChronology chrono = (ISOChronology) obj;\n        return getZone().equals(chrono.getZone());\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if this chronology instance equals another.\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 1.6\n */\n", "repo_name": "joda-time-main/", "id": 334, "method_signature": "boolean equals(Object)"}, "ISOChronology.getInstance": {"callee_method_names": ["ConcurrentHashMap.get", "ConcurrentHashMap.putIfAbsent"], "method_name": "ISOChronology.getInstance", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    ISOChronology chrono = cCache.get(zone);\n    if (chrono == null) {\n        chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n        ISOChronology oldChrono = cCache.putIfAbsent(zone, chrono);\n        if (oldChrono != null) {\n            chrono = oldChrono;\n        }\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets an instance of the ISOChronology in the given time zone.\n *\n * @param zone  the time zone to get the chronology in, null is default\n * @return a chronology in the specified time zone\n */\n", "repo_name": "joda-time-main/", "id": 331, "method_signature": "ISOChronology getInstance(DateTimeZone)"}, "ISOChronology.toString": {"callee_method_names": ["DateTimeZone.getID"], "method_name": "ISOChronology.toString", "method_implementation": "{\n    String str = \"ISOChronology\";\n    DateTimeZone zone = getZone();\n    if (zone != null) {\n        str = str + '[' + zone.getID() + ']';\n    }\n    return str;\n}", "repo_id": "7", "comment": "/**\n * Gets a debugging toString.\n *\n * @return a debugging string\n */\n", "repo_name": "joda-time-main/", "id": 333, "method_signature": "String toString()"}, "ISOChronology.withZone": {"callee_method_names": [], "method_name": "ISOChronology.withZone", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    if (zone == getZone()) {\n        return this;\n    }\n    return getInstance(zone);\n}", "repo_id": "7", "comment": "/**\n * Gets the Chronology in a specific time zone.\n *\n * @param zone  the zone to get the chronology in, null is default\n * @return the chronology\n */\n", "repo_name": "joda-time-main/", "id": 332, "method_signature": "Chronology withZone(DateTimeZone)"}, "ISODateTimeFormat.appendSeparator": {"callee_method_ids": [920], "callee_method_names": ["DateTimeFormatterBuilder.appendLiteral"], "method_name": "ISODateTimeFormat.appendSeparator", "method_implementation": "{\n    if (extended) {\n        bld.appendLiteral('-');\n    }\n}", "repo_id": "7", "comment": "/**\n * Appends the separator if necessary.\n *\n * @param bld  the builder\n * @param extended  whether to append the separator\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 816, "method_signature": "void appendSeparator(DateTimeFormatterBuilder, boolean)"}, "ISODateTimeFormat.basicDate": {"callee_method_names": [], "method_name": "ISODateTimeFormat.basicDate", "method_implementation": "{\n    if (bd == null) {\n        return new DateTimeFormatterBuilder().appendYear(4, 4).appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2).appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2).toFormatter();\n    }\n    return bd;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 819, "method_signature": "DateTimeFormatter basicDate()"}, "ISODateTimeFormat.checkNotStrictISO": {"callee_method_names": [], "method_name": "ISODateTimeFormat.checkNotStrictISO", "method_implementation": "{\n    if (strictISO) {\n        throw new IllegalArgumentException(\"No valid ISO8601 format for fields: \" + fields);\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks that the iso only flag is not set, throwing an exception if it is.\n *\n * @param fields  the fields\n * @param strictISO  true if only ISO formats allowed\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 815, "method_signature": "void checkNotStrictISO(Collection, boolean)"}, "ISODateTimeFormat.dateByMonth": {"callee_method_ids": [916, 920, 920, 920, 920, 920, 920, 920, 920], "callee_method_names": ["Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.append", "Collection<DateTimeFieldType>.remove", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendMonthOfYear", "DateTimeFormatterBuilder.appendDayOfMonth", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendMonthOfYear", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendDayOfMonth", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendMonthOfYear", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendDayOfMonth", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendDayOfMonth"], "method_name": "ISODateTimeFormat.dateByMonth", "method_implementation": "{\n    boolean reducedPrec = false;\n    if (fields.remove(DateTimeFieldType.year())) {\n        bld.append(Constants.ye);\n        if (fields.remove(DateTimeFieldType.monthOfYear())) {\n            if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n                // YYYY-MM-DD/YYYYMMDD\n                appendSeparator(bld, extended);\n                bld.appendMonthOfYear(2);\n                appendSeparator(bld, extended);\n                bld.appendDayOfMonth(2);\n            } else {\n                // YYYY-MM/YYYY-MM\n                bld.appendLiteral('-');\n                bld.appendMonthOfYear(2);\n                reducedPrec = true;\n            }\n        } else {\n            if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n                // YYYY--DD/YYYY--DD (non-iso)\n                checkNotStrictISO(fields, strictISO);\n                bld.appendLiteral('-');\n                bld.appendLiteral('-');\n                bld.appendDayOfMonth(2);\n            } else {\n                // YYYY/YYYY\n                reducedPrec = true;\n            }\n        }\n    } else if (fields.remove(DateTimeFieldType.monthOfYear())) {\n        bld.appendLiteral('-');\n        bld.appendLiteral('-');\n        bld.appendMonthOfYear(2);\n        if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n            // --MM-DD/--MMDD\n            appendSeparator(bld, extended);\n            bld.appendDayOfMonth(2);\n        } else {\n            // --MM/--MM\n            reducedPrec = true;\n        }\n    } else if (fields.remove(DateTimeFieldType.dayOfMonth())) {\n        // ---DD/---DD\n        bld.appendLiteral('-');\n        bld.appendLiteral('-');\n        bld.appendLiteral('-');\n        bld.appendDayOfMonth(2);\n    }\n    return reducedPrec;\n}", "repo_id": "7", "comment": "/**\n * Creates a date using the calendar date format.\n * Specification reference: 5.2.1.\n *\n * @param bld  the builder\n * @param fields  the fields\n * @param extended  true to use extended format\n * @param strictISO  true to only allow ISO formats\n * @return true if reduced precision\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 811, "method_signature": "boolean dateByMonth(DateTimeFormatterBuilder, Collection, boolean, boolean)"}, "ISODateTimeFormat.dateByOrdinal": {"callee_method_ids": [916, 920], "callee_method_names": ["Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.append", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendDayOfYear", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendDayOfYear"], "method_name": "ISODateTimeFormat.dateByOrdinal", "method_implementation": "{\n    boolean reducedPrec = false;\n    if (fields.remove(DateTimeFieldType.year())) {\n        bld.append(Constants.ye);\n        if (fields.remove(DateTimeFieldType.dayOfYear())) {\n            // YYYY-DDD/YYYYDDD\n            appendSeparator(bld, extended);\n            bld.appendDayOfYear(3);\n        } else {\n            // YYYY/YYYY\n            reducedPrec = true;\n        }\n    } else if (fields.remove(DateTimeFieldType.dayOfYear())) {\n        // -DDD/-DDD\n        bld.appendLiteral('-');\n        bld.appendDayOfYear(3);\n    }\n    return reducedPrec;\n}", "repo_id": "7", "comment": "/**\n * Creates a date using the ordinal date format.\n * Specification reference: 5.2.2.\n *\n * @param bld  the builder\n * @param fields  the fields\n * @param extended  true to use extended format\n * @param strictISO  true to only allow ISO formats\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 812, "method_signature": "boolean dateByOrdinal(DateTimeFormatterBuilder, Collection, boolean, boolean)"}, "ISODateTimeFormat.dateByWeek": {"callee_method_ids": [916, 920, 920, 920, 920, 920, 920, 920, 920], "callee_method_names": ["Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.append", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendWeekOfWeekyear", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendDayOfWeek", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendDayOfWeek", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendWeekOfWeekyear", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendDayOfWeek", "Collection<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendDayOfWeek"], "method_name": "ISODateTimeFormat.dateByWeek", "method_implementation": "{\n    boolean reducedPrec = false;\n    if (fields.remove(DateTimeFieldType.weekyear())) {\n        bld.append(Constants.we);\n        if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\n            appendSeparator(bld, extended);\n            bld.appendLiteral('W');\n            bld.appendWeekOfWeekyear(2);\n            if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n                // YYYY-WWW-D/YYYYWWWD\n                appendSeparator(bld, extended);\n                bld.appendDayOfWeek(1);\n            } else {\n                // YYYY-WWW/YYYY-WWW\n                reducedPrec = true;\n            }\n        } else {\n            if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n                // YYYY-W-D/YYYYW-D (non-iso)\n                checkNotStrictISO(fields, strictISO);\n                appendSeparator(bld, extended);\n                bld.appendLiteral('W');\n                bld.appendLiteral('-');\n                bld.appendDayOfWeek(1);\n            } else {\n                // YYYY/YYYY\n                reducedPrec = true;\n            }\n        }\n    } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) {\n        bld.appendLiteral('-');\n        bld.appendLiteral('W');\n        bld.appendWeekOfWeekyear(2);\n        if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n            // -WWW-D/-WWWD\n            appendSeparator(bld, extended);\n            bld.appendDayOfWeek(1);\n        } else {\n            // -WWW/-WWW\n            reducedPrec = true;\n        }\n    } else if (fields.remove(DateTimeFieldType.dayOfWeek())) {\n        // -W-D/-W-D\n        bld.appendLiteral('-');\n        bld.appendLiteral('W');\n        bld.appendLiteral('-');\n        bld.appendDayOfWeek(1);\n    }\n    return reducedPrec;\n}", "repo_id": "7", "comment": "/**\n * Creates a date using the calendar date format.\n * Specification reference: 5.2.3.\n *\n * @param bld  the builder\n * @param fields  the fields\n * @param extended  true to use extended format\n * @param strictISO  true to only allow ISO formats\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 813, "method_signature": "boolean dateByWeek(DateTimeFormatterBuilder, Collection, boolean, boolean)"}, "ISODateTimeFormat.dateParser": {"callee_method_names": [], "method_name": "ISODateTimeFormat.dateParser", "method_implementation": "{\n    if (dp == null) {\n        DateTimeParser tOffset = new DateTimeFormatterBuilder().appendLiteral('T').append(offsetElement()).toParser();\n        return new DateTimeFormatterBuilder().append(dateElementParser()).appendOptional(tOffset).toFormatter();\n    }\n    return dp;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 817, "method_signature": "DateTimeFormatter dateParser()"}, "ISODateTimeFormat.forFields": {"callee_method_ids": [916, 916, 911], "callee_method_names": ["Collection<DateTimeFieldType>.size", "Set<DateTimeFieldType>.size", "Set<DateTimeFieldType>.contains", "Set<DateTimeFieldType>.contains", "Set<DateTimeFieldType>.contains", "Set<DateTimeFieldType>.contains", "Set<DateTimeFieldType>.contains", "Set<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.append", "Set<DateTimeFieldType>.remove", "DateTimeFormatterBuilder.append", "Set<DateTimeFieldType>.size", "DateTimeFormatterBuilder.canBuildFormatter", "Collection<DateTimeFieldType>.retainAll", "DateTimeFormatterBuilder.toFormatter"], "method_name": "ISODateTimeFormat.forFields", "method_implementation": "{\n    if (fields == null || fields.size() == 0) {\n        throw new IllegalArgumentException(\"The fields must not be null or empty\");\n    }\n    Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields);\n    int inputSize = workingFields.size();\n    boolean reducedPrec = false;\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    // date\n    if (workingFields.contains(DateTimeFieldType.monthOfYear())) {\n        reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n    } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) {\n        reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO);\n    } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) {\n        reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n    } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) {\n        reducedPrec = dateByMonth(bld, workingFields, extended, strictISO);\n    } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) {\n        reducedPrec = dateByWeek(bld, workingFields, extended, strictISO);\n    } else if (workingFields.remove(DateTimeFieldType.year())) {\n        bld.append(Constants.ye);\n        reducedPrec = true;\n    } else if (workingFields.remove(DateTimeFieldType.weekyear())) {\n        bld.append(Constants.we);\n        reducedPrec = true;\n    }\n    boolean datePresent = (workingFields.size() < inputSize);\n    // time\n    time(bld, workingFields, extended, strictISO, reducedPrec, datePresent);\n    // result\n    if (bld.canBuildFormatter() == false) {\n        throw new IllegalArgumentException(\"No valid format for fields: \" + fields);\n    }\n    // side effect the input collection to indicate the processed fields\n    // handling unmodifiable collections with no side effect\n    try {\n        fields.retainAll(workingFields);\n    } catch (UnsupportedOperationException ex) {\n        // ignore, so we can handle unmodifiable collections\n    }\n    return bld.toFormatter();\n}", "repo_id": "7", "comment": "/**\n * Returns a formatter that outputs only those fields specified.\n * <p>\n * This method examines the fields provided and returns an ISO-style\n * formatter that best fits. This can be useful for outputting\n * less-common ISO styles, such as YearMonth (YYYY-MM) or MonthDay (--MM-DD).\n * <p>\n * Note that parsing is often not supported by the resulting formatter, especially in basic mode.\n * <p>\n * The list provided may have overlapping fields, such as dayOfWeek and\n * dayOfMonth. In this case, the style is chosen based on the following\n * list, thus in the example, the calendar style is chosen as dayOfMonth\n * is higher in priority than dayOfWeek:\n * <ul>\n * <li>monthOfYear - calendar date style\n * <li>dayOfYear - ordinal date style\n * <li>weekOfWeekYear - week date style\n * <li>dayOfMonth - calendar date style\n * <li>dayOfWeek - week date style\n * <li>year\n * <li>weekyear\n * </ul>\n * The supported formats are:\n * <pre>\n * Extended      Basic       Fields\n * 2005-03-25    20050325    year/monthOfYear/dayOfMonth\n * 2005-03       2005-03     year/monthOfYear\n * 2005--25      2005--25    year/dayOfMonth *\n * 2005          2005        year\n * --03-25       --0325      monthOfYear/dayOfMonth\n * --03          --03        monthOfYear\n * ---03         ---03       dayOfMonth\n * 2005-084      2005084     year/dayOfYear\n * -084          -084        dayOfYear\n * 2005-W12-5    2005W125    weekyear/weekOfWeekyear/dayOfWeek\n * 2005-W-5      2005W-5     weekyear/dayOfWeek *\n * 2005-W12      2005W12     weekyear/weekOfWeekyear\n * -W12-5        -W125       weekOfWeekyear/dayOfWeek\n * -W12          -W12        weekOfWeekyear\n * -W-5          -W-5        dayOfWeek\n * 10:20:30.040  102030.040  hour/minute/second/milli\n * 10:20:30      102030      hour/minute/second\n * 10:20         1020        hour/minute\n * 10            10          hour\n * -20:30.040    -2030.040   minute/second/milli\n * -20:30        -2030       minute/second\n * -20           -20         minute\n * --30.040      --30.040    second/milli\n * --30          --30        second\n * ---.040       ---.040     milli *\n * 10-30.040     10-30.040   hour/second/milli *\n * 10:20-.040    1020-.040   hour/minute/milli *\n * 10-30         10-30       hour/second *\n * 10--.040      10--.040    hour/milli *\n * -20-.040      -20-.040    minute/milli *\n *   plus datetime formats like {date}T{time}\n * </pre>\n * * indicates that this is not an official ISO format and can be excluded\n * by passing in <code>strictISO</code> as <code>true</code>.\n * <p>\n * This method can side effect the input collection of fields.\n * If the input collection is modifiable, then each field that was added to\n * the formatter will be removed from the collection, including any duplicates.\n * If the input collection is unmodifiable then no side effect occurs.\n * <p>\n * This side effect processing is useful if you need to know whether all\n * the fields were converted into the formatter or not. To achieve this,\n * pass in a modifiable list, and check that it is empty on exit.\n *\n * @param fields  the fields to get a formatter for, not null,\n *  updated by the method call unless unmodifiable,\n *  removing those fields built in the formatter\n * @param extended  true to use the extended format (with separators)\n * @param strictISO  true to stick exactly to ISO8601, false to include additional formats\n * @return a suitable formatter\n * @throws IllegalArgumentException if there is no format for the fields\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 810, "method_signature": "DateTimeFormatter forFields(Collection, boolean, boolean)"}, "ISODateTimeFormat.time": {"callee_method_names": [], "method_name": "ISODateTimeFormat.time", "method_implementation": "{\n    if (t == null) {\n        return new DateTimeFormatterBuilder().append(hourMinuteSecondFraction()).append(offsetElement()).toFormatter();\n    }\n    return t;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 818, "method_signature": "DateTimeFormatter time()"}, "ISODateTimeFormat.yearElement": {"callee_method_names": [], "method_name": "ISODateTimeFormat.yearElement", "method_implementation": "{\n    if (ye == null) {\n        return new DateTimeFormatterBuilder().appendYear(4, 9).toFormatter();\n    }\n    return ye;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 821, "method_signature": "DateTimeFormatter yearElement()"}, "ISODateTimeFormat.yearMonth": {"callee_method_names": [], "method_name": "ISODateTimeFormat.yearMonth", "method_implementation": "{\n    if (ym == null) {\n        return new DateTimeFormatterBuilder().append(yearElement()).append(monthElement()).toFormatter();\n    }\n    return ym;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 820, "method_signature": "DateTimeFormatter yearMonth()"}, "ISOPeriodFormat.alternate": {"callee_method_names": [], "method_name": "ISOPeriodFormat.alternate", "method_implementation": "{\n    if (cAlternate == null) {\n        cAlternate = new PeriodFormatterBuilder().appendLiteral(\"P\").printZeroAlways().minimumPrintedDigits(4).appendYears().minimumPrintedDigits(2).appendMonths().appendDays().appendSeparatorIfFieldsAfter(\"T\").appendHours().appendMinutes().appendSecondsWithOptionalMillis().toFormatter();\n    }\n    return cAlternate;\n}", "repo_id": "7", "comment": "/**\n * The alternate ISO format, PyyyymmddThhmmss, which excludes weeks.\n * <p>\n * Even if weeks are present in the period, they are not output.\n * Fractional seconds (milliseconds) will appear if required.\n *\n * @return the formatter\n */\n", "repo_name": "joda-time-main/", "id": 798, "method_signature": "PeriodFormatter alternate()"}, "ISOPeriodFormat.alternateExtended": {"callee_method_names": [], "method_name": "ISOPeriodFormat.alternateExtended", "method_implementation": "{\n    if (cAlternateExtended == null) {\n        cAlternateExtended = new PeriodFormatterBuilder().appendLiteral(\"P\").printZeroAlways().minimumPrintedDigits(4).appendYears().appendSeparator(\"-\").minimumPrintedDigits(2).appendMonths().appendSeparator(\"-\").appendDays().appendSeparatorIfFieldsAfter(\"T\").appendHours().appendSeparator(\":\").appendMinutes().appendSeparator(\":\").appendSecondsWithOptionalMillis().toFormatter();\n    }\n    return cAlternateExtended;\n}", "repo_id": "7", "comment": "/**\n * The alternate ISO format, Pyyyy-mm-ddThh:mm:ss, which excludes weeks.\n * <p>\n * Even if weeks are present in the period, they are not output.\n * Fractional seconds (milliseconds) will appear if required.\n *\n * @return the formatter\n */\n", "repo_name": "joda-time-main/", "id": 799, "method_signature": "PeriodFormatter alternateExtended()"}, "ISOPeriodFormat.alternateExtendedWithWeeks": {"callee_method_names": [], "method_name": "ISOPeriodFormat.alternateExtendedWithWeeks", "method_implementation": "{\n    if (cAlternateExtendedWihWeeks == null) {\n        cAlternateExtendedWihWeeks = new PeriodFormatterBuilder().appendLiteral(\"P\").printZeroAlways().minimumPrintedDigits(4).appendYears().appendSeparator(\"-\").minimumPrintedDigits(2).appendPrefix(\"W\").appendWeeks().appendSeparator(\"-\").appendDays().appendSeparatorIfFieldsAfter(\"T\").appendHours().appendSeparator(\":\").appendMinutes().appendSeparator(\":\").appendSecondsWithOptionalMillis().toFormatter();\n    }\n    return cAlternateExtendedWihWeeks;\n}", "repo_id": "7", "comment": "/**\n * The alternate ISO format, Pyyyy-Www-ddThh:mm:ss, which excludes months.\n * <p>\n * Even if months are present in the period, they are not output.\n * Fractional seconds (milliseconds) will appear if required.\n *\n * @return the formatter\n */\n", "repo_name": "joda-time-main/", "id": 801, "method_signature": "PeriodFormatter alternateExtendedWithWeeks()"}, "ISOPeriodFormat.alternateWithWeeks": {"callee_method_names": [], "method_name": "ISOPeriodFormat.alternateWithWeeks", "method_implementation": "{\n    if (cAlternateWithWeeks == null) {\n        cAlternateWithWeeks = new PeriodFormatterBuilder().appendLiteral(\"P\").printZeroAlways().minimumPrintedDigits(4).appendYears().minimumPrintedDigits(2).appendPrefix(\"W\").appendWeeks().appendDays().appendSeparatorIfFieldsAfter(\"T\").appendHours().appendMinutes().appendSecondsWithOptionalMillis().toFormatter();\n    }\n    return cAlternateWithWeeks;\n}", "repo_id": "7", "comment": "/**\n * The alternate ISO format, PyyyyWwwddThhmmss, which excludes months.\n * <p>\n * Even if months are present in the period, they are not output.\n * Fractional seconds (milliseconds) will appear if required.\n *\n * @return the formatter\n */\n", "repo_name": "joda-time-main/", "id": 800, "method_signature": "PeriodFormatter alternateWithWeeks()"}, "ISOPeriodFormat.standard": {"callee_method_names": [], "method_name": "ISOPeriodFormat.standard", "method_implementation": "{\n    if (cStandard == null) {\n        cStandard = new PeriodFormatterBuilder().appendLiteral(\"P\").appendYears().appendSuffix(\"Y\").appendMonths().appendSuffix(\"M\").appendWeeks().appendSuffix(\"W\").appendDays().appendSuffix(\"D\").appendSeparatorIfFieldsAfter(\"T\").appendHours().appendSuffix(\"H\").appendMinutes().appendSuffix(\"M\").appendSecondsWithOptionalMillis().appendSuffix(\"S\").toFormatter();\n    }\n    return cStandard;\n}", "repo_id": "7", "comment": "/**\n * The standard ISO format - PyYmMwWdDThHmMsS.\n * Milliseconds are not output.\n * Note that the ISO8601 standard actually indicates weeks should not\n * be shown if any other field is present and vice versa.\n *\n * @return the formatter\n */\n", "repo_name": "joda-time-main/", "id": 797, "method_signature": "PeriodFormatter standard()"}, "IgnorableAffix.matchesOtherAffix": {"callee_method_names": ["String.regionMatches", "String.regionMatches"], "method_name": "IgnorableAffix.matchesOtherAffix", "method_implementation": "{\n    if (iOtherAffixes != null) {\n        // ignore case when affix length differs\n        // match case when affix length is same\n        for (String affixToIgnore : iOtherAffixes) {\n            int textToIgnoreLength = affixToIgnore.length();\n            if ((textLength < textToIgnoreLength && periodStr.regionMatches(true, position, affixToIgnore, 0, textToIgnoreLength)) || (textLength == textToIgnoreLength && periodStr.regionMatches(false, position, affixToIgnore, 0, textToIgnoreLength))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if there is a match among the other affixes (stored internally)\n * that is longer than the passed value (textLength).\n *\n * @param textLength  the length of the match\n * @param periodStr  the Period string that will be parsed\n * @param position  the position in the Period string at which the parsing should be started.\n * @return true if the other affixes (stored internally) contain a match\n *  that is longer than the textLength parameter, false otherwise\n */\n", "repo_name": "joda-time-main/", "id": 884, "method_signature": "boolean matchesOtherAffix(int, String, int)"}, "IllegalFieldValueException.createMessage": {"callee_method_names": ["StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.append", "StringBuffer.toString"], "method_name": "IllegalFieldValueException.createMessage", "method_implementation": "{\n    StringBuffer buf = new StringBuffer().append(\"Value \");\n    if (value == null) {\n        buf.append(\"null\");\n    } else {\n        buf.append('\"');\n        buf.append(value);\n        buf.append('\"');\n    }\n    buf.append(\" for \").append(fieldName).append(' ').append(\"is not supported\");\n    return buf.toString();\n}", "repo_id": "7", "comment": "/**\n * Creates a message for the exception.\n *\n * @param fieldName  the field name\n * @param value  the value rejected\n * @return the message\n */\n", "repo_name": "joda-time-main/", "id": 123, "method_signature": "String createMessage(String, String)"}, "IllegalFieldValueException.getIllegalValueAsString": {"callee_method_names": [], "method_name": "IllegalFieldValueException.getIllegalValueAsString", "method_implementation": "{\n    String value = iStringValue;\n    if (value == null) {\n        value = String.valueOf(iNumberValue);\n    }\n    return value;\n}", "repo_id": "7", "comment": "/**\n * Returns the illegal value assigned to the field as a non-null string.\n *\n * @return the value\n */\n", "repo_name": "joda-time-main/", "id": 124, "method_signature": "String getIllegalValueAsString()"}, "IllegalFieldValueException.prependMessage": {"callee_method_names": [], "method_name": "IllegalFieldValueException.prependMessage", "method_implementation": "{\n    if (iMessage == null) {\n        iMessage = message;\n    } else if (message != null) {\n        iMessage = message + \": \" + iMessage;\n    }\n}", "repo_id": "7", "comment": "/**\n * Provide additional detail by prepending a message to the existing message.\n * A colon is separator is automatically inserted between the messages.\n *\n * @param message the message to prepend\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 125, "method_signature": "void prependMessage(String)"}, "IllegalInstantException.isIllegalInstant": {"callee_method_names": ["Throwable.getCause", "Throwable.getCause", "Throwable.getCause"], "method_name": "IllegalInstantException.isIllegalInstant", "method_implementation": "{\n    if (ex instanceof IllegalInstantException) {\n        return true;\n    }\n    while (ex.getCause() != null && ex.getCause() != ex) {\n        return isIllegalInstant(ex.getCause());\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if the exception is, or has a cause, of {@code IllegalInstantException}.\n *\n * @param ex  the exception to check\n * @return true if an {@code IllegalInstantException}\n */\n", "repo_name": "joda-time-main/", "id": 249, "method_signature": "boolean isIllegalInstant(Throwable)"}, "ImpreciseDateTimeField.getDifferenceAsLong": {"callee_method_names": [], "method_name": "ImpreciseDateTimeField.getDifferenceAsLong", "method_implementation": "{\n    if (minuendInstant < subtrahendInstant) {\n        return -getDifferenceAsLong(subtrahendInstant, minuendInstant);\n    }\n    long difference = (minuendInstant - subtrahendInstant) / iUnitMillis;\n    if (add(subtrahendInstant, difference) < minuendInstant) {\n        do {\n            difference++;\n        } while (add(subtrahendInstant, difference) <= minuendInstant);\n        difference--;\n    } else if (add(subtrahendInstant, difference) > minuendInstant) {\n        do {\n            difference--;\n        } while (add(subtrahendInstant, difference) > minuendInstant);\n    }\n    return difference;\n}", "repo_id": "7", "comment": "/**\n * Computes the difference between two instants, as measured in the units\n * of this field. Any fractional units are dropped from the result. Calling\n * getDifference reverses the effect of calling add. In the following code:\n *\n * <pre>\n * long instant = ...\n * long v = ...\n * long age = getDifferenceAsLong(add(instant, v), instant);\n * </pre>\n *\n * The value 'age' is the same as the value 'v'.\n * <p>\n * The default implementation performs a guess-and-check algorithm using\n * getDurationField().getUnitMillis() and the add() method. Subclasses are\n * encouraged to provide a more efficient implementation.\n *\n * @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to\n * subtract from\n * @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to\n * subtract off the minuend\n * @return the difference in the units of this field\n */\n", "repo_name": "joda-time-main/", "id": 46, "method_signature": "long getDifferenceAsLong(long, long)"}, "Instant.toDateTimeISO": {"callee_method_names": [], "method_name": "Instant.toDateTimeISO", "method_implementation": "{\n    return toDateTime();\n}", "repo_id": "7", "comment": "/**\n * Get this object as a DateTime using ISOChronology in the default zone.\n * This method is identical to <code>toDateTime()</code>.\n * <p>\n * This method returns a DateTime object in the default zone.\n * This differs from the similarly named method on DateTime, DateMidnight\n * or MutableDateTime which retains the time zone. The difference is\n * because Instant really represents a time <i>without</i> a zone,\n * thus calling this method we really have no zone to 'retain' and\n * hence expect to switch to the default zone.\n * <p>\n * This method is deprecated because it is a duplicate of {@link #toDateTime()}.\n * However, removing it would cause the superclass implementation to be used,\n * which would create silent bugs in any caller depending on this implementation.\n * As such, the method itself is not currently planned to be removed.\n * <p>\n * This method definition preserves compatibility with earlier versions\n * of Joda-Time.\n *\n * @return a DateTime using the same millis with ISOChronology\n * @deprecated Use toDateTime() as it is identical\n */\n", "repo_name": "joda-time-main/", "id": 399, "method_signature": "DateTime toDateTimeISO()"}, "Instant.toMutableDateTimeISO": {"callee_method_names": [], "method_name": "Instant.toMutableDateTimeISO", "method_implementation": "{\n    return toMutableDateTime();\n}", "repo_id": "7", "comment": "/**\n * Get this object as a MutableDateTime using ISOChronology in the default zone.\n * This method is identical to <code>toMutableDateTime()</code>.\n * <p>\n * This method returns a MutableDateTime object in the default zone.\n * This differs from the similarly named method on DateTime, DateMidnight\n * or MutableDateTime which retains the time zone. The difference is\n * because Instant really represents a time <i>without</i> a zone,\n * thus calling this method we really have no zone to 'retain' and\n * hence expect to switch to the default zone.\n * <p>\n * This method is deprecated because it is a duplicate of {@link #toMutableDateTime()}.\n * However, removing it would cause the superclass implementation to be used,\n * which would create silent bugs in any caller depending on this implementation.\n * As such, the method itself is not currently planned to be removed.\n * <p>\n * This method definition preserves compatibility with earlier versions\n * of Joda-Time.\n *\n * @return a MutableDateTime using the same millis with ISOChronology\n * @deprecated Use toMutableDateTime() as it is identical\n */\n", "repo_name": "joda-time-main/", "id": 400, "method_signature": "MutableDateTime toMutableDateTimeISO()"}, "Instant.withDurationAdded": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "Instant.withDurationAdded", "method_implementation": "{\n    if (durationToAdd == null || scalar == 0) {\n        return this;\n    }\n    return withDurationAdded(durationToAdd.getMillis(), scalar);\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of this instant with the specified duration added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n *\n * @param durationToAdd  the duration to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this instant with the duration added\n * @throws ArithmeticException if the new instant exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 398, "method_signature": "Instant withDurationAdded(ReadableDuration, int)"}, "InternalParserDateTimeParser.equals": {"callee_method_names": ["InternalParser.equals"], "method_name": "InternalParserDateTimeParser.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (obj instanceof InternalParserDateTimeParser) {\n        InternalParserDateTimeParser other = (InternalParserDateTimeParser) obj;\n        return underlying.equals(other.underlying);\n    }\n    return false;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 887, "method_signature": "boolean equals(Object)"}, "InternalPrinterDateTimePrinter.equals": {"callee_method_names": ["InternalPrinter.equals"], "method_name": "InternalPrinterDateTimePrinter.equals", "method_implementation": "{\n    if (obj == this) {\n        return true;\n    }\n    if (obj instanceof InternalPrinterDateTimePrinter) {\n        InternalPrinterDateTimePrinter other = (InternalPrinterDateTimePrinter) obj;\n        return underlying.equals(other.underlying);\n    }\n    return false;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 796, "method_signature": "boolean equals(Object)"}, "Interval.abuts": {"callee_method_names": ["ReadableInterval.getEndMillis", "ReadableInterval.getStartMillis"], "method_name": "Interval.abuts", "method_implementation": "{\n    if (interval == null) {\n        long now = DateTimeUtils.currentTimeMillis();\n        return (getStartMillis() == now || getEndMillis() == now);\n    } else {\n        return (interval.getEndMillis() == getStartMillis() || getEndMillis() == interval.getStartMillis());\n    }\n}", "repo_id": "7", "comment": "/**\n * Does this interval abut with the interval specified.\n * <p>\n * Intervals are inclusive of the start instant and exclusive of the end.\n * An interval abuts if it starts immediately after, or ends immediately\n * before this interval without overlap.\n * A zero duration interval abuts with itself.\n * <p>\n * When two intervals are compared the result is one of three states:\n * (a) they abut, (b) there is a gap between them, (c) they overlap.\n * The abuts state takes precedence over the other two, thus a zero duration\n * interval at the start of a larger interval abuts and does not overlap.\n * <p>\n * For example:\n * <pre>\n * [09:00 to 10:00) abuts [08:00 to 08:30)  = false (completely before)\n * [09:00 to 10:00) abuts [08:00 to 09:00)  = true\n * [09:00 to 10:00) abuts [08:00 to 09:01)  = false (overlaps)\n *\n * [09:00 to 10:00) abuts [09:00 to 09:00)  = true\n * [09:00 to 10:00) abuts [09:00 to 09:01)  = false (overlaps)\n *\n * [09:00 to 10:00) abuts [10:00 to 10:00)  = true\n * [09:00 to 10:00) abuts [10:00 to 10:30)  = true\n *\n * [09:00 to 10:00) abuts [10:30 to 11:00)  = false (completely after)\n *\n * [14:00 to 14:00) abuts [14:00 to 14:00)  = true\n * [14:00 to 14:00) abuts [14:00 to 15:00)  = true\n * [14:00 to 14:00) abuts [13:00 to 14:00)  = true\n * </pre>\n *\n * @param interval  the interval to examine, null means now\n * @return true if the interval abuts\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 625, "method_signature": "boolean abuts(ReadableInterval)"}, "Interval.gap": {"callee_method_names": ["ReadableInterval.getStartMillis", "ReadableInterval.getEndMillis"], "method_name": "Interval.gap", "method_implementation": "{\n    interval = DateTimeUtils.getReadableInterval(interval);\n    long otherStart = interval.getStartMillis();\n    long otherEnd = interval.getEndMillis();\n    long thisStart = getStartMillis();\n    long thisEnd = getEndMillis();\n    if (thisStart > otherEnd) {\n        return new Interval(otherEnd, thisStart, getChronology());\n    } else if (otherStart > thisEnd) {\n        return new Interval(thisEnd, otherStart, getChronology());\n    } else {\n        return null;\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the gap between this interval and another interval.\n * The other interval can be either before or after this interval.\n * <p>\n * Intervals are inclusive of the start instant and exclusive of the end.\n * An interval has a gap to another interval if there is a non-zero\n * duration between them. This method returns the amount of the gap only\n * if the intervals do actually have a gap between them.\n * If the intervals overlap or abut, then null is returned.\n * <p>\n * When two intervals are compared the result is one of three states:\n * (a) they abut, (b) there is a gap between them, (c) they overlap.\n * The abuts state takes precedence over the other two, thus a zero duration\n * interval at the start of a larger interval abuts and does not overlap.\n * <p>\n * The chronology of the returned interval is the same as that of\n * this interval (the chronology of the interval parameter is not used).\n * Note that the use of the chronology was only correctly implemented\n * in version 1.3.\n *\n * @param interval  the interval to examine, null means now\n * @return the gap interval, null if no gap\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 624, "method_signature": "Interval gap(ReadableInterval)"}, "Interval.overlap": {"callee_method_names": ["ReadableInterval.getStartMillis", "ReadableInterval.getEndMillis"], "method_name": "Interval.overlap", "method_implementation": "{\n    interval = DateTimeUtils.getReadableInterval(interval);\n    if (overlaps(interval) == false) {\n        return null;\n    }\n    long start = Math.max(getStartMillis(), interval.getStartMillis());\n    long end = Math.min(getEndMillis(), interval.getEndMillis());\n    return new Interval(start, end, getChronology());\n}", "repo_id": "7", "comment": "/**\n * Gets the overlap between this interval and another interval.\n * <p>\n * Intervals are inclusive of the start instant and exclusive of the end.\n * An interval overlaps another if it shares some common part of the\n * datetime continuum. This method returns the amount of the overlap,\n * only if the intervals actually do overlap.\n * If the intervals do not overlap, then null is returned.\n * <p>\n * When two intervals are compared the result is one of three states:\n * (a) they abut, (b) there is a gap between them, (c) they overlap.\n * The abuts state takes precedence over the other two, thus a zero duration\n * interval at the start of a larger interval abuts and does not overlap.\n * <p>\n * The chronology of the returned interval is the same as that of\n * this interval (the chronology of the interval parameter is not used).\n * Note that the use of the chronology was only correctly implemented\n * in version 1.3.\n *\n * @param interval  the interval to examine, null means now\n * @return the overlap interval, null if no overlap\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 623, "method_signature": "Interval overlap(ReadableInterval)"}, "Interval.parseWithOffset": {"callee_method_ids": [901, 860, 901, 860], "callee_method_names": ["String.indexOf", "String.substring", "String.length", "String.substring", "String.length", "String.charAt", "PeriodFormatter.withParseType", "DateTimeFormatter.parseDateTime", "String.charAt", "PeriodFormatter.withParseType", "DateTimeFormatter.parseDateTime"], "method_name": "Interval.parseWithOffset", "method_implementation": "{\n    int separator = str.indexOf('/');\n    if (separator < 0) {\n        throw new IllegalArgumentException(\"Format requires a '/' separator: \" + str);\n    }\n    String leftStr = str.substring(0, separator);\n    if (leftStr.length() <= 0) {\n        throw new IllegalArgumentException(\"Format invalid: \" + str);\n    }\n    String rightStr = str.substring(separator + 1);\n    if (rightStr.length() <= 0) {\n        throw new IllegalArgumentException(\"Format invalid: \" + str);\n    }\n    DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser().withOffsetParsed();\n    PeriodFormatter periodParser = ISOPeriodFormat.standard();\n    DateTime start = null;\n    Period period = null;\n    // before slash\n    char c = leftStr.charAt(0);\n    if (c == 'P' || c == 'p') {\n        period = periodParser.withParseType(PeriodType.standard()).parsePeriod(leftStr);\n    } else {\n        start = dateTimeParser.parseDateTime(leftStr);\n    }\n    // after slash\n    c = rightStr.charAt(0);\n    if (c == 'P' || c == 'p') {\n        if (period != null) {\n            throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n        }\n        period = periodParser.withParseType(PeriodType.standard()).parsePeriod(rightStr);\n        return new Interval(start, period);\n    } else {\n        DateTime end = dateTimeParser.parseDateTime(rightStr);\n        if (period != null) {\n            return new Interval(period, end);\n        } else {\n            return new Interval(start, end);\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Parses an {@code Interval} from the specified string, using any offset it contains.\n * <p>\n * The String formats are described by\n * {@link ISODateTimeFormat#dateTimeParser()}{@code .withOffsetParsed()}\n * and {@link ISOPeriodFormat#standard()}, and may be 'datetime/datetime',\n * 'datetime/period' or 'period/datetime'.\n * <p>\n * Sometimes this method and {@code new Interval(str)} return different results.\n * This can be confusing as the difference is not visible in {@link #toString()}.\n * <p>\n * When passed a string without an offset, such as '2010-06-30T01:20/P1D',\n * both the constructor and this method use the default time-zone.\n * As such, {@code Interval.parseWithOffset(\"2010-06-30T01:20/P1D\")} and\n * {@code new Interval(\"2010-06-30T01:20/P1D\"))} are equal.\n * <p>\n * However, when this method is passed a string with an offset,\n * the offset is directly parsed and stored.\n * As such, {@code Interval.parseWithOffset(\"2010-06-30T01:20+02:00/P1D\")} and\n * {@code new Interval(\"2010-06-30T01:20+02:00/P1D\"))} are NOT equal.\n * The object produced via this method has a zone of {@code DateTimeZone.forOffsetHours(2)}.\n * The object produced via the constructor has a zone of {@code DateTimeZone.getDefault()}.\n *\n * @param str  the string to parse, not null\n * @return the parsed interval, not null\n * @since 2.9\n */\n", "repo_name": "joda-time-main/", "id": 622, "method_signature": "Interval parseWithOffset(String)"}, "Interval.withChronology": {"callee_method_names": [], "method_name": "Interval.withChronology", "method_implementation": "{\n    if (getChronology() == chronology) {\n        return this;\n    }\n    return new Interval(getStartMillis(), getEndMillis(), chronology);\n}", "repo_id": "7", "comment": "/**\n * Creates a new interval with the same start and end, but a different chronology.\n *\n * @param chronology  the chronology to use, null means ISO default\n * @return an interval with a different chronology\n */\n", "repo_name": "joda-time-main/", "id": 626, "method_signature": "Interval withChronology(Chronology)"}, "Interval.withDurationAfterStart": {"callee_method_names": ["Chronology.add"], "method_name": "Interval.withDurationAfterStart", "method_implementation": "{\n    long durationMillis = DateTimeUtils.getDurationMillis(duration);\n    if (durationMillis == toDurationMillis()) {\n        return this;\n    }\n    Chronology chrono = getChronology();\n    long startMillis = getStartMillis();\n    long endMillis = chrono.add(startMillis, durationMillis, 1);\n    return new Interval(startMillis, endMillis, chrono);\n}", "repo_id": "7", "comment": "/**\n * Creates a new interval with the specified duration after the start instant.\n *\n * @param duration  the duration to add to the start to get the new end instant, null means zero\n * @return an interval with the start from this interval and a calculated end\n * @throws IllegalArgumentException if the duration is negative\n */\n", "repo_name": "joda-time-main/", "id": 629, "method_signature": "Interval withDurationAfterStart(ReadableDuration)"}, "Interval.withDurationBeforeEnd": {"callee_method_names": ["Chronology.add"], "method_name": "Interval.withDurationBeforeEnd", "method_implementation": "{\n    long durationMillis = DateTimeUtils.getDurationMillis(duration);\n    if (durationMillis == toDurationMillis()) {\n        return this;\n    }\n    Chronology chrono = getChronology();\n    long endMillis = getEndMillis();\n    long startMillis = chrono.add(endMillis, durationMillis, -1);\n    return new Interval(startMillis, endMillis, chrono);\n}", "repo_id": "7", "comment": "/**\n * Creates a new interval with the specified duration before the end instant.\n *\n * @param duration  the duration to subtract from the end to get the new start instant, null means zero\n * @return an interval with the end from this interval and a calculated start\n * @throws IllegalArgumentException if the duration is negative\n */\n", "repo_name": "joda-time-main/", "id": 630, "method_signature": "Interval withDurationBeforeEnd(ReadableDuration)"}, "Interval.withEndMillis": {"callee_method_names": [], "method_name": "Interval.withEndMillis", "method_implementation": "{\n    if (endInstant == getEndMillis()) {\n        return this;\n    }\n    return new Interval(getStartMillis(), endInstant, getChronology());\n}", "repo_id": "7", "comment": "/**\n * Creates a new interval with the specified end millisecond instant.\n *\n * @param endInstant  the end instant for the new interval\n * @return an interval with the start from this interval and the specified end\n * @throws IllegalArgumentException if the resulting interval has end before start\n */\n", "repo_name": "joda-time-main/", "id": 628, "method_signature": "Interval withEndMillis(long)"}, "Interval.withPeriodAfterStart": {"callee_method_names": ["Chronology.add"], "method_name": "Interval.withPeriodAfterStart", "method_implementation": "{\n    if (period == null) {\n        return withDurationAfterStart(null);\n    }\n    Chronology chrono = getChronology();\n    long startMillis = getStartMillis();\n    long endMillis = chrono.add(period, startMillis, 1);\n    return new Interval(startMillis, endMillis, chrono);\n}", "repo_id": "7", "comment": "/**\n * Creates a new interval with the specified period after the start instant.\n *\n * @param period  the period to add to the start to get the new end instant, null means zero\n * @return an interval with the start from this interval and a calculated end\n * @throws IllegalArgumentException if the period is negative\n */\n", "repo_name": "joda-time-main/", "id": 631, "method_signature": "Interval withPeriodAfterStart(ReadablePeriod)"}, "Interval.withPeriodBeforeEnd": {"callee_method_names": ["Chronology.add"], "method_name": "Interval.withPeriodBeforeEnd", "method_implementation": "{\n    if (period == null) {\n        return withDurationBeforeEnd(null);\n    }\n    Chronology chrono = getChronology();\n    long endMillis = getEndMillis();\n    long startMillis = chrono.add(period, endMillis, -1);\n    return new Interval(startMillis, endMillis, chrono);\n}", "repo_id": "7", "comment": "/**\n * Creates a new interval with the specified period before the end instant.\n *\n * @param period the period to subtract from the end to get the new start instant, null means zero\n * @return an interval with the end from this interval and a calculated start\n * @throws IllegalArgumentException if the period is negative\n */\n", "repo_name": "joda-time-main/", "id": 632, "method_signature": "Interval withPeriodBeforeEnd(ReadablePeriod)"}, "Interval.withStartMillis": {"callee_method_names": [], "method_name": "Interval.withStartMillis", "method_implementation": "{\n    if (startInstant == getStartMillis()) {\n        return this;\n    }\n    return new Interval(startInstant, getEndMillis(), getChronology());\n}", "repo_id": "7", "comment": "/**\n * Creates a new interval with the specified start millisecond instant.\n *\n * @param startInstant  the start instant for the new interval\n * @return an interval with the end from this interval and the specified start\n * @throws IllegalArgumentException if the resulting interval has end before start\n */\n", "repo_name": "joda-time-main/", "id": 627, "method_signature": "Interval withStartMillis(long)"}, "IslamicChronology.assemble": {"callee_method_names": ["Fields.getDurationField"], "method_name": "IslamicChronology.assemble", "method_implementation": "{\n    if (getBase() == null) {\n        super.assemble(fields);\n        fields.era = ERA_FIELD;\n        fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 12);\n        fields.months = fields.monthOfYear.getDurationField();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 378, "method_signature": "void assemble(Fields)"}, "IslamicChronology.calculateFirstDayOfYearMillis": {"callee_method_names": [], "method_name": "IslamicChronology.calculateFirstDayOfYearMillis", "method_implementation": "{\n    if (year > MAX_YEAR) {\n        throw new ArithmeticException(\"Year is too large: \" + year + \" > \" + MAX_YEAR);\n    }\n    if (year < MIN_YEAR) {\n        throw new ArithmeticException(\"Year is too small: \" + year + \" < \" + MIN_YEAR);\n    }\n    // Java epoch is 1970-01-01 Gregorian which is 0622-07-16 Islamic.\n    // 0001-01-01 Islamic is -42520809600000L\n    // would prefer to calculate against year zero, but leap year\n    // can be in that year so it doesn't work\n    year--;\n    long cycle = year / CYCLE;\n    long millis = MILLIS_YEAR_1 + cycle * MILLIS_PER_CYCLE;\n    int cycleRemainder = (year % CYCLE) + 1;\n    for (int i = 1; i < cycleRemainder; i++) {\n        millis += (isLeapYear(i) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);\n    }\n    return millis;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 376, "method_signature": "long calculateFirstDayOfYearMillis(int)"}, "IslamicChronology.equals": {"callee_method_names": ["IslamicChronology.getLeapYearPatternType"], "method_name": "IslamicChronology.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof IslamicChronology) {\n        IslamicChronology chrono = (IslamicChronology) obj;\n        return getLeapYearPatternType().index == chrono.getLeapYearPatternType().index && super.equals(obj);\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if this chronology instance equals another.\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 2.3\n */\n", "repo_name": "joda-time-main/", "id": 368, "method_signature": "boolean equals(Object)"}, "IslamicChronology.getApproxMillisAtEpochDividedByTwo": {"callee_method_names": [], "method_name": "IslamicChronology.getApproxMillisAtEpochDividedByTwo", "method_implementation": "{\n    // Epoch 1970-01-01 ISO = 1389-10-22 Islamic\n    return (-MILLIS_YEAR_1) / 2;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 377, "method_signature": "long getApproxMillisAtEpochDividedByTwo()"}, "IslamicChronology.getDayOfMonth": {"callee_method_names": [], "method_name": "IslamicChronology.getDayOfMonth", "method_implementation": "{\n    // optimised for simple months\n    int doy = getDayOfYear(millis) - 1;\n    if (doy == 354) {\n        return 30;\n    }\n    return (doy % MONTH_PAIR_LENGTH) % LONG_MONTH_LENGTH + 1;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 372, "method_signature": "int getDayOfMonth(long)"}, "IslamicChronology.getDaysInMonthMax": {"callee_method_names": [], "method_name": "IslamicChronology.getDaysInMonthMax", "method_implementation": "{\n    if (month == 12) {\n        return LONG_MONTH_LENGTH;\n    }\n    return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 374, "method_signature": "int getDaysInMonthMax(int)"}, "IslamicChronology.getDaysInYearMonth": {"callee_method_names": [], "method_name": "IslamicChronology.getDaysInYearMonth", "method_implementation": "{\n    if (month == 12 && isLeapYear(year)) {\n        return LONG_MONTH_LENGTH;\n    }\n    return (--month % 2 == 0 ? LONG_MONTH_LENGTH : SHORT_MONTH_LENGTH);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 373, "method_signature": "int getDaysInYearMonth(int, int)"}, "IslamicChronology.getInstance": {"callee_method_names": ["ConcurrentHashMap.get", "ConcurrentHashMap.putIfAbsent"], "method_name": "IslamicChronology.getInstance", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    IslamicChronology chrono;\n    IslamicChronology[] chronos = cCache.get(zone);\n    if (chronos == null) {\n        chronos = new IslamicChronology[4];\n        IslamicChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\n        if (oldChronos != null) {\n            chronos = oldChronos;\n        }\n    }\n    chrono = chronos[leapYears.index];\n    if (chrono == null) {\n        synchronized (chronos) {\n            chrono = chronos[leapYears.index];\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    // First create without a lower limit.\n                    chrono = new IslamicChronology(null, null, leapYears);\n                    // Impose lower limit and make another IslamicChronology.\n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n                    chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, leapYears);\n                    chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears);\n                }\n                chronos[leapYears.index] = chrono;\n            }\n        }\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets an instance of the IslamicChronology in the given time zone.\n *\n * @param zone  the time zone to get the chronology in, null is default\n * @param leapYears  the type defining the leap year pattern\n * @return a chronology in the specified time zone\n */\n", "repo_name": "joda-time-main/", "id": 366, "method_signature": "IslamicChronology getInstance(DateTimeZone, LeapYearPatternType)"}, "IslamicChronology.getMonthOfYear": {"callee_method_names": [], "method_name": "IslamicChronology.getMonthOfYear", "method_implementation": "{\n    int doyZeroBased = (int) ((millis - getYearMillis(year)) / DateTimeConstants.MILLIS_PER_DAY);\n    if (doyZeroBased == 354) {\n        return 12;\n    }\n    return ((doyZeroBased * 2) / MONTH_PAIR_LENGTH) + 1;\n    //        return (int) (doyZeroBased / 29.9f) + 1;\n    //\n    //        int monthPairZeroBased = doyZeroBased / MONTH_PAIR_LENGTH;\n    //        int monthPairRemainder = doyZeroBased % MONTH_PAIR_LENGTH;\n    //        return (monthPairZeroBased * 2) + 1 + (monthPairRemainder >= LONG_MONTH_LENGTH ? 1 : 0);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 375, "method_signature": "int getMonthOfYear(long, int)"}, "IslamicChronology.getTotalMillisByYearMonth": {"callee_method_names": [], "method_name": "IslamicChronology.getTotalMillisByYearMonth", "method_implementation": "{\n    if (--month % 2 == 1) {\n        month /= 2;\n        return month * MILLIS_PER_MONTH_PAIR + MILLIS_PER_LONG_MONTH;\n    } else {\n        month /= 2;\n        return month * MILLIS_PER_MONTH_PAIR;\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 371, "method_signature": "long getTotalMillisByYearMonth(int, int)"}, "IslamicChronology.getYear": {"callee_method_names": [], "method_name": "IslamicChronology.getYear", "method_implementation": "{\n    long millisIslamic = instant - MILLIS_YEAR_1;\n    long cycles = millisIslamic / MILLIS_PER_CYCLE;\n    long cycleRemainder = millisIslamic % MILLIS_PER_CYCLE;\n    int year = (int) ((cycles * CYCLE) + 1L);\n    long yearMillis = (isLeapYear(year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);\n    while (cycleRemainder >= yearMillis) {\n        cycleRemainder -= yearMillis;\n        yearMillis = (isLeapYear(++year) ? MILLIS_PER_LONG_YEAR : MILLIS_PER_SHORT_YEAR);\n    }\n    return year;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 369, "method_signature": "int getYear(long)"}, "IslamicChronology.getYearDifference": {"callee_method_names": [], "method_name": "IslamicChronology.getYearDifference", "method_implementation": "{\n    // optimsed implementation of getDifference, due to fixed months\n    int minuendYear = getYear(minuendInstant);\n    int subtrahendYear = getYear(subtrahendInstant);\n    // Inlined remainder method to avoid duplicate calls to get.\n    long minuendRem = minuendInstant - getYearMillis(minuendYear);\n    long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n    int difference = minuendYear - subtrahendYear;\n    if (minuendRem < subtrahendRem) {\n        difference--;\n    }\n    return difference;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 370, "method_signature": "long getYearDifference(long, long)"}, "IslamicChronology.readResolve": {"callee_method_names": [], "method_name": "IslamicChronology.readResolve", "method_implementation": "{\n    switch(index) {\n        case 0:\n            return LEAP_YEAR_15_BASED;\n        case 1:\n            return LEAP_YEAR_16_BASED;\n        case 2:\n            return LEAP_YEAR_INDIAN;\n        case 3:\n            return LEAP_YEAR_HABASH_AL_HASIB;\n        default:\n            return this;\n    }\n}", "repo_id": "7", "comment": "/**\n * Ensure a singleton is returned if possible.\n * @return the singleton instance\n */\n", "repo_name": "joda-time-main/", "id": 379, "method_signature": "Object readResolve()"}, "IslamicChronology.withZone": {"callee_method_names": [], "method_name": "IslamicChronology.withZone", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    if (zone == getZone()) {\n        return this;\n    }\n    return getInstance(zone);\n}", "repo_id": "7", "comment": "/**\n * Gets the Chronology in a specific time zone.\n *\n * @param zone  the zone to get the chronology in, null is default\n * @return the chronology\n */\n", "repo_name": "joda-time-main/", "id": 367, "method_signature": "Chronology withZone(DateTimeZone)"}, "JulianChronology.getInstance": {"callee_method_names": ["ConcurrentHashMap.get", "ConcurrentHashMap.putIfAbsent"], "method_name": "JulianChronology.getInstance", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    JulianChronology chrono;\n    JulianChronology[] chronos = cCache.get(zone);\n    if (chronos == null) {\n        chronos = new JulianChronology[7];\n        JulianChronology[] oldChronos = cCache.putIfAbsent(zone, chronos);\n        if (oldChronos != null) {\n            chronos = oldChronos;\n        }\n    }\n    try {\n        chrono = chronos[minDaysInFirstWeek - 1];\n    } catch (ArrayIndexOutOfBoundsException e) {\n        throw new IllegalArgumentException(\"Invalid min days in first week: \" + minDaysInFirstWeek);\n    }\n    if (chrono == null) {\n        synchronized (chronos) {\n            chrono = chronos[minDaysInFirstWeek - 1];\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new JulianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets an instance of the JulianChronology in the given time zone.\n *\n * @param zone  the time zone to get the chronology in, null is default\n * @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4\n * @return a chronology in the specified time zone\n */\n", "repo_name": "joda-time-main/", "id": 357, "method_signature": "JulianChronology getInstance(DateTimeZone, int)"}, "JulianChronology.readResolve": {"callee_method_names": ["Chronology.getZone"], "method_name": "JulianChronology.readResolve", "method_implementation": "{\n    Chronology base = getBase();\n    int minDays = getMinimumDaysInFirstWeek();\n    // handle rename of BaseGJChronology\n    minDays = (minDays == 0 ? 4 : minDays);\n    return base == null ? getInstance(DateTimeZone.UTC, minDays) : getInstance(base.getZone(), minDays);\n}", "repo_id": "7", "comment": "/**\n * Serialization singleton\n */\n", "repo_name": "joda-time-main/", "id": 358, "method_signature": "Object readResolve()"}, "JulianChronology.withZone": {"callee_method_names": [], "method_name": "JulianChronology.withZone", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    if (zone == getZone()) {\n        return this;\n    }\n    return getInstance(zone);\n}", "repo_id": "7", "comment": "/**\n * Gets the Chronology in a specific time zone.\n *\n * @param zone  the zone to get the chronology in, null is default\n * @return the chronology\n */\n", "repo_name": "joda-time-main/", "id": 359, "method_signature": "Chronology withZone(DateTimeZone)"}, "LeapYearPatternType.readResolve": {"callee_method_names": [], "method_name": "LeapYearPatternType.readResolve", "method_implementation": "{\n    switch(index) {\n        case 0:\n            return LEAP_YEAR_15_BASED;\n        case 1:\n            return LEAP_YEAR_16_BASED;\n        case 2:\n            return LEAP_YEAR_INDIAN;\n        case 3:\n            return LEAP_YEAR_HABASH_AL_HASIB;\n        default:\n            return this;\n    }\n}", "repo_id": "7", "comment": "/**\n * Ensure a singleton is returned if possible.\n * @return the singleton instance\n */\n", "repo_name": "joda-time-main/", "id": 380, "method_signature": "Object readResolve()"}, "LenientChronology.equals": {"callee_method_names": ["LenientChronology.getBase"], "method_name": "LenientChronology.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof LenientChronology == false) {\n        return false;\n    }\n    LenientChronology chrono = (LenientChronology) obj;\n    return getBase().equals(chrono.getBase());\n}", "repo_id": "7", "comment": "/**\n * A lenient chronology is only equal to a lenient chronology with the\n * same base chronology.\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 1.4\n */\n", "repo_name": "joda-time-main/", "id": 294, "method_signature": "boolean equals(Object)"}, "LenientChronology.getInstance": {"callee_method_names": [], "method_name": "LenientChronology.getInstance", "method_implementation": "{\n    if (base == null) {\n        throw new IllegalArgumentException(\"Must supply a chronology\");\n    }\n    return new LenientChronology(base);\n}", "repo_id": "7", "comment": "/**\n * Create a LenientChronology for any chronology.\n *\n * @param base the chronology to wrap\n * @return the chronology, not null\n * @throws IllegalArgumentException if chronology is null\n */\n", "repo_name": "joda-time-main/", "id": 293, "method_signature": "LenientChronology getInstance(Chronology)"}, "LenientDateTimeField.getInstance": {"callee_method_names": ["DateTimeField.isLenient"], "method_name": "LenientDateTimeField.getInstance", "method_implementation": "{\n    if (field == null) {\n        return null;\n    }\n    if (field instanceof StrictDateTimeField) {\n        field = ((StrictDateTimeField) field).getWrappedField();\n    }\n    if (field.isLenient()) {\n        return field;\n    }\n    return new LenientDateTimeField(field, base);\n}", "repo_id": "7", "comment": "/**\n * Returns a lenient version of the given field. If it is already lenient,\n * then it is returned as-is. Otherwise, a new LenientDateTimeField is returned.\n *\n * @param field  the field, null returns null\n * @param base  the chronology, not null\n * @return the field. may be null\n */\n", "repo_name": "joda-time-main/", "id": 43, "method_signature": "DateTimeField getInstance(DateTimeField, Chronology)"}, "LenientDateTimeField.set": {"callee_method_names": ["Chronology.getZone", "Chronology.withUTC", "Chronology.getZone"], "method_name": "LenientDateTimeField.set", "method_implementation": "{\n    // lenient needs to handle time zone chronologies\n    // so we do the calculation using local milliseconds\n    long localInstant = iBase.getZone().convertUTCToLocal(instant);\n    long difference = FieldUtils.safeSubtract(value, get(instant));\n    localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n    return iBase.getZone().convertLocalToUTC(localInstant, false, instant);\n}", "repo_id": "7", "comment": "/**\n * Set values which may be out of bounds by adding the difference between\n * the new value and the current value.\n */\n", "repo_name": "joda-time-main/", "id": 44, "method_signature": "long set(long, int)"}, "LimitChronology.equals": {"callee_method_names": ["LimitChronology.getBase", "LimitChronology.getLowerLimit", "LimitChronology.getUpperLimit"], "method_name": "LimitChronology.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof LimitChronology == false) {\n        return false;\n    }\n    LimitChronology chrono = (LimitChronology) obj;\n    return getBase().equals(chrono.getBase()) && FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) && FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit());\n}", "repo_id": "7", "comment": "/**\n * A limit chronology is only equal to a limit chronology with the\n * same base chronology and limits.\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 1.4\n */\n", "repo_name": "joda-time-main/", "id": 341, "method_signature": "boolean equals(Object)"}, "LimitChronology.getInstance": {"callee_method_names": ["ReadableDateTime.toDateTime", "ReadableDateTime.toDateTime", "ReadableDateTime.isBefore"], "method_name": "LimitChronology.getInstance", "method_implementation": "{\n    if (base == null) {\n        throw new IllegalArgumentException(\"Must supply a chronology\");\n    }\n    lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();\n    upperLimit = upperLimit == null ? null : upperLimit.toDateTime();\n    if (lowerLimit != null && upperLimit != null && !lowerLimit.isBefore(upperLimit)) {\n        throw new IllegalArgumentException(\"The lower limit must be come before than the upper limit\");\n    }\n    return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit);\n}", "repo_id": "7", "comment": "/**\n * Wraps another chronology, with datetime limits. When withUTC or\n * withZone is called, the returned LimitChronology instance has\n * the same limits, except they are time zone adjusted.\n *\n * @param base  base chronology to wrap\n * @param lowerLimit  inclusive lower limit, or null if none\n * @param upperLimit  exclusive upper limit, or null if none\n * @return the chronology, not null\n * @throws IllegalArgumentException if chronology is null or limits are invalid\n */\n", "repo_name": "joda-time-main/", "id": 339, "method_signature": "LimitChronology getInstance(Chronology, ReadableDateTime, ReadableDateTime)"}, "LimitChronology.hashCode": {"callee_method_names": [], "method_name": "LimitChronology.hashCode", "method_implementation": "{\n    int hash = 317351877;\n    hash += (getLowerLimit() != null ? getLowerLimit().hashCode() : 0);\n    hash += (getUpperLimit() != null ? getUpperLimit().hashCode() : 0);\n    hash += getBase().hashCode() * 7;\n    return hash;\n}", "repo_id": "7", "comment": "/**\n * A suitable hashcode for the chronology.\n *\n * @return the hashcode\n * @since 1.4\n */\n", "repo_name": "joda-time-main/", "id": 342, "method_signature": "int hashCode()"}, "LimitChronology.toString": {"callee_method_names": [], "method_name": "LimitChronology.toString", "method_implementation": "{\n    return \"LimitChronology[\" + getBase().toString() + \", \" + (getLowerLimit() == null ? \"NoLimit\" : getLowerLimit().toString()) + \", \" + (getUpperLimit() == null ? \"NoLimit\" : getUpperLimit().toString()) + ']';\n}", "repo_id": "7", "comment": "/**\n * A debugging string for the chronology.\n *\n * @return the debugging string\n */\n", "repo_name": "joda-time-main/", "id": 343, "method_signature": "String toString()"}, "LimitChronology.withZone": {"callee_method_ids": [663, 663], "callee_method_names": ["DateTime.toMutableDateTime", "MutableDateTime.setZoneRetainFields", "MutableDateTime.toDateTime", "DateTime.toMutableDateTime", "MutableDateTime.setZoneRetainFields", "MutableDateTime.toDateTime"], "method_name": "LimitChronology.withZone", "method_implementation": "{\n    if (zone == null) {\n        zone = DateTimeZone.getDefault();\n    }\n    if (zone == getZone()) {\n        return this;\n    }\n    if (zone == DateTimeZone.UTC && iWithUTC != null) {\n        return iWithUTC;\n    }\n    DateTime lowerLimit = iLowerLimit;\n    if (lowerLimit != null) {\n        MutableDateTime mdt = lowerLimit.toMutableDateTime();\n        mdt.setZoneRetainFields(zone);\n        lowerLimit = mdt.toDateTime();\n    }\n    DateTime upperLimit = iUpperLimit;\n    if (upperLimit != null) {\n        MutableDateTime mdt = upperLimit.toMutableDateTime();\n        mdt.setZoneRetainFields(zone);\n        upperLimit = mdt.toDateTime();\n    }\n    LimitChronology chrono = getInstance(getBase().withZone(zone), lowerLimit, upperLimit);\n    if (zone == DateTimeZone.UTC) {\n        iWithUTC = chrono;\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * If this LimitChronology has the same time zone as the one given, then\n * this is returned. Otherwise, a new instance is returned, with the limits\n * adjusted to the new time zone.\n */\n", "repo_name": "joda-time-main/", "id": 340, "method_signature": "Chronology withZone(DateTimeZone)"}, "LoadedFile.validateFile": {"callee_method_names": ["File.exists", "File.canRead", "File.length"], "method_name": "LoadedFile.validateFile", "method_implementation": "{\n    /*\n             * Verify the user specified file exists and can\n             * be read.\n             */\n    File f = new File(fileName);\n    if (!f.exists() || !f.canRead()) {\n        System.err.println(\"File: \" + mainArgs[0] + \" does not exist or cannot be read!\");\n        usage();\n        System.exit(2);\n    }\n    /*\n             * Try to get a reasonable estimate of the number of lines\n             * in the file.\n             */\n    // Java does not do this right IMO.  The number of bytes in a\n    // file is a\n    // long, but the length of a string is an int.  Why?\n    lineGuess = (int) (f.length() / (long) \"YYYY-MM-DDTHH:MM:SS\".length());\n    lineGuess += (lineGuess / 10);\n    //\n    // Debugging\n    //\n    if (false) {\n        System.out.println(\"Line guess is: \" + lineGuess);\n    }\n}", "repo_id": "7", "comment": "/*\n         * validateFile\n         */\n", "repo_name": "joda-time-main/", "id": 1092, "method_signature": "void validateFile(String)"}, "LocalDate.compareTo": {"callee_method_names": ["Chronology.equals"], "method_name": "LocalDate.compareTo", "method_implementation": "{\n    // override to perform faster\n    if (this == partial) {\n        return 0;\n    }\n    if (partial instanceof LocalDate) {\n        LocalDate other = (LocalDate) partial;\n        if (iChronology.equals(other.iChronology)) {\n            return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1));\n        }\n    }\n    return super.compareTo(partial);\n}", "repo_id": "7", "comment": "/**\n * Compares this partial with another returning an integer\n * indicating the order.\n * <p>\n * The fields are compared in order, from largest to smallest.\n * The first field that is non-equal is used to determine the result.\n * <p>\n * The specified object must be a partial instance whose field types\n * match those of this partial.\n *\n * @param partial  an object to check against\n * @return negative if this is less, zero if equal, positive if greater\n * @throws ClassCastException if the partial is the wrong class\n *  or if it has field types that don't match\n * @throws NullPointerException if the partial is null\n */\n", "repo_name": "joda-time-main/", "id": 696, "method_signature": "int compareTo(ReadablePartial)"}, "LocalDate.equals": {"callee_method_names": ["Chronology.equals"], "method_name": "LocalDate.equals", "method_implementation": "{\n    // override to perform faster\n    if (this == partial) {\n        return true;\n    }\n    if (partial instanceof LocalDate) {\n        LocalDate other = (LocalDate) partial;\n        if (iChronology.equals(other.iChronology)) {\n            return iLocalMillis == other.iLocalMillis;\n        }\n    }\n    return super.equals(partial);\n}", "repo_id": "7", "comment": "/**\n * Compares this ReadablePartial with another returning true if the chronology,\n * field types and values are equal.\n *\n * @param partial  an object to check against\n * @return true if fields and values are equal\n */\n", "repo_name": "joda-time-main/", "id": 694, "method_signature": "boolean equals(Object)"}, "LocalDate.fromCalendarFields": {"callee_method_names": ["Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get"], "method_name": "LocalDate.fromCalendarFields", "method_implementation": "{\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int era = calendar.get(Calendar.ERA);\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    return new LocalDate((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\n}", "repo_id": "7", "comment": "/**\n * Constructs a LocalDate from a <code>java.util.Calendar</code>\n * using exactly the same field values.\n * <p>\n * Each field is queried from the Calendar and assigned to the LocalDate.\n * This is useful if you have been using the Calendar as a local date,\n * ignoring the zone.\n * <p>\n * One advantage of this method is that this method is unaffected if the\n * version of the time zone data differs between the JDK and Joda-Time.\n * That is because the local field values are transferred, calculated using\n * the JDK time zone data and without using the Joda-Time time zone data.\n * <p>\n * This factory method ignores the type of the calendar and always\n * creates a LocalDate with ISO chronology. It is expected that you\n * will only pass in instances of <code>GregorianCalendar</code> however\n * this is not validated.\n *\n * @param calendar  the Calendar to extract fields from, not null\n * @return the created local date, not null\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 686, "method_signature": "LocalDate fromCalendarFields(Calendar)"}, "LocalDate.fromDateFields": {"callee_method_names": ["Date.getTime", "GregorianCalendar.setTime", "Date.getYear", "Date.getMonth", "Date.getDate"], "method_name": "LocalDate.fromDateFields", "method_implementation": "{\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    if (date.getTime() < 0) {\n        // handle years in era BC\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(date);\n        return fromCalendarFields(cal);\n    }\n    return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate());\n}", "repo_id": "7", "comment": "/**\n * Constructs a LocalDate from a <code>java.util.Date</code>\n * using exactly the same field values.\n * <p>\n * Each field is queried from the Date and assigned to the LocalDate.\n * This is useful if you have been using the Date as a local date,\n * ignoring the zone.\n * <p>\n * One advantage of this method is that this method is unaffected if the\n * version of the time zone data differs between the JDK and Joda-Time.\n * That is because the local field values are transferred, calculated using\n * the JDK time zone data and without using the Joda-Time time zone data.\n * <p>\n * This factory method always creates a LocalDate with ISO chronology.\n *\n * @param date  the Date to extract fields from, not null\n * @return the created local date, not null\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 687, "method_signature": "LocalDate fromDateFields(Date)"}, "LocalDate.get": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "LocalDate.get", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    if (isSupported(fieldType) == false) {\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n    }\n    return fieldType.getField(getChronology()).get(getLocalMillis());\n}", "repo_id": "7", "comment": "/**\n * Get the value of one of the fields of a datetime.\n * <p>\n * This method gets the value of the specified field.\n * For example:\n * <pre>\n * LocalDate dt = LocalDate.nowDefaultZone();\n * int year = dt.get(DateTimeFieldType.year());\n * </pre>\n *\n * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n * @return the value of that field\n * @throws IllegalArgumentException if the field type is null or unsupported\n */\n", "repo_name": "joda-time-main/", "id": 691, "method_signature": "int get(DateTimeFieldType)"}, "LocalDate.getField": {"callee_method_names": ["Chronology.year", "Chronology.monthOfYear", "Chronology.dayOfMonth"], "method_name": "LocalDate.getField", "method_implementation": "{\n    switch(index) {\n        case YEAR:\n            return chrono.year();\n        case MONTH_OF_YEAR:\n            return chrono.monthOfYear();\n        case DAY_OF_MONTH:\n            return chrono.dayOfMonth();\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the field for a specific index in the chronology specified.\n * <p>\n * This method must not use any instance variables.\n *\n * @param index  the index to retrieve\n * @param chrono  the chronology to use\n * @return the field\n */\n", "repo_name": "joda-time-main/", "id": 689, "method_signature": "DateTimeField getField(int, Chronology)"}, "LocalDate.getValue": {"callee_method_names": [], "method_name": "LocalDate.getValue", "method_implementation": "{\n    switch(index) {\n        case YEAR:\n            return getChronology().year().get(getLocalMillis());\n        case MONTH_OF_YEAR:\n            return getChronology().monthOfYear().get(getLocalMillis());\n        case DAY_OF_MONTH:\n            return getChronology().dayOfMonth().get(getLocalMillis());\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the value of the field at the specified index.\n * <p>\n * This method is required to support the <code>ReadablePartial</code>\n * interface. The supported fields are Year, MonthOfYear and DayOfMonth.\n * Note that all fields from day and above may in fact be queried via\n * other methods.\n *\n * @param index  the index, zero to two\n * @return the value\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "joda-time-main/", "id": 690, "method_signature": "int getValue(int)"}, "LocalDate.hashCode": {"callee_method_names": [], "method_name": "LocalDate.hashCode", "method_implementation": "{\n    // override for performance\n    int hash = iHash;\n    if (hash == 0) {\n        hash = iHash = super.hashCode();\n    }\n    return hash;\n}", "repo_id": "7", "comment": "/**\n * Gets a hash code for the instant as defined in <code>ReadablePartial</code>.\n *\n * @return a suitable hash code\n */\n", "repo_name": "joda-time-main/", "id": 695, "method_signature": "int hashCode()"}, "LocalDate.isSupported": {"callee_method_names": ["DurationFieldType.getField", "HashSet.contains", "DurationField.getUnitMillis", "DurationField.isSupported"], "method_name": "LocalDate.isSupported", "method_implementation": "{\n    if (type == null) {\n        return false;\n    }\n    DurationField field = type.getField(getChronology());\n    if (DATE_DURATION_TYPES.contains(type) || field.getUnitMillis() >= getChronology().days().getUnitMillis()) {\n        return field.isSupported();\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if the duration type specified is supported by this\n * local date and chronology.\n *\n * @param type  a duration type, usually obtained from DurationFieldType\n * @return true if the field type is supported\n */\n", "repo_name": "joda-time-main/", "id": 693, "method_signature": "boolean isSupported(DurationFieldType)"}, "LocalDate.minusDays": {"callee_method_names": [], "method_name": "LocalDate.minusDays", "method_implementation": "{\n    if (days == 0) {\n        return this;\n    }\n    long instant = getChronology().days().subtract(getLocalMillis(), days);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date minus the specified number of days.\n * <p>\n * This LocalDate instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDate subtracted = dt.minusDays(6);\n * LocalDate subtracted = dt.minus(Period.days(6));\n * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n * </pre>\n *\n * @param days  the amount of days to subtract, may be negative\n * @return the new LocalDate minus the increased days\n */\n", "repo_name": "joda-time-main/", "id": 716, "method_signature": "LocalDate minusDays(int)"}, "LocalDate.minusMonths": {"callee_method_names": [], "method_name": "LocalDate.minusMonths", "method_implementation": "{\n    if (months == 0) {\n        return this;\n    }\n    long instant = getChronology().months().subtract(getLocalMillis(), months);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date minus the specified number of months.\n * <p>\n * This subtracts the specified number of months from the date.\n * The subtraction may change the year, but the day-of-month is normally unchanged.\n * If subtracting months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n * This LocalDate instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDate subtracted = dt.minusMonths(6);\n * LocalDate subtracted = dt.minus(Period.months(6));\n * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n * </pre>\n *\n * @param months  the amount of months to subtract, may be negative\n * @return the new LocalDate minus the increased months\n */\n", "repo_name": "joda-time-main/", "id": 714, "method_signature": "LocalDate minusMonths(int)"}, "LocalDate.minusWeeks": {"callee_method_names": [], "method_name": "LocalDate.minusWeeks", "method_implementation": "{\n    if (weeks == 0) {\n        return this;\n    }\n    long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date minus the specified number of weeks.\n * <p>\n * This LocalDate instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDate subtracted = dt.minusWeeks(6);\n * LocalDate subtracted = dt.minus(Period.weeks(6));\n * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n * </pre>\n *\n * @param weeks  the amount of weeks to subtract, may be negative\n * @return the new LocalDate minus the increased weeks\n */\n", "repo_name": "joda-time-main/", "id": 715, "method_signature": "LocalDate minusWeeks(int)"}, "LocalDate.minusYears": {"callee_method_names": [], "method_name": "LocalDate.minusYears", "method_implementation": "{\n    if (years == 0) {\n        return this;\n    }\n    long instant = getChronology().years().subtract(getLocalMillis(), years);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date minus the specified number of years.\n * <p>\n * This subtracts the specified number of years from the date.\n * If subtracting years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n * This LocalDate instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDate subtracted = dt.minusYears(6);\n * LocalDate subtracted = dt.minus(Period.years(6));\n * LocalDate subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n * </pre>\n *\n * @param years  the amount of years to subtract, may be negative\n * @return the new LocalDate minus the increased years\n */\n", "repo_name": "joda-time-main/", "id": 713, "method_signature": "LocalDate minusYears(int)"}, "LocalDate.now": {"callee_method_names": [], "method_name": "LocalDate.now", "method_implementation": "{\n    if (chronology == null) {\n        throw new NullPointerException(\"Chronology must not be null\");\n    }\n    return new LocalDate(chronology);\n}", "repo_id": "7", "comment": "/**\n * Obtains a {@code LocalDate} set to the current system millisecond time\n * using the specified chronology.\n *\n * @param chronology  the chronology, not null\n * @return the current date-time, not null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 685, "method_signature": "LocalDate now(Chronology)"}, "LocalDate.plusDays": {"callee_method_names": [], "method_name": "LocalDate.plusDays", "method_implementation": "{\n    if (days == 0) {\n        return this;\n    }\n    long instant = getChronology().days().add(getLocalMillis(), days);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date plus the specified number of days.\n * <p>\n * This LocalDate instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDate added = dt.plusDays(6);\n * LocalDate added = dt.plus(Period.days(6));\n * LocalDate added = dt.withFieldAdded(DurationFieldType.days(), 6);\n * </pre>\n *\n * @param days  the amount of days to add, may be negative\n * @return the new LocalDate plus the increased days\n */\n", "repo_name": "joda-time-main/", "id": 712, "method_signature": "LocalDate plusDays(int)"}, "LocalDate.plusMonths": {"callee_method_names": [], "method_name": "LocalDate.plusMonths", "method_implementation": "{\n    if (months == 0) {\n        return this;\n    }\n    long instant = getChronology().months().add(getLocalMillis(), months);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date plus the specified number of months.\n * <p>\n * This adds the specified number of months to the date.\n * The addition may change the year, but the day-of-month is normally unchanged.\n * If adding months makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n * This LocalDate instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDate added = dt.plusMonths(6);\n * LocalDate added = dt.plus(Period.months(6));\n * LocalDate added = dt.withFieldAdded(DurationFieldType.months(), 6);\n * </pre>\n *\n * @param months  the amount of months to add, may be negative\n * @return the new LocalDate plus the increased months\n */\n", "repo_name": "joda-time-main/", "id": 710, "method_signature": "LocalDate plusMonths(int)"}, "LocalDate.plusWeeks": {"callee_method_names": [], "method_name": "LocalDate.plusWeeks", "method_implementation": "{\n    if (weeks == 0) {\n        return this;\n    }\n    long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date plus the specified number of weeks.\n * <p>\n * This LocalDate instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDate added = dt.plusWeeks(6);\n * LocalDate added = dt.plus(Period.weeks(6));\n * LocalDate added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n * </pre>\n *\n * @param weeks  the amount of weeks to add, may be negative\n * @return the new LocalDate plus the increased weeks\n */\n", "repo_name": "joda-time-main/", "id": 711, "method_signature": "LocalDate plusWeeks(int)"}, "LocalDate.plusYears": {"callee_method_names": [], "method_name": "LocalDate.plusYears", "method_implementation": "{\n    if (years == 0) {\n        return this;\n    }\n    long instant = getChronology().years().add(getLocalMillis(), years);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date plus the specified number of years.\n * <p>\n * This adds the specified number of years to the date.\n * If adding years makes the day-of-month invalid, it is adjusted to the last valid day in the month.\n * This LocalDate instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDate added = dt.plusYears(6);\n * LocalDate added = dt.plus(Period.years(6));\n * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n * </pre>\n *\n * @param years  the amount of years to add, may be negative\n * @return the new LocalDate plus the increased years\n */\n", "repo_name": "joda-time-main/", "id": 709, "method_signature": "LocalDate plusYears(int)"}, "LocalDate.property": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "LocalDate.property", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    if (isSupported(fieldType) == false) {\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n    }\n    return new Property(this, fieldType.getField(getChronology()));\n}", "repo_id": "7", "comment": "/**\n * Gets the property object for the specified type, which contains many\n * useful methods.\n *\n * @param fieldType  the field type to get the chronology for\n * @return the property object\n * @throws IllegalArgumentException if the field is null or unsupported\n */\n", "repo_name": "joda-time-main/", "id": 717, "method_signature": "Property property(DateTimeFieldType)"}, "LocalDate.readObject": {"callee_method_ids": [70], "callee_method_names": ["ObjectInputStream.readObject", "ObjectInputStream.readObject", "DateTimeFieldType.getField", "LocalDate.getChronology"], "method_name": "LocalDate.readObject", "method_implementation": "{\n    iInstant = (LocalDate) oos.readObject();\n    DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n    iField = type.getField(iInstant.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Reads the property from a safe serialization format.\n */\n", "repo_name": "joda-time-main/", "id": 721, "method_signature": "void readObject(ObjectInputStream)"}, "LocalDate.readResolve": {"callee_method_names": ["Chronology.getZone", "Chronology.withUTC"], "method_name": "LocalDate.readResolve", "method_implementation": "{\n    if (iChronology == null) {\n        return new LocalDate(iLocalMillis, ISOChronology.getInstanceUTC());\n    }\n    if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n        return new LocalDate(iLocalMillis, iChronology.withUTC());\n    }\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Handle broken serialization from other tools.\n * @return the resolved object, not null\n */\n", "repo_name": "joda-time-main/", "id": 688, "method_signature": "Object readResolve()"}, "LocalDate.toDate": {"callee_method_ids": [694, 694], "callee_method_names": ["LocalDate.isBefore", "LocalDate.equals", "Date.setTime", "Date.getTime", "Date.getDate", "Date.setTime", "Date.getTime", "Date.setTime", "Date.getTime", "LocalDate.equals", "Date.getTime", "Date.getDate"], "method_name": "LocalDate.toDate", "method_implementation": "{\n    int dom = getDayOfMonth();\n    Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom);\n    LocalDate check = LocalDate.fromDateFields(date);\n    if (check.isBefore(this)) {\n        // DST gap (no midnight)\n        // move forward in units of one hour until date correct\n        while (check.equals(this) == false) {\n            date.setTime(date.getTime() + 3600000);\n            check = LocalDate.fromDateFields(date);\n        }\n        // move back in units of one second until date wrong\n        while (date.getDate() == dom) {\n            date.setTime(date.getTime() - 1000);\n        }\n        // fix result\n        date.setTime(date.getTime() + 1000);\n    } else if (check.equals(this)) {\n        // check for DST overlap (two midnights)\n        Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings());\n        if (earlier.getDate() == dom) {\n            date = earlier;\n        }\n    }\n    return date;\n}", "repo_id": "7", "comment": "/**\n * Get the date time as a <code>java.util.Date</code>.\n * <p>\n * The <code>Date</code> object created has exactly the same year, month and day\n * as this date. The time will be set to the earliest valid time for that date.\n * <p>\n * Converting to a JDK Date is full of complications as the JDK Date constructor\n * doesn't behave as you might expect around DST transitions. This method works\n * by taking a first guess and then adjusting the JDK date until it has the\n * earliest valid instant. This also handles the situation where the JDK time\n * zone data differs from the Joda-Time time zone data.\n *\n * @return a Date initialised with this date, never null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 704, "method_signature": "Date toDate()"}, "LocalDate.toDateMidnight": {"callee_method_names": [], "method_name": "LocalDate.toDateMidnight", "method_implementation": "{\n    zone = DateTimeUtils.getZone(zone);\n    Chronology chrono = getChronology().withZone(zone);\n    return new DateMidnight(getYear(), getMonthOfYear(), getDayOfMonth(), chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this LocalDate to a DateMidnight.\n * <p>\n * As from v1.5, you are recommended to avoid DateMidnight and use\n * {@link #toDateTimeAtStartOfDay()} instead because of the exception\n * detailed below.\n * <p>\n * This method will throw an exception if the time zone switches\n * to Daylight Savings Time at midnight and this LocalDate represents\n * that switchover date. The problem is that there is no such time as\n * midnight on the required date, and as such an exception is thrown.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param zone  the zone to get the DateMidnight in, null means default zone\n * @return the DateMidnight instance\n * @deprecated DateMidnight is deprecated\n */\n", "repo_name": "joda-time-main/", "id": 700, "method_signature": "DateMidnight toDateMidnight(DateTimeZone)"}, "LocalDate.toDateTime": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "LocalDate.toDateTime", "method_implementation": "{\n    if (time == null) {\n        return toDateTimeAtCurrentTime(zone);\n    }\n    if (getChronology() != time.getChronology()) {\n        throw new IllegalArgumentException(\"The chronology of the time does not match\");\n    }\n    Chronology chrono = getChronology().withZone(zone);\n    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), time.getHourOfDay(), time.getMinuteOfHour(), time.getSecondOfMinute(), time.getMillisOfSecond(), chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this object to a DateTime using a LocalTime to fill in the\n * missing fields.\n * <p>\n * The resulting chronology is determined by the chronology of this\n * LocalDate plus the time zone. The chronology of the time must match.\n * <p>\n * If the time is null, this method delegates to {@link #toDateTimeAtCurrentTime(DateTimeZone)}\n * and the following documentation does not apply.\n * <p>\n * When the time zone is applied, the local date-time may be affected by daylight saving.\n * In a daylight saving gap, when the local time does not exist,\n * this method will throw an exception.\n * In a daylight saving overlap, when the same local time occurs twice,\n * this method returns the first occurrence of the local time.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param time  the time of day to use, null uses current time\n * @param zone  the zone to get the DateTime in, null means default\n * @return the DateTime instance\n * @throws IllegalArgumentException if the chronology of the time does not match\n * @throws IllegalInstantException if the local time does not exist when the time zone is applied\n */\n", "repo_name": "joda-time-main/", "id": 702, "method_signature": "DateTime toDateTime(LocalTime, DateTimeZone)"}, "LocalDate.toDateTimeAtCurrentTime": {"callee_method_names": ["Chronology.set"], "method_name": "LocalDate.toDateTimeAtCurrentTime", "method_implementation": "{\n    zone = DateTimeUtils.getZone(zone);\n    Chronology chrono = getChronology().withZone(zone);\n    long instantMillis = DateTimeUtils.currentTimeMillis();\n    long resolved = chrono.set(this, instantMillis);\n    return new DateTime(resolved, chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this LocalDate to a full datetime using the specified time zone\n * setting the date fields from this instance and the time fields from\n * the current time.\n * <p>\n * This method uses the chronology from this instance plus the time zone\n * specified.\n * <p>\n * This method will throw an exception if the datetime that would be\n * created does not exist when the time zone is taken into account.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param zone  the zone to use, null means default zone\n * @return this date as a datetime with the time as the current time\n */\n", "repo_name": "joda-time-main/", "id": 699, "method_signature": "DateTime toDateTimeAtCurrentTime(DateTimeZone)"}, "LocalDate.toDateTimeAtMidnight": {"callee_method_names": [], "method_name": "LocalDate.toDateTimeAtMidnight", "method_implementation": "{\n    zone = DateTimeUtils.getZone(zone);\n    Chronology chrono = getChronology().withZone(zone);\n    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), 0, 0, 0, 0, chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this LocalDate to a full datetime at midnight using the\n * specified time zone.\n * <p>\n * This method will throw an exception if the time zone switches\n * to Daylight Savings Time at midnight and this LocalDate represents\n * that switchover date. The problem is that there is no such time as\n * midnight on the required date, and as such an exception is thrown.\n * <p>\n * This method uses the chronology from this instance plus the time zone\n * specified.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param zone  the zone to use, null means default zone\n * @return this date as a datetime at midnight\n * @deprecated Use {@link #toDateTimeAtStartOfDay(DateTimeZone)} which won't throw an exception\n */\n", "repo_name": "joda-time-main/", "id": 698, "method_signature": "DateTime toDateTimeAtMidnight(DateTimeZone)"}, "LocalDate.toDateTimeAtStartOfDay": {"callee_method_ids": [118], "callee_method_names": ["DateTimeZone.convertLocalToUTC", "Chronology.dayOfMonth"], "method_name": "LocalDate.toDateTimeAtStartOfDay", "method_implementation": "{\n    zone = DateTimeUtils.getZone(zone);\n    Chronology chrono = getChronology().withZone(zone);\n    long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;\n    long instant = zone.convertLocalToUTC(localMillis, false);\n    instant = chrono.dayOfMonth().roundFloor(instant);\n    return new DateTime(instant, chrono).withEarlierOffsetAtOverlap();\n}", "repo_id": "7", "comment": "/**\n * Converts this LocalDate to a full datetime at the earliest valid time\n * for the date using the specified time zone.\n * <p>\n * The time will normally be midnight, as that is the earliest time on\n * any given day. However, in some time zones when Daylight Savings Time\n * starts, there is no midnight because time jumps from 11:59 to 01:00.\n * This method handles that situation by returning 01:00 on that date.\n * <p>\n * This method uses the chronology from this instance plus the time zone\n * specified.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param zone  the zone to use, null means default zone\n * @return this date as a datetime at the start of the day\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 697, "method_signature": "DateTime toDateTimeAtStartOfDay(DateTimeZone)"}, "LocalDate.toInterval": {"callee_method_names": [], "method_name": "LocalDate.toInterval", "method_implementation": "{\n    zone = DateTimeUtils.getZone(zone);\n    DateTime start = toDateTimeAtStartOfDay(zone);\n    DateTime end = plusDays(1).toDateTimeAtStartOfDay(zone);\n    return new Interval(start, end);\n}", "repo_id": "7", "comment": "/**\n * Converts this object to an Interval representing the whole day.\n * <p>\n * The interval may have more or less than 24 hours if this is a daylight\n * savings cutover date.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param zone  the zone to get the Interval in, null means default\n * @return a interval over the day\n */\n", "repo_name": "joda-time-main/", "id": 703, "method_signature": "Interval toInterval(DateTimeZone)"}, "LocalDate.toLocalDateTime": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getLocalMillis"], "method_name": "LocalDate.toLocalDateTime", "method_implementation": "{\n    if (time == null) {\n        throw new IllegalArgumentException(\"The time must not be null\");\n    }\n    if (getChronology() != time.getChronology()) {\n        throw new IllegalArgumentException(\"The chronology of the time does not match\");\n    }\n    long localMillis = getLocalMillis() + time.getLocalMillis();\n    return new LocalDateTime(localMillis, getChronology());\n}", "repo_id": "7", "comment": "/**\n * Converts this object to a LocalDateTime using a LocalTime to fill in\n * the missing fields.\n * <p>\n * The resulting chronology is determined by the chronology of this\n * LocalDate. The chronology of the time must also match.\n * If the time is null an exception is thrown.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param time  the time of day to use, must not be null\n * @return the LocalDateTime instance\n * @throws IllegalArgumentException if the time is null\n * @throws IllegalArgumentException if the chronology of the time does not match\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 701, "method_signature": "LocalDateTime toLocalDateTime(LocalTime)"}, "LocalDate.toString": {"callee_method_names": [], "method_name": "LocalDate.toString", "method_implementation": "{\n    if (pattern == null) {\n        return toString();\n    }\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n}", "repo_id": "7", "comment": "/**\n * Output the date using the specified format pattern.\n *\n * @param pattern  the pattern specification, null means use <code>toString</code>\n * @param locale  Locale to use, null means default\n * @return the formatted output\n * @throws IllegalArgumentException if the pattern is invalid\n * @see org.joda.time.format.DateTimeFormat\n */\n", "repo_name": "joda-time-main/", "id": 720, "method_signature": "String toString(String, Locale)"}, "LocalDate.withField": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "LocalDate.withField", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (isSupported(fieldType) == false) {\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n    }\n    long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the specified field set to a new value.\n * <p>\n * For example, if the field type is <code>monthOfYear</code> then the\n * month of year field will be changed in the returned instance.\n * If the field type is null, then <code>this</code> is returned.\n * <p>\n * These two lines are equivalent:\n * <pre>\n * LocalDate updated = dt.withDayOfMonth(6);\n * LocalDate updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n * </pre>\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this date with the field set\n * @throws IllegalArgumentException if the field is null or unsupported\n */\n", "repo_name": "joda-time-main/", "id": 706, "method_signature": "LocalDate withField(DateTimeFieldType, int)"}, "LocalDate.withFieldAdded": {"callee_method_names": ["DurationFieldType.getField"], "method_name": "LocalDate.withFieldAdded", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (isSupported(fieldType) == false) {\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n    }\n    if (amount == 0) {\n        return this;\n    }\n    long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the value of the specified field increased.\n * <p>\n * If the addition is zero or the field is null, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * LocalDate added = dt.withFieldAdded(DurationFieldType.years(), 6);\n * LocalDate added = dt.plusYears(6);\n * LocalDate added = dt.plus(Period.years(6));\n * </pre>\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this date with the field updated\n * @throws IllegalArgumentException if the field is null or unsupported\n * @throws ArithmeticException if the result exceeds the internal capacity\n */\n", "repo_name": "joda-time-main/", "id": 707, "method_signature": "LocalDate withFieldAdded(DurationFieldType, int)"}, "LocalDate.withFields": {"callee_method_names": [], "method_name": "LocalDate.withFields", "method_implementation": "{\n    if (partial == null) {\n        return this;\n    }\n    return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the partial set of fields replacing\n * those from this instance.\n * <p>\n * For example, if the partial contains a year and a month then those two\n * fields will be changed in the returned instance.\n * Unsupported fields are ignored.\n * If the partial is null, then <code>this</code> is returned.\n *\n * @param partial  the partial set of fields to apply to this date, null ignored\n * @return a copy of this date with a different set of fields\n * @throws IllegalArgumentException if any value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 705, "method_signature": "LocalDate withFields(ReadablePartial)"}, "LocalDate.withPeriodAdded": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getValue", "ReadablePeriod.getFieldType", "DurationFieldType.getField"], "method_name": "LocalDate.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    long instant = getLocalMillis();\n    Chronology chrono = getChronology();\n    for (int i = 0; i < period.size(); i++) {\n        long value = FieldUtils.safeMultiply(period.getValue(i), scalar);\n        DurationFieldType type = period.getFieldType(i);\n        if (isSupported(type)) {\n            instant = type.getField(chrono).add(instant, value);\n        }\n    }\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the specified period added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using methods\n * like {@link #withFieldAdded(DurationFieldType, int)}\n * or {@link #plusYears(int)}.\n * <p>\n * Unsupported time fields are ignored, thus adding a period of 24 hours\n * will not have any effect.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this date with the period added\n * @throws ArithmeticException if the result exceeds the internal capacity\n */\n", "repo_name": "joda-time-main/", "id": 708, "method_signature": "LocalDate withPeriodAdded(ReadablePeriod, int)"}, "LocalDateTime.compareTo": {"callee_method_names": ["Chronology.equals"], "method_name": "LocalDateTime.compareTo", "method_implementation": "{\n    // override to perform faster\n    if (this == partial) {\n        return 0;\n    }\n    if (partial instanceof LocalDateTime) {\n        LocalDateTime other = (LocalDateTime) partial;\n        if (iChronology.equals(other.iChronology)) {\n            return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1));\n        }\n    }\n    return super.compareTo(partial);\n}", "repo_id": "7", "comment": "/**\n * Compares this partial with another returning an integer\n * indicating the order.\n * <p>\n * The fields are compared in order, from largest to smallest.\n * The first field that is non-equal is used to determine the result.\n * <p>\n * The specified object must be a partial instance whose field types\n * match those of this partial.\n *\n * @param partial  an object to check against\n * @return negative if this is less, zero if equal, positive if greater\n * @throws ClassCastException if the partial is the wrong class\n *  or if it has field types that don't match\n * @throws NullPointerException if the partial is null\n */\n", "repo_name": "joda-time-main/", "id": 957, "method_signature": "int compareTo(ReadablePartial)"}, "LocalDateTime.correctDstTransition": {"callee_method_ids": [956, 956], "callee_method_names": ["Calendar.setTime", "LocalDateTime.isBefore", "LocalDateTime.isBefore", "Calendar.setTimeInMillis", "Calendar.getTimeInMillis", "LocalDateTime.isBefore", "Calendar.setTimeInMillis", "Calendar.getTimeInMillis", "Calendar.setTimeInMillis", "Calendar.getTimeInMillis", "LocalDateTime.equals", "Calendar.setTimeInMillis", "Calendar.getTimeInMillis", "TimeZone.getDSTSavings", "LocalDateTime.equals", "Calendar.getTime"], "method_name": "LocalDateTime.correctDstTransition", "method_implementation": "{\n    Calendar calendar = Calendar.getInstance(timeZone);\n    calendar.setTime(date);\n    LocalDateTime check = LocalDateTime.fromCalendarFields(calendar);\n    if (check.isBefore(this)) {\n        // DST gap\n        // move forward in units of one minute until equal/after\n        while (check.isBefore(this)) {\n            calendar.setTimeInMillis(calendar.getTimeInMillis() + 60000);\n            check = LocalDateTime.fromCalendarFields(calendar);\n        }\n        // move back in units of one second until date wrong\n        while (check.isBefore(this) == false) {\n            calendar.setTimeInMillis(calendar.getTimeInMillis() - 1000);\n            check = LocalDateTime.fromCalendarFields(calendar);\n        }\n        calendar.setTimeInMillis(calendar.getTimeInMillis() + 1000);\n    } else if (check.equals(this)) {\n        // check for DST overlap\n        final Calendar earlier = Calendar.getInstance(timeZone);\n        earlier.setTimeInMillis(calendar.getTimeInMillis() - timeZone.getDSTSavings());\n        check = LocalDateTime.fromCalendarFields(earlier);\n        if (check.equals(this)) {\n            calendar = earlier;\n        }\n    }\n    return calendar.getTime();\n}", "repo_id": "7", "comment": "/**\n * Correct <code>date</code> in case of DST overlap.\n * <p>\n * The <code>Date</code> object created has exactly the same fields as this\n * date-time, except when the time would be invalid due to a daylight savings\n * gap. In that case, the time will be set to the earliest valid time after the gap.\n * <p>\n * In the case of a daylight savings overlap, the earlier instant is selected.\n * <p>\n * Converting to a JDK Date is full of complications as the JDK Date constructor\n * doesn't behave as you might expect around DST transitions. This method works\n * by taking a first guess and then adjusting. This also handles the situation\n * where the JDK time zone data differs from the Joda-Time time zone data.\n * @see #toDate()\n */\n", "repo_name": "joda-time-main/", "id": 961, "method_signature": "Date correctDstTransition(Date, TimeZone)"}, "LocalDateTime.equals": {"callee_method_names": ["Chronology.equals"], "method_name": "LocalDateTime.equals", "method_implementation": "{\n    // override to perform faster\n    if (this == partial) {\n        return true;\n    }\n    if (partial instanceof LocalDateTime) {\n        LocalDateTime other = (LocalDateTime) partial;\n        if (iChronology.equals(other.iChronology)) {\n            return iLocalMillis == other.iLocalMillis;\n        }\n    }\n    return super.equals(partial);\n}", "repo_id": "7", "comment": "/**\n * Compares this ReadablePartial with another returning true if the chronology,\n * field types and values are equal.\n *\n * @param partial  an object to check against\n * @return true if fields and values are equal\n */\n", "repo_name": "joda-time-main/", "id": 956, "method_signature": "boolean equals(Object)"}, "LocalDateTime.fromCalendarFields": {"callee_method_names": ["Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get"], "method_name": "LocalDateTime.fromCalendarFields", "method_implementation": "{\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    int era = calendar.get(Calendar.ERA);\n    int yearOfEra = calendar.get(Calendar.YEAR);\n    return new LocalDateTime((era == GregorianCalendar.AD ? yearOfEra : 1 - yearOfEra), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH), calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND));\n}", "repo_id": "7", "comment": "/**\n * Constructs a LocalDateTime from a <code>java.util.Calendar</code>\n * using exactly the same field values.\n * <p>\n * Each field is queried from the Calendar and assigned to the LocalDateTime.\n * This is useful if you have been using the Calendar as a local date,\n * ignoring the zone.\n * <p>\n * One advantage of this method is that this method is unaffected if the\n * version of the time zone data differs between the JDK and Joda-Time.\n * That is because the local field values are transferred, calculated using\n * the JDK time zone data and without using the Joda-Time time zone data.\n * <p>\n * This factory method ignores the type of the calendar and always\n * creates a LocalDateTime with ISO chronology. It is expected that you\n * will only pass in instances of <code>GregorianCalendar</code> however\n * this is not validated.\n *\n * @param calendar  the Calendar to extract fields from, not null\n * @return the created local date-time, not null\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 948, "method_signature": "LocalDateTime fromCalendarFields(Calendar)"}, "LocalDateTime.fromDateFields": {"callee_method_names": ["Date.getTime", "GregorianCalendar.setTime", "Date.getYear", "Date.getMonth", "Date.getDate", "Date.getHours", "Date.getMinutes", "Date.getSeconds", "Date.getTime"], "method_name": "LocalDateTime.fromDateFields", "method_implementation": "{\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    if (date.getTime() < 0) {\n        // handle years in era BC\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTime(date);\n        return fromCalendarFields(cal);\n    }\n    return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000);\n}", "repo_id": "7", "comment": "/**\n * Constructs a LocalDateTime from a <code>java.util.Date</code>\n * using exactly the same field values.\n * <p>\n * Each field is queried from the Date and assigned to the LocalDateTime.\n * This is useful if you have been using the Date as a local date,\n * ignoring the zone.\n * <p>\n * One advantage of this method is that this method is unaffected if the\n * version of the time zone data differs between the JDK and Joda-Time.\n * That is because the local field values are transferred, calculated using\n * the JDK time zone data and without using the Joda-Time time zone data.\n * <p>\n * This factory method always creates a LocalDateTime with ISO chronology.\n *\n * @param date  the Date to extract fields from, not null\n * @return the created local date-time, not null\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 949, "method_signature": "LocalDateTime fromDateFields(Date)"}, "LocalDateTime.get": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "LocalDateTime.get", "method_implementation": "{\n    if (type == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    return type.getField(getChronology()).get(getLocalMillis());\n}", "repo_id": "7", "comment": "/**\n * Get the value of one of the fields of a datetime.\n * <p>\n * This method gets the value of the specified field.\n * For example:\n * <pre>\n * DateTime dt = new DateTime();\n * int year = dt.get(DateTimeFieldType.year());\n * </pre>\n *\n * @param type  a field type, usually obtained from DateTimeFieldType, not null\n * @return the value of that field\n * @throws IllegalArgumentException if the field type is null\n */\n", "repo_name": "joda-time-main/", "id": 953, "method_signature": "int get(DateTimeFieldType)"}, "LocalDateTime.getField": {"callee_method_names": ["Chronology.year", "Chronology.monthOfYear", "Chronology.dayOfMonth", "Chronology.millisOfDay"], "method_name": "LocalDateTime.getField", "method_implementation": "{\n    switch(index) {\n        case YEAR:\n            return chrono.year();\n        case MONTH_OF_YEAR:\n            return chrono.monthOfYear();\n        case DAY_OF_MONTH:\n            return chrono.dayOfMonth();\n        case MILLIS_OF_DAY:\n            return chrono.millisOfDay();\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the field for a specific index in the chronology specified.\n * <p>\n * This method must not use any instance variables.\n *\n * @param index  the index to retrieve\n * @param chrono  the chronology to use\n * @return the field\n */\n", "repo_name": "joda-time-main/", "id": 951, "method_signature": "DateTimeField getField(int, Chronology)"}, "LocalDateTime.getValue": {"callee_method_names": [], "method_name": "LocalDateTime.getValue", "method_implementation": "{\n    switch(index) {\n        case YEAR:\n            return getChronology().year().get(getLocalMillis());\n        case MONTH_OF_YEAR:\n            return getChronology().monthOfYear().get(getLocalMillis());\n        case DAY_OF_MONTH:\n            return getChronology().dayOfMonth().get(getLocalMillis());\n        case MILLIS_OF_DAY:\n            return getChronology().millisOfDay().get(getLocalMillis());\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the value of the field at the specified index.\n * <p>\n * This method is required to support the <code>ReadablePartial</code>\n * interface. The supported fields are Year, MonthOfDay, DayOfMonth and MillisOfDay.\n *\n * @param index  the index, zero to two\n * @return the value\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "joda-time-main/", "id": 952, "method_signature": "int getValue(int)"}, "LocalDateTime.isSupported": {"callee_method_names": ["DurationFieldType.getField"], "method_name": "LocalDateTime.isSupported", "method_implementation": "{\n    if (type == null) {\n        return false;\n    }\n    return type.getField(getChronology()).isSupported();\n}", "repo_id": "7", "comment": "/**\n * Checks if the duration type specified is supported by this\n * local datetime and chronology.\n *\n * @param type  a duration type, usually obtained from DurationFieldType\n * @return true if the field type is supported\n */\n", "repo_name": "joda-time-main/", "id": 955, "method_signature": "boolean isSupported(DurationFieldType)"}, "LocalDateTime.minusDays": {"callee_method_names": [], "method_name": "LocalDateTime.minusDays", "method_implementation": "{\n    if (days == 0) {\n        return this;\n    }\n    long instant = getChronology().days().subtract(getLocalMillis(), days);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of days.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime subtracted = dt.minusDays(6);\n * LocalDateTime subtracted = dt.minus(Period.days(6));\n * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.days(), -6);\n * </pre>\n *\n * @param days  the amount of days to subtract, may be negative\n * @return the new LocalDateTime minus the increased days\n */\n", "repo_name": "joda-time-main/", "id": 980, "method_signature": "LocalDateTime minusDays(int)"}, "LocalDateTime.minusHours": {"callee_method_names": [], "method_name": "LocalDateTime.minusHours", "method_implementation": "{\n    if (hours == 0) {\n        return this;\n    }\n    long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of hours.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime subtracted = dt.minusHours(6);\n * LocalDateTime subtracted = dt.minus(Period.hours(6));\n * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n * </pre>\n *\n * @param hours  the amount of hours to subtract, may be negative\n * @return the new LocalDateTime minus the increased hours\n */\n", "repo_name": "joda-time-main/", "id": 981, "method_signature": "LocalDateTime minusHours(int)"}, "LocalDateTime.minusMillis": {"callee_method_names": [], "method_name": "LocalDateTime.minusMillis", "method_implementation": "{\n    if (millis == 0) {\n        return this;\n    }\n    long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of millis.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime subtracted = dt.minusMillis(6);\n * LocalDateTime subtracted = dt.minus(Period.millis(6));\n * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n * </pre>\n *\n * @param millis  the amount of millis to subtract, may be negative\n * @return the new LocalDateTime minus the increased millis\n */\n", "repo_name": "joda-time-main/", "id": 984, "method_signature": "LocalDateTime minusMillis(int)"}, "LocalDateTime.minusMinutes": {"callee_method_names": [], "method_name": "LocalDateTime.minusMinutes", "method_implementation": "{\n    if (minutes == 0) {\n        return this;\n    }\n    long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of minutes.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime subtracted = dt.minusMinutes(6);\n * LocalDateTime subtracted = dt.minus(Period.minutes(6));\n * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n * </pre>\n *\n * @param minutes  the amount of minutes to subtract, may be negative\n * @return the new LocalDateTime minus the increased minutes\n */\n", "repo_name": "joda-time-main/", "id": 982, "method_signature": "LocalDateTime minusMinutes(int)"}, "LocalDateTime.minusMonths": {"callee_method_names": [], "method_name": "LocalDateTime.minusMonths", "method_implementation": "{\n    if (months == 0) {\n        return this;\n    }\n    long instant = getChronology().months().subtract(getLocalMillis(), months);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of months.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime subtracted = dt.minusMonths(6);\n * LocalDateTime subtracted = dt.minus(Period.months(6));\n * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.months(), -6);\n * </pre>\n *\n * @param months  the amount of months to subtract, may be negative\n * @return the new LocalDateTime minus the increased months\n */\n", "repo_name": "joda-time-main/", "id": 978, "method_signature": "LocalDateTime minusMonths(int)"}, "LocalDateTime.minusSeconds": {"callee_method_names": [], "method_name": "LocalDateTime.minusSeconds", "method_implementation": "{\n    if (seconds == 0) {\n        return this;\n    }\n    long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of seconds.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime subtracted = dt.minusSeconds(6);\n * LocalDateTime subtracted = dt.minus(Period.seconds(6));\n * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n * </pre>\n *\n * @param seconds  the amount of seconds to subtract, may be negative\n * @return the new LocalDateTime minus the increased seconds\n */\n", "repo_name": "joda-time-main/", "id": 983, "method_signature": "LocalDateTime minusSeconds(int)"}, "LocalDateTime.minusWeeks": {"callee_method_names": [], "method_name": "LocalDateTime.minusWeeks", "method_implementation": "{\n    if (weeks == 0) {\n        return this;\n    }\n    long instant = getChronology().weeks().subtract(getLocalMillis(), weeks);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of weeks.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime subtracted = dt.minusWeeks(6);\n * LocalDateTime subtracted = dt.minus(Period.weeks(6));\n * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.weeks(), -6);\n * </pre>\n *\n * @param weeks  the amount of weeks to subtract, may be negative\n * @return the new LocalDateTime minus the increased weeks\n */\n", "repo_name": "joda-time-main/", "id": 979, "method_signature": "LocalDateTime minusWeeks(int)"}, "LocalDateTime.minusYears": {"callee_method_names": [], "method_name": "LocalDateTime.minusYears", "method_implementation": "{\n    if (years == 0) {\n        return this;\n    }\n    long instant = getChronology().years().subtract(getLocalMillis(), years);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime minus the specified number of years.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime subtracted = dt.minusYears(6);\n * LocalDateTime subtracted = dt.minus(Period.years(6));\n * LocalDateTime subtracted = dt.withFieldAdded(DurationFieldType.years(), -6);\n * </pre>\n *\n * @param years  the amount of years to subtract, may be negative\n * @return the new LocalDateTime minus the increased years\n */\n", "repo_name": "joda-time-main/", "id": 977, "method_signature": "LocalDateTime minusYears(int)"}, "LocalDateTime.now": {"callee_method_names": [], "method_name": "LocalDateTime.now", "method_implementation": "{\n    if (chronology == null) {\n        throw new NullPointerException(\"Chronology must not be null\");\n    }\n    return new LocalDateTime(chronology);\n}", "repo_id": "7", "comment": "/**\n * Obtains a {@code LocalDateTime} set to the current system millisecond time\n * using the specified chronology.\n * The resulting object does not use the zone.\n *\n * @param chronology  the chronology, not null\n * @return the current date, not null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 947, "method_signature": "LocalDateTime now(Chronology)"}, "LocalDateTime.plusDays": {"callee_method_names": [], "method_name": "LocalDateTime.plusDays", "method_implementation": "{\n    if (days == 0) {\n        return this;\n    }\n    long instant = getChronology().days().add(getLocalMillis(), days);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of days.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime added = dt.plusDays(6);\n * LocalDateTime added = dt.plus(Period.days(6));\n * LocalDateTime added = dt.withFieldAdded(DurationFieldType.days(), 6);\n * </pre>\n *\n * @param days  the amount of days to add, may be negative\n * @return the new LocalDateTime plus the increased days\n */\n", "repo_name": "joda-time-main/", "id": 972, "method_signature": "LocalDateTime plusDays(int)"}, "LocalDateTime.plusHours": {"callee_method_names": [], "method_name": "LocalDateTime.plusHours", "method_implementation": "{\n    if (hours == 0) {\n        return this;\n    }\n    long instant = getChronology().hours().add(getLocalMillis(), hours);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of hours.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime added = dt.plusHours(6);\n * LocalDateTime added = dt.plus(Period.hours(6));\n * LocalDateTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n * </pre>\n *\n * @param hours  the amount of hours to add, may be negative\n * @return the new LocalDateTime plus the increased hours\n */\n", "repo_name": "joda-time-main/", "id": 973, "method_signature": "LocalDateTime plusHours(int)"}, "LocalDateTime.plusMillis": {"callee_method_names": [], "method_name": "LocalDateTime.plusMillis", "method_implementation": "{\n    if (millis == 0) {\n        return this;\n    }\n    long instant = getChronology().millis().add(getLocalMillis(), millis);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of millis.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime added = dt.plusMillis(6);\n * LocalDateTime added = dt.plus(Period.millis(6));\n * LocalDateTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n * </pre>\n *\n * @param millis  the amount of millis to add, may be negative\n * @return the new LocalDateTime plus the increased millis\n */\n", "repo_name": "joda-time-main/", "id": 976, "method_signature": "LocalDateTime plusMillis(int)"}, "LocalDateTime.plusMinutes": {"callee_method_names": [], "method_name": "LocalDateTime.plusMinutes", "method_implementation": "{\n    if (minutes == 0) {\n        return this;\n    }\n    long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of minutes.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime added = dt.plusMinutes(6);\n * LocalDateTime added = dt.plus(Period.minutes(6));\n * LocalDateTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n * </pre>\n *\n * @param minutes  the amount of minutes to add, may be negative\n * @return the new LocalDateTime plus the increased minutes\n */\n", "repo_name": "joda-time-main/", "id": 974, "method_signature": "LocalDateTime plusMinutes(int)"}, "LocalDateTime.plusMonths": {"callee_method_names": [], "method_name": "LocalDateTime.plusMonths", "method_implementation": "{\n    if (months == 0) {\n        return this;\n    }\n    long instant = getChronology().months().add(getLocalMillis(), months);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of months.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime added = dt.plusMonths(6);\n * LocalDateTime added = dt.plus(Period.months(6));\n * LocalDateTime added = dt.withFieldAdded(DurationFieldType.months(), 6);\n * </pre>\n *\n * @param months  the amount of months to add, may be negative\n * @return the new LocalDateTime plus the increased months\n */\n", "repo_name": "joda-time-main/", "id": 970, "method_signature": "LocalDateTime plusMonths(int)"}, "LocalDateTime.plusSeconds": {"callee_method_names": [], "method_name": "LocalDateTime.plusSeconds", "method_implementation": "{\n    if (seconds == 0) {\n        return this;\n    }\n    long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of seconds.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime added = dt.plusSeconds(6);\n * LocalDateTime added = dt.plus(Period.seconds(6));\n * LocalDateTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n * </pre>\n *\n * @param seconds  the amount of seconds to add, may be negative\n * @return the new LocalDateTime plus the increased seconds\n */\n", "repo_name": "joda-time-main/", "id": 975, "method_signature": "LocalDateTime plusSeconds(int)"}, "LocalDateTime.plusWeeks": {"callee_method_names": [], "method_name": "LocalDateTime.plusWeeks", "method_implementation": "{\n    if (weeks == 0) {\n        return this;\n    }\n    long instant = getChronology().weeks().add(getLocalMillis(), weeks);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of weeks.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime added = dt.plusWeeks(6);\n * LocalDateTime added = dt.plus(Period.weeks(6));\n * LocalDateTime added = dt.withFieldAdded(DurationFieldType.weeks(), 6);\n * </pre>\n *\n * @param weeks  the amount of weeks to add, may be negative\n * @return the new LocalDateTime plus the increased weeks\n */\n", "repo_name": "joda-time-main/", "id": 971, "method_signature": "LocalDateTime plusWeeks(int)"}, "LocalDateTime.plusYears": {"callee_method_names": [], "method_name": "LocalDateTime.plusYears", "method_implementation": "{\n    if (years == 0) {\n        return this;\n    }\n    long instant = getChronology().years().add(getLocalMillis(), years);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime plus the specified number of years.\n * <p>\n * This LocalDateTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalDateTime added = dt.plusYears(6);\n * LocalDateTime added = dt.plus(Period.years(6));\n * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n * </pre>\n *\n * @param years  the amount of years to add, may be negative\n * @return the new LocalDateTime plus the increased years\n */\n", "repo_name": "joda-time-main/", "id": 969, "method_signature": "LocalDateTime plusYears(int)"}, "LocalDateTime.property": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "LocalDateTime.property", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    if (isSupported(fieldType) == false) {\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n    }\n    return new Property(this, fieldType.getField(getChronology()));\n}", "repo_id": "7", "comment": "/**\n * Gets the property object for the specified type, which contains many\n * useful methods.\n *\n * @param fieldType  the field type to get the chronology for\n * @return the property object\n * @throws IllegalArgumentException if the field is null or unsupported\n */\n", "repo_name": "joda-time-main/", "id": 985, "method_signature": "Property property(DateTimeFieldType)"}, "LocalDateTime.readObject": {"callee_method_ids": [70], "callee_method_names": ["ObjectInputStream.readObject", "ObjectInputStream.readObject", "DateTimeFieldType.getField", "LocalDateTime.getChronology"], "method_name": "LocalDateTime.readObject", "method_implementation": "{\n    iInstant = (LocalDateTime) oos.readObject();\n    DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n    iField = type.getField(iInstant.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Reads the property from a safe serialization format.\n */\n", "repo_name": "joda-time-main/", "id": 989, "method_signature": "void readObject(ObjectInputStream)"}, "LocalDateTime.readResolve": {"callee_method_names": ["Chronology.getZone", "Chronology.withUTC"], "method_name": "LocalDateTime.readResolve", "method_implementation": "{\n    if (iChronology == null) {\n        return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC());\n    }\n    if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n        return new LocalDateTime(iLocalMillis, iChronology.withUTC());\n    }\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Handle broken serialization from other tools.\n * @return the resolved object, not null\n */\n", "repo_name": "joda-time-main/", "id": 950, "method_signature": "Object readResolve()"}, "LocalDateTime.toDate": {"callee_method_names": ["Calendar.clear", "Calendar.set", "Calendar.getTime", "Date.setTime", "Date.getTime"], "method_name": "LocalDateTime.toDate", "method_implementation": "{\n    final Calendar calendar = Calendar.getInstance(timeZone);\n    calendar.clear();\n    calendar.set(getYear(), getMonthOfYear() - 1, getDayOfMonth(), getHourOfDay(), getMinuteOfHour(), getSecondOfMinute());\n    Date date = calendar.getTime();\n    date.setTime(date.getTime() + getMillisOfSecond());\n    return correctDstTransition(date, timeZone);\n}", "repo_id": "7", "comment": "/**\n * Get the date time as a <code>java.util.Date</code> using the specified time zone.\n * <p>\n * The <code>Date</code> object created has exactly the same fields as this\n * date-time, except when the time would be invalid due to a daylight savings\n * gap. In that case, the time will be set to the earliest valid time after the gap.\n * <p>\n * In the case of a daylight savings overlap, the earlier instant is selected.\n * <p>\n * Converting to a JDK Date is full of complications as the JDK Date constructor\n * doesn't behave as you might expect around DST transitions. This method works\n * by taking a first guess and then adjusting. This also handles the situation\n * where the JDK time zone data differs from the Joda-Time time zone data.\n * <p>\n * Unlike {@link #toDate()}, this implementation does not rely on Java's synchronized\n * time zone initialization logic, and should demonstrate better concurrent performance\n * characteristics.\n *\n * @param timeZone  the time zone\n * @return a Date initialised with this date-time, never null\n * @since 2.3\n */\n", "repo_name": "joda-time-main/", "id": 960, "method_signature": "Date toDate(TimeZone)"}, "LocalDateTime.toDateTime": {"callee_method_names": ["Chronology.withZone"], "method_name": "LocalDateTime.toDateTime", "method_implementation": "{\n    zone = DateTimeUtils.getZone(zone);\n    Chronology chrono = iChronology.withZone(zone);\n    return new DateTime(getYear(), getMonthOfYear(), getDayOfMonth(), getHourOfDay(), getMinuteOfHour(), getSecondOfMinute(), getMillisOfSecond(), chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this object to a DateTime using the specified zone.\n * <p>\n * When the time zone is applied, the local date-time may be affected by daylight saving.\n * In a daylight saving gap, when the local time does not exist,\n * this method will throw an exception.\n * In a daylight saving overlap, when the same local time occurs twice,\n * this method returns the first occurrence of the local time.\n *\n * @param zone time zone to apply, or default if null\n * @return a DateTime using the same millis\n * @throws IllegalInstantException if the local time does not exist when the time zone is applied\n */\n", "repo_name": "joda-time-main/", "id": 958, "method_signature": "DateTime toDateTime(DateTimeZone)"}, "LocalDateTime.toString": {"callee_method_names": [], "method_name": "LocalDateTime.toString", "method_implementation": "{\n    if (pattern == null) {\n        return toString();\n    }\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n}", "repo_id": "7", "comment": "/**\n * Output the date using the specified format pattern.\n *\n * @param pattern  the pattern specification, null means use <code>toString</code>\n * @param locale  Locale to use, null means default\n * @return the formatted output, not null\n * @throws IllegalArgumentException if the pattern is invalid\n * @see org.joda.time.format.DateTimeFormat\n */\n", "repo_name": "joda-time-main/", "id": 988, "method_signature": "String toString(String, Locale)"}, "LocalDateTime.withDate": {"callee_method_names": ["Chronology.year", "Chronology.monthOfYear", "Chronology.dayOfMonth"], "method_name": "LocalDateTime.withDate", "method_implementation": "{\n    Chronology chrono = getChronology();\n    long instant = getLocalMillis();\n    instant = chrono.year().set(instant, year);\n    instant = chrono.monthOfYear().set(instant, monthOfYear);\n    instant = chrono.dayOfMonth().set(instant, dayOfMonth);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified date,\n * retaining the time fields.\n * <p>\n * If the date is already the date passed in, then <code>this</code> is returned.\n * <p>\n * To set a single field use the properties, for example:\n * <pre>\n * DateTime set = dt.monthOfYear().setCopy(6);\n * </pre>\n *\n * @param year  the new year value\n * @param monthOfYear  the new monthOfYear value\n * @param dayOfMonth  the new dayOfMonth value\n * @return a copy of this datetime with a different date\n * @throws IllegalArgumentException if any value if invalid\n */\n", "repo_name": "joda-time-main/", "id": 962, "method_signature": "LocalDateTime withDate(int, int, int)"}, "LocalDateTime.withDurationAdded": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "LocalDateTime.withDurationAdded", "method_implementation": "{\n    if (durationToAdd == null || scalar == 0) {\n        return this;\n    }\n    long instant = getChronology().add(getLocalMillis(), durationToAdd.getMillis(), scalar);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified duration added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n *\n * @param durationToAdd  the duration to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this datetime with the duration added\n * @throws ArithmeticException if the result exceeds the internal capacity\n */\n", "repo_name": "joda-time-main/", "id": 967, "method_signature": "LocalDateTime withDurationAdded(ReadableDuration, int)"}, "LocalDateTime.withField": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "LocalDateTime.withField", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified field set to a new value.\n * <p>\n * For example, if the field type is <code>hourOfDay</code> then the hour of day\n * field would be changed in the returned instance.\n * If the field type is null, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * LocalDateTime updated = dt.withField(DateTimeFieldType.dayOfMonth(), 6);\n * LocalDateTime updated = dt.dayOfMonth().setCopy(6);\n * LocalDateTime updated = dt.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this datetime with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 965, "method_signature": "LocalDateTime withField(DateTimeFieldType, int)"}, "LocalDateTime.withFieldAdded": {"callee_method_names": ["DurationFieldType.getField"], "method_name": "LocalDateTime.withFieldAdded", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (amount == 0) {\n        return this;\n    }\n    long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the value of the specified\n * field increased.\n * <p>\n * If the addition is zero or the field is null, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * LocalDateTime added = dt.withFieldAdded(DurationFieldType.years(), 6);\n * LocalDateTime added = dt.plusYears(6);\n * LocalDateTime added = dt.plus(Period.years(6));\n * </pre>\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this datetime with the field updated\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the result exceeds the internal capacity\n */\n", "repo_name": "joda-time-main/", "id": 966, "method_signature": "LocalDateTime withFieldAdded(DurationFieldType, int)"}, "LocalDateTime.withFields": {"callee_method_names": [], "method_name": "LocalDateTime.withFields", "method_implementation": "{\n    if (partial == null) {\n        return this;\n    }\n    return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the partial set of fields\n * replacing those from this instance.\n * <p>\n * For example, if the partial is a <code>TimeOfDay</code> then the time fields\n * would be changed in the returned instance.\n * If the partial is null, then <code>this</code> is returned.\n *\n * @param partial  the partial set of fields to apply to this datetime, null ignored\n * @return a copy of this datetime with a different set of fields\n * @throws IllegalArgumentException if any value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 964, "method_signature": "LocalDateTime withFields(ReadablePartial)"}, "LocalDateTime.withPeriodAdded": {"callee_method_names": [], "method_name": "LocalDateTime.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    long instant = getChronology().add(period, getLocalMillis(), scalar);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified period added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using methods\n * like {@link #withFieldAdded(DurationFieldType, int)}\n * or {@link #plusYears(int)}.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this datetime with the period added\n * @throws ArithmeticException if the result exceeds the internal capacity\n */\n", "repo_name": "joda-time-main/", "id": 968, "method_signature": "LocalDateTime withPeriodAdded(ReadablePeriod, int)"}, "LocalDateTime.withTime": {"callee_method_names": ["Chronology.hourOfDay", "Chronology.minuteOfHour", "Chronology.secondOfMinute", "Chronology.millisOfSecond"], "method_name": "LocalDateTime.withTime", "method_implementation": "{\n    Chronology chrono = getChronology();\n    long instant = getLocalMillis();\n    instant = chrono.hourOfDay().set(instant, hourOfDay);\n    instant = chrono.minuteOfHour().set(instant, minuteOfHour);\n    instant = chrono.secondOfMinute().set(instant, secondOfMinute);\n    instant = chrono.millisOfSecond().set(instant, millisOfSecond);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this datetime with the specified time,\n * retaining the date fields.\n * <p>\n * If the time is already the time passed in, then <code>this</code> is returned.\n * <p>\n * To set a single field use the properties, for example:\n * <pre>\n * LocalDateTime set = dt.hourOfDay().setCopy(6);\n * </pre>\n *\n * @param hourOfDay  the hour of the day\n * @param minuteOfHour  the minute of the hour\n * @param secondOfMinute  the second of the minute\n * @param millisOfSecond  the millisecond of the second\n * @return a copy of this datetime with a different time\n * @throws IllegalArgumentException if any value if invalid\n */\n", "repo_name": "joda-time-main/", "id": 963, "method_signature": "LocalDateTime withTime(int, int, int, int)"}, "LocalTime.addNoWrapToCopy": {"callee_method_names": ["DateTimeField.add", "LocalTime.getLocalMillis", "LocalTime.getChronology", "LocalTime.withLocalMillis"], "method_name": "LocalTime.addNoWrapToCopy", "method_implementation": "{\n    long millis = iField.add(iInstant.getLocalMillis(), value);\n    long rounded = iInstant.getChronology().millisOfDay().get(millis);\n    if (rounded != millis) {\n        throw new IllegalArgumentException(\"The addition exceeded the boundaries of LocalTime\");\n    }\n    return iInstant.withLocalMillis(millis);\n}", "repo_id": "7", "comment": "/**\n * Adds to this field in a copy of this LocalTime.\n * If the addition exceeds the maximum value (eg. 23:59) then\n * an exception will be thrown.\n * Contrast this behaviour to {@link #addCopy(int)}.\n * <p>\n * The LocalTime attached to this property is unchanged by this call.\n *\n * @param value  the value to add to the field in the copy\n * @return a copy of the LocalTime with the field value changed\n * @throws IllegalArgumentException if the result is invalid\n */\n", "repo_name": "joda-time-main/", "id": 1053, "method_signature": "LocalTime addNoWrapToCopy(int)"}, "LocalTime.compareTo": {"callee_method_names": ["Chronology.equals"], "method_name": "LocalTime.compareTo", "method_implementation": "{\n    // override to perform faster\n    if (this == partial) {\n        return 0;\n    }\n    if (partial instanceof LocalTime) {\n        LocalTime other = (LocalTime) partial;\n        if (iChronology.equals(other.iChronology)) {\n            return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1));\n        }\n    }\n    return super.compareTo(partial);\n}", "repo_id": "7", "comment": "/**\n * Compares this partial with another returning an integer\n * indicating the order.\n * <p>\n * The fields are compared in order, from largest to smallest.\n * The first field that is non-equal is used to determine the result.\n * <p>\n * The specified object must be a partial instance whose field types\n * match those of this partial.\n *\n * @param partial  an object to check against\n * @return negative if this is less, zero if equal, positive if greater\n * @throws ClassCastException if the partial is the wrong class\n *  or if it has field types that don't match\n * @throws NullPointerException if the partial is null\n */\n", "repo_name": "joda-time-main/", "id": 1034, "method_signature": "int compareTo(ReadablePartial)"}, "LocalTime.equals": {"callee_method_names": ["Chronology.equals"], "method_name": "LocalTime.equals", "method_implementation": "{\n    // override to perform faster\n    if (this == partial) {\n        return true;\n    }\n    if (partial instanceof LocalTime) {\n        LocalTime other = (LocalTime) partial;\n        if (iChronology.equals(other.iChronology)) {\n            return iLocalMillis == other.iLocalMillis;\n        }\n    }\n    return super.equals(partial);\n}", "repo_id": "7", "comment": "/**\n * Compares this ReadablePartial with another returning true if the chronology,\n * field types and values are equal.\n *\n * @param partial  an object to check against\n * @return true if fields and values are equal\n */\n", "repo_name": "joda-time-main/", "id": 1033, "method_signature": "boolean equals(Object)"}, "LocalTime.fromCalendarFields": {"callee_method_names": ["Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get"], "method_name": "LocalTime.fromCalendarFields", "method_implementation": "{\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    return new LocalTime(calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND));\n}", "repo_id": "7", "comment": "/**\n * Constructs a LocalTime from a <code>java.util.Calendar</code>\n * using exactly the same field values.\n * <p>\n * Each field is queried from the Calendar and assigned to the LocalTime.\n * This is useful if you have been using the Calendar as a local time,\n * ignoring the zone.\n * <p>\n * One advantage of this method is that this method is unaffected if the\n * version of the time zone data differs between the JDK and Joda-Time.\n * That is because the local field values are transferred, calculated using\n * the JDK time zone data and without using the Joda-Time time zone data.\n * <p>\n * This factory method ignores the type of the calendar and always\n * creates a LocalTime with ISO chronology. It is expected that you\n * will only pass in instances of <code>GregorianCalendar</code> however\n * this is not validated.\n *\n * @param calendar  the Calendar to extract fields from\n * @return the created LocalTime\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 1025, "method_signature": "LocalTime fromCalendarFields(Calendar)"}, "LocalTime.fromDateFields": {"callee_method_names": ["Date.getHours", "Date.getMinutes", "Date.getSeconds", "Date.getTime"], "method_name": "LocalTime.fromDateFields", "method_implementation": "{\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return new LocalTime(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000);\n}", "repo_id": "7", "comment": "/**\n * Constructs a LocalTime from a <code>java.util.Date</code>\n * using exactly the same field values.\n * <p>\n * Each field is queried from the Date and assigned to the LocalTime.\n * This is useful if you have been using the Date as a local time,\n * ignoring the zone.\n * <p>\n * One advantage of this method is that this method is unaffected if the\n * version of the time zone data differs between the JDK and Joda-Time.\n * That is because the local field values are transferred, calculated using\n * the JDK time zone data and without using the Joda-Time time zone data.\n * <p>\n * This factory method always creates a LocalTime with ISO chronology.\n *\n * @param date  the Date to extract fields from\n * @return the created LocalTime\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 1026, "method_signature": "LocalTime fromDateFields(Date)"}, "LocalTime.get": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "LocalTime.get", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    if (isSupported(fieldType) == false) {\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n    }\n    return fieldType.getField(getChronology()).get(getLocalMillis());\n}", "repo_id": "7", "comment": "/**\n * Get the value of one of the fields of time.\n * <p>\n * This method gets the value of the specified field.\n * For example:\n * <pre>\n * DateTime dt = new DateTime();\n * int hourOfDay = dt.get(DateTimeFieldType.hourOfDay());\n * </pre>\n *\n * @param fieldType  a field type, usually obtained from DateTimeFieldType, not null\n * @return the value of that field\n * @throws IllegalArgumentException if the field type is null\n */\n", "repo_name": "joda-time-main/", "id": 1030, "method_signature": "int get(DateTimeFieldType)"}, "LocalTime.getField": {"callee_method_names": ["Chronology.hourOfDay", "Chronology.minuteOfHour", "Chronology.secondOfMinute", "Chronology.millisOfSecond"], "method_name": "LocalTime.getField", "method_implementation": "{\n    switch(index) {\n        case HOUR_OF_DAY:\n            return chrono.hourOfDay();\n        case MINUTE_OF_HOUR:\n            return chrono.minuteOfHour();\n        case SECOND_OF_MINUTE:\n            return chrono.secondOfMinute();\n        case MILLIS_OF_SECOND:\n            return chrono.millisOfSecond();\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the field for a specific index in the chronology specified.\n * <p>\n * This method must not use any instance variables.\n *\n * @param index  the index to retrieve\n * @param chrono  the chronology to use\n * @return the field\n */\n", "repo_name": "joda-time-main/", "id": 1028, "method_signature": "DateTimeField getField(int, Chronology)"}, "LocalTime.getValue": {"callee_method_names": [], "method_name": "LocalTime.getValue", "method_implementation": "{\n    switch(index) {\n        case HOUR_OF_DAY:\n            return getChronology().hourOfDay().get(getLocalMillis());\n        case MINUTE_OF_HOUR:\n            return getChronology().minuteOfHour().get(getLocalMillis());\n        case SECOND_OF_MINUTE:\n            return getChronology().secondOfMinute().get(getLocalMillis());\n        case MILLIS_OF_SECOND:\n            return getChronology().millisOfSecond().get(getLocalMillis());\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the value of the field at the specified index.\n * <p>\n * This method is required to support the <code>ReadablePartial</code>\n * interface. The supported fields are HourOfDay, MinuteOfHour,\n * SecondOfMinute and MillisOfSecond.\n *\n * @param index  the index, zero to three\n * @return the value\n * @throws IndexOutOfBoundsException if the index is invalid\n */\n", "repo_name": "joda-time-main/", "id": 1029, "method_signature": "int getValue(int)"}, "LocalTime.isSupported": {"callee_method_names": ["DurationFieldType.getField", "HashSet.contains", "DurationField.getUnitMillis", "DurationField.isSupported"], "method_name": "LocalTime.isSupported", "method_implementation": "{\n    if (type == null) {\n        return false;\n    }\n    DurationField field = type.getField(getChronology());\n    if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) {\n        return field.isSupported();\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if the duration type specified is supported by this\n * local time and chronology.\n *\n * @param type  a duration type, usually obtained from DurationFieldType\n * @return true if the field type is supported\n */\n", "repo_name": "joda-time-main/", "id": 1032, "method_signature": "boolean isSupported(DurationFieldType)"}, "LocalTime.minusHours": {"callee_method_names": [], "method_name": "LocalTime.minusHours", "method_implementation": "{\n    if (hours == 0) {\n        return this;\n    }\n    long instant = getChronology().hours().subtract(getLocalMillis(), hours);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time minus the specified number of hours.\n * <p>\n * This LocalTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalTime subtracted = dt.minusHours(6);\n * LocalTime subtracted = dt.minus(Period.hours(6));\n * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.hours(), -6);\n * </pre>\n *\n * @param hours  the amount of hours to subtract, may be negative\n * @return the new LocalTime minus the increased hours\n */\n", "repo_name": "joda-time-main/", "id": 1043, "method_signature": "LocalTime minusHours(int)"}, "LocalTime.minusMillis": {"callee_method_names": [], "method_name": "LocalTime.minusMillis", "method_implementation": "{\n    if (millis == 0) {\n        return this;\n    }\n    long instant = getChronology().millis().subtract(getLocalMillis(), millis);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time minus the specified number of millis.\n * <p>\n * This LocalTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalTime subtracted = dt.minusMillis(6);\n * LocalTime subtracted = dt.minus(Period.millis(6));\n * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.millis(), -6);\n * </pre>\n *\n * @param millis  the amount of millis to subtract, may be negative\n * @return the new LocalTime minus the increased millis\n */\n", "repo_name": "joda-time-main/", "id": 1046, "method_signature": "LocalTime minusMillis(int)"}, "LocalTime.minusMinutes": {"callee_method_names": [], "method_name": "LocalTime.minusMinutes", "method_implementation": "{\n    if (minutes == 0) {\n        return this;\n    }\n    long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time minus the specified number of minutes.\n * <p>\n * This LocalTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalTime subtracted = dt.minusMinutes(6);\n * LocalTime subtracted = dt.minus(Period.minutes(6));\n * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.minutes(), -6);\n * </pre>\n *\n * @param minutes  the amount of minutes to subtract, may be negative\n * @return the new LocalTime minus the increased minutes\n */\n", "repo_name": "joda-time-main/", "id": 1044, "method_signature": "LocalTime minusMinutes(int)"}, "LocalTime.minusSeconds": {"callee_method_names": [], "method_name": "LocalTime.minusSeconds", "method_implementation": "{\n    if (seconds == 0) {\n        return this;\n    }\n    long instant = getChronology().seconds().subtract(getLocalMillis(), seconds);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time minus the specified number of seconds.\n * <p>\n * This LocalTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalTime subtracted = dt.minusSeconds(6);\n * LocalTime subtracted = dt.minus(Period.seconds(6));\n * LocalTime subtracted = dt.withFieldAdded(DurationFieldType.seconds(), -6);\n * </pre>\n *\n * @param seconds  the amount of seconds to subtract, may be negative\n * @return the new LocalTime minus the increased seconds\n */\n", "repo_name": "joda-time-main/", "id": 1045, "method_signature": "LocalTime minusSeconds(int)"}, "LocalTime.now": {"callee_method_names": [], "method_name": "LocalTime.now", "method_implementation": "{\n    if (chronology == null) {\n        throw new NullPointerException(\"Chronology must not be null\");\n    }\n    return new LocalTime(chronology);\n}", "repo_id": "7", "comment": "/**\n * Obtains a {@code LocalTime} set to the current system millisecond time\n * using the specified chronology.\n * The resulting object does not use the zone.\n *\n * @param chronology  the chronology, not null\n * @return the current time, not null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 1024, "method_signature": "LocalTime now(Chronology)"}, "LocalTime.plusHours": {"callee_method_names": [], "method_name": "LocalTime.plusHours", "method_implementation": "{\n    if (hours == 0) {\n        return this;\n    }\n    long instant = getChronology().hours().add(getLocalMillis(), hours);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time plus the specified number of hours.\n * <p>\n * This LocalTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalTime added = dt.plusHours(6);\n * LocalTime added = dt.plus(Period.hours(6));\n * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n * </pre>\n *\n * @param hours  the amount of hours to add, may be negative\n * @return the new LocalTime plus the increased hours\n */\n", "repo_name": "joda-time-main/", "id": 1039, "method_signature": "LocalTime plusHours(int)"}, "LocalTime.plusMillis": {"callee_method_names": [], "method_name": "LocalTime.plusMillis", "method_implementation": "{\n    if (millis == 0) {\n        return this;\n    }\n    long instant = getChronology().millis().add(getLocalMillis(), millis);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time plus the specified number of millis.\n * <p>\n * This LocalTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalTime added = dt.plusMillis(6);\n * LocalTime added = dt.plus(Period.millis(6));\n * LocalTime added = dt.withFieldAdded(DurationFieldType.millis(), 6);\n * </pre>\n *\n * @param millis  the amount of millis to add, may be negative\n * @return the new LocalTime plus the increased millis\n */\n", "repo_name": "joda-time-main/", "id": 1042, "method_signature": "LocalTime plusMillis(int)"}, "LocalTime.plusMinutes": {"callee_method_names": [], "method_name": "LocalTime.plusMinutes", "method_implementation": "{\n    if (minutes == 0) {\n        return this;\n    }\n    long instant = getChronology().minutes().add(getLocalMillis(), minutes);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time plus the specified number of minutes.\n * <p>\n * This LocalTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalTime added = dt.plusMinutes(6);\n * LocalTime added = dt.plus(Period.minutes(6));\n * LocalTime added = dt.withFieldAdded(DurationFieldType.minutes(), 6);\n * </pre>\n *\n * @param minutes  the amount of minutes to add, may be negative\n * @return the new LocalTime plus the increased minutes\n */\n", "repo_name": "joda-time-main/", "id": 1040, "method_signature": "LocalTime plusMinutes(int)"}, "LocalTime.plusSeconds": {"callee_method_names": [], "method_name": "LocalTime.plusSeconds", "method_implementation": "{\n    if (seconds == 0) {\n        return this;\n    }\n    long instant = getChronology().seconds().add(getLocalMillis(), seconds);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time plus the specified number of seconds.\n * <p>\n * This LocalTime instance is immutable and unaffected by this method call.\n * <p>\n * The following three lines are identical in effect:\n * <pre>\n * LocalTime added = dt.plusSeconds(6);\n * LocalTime added = dt.plus(Period.seconds(6));\n * LocalTime added = dt.withFieldAdded(DurationFieldType.seconds(), 6);\n * </pre>\n *\n * @param seconds  the amount of seconds to add, may be negative\n * @return the new LocalTime plus the increased seconds\n */\n", "repo_name": "joda-time-main/", "id": 1041, "method_signature": "LocalTime plusSeconds(int)"}, "LocalTime.property": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "LocalTime.property", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    if (isSupported(fieldType) == false) {\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n    }\n    return new Property(this, fieldType.getField(getChronology()));\n}", "repo_id": "7", "comment": "/**\n * Gets the property object for the specified type, which contains\n * many useful methods.\n *\n * @param fieldType  the field type to get the chronology for\n * @return the property object\n * @throws IllegalArgumentException if the field is null or unsupported\n */\n", "repo_name": "joda-time-main/", "id": 1047, "method_signature": "Property property(DateTimeFieldType)"}, "LocalTime.readObject": {"callee_method_ids": [70], "callee_method_names": ["ObjectInputStream.readObject", "ObjectInputStream.readObject", "DateTimeFieldType.getField", "LocalTime.getChronology"], "method_name": "LocalTime.readObject", "method_implementation": "{\n    iInstant = (LocalTime) oos.readObject();\n    DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n    iField = type.getField(iInstant.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Reads the property from a safe serialization format.\n */\n", "repo_name": "joda-time-main/", "id": 1052, "method_signature": "void readObject(ObjectInputStream)"}, "LocalTime.readResolve": {"callee_method_names": ["Chronology.getZone", "Chronology.withUTC"], "method_name": "LocalTime.readResolve", "method_implementation": "{\n    if (iChronology == null) {\n        return new LocalTime(iLocalMillis, ISOChronology.getInstanceUTC());\n    }\n    if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) {\n        return new LocalTime(iLocalMillis, iChronology.withUTC());\n    }\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Handle broken serialization from other tools.\n * @return the resolved object, not null\n */\n", "repo_name": "joda-time-main/", "id": 1027, "method_signature": "Object readResolve()"}, "LocalTime.toDateTimeToday": {"callee_method_names": ["Chronology.set"], "method_name": "LocalTime.toDateTimeToday", "method_implementation": "{\n    Chronology chrono = getChronology().withZone(zone);\n    long instantMillis = DateTimeUtils.currentTimeMillis();\n    long resolved = chrono.set(this, instantMillis);\n    return new DateTime(resolved, chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this LocalTime to a full datetime using the specified time zone\n * setting the time fields from this instance and the date fields from\n * the current time.\n * <p>\n * This method uses the chronology from this instance plus the time zone\n * specified.\n *\n * @param zone  the zone to use, null means default\n * @return this time as a datetime using today's date\n */\n", "repo_name": "joda-time-main/", "id": 1048, "method_signature": "DateTime toDateTimeToday(DateTimeZone)"}, "LocalTime.toString": {"callee_method_names": [], "method_name": "LocalTime.toString", "method_implementation": "{\n    if (pattern == null) {\n        return toString();\n    }\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n}", "repo_id": "7", "comment": "/**\n * Output the time using the specified format pattern.\n *\n * @param pattern  the pattern specification, null means use <code>toString</code>\n * @param locale  Locale to use, null means default\n * @return the formatted output, not null\n * @throws IllegalArgumentException if the pattern is invalid\n * @see org.joda.time.format.DateTimeFormat\n */\n", "repo_name": "joda-time-main/", "id": 1051, "method_signature": "String toString(String, Locale)"}, "LocalTime.withField": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "LocalTime.withField", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (isSupported(fieldType) == false) {\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n    }\n    long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the specified field set\n * to a new value.\n * <p>\n * For example, if the field type is <code>hourOfDay</code> then the hour of day\n * field would be changed in the returned instance.\n * If the field type is null, then <code>this</code> is returned.\n * <p>\n * These lines are equivalent:\n * <pre>\n * LocalTime updated = dt.withHourOfDay(6);\n * LocalTime updated = dt.withField(DateTimeFieldType.hourOfDay(), 6);\n * </pre>\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this time with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 1036, "method_signature": "LocalTime withField(DateTimeFieldType, int)"}, "LocalTime.withFieldAdded": {"callee_method_names": ["DurationFieldType.getField"], "method_name": "LocalTime.withFieldAdded", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (isSupported(fieldType) == false) {\n        throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n    }\n    if (amount == 0) {\n        return this;\n    }\n    long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the value of the specified\n * field increased.\n * <p>\n * If the addition is zero or the field is null, then <code>this</code>\n * is returned.\n * <p>\n * If the addition causes the maximum value of the field to be exceeded,\n * then the value will wrap. Thus 23:59 plus two minutes yields 00:01.\n * <p>\n * These lines are equivalent:\n * <pre>\n * LocalTime added = dt.plusHours(6);\n * LocalTime added = dt.withFieldAdded(DurationFieldType.hours(), 6);\n * </pre>\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this time with the field updated\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the result exceeds the internal capacity\n */\n", "repo_name": "joda-time-main/", "id": 1037, "method_signature": "LocalTime withFieldAdded(DurationFieldType, int)"}, "LocalTime.withFields": {"callee_method_names": [], "method_name": "LocalTime.withFields", "method_implementation": "{\n    if (partial == null) {\n        return this;\n    }\n    return withLocalMillis(getChronology().set(partial, getLocalMillis()));\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the partial set of fields replacing\n * those from this instance.\n * <p>\n * For example, if the partial contains an hour and minute then those two\n * fields will be changed in the returned instance.\n * Unsupported fields are ignored.\n * If the partial is null, then <code>this</code> is returned.\n *\n * @param partial  the partial set of fields to apply to this time, null ignored\n * @return a copy of this time with a different set of fields\n * @throws IllegalArgumentException if any value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 1035, "method_signature": "LocalTime withFields(ReadablePartial)"}, "LocalTime.withPeriodAdded": {"callee_method_names": [], "method_name": "LocalTime.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    long instant = getChronology().add(period, getLocalMillis(), scalar);\n    return withLocalMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the specified period added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using methods\n * like {@link #withFieldAdded(DurationFieldType, int)}\n * or {@link #plusHours(int)}.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this time with the period added\n * @throws ArithmeticException if the result exceeds the internal capacity\n */\n", "repo_name": "joda-time-main/", "id": 1038, "method_signature": "LocalTime withPeriodAdded(ReadablePeriod, int)"}, "MainTest.main": {"callee_method_names": ["String[].startsWith", "String[].startsWith"], "method_name": "MainTest.main", "method_implementation": "{\n    int iterations = 1000000;\n    int mode = GREGORIAN_MODE;\n    long seed = 1345435247779935L;\n    if (args.length > 0) {\n        iterations = Integer.parseInt(args[0]);\n        if (args.length > 1) {\n            if (args[1].startsWith(\"g\")) {\n                mode = GREGORIAN_MODE;\n            } else if (args[1].startsWith(\"j\")) {\n                mode = JULIAN_MODE;\n            } else {\n                throw new IllegalArgumentException(\"Unknown mode: \" + args[1]);\n            }\n            if (args.length > 2) {\n                seed = Long.parseLong(args[2]);\n            }\n        }\n    }\n    new MainTest(iterations, mode, seed).testChronology();\n}", "repo_id": "7", "comment": "/**\n * Arguments: iterations [mode [seed]]\n */\n", "repo_name": "joda-time-main/", "id": 1981, "method_signature": "void main(String[])"}, "MainTest.randomMillis": {"callee_method_names": ["Random.nextLong"], "method_name": "MainTest.randomMillis", "method_implementation": "{\n    long millis = rnd.nextLong();\n    if (millis >= 0) {\n        millis = millis % MAX_MILLIS;\n    } else {\n        millis = millis % -MIN_MILLIS;\n    }\n    return millis;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1984, "method_signature": "long randomMillis(Random)"}, "MainTest.testChronology": {"callee_method_names": ["Random.nextInt", "Random.nextLong", "ActionEvent.getMessage"], "method_name": "MainTest.testChronology", "method_implementation": "{\n    int iterations = iIterations;\n    long seed = iSeed;\n    String modeStr;\n    if (iMode == GREGORIAN_MODE) {\n        modeStr = \"Gregorian\";\n    } else {\n        modeStr = \"Julian\";\n    }\n    System.out.println(\"\\nTesting \" + modeStr + \" chronology over \" + iterations + \" iterations\");\n    Random rnd = new Random(seed);\n    long updateMillis = System.currentTimeMillis() + UPDATE_INTERVAL;\n    for (int i = 0; i < iterations; i++) {\n        long now = System.currentTimeMillis();\n        if (now >= updateMillis) {\n            updateMillis = now + UPDATE_INTERVAL;\n            double complete = ((int) ((double) i / iterations * 1000.0)) / 10d;\n            if (complete < 100) {\n                System.out.println(\"\" + complete + \"% complete (i=\" + i + \")\");\n            }\n        }\n        long millis = randomMillis(rnd);\n        int value = rnd.nextInt(200) - 100;\n        // millis2 is used for difference tests.\n        long millis2 = millis + rnd.nextLong() % _1000_YEARS - _500_YEARS;\n        try {\n            testFields(millis, value, millis2);\n        } catch (RuntimeException e) {\n            System.out.println(\"Failure index: \" + i);\n            System.out.println(\"Test millis: \" + millis);\n            System.out.println(\"Test value: \" + value);\n            System.out.println(\"Test millis2: \" + millis2);\n            fail(e.getMessage());\n        }\n    }\n    System.out.println(\"100% complete (i=\" + iterations + \")\");\n}", "repo_id": "7", "comment": "/**\n * Main junit test\n */\n", "repo_name": "joda-time-main/", "id": 1982, "method_signature": "void testChronology()"}, "MainTest.testFields": {"callee_method_names": ["Chronology.year", "Chronology.year", "Chronology.monthOfYear", "Chronology.monthOfYear", "Chronology.dayOfMonth", "Chronology.dayOfMonth", "Chronology.weekyear", "Chronology.weekyear", "Chronology.weekOfWeekyear", "Chronology.weekOfWeekyear", "Chronology.dayOfWeek", "Chronology.dayOfWeek", "Chronology.dayOfYear", "Chronology.dayOfYear"], "method_name": "MainTest.testFields", "method_implementation": "{\n    testField(iTest.year(), iActual.year(), millis, value, millis2);\n    testField(iTest.monthOfYear(), iActual.monthOfYear(), millis, value, millis2);\n    testField(iTest.dayOfMonth(), iActual.dayOfMonth(), millis, value, millis2);\n    testField(iTest.weekyear(), iActual.weekyear(), millis, value, millis2);\n    testField(iTest.weekOfWeekyear(), iActual.weekOfWeekyear(), millis, value, millis2);\n    testField(iTest.dayOfWeek(), iActual.dayOfWeek(), millis, value, millis2);\n    testField(iTest.dayOfYear(), iActual.dayOfYear(), millis, value, millis2);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1983, "method_signature": "void testFields(long, int, long)"}, "MillisDurationField.compareTo": {"callee_method_names": ["DurationField.getUnitMillis"], "method_name": "MillisDurationField.compareTo", "method_implementation": "{\n    long otherMillis = otherField.getUnitMillis();\n    long thisMillis = getUnitMillis();\n    // cannot do (thisMillis - otherMillis) as can overflow\n    if (thisMillis == otherMillis) {\n        return 0;\n    }\n    if (thisMillis < otherMillis) {\n        return -1;\n    } else {\n        return 1;\n    }\n}", "repo_id": "7", "comment": "//------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 51, "method_signature": "int compareTo(DurationField)"}, "Minutes.dividedBy": {"callee_method_names": [], "method_name": "Minutes.dividedBy", "method_implementation": "{\n    if (divisor == 1) {\n        return this;\n    }\n    return Minutes.minutes(getValue() / divisor);\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the minutes divided by the specified divisor.\n * The calculation uses integer division, thus 3 divided by 2 is 1.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param divisor  the amount to divide by, may be negative\n * @return the new period divided by the specified divisor\n * @throws ArithmeticException if the divisor is zero\n */\n", "repo_name": "joda-time-main/", "id": 157, "method_signature": "Minutes dividedBy(int)"}, "Minutes.isGreaterThan": {"callee_method_names": ["Minutes.getValue"], "method_name": "Minutes.isGreaterThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() > 0;\n    }\n    return getValue() > other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this minutes instance greater than the specified number of minutes.\n *\n * @param other  the other period, null means zero\n * @return true if this minutes instance is greater than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 158, "method_signature": "boolean isGreaterThan(Minutes)"}, "Minutes.isLessThan": {"callee_method_names": ["Minutes.getValue"], "method_name": "Minutes.isLessThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() < 0;\n    }\n    return getValue() < other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this minutes instance less than the specified number of minutes.\n *\n * @param other  the other period, null means zero\n * @return true if this minutes instance is less than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 159, "method_signature": "boolean isLessThan(Minutes)"}, "Minutes.minus": {"callee_method_names": ["Minutes.getValue"], "method_name": "Minutes.minus", "method_implementation": "{\n    if (minutes == null) {\n        return this;\n    }\n    return minus(minutes.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of minutes taken away.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param minutes  the amount of minutes to take away, may be negative, null means zero\n * @return the new period minus the specified number of minutes\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 156, "method_signature": "Minutes minus(Minutes)"}, "Minutes.minutes": {"callee_method_names": [], "method_name": "Minutes.minutes", "method_implementation": "{\n    switch(minutes) {\n        case 0:\n            return ZERO;\n        case 1:\n            return ONE;\n        case 2:\n            return TWO;\n        case 3:\n            return THREE;\n        case Integer.MAX_VALUE:\n            return MAX_VALUE;\n        case Integer.MIN_VALUE:\n            return MIN_VALUE;\n        default:\n            return new Minutes(minutes);\n    }\n}", "repo_id": "7", "comment": "/**\n * Obtains an instance of <code>Minutes</code> that may be cached.\n * <code>Minutes</code> is immutable, so instances can be cached and shared.\n * This factory method provides access to shared instances.\n *\n * @param minutes  the number of minutes to obtain an instance for\n * @return the instance of Minutes\n */\n", "repo_name": "joda-time-main/", "id": 150, "method_signature": "Minutes minutes(int)"}, "Minutes.minutesBetween": {"callee_method_names": ["ReadablePartial.getChronology", "Chronology.minutes"], "method_name": "Minutes.minutesBetween", "method_implementation": "{\n    if (start instanceof LocalTime && end instanceof LocalTime) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int minutes = chrono.minutes().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n        return Minutes.minutes(minutes);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return Minutes.minutes(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Minutes</code> representing the number of whole minutes\n * between the two specified partial datetimes.\n * <p>\n * The two partials must contain the same fields, for example you can specify\n * two <code>LocalTime</code> objects.\n *\n * @param start  the start partial date, must not be null\n * @param end  the end partial date, must not be null\n * @return the period in minutes\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 151, "method_signature": "Minutes minutesBetween(ReadablePartial, ReadablePartial)"}, "Minutes.minutesIn": {"callee_method_names": ["ReadableInterval.getStart", "ReadableInterval.getEnd"], "method_name": "Minutes.minutesIn", "method_implementation": "{\n    if (interval == null) {\n        return Minutes.ZERO;\n    }\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.minutes());\n    return Minutes.minutes(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Minutes</code> representing the number of whole minutes\n * in the specified interval.\n *\n * @param interval  the interval to extract minutes from, null returns zero\n * @return the period in minutes\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 152, "method_signature": "Minutes minutesIn(ReadableInterval)"}, "Minutes.parseMinutes": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod", "Period.getMinutes"], "method_name": "Minutes.parseMinutes", "method_implementation": "{\n    if (periodStr == null) {\n        return Minutes.ZERO;\n    }\n    Period p = PARSER.parsePeriod(periodStr);\n    return Minutes.minutes(p.getMinutes());\n}", "repo_id": "7", "comment": "/**\n * Creates a new <code>Minutes</code> by parsing a string in the ISO8601 format 'PTnM'.\n * <p>\n * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n * minutes component may be non-zero. If any other component is non-zero, an exception\n * will be thrown.\n *\n * @param periodStr  the period string, null returns zero\n * @return the period in minutes\n * @throws IllegalArgumentException if the string format is invalid\n */\n", "repo_name": "joda-time-main/", "id": 153, "method_signature": "Minutes parseMinutes(String)"}, "Minutes.plus": {"callee_method_names": ["Minutes.getValue"], "method_name": "Minutes.plus", "method_implementation": "{\n    if (minutes == null) {\n        return this;\n    }\n    return plus(minutes.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of minutes added.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param minutes  the amount of minutes to add, may be negative, null means zero\n * @return the new period plus the specified number of minutes\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 155, "method_signature": "Minutes plus(Minutes)"}, "Minutes.toString": {"callee_method_names": [], "method_name": "Minutes.toString", "method_implementation": "{\n    return \"PT\" + String.valueOf(getValue()) + \"M\";\n}", "repo_id": "7", "comment": "/**\n * Gets this instance as a String in the ISO8601 duration format.\n * <p>\n * For example, \"PT4M\" represents 4 minutes.\n *\n * @return the value as an ISO8601 string\n */\n", "repo_name": "joda-time-main/", "id": 160, "method_signature": "String toString()"}, "MonthDay.addToCopy": {"callee_method_names": ["MonthDay.getValues"], "method_name": "MonthDay.addToCopy", "method_implementation": "{\n    int[] newValues = iBase.getValues();\n    newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);\n    return new MonthDay(iBase, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this MonthDay.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it will affect larger fields.\n * Smaller fields are unaffected.\n * <p>\n * The MonthDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the MonthDay with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 176, "method_signature": "MonthDay addToCopy(int)"}, "MonthDay.addWrapFieldToCopy": {"callee_method_names": ["MonthDay.getValues"], "method_name": "MonthDay.addWrapFieldToCopy", "method_implementation": "{\n    int[] newValues = iBase.getValues();\n    newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n    return new MonthDay(iBase, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this MonthDay wrapping\n * within this field if the maximum value is reached.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it wraps within this field.\n * Other fields are unaffected.\n * <p>\n * For example,\n * <code>--12-30</code> addWrapField one month returns <code>--01-30</code>.\n * <p>\n * The MonthDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the MonthDay with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 177, "method_signature": "MonthDay addWrapFieldToCopy(int)"}, "MonthDay.fromCalendarFields": {"callee_method_names": ["Calendar.get", "Calendar.get"], "method_name": "MonthDay.fromCalendarFields", "method_implementation": "{\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    return new MonthDay(calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\n}", "repo_id": "7", "comment": "/**\n * Constructs a MonthDay from a <code>java.util.Calendar</code>\n * using exactly the same field values avoiding any time zone effects.\n * <p>\n * Each field is queried from the Calendar and assigned to the MonthDay.\n * <p>\n * This factory method ignores the type of the calendar and always\n * creates a MonthDay with ISO chronology. It is expected that you\n * will only pass in instances of <code>GregorianCalendar</code> however\n * this is not validated.\n *\n * @param calendar  the Calendar to extract fields from\n * @return the created MonthDay, never null\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 163, "method_signature": "MonthDay fromCalendarFields(Calendar)"}, "MonthDay.fromDateFields": {"callee_method_names": ["Date.getMonth", "Date.getDate"], "method_name": "MonthDay.fromDateFields", "method_implementation": "{\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return new MonthDay(date.getMonth() + 1, date.getDate());\n}", "repo_id": "7", "comment": "/**\n * Constructs a MonthDay from a <code>java.util.Date</code>\n * using exactly the same field values avoiding any time zone effects.\n * <p>\n * Each field is queried from the Date and assigned to the MonthDay.\n * <p>\n * This factory method always creates a MonthDay with ISO chronology.\n *\n * @param date  the Date to extract fields from\n * @return the created MonthDay, never null\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the monthOfYear or dayOfMonth is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 164, "method_signature": "MonthDay fromDateFields(Date)"}, "MonthDay.getField": {"callee_method_names": ["Chronology.monthOfYear", "Chronology.dayOfMonth"], "method_name": "MonthDay.getField", "method_implementation": "{\n    switch(index) {\n        case MONTH_OF_YEAR:\n            return chrono.monthOfYear();\n        case DAY_OF_MONTH:\n            return chrono.dayOfMonth();\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the field for a specific index in the chronology specified.\n * <p>\n * This method must not use any instance variables.\n *\n * @param index  the index to retrieve\n * @param chrono  the chronology to use\n * @return the field, never null\n */\n", "repo_name": "joda-time-main/", "id": 166, "method_signature": "DateTimeField getField(int, Chronology)"}, "MonthDay.now": {"callee_method_names": [], "method_name": "MonthDay.now", "method_implementation": "{\n    if (chronology == null) {\n        throw new NullPointerException(\"Chronology must not be null\");\n    }\n    return new MonthDay(chronology);\n}", "repo_id": "7", "comment": "/**\n * Obtains a {@code MonthDay} set to the current system millisecond time\n * using the specified chronology.\n * The resulting object does not use the zone.\n *\n * @param chronology  the chronology, not null\n * @return the current month-day, not null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 162, "method_signature": "MonthDay now(Chronology)"}, "MonthDay.readResolve": {"callee_method_names": [], "method_name": "MonthDay.readResolve", "method_implementation": "{\n    if (DateTimeZone.UTC.equals(getChronology().getZone()) == false) {\n        return new MonthDay(this, getChronology().withUTC());\n    }\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Handle broken serialization from other tools.\n * @return the resolved object, not null\n */\n", "repo_name": "joda-time-main/", "id": 165, "method_signature": "Object readResolve()"}, "MonthDay.setCopy": {"callee_method_names": ["MonthDay.getValues"], "method_name": "MonthDay.setCopy", "method_implementation": "{\n    int[] newValues = iBase.getValues();\n    newValues = getField().set(iBase, iFieldIndex, newValues, text, locale);\n    return new MonthDay(iBase, newValues);\n}", "repo_id": "7", "comment": "/**\n * Sets this field in a copy of the MonthDay to a parsed text value.\n * <p>\n * The MonthDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param text  the text value to set\n * @param locale  optional locale to use for selecting a text symbol\n * @return a copy of the MonthDay with the field value changed\n * @throws IllegalArgumentException if the text value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 179, "method_signature": "MonthDay setCopy(String, Locale)"}, "MonthDay.toString": {"callee_method_names": [], "method_name": "MonthDay.toString", "method_implementation": "{\n    if (pattern == null) {\n        return toString();\n    }\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n}", "repo_id": "7", "comment": "/**\n * Output the month-day using the specified format pattern.\n *\n * @param pattern  the pattern specification, null means use <code>toString</code>\n * @param locale  Locale to use, null means default\n * @see org.joda.time.format.DateTimeFormat\n */\n", "repo_name": "joda-time-main/", "id": 175, "method_signature": "String toString(String, Locale)"}, "MonthDay.withChronologyRetainFields": {"callee_method_names": ["Chronology.withUTC", "Chronology.validate"], "method_name": "MonthDay.withChronologyRetainFields", "method_implementation": "{\n    newChronology = DateTimeUtils.getChronology(newChronology);\n    newChronology = newChronology.withUTC();\n    if (newChronology == getChronology()) {\n        return this;\n    } else {\n        MonthDay newMonthDay = new MonthDay(this, newChronology);\n        newChronology.validate(newMonthDay, getValues());\n        return newMonthDay;\n    }\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this month-day with the specified chronology.\n * This instance is immutable and unaffected by this method call.\n * <p>\n * This method retains the values of the fields, thus the result will\n * typically refer to a different instant.\n * <p>\n * The time zone of the specified chronology is ignored, as MonthDay\n * operates without a time zone.\n *\n * @param newChronology  the new chronology, null means ISO\n * @return a copy of this month-day with a different chronology, never null\n * @throws IllegalArgumentException if the values are invalid for the new chronology\n */\n", "repo_name": "joda-time-main/", "id": 167, "method_signature": "MonthDay withChronologyRetainFields(Chronology)"}, "MonthDay.withDayOfMonth": {"callee_method_names": [], "method_name": "MonthDay.withDayOfMonth", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\n    return new MonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this month-day with the day of month field updated.\n * <p>\n * MonthDay is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * day of month changed.\n *\n * @param dayOfMonth  the day of month to set\n * @return a copy of this object with the field set, never null\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 172, "method_signature": "MonthDay withDayOfMonth(int)"}, "MonthDay.withField": {"callee_method_names": [], "method_name": "MonthDay.withField", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new MonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this month-day with the specified field set to a new value.\n * <p>\n * For example, if the field type is <code>dayOfMonth</code> then the day\n * would be changed in the returned instance.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * MonthDay updated = md.withField(DateTimeFieldType.dayOfMonth(), 6);\n * MonthDay updated = md.dayOfMonth().setCopy(6);\n * MonthDay updated = md.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this instance with the field set, never null\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 168, "method_signature": "MonthDay withField(DateTimeFieldType, int)"}, "MonthDay.withFieldAdded": {"callee_method_names": [], "method_name": "MonthDay.withFieldAdded", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (amount == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).add(this, index, newValues, amount);\n    return new MonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this month-day with the value of the specified field increased.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * MonthDay added = md.withFieldAdded(DurationFieldType.days(), 6);\n * MonthDay added = md.plusDays(6);\n * MonthDay added = md.dayOfMonth().addToCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this instance with the field updated, never null\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the new date-time exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 169, "method_signature": "MonthDay withFieldAdded(DurationFieldType, int)"}, "MonthDay.withMonthOfYear": {"callee_method_names": [], "method_name": "MonthDay.withMonthOfYear", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n    return new MonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this month-day with the month of year field updated.\n * <p>\n * MonthDay is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * month of year changed.\n *\n * @param monthOfYear  the month of year to set\n * @return a copy of this object with the field set, never null\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 171, "method_signature": "MonthDay withMonthOfYear(int)"}, "MonthDay.withPeriodAdded": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getFieldType", "ReadablePeriod.getValue"], "method_name": "MonthDay.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    for (int i = 0; i < period.size(); i++) {\n        DurationFieldType fieldType = period.getFieldType(i);\n        int index = indexOf(fieldType);\n        if (index >= 0) {\n            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\n        }\n    }\n    return new MonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this month-day with the specified period added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * Fields in the period that aren't present in the partial are ignored.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using methods\n * like {@link #withFieldAdded(DurationFieldType, int)}\n * or {@link #plusMonths(int)}.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this instance with the period added, never null\n * @throws ArithmeticException if the new date-time exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 170, "method_signature": "MonthDay withPeriodAdded(ReadablePeriod, int)"}, "Months.dividedBy": {"callee_method_names": [], "method_name": "Months.dividedBy", "method_implementation": "{\n    if (divisor == 1) {\n        return this;\n    }\n    return Months.months(getValue() / divisor);\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the months divided by the specified divisor.\n * The calculation uses integer division, thus 3 divided by 2 is 1.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param divisor  the amount to divide by, may be negative\n * @return the new period divided by the specified divisor\n * @throws ArithmeticException if the divisor is zero\n */\n", "repo_name": "joda-time-main/", "id": 554, "method_signature": "Months dividedBy(int)"}, "Months.isGreaterThan": {"callee_method_names": ["Months.getValue"], "method_name": "Months.isGreaterThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() > 0;\n    }\n    return getValue() > other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this months instance greater than the specified number of months.\n *\n * @param other  the other period, null means zero\n * @return true if this months instance is greater than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 555, "method_signature": "boolean isGreaterThan(Months)"}, "Months.isLessThan": {"callee_method_names": ["Months.getValue"], "method_name": "Months.isLessThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() < 0;\n    }\n    return getValue() < other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this months instance less than the specified number of months.\n *\n * @param other  the other period, null means zero\n * @return true if this months instance is less than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 556, "method_signature": "boolean isLessThan(Months)"}, "Months.minus": {"callee_method_names": ["Months.getValue"], "method_name": "Months.minus", "method_implementation": "{\n    if (months == null) {\n        return this;\n    }\n    return minus(months.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of months taken away.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param months  the amount of months to take away, may be negative, null means zero\n * @return the new period minus the specified number of months\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 553, "method_signature": "Months minus(Months)"}, "Months.months": {"callee_method_names": [], "method_name": "Months.months", "method_implementation": "{\n    switch(months) {\n        case 0:\n            return ZERO;\n        case 1:\n            return ONE;\n        case 2:\n            return TWO;\n        case 3:\n            return THREE;\n        case 4:\n            return FOUR;\n        case 5:\n            return FIVE;\n        case 6:\n            return SIX;\n        case 7:\n            return SEVEN;\n        case 8:\n            return EIGHT;\n        case 9:\n            return NINE;\n        case 10:\n            return TEN;\n        case 11:\n            return ELEVEN;\n        case 12:\n            return TWELVE;\n        case Integer.MAX_VALUE:\n            return MAX_VALUE;\n        case Integer.MIN_VALUE:\n            return MIN_VALUE;\n        default:\n            return new Months(months);\n    }\n}", "repo_id": "7", "comment": "/**\n * Obtains an instance of <code>Months</code> that may be cached.\n * <code>Months</code> is immutable, so instances can be cached and shared.\n * This factory method provides access to shared instances.\n *\n * @param months  the number of months to obtain an instance for\n * @return the instance of Months\n */\n", "repo_name": "joda-time-main/", "id": 547, "method_signature": "Months months(int)"}, "Months.monthsBetween": {"callee_method_names": ["ReadablePartial.getChronology", "Chronology.months"], "method_name": "Months.monthsBetween", "method_implementation": "{\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int months = chrono.months().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return Months.months(months);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return Months.months(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Months</code> representing the number of whole months\n * between the two specified partial datetimes.\n * <p>\n * The two partials must contain the same fields, for example you can specify\n * two <code>LocalDate</code> objects.\n * <p>\n * This method calculates by adding months to the start date until the result\n * is past the end date. As such, a period from the end of a \"long\" month to\n * the end of a \"short\" month is counted as a whole month.\n *\n * @param start  the start partial date, must not be null\n * @param end  the end partial date, must not be null\n * @return the period in months\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 548, "method_signature": "Months monthsBetween(ReadablePartial, ReadablePartial)"}, "Months.monthsIn": {"callee_method_names": ["ReadableInterval.getStart", "ReadableInterval.getEnd"], "method_name": "Months.monthsIn", "method_implementation": "{\n    if (interval == null) {\n        return Months.ZERO;\n    }\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.months());\n    return Months.months(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Months</code> representing the number of whole months\n * in the specified interval. This method correctly handles any daylight\n * savings time changes that may occur during the interval.\n *\n * @param interval  the interval to extract months from, null returns zero\n * @return the period in months\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 549, "method_signature": "Months monthsIn(ReadableInterval)"}, "Months.parseMonths": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod", "Period.getMonths"], "method_name": "Months.parseMonths", "method_implementation": "{\n    if (periodStr == null) {\n        return Months.ZERO;\n    }\n    Period p = PARSER.parsePeriod(periodStr);\n    return Months.months(p.getMonths());\n}", "repo_id": "7", "comment": "/**\n * Creates a new <code>Months</code> by parsing a string in the ISO8601 format 'PnM'.\n * <p>\n * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n * months component may be non-zero. If any other component is non-zero, an exception\n * will be thrown.\n *\n * @param periodStr  the period string, null returns zero\n * @return the period in months\n * @throws IllegalArgumentException if the string format is invalid\n */\n", "repo_name": "joda-time-main/", "id": 550, "method_signature": "Months parseMonths(String)"}, "Months.plus": {"callee_method_names": ["Months.getValue"], "method_name": "Months.plus", "method_implementation": "{\n    if (months == null) {\n        return this;\n    }\n    return plus(months.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of months added.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param months  the amount of months to add, may be negative, null means zero\n * @return the new period plus the specified number of months\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 552, "method_signature": "Months plus(Months)"}, "Months.toString": {"callee_method_names": [], "method_name": "Months.toString", "method_implementation": "{\n    return \"P\" + String.valueOf(getValue()) + \"M\";\n}", "repo_id": "7", "comment": "/**\n * Gets this instance as a String in the ISO8601 duration format.\n * <p>\n * For example, \"P4M\" represents 4 months.\n *\n * @return the value as an ISO8601 string\n */\n", "repo_name": "joda-time-main/", "id": 557, "method_signature": "String toString()"}, "MutableDateTime.add": {"callee_method_names": ["DurationFieldType.getField"], "method_name": "MutableDateTime.add", "method_implementation": "{\n    if (type == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (amount != 0) {\n        setMillis(type.getField(getChronology()).add(getMillis(), amount));\n    }\n}", "repo_id": "7", "comment": "/**\n * Adds to the instant specifying the duration and multiple to add.\n *\n * @param type  a field type, usually obtained from DateTimeFieldType, not null\n * @param amount  the amount to add of this duration\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the result exceeds the capacity of the instant\n */\n", "repo_name": "joda-time-main/", "id": 665, "method_signature": "void add(DurationFieldType, int)"}, "MutableDateTime.addDays": {"callee_method_names": [], "method_name": "MutableDateTime.addDays", "method_implementation": "{\n    if (days != 0) {\n        setMillis(getChronology().days().add(getMillis(), days));\n    }\n}", "repo_id": "7", "comment": "/**\n * Add a number of days to the date.\n *\n * @param days  the days to add\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 670, "method_signature": "void addDays(int)"}, "MutableDateTime.addHours": {"callee_method_names": [], "method_name": "MutableDateTime.addHours", "method_implementation": "{\n    if (hours != 0) {\n        setMillis(getChronology().hours().add(getMillis(), hours));\n    }\n}", "repo_id": "7", "comment": "/**\n * Add a number of hours to the date.\n *\n * @param hours  the hours to add\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 671, "method_signature": "void addHours(int)"}, "MutableDateTime.addMillis": {"callee_method_names": [], "method_name": "MutableDateTime.addMillis", "method_implementation": "{\n    if (millis != 0) {\n        setMillis(getChronology().millis().add(getMillis(), millis));\n    }\n}", "repo_id": "7", "comment": "/**\n * Add a number of milliseconds to the date. The implementation of this\n * method differs from the {@link #add(long)} method in that a\n * DateTimeField performs the addition.\n *\n * @param millis  the milliseconds to add\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 674, "method_signature": "void addMillis(int)"}, "MutableDateTime.addMinutes": {"callee_method_names": [], "method_name": "MutableDateTime.addMinutes", "method_implementation": "{\n    if (minutes != 0) {\n        setMillis(getChronology().minutes().add(getMillis(), minutes));\n    }\n}", "repo_id": "7", "comment": "/**\n * Add a number of minutes to the date.\n *\n * @param minutes  the minutes to add\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 672, "method_signature": "void addMinutes(int)"}, "MutableDateTime.addMonths": {"callee_method_names": [], "method_name": "MutableDateTime.addMonths", "method_implementation": "{\n    if (months != 0) {\n        setMillis(getChronology().months().add(getMillis(), months));\n    }\n}", "repo_id": "7", "comment": "/**\n * Add a number of months to the date.\n *\n * @param months  the months to add\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 668, "method_signature": "void addMonths(int)"}, "MutableDateTime.addSeconds": {"callee_method_names": [], "method_name": "MutableDateTime.addSeconds", "method_implementation": "{\n    if (seconds != 0) {\n        setMillis(getChronology().seconds().add(getMillis(), seconds));\n    }\n}", "repo_id": "7", "comment": "/**\n * Add a number of seconds to the date.\n *\n * @param seconds  the seconds to add\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 673, "method_signature": "void addSeconds(int)"}, "MutableDateTime.addWeeks": {"callee_method_names": [], "method_name": "MutableDateTime.addWeeks", "method_implementation": "{\n    if (weeks != 0) {\n        setMillis(getChronology().weeks().add(getMillis(), weeks));\n    }\n}", "repo_id": "7", "comment": "/**\n * Add a number of weeks to the date.\n *\n * @param weeks  the weeks to add\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 669, "method_signature": "void addWeeks(int)"}, "MutableDateTime.addWeekyears": {"callee_method_names": [], "method_name": "MutableDateTime.addWeekyears", "method_implementation": "{\n    if (weekyears != 0) {\n        setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n    }\n}", "repo_id": "7", "comment": "/**\n * Add a number of weekyears to the date.\n *\n * @param weekyears  the weekyears to add\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 667, "method_signature": "void addWeekyears(int)"}, "MutableDateTime.addYears": {"callee_method_names": [], "method_name": "MutableDateTime.addYears", "method_implementation": "{\n    if (years != 0) {\n        setMillis(getChronology().years().add(getMillis(), years));\n    }\n}", "repo_id": "7", "comment": "/**\n * Add a number of years to the date.\n *\n * @param years  the years to add\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 666, "method_signature": "void addYears(int)"}, "MutableDateTime.clone": {"callee_method_names": [], "method_name": "MutableDateTime.clone", "method_implementation": "{\n    try {\n        return super.clone();\n    } catch (CloneNotSupportedException ex) {\n        throw new InternalError(\"Clone error\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Clone this object.\n *\n * @return a clone of this object.\n */\n", "repo_name": "joda-time-main/", "id": 681, "method_signature": "Object clone()"}, "MutableDateTime.now": {"callee_method_names": [], "method_name": "MutableDateTime.now", "method_implementation": "{\n    if (chronology == null) {\n        throw new NullPointerException(\"Chronology must not be null\");\n    }\n    return new MutableDateTime(chronology);\n}", "repo_id": "7", "comment": "/**\n * Obtains a {@code MutableDateTime} set to the current system millisecond time\n * using the specified chronology.\n *\n * @param chronology  the chronology, not null\n * @return the current date-time, not null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 657, "method_signature": "MutableDateTime now(Chronology)"}, "MutableDateTime.property": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField", "DateTimeField.isSupported"], "method_name": "MutableDateTime.property", "method_implementation": "{\n    if (type == null) {\n        throw new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n    }\n    DateTimeField field = type.getField(getChronology());\n    if (field.isSupported() == false) {\n        throw new IllegalArgumentException(\"Field '\" + type + \"' is not supported\");\n    }\n    return new Property(this, field);\n}", "repo_id": "7", "comment": "/**\n * Gets the property object for the specified type, which contains many useful methods.\n *\n * @param type  the field type to get the chronology for\n * @return the property object\n * @throws IllegalArgumentException if the field is null or unsupported\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 680, "method_signature": "Property property(DateTimeFieldType)"}, "MutableDateTime.readObject": {"callee_method_ids": [70], "callee_method_names": ["ObjectInputStream.readObject", "ObjectInputStream.readObject", "DateTimeFieldType.getField", "MutableDateTime.getChronology"], "method_name": "MutableDateTime.readObject", "method_implementation": "{\n    iInstant = (MutableDateTime) oos.readObject();\n    DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n    iField = type.getField(iInstant.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Reads the property from a safe serialization format.\n */\n", "repo_name": "joda-time-main/", "id": 682, "method_signature": "void readObject(ObjectInputStream)"}, "MutableDateTime.set": {"callee_method_ids": [70], "callee_method_names": ["DateTimeFieldType.getField"], "method_name": "MutableDateTime.set", "method_implementation": "{\n    if (type == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    setMillis(type.getField(getChronology()).set(getMillis(), value));\n}", "repo_id": "7", "comment": "/**\n * Sets the value of one of the fields of the instant, such as hourOfDay.\n *\n * @param type  a field type, usually obtained from DateTimeFieldType, not null\n * @param value  the value to set the field to\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 664, "method_signature": "void set(DateTimeFieldType, int)"}, "MutableDateTime.setDate": {"callee_method_names": ["Chronology.getDateTimeMillis"], "method_name": "MutableDateTime.setDate", "method_implementation": "{\n    Chronology c = getChronology();\n    long instantMidnight = c.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\n    setDate(instantMidnight);\n}", "repo_id": "7", "comment": "/**\n * Set the date from fields.\n * The time part of this object will be unaffected.\n *\n * @param year  the year\n * @param monthOfYear  the month of the year\n * @param dayOfMonth  the day of the month\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 676, "method_signature": "void setDate(int, int, int)"}, "MutableDateTime.setDateTime": {"callee_method_names": [], "method_name": "MutableDateTime.setDateTime", "method_implementation": "{\n    long instant = getChronology().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    setMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Set the date and time from fields.\n *\n * @param year  the year\n * @param monthOfYear  the month of the year\n * @param dayOfMonth  the day of the month\n * @param hourOfDay  the hour of the day\n * @param minuteOfHour  the minute of the hour\n * @param secondOfMinute  the second of the minute\n * @param millisOfSecond  the millisecond of the second\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 679, "method_signature": "void setDateTime(int, int, int, int, int, int, int)"}, "MutableDateTime.setMillis": {"callee_method_names": ["DateTimeField.roundFloor", "DateTimeField.roundCeiling", "DateTimeField.roundHalfFloor", "DateTimeField.roundHalfCeiling", "DateTimeField.roundHalfEven"], "method_name": "MutableDateTime.setMillis", "method_implementation": "{\n    switch(iRoundingMode) {\n        case ROUND_NONE:\n            break;\n        case ROUND_FLOOR:\n            instant = iRoundingField.roundFloor(instant);\n            break;\n        case ROUND_CEILING:\n            instant = iRoundingField.roundCeiling(instant);\n            break;\n        case ROUND_HALF_FLOOR:\n            instant = iRoundingField.roundHalfFloor(instant);\n            break;\n        case ROUND_HALF_CEILING:\n            instant = iRoundingField.roundHalfCeiling(instant);\n            break;\n        case ROUND_HALF_EVEN:\n            instant = iRoundingField.roundHalfEven(instant);\n            break;\n    }\n    super.setMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Set the milliseconds of the datetime.\n * <p>\n * All changes to the millisecond field occurs via this method.\n *\n * @param instant  the milliseconds since 1970-01-01T00:00:00Z to set the\n * datetime to\n */\n", "repo_name": "joda-time-main/", "id": 659, "method_signature": "void setMillis(long)"}, "MutableDateTime.setRounding": {"callee_method_names": [], "method_name": "MutableDateTime.setRounding", "method_implementation": "{\n    if (field != null && (mode < ROUND_NONE || mode > ROUND_HALF_EVEN)) {\n        throw new IllegalArgumentException(\"Illegal rounding mode: \" + mode);\n    }\n    iRoundingField = (mode == ROUND_NONE ? null : field);\n    iRoundingMode = (field == null ? ROUND_NONE : mode);\n    setMillis(getMillis());\n}", "repo_id": "7", "comment": "/**\n * Sets the status of rounding to use the specified field and mode.\n * A null field or mode of ROUND_NONE will disable rounding.\n * Once set, the instant is then rounded using the new field and mode.\n * <p>\n * Enabling rounding will cause all subsequent calls to {@link #setMillis(long)}\n * to be rounded. This can be used to control the precision of the instant,\n * for example by setting a rounding field of minuteOfDay, the seconds and\n * milliseconds will always be zero.\n *\n * @param field  rounding field or null to disable\n * @param mode  rounding mode or ROUND_NONE to disable\n * @throws IllegalArgumentException if mode is unknown, no exception if field is null\n */\n", "repo_name": "joda-time-main/", "id": 658, "method_signature": "void setRounding(DateTimeField, int)"}, "MutableDateTime.setTime": {"callee_method_names": [], "method_name": "MutableDateTime.setTime", "method_implementation": "{\n    long instant = getChronology().getDateTimeMillis(getMillis(), hour, minuteOfHour, secondOfMinute, millisOfSecond);\n    setMillis(instant);\n}", "repo_id": "7", "comment": "/**\n * Set the time from fields.\n * The date part of this object will be unaffected.\n *\n * @param hour  the hour\n * @param minuteOfHour  the minute of the hour\n * @param secondOfMinute  the second of the minute\n * @param millisOfSecond  the millisecond of the second\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 678, "method_signature": "void setTime(int, int, int, int)"}, "MutableDateTime.setZone": {"callee_method_names": ["Chronology.getZone", "Chronology.withZone"], "method_name": "MutableDateTime.setZone", "method_implementation": "{\n    newZone = DateTimeUtils.getZone(newZone);\n    Chronology chrono = getChronology();\n    if (chrono.getZone() != newZone) {\n        // set via this class not super\n        setChronology(chrono.withZone(newZone));\n    }\n}", "repo_id": "7", "comment": "/**\n * Sets the time zone of the datetime, changing the chronology and field values.\n * <p>\n * Changing the zone using this method retains the millisecond instant.\n * The millisecond instant is adjusted in the new zone to compensate.\n *\n * chronology. Setting the time zone does not affect the millisecond value\n * of this instant.\n * <p>\n * If the chronology already has this time zone, no change occurs.\n *\n * @param newZone  the time zone to use, null means default zone\n * @see #setZoneRetainFields\n */\n", "repo_name": "joda-time-main/", "id": 662, "method_signature": "void setZone(DateTimeZone)"}, "MutableDateTime.setZoneRetainFields": {"callee_method_ids": [119], "callee_method_names": ["DateTimeZone.getMillisKeepLocal"], "method_name": "MutableDateTime.setZoneRetainFields", "method_implementation": "{\n    newZone = DateTimeUtils.getZone(newZone);\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return;\n    }\n    long millis = originalZone.getMillisKeepLocal(newZone, getMillis());\n    // set via this class not super\n    setChronology(getChronology().withZone(newZone));\n    setMillis(millis);\n}", "repo_id": "7", "comment": "/**\n * Sets the time zone of the datetime, changing the chronology and millisecond.\n * <p>\n * Changing the zone using this method retains the field values.\n * The millisecond instant is adjusted in the new zone to compensate.\n * <p>\n * If the chronology already has this time zone, no change occurs.\n *\n * @param newZone  the time zone to use, null means default zone\n * @see #setZone\n */\n", "repo_name": "joda-time-main/", "id": 663, "method_signature": "void setZoneRetainFields(DateTimeZone)"}, "MutableInterval.clone": {"callee_method_names": [], "method_name": "MutableInterval.clone", "method_implementation": "{\n    try {\n        return super.clone();\n    } catch (CloneNotSupportedException ex) {\n        throw new InternalError(\"Clone error\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Clone this object.\n *\n * @return a clone of this object.\n */\n", "repo_name": "joda-time-main/", "id": 188, "method_signature": "Object clone()"}, "MutableInterval.setInterval": {"callee_method_names": [], "method_name": "MutableInterval.setInterval", "method_implementation": "{\n    if (start == null && end == null) {\n        long now = DateTimeUtils.currentTimeMillis();\n        setInterval(now, now);\n    } else {\n        long startMillis = DateTimeUtils.getInstantMillis(start);\n        long endMillis = DateTimeUtils.getInstantMillis(end);\n        Chronology chrono = DateTimeUtils.getInstantChronology(start);\n        super.setInterval(startMillis, endMillis, chrono);\n    }\n}", "repo_id": "7", "comment": "/**\n * Sets this interval from two instants, replacing the chronology with\n * that from the start instant.\n *\n * @param start  the start of the time interval\n * @param end  the start of the time interval\n * @throws IllegalArgumentException if the end is before the start\n */\n", "repo_name": "joda-time-main/", "id": 185, "method_signature": "void setInterval(ReadableInstant, ReadableInstant)"}, "MutableInterval.setPeriodAfterStart": {"callee_method_names": [], "method_name": "MutableInterval.setPeriodAfterStart", "method_implementation": "{\n    if (period == null) {\n        setEndMillis(getStartMillis());\n    } else {\n        setEndMillis(getChronology().add(period, getStartMillis(), 1));\n    }\n}", "repo_id": "7", "comment": "/**\n * Sets the period of this time interval, preserving the start instant\n * and using the ISOChronology in the default zone for calculations.\n *\n * @param period  new period for interval, null means zero length\n * @throws IllegalArgumentException if the end is before the start\n * @throws ArithmeticException if the end instant exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 186, "method_signature": "void setPeriodAfterStart(ReadablePeriod)"}, "MutableInterval.setPeriodBeforeEnd": {"callee_method_names": [], "method_name": "MutableInterval.setPeriodBeforeEnd", "method_implementation": "{\n    if (period == null) {\n        setStartMillis(getEndMillis());\n    } else {\n        setStartMillis(getChronology().add(period, getEndMillis(), -1));\n    }\n}", "repo_id": "7", "comment": "/**\n * Sets the period of this time interval, preserving the end instant\n * and using the ISOChronology in the default zone for calculations.\n *\n * @param period  new period for interval, null means zero length\n * @throws IllegalArgumentException if the end is before the start\n * @throws ArithmeticException if the start instant exceeds the capacity of a long\n */\n", "repo_name": "joda-time-main/", "id": 187, "method_signature": "void setPeriodBeforeEnd(ReadablePeriod)"}, "MutablePeriod.add": {"callee_method_names": ["ReadableDuration.getMillis"], "method_name": "MutablePeriod.add", "method_implementation": "{\n    if (duration != null) {\n        add(new Period(duration.getMillis(), getPeriodType()));\n    }\n}", "repo_id": "7", "comment": "/**\n * Adds a duration to this one by dividing the duration into\n * fields and calling {@link #add(ReadablePeriod)}.\n *\n * @param duration  the duration to add, null means add nothing\n * @throws ArithmeticException if the addition exceeds the capacity of the period\n */\n", "repo_name": "joda-time-main/", "id": 794, "method_signature": "void add(ReadableDuration)"}, "MutablePeriod.clone": {"callee_method_names": [], "method_name": "MutablePeriod.clone", "method_implementation": "{\n    try {\n        return super.clone();\n    } catch (CloneNotSupportedException ex) {\n        throw new InternalError(\"Clone error\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Clone this object.\n *\n * @return a clone of this object.\n */\n", "repo_name": "joda-time-main/", "id": 795, "method_signature": "Object clone()"}, "MutablePeriod.setPeriod": {"callee_method_names": [], "method_name": "MutablePeriod.setPeriod", "method_implementation": "{\n    if (start == end) {\n        setPeriod(0L);\n    } else {\n        long startMillis = DateTimeUtils.getInstantMillis(start);\n        long endMillis = DateTimeUtils.getInstantMillis(end);\n        Chronology chrono = DateTimeUtils.getIntervalChronology(start, end);\n        setPeriod(startMillis, endMillis, chrono);\n    }\n}", "repo_id": "7", "comment": "/**\n * Sets all the fields in one go from two instants representing an interval.\n * <p>\n * The chronology of the start instant is used, unless that is null when the\n * chronology of the end instant is used instead.\n *\n * @param start  the start instant, null means now\n * @param end  the end instant, null means now\n * @throws ArithmeticException if the set exceeds the capacity of the period\n */\n", "repo_name": "joda-time-main/", "id": 791, "method_signature": "void setPeriod(ReadableInstant, ReadableInstant)"}, "NullConverter.setInto": {"callee_method_names": ["ReadWritableInterval.setChronology", "ReadWritableInterval.setInterval"], "method_name": "NullConverter.setInto", "method_implementation": "{\n    writableInterval.setChronology(chrono);\n    long now = DateTimeUtils.currentTimeMillis();\n    writableInterval.setInterval(now, now);\n}", "repo_id": "7", "comment": "/**\n * Extracts interval endpoint values from an object of this converter's\n * type, and sets them into the given ReadWritableInterval.\n *\n * @param writableInterval interval to get modified, not null\n * @param object  the object to convert, which is null\n * @param chrono  the chronology to use, may be null\n * @throws NullPointerException if the interval is null\n */\n", "repo_name": "joda-time-main/", "id": 587, "method_signature": "void setInto(ReadWritableInterval, Object, Chronology)"}, "OfYear.next": {"callee_method_names": ["Chronology.monthOfYear", "Chronology.millisOfDay", "Chronology.millisOfDay", "Chronology.year", "Chronology.year", "Chronology.monthOfYear", "Chronology.millisOfDay", "Chronology.millisOfDay"], "method_name": "OfYear.next", "method_implementation": "{\n    int offset;\n    if (iMode == 'w') {\n        offset = standardOffset + saveMillis;\n    } else if (iMode == 's') {\n        offset = standardOffset;\n    } else {\n        offset = 0;\n    }\n    // Convert from UTC to local time.\n    instant += offset;\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    long next = chrono.monthOfYear().set(instant, iMonthOfYear);\n    // Be lenient with millisOfDay.\n    next = chrono.millisOfDay().set(next, 0);\n    // avoid going into the next day, as that can change the month and cause setDayOfMonthNext to fail\n    // this is not a particularly good solution to the problem (it is vital to use iMillisOfDay\n    // as otherwise the logic doesn't find the correct *next* occurrence)\n    next = chrono.millisOfDay().add(next, Math.min(iMillisOfDay, DateTimeConstants.MILLIS_PER_DAY - 1));\n    next = setDayOfMonthNext(chrono, next);\n    if (iDayOfWeek == 0) {\n        if (next <= instant) {\n            next = chrono.year().add(next, 1);\n            next = setDayOfMonthNext(chrono, next);\n        }\n    } else {\n        next = setDayOfWeek(chrono, next);\n        if (next <= instant) {\n            next = chrono.year().add(next, 1);\n            next = chrono.monthOfYear().set(next, iMonthOfYear);\n            next = setDayOfMonthNext(chrono, next);\n            next = setDayOfWeek(chrono, next);\n        }\n    }\n    next = chrono.millisOfDay().set(next, 0);\n    next = chrono.millisOfDay().add(next, iMillisOfDay);\n    // Convert from local time to UTC.\n    return next - offset;\n}", "repo_id": "7", "comment": "/**\n * @param standardOffset standard offset just before next recurrence\n */\n", "repo_name": "joda-time-main/", "id": 762, "method_signature": "long next(long, int, int)"}, "OfYear.previous": {"callee_method_names": ["Chronology.monthOfYear", "Chronology.millisOfDay", "Chronology.millisOfDay", "Chronology.year", "Chronology.year", "Chronology.monthOfYear", "Chronology.millisOfDay", "Chronology.millisOfDay"], "method_name": "OfYear.previous", "method_implementation": "{\n    int offset;\n    if (iMode == 'w') {\n        offset = standardOffset + saveMillis;\n    } else if (iMode == 's') {\n        offset = standardOffset;\n    } else {\n        offset = 0;\n    }\n    // Convert from UTC to local time.\n    instant += offset;\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    long prev = chrono.monthOfYear().set(instant, iMonthOfYear);\n    // Be lenient with millisOfDay.\n    prev = chrono.millisOfDay().set(prev, 0);\n    prev = chrono.millisOfDay().add(prev, iMillisOfDay);\n    prev = setDayOfMonthPrevious(chrono, prev);\n    if (iDayOfWeek == 0) {\n        if (prev >= instant) {\n            prev = chrono.year().add(prev, -1);\n            prev = setDayOfMonthPrevious(chrono, prev);\n        }\n    } else {\n        prev = setDayOfWeek(chrono, prev);\n        if (prev >= instant) {\n            prev = chrono.year().add(prev, -1);\n            prev = chrono.monthOfYear().set(prev, iMonthOfYear);\n            prev = setDayOfMonthPrevious(chrono, prev);\n            prev = setDayOfWeek(chrono, prev);\n        }\n    }\n    prev = chrono.millisOfDay().set(prev, 0);\n    prev = chrono.millisOfDay().add(prev, iMillisOfDay);\n    // Convert from local time to UTC.\n    return prev - offset;\n}", "repo_id": "7", "comment": "/**\n * @param standardOffset standard offset just before previous recurrence\n */\n", "repo_name": "joda-time-main/", "id": 763, "method_signature": "long previous(long, int, int)"}, "OfYear.setDayOfMonthNext": {"callee_method_names": ["Chronology.year", "Chronology.year"], "method_name": "OfYear.setDayOfMonthNext", "method_implementation": "{\n    try {\n        next = setDayOfMonth(chrono, next);\n    } catch (IllegalArgumentException e) {\n        if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n            while (chrono.year().isLeap(next) == false) {\n                next = chrono.year().add(next, 1);\n            }\n            next = setDayOfMonth(chrono, next);\n        } else {\n            throw e;\n        }\n    }\n    return next;\n}", "repo_id": "7", "comment": "/**\n * If month-day is 02-29 and year isn't leap, advances to next leap year.\n */\n", "repo_name": "joda-time-main/", "id": 764, "method_signature": "long setDayOfMonthNext(Chronology, long)"}, "OfYear.setDayOfMonthPrevious": {"callee_method_names": ["Chronology.year", "Chronology.year"], "method_name": "OfYear.setDayOfMonthPrevious", "method_implementation": "{\n    try {\n        prev = setDayOfMonth(chrono, prev);\n    } catch (IllegalArgumentException e) {\n        if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n            while (chrono.year().isLeap(prev) == false) {\n                prev = chrono.year().add(prev, -1);\n            }\n            prev = setDayOfMonth(chrono, prev);\n        } else {\n            throw e;\n        }\n    }\n    return prev;\n}", "repo_id": "7", "comment": "/**\n * If month-day is 02-29 and year isn't leap, retreats to previous leap year.\n */\n", "repo_name": "joda-time-main/", "id": 765, "method_signature": "long setDayOfMonthPrevious(Chronology, long)"}, "OfYear.setInstant": {"callee_method_names": ["Chronology.year", "Chronology.monthOfYear", "Chronology.millisOfDay"], "method_name": "OfYear.setInstant", "method_implementation": "{\n    int offset;\n    if (iMode == 'w') {\n        offset = standardOffset + saveMillis;\n    } else if (iMode == 's') {\n        offset = standardOffset;\n    } else {\n        offset = 0;\n    }\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    long millis = chrono.year().set(0, year);\n    millis = chrono.monthOfYear().set(millis, iMonthOfYear);\n    millis = chrono.millisOfDay().set(millis, iMillisOfDay);\n    millis = setDayOfMonth(chrono, millis);\n    if (iDayOfWeek != 0) {\n        millis = setDayOfWeek(chrono, millis);\n    }\n    // Convert from local time to UTC.\n    return millis - offset;\n}", "repo_id": "7", "comment": "/**\n * @param standardOffset standard offset just before instant\n */\n", "repo_name": "joda-time-main/", "id": 761, "method_signature": "long setInstant(int, int, int)"}, "OffsetDateTimeField.add": {"callee_method_names": [], "method_name": "OffsetDateTimeField.add", "method_implementation": "{\n    instant = super.add(instant, amount);\n    FieldUtils.verifyValueBounds(this, get(instant), iMin, iMax);\n    return instant;\n}", "repo_id": "7", "comment": "/**\n * Add the specified amount of offset units to the specified time\n * instant. The amount added may be negative.\n *\n * @param instant  the time instant in millis to update.\n * @param amount  the amount of units to add (can be negative).\n * @return the updated time instant.\n */\n", "repo_name": "joda-time-main/", "id": 60, "method_signature": "long add(long, long)"}, "OffsetDateTimeField.set": {"callee_method_names": [], "method_name": "OffsetDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n    return super.set(instant, value - iOffset);\n}", "repo_id": "7", "comment": "/**\n * Set the specified amount of offset units to the specified time instant.\n *\n * @param instant  the time instant in millis to update.\n * @param value  value of units to set.\n * @return the updated time instant.\n * @throws IllegalArgumentException if value is too large or too small.\n */\n", "repo_name": "joda-time-main/", "id": 61, "method_signature": "long set(long, int)"}, "OpenAction.actionPerformed": {"callee_method_names": ["JFileChooser.showOpenDialog", "JFileChooser.getSelectedFile", "File.getCanonicalPath"], "method_name": "OpenAction.actionPerformed", "method_implementation": "{\n    int result = chooser.showOpenDialog(DateTimeBrowser.this);\n    String canPath = null;\n    if (result == JFileChooser.APPROVE_OPTION) {\n        File chosenFile = chooser.getSelectedFile();\n        try {\n            canPath = chosenFile.getCanonicalPath();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O Error on file: \" + chosenFile);\n            // Ignore it for now.\n        }\n        enableAllViews();\n        currFile = new LoadedFile(canPath);\n        TableView tView = getDefaultTableView();\n        resetDefaults(tView);\n    }\n    // end of if a file actually chosen.\n}", "repo_id": "7", "comment": "/*\n         * actionPerformed\n         */\n", "repo_name": "joda-time-main/", "id": 1108, "method_signature": "void actionPerformed(ActionEvent)"}, "Partial.addToCopy": {"callee_method_names": ["Partial.getValues"], "method_name": "Partial.addToCopy", "method_implementation": "{\n    int[] newValues = iPartial.getValues();\n    newValues = getField().add(iPartial, iFieldIndex, newValues, valueToAdd);\n    return new Partial(iPartial, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this Partial.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it will affect larger fields.\n * Smaller fields are unaffected.\n * <p>\n * If the result would be too large, beyond the maximum year, then an\n * IllegalArgumentException is thrown.\n * <p>\n * The Partial attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the Partial with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 142, "method_signature": "Partial addToCopy(int)"}, "Partial.addWrapFieldToCopy": {"callee_method_names": ["Partial.getValues"], "method_name": "Partial.addWrapFieldToCopy", "method_implementation": "{\n    int[] newValues = iPartial.getValues();\n    newValues = getField().addWrapField(iPartial, iFieldIndex, newValues, valueToAdd);\n    return new Partial(iPartial, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this Partial wrapping\n * within this field if the maximum value is reached.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it wraps within this field.\n * Other fields are unaffected.\n * <p>\n * For example,\n * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n * <p>\n * The Partial attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the Partial with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 143, "method_signature": "Partial addWrapFieldToCopy(int)"}, "Partial.getFormatter": {"callee_method_names": ["List<DateTimeFieldType>.size"], "method_name": "Partial.getFormatter", "method_implementation": "{\n    DateTimeFormatter[] f = iFormatter;\n    if (f == null) {\n        if (size() == 0) {\n            return null;\n        }\n        f = new DateTimeFormatter[2];\n        try {\n            List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes));\n            f[0] = ISODateTimeFormat.forFields(list, true, false);\n            if (list.size() == 0) {\n                f[1] = f[0];\n            }\n        } catch (IllegalArgumentException ex) {\n            // ignore\n        }\n        iFormatter = f;\n    }\n    return f[0];\n}", "repo_id": "7", "comment": "/**\n * Gets a formatter suitable for the fields in this partial.\n * <p>\n * If there is no appropriate ISO format, null is returned.\n * This method may return a formatter that does not display all the\n * fields of the partial. This might occur when you have overlapping\n * fields, such as dayOfWeek and dayOfMonth.\n *\n * @return a formatter suitable for the fields in this partial, null\n *  if none is suitable\n */\n", "repo_name": "joda-time-main/", "id": 137, "method_signature": "DateTimeFormatter getFormatter()"}, "Partial.isMatch": {"callee_method_names": ["ReadablePartial.get"], "method_name": "Partial.isMatch", "method_implementation": "{\n    if (partial == null) {\n        throw new IllegalArgumentException(\"The partial must not be null\");\n    }\n    for (int i = 0; i < iTypes.length; i++) {\n        int value = partial.get(iTypes[i]);\n        if (value != iValues[i]) {\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "7", "comment": "/**\n * Does this partial match the specified partial.\n * <p>\n * A match occurs when all the fields of this partial are the same as the\n * corresponding fields on the specified partial.\n *\n * @param partial  a partial to check against, must not be null\n * @return true if this partial matches the specified partial\n * @throws IllegalArgumentException if the partial is null\n * @throws IllegalArgumentException if the fields of the two partials do not match\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 136, "method_signature": "boolean isMatch(ReadablePartial)"}, "Partial.setCopy": {"callee_method_names": ["Partial.getValues"], "method_name": "Partial.setCopy", "method_implementation": "{\n    int[] newValues = iPartial.getValues();\n    newValues = getField().set(iPartial, iFieldIndex, newValues, text, locale);\n    return new Partial(iPartial, newValues);\n}", "repo_id": "7", "comment": "/**\n * Sets this field in a copy of the Partial to a parsed text value.\n * <p>\n * The Partial attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param text  the text value to set\n * @param locale  optional locale to use for selecting a text symbol\n * @return a copy of the Partial with the field value changed\n * @throws IllegalArgumentException if the text value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 145, "method_signature": "Partial setCopy(String, Locale)"}, "Partial.toString": {"callee_method_names": [], "method_name": "Partial.toString", "method_implementation": "{\n    if (pattern == null) {\n        return toString();\n    }\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n}", "repo_id": "7", "comment": "/**\n * Output the date using the specified format pattern.\n * Unsupported fields will appear as special unicode characters.\n *\n * @param pattern  the pattern specification, null means use <code>toString</code>\n * @param locale  Locale to use, null means default\n * @return the formatted output, not null\n * @see org.joda.time.format.DateTimeFormat\n */\n", "repo_name": "joda-time-main/", "id": 141, "method_signature": "String toString(String, Locale)"}, "Partial.toStringList": {"callee_method_names": ["StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "DateTimeFieldType[].getName", "StringBuilder.append", "StringBuilder.append", "StringBuilder.append", "StringBuilder.toString"], "method_name": "Partial.toStringList", "method_implementation": "{\n    int size = size();\n    StringBuilder buf = new StringBuilder(20 * size);\n    buf.append('[');\n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            buf.append(',').append(' ');\n        }\n        buf.append(iTypes[i].getName());\n        buf.append('=');\n        buf.append(iValues[i]);\n    }\n    buf.append(']');\n    return buf.toString();\n}", "repo_id": "7", "comment": "/**\n * Gets a string version of the partial that lists all the fields.\n * <p>\n * This method exists to provide a better debugging toString than\n * the standard toString. This method lists all the fields and their\n * values in a style similar to the collections framework.\n *\n * @return a toString format that lists all the fields\n */\n", "repo_name": "joda-time-main/", "id": 139, "method_signature": "String toStringList()"}, "Partial.with": {"callee_method_names": ["DateTimeFieldType.getDurationType", "DurationField.isSupported", "DateTimeFieldType.getDurationType", "DurationField.isSupported", "DurationField.compareTo", "DateTimeFieldType.getRangeDurationType", "DateTimeFieldType.getRangeDurationType", "DateTimeFieldType.getRangeDurationType", "DateTimeFieldType.getRangeDurationType", "DurationField.compareTo", "Chronology.validate"], "method_name": "Partial.with", "method_implementation": "{\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        // find correct insertion point to keep largest-smallest order\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        if (fieldType.getRangeDurationType() == null) {\n                            break;\n                        }\n                        if (loopType.getRangeDurationType() == null) {\n                            continue;\n                        }\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n        // use public constructor to ensure full validation\n        // this isn't overly efficient, but is safe\n        Partial newPartial = new Partial(newTypes, newValues, iChronology);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of this date with the specified field set to a new value.\n * <p>\n * If this partial did not previously support the field, the new one will.\n * Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}.\n * <p>\n * For example, if the field type is <code>dayOfMonth</code> then the day\n * would be changed/added in the returned instance.\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this instance with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 129, "method_signature": "Partial with(DateTimeFieldType, int)"}, "Partial.withChronologyRetainFields": {"callee_method_names": ["Chronology.withUTC", "Chronology.validate"], "method_name": "Partial.withChronologyRetainFields", "method_implementation": "{\n    newChronology = DateTimeUtils.getChronology(newChronology);\n    newChronology = newChronology.withUTC();\n    if (newChronology == getChronology()) {\n        return this;\n    } else {\n        Partial newPartial = new Partial(newChronology, iTypes, iValues);\n        newChronology.validate(newPartial, iValues);\n        return newPartial;\n    }\n}", "repo_id": "7", "comment": "/**\n * Creates a new Partial instance with the specified chronology.\n * This instance is immutable and unaffected by this method call.\n * <p>\n * This method retains the values of the fields, thus the result will\n * typically refer to a different instant.\n * <p>\n * The time zone of the specified chronology is ignored, as Partial\n * operates without a time zone.\n *\n * @param newChronology  the new chronology, null means ISO\n * @return a copy of this datetime with a different chronology\n * @throws IllegalArgumentException if the values are invalid for the new chronology\n */\n", "repo_name": "joda-time-main/", "id": 128, "method_signature": "Partial withChronologyRetainFields(Chronology)"}, "Partial.withField": {"callee_method_names": [], "method_name": "Partial.withField", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new Partial(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of this Partial with the specified field set to a new value.\n * <p>\n * If this partial does not support the field, an exception is thrown.\n * Contrast this behaviour with {@link #with(DateTimeFieldType, int)}.\n * <p>\n * For example, if the field type is <code>dayOfMonth</code> then the day\n * would be changed in the returned instance if supported.\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this instance with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 131, "method_signature": "Partial withField(DateTimeFieldType, int)"}, "Partial.withFieldAddWrapped": {"callee_method_names": [], "method_name": "Partial.withFieldAddWrapped", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (amount == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n    return new Partial(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of this Partial with the value of the specified field increased.\n * If this partial does not support the field, an exception is thrown.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * The addition will overflow into larger fields (eg. minute to hour).\n * If the maximum is reached, the addition will wrap.\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this instance with the field updated\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the new datetime exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 133, "method_signature": "Partial withFieldAddWrapped(DurationFieldType, int)"}, "Partial.withFieldAdded": {"callee_method_names": [], "method_name": "Partial.withFieldAdded", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (amount == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).add(this, index, newValues, amount);\n    return new Partial(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of this Partial with the value of the specified field increased.\n * If this partial does not support the field, an exception is thrown.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * The addition will overflow into larger fields (eg. minute to hour).\n * However, it will not wrap around if the top maximum is reached.\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this instance with the field updated\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the new datetime exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 132, "method_signature": "Partial withFieldAdded(DurationFieldType, int)"}, "Partial.withPeriodAdded": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getFieldType", "ReadablePeriod.getValue"], "method_name": "Partial.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    for (int i = 0; i < period.size(); i++) {\n        DurationFieldType fieldType = period.getFieldType(i);\n        int index = indexOf(fieldType);\n        if (index >= 0) {\n            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\n        }\n    }\n    return new Partial(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of this Partial with the specified period added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * Fields in the period that aren't present in the partial are ignored.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using the method\n * {@link #withFieldAdded(DurationFieldType, int)}.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this instance with the period added\n * @throws ArithmeticException if the new datetime exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 134, "method_signature": "Partial withPeriodAdded(ReadablePeriod, int)"}, "Partial.without": {"callee_method_names": ["Chronology.validate"], "method_name": "Partial.without", "method_implementation": "{\n    int index = indexOf(fieldType);\n    if (index != -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[size() - 1];\n        int[] newValues = new int[size() - 1];\n        System.arraycopy(iTypes, 0, newTypes, 0, index);\n        System.arraycopy(iTypes, index + 1, newTypes, index, newTypes.length - index);\n        System.arraycopy(iValues, 0, newValues, 0, index);\n        System.arraycopy(iValues, index + 1, newValues, index, newValues.length - index);\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        iChronology.validate(newPartial, newValues);\n        return newPartial;\n    }\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Gets a copy of this date with the specified field removed.\n * <p>\n * If this partial did not previously support the field, no error occurs.\n *\n * @param fieldType  the field type to remove, may be null\n * @return a copy of this instance with the field removed\n */\n", "repo_name": "joda-time-main/", "id": 130, "method_signature": "Partial without(DateTimeFieldType)"}, "Period.checkYearsAndMonths": {"callee_method_names": [], "method_name": "Period.checkYearsAndMonths", "method_implementation": "{\n    if (getMonths() != 0) {\n        throw new UnsupportedOperationException(\"Cannot convert to \" + destintionType + \" as this period contains months and months vary in length\");\n    }\n    if (getYears() != 0) {\n        throw new UnsupportedOperationException(\"Cannot convert to \" + destintionType + \" as this period contains years and years vary in length\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Check that there are no years or months in the period.\n *\n * @param destintionType  the destination type, not null\n * @throws UnsupportedOperationException if the period contains years or months\n */\n", "repo_name": "joda-time-main/", "id": 1021, "method_signature": "void checkYearsAndMonths(String)"}, "Period.fieldDifference": {"callee_method_names": ["ReadablePartial.size", "ReadablePartial.size", "ReadablePartial.size", "ReadablePartial.size", "ReadablePartial.size", "ReadablePartial.getFieldType", "ReadablePartial.getFieldType", "ReadablePartial.getFieldType", "DurationFieldType[].equals", "ReadablePartial.getValue", "ReadablePartial.getValue"], "method_name": "Period.fieldDifference", "method_implementation": "{\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    DurationFieldType[] types = new DurationFieldType[start.size()];\n    int[] values = new int[start.size()];\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        types[i] = start.getFieldType(i).getDurationType();\n        if (i > 0 && types[i - 1].equals(types[i])) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\");\n        }\n        values[i] = end.getValue(i) - start.getValue(i);\n    }\n    return new Period(values, PeriodType.forFields(types));\n}", "repo_id": "7", "comment": "/**\n * Creates a period from two partially specified times, calculating\n * by field difference.\n * <p>\n * The two partials must contain the same fields, thus you can specify\n * two <code>LocalDate</code> objects, or two <code>LocalTime</code> objects,\n * but not one of each. Also, the partial may not contain overlapping\n * fields, such as dayOfWeek and dayOfMonth.\n * <p>\n * Calculation by field difference works by extracting the difference\n * one field at a time and not wrapping into other fields.\n * Thus 2005-06-09/2007-04-12 will yield P2Y-2M3D.\n * <p>\n * For example, you have an event that always runs from the 27th of\n * each month to the 2nd of the next month. If you calculate this\n * period using a standard constructor, then you will get between\n * P3D and P6D depending on the month. If you use this method, then\n * you will get P1M-25D. This field-difference based period can\n * be successfully applied to each month of the year to obtain the\n * correct end date for a given start date.\n *\n * @param start  the start of the period, must not be null\n * @param end  the end of the period, must not be null\n * @return the period, not null\n * @throws IllegalArgumentException if the partials are null or invalid\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 991, "method_signature": "Period fieldDifference(ReadablePartial, ReadablePartial)"}, "Period.minus": {"callee_method_names": ["ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get"], "method_name": "Period.minus", "method_implementation": "{\n    if (period == null) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, -period.get(DurationFieldType.YEARS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, -period.get(DurationFieldType.MONTHS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, -period.get(DurationFieldType.WEEKS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, -period.get(DurationFieldType.DAYS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, -period.get(DurationFieldType.HOURS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, -period.get(DurationFieldType.MINUTES_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, -period.get(DurationFieldType.SECONDS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, -period.get(DurationFieldType.MILLIS_TYPE));\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified period subtracted.\n * <p>\n * Each field of the period is subtracted separately. Thus a period of\n * 3 hours 30 minutes minus 2 hours 40 minutes will produce a result\n * of 1 hour and -10 minutes - see {@link #normalizedStandard()}.\n * <p>\n * If the period being added contains a non-zero amount for a field that\n * is not supported in this period then an exception is thrown.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param period  the period to add, null adds zero and returns this\n * @return the new updated period\n * @throws UnsupportedOperationException if any field is not supported\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 1013, "method_signature": "Period minus(ReadablePeriod)"}, "Period.multipliedBy": {"callee_method_names": [], "method_name": "Period.multipliedBy", "method_implementation": "{\n    if (this == ZERO || scalar == 1) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    for (int i = 0; i < values.length; i++) {\n        values[i] = FieldUtils.safeMultiply(values[i], scalar);\n    }\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with each element in this period multiplied\n * by the specified scalar.\n *\n * @param scalar  the scalar to multiply by, not null\n * @return a {@code Period} based on this period with the amounts multiplied by the scalar, never null\n * @throws ArithmeticException if the capacity of any field is exceeded\n * @since 2.1\n */\n", "repo_name": "joda-time-main/", "id": 1014, "method_signature": "Period multipliedBy(int)"}, "Period.normalizedStandard": {"callee_method_ids": [996, 997], "callee_method_names": ["PeriodType.isSupported", "Period.withYears", "PeriodType.isSupported", "Period.withMonths"], "method_name": "Period.normalizedStandard", "method_implementation": "{\n    type = DateTimeUtils.getPeriodType(type);\n    // no overflow can happen, even with Integer.MAX_VALUEs\n    long millis = getMillis();\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n    Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n    int years = getYears();\n    int months = getMonths();\n    if (years != 0 || months != 0) {\n        long totalMonths = years * 12L + months;\n        if (type.isSupported(DurationFieldType.YEARS_TYPE)) {\n            int normalizedYears = FieldUtils.safeToInt(totalMonths / 12);\n            result = result.withYears(normalizedYears);\n            totalMonths = totalMonths - (normalizedYears * 12L);\n        }\n        if (type.isSupported(DurationFieldType.MONTHS_TYPE)) {\n            int normalizedMonths = FieldUtils.safeToInt(totalMonths);\n            result = result.withMonths(normalizedMonths);\n            totalMonths = totalMonths - normalizedMonths;\n        }\n        if (totalMonths != 0) {\n            throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());\n        }\n    }\n    return result;\n}", "repo_id": "7", "comment": "/**\n * Normalizes this period using standard rules, assuming a 12 month year,\n * 7 day week, 24 hour day, 60 minute hour and 60 second minute,\n * providing control over how the result is split into fields.\n * <p>\n * This method allows you to normalize a period.\n * However to achieve this it makes the assumption that all years are\n * 12 months, all weeks are 7 days, all days are 24 hours,\n * all hours are 60 minutes and all minutes are 60 seconds. This is not\n * true when daylight savings time is considered, and may also not be true\n * for some chronologies. However, it is included as it is a useful operation\n * for many applications and business rules.\n * <p>\n * If the period contains years or months, then the months will be\n * normalized to be between 0 and 11. The days field and below will be\n * normalized as necessary, however this will not overflow into the months\n * field. Thus a period of 1 year 15 months will normalize to 2 years 3 months.\n * But a period of 1 month 40 days will remain as 1 month 40 days.\n * <p>\n * The PeriodType parameter controls how the result is created. It allows\n * you to omit certain fields from the result if desired. For example,\n * you may not want the result to include weeks, in which case you pass\n * in <code>PeriodType.yearMonthDayTime()</code>.\n *\n * @param type  the period type of the new period, null means standard type\n * @return a normalized period equivalent to this period\n * @throws ArithmeticException if any field is too large to be represented\n * @throws UnsupportedOperationException if this period contains non-zero\n *  years or months but the specified period type does not support them\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 1022, "method_signature": "Period normalizedStandard(PeriodType)"}, "Period.plus": {"callee_method_names": ["ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get"], "method_name": "Period.plus", "method_implementation": "{\n    if (period == null) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, period.get(DurationFieldType.YEARS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, period.get(DurationFieldType.MONTHS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, period.get(DurationFieldType.WEEKS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, period.get(DurationFieldType.DAYS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, period.get(DurationFieldType.HOURS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, period.get(DurationFieldType.MINUTES_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, period.get(DurationFieldType.SECONDS_TYPE));\n    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, period.get(DurationFieldType.MILLIS_TYPE));\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified period added.\n * <p>\n * Each field of the period is added separately. Thus a period of\n * 2 hours 30 minutes plus 3 hours 40 minutes will produce a result\n * of 5 hours 70 minutes - see {@link #normalizedStandard()}.\n * <p>\n * If the period being added contains a non-zero amount for a field that\n * is not supported in this period then an exception is thrown.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param period  the period to add, null adds zero and returns this\n * @return the new updated period\n * @throws UnsupportedOperationException if any field is not supported\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 1004, "method_signature": "Period plus(ReadablePeriod)"}, "Period.plusDays": {"callee_method_names": [], "method_name": "Period.plusDays", "method_implementation": "{\n    if (days == 0) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period plus the specified number of days added.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param days  the amount of days to add, may be negative\n * @return the new period plus the increased days\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1008, "method_signature": "Period plusDays(int)"}, "Period.plusHours": {"callee_method_names": [], "method_name": "Period.plusHours", "method_implementation": "{\n    if (hours == 0) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period plus the specified number of hours added.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param hours  the amount of hours to add, may be negative\n * @return the new period plus the increased hours\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1009, "method_signature": "Period plusHours(int)"}, "Period.plusMillis": {"callee_method_names": [], "method_name": "Period.plusMillis", "method_implementation": "{\n    if (millis == 0) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period plus the specified number of millis added.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param millis  the amount of millis to add, may be negative\n * @return the new period plus the increased millis\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1012, "method_signature": "Period plusMillis(int)"}, "Period.plusMinutes": {"callee_method_names": [], "method_name": "Period.plusMinutes", "method_implementation": "{\n    if (minutes == 0) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period plus the specified number of minutes added.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param minutes  the amount of minutes to add, may be negative\n * @return the new period plus the increased minutes\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1010, "method_signature": "Period plusMinutes(int)"}, "Period.plusMonths": {"callee_method_names": [], "method_name": "Period.plusMonths", "method_implementation": "{\n    if (months == 0) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period plus the specified number of months added.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param months  the amount of months to add, may be negative\n * @return the new period plus the increased months\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1006, "method_signature": "Period plusMonths(int)"}, "Period.plusSeconds": {"callee_method_names": [], "method_name": "Period.plusSeconds", "method_implementation": "{\n    if (seconds == 0) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period plus the specified number of seconds added.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param seconds  the amount of seconds to add, may be negative\n * @return the new period plus the increased seconds\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1011, "method_signature": "Period plusSeconds(int)"}, "Period.plusWeeks": {"callee_method_names": [], "method_name": "Period.plusWeeks", "method_implementation": "{\n    if (weeks == 0) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period plus the specified number of weeks added.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param weeks  the amount of weeks to add, may be negative\n * @return the new period plus the increased weeks\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1007, "method_signature": "Period plusWeeks(int)"}, "Period.plusYears": {"callee_method_names": [], "method_name": "Period.plusYears", "method_implementation": "{\n    if (years == 0) {\n        return this;\n    }\n    // cloned\n    int[] values = getValues();\n    getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified number of years added.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param years  the amount of years to add, may be negative\n * @return the new period with the increased years\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1005, "method_signature": "Period plusYears(int)"}, "Period.toStandardDays": {"callee_method_names": [], "method_name": "Period.toStandardDays", "method_implementation": "{\n    checkYearsAndMonths(\"Days\");\n    // assign to a long\n    long millis = getMillis();\n    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n    long days = millis / DateTimeConstants.MILLIS_PER_DAY;\n    days = FieldUtils.safeAdd(days, getDays());\n    days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK));\n    return Days.days(FieldUtils.safeToInt(days));\n}", "repo_id": "7", "comment": "/**\n * Converts this period to a period in days assuming a\n * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n * <p>\n * This method allows you to convert between different types of period.\n * However to achieve this it makes the assumption that all\n * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n * all minutes are 60 seconds. This is not true when daylight savings time\n * is considered, and may also not be true for some unusual chronologies.\n * However, it is included as it is a useful operation for many\n * applications and business rules.\n * <p>\n * If the period contains years or months, an exception will be thrown.\n *\n * @return a period representing the number of standard days in this period\n * @throws UnsupportedOperationException if the period contains years or months\n * @throws ArithmeticException if the number of days is too large to be represented\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 1016, "method_signature": "Days toStandardDays()"}, "Period.toStandardDuration": {"callee_method_names": [], "method_name": "Period.toStandardDuration", "method_implementation": "{\n    checkYearsAndMonths(\"Duration\");\n    // no overflow can happen, even with Integer.MAX_VALUEs\n    long millis = getMillis();\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n    return new Duration(millis);\n}", "repo_id": "7", "comment": "/**\n * Converts this period to a duration assuming a\n * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n * <p>\n * This method allows you to convert from a period to a duration.\n * However to achieve this it makes the assumption that all\n * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n * all minutes are 60 seconds. This is not true when daylight savings time\n * is considered, and may also not be true for some unusual chronologies.\n * However, it is included as it is a useful operation for many\n * applications and business rules.\n * <p>\n * If the period contains years or months, an exception will be thrown.\n *\n * @return a duration equivalent to this period\n * @throws UnsupportedOperationException if the period contains years or months\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 1020, "method_signature": "Duration toStandardDuration()"}, "Period.toStandardHours": {"callee_method_names": [], "method_name": "Period.toStandardHours", "method_implementation": "{\n    checkYearsAndMonths(\"Hours\");\n    // assign to a long\n    long millis = getMillis();\n    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n    long hours = millis / DateTimeConstants.MILLIS_PER_HOUR;\n    hours = FieldUtils.safeAdd(hours, getHours());\n    hours = FieldUtils.safeAdd(hours, ((long) getDays()) * ((long) DateTimeConstants.HOURS_PER_DAY));\n    hours = FieldUtils.safeAdd(hours, ((long) getWeeks()) * ((long) DateTimeConstants.HOURS_PER_WEEK));\n    return Hours.hours(FieldUtils.safeToInt(hours));\n}", "repo_id": "7", "comment": "/**\n * Converts this period to a period in hours assuming a\n * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n * <p>\n * This method allows you to convert between different types of period.\n * However to achieve this it makes the assumption that all\n * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n * all minutes are 60 seconds. This is not true when daylight savings time\n * is considered, and may also not be true for some unusual chronologies.\n * However, it is included as it is a useful operation for many\n * applications and business rules.\n * <p>\n * If the period contains years or months, an exception will be thrown.\n *\n * @return a period representing the number of standard hours in this period\n * @throws UnsupportedOperationException if the period contains years or months\n * @throws ArithmeticException if the number of hours is too large to be represented\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 1017, "method_signature": "Hours toStandardHours()"}, "Period.toStandardMinutes": {"callee_method_names": [], "method_name": "Period.toStandardMinutes", "method_implementation": "{\n    checkYearsAndMonths(\"Minutes\");\n    // assign to a long\n    long millis = getMillis();\n    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n    long minutes = millis / DateTimeConstants.MILLIS_PER_MINUTE;\n    minutes = FieldUtils.safeAdd(minutes, getMinutes());\n    minutes = FieldUtils.safeAdd(minutes, ((long) getHours()) * ((long) DateTimeConstants.MINUTES_PER_HOUR));\n    minutes = FieldUtils.safeAdd(minutes, ((long) getDays()) * ((long) DateTimeConstants.MINUTES_PER_DAY));\n    minutes = FieldUtils.safeAdd(minutes, ((long) getWeeks()) * ((long) DateTimeConstants.MINUTES_PER_WEEK));\n    return Minutes.minutes(FieldUtils.safeToInt(minutes));\n}", "repo_id": "7", "comment": "/**\n * Converts this period to a period in minutes assuming a\n * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n * <p>\n * This method allows you to convert between different types of period.\n * However to achieve this it makes the assumption that all\n * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n * all minutes are 60 seconds. This is not true when daylight savings time\n * is considered, and may also not be true for some unusual chronologies.\n * However, it is included as it is a useful operation for many\n * applications and business rules.\n * <p>\n * If the period contains years or months, an exception will be thrown.\n *\n * @return a period representing the number of standard minutes in this period\n * @throws UnsupportedOperationException if the period contains years or months\n * @throws ArithmeticException if the number of minutes is too large to be represented\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 1018, "method_signature": "Minutes toStandardMinutes()"}, "Period.toStandardSeconds": {"callee_method_names": [], "method_name": "Period.toStandardSeconds", "method_implementation": "{\n    checkYearsAndMonths(\"Seconds\");\n    long seconds = getMillis() / DateTimeConstants.MILLIS_PER_SECOND;\n    seconds = FieldUtils.safeAdd(seconds, getSeconds());\n    seconds = FieldUtils.safeAdd(seconds, ((long) getMinutes()) * ((long) DateTimeConstants.SECONDS_PER_MINUTE));\n    seconds = FieldUtils.safeAdd(seconds, ((long) getHours()) * ((long) DateTimeConstants.SECONDS_PER_HOUR));\n    seconds = FieldUtils.safeAdd(seconds, ((long) getDays()) * ((long) DateTimeConstants.SECONDS_PER_DAY));\n    seconds = FieldUtils.safeAdd(seconds, ((long) getWeeks()) * ((long) DateTimeConstants.SECONDS_PER_WEEK));\n    return Seconds.seconds(FieldUtils.safeToInt(seconds));\n}", "repo_id": "7", "comment": "/**\n * Converts this period to a period in seconds assuming a\n * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n * <p>\n * This method allows you to convert between different types of period.\n * However to achieve this it makes the assumption that all\n * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n * all minutes are 60 seconds. This is not true when daylight savings time\n * is considered, and may also not be true for some unusual chronologies.\n * However, it is included as it is a useful operation for many\n * applications and business rules.\n * <p>\n * If the period contains years or months, an exception will be thrown.\n *\n * @return a period representing the number of standard seconds in this period\n * @throws UnsupportedOperationException if the period contains years or months\n * @throws ArithmeticException if the number of seconds is too large to be represented\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 1019, "method_signature": "Seconds toStandardSeconds()"}, "Period.toStandardWeeks": {"callee_method_names": [], "method_name": "Period.toStandardWeeks", "method_implementation": "{\n    checkYearsAndMonths(\"Weeks\");\n    // assign to a long\n    long millis = getMillis();\n    millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND;\n    millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE;\n    millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR;\n    millis += ((long) getDays()) * DateTimeConstants.MILLIS_PER_DAY;\n    long weeks = ((long) getWeeks()) + millis / DateTimeConstants.MILLIS_PER_WEEK;\n    return Weeks.weeks(FieldUtils.safeToInt(weeks));\n}", "repo_id": "7", "comment": "/**\n * Converts this period to a period in weeks assuming a\n * 7 day week, 24 hour day, 60 minute hour and 60 second minute.\n * <p>\n * This method allows you to convert between different types of period.\n * However to achieve this it makes the assumption that all\n * weeks are 7 days, all days are 24 hours, all hours are 60 minutes and\n * all minutes are 60 seconds. This is not true when daylight savings time\n * is considered, and may also not be true for some unusual chronologies.\n * However, it is included as it is a useful operation for many\n * applications and business rules.\n * <p>\n * If the period contains years or months, an exception will be thrown.\n *\n * @return a period representing the number of standard weeks in this period\n * @throws UnsupportedOperationException if the period contains years or months\n * @throws ArithmeticException if the number of weeks is too large to be represented\n * @since 1.5\n */\n", "repo_name": "joda-time-main/", "id": 1015, "method_signature": "Weeks toStandardWeeks()"}, "Period.withDays": {"callee_method_names": [], "method_name": "Period.withDays", "method_implementation": "{\n    // cloned\n    int[] values = getValues();\n    getPeriodType().setIndexedField(this, PeriodType.DAY_INDEX, values, days);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified number of days.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param days  the amount of days to add, may be negative\n * @return the new period with the increased days\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 999, "method_signature": "Period withDays(int)"}, "Period.withField": {"callee_method_names": [], "method_name": "Period.withField", "method_implementation": "{\n    if (field == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    // cloned\n    int[] newValues = getValues();\n    super.setFieldInto(newValues, field, value);\n    return new Period(newValues, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Creates a new Period instance with the specified field set to a new value.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param field  the field to set, not null\n * @param value  the value to set to\n * @return the new period instance\n * @throws IllegalArgumentException if the field type is null or unsupported\n */\n", "repo_name": "joda-time-main/", "id": 994, "method_signature": "Period withField(DurationFieldType, int)"}, "Period.withFieldAdded": {"callee_method_names": [], "method_name": "Period.withFieldAdded", "method_implementation": "{\n    if (field == null) {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (value == 0) {\n        return this;\n    }\n    // cloned\n    int[] newValues = getValues();\n    super.addFieldInto(newValues, field, value);\n    return new Period(newValues, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Creates a new Period instance with the valueToAdd added to the specified field.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param field  the field to set, not null\n * @param value  the value to add\n * @return the new period instance\n * @throws IllegalArgumentException if the field type is null or unsupported\n */\n", "repo_name": "joda-time-main/", "id": 995, "method_signature": "Period withFieldAdded(DurationFieldType, int)"}, "Period.withFields": {"callee_method_names": [], "method_name": "Period.withFields", "method_implementation": "{\n    if (period == null) {\n        return this;\n    }\n    // cloned\n    int[] newValues = getValues();\n    newValues = super.mergePeriodInto(newValues, period);\n    return new Period(newValues, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Creates a new Period instance with the fields from the specified period\n * copied on top of those from this period.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param period  the period to copy from, null ignored\n * @return the new period instance\n * @throws IllegalArgumentException if a field type is unsupported\n */\n", "repo_name": "joda-time-main/", "id": 993, "method_signature": "Period withFields(ReadablePeriod)"}, "Period.withHours": {"callee_method_names": [], "method_name": "Period.withHours", "method_implementation": "{\n    // cloned\n    int[] values = getValues();\n    getPeriodType().setIndexedField(this, PeriodType.HOUR_INDEX, values, hours);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified number of hours.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param hours  the amount of hours to add, may be negative\n * @return the new period with the increased hours\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1000, "method_signature": "Period withHours(int)"}, "Period.withMillis": {"callee_method_names": [], "method_name": "Period.withMillis", "method_implementation": "{\n    // cloned\n    int[] values = getValues();\n    getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified number of millis.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param millis  the amount of millis to add, may be negative\n * @return the new period with the increased millis\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1003, "method_signature": "Period withMillis(int)"}, "Period.withMinutes": {"callee_method_names": [], "method_name": "Period.withMinutes", "method_implementation": "{\n    // cloned\n    int[] values = getValues();\n    getPeriodType().setIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified number of minutes.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param minutes  the amount of minutes to add, may be negative\n * @return the new period with the increased minutes\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1001, "method_signature": "Period withMinutes(int)"}, "Period.withMonths": {"callee_method_names": [], "method_name": "Period.withMonths", "method_implementation": "{\n    // cloned\n    int[] values = getValues();\n    getPeriodType().setIndexedField(this, PeriodType.MONTH_INDEX, values, months);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified number of months.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param months  the amount of months to add, may be negative\n * @return the new period with the increased months\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 997, "method_signature": "Period withMonths(int)"}, "Period.withPeriodType": {"callee_method_ids": [231], "callee_method_names": ["PeriodType.equals"], "method_name": "Period.withPeriodType", "method_implementation": "{\n    type = DateTimeUtils.getPeriodType(type);\n    if (type.equals(getPeriodType())) {\n        return this;\n    }\n    return new Period(this, type);\n}", "repo_id": "7", "comment": "/**\n * Creates a new Period instance with the same field values but\n * different PeriodType.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param type  the period type to use, null means standard\n * @return the new period instance\n * @throws IllegalArgumentException if the new period won't accept all of the current fields\n */\n", "repo_name": "joda-time-main/", "id": 992, "method_signature": "Period withPeriodType(PeriodType)"}, "Period.withSeconds": {"callee_method_names": [], "method_name": "Period.withSeconds", "method_implementation": "{\n    // cloned\n    int[] values = getValues();\n    getPeriodType().setIndexedField(this, PeriodType.SECOND_INDEX, values, seconds);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified number of seconds.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param seconds  the amount of seconds to add, may be negative\n * @return the new period with the increased seconds\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 1002, "method_signature": "Period withSeconds(int)"}, "Period.withWeeks": {"callee_method_names": [], "method_name": "Period.withWeeks", "method_implementation": "{\n    // cloned\n    int[] values = getValues();\n    getPeriodType().setIndexedField(this, PeriodType.WEEK_INDEX, values, weeks);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified number of weeks.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param weeks  the amount of weeks to add, may be negative\n * @return the new period with the increased weeks\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 998, "method_signature": "Period withWeeks(int)"}, "Period.withYears": {"callee_method_names": [], "method_name": "Period.withYears", "method_implementation": "{\n    // cloned\n    int[] values = getValues();\n    getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n    return new Period(values, getPeriodType());\n}", "repo_id": "7", "comment": "/**\n * Returns a new period with the specified number of years.\n * <p>\n * This period instance is immutable and unaffected by this method call.\n *\n * @param years  the amount of years to add, may be negative\n * @return the new period with the increased years\n * @throws UnsupportedOperationException if the field is not supported\n */\n", "repo_name": "joda-time-main/", "id": 996, "method_signature": "Period withYears(int)"}, "PeriodFormat.buildWordBased": {"callee_method_names": [], "method_name": "PeriodFormat.buildWordBased", "method_implementation": "{\n    ResourceBundle b = ResourceBundle.getBundle(BUNDLE_NAME, locale);\n    if (containsKey(b, \"PeriodFormat.regex.separator\")) {\n        return buildRegExFormatter(b, locale);\n    } else {\n        return buildNonRegExFormatter(b, locale);\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 889, "method_signature": "PeriodFormatter buildWordBased(Locale)"}, "PeriodFormat.containsKey": {"callee_method_names": ["ResourceBundle.getKeys"], "method_name": "PeriodFormat.containsKey", "method_implementation": "{\n    for (Enumeration<String> en = bundle.getKeys(); en.hasMoreElements(); ) {\n        if (en.nextElement().equals(key)) {\n            return true;\n        }\n    }\n    return false;\n}", "repo_id": "7", "comment": "// simulate ResourceBundle.containsKey()\n", "repo_name": "joda-time-main/", "id": 890, "method_signature": "boolean containsKey(ResourceBundle, String)"}, "PeriodFormat.wordBased": {"callee_method_names": ["ConcurrentHashMap.get", "ConcurrentHashMap.putIfAbsent"], "method_name": "PeriodFormat.wordBased", "method_implementation": "{\n    PeriodFormatter pf = FORMATTERS.get(locale);\n    if (pf == null) {\n        DynamicWordBased dynamic = new DynamicWordBased(buildWordBased(locale));\n        pf = new PeriodFormatter(dynamic, dynamic, locale, null);\n        PeriodFormatter existing = FORMATTERS.putIfAbsent(locale, pf);\n        if (existing != null) {\n            pf = existing;\n        }\n    }\n    return pf;\n}", "repo_id": "7", "comment": "/**\n * Returns a word based formatter for the specified locale.\n * <p>\n * The words are configured in a resource bundle text file -\n * {@code org.joda.time.format.messages}.\n * This can be added to via the normal classpath resource bundle mechanisms.\n * <p>\n * You can add your own translation by creating messages_<locale>.properties file\n * and adding it to the {@code org.joda.time.format.messages} path.\n * <p>\n * Simple example (1 -> singular suffix, not 1 -> plural suffix):\n *\n * <pre>\n * PeriodFormat.space=\\\n * PeriodFormat.comma=,\n * PeriodFormat.commandand=,and\n * PeriodFormat.commaspaceand=, and\n * PeriodFormat.commaspace=,\n * PeriodFormat.spaceandspace=\\ and\n * PeriodFormat.year=\\ year\n * PeriodFormat.years=\\ years\n * PeriodFormat.month=\\ month\n * PeriodFormat.months=\\ months\n * PeriodFormat.week=\\ week\n * PeriodFormat.weeks=\\ weeks\n * PeriodFormat.day=\\ day\n * PeriodFormat.days=\\ days\n * PeriodFormat.hour=\\ hour\n * PeriodFormat.hours=\\ hours\n * PeriodFormat.minute=\\ minute\n * PeriodFormat.minutes=\\ minutes\n * PeriodFormat.second=\\ second\n * PeriodFormat.seconds=\\ seconds\n * PeriodFormat.millisecond=\\ millisecond\n * PeriodFormat.milliseconds=\\ milliseconds\n * </pre>\n *\n * <p>\n * Some languages contain more than two suffixes. You can use regular expressions\n * for them. Here's an example using regular expression for English:\n *\n * <pre>\n * PeriodFormat.space=\\\n * PeriodFormat.comma=,\n * PeriodFormat.commandand=,and\n * PeriodFormat.commaspaceand=, and\n * PeriodFormat.commaspace=,\n * PeriodFormat.spaceandspace=\\ and\n * PeriodFormat.regex.separator=%\n * PeriodFormat.years.regex=1$%.*\n * PeriodFormat.years.list=\\ year%\\ years\n * PeriodFormat.months.regex=1$%.*\n * PeriodFormat.months.list=\\ month%\\ months\n * PeriodFormat.weeks.regex=1$%.*\n * PeriodFormat.weeks.list=\\ week%\\ weeks\n * PeriodFormat.days.regex=1$%.*\n * PeriodFormat.days.list=\\ day%\\ days\n * PeriodFormat.hours.regex=1$%.*\n * PeriodFormat.hours.list=\\ hour%\\ hours\n * PeriodFormat.minutes.regex=1$%.*\n * PeriodFormat.minutes.list=\\ minute%\\ minutes\n * PeriodFormat.seconds.regex=1$%.*\n * PeriodFormat.seconds.list=\\ second%\\ seconds\n * PeriodFormat.milliseconds.regex=1$%.*\n * PeriodFormat.milliseconds.list=\\ millisecond%\\ milliseconds\n * </pre>\n *\n * <p>\n * You can mix both approaches. Here's example for Polish (\n * \"1 year, 2 years, 5 years, 12 years, 15 years, 21 years, 22 years, 25 years\"\n * translates to\n * \"1 rok, 2 lata, 5 lat, 12 lat, 15 lat, 21 lat, 22 lata, 25 lat\"). Notice that\n * PeriodFormat.day and PeriodFormat.days is used for day suffixes as there is no\n * need for regular expressions:\n *\n * <pre>\n * PeriodFormat.space=\\\n * PeriodFormat.comma=,\n * PeriodFormat.commandand=,i\n * PeriodFormat.commaspaceand=, i\n * PeriodFormat.commaspace=,\n * PeriodFormat.spaceandspace=\\ i\n * PeriodFormat.regex.separator=%\n * PeriodFormat.years.regex=^1$%[0-9]*(?&lt;!1)[2-4]$%[0-9]*\n * PeriodFormat.years.list=\\ rok%\\ lata%\\ lat\n * PeriodFormat.months.regex=^1$%[0-9]*(?&lt;!1)[2-4]$%[0-9]*\n * PeriodFormat.months.list=\\ miesi\\u0105c%\\ miesi\\u0105ce%\\ miesi\\u0119cy\n * PeriodFormat.weeks.regex=^1$%[0-9]*(?&lt;!1)[2-4]$%[0-9]*\n * PeriodFormat.weeks.list=\\ tydzie\\u0144%\\ tygodnie%\\ tygodni\n * PeriodFormat.day=\\ dzie\\u0144\n * PeriodFormat.days=\\ dni\n * PeriodFormat.hours.regex=^1$%[0-9]*(?&lt;!1)[2-4]$%[0-9]*\n * PeriodFormat.hours.list=\\ godzina%\\ godziny%\\ godzin\n * PeriodFormat.minutes.regex=^1$%[0-9]*(?&lt;!1)[2-4]$%[0-9]*\n * PeriodFormat.minutes.list=\\ minuta%\\ minuty%\\ minut\n * PeriodFormat.seconds.regex=^1$%[0-9]*(?&lt;!1)[2-4]$%[0-9]*\n * PeriodFormat.seconds.list=\\ sekunda%\\ sekundy%\\ sekund\n * PeriodFormat.milliseconds.regex=^1$%[0-9]*(?&lt;!1)[2-4]$%[0-9]*\n * PeriodFormat.milliseconds.list=\\ milisekunda%\\ milisekundy%\\ milisekund\n * </pre>\n *\n * <p>\n * Each PeriodFormat.&lt;duration_field_type&gt;.regex property stands for an array of\n * regular expressions and is followed by a property\n * PeriodFormat.&lt;duration_field_type&gt;.list holding an array of suffixes.\n * PeriodFormat.regex.separator is used for splitting. See\n * {@link PeriodFormatterBuilder#appendSuffix(String[], String[])} for details.\n * <p>\n * Available languages are English, Danish, Dutch, French, German, Japanese,\n * Polish, Portuguese and Spanish.\n *\n * @param locale the locale\n * @return the formatter, not null\n * @since 2.0, regex since 2.5\n */\n", "repo_name": "joda-time-main/", "id": 888, "method_signature": "PeriodFormatter wordBased(Locale)"}, "PeriodFormatter.checkParser": {"callee_method_names": [], "method_name": "PeriodFormatter.checkParser", "method_implementation": "{\n    if (iParser == null) {\n        throw new UnsupportedOperationException(\"Parsing not supported\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether parsing is supported.\n *\n * @throws UnsupportedOperationException if parsing is not supported\n */\n", "repo_name": "joda-time-main/", "id": 910, "method_signature": "void checkParser()"}, "PeriodFormatter.checkPeriod": {"callee_method_names": [], "method_name": "PeriodFormatter.checkPeriod", "method_implementation": "{\n    if (period == null) {\n        throw new IllegalArgumentException(\"Period must not be null\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether the period is non-null.\n *\n * @throws IllegalArgumentException if the period is null\n */\n", "repo_name": "joda-time-main/", "id": 906, "method_signature": "void checkPeriod(ReadablePeriod)"}, "PeriodFormatter.checkPrinter": {"callee_method_names": [], "method_name": "PeriodFormatter.checkPrinter", "method_implementation": "{\n    if (iPrinter == null) {\n        throw new UnsupportedOperationException(\"Printing not supported\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Checks whether printing is supported.\n *\n * @throws UnsupportedOperationException if printing is not supported\n */\n", "repo_name": "joda-time-main/", "id": 905, "method_signature": "void checkPrinter()"}, "PeriodFormatter.parseInto": {"callee_method_names": [], "method_name": "PeriodFormatter.parseInto", "method_implementation": "{\n    checkParser();\n    checkPeriod(period);\n    return getParser().parseInto(period, text, position, iLocale);\n}", "repo_id": "7", "comment": "/**\n * Parses a period from the given text, at the given position, saving the\n * result into the fields of the given ReadWritablePeriod. If the parse\n * succeeds, the return value is the new text position. Note that the parse\n * may succeed without fully reading the text.\n * <p>\n * The parse type of the formatter is not used by this method.\n * <p>\n * If it fails, the return value is negative, but the period may still be\n * modified. To determine the position where the parse failed, apply the\n * one's complement operator (~) on the return value.\n *\n * @param period  a period that will be modified\n * @param text  text to parse\n * @param position position to start parsing from\n * @return new position, if negative, parse failed. Apply complement\n * operator (~) to get position of failure\n * @throws IllegalArgumentException if any field is out of range\n */\n", "repo_name": "joda-time-main/", "id": 907, "method_signature": "int parseInto(ReadWritablePeriod, String, int)"}, "PeriodFormatter.parseMutablePeriod": {"callee_method_names": ["String.length"], "method_name": "PeriodFormatter.parseMutablePeriod", "method_implementation": "{\n    checkParser();\n    MutablePeriod period = new MutablePeriod(0, iParseType);\n    int newPos = getParser().parseInto(period, text, 0, iLocale);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return period;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}", "repo_id": "7", "comment": "/**\n * Parses a period from the given text, returning a new MutablePeriod.\n *\n * @param text  text to parse\n * @return parsed value in a MutablePeriod object\n * @throws IllegalArgumentException if any field is out of range\n */\n", "repo_name": "joda-time-main/", "id": 909, "method_signature": "MutablePeriod parseMutablePeriod(String)"}, "PeriodFormatter.parsePeriod": {"callee_method_names": [], "method_name": "PeriodFormatter.parsePeriod", "method_implementation": "{\n    checkParser();\n    return parseMutablePeriod(text).toPeriod();\n}", "repo_id": "7", "comment": "/**\n * Parses a period from the given text, returning a new Period.\n *\n * @param text  text to parse\n * @return parsed value in a Period object\n * @throws IllegalArgumentException if any field is out of range\n */\n", "repo_name": "joda-time-main/", "id": 908, "method_signature": "Period parsePeriod(String)"}, "PeriodFormatter.print": {"callee_method_names": ["PeriodPrinter.calculatePrintedLength", "PeriodPrinter.printTo", "StringBuffer.toString"], "method_name": "PeriodFormatter.print", "method_implementation": "{\n    checkPrinter();\n    checkPeriod(period);\n    PeriodPrinter printer = getPrinter();\n    StringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale));\n    printer.printTo(buf, period, iLocale);\n    return buf.toString();\n}", "repo_id": "7", "comment": "/**\n * Prints a ReadablePeriod to a new String.\n *\n * @param period  the period to format, not null\n * @return the printed result\n */\n", "repo_name": "joda-time-main/", "id": 904, "method_signature": "String print(ReadablePeriod)"}, "PeriodFormatter.printTo": {"callee_method_names": [], "method_name": "PeriodFormatter.printTo", "method_implementation": "{\n    checkPrinter();\n    checkPeriod(period);\n    getPrinter().printTo(out, period, iLocale);\n}", "repo_id": "7", "comment": "/**\n * Prints a ReadablePeriod to a Writer.\n *\n * @param out  the formatted period is written out\n * @param period  the period to format, not null\n * @throws IOException if an IO error occurs\n */\n", "repo_name": "joda-time-main/", "id": 903, "method_signature": "void printTo(Writer, ReadablePeriod)"}, "PeriodFormatter.withLocale": {"callee_method_names": ["Locale.equals"], "method_name": "PeriodFormatter.withLocale", "method_implementation": "{\n    if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\n        return this;\n    }\n    return new PeriodFormatter(iPrinter, iParser, locale, iParseType);\n}", "repo_id": "7", "comment": "/**\n * Returns a new formatter with a different locale that will be used\n * for printing and parsing.\n * <p>\n * A PeriodFormatter is immutable, so a new instance is returned,\n * and the original is unaltered and still usable.\n * <p>\n * A null locale indicates that no specific locale override is in use.\n *\n * @param locale  the locale to use\n * @return the new formatter\n */\n", "repo_name": "joda-time-main/", "id": 900, "method_signature": "PeriodFormatter withLocale(Locale)"}, "PeriodFormatter.withParseType": {"callee_method_names": [], "method_name": "PeriodFormatter.withParseType", "method_implementation": "{\n    if (type == iParseType) {\n        return this;\n    }\n    return new PeriodFormatter(iPrinter, iParser, iLocale, type);\n}", "repo_id": "7", "comment": "/**\n * Returns a new formatter with a different PeriodType for parsing.\n * <p>\n * A PeriodFormatter is immutable, so a new instance is returned,\n * and the original is unaltered and still usable.\n *\n * @param type  the type to use in parsing\n * @return the new formatter\n */\n", "repo_name": "joda-time-main/", "id": 901, "method_signature": "PeriodFormatter withParseType(PeriodType)"}, "PeriodFormatterBuilder.append": {"callee_method_names": [], "method_name": "PeriodFormatterBuilder.append", "method_implementation": "{\n    if (printer == null && parser == null) {\n        throw new IllegalArgumentException(\"No printer or parser supplied\");\n    }\n    clearPrefix();\n    append0(printer, parser);\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Appends a printer parser pair.\n * <p>\n * Either the printer or the parser may be null, in which case the builder will\n * be unable to produce a parser or printer respectively.\n *\n * @param printer  appends a printer to the builder, null if printing is not supported\n * @param parser  appends a parser to the builder, null if parsing is not supported\n * @return this PeriodFormatterBuilder\n * @throws IllegalArgumentException if both the printer and parser are null\n */\n", "repo_name": "joda-time-main/", "id": 869, "method_signature": "PeriodFormatterBuilder append(PeriodPrinter, PeriodParser)"}, "PeriodFormatterBuilder.appendLiteral": {"callee_method_names": [], "method_name": "PeriodFormatterBuilder.appendLiteral", "method_implementation": "{\n    if (text == null) {\n        throw new IllegalArgumentException(\"Literal must not be null\");\n    }\n    clearPrefix();\n    Literal literal = new Literal(text);\n    append0(literal, literal);\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Instructs the printer to emit specific text, and the parser to expect it.\n * The parser is case-insensitive.\n *\n * @param text the text to append\n * @return this PeriodFormatterBuilder\n * @throws IllegalArgumentException if text is null\n */\n", "repo_name": "joda-time-main/", "id": 870, "method_signature": "PeriodFormatterBuilder appendLiteral(String)"}, "PeriodFormatterBuilder.appendPrefix": {"callee_method_names": [], "method_name": "PeriodFormatterBuilder.appendPrefix", "method_implementation": "{\n    if (prefix == null) {\n        throw new IllegalArgumentException();\n    }\n    if (iPrefix != null) {\n        prefix = new CompositeAffix(iPrefix, prefix);\n    }\n    iPrefix = prefix;\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Append a field prefix which applies only to the next appended field. If\n * the field is not printed, neither is the prefix.\n *\n * @param prefix custom prefix\n * @return this PeriodFormatterBuilder\n * @see #appendSuffix\n */\n", "repo_name": "joda-time-main/", "id": 874, "method_signature": "PeriodFormatterBuilder appendPrefix(PeriodFieldAffix)"}, "PeriodFormatterBuilder.appendSuffix": {"callee_method_names": ["List<Object>.size", "List<Object>.get", "List<Object>.size", "List<Object>.get", "List<Object>.size", "List<Object>.set", "List<Object>.size", "List<Object>.set", "List<Object>.size", "FieldFormatter.getFieldType"], "method_name": "PeriodFormatterBuilder.appendSuffix", "method_implementation": "{\n    final Object originalPrinter;\n    final Object originalParser;\n    if (iElementPairs.size() > 0) {\n        originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n        originalParser = iElementPairs.get(iElementPairs.size() - 1);\n    } else {\n        originalPrinter = null;\n        originalParser = null;\n    }\n    if (originalPrinter == null || originalParser == null || originalPrinter != originalParser || !(originalPrinter instanceof FieldFormatter)) {\n        throw new IllegalStateException(\"No field to apply suffix to\");\n    }\n    clearPrefix();\n    FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n    iElementPairs.set(iElementPairs.size() - 2, newField);\n    iElementPairs.set(iElementPairs.size() - 1, newField);\n    iFieldFormatters[newField.getFieldType()] = newField;\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Append a field suffix which applies only to the last appended field. If\n * the field is not printed, neither is the suffix.\n *\n * @param suffix custom suffix\n * @return this PeriodFormatterBuilder\n * @throws IllegalStateException if no field exists to append to\n * @see #appendPrefix\n */\n", "repo_name": "joda-time-main/", "id": 878, "method_signature": "PeriodFormatterBuilder appendSuffix(PeriodFieldAffix)"}, "PeriodFormatterBuilder.clear": {"callee_method_names": ["List<Object>.clear"], "method_name": "PeriodFormatterBuilder.clear", "method_implementation": "{\n    iMinPrintedDigits = 1;\n    iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n    iMaxParsedDigits = 10;\n    iRejectSignedValues = false;\n    iPrefix = null;\n    if (iElementPairs == null) {\n        iElementPairs = new ArrayList<Object>();\n    } else {\n        iElementPairs.clear();\n    }\n    iNotPrinter = false;\n    iNotParser = false;\n    iFieldFormatters = new FieldFormatter[10];\n}", "repo_id": "7", "comment": "/**\n * Clears out all the appended elements, allowing this builder to be reused.\n */\n", "repo_name": "joda-time-main/", "id": 867, "method_signature": "void clear()"}, "PeriodFormatterBuilder.clearPrefix": {"callee_method_names": [], "method_name": "PeriodFormatterBuilder.clearPrefix", "method_implementation": "{\n    if (iPrefix != null) {\n        throw new IllegalStateException(\"Prefix not followed by field\");\n    }\n    iPrefix = null;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 879, "method_signature": "void clearPrefix()"}, "PeriodFormatterBuilder.getFieldValue": {"callee_method_names": ["ReadablePeriod.getPeriodType", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get", "ReadablePeriod.get"], "method_name": "PeriodFormatterBuilder.getFieldValue", "method_implementation": "{\n    PeriodType type;\n    if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n        // Don't need to check if supported.\n        type = null;\n    } else {\n        type = period.getPeriodType();\n    }\n    if (type != null && isSupported(type, iFieldType) == false) {\n        return Long.MAX_VALUE;\n    }\n    long value;\n    switch(iFieldType) {\n        default:\n            return Long.MAX_VALUE;\n        case YEARS:\n            value = period.get(DurationFieldType.years());\n            break;\n        case MONTHS:\n            value = period.get(DurationFieldType.months());\n            break;\n        case WEEKS:\n            value = period.get(DurationFieldType.weeks());\n            break;\n        case DAYS:\n            value = period.get(DurationFieldType.days());\n            break;\n        case HOURS:\n            value = period.get(DurationFieldType.hours());\n            break;\n        case MINUTES:\n            value = period.get(DurationFieldType.minutes());\n            break;\n        case SECONDS:\n            value = period.get(DurationFieldType.seconds());\n            break;\n        case MILLIS:\n            value = period.get(DurationFieldType.millis());\n            break;\n        // drop through\n        case SECONDS_MILLIS:\n        case SECONDS_OPTIONAL_MILLIS:\n            int seconds = period.get(DurationFieldType.seconds());\n            int millis = period.get(DurationFieldType.millis());\n            value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n            break;\n    }\n    // determine if period is zero and this is the last field\n    if (value == 0) {\n        switch(iPrintZeroSetting) {\n            case PRINT_ZERO_NEVER:\n                return Long.MAX_VALUE;\n            case PRINT_ZERO_RARELY_LAST:\n                if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                    for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                        if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                            return Long.MAX_VALUE;\n                        }\n                    }\n                } else {\n                    return Long.MAX_VALUE;\n                }\n                break;\n            case PRINT_ZERO_RARELY_FIRST:\n                if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                    // line split out for IBM JDK\n                    int i = Math.min(iFieldType, 8);\n                    // see bug 1660490\n                    i--;\n                    for (; i >= 0; i--) {\n                        if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                            return Long.MAX_VALUE;\n                        }\n                    }\n                } else {\n                    return Long.MAX_VALUE;\n                }\n                break;\n        }\n    }\n    return value;\n}", "repo_id": "7", "comment": "/**\n * @return Long.MAX_VALUE if nothing to print, otherwise value\n */\n", "repo_name": "joda-time-main/", "id": 883, "method_signature": "long getFieldValue(ReadablePeriod)"}, "PeriodFormatterBuilder.matchesOtherAffix": {"callee_method_names": ["String.regionMatches", "String.regionMatches"], "method_name": "PeriodFormatterBuilder.matchesOtherAffix", "method_implementation": "{\n    if (iOtherAffixes != null) {\n        // ignore case when affix length differs\n        // match case when affix length is same\n        for (String affixToIgnore : iOtherAffixes) {\n            int textToIgnoreLength = affixToIgnore.length();\n            if ((textLength < textToIgnoreLength && periodStr.regionMatches(true, position, affixToIgnore, 0, textToIgnoreLength)) || (textLength == textToIgnoreLength && periodStr.regionMatches(false, position, affixToIgnore, 0, textToIgnoreLength))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Checks if there is a match among the other affixes (stored internally)\n * that is longer than the passed value (textLength).\n *\n * @param textLength  the length of the match\n * @param periodStr  the Period string that will be parsed\n * @param position  the position in the Period string at which the parsing should be started.\n * @return true if the other affixes (stored internally) contain a match\n *  that is longer than the textLength parameter, false otherwise\n */\n", "repo_name": "joda-time-main/", "id": 881, "method_signature": "boolean matchesOtherAffix(int, String, int)"}, "PeriodFormatterBuilder.parseInt": {"callee_method_names": ["String.substring", "String.charAt", "String.charAt", "String.charAt"], "method_name": "PeriodFormatterBuilder.parseInt", "method_implementation": "{\n    if (length >= 10) {\n        // Since value may exceed max, use stock parser which checks for this.\n        return Integer.parseInt(text.substring(position, position + length));\n    }\n    if (length <= 0) {\n        return 0;\n    }\n    int value = text.charAt(position++);\n    length--;\n    boolean negative;\n    if (value == '-') {\n        if (--length < 0) {\n            return 0;\n        }\n        negative = true;\n        value = text.charAt(position++);\n    } else {\n        negative = false;\n    }\n    value -= '0';\n    while (length-- > 0) {\n        value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n    }\n    return negative ? -value : value;\n}", "repo_id": "7", "comment": "/**\n * @param text text to parse\n * @param position position in text\n * @param length exact count of characters to parse\n * @return parsed int value\n */\n", "repo_name": "joda-time-main/", "id": 882, "method_signature": "int parseInt(String, int, int)"}, "PeriodFormatterBuilder.toFormatter": {"callee_method_names": ["List<Object>.size", "List<Object>.get", "List<Object>.get", "List<Object>.subList", "Separator.finish", "PeriodFormatter.getPrinter", "PeriodFormatter.getParser"], "method_name": "PeriodFormatterBuilder.toFormatter", "method_implementation": "{\n    if (notPrinter && notParser) {\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n    }\n    int size = elementPairs.size();\n    if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n        Separator sep = (Separator) elementPairs.get(0);\n        if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n            PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n            sep = sep.finish(f.getPrinter(), f.getParser());\n            return new PeriodFormatter(sep, sep);\n        }\n    }\n    Object[] comp = createComposite(elementPairs);\n    if (notPrinter) {\n        return new PeriodFormatter(null, (PeriodParser) comp[1]);\n    } else if (notParser) {\n        return new PeriodFormatter((PeriodPrinter) comp[0], null);\n    } else {\n        return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 880, "method_signature": "PeriodFormatter toFormatter(List, boolean, boolean)"}, "PeriodFormatterBuilder.toParser": {"callee_method_names": [], "method_name": "PeriodFormatterBuilder.toParser", "method_implementation": "{\n    if (iNotParser) {\n        return null;\n    }\n    return toFormatter().getParser();\n}", "repo_id": "7", "comment": "/**\n * Internal method to create a PeriodParser instance using all the\n * appended elements.\n * <p>\n * Most applications will not use this method.\n * If you want a printer in an application, call {@link #toFormatter()}\n * and just use the printing API.\n * <p>\n * Subsequent changes to this builder do not affect the returned parser.\n *\n * @return the newly created parser, null if builder cannot create a parser\n */\n", "repo_name": "joda-time-main/", "id": 866, "method_signature": "PeriodParser toParser()"}, "PeriodFormatterBuilder.toPrinter": {"callee_method_names": [], "method_name": "PeriodFormatterBuilder.toPrinter", "method_implementation": "{\n    if (iNotPrinter) {\n        return null;\n    }\n    return toFormatter().getPrinter();\n}", "repo_id": "7", "comment": "/**\n * Internal method to create a PeriodPrinter instance using all the\n * appended elements.\n * <p>\n * Most applications will not use this method.\n * If you want a printer in an application, call {@link #toFormatter()}\n * and just use the printing API.\n * <p>\n * Subsequent changes to this builder do not affect the returned printer.\n *\n * @return the newly created printer, null if builder cannot create a printer\n */\n", "repo_name": "joda-time-main/", "id": 865, "method_signature": "PeriodPrinter toPrinter()"}, "PeriodType.addIndexedField": {"callee_method_names": [], "method_name": "PeriodType.addIndexedField", "method_implementation": "{\n    if (valueToAdd == 0) {\n        return false;\n    }\n    int realIndex = iIndices[index];\n    if (realIndex == -1) {\n        throw new UnsupportedOperationException(\"Field is not supported\");\n    }\n    values[realIndex] = FieldUtils.safeAdd(values[realIndex], valueToAdd);\n    return true;\n}", "repo_id": "7", "comment": "/**\n * Adds to the indexed field part of the period.\n *\n * @param period  the period to query\n * @param index  the index to use\n * @param values  the array to populate\n * @param valueToAdd  the value to add\n * @return true if the array is updated\n * @throws UnsupportedOperationException if not supported\n */\n", "repo_name": "joda-time-main/", "id": 229, "method_signature": "boolean addIndexedField(ReadablePeriod, int, int[], int)"}, "PeriodType.dayTime": {"callee_method_names": [], "method_name": "PeriodType.dayTime", "method_implementation": "{\n    PeriodType type = cDTime;\n    if (type == null) {\n        type = new PeriodType(\"DayTime\", new DurationFieldType[] { DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, 0, 1, 2, 3, 4 });\n        cDTime = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines all standard fields from days downwards.\n * <ul>\n * <li>days\n * <li>hours\n * <li>minutes\n * <li>seconds\n * <li>milliseconds\n * </ul>\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 216, "method_signature": "PeriodType dayTime()"}, "PeriodType.days": {"callee_method_names": [], "method_name": "PeriodType.days", "method_implementation": "{\n    PeriodType type = cDays;\n    if (type == null) {\n        type = new PeriodType(\"Days\", new DurationFieldType[] { DurationFieldType.days() }, new int[] { -1, -1, -1, 0, -1, -1, -1, -1 });\n        cDays = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines just the days field.\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 221, "method_signature": "PeriodType days()"}, "PeriodType.equals": {"callee_method_names": [], "method_name": "PeriodType.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof PeriodType == false) {\n        return false;\n    }\n    PeriodType other = (PeriodType) obj;\n    return (Arrays.equals(iTypes, other.iTypes));\n}", "repo_id": "7", "comment": "/**\n * Compares this type to another object.\n * To be equal, the object must be a PeriodType with the same set of fields.\n *\n * @param obj  the object to compare to\n * @return true if equal\n */\n", "repo_name": "joda-time-main/", "id": 231, "method_signature": "boolean equals(Object)"}, "PeriodType.forFields": {"callee_method_names": ["Map<PeriodType, Object>.isEmpty", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.get", "List<DurationFieldType>.remove", "PeriodType.withYearsRemoved", "List<DurationFieldType>.remove", "PeriodType.withMonthsRemoved", "List<DurationFieldType>.remove", "PeriodType.withWeeksRemoved", "List<DurationFieldType>.remove", "PeriodType.withDaysRemoved", "List<DurationFieldType>.remove", "PeriodType.withHoursRemoved", "List<DurationFieldType>.remove", "PeriodType.withMinutesRemoved", "List<DurationFieldType>.remove", "PeriodType.withSecondsRemoved", "List<DurationFieldType>.remove", "PeriodType.withMillisRemoved", "List<DurationFieldType>.size", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.get", "Map<PeriodType, Object>.put", "Map<PeriodType, Object>.put"], "method_name": "PeriodType.forFields", "method_implementation": "{\n    if (types == null || types.length == 0) {\n        throw new IllegalArgumentException(\"Types array must not be null or empty\");\n    }\n    for (int i = 0; i < types.length; i++) {\n        if (types[i] == null) {\n            throw new IllegalArgumentException(\"Types array must not contain null\");\n        }\n    }\n    Map<PeriodType, Object> cache = cTypes;\n    if (cache.isEmpty()) {\n        cache.put(standard(), standard());\n        cache.put(yearMonthDayTime(), yearMonthDayTime());\n        cache.put(yearMonthDay(), yearMonthDay());\n        cache.put(yearWeekDayTime(), yearWeekDayTime());\n        cache.put(yearWeekDay(), yearWeekDay());\n        cache.put(yearDayTime(), yearDayTime());\n        cache.put(yearDay(), yearDay());\n        cache.put(dayTime(), dayTime());\n        cache.put(time(), time());\n        cache.put(years(), years());\n        cache.put(months(), months());\n        cache.put(weeks(), weeks());\n        cache.put(days(), days());\n        cache.put(hours(), hours());\n        cache.put(minutes(), minutes());\n        cache.put(seconds(), seconds());\n        cache.put(millis(), millis());\n    }\n    PeriodType inPartType = new PeriodType(null, types, null);\n    Object cached = cache.get(inPartType);\n    if (cached instanceof PeriodType) {\n        return (PeriodType) cached;\n    }\n    if (cached != null) {\n        throw new IllegalArgumentException(\"PeriodType does not support fields: \" + cached);\n    }\n    PeriodType type = standard();\n    List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types));\n    if (list.remove(DurationFieldType.years()) == false) {\n        type = type.withYearsRemoved();\n    }\n    if (list.remove(DurationFieldType.months()) == false) {\n        type = type.withMonthsRemoved();\n    }\n    if (list.remove(DurationFieldType.weeks()) == false) {\n        type = type.withWeeksRemoved();\n    }\n    if (list.remove(DurationFieldType.days()) == false) {\n        type = type.withDaysRemoved();\n    }\n    if (list.remove(DurationFieldType.hours()) == false) {\n        type = type.withHoursRemoved();\n    }\n    if (list.remove(DurationFieldType.minutes()) == false) {\n        type = type.withMinutesRemoved();\n    }\n    if (list.remove(DurationFieldType.seconds()) == false) {\n        type = type.withSecondsRemoved();\n    }\n    if (list.remove(DurationFieldType.millis()) == false) {\n        type = type.withMillisRemoved();\n    }\n    if (list.size() > 0) {\n        cache.put(inPartType, list);\n        throw new IllegalArgumentException(\"PeriodType does not support fields: \" + list);\n    }\n    // recheck cache in case initial array order was wrong\n    PeriodType checkPartType = new PeriodType(null, type.iTypes, null);\n    PeriodType checkedType = (PeriodType) cache.get(checkPartType);\n    if (checkedType != null) {\n        cache.put(checkPartType, checkedType);\n        return checkedType;\n    }\n    cache.put(checkPartType, type);\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a period type that contains the duration types of the array.\n * <p>\n * Only the 8 standard duration field types are supported.\n *\n * @param types  the types to include in the array.\n * @return the period type\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 226, "method_signature": "PeriodType forFields(DurationFieldType[])"}, "PeriodType.hashCode": {"callee_method_names": ["DurationFieldType[].hashCode"], "method_name": "PeriodType.hashCode", "method_implementation": "{\n    int hash = 0;\n    for (int i = 0; i < iTypes.length; i++) {\n        hash += iTypes[i].hashCode();\n    }\n    return hash;\n}", "repo_id": "7", "comment": "/**\n * Returns a hashcode based on the field types.\n *\n * @return a suitable hashcode\n */\n", "repo_name": "joda-time-main/", "id": 232, "method_signature": "int hashCode()"}, "PeriodType.hours": {"callee_method_names": [], "method_name": "PeriodType.hours", "method_implementation": "{\n    PeriodType type = cHours;\n    if (type == null) {\n        type = new PeriodType(\"Hours\", new DurationFieldType[] { DurationFieldType.hours() }, new int[] { -1, -1, -1, -1, 0, -1, -1, -1 });\n        cHours = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines just the hours field.\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 222, "method_signature": "PeriodType hours()"}, "PeriodType.indexOf": {"callee_method_names": ["DurationFieldType[].equals"], "method_name": "PeriodType.indexOf", "method_implementation": "{\n    for (int i = 0, isize = size(); i < isize; i++) {\n        if (iTypes[i].equals(type)) {\n            return i;\n        }\n    }\n    return -1;\n}", "repo_id": "7", "comment": "/**\n * Gets the index of the field in this period.\n *\n * @param type  the type to check, may be null which returns -1\n * @return the index of -1 if not supported\n */\n", "repo_name": "joda-time-main/", "id": 227, "method_signature": "int indexOf(DurationFieldType)"}, "PeriodType.millis": {"callee_method_names": [], "method_name": "PeriodType.millis", "method_implementation": "{\n    PeriodType type = cMillis;\n    if (type == null) {\n        type = new PeriodType(\"Millis\", new DurationFieldType[] { DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, -1, -1, -1, 0 });\n        cMillis = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines just the millis field.\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 225, "method_signature": "PeriodType millis()"}, "PeriodType.minutes": {"callee_method_names": [], "method_name": "PeriodType.minutes", "method_implementation": "{\n    PeriodType type = cMinutes;\n    if (type == null) {\n        type = new PeriodType(\"Minutes\", new DurationFieldType[] { DurationFieldType.minutes() }, new int[] { -1, -1, -1, -1, -1, 0, -1, -1 });\n        cMinutes = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines just the minutes field.\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 223, "method_signature": "PeriodType minutes()"}, "PeriodType.months": {"callee_method_names": [], "method_name": "PeriodType.months", "method_implementation": "{\n    PeriodType type = cMonths;\n    if (type == null) {\n        type = new PeriodType(\"Months\", new DurationFieldType[] { DurationFieldType.months() }, new int[] { -1, 0, -1, -1, -1, -1, -1, -1 });\n        cMonths = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines just the months field.\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 219, "method_signature": "PeriodType months()"}, "PeriodType.seconds": {"callee_method_names": [], "method_name": "PeriodType.seconds", "method_implementation": "{\n    PeriodType type = cSeconds;\n    if (type == null) {\n        type = new PeriodType(\"Seconds\", new DurationFieldType[] { DurationFieldType.seconds() }, new int[] { -1, -1, -1, -1, -1, -1, 0, -1 });\n        cSeconds = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines just the seconds field.\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 224, "method_signature": "PeriodType seconds()"}, "PeriodType.setIndexedField": {"callee_method_names": [], "method_name": "PeriodType.setIndexedField", "method_implementation": "{\n    int realIndex = iIndices[index];\n    if (realIndex == -1) {\n        throw new UnsupportedOperationException(\"Field is not supported\");\n    }\n    values[realIndex] = newValue;\n    return true;\n}", "repo_id": "7", "comment": "/**\n * Sets the indexed field part of the period.\n *\n * @param period  the period to query\n * @param index  the index to use\n * @param values  the array to populate\n * @param newValue  the value to set\n * @throws UnsupportedOperationException if not supported\n */\n", "repo_name": "joda-time-main/", "id": 228, "method_signature": "boolean setIndexedField(ReadablePeriod, int, int[], int)"}, "PeriodType.standard": {"callee_method_names": [], "method_name": "PeriodType.standard", "method_implementation": "{\n    PeriodType type = cStandard;\n    if (type == null) {\n        type = new PeriodType(\"Standard\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, 2, 3, 4, 5, 6, 7 });\n        cStandard = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines all standard fields.\n * <ul>\n * <li>years\n * <li>months\n * <li>weeks\n * <li>days\n * <li>hours\n * <li>minutes\n * <li>seconds\n * <li>milliseconds\n * </ul>\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 209, "method_signature": "PeriodType standard()"}, "PeriodType.time": {"callee_method_names": [], "method_name": "PeriodType.time", "method_implementation": "{\n    PeriodType type = cTime;\n    if (type == null) {\n        type = new PeriodType(\"Time\", new DurationFieldType[] { DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { -1, -1, -1, -1, 0, 1, 2, 3 });\n        cTime = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines all standard time fields.\n * <ul>\n * <li>hours\n * <li>minutes\n * <li>seconds\n * <li>milliseconds\n * </ul>\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 217, "method_signature": "PeriodType time()"}, "PeriodType.weeks": {"callee_method_names": [], "method_name": "PeriodType.weeks", "method_implementation": "{\n    PeriodType type = cWeeks;\n    if (type == null) {\n        type = new PeriodType(\"Weeks\", new DurationFieldType[] { DurationFieldType.weeks() }, new int[] { -1, -1, 0, -1, -1, -1, -1, -1 });\n        cWeeks = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines just the weeks field.\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 220, "method_signature": "PeriodType weeks()"}, "PeriodType.withFieldRemoved": {"callee_method_names": [], "method_name": "PeriodType.withFieldRemoved", "method_implementation": "{\n    int fieldIndex = iIndices[indicesIndex];\n    if (fieldIndex == -1) {\n        return this;\n    }\n    DurationFieldType[] types = new DurationFieldType[size() - 1];\n    for (int i = 0; i < iTypes.length; i++) {\n        if (i < fieldIndex) {\n            types[i] = iTypes[i];\n        } else if (i > fieldIndex) {\n            types[i - 1] = iTypes[i];\n        }\n    }\n    int[] indices = new int[8];\n    for (int i = 0; i < indices.length; i++) {\n        if (i < indicesIndex) {\n            indices[i] = iIndices[i];\n        } else if (i > indicesIndex) {\n            indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1);\n        } else {\n            indices[i] = -1;\n        }\n    }\n    return new PeriodType(getName() + name, types, indices);\n}", "repo_id": "7", "comment": "/**\n * Removes the field specified by indices index.\n *\n * @param indicesIndex  the index to remove\n * @param name  the name addition\n * @return the new type\n */\n", "repo_name": "joda-time-main/", "id": 230, "method_signature": "PeriodType withFieldRemoved(int, String)"}, "PeriodType.yearDay": {"callee_method_names": [], "method_name": "PeriodType.yearDay", "method_implementation": "{\n    PeriodType type = cYD;\n    if (type == null) {\n        type = new PeriodType(\"YearDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days() }, new int[] { 0, -1, -1, 1, -1, -1, -1, -1 });\n        cYD = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines the year and day fields.\n * <ul>\n * <li>years\n * <li>days\n * </ul>\n *\n * @return the period type\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 215, "method_signature": "PeriodType yearDay()"}, "PeriodType.yearDayTime": {"callee_method_names": [], "method_name": "PeriodType.yearDayTime", "method_implementation": "{\n    PeriodType type = cYDTime;\n    if (type == null) {\n        type = new PeriodType(\"YearDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, -1, 1, 2, 3, 4, 5 });\n        cYDTime = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines all standard fields except months and weeks.\n * <ul>\n * <li>years\n * <li>days\n * <li>hours\n * <li>minutes\n * <li>seconds\n * <li>milliseconds\n * </ul>\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 214, "method_signature": "PeriodType yearDayTime()"}, "PeriodType.yearMonthDay": {"callee_method_names": [], "method_name": "PeriodType.yearMonthDay", "method_implementation": "{\n    PeriodType type = cYMD;\n    if (type == null) {\n        type = new PeriodType(\"YearMonthDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days() }, new int[] { 0, 1, -1, 2, -1, -1, -1, -1 });\n        cYMD = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines the year, month and day fields.\n * <ul>\n * <li>years\n * <li>months\n * <li>days\n * </ul>\n *\n * @return the period type\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 211, "method_signature": "PeriodType yearMonthDay()"}, "PeriodType.yearMonthDayTime": {"callee_method_names": [], "method_name": "PeriodType.yearMonthDayTime", "method_implementation": "{\n    PeriodType type = cYMDTime;\n    if (type == null) {\n        type = new PeriodType(\"YearMonthDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.months(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, 1, -1, 2, 3, 4, 5, 6 });\n        cYMDTime = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines all standard fields except weeks.\n * <ul>\n * <li>years\n * <li>months\n * <li>days\n * <li>hours\n * <li>minutes\n * <li>seconds\n * <li>milliseconds\n * </ul>\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 210, "method_signature": "PeriodType yearMonthDayTime()"}, "PeriodType.yearWeekDay": {"callee_method_names": [], "method_name": "PeriodType.yearWeekDay", "method_implementation": "{\n    PeriodType type = cYWD;\n    if (type == null) {\n        type = new PeriodType(\"YearWeekDay\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days() }, new int[] { 0, -1, 1, 2, -1, -1, -1, -1 });\n        cYWD = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines year, week and day fields.\n * <ul>\n * <li>years\n * <li>weeks\n * <li>days\n * </ul>\n *\n * @return the period type\n * @since 1.1\n */\n", "repo_name": "joda-time-main/", "id": 213, "method_signature": "PeriodType yearWeekDay()"}, "PeriodType.yearWeekDayTime": {"callee_method_names": [], "method_name": "PeriodType.yearWeekDayTime", "method_implementation": "{\n    PeriodType type = cYWDTime;\n    if (type == null) {\n        type = new PeriodType(\"YearWeekDayTime\", new DurationFieldType[] { DurationFieldType.years(), DurationFieldType.weeks(), DurationFieldType.days(), DurationFieldType.hours(), DurationFieldType.minutes(), DurationFieldType.seconds(), DurationFieldType.millis() }, new int[] { 0, -1, 1, 2, 3, 4, 5, 6 });\n        cYWDTime = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines all standard fields except months.\n * <ul>\n * <li>years\n * <li>weeks\n * <li>days\n * <li>hours\n * <li>minutes\n * <li>seconds\n * <li>milliseconds\n * </ul>\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 212, "method_signature": "PeriodType yearWeekDayTime()"}, "PeriodType.years": {"callee_method_names": [], "method_name": "PeriodType.years", "method_implementation": "{\n    PeriodType type = cYears;\n    if (type == null) {\n        type = new PeriodType(\"Years\", new DurationFieldType[] { DurationFieldType.years() }, new int[] { 0, -1, -1, -1, -1, -1, -1, -1 });\n        cYears = type;\n    }\n    return type;\n}", "repo_id": "7", "comment": "/**\n * Gets a type that defines just the years field.\n *\n * @return the period type\n */\n", "repo_name": "joda-time-main/", "id": 218, "method_signature": "PeriodType years()"}, "PrecalculatedZone.create": {"callee_method_ids": [766], "callee_method_names": ["ArrayList<Transition>.size", "ArrayList<Transition>.get", "Transition.isTransitionFrom", "Transition.getMillis", "Transition.getWallOffset", "Transition.getStandardOffset", "Transition.getNameKey", "String.equals", "String.equals", "Period.getYears", "Period.getMonths", "Period.getMonths", "String.equals", "String.equals", "DSTZone.getNameKey", "DSTZone.getNameKey", "DSTZone.getNameKey", "DSTZone.getSaveMillis", "DSTZone.getID", "DSTZone.renameAppend", "DSTZone.getID", "DSTZone.renameAppend"], "method_name": "PrecalculatedZone.create", "method_implementation": "{\n    int size = transitions.size();\n    if (size == 0) {\n        throw new IllegalArgumentException();\n    }\n    long[] trans = new long[size];\n    int[] wallOffsets = new int[size];\n    int[] standardOffsets = new int[size];\n    String[] nameKeys = new String[size];\n    Transition last = null;\n    for (int i = 0; i < size; i++) {\n        Transition tr = transitions.get(i);\n        if (!tr.isTransitionFrom(last)) {\n            throw new IllegalArgumentException(id);\n        }\n        trans[i] = tr.getMillis();\n        wallOffsets[i] = tr.getWallOffset();\n        standardOffsets[i] = tr.getStandardOffset();\n        nameKeys[i] = tr.getNameKey();\n        last = tr;\n    }\n    // Some timezones (Australia) have the same name key for\n    // summer and winter which messes everything up. Fix it here.\n    String[] zoneNameData = new String[5];\n    String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n    for (int j = 0; j < zoneStrings.length; j++) {\n        String[] set = zoneStrings[j];\n        if (set != null && set.length == 5 && id.equals(set[0])) {\n            zoneNameData = set;\n        }\n    }\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    for (int i = 0; i < nameKeys.length - 1; i++) {\n        String curNameKey = nameKeys[i];\n        String nextNameKey = nameKeys[i + 1];\n        long curOffset = wallOffsets[i];\n        long nextOffset = wallOffsets[i + 1];\n        long curStdOffset = standardOffsets[i];\n        long nextStdOffset = standardOffsets[i + 1];\n        Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n        if (curOffset != nextOffset && curStdOffset == nextStdOffset && curNameKey.equals(nextNameKey) && p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 && curNameKey.equals(zoneNameData[2]) && curNameKey.equals(zoneNameData[4])) {\n            if (ZoneInfoLogger.verbose()) {\n                System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n                System.out.println(\"     - \" + new DateTime(trans[i], chrono) + \" - \" + new DateTime(trans[i + 1], chrono));\n            }\n            if (curOffset > nextOffset) {\n                nameKeys[i] = (curNameKey + \"-Summer\").intern();\n            } else {\n                nameKeys[i + 1] = (nextNameKey + \"-Summer\").intern();\n                i++;\n            }\n        }\n    }\n    if (tailZone != null) {\n        if (tailZone.iStartRecurrence.getNameKey().equals(tailZone.iEndRecurrence.getNameKey())) {\n            if (ZoneInfoLogger.verbose()) {\n                System.out.println(\"Fixing duplicate recurrent name key - \" + tailZone.iStartRecurrence.getNameKey());\n            }\n            if (tailZone.iStartRecurrence.getSaveMillis() > 0) {\n                tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence.renameAppend(\"-Summer\"), tailZone.iEndRecurrence);\n            } else {\n                tailZone = new DSTZone(tailZone.getID(), tailZone.iStandardOffset, tailZone.iStartRecurrence, tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n            }\n        }\n    }\n    return new PrecalculatedZone((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n}", "repo_id": "7", "comment": "/**\n * Factory to create instance from builder.\n *\n * @param id  the zone id\n * @param outputID  true if the zone id should be output\n * @param transitions  the list of Transition objects\n * @param tailZone  optional zone for getting info beyond precalculated tables\n */\n", "repo_name": "joda-time-main/", "id": 771, "method_signature": "PrecalculatedZone create(String, boolean, ArrayList, DSTZone)"}, "PreciseDateTimeField.addWrapField": {"callee_method_names": [], "method_name": "PreciseDateTimeField.addWrapField", "method_implementation": "{\n    int thisValue = get(instant);\n    int wrappedValue = FieldUtils.getWrappedValue(thisValue, amount, getMinimumValue(), getMaximumValue());\n    // copy code from set() to avoid repeat call to get()\n    return instant + (wrappedValue - thisValue) * getUnitMillis();\n}", "repo_id": "7", "comment": "/**\n * Add to the component of the specified time instant, wrapping around\n * within that component if necessary.\n *\n * @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to\n * @param amount  the amount of units to add (can be negative).\n * @return the updated time instant.\n */\n", "repo_name": "joda-time-main/", "id": 67, "method_signature": "long addWrapField(long, int)"}, "PreciseDateTimeField.get": {"callee_method_names": [], "method_name": "PreciseDateTimeField.get", "method_implementation": "{\n    if (instant >= 0) {\n        return (int) ((instant / getUnitMillis()) % iRange);\n    } else {\n        return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n    }\n}", "repo_id": "7", "comment": "/**\n * Get the amount of fractional units from the specified time instant.\n *\n * @param instant  the milliseconds from 1970-01-01T00:00:00Z to query\n * @return the amount of fractional units extracted from the input.\n */\n", "repo_name": "joda-time-main/", "id": 66, "method_signature": "int get(long)"}, "PreciseDateTimeField.set": {"callee_method_names": [], "method_name": "PreciseDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\n    return instant + (value - get(instant)) * iUnitMillis;\n}", "repo_id": "7", "comment": "/**\n * Set the specified amount of units to the specified time instant.\n *\n * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n * @param value  value of units to set.\n * @return the updated time instant.\n * @throws IllegalArgumentException if value is too large or too small.\n */\n", "repo_name": "joda-time-main/", "id": 68, "method_signature": "long set(long, int)"}, "PreciseDurationDateTimeField.remainder": {"callee_method_names": [], "method_name": "PreciseDurationDateTimeField.remainder", "method_implementation": "{\n    if (instant >= 0) {\n        return instant % iUnitMillis;\n    } else {\n        return (instant + 1) % iUnitMillis + iUnitMillis - 1;\n    }\n}", "repo_id": "7", "comment": "/**\n * This method assumes that this field is properly rounded on\n * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n * method as follows:\n * <pre>\n * return super.remainder(instant + ALIGNMENT_MILLIS);\n * </pre>\n */\n", "repo_name": "joda-time-main/", "id": 50, "method_signature": "long remainder(long)"}, "PreciseDurationDateTimeField.roundCeiling": {"callee_method_names": [], "method_name": "PreciseDurationDateTimeField.roundCeiling", "method_implementation": "{\n    if (instant > 0) {\n        instant -= 1;\n        return instant - instant % iUnitMillis + iUnitMillis;\n    } else {\n        return instant - instant % iUnitMillis;\n    }\n}", "repo_id": "7", "comment": "/**\n * This method assumes that this field is properly rounded on\n * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n * method as follows:\n * <pre>\n * return super.roundCeiling(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n * </pre>\n */\n", "repo_name": "joda-time-main/", "id": 49, "method_signature": "long roundCeiling(long)"}, "PreciseDurationDateTimeField.roundFloor": {"callee_method_names": [], "method_name": "PreciseDurationDateTimeField.roundFloor", "method_implementation": "{\n    if (instant >= 0) {\n        return instant - instant % iUnitMillis;\n    } else {\n        instant += 1;\n        return instant - instant % iUnitMillis - iUnitMillis;\n    }\n}", "repo_id": "7", "comment": "/**\n * This method assumes that this field is properly rounded on\n * 1970-01-01T00:00:00. If the rounding alignment differs, override this\n * method as follows:\n * <pre>\n * return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS;\n * </pre>\n */\n", "repo_name": "joda-time-main/", "id": 48, "method_signature": "long roundFloor(long)"}, "PreciseDurationDateTimeField.set": {"callee_method_names": [], "method_name": "PreciseDurationDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValueForSet(instant, value));\n    return instant + (value - get(instant)) * iUnitMillis;\n}", "repo_id": "7", "comment": "/**\n * Set the specified amount of units to the specified time instant.\n *\n * @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in\n * @param value  value of units to set.\n * @return the updated time instant.\n * @throws IllegalArgumentException if value is too large or too small.\n */\n", "repo_name": "joda-time-main/", "id": 47, "method_signature": "long set(long, int)"}, "PreciseDurationField.equals": {"callee_method_names": ["PreciseDurationField.getType"], "method_name": "PreciseDurationField.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    } else if (obj instanceof PreciseDurationField) {\n        PreciseDurationField other = (PreciseDurationField) obj;\n        return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis);\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Compares this duration field to another.\n * Two fields are equal if of the same type and duration.\n *\n * @param obj  the object to compare to\n * @return if equal\n */\n", "repo_name": "joda-time-main/", "id": 22, "method_signature": "boolean equals(Object)"}, "PreciseDurationField.hashCode": {"callee_method_names": [], "method_name": "PreciseDurationField.hashCode", "method_implementation": "{\n    long millis = iUnitMillis;\n    int hash = (int) (millis ^ (millis >>> 32));\n    hash += getType().hashCode();\n    return hash;\n}", "repo_id": "7", "comment": "/**\n * Gets a hash code for this instance.\n *\n * @return a suitable hashcode\n */\n", "repo_name": "joda-time-main/", "id": 23, "method_signature": "int hashCode()"}, "Property.addNoWrapToCopy": {"callee_method_names": ["DateTimeField.add", "LocalTime.getLocalMillis", "LocalTime.getChronology", "LocalTime.withLocalMillis"], "method_name": "Property.addNoWrapToCopy", "method_implementation": "{\n    long millis = iField.add(iInstant.getLocalMillis(), value);\n    long rounded = iInstant.getChronology().millisOfDay().get(millis);\n    if (rounded != millis) {\n        throw new IllegalArgumentException(\"The addition exceeded the boundaries of LocalTime\");\n    }\n    return iInstant.withLocalMillis(millis);\n}", "repo_id": "7", "comment": "/**\n * Adds to this field in a copy of this LocalTime.\n * If the addition exceeds the maximum value (eg. 23:59) then\n * an exception will be thrown.\n * Contrast this behaviour to {@link #addCopy(int)}.\n * <p>\n * The LocalTime attached to this property is unchanged by this call.\n *\n * @param value  the value to add to the field in the copy\n * @return a copy of the LocalTime with the field value changed\n * @throws IllegalArgumentException if the result is invalid\n */\n", "repo_name": "joda-time-main/", "id": 1055, "method_signature": "LocalTime addNoWrapToCopy(int)"}, "Property.addToCopy": {"callee_method_names": ["TimeOfDay.getValues"], "method_name": "Property.addToCopy", "method_implementation": "{\n    int[] newValues = iTimeOfDay.getValues();\n    newValues = getField().addWrapPartial(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n    return new TimeOfDay(iTimeOfDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this TimeOfDay,\n * wrapping to what would be the next day if necessary.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it will affect larger fields.\n * Smaller fields are unaffected.\n * <p>\n * If the result would be too large, beyond 23:59:59:999, then the\n * calculation wraps to 00:00:00.000. For the alternate strict behaviour\n * with no wrapping see {@link #addNoWrapToCopy(int)}.\n * <p>\n * The TimeOfDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the TimeOfDay with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 651, "method_signature": "TimeOfDay addToCopy(int)"}, "Property.addWrapFieldToCopy": {"callee_method_names": ["TimeOfDay.getValues"], "method_name": "Property.addWrapFieldToCopy", "method_implementation": "{\n    int[] newValues = iTimeOfDay.getValues();\n    newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n    return new TimeOfDay(iTimeOfDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this TimeOfDay wrapping\n * within this field if the maximum value is reached.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it wraps within this field.\n * Other fields are unaffected.\n * <p>\n * For example,\n * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.\n * <p>\n * The TimeOfDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the TimeOfDay with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 653, "method_signature": "TimeOfDay addWrapFieldToCopy(int)"}, "Property.readObject": {"callee_method_ids": [70], "callee_method_names": ["ObjectInputStream.readObject", "ObjectInputStream.readObject", "DateTimeFieldType.getField", "LocalTime.getChronology"], "method_name": "Property.readObject", "method_implementation": "{\n    iInstant = (LocalTime) oos.readObject();\n    DateTimeFieldType type = (DateTimeFieldType) oos.readObject();\n    iField = type.getField(iInstant.getChronology());\n}", "repo_id": "7", "comment": "/**\n * Reads the property from a safe serialization format.\n */\n", "repo_name": "joda-time-main/", "id": 1054, "method_signature": "void readObject(ObjectInputStream)"}, "Property.setCopy": {"callee_method_names": ["TimeOfDay.getValues"], "method_name": "Property.setCopy", "method_implementation": "{\n    int[] newValues = iTimeOfDay.getValues();\n    newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale);\n    return new TimeOfDay(iTimeOfDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Sets this field in a copy of the TimeOfDay to a parsed text value.\n * <p>\n * The TimeOfDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param text  the text value to set\n * @param locale  optional locale to use for selecting a text symbol\n * @return a copy of the TimeOfDay with the field value changed\n * @throws IllegalArgumentException if the text value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 655, "method_signature": "TimeOfDay setCopy(String, Locale)"}, "Property.withMaximumValue": {"callee_method_names": [], "method_name": "Property.withMaximumValue", "method_implementation": "{\n    try {\n        return setCopy(getMaximumValue());\n    } catch (RuntimeException ex) {\n        if (IllegalInstantException.isIllegalInstant(ex)) {\n            // adding MILLIS_PER_DAY is not perfect, but will work in almost all situations\n            long beforeGap = getChronology().getZone().previousTransition(getMillis() + DateTimeConstants.MILLIS_PER_DAY);\n            return new DateTime(beforeGap, getChronology());\n        }\n        throw ex;\n    }\n}", "repo_id": "7", "comment": "/**\n * Returns a new DateTime with this field set to the maximum value\n * for this field.\n * <p>\n * This operation is useful for obtaining a DateTime on the last day\n * of the month, as month lengths vary.\n * <pre>\n * DateTime lastDayOfMonth = dt.dayOfMonth().withMaximumValue();\n * </pre>\n * <p>\n * Where possible, the offset from UTC will be retained, thus applications\n * may need to call {@link DateTime#withLaterOffsetAtOverlap()} on the result\n * to force the later time during a DST overlap if desired.\n * <p>\n * From v2.2, this method handles a daylight savings time gap, setting the\n * time to the last instant before the gap.\n * <p>\n * The DateTime attached to this property is unchanged by this call.\n *\n * @return a copy of the DateTime with this field set to its maximum\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 460, "method_signature": "DateTime withMaximumValue()"}, "Property.withMinimumValue": {"callee_method_names": [], "method_name": "Property.withMinimumValue", "method_implementation": "{\n    try {\n        return setCopy(getMinimumValue());\n    } catch (RuntimeException ex) {\n        if (IllegalInstantException.isIllegalInstant(ex)) {\n            // subtracting MILLIS_PER_DAY is not perfect, but will work in almost all situations\n            long afterGap = getChronology().getZone().nextTransition(getMillis() - DateTimeConstants.MILLIS_PER_DAY);\n            return new DateTime(afterGap, getChronology());\n        }\n        throw ex;\n    }\n}", "repo_id": "7", "comment": "/**\n * Returns a new DateTime with this field set to the minimum value\n * for this field.\n * <p>\n * Where possible, the offset from UTC will be retained, thus applications\n * may need to call {@link DateTime#withEarlierOffsetAtOverlap()} on the result\n * to force the earlier time during a DST overlap if desired.\n * <p>\n * From v2.2, this method handles a daylight savings time gap, setting the\n * time to the first instant after the gap.\n * <p>\n * The DateTime attached to this property is unchanged by this call.\n *\n * @return a copy of the DateTime with this field set to its minimum\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 461, "method_signature": "DateTime withMinimumValue()"}, "ReadableDurationConverter.setInto": {"callee_method_names": ["ReadableDuration.getMillis", "Chronology.get", "ReadWritablePeriod.setValue"], "method_name": "ReadableDurationConverter.setInto", "method_implementation": "{\n    ReadableDuration dur = (ReadableDuration) object;\n    chrono = DateTimeUtils.getChronology(chrono);\n    long duration = dur.getMillis();\n    int[] values = chrono.get(writablePeriod, duration);\n    for (int i = 0; i < values.length; i++) {\n        writablePeriod.setValue(i, values[i]);\n    }\n}", "repo_id": "7", "comment": "/**\n * Extracts duration values from an object of this converter's type, and\n * sets them into the given ReadWritableDuration.\n *\n * @param writablePeriod  period to get modified\n * @param object  the object to convert, must not be null\n * @param chrono  the chronology to use, must not be null\n * @throws NullPointerException if the duration or object is null\n * @throws ClassCastException if the object is an invalid type\n * @throws IllegalArgumentException if the object is invalid\n */\n", "repo_name": "joda-time-main/", "id": 583, "method_signature": "void setInto(ReadWritablePeriod, Object, Chronology)"}, "ReadableInstantConverter.getChronology": {"callee_method_names": [], "method_name": "ReadableInstantConverter.getChronology", "method_implementation": "{\n    if (chrono == null) {\n        chrono = ((ReadableInstant) object).getChronology();\n        chrono = DateTimeUtils.getChronology(chrono);\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets the chronology, which is taken from the ReadableInstant.\n * <p>\n * If the passed in chronology is non-null, it is used.\n * Otherwise the chronology from the instant is used.\n *\n * @param object  the ReadableInstant to convert, must not be null\n * @param chrono  the chronology to use, null means use that from object\n * @return the chronology, never null\n */\n", "repo_name": "joda-time-main/", "id": 582, "method_signature": "Chronology getChronology(Object, Chronology)"}, "ReadableIntervalConverter.setInto": {"callee_method_names": ["ReadWritableInterval.setInterval", "ReadWritableInterval.setChronology", "ReadWritableInterval.setChronology", "ReadableInterval.getChronology"], "method_name": "ReadableIntervalConverter.setInto", "method_implementation": "{\n    ReadableInterval input = (ReadableInterval) object;\n    writableInterval.setInterval(input);\n    if (chrono != null) {\n        writableInterval.setChronology(chrono);\n    } else {\n        writableInterval.setChronology(input.getChronology());\n    }\n}", "repo_id": "7", "comment": "/**\n * Extracts interval endpoint values from an object of this converter's\n * type, and sets them into the given ReadWritableInterval.\n *\n * @param writableInterval interval to get modified, not null\n * @param object  the object to convert, must not be null\n * @param chrono  the chronology to use, may be null\n * @throws ClassCastException if the object is invalid\n */\n", "repo_name": "joda-time-main/", "id": 621, "method_signature": "void setInto(ReadWritableInterval, Object, Chronology)"}, "ReadablePartialConverter.getChronology": {"callee_method_names": [], "method_name": "ReadablePartialConverter.getChronology", "method_implementation": "{\n    if (chrono == null) {\n        chrono = ((ReadablePartial) object).getChronology();\n        chrono = DateTimeUtils.getChronology(chrono);\n    }\n    return chrono;\n}", "repo_id": "7", "comment": "/**\n * Gets the chronology, which is taken from the ReadableInstant.\n * <p>\n * If the passed in chronology is non-null, it is used.\n * Otherwise the chronology from the instant is used.\n *\n * @param object  the ReadablePartial to convert, must not be null\n * @param chrono  the chronology to use, null means use that from object\n * @return the chronology, never null\n */\n", "repo_name": "joda-time-main/", "id": 573, "method_signature": "Chronology getChronology(Object, Chronology)"}, "ReadablePartialConverter.getPartialValues": {"callee_method_names": ["ReadablePartial.size", "ReadablePartial.get", "ReadablePartial.getFieldType", "Chronology.validate"], "method_name": "ReadablePartialConverter.getPartialValues", "method_implementation": "{\n    ReadablePartial input = (ReadablePartial) object;\n    int size = fieldSource.size();\n    int[] values = new int[size];\n    for (int i = 0; i < size; i++) {\n        values[i] = input.get(fieldSource.getFieldType(i));\n    }\n    chrono.validate(fieldSource, values);\n    return values;\n}", "repo_id": "7", "comment": "/**\n * Extracts the values of the partial from an object of this converter's type.\n * The chrono parameter is a hint to the converter, should it require a\n * chronology to aid in conversion.\n *\n * @param fieldSource  a partial that provides access to the fields.\n *  This partial may be incomplete and only getFieldType(int) should be used\n * @param object  the object to convert\n * @param chrono  the chronology to use, which is the non-null result of getChronology()\n * @return the array of field values that match the fieldSource, must be non-null valid\n * @throws ClassCastException if the object is invalid\n */\n", "repo_name": "joda-time-main/", "id": 574, "method_signature": "int[] getPartialValues(ReadablePartial, Object, Chronology)"}, "ReadablePeriodConverter.getPeriodType": {"callee_method_names": ["ReadablePeriod.getPeriodType"], "method_name": "ReadablePeriodConverter.getPeriodType", "method_implementation": "{\n    ReadablePeriod period = (ReadablePeriod) object;\n    return period.getPeriodType();\n}", "repo_id": "7", "comment": "/**\n * Selects a suitable period type for the given object.\n *\n * @param object  the object to examine, must not be null\n * @return the period type from the readable duration\n * @throws NullPointerException if the object is null\n * @throws ClassCastException if the object is an invalid type\n */\n", "repo_name": "joda-time-main/", "id": 619, "method_signature": "PeriodType getPeriodType(Object)"}, "RemainderDateTimeField.get": {"callee_method_names": [], "method_name": "RemainderDateTimeField.get", "method_implementation": "{\n    int value = getWrappedField().get(instant);\n    if (value >= 0) {\n        return value % iDivisor;\n    } else {\n        return (iDivisor - 1) + ((value + 1) % iDivisor);\n    }\n}", "repo_id": "7", "comment": "/**\n * Get the remainder from the specified time instant.\n *\n * @param instant  the time instant in millis to query.\n * @return the remainder extracted from the input.\n */\n", "repo_name": "joda-time-main/", "id": 25, "method_signature": "int get(long)"}, "RemainderDateTimeField.set": {"callee_method_names": [], "method_name": "RemainderDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, value, 0, iDivisor - 1);\n    int divided = getDivided(getWrappedField().get(instant));\n    return getWrappedField().set(instant, divided * iDivisor + value);\n}", "repo_id": "7", "comment": "/**\n * Set the specified amount of remainder units to the specified time instant.\n *\n * @param instant  the time instant in millis to update.\n * @param value  value of remainder units to set.\n * @return the updated time instant.\n * @throws IllegalArgumentException if value is too large or too small.\n */\n", "repo_name": "joda-time-main/", "id": 26, "method_signature": "long set(long, int)"}, "Rule.addRecurring": {"callee_method_ids": [736], "callee_method_names": ["DateTimeOfYear.addRecurring"], "method_name": "Rule.addRecurring", "method_implementation": "{\n    int saveMillis = iSaveMillis + -negativeSave;\n    String nameKey = formatName(nameFormat, saveMillis, iLetterS);\n    iDateTimeOfYear.addRecurring(builder, nameKey, saveMillis, iFromYear, iToYear);\n}", "repo_id": "7", "comment": "/**\n * Adds a recurring savings rule to the builder.\n *\n * @param builder  the builder\n * @param negativeSave  the negative save value\n * @param nameFormat  the name format\n */\n", "repo_name": "joda-time-main/", "id": 738, "method_signature": "void addRecurring(DateTimeZoneBuilder, int, String)"}, "RuleSet.addRecurring": {"callee_method_ids": [738, 738], "callee_method_names": ["List<Rule>.size", "List<Rule>.get", "List<Rule>.get", "String.indexOf", "String.substring", "String.substring", "DateTimeZoneBuilder.setStandardOffset", "List<Rule>.get", "Rule.addRecurring", "List<Rule>.size", "List<Rule>.get", "Rule.addRecurring"], "method_name": "RuleSet.addRecurring", "method_implementation": "{\n    // a hack is necessary to remove negative SAVE values from the input tzdb file\n    // negative save values cause the standard offset to be set in the summer instead of the winter\n    // this causes the wrong name to be chosen from the CLDR data\n    // check if the ruleset has negative SAVE values\n    int negativeSave = 0;\n    for (int i = 0; i < iRules.size(); i++) {\n        Rule rule = iRules.get(i);\n        if (rule.iSaveMillis < 0) {\n            negativeSave = Math.min(negativeSave, rule.iSaveMillis);\n        }\n    }\n    // if negative SAVE values, then patch standard millis and name format\n    if (negativeSave < 0) {\n        System.out.println(\"Fixed negative save values for rule '\" + iRules.get(0).iName + \"'\");\n        standardMillis += negativeSave;\n        int slashPos = nameFormat.indexOf(\"/\");\n        if (slashPos > 0) {\n            nameFormat = nameFormat.substring(slashPos + 1) + \"/\" + nameFormat.substring(0, slashPos);\n        }\n    }\n    builder.setStandardOffset(standardMillis);\n    // add a fake rule that predates all other rules to ensure standard=summer (see Namibia)\n    if (negativeSave < 0) {\n        Rule rule = new Rule(iRules.get(0));\n        rule.addRecurring(builder, negativeSave, nameFormat);\n    }\n    // add each rule, passing through the negative save to alter the actual iSaveMillis value that is used\n    for (int i = 0; i < iRules.size(); i++) {\n        Rule rule = iRules.get(i);\n        rule.addRecurring(builder, negativeSave, nameFormat);\n    }\n}", "repo_id": "7", "comment": "/**\n * Adds recurring savings rules to the builder.\n *\n * @param builder  the builder\n * @param standardMillis  the standard millis\n * @param nameFormat  the name format\n */\n", "repo_name": "joda-time-main/", "id": 739, "method_signature": "void addRecurring(DateTimeZoneBuilder, int, String)"}, "RuleSet.buildTailZone": {"callee_method_names": ["ArrayList<Rule>.size", "ArrayList<Rule>.get", "ArrayList<Rule>.get", "Rule.getToYear", "Rule.getToYear"], "method_name": "RuleSet.buildTailZone", "method_implementation": "{\n    if (iRules.size() == 2) {\n        Rule startRule = iRules.get(0);\n        Rule endRule = iRules.get(1);\n        if (startRule.getToYear() == Integer.MAX_VALUE && endRule.getToYear() == Integer.MAX_VALUE) {\n            // With exactly two infinitely recurring rules left, a\n            // simple DSTZone can be formed.\n            // The order of rules can come in any order, and it doesn't\n            // really matter which rule was chosen the 'start' and\n            // which is chosen the 'end'. DSTZone works properly either\n            // way.\n            return new DSTZone(id, iStandardOffset, startRule.iRecurrence, endRule.iRecurrence);\n        }\n    }\n    return null;\n}", "repo_id": "7", "comment": "/**\n * Returns null if none can be built.\n */\n", "repo_name": "joda-time-main/", "id": 770, "method_signature": "DSTZone buildTailZone(String)"}, "RuleSet.firstTransition": {"callee_method_names": ["Transition.getMillis", "Rule.getSaveMillis", "Transition.getNameKey", "Transition.getSaveMillis"], "method_name": "RuleSet.firstTransition", "method_implementation": "{\n    if (iInitialNameKey != null) {\n        // Initial zone info explicitly set, so don't search the rules.\n        return new Transition(firstMillis, iInitialNameKey, iStandardOffset + iInitialSaveMillis, iStandardOffset);\n    }\n    // Make a copy before we destroy the rules.\n    ArrayList<Rule> copy = new ArrayList<Rule>(iRules);\n    // Iterate through all the transitions until firstMillis is\n    // reached. Use the name key and savings for whatever rule reaches\n    // the limit.\n    long millis = Long.MIN_VALUE;\n    int saveMillis = 0;\n    Transition first = null;\n    Transition next;\n    while ((next = nextTransition(millis, saveMillis)) != null) {\n        millis = next.getMillis();\n        if (millis == firstMillis) {\n            first = new Transition(firstMillis, next);\n            break;\n        }\n        if (millis > firstMillis) {\n            if (first == null) {\n                // Find first rule without savings. This way a more\n                // accurate nameKey is found even though no rule\n                // extends to the RuleSet's lower limit.\n                for (Rule rule : copy) {\n                    if (rule.getSaveMillis() == 0) {\n                        first = new Transition(firstMillis, rule, iStandardOffset);\n                        break;\n                    }\n                }\n            }\n            if (first == null) {\n                // Found no rule without savings. Create a transition\n                // with no savings anyhow, and use the best available\n                // name key.\n                first = new Transition(firstMillis, next.getNameKey(), iStandardOffset, iStandardOffset);\n            }\n            break;\n        }\n        // Set first to the best transition found so far, but next\n        // iteration may find something closer to lower limit.\n        first = new Transition(firstMillis, next);\n        saveMillis = next.getSaveMillis();\n    }\n    iRules = copy;\n    return first;\n}", "repo_id": "7", "comment": "/**\n * Returns a transition at firstMillis with the first name key and\n * offsets for this rule set. This method may return null.\n *\n * @param firstMillis millis of first transition\n */\n", "repo_name": "joda-time-main/", "id": 767, "method_signature": "Transition firstTransition(long)"}, "RuleSet.getUpperLimit": {"callee_method_ids": [761], "callee_method_names": ["OfYear.setInstant"], "method_name": "RuleSet.getUpperLimit", "method_implementation": "{\n    if (iUpperYear == Integer.MAX_VALUE) {\n        return Long.MAX_VALUE;\n    }\n    return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n}", "repo_id": "7", "comment": "/**\n * @param saveMillis savings before upper limit\n */\n", "repo_name": "joda-time-main/", "id": 769, "method_signature": "long getUpperLimit(int)"}, "RuleSet.nextTransition": {"callee_method_ids": [761], "callee_method_names": ["ArrayList<Rule>.iterator", "Iterator<Rule>.hasNext", "Iterator<Rule>.next", "Rule.next", "Iterator<Rule>.remove", "Chronology.year", "OfYear.setInstant"], "method_name": "RuleSet.nextTransition", "method_implementation": "{\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    // Find next matching rule.\n    Rule nextRule = null;\n    long nextMillis = Long.MAX_VALUE;\n    Iterator<Rule> it = iRules.iterator();\n    while (it.hasNext()) {\n        Rule rule = it.next();\n        long next = rule.next(instant, iStandardOffset, saveMillis);\n        if (next <= instant) {\n            it.remove();\n            continue;\n        }\n        // Even if next is same as previous next, choose the rule\n        // in order for more recently added rules to override.\n        if (next <= nextMillis) {\n            // Found a better match.\n            nextRule = rule;\n            nextMillis = next;\n        }\n    }\n    if (nextRule == null) {\n        return null;\n    }\n    // Stop precalculating if year reaches some arbitrary limit.\n    if (chrono.year().get(nextMillis) >= YEAR_LIMIT) {\n        return null;\n    }\n    // Check if upper limit reached or passed.\n    if (iUpperYear < Integer.MAX_VALUE) {\n        long upperMillis = iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        if (nextMillis >= upperMillis) {\n            // At or after upper limit.\n            return null;\n        }\n    }\n    return new Transition(nextMillis, nextRule, iStandardOffset);\n}", "repo_id": "7", "comment": "/**\n * Returns null if RuleSet is exhausted or upper limit reached. Calling\n * this method will throw away rules as they each become\n * exhausted. Copy the RuleSet before using it to compute transitions.\n *\n * Returned transition may be a duplicate from previous\n * transition. Caller must call isTransitionFrom to filter out\n * duplicates.\n *\n * @param saveMillis savings before next transition\n */\n", "repo_name": "joda-time-main/", "id": 768, "method_signature": "Transition nextTransition(long, int)"}, "SavedField.compareTo": {"callee_method_names": ["DateTimeField.getRangeDurationField", "DateTimeField.getRangeDurationField", "DateTimeField.getDurationField", "DateTimeField.getDurationField"], "method_name": "SavedField.compareTo", "method_implementation": "{\n    DateTimeField other = obj.iField;\n    int result = compareReverse(iField.getRangeDurationField(), other.getRangeDurationField());\n    if (result != 0) {\n        return result;\n    }\n    return compareReverse(iField.getDurationField(), other.getDurationField());\n}", "repo_id": "7", "comment": "/**\n * The field with the longer range duration is ordered first, where\n * null is considered infinite. If the ranges match, then the field\n * with the longer duration is ordered first.\n */\n", "repo_name": "joda-time-main/", "id": 809, "method_signature": "int compareTo(SavedField)"}, "ScaledDurationField.equals": {"callee_method_names": ["ScaledDurationField.getWrappedField", "ScaledDurationField.getType"], "method_name": "ScaledDurationField.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    } else if (obj instanceof ScaledDurationField) {\n        ScaledDurationField other = (ScaledDurationField) obj;\n        return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar);\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Compares this duration field to another.\n * Two fields are equal if of the same type and duration.\n *\n * @param obj  the object to compare to\n * @return if equal\n */\n", "repo_name": "joda-time-main/", "id": 20, "method_signature": "boolean equals(Object)"}, "ScaledDurationField.hashCode": {"callee_method_names": [], "method_name": "ScaledDurationField.hashCode", "method_implementation": "{\n    long scalar = iScalar;\n    int hash = (int) (scalar ^ (scalar >>> 32));\n    hash += getType().hashCode();\n    hash += getWrappedField().hashCode();\n    return hash;\n}", "repo_id": "7", "comment": "/**\n * Gets a hash code for this instance.\n *\n * @return a suitable hashcode\n */\n", "repo_name": "joda-time-main/", "id": 21, "method_signature": "int hashCode()"}, "Seconds.dividedBy": {"callee_method_names": [], "method_name": "Seconds.dividedBy", "method_implementation": "{\n    if (divisor == 1) {\n        return this;\n    }\n    return Seconds.seconds(getValue() / divisor);\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the seconds divided by the specified divisor.\n * The calculation uses integer division, thus 3 divided by 2 is 1.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param divisor  the amount to divide by, may be negative\n * @return the new period divided by the specified divisor\n * @throws ArithmeticException if the divisor is zero\n */\n", "repo_name": "joda-time-main/", "id": 781, "method_signature": "Seconds dividedBy(int)"}, "Seconds.isGreaterThan": {"callee_method_names": ["Seconds.getValue"], "method_name": "Seconds.isGreaterThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() > 0;\n    }\n    return getValue() > other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this seconds instance greater than the specified number of seconds.\n *\n * @param other  the other period, null means zero\n * @return true if this seconds instance is greater than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 782, "method_signature": "boolean isGreaterThan(Seconds)"}, "Seconds.isLessThan": {"callee_method_names": ["Seconds.getValue"], "method_name": "Seconds.isLessThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() < 0;\n    }\n    return getValue() < other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this seconds instance less than the specified number of seconds.\n *\n * @param other  the other period, null means zero\n * @return true if this seconds instance is less than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 783, "method_signature": "boolean isLessThan(Seconds)"}, "Seconds.minus": {"callee_method_names": ["Seconds.getValue"], "method_name": "Seconds.minus", "method_implementation": "{\n    if (seconds == null) {\n        return this;\n    }\n    return minus(seconds.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of seconds taken away.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param seconds  the amount of seconds to take away, may be negative, null means zero\n * @return the new period minus the specified number of seconds\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 780, "method_signature": "Seconds minus(Seconds)"}, "Seconds.parseSeconds": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod", "Period.getSeconds"], "method_name": "Seconds.parseSeconds", "method_implementation": "{\n    if (periodStr == null) {\n        return Seconds.ZERO;\n    }\n    Period p = PARSER.parsePeriod(periodStr);\n    return Seconds.seconds(p.getSeconds());\n}", "repo_id": "7", "comment": "/**\n * Creates a new <code>Seconds</code> by parsing a string in the ISO8601 format 'PTnS'.\n * <p>\n * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n * seconds component may be non-zero. If any other component is non-zero, an exception\n * will be thrown.\n *\n * @param periodStr  the period string, null returns zero\n * @return the period in seconds\n * @throws IllegalArgumentException if the string format is invalid\n */\n", "repo_name": "joda-time-main/", "id": 777, "method_signature": "Seconds parseSeconds(String)"}, "Seconds.plus": {"callee_method_names": ["Seconds.getValue"], "method_name": "Seconds.plus", "method_implementation": "{\n    if (seconds == null) {\n        return this;\n    }\n    return plus(seconds.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of seconds added.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param seconds  the amount of seconds to add, may be negative, null means zero\n * @return the new period plus the specified number of seconds\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 779, "method_signature": "Seconds plus(Seconds)"}, "Seconds.seconds": {"callee_method_names": [], "method_name": "Seconds.seconds", "method_implementation": "{\n    switch(seconds) {\n        case 0:\n            return ZERO;\n        case 1:\n            return ONE;\n        case 2:\n            return TWO;\n        case 3:\n            return THREE;\n        case Integer.MAX_VALUE:\n            return MAX_VALUE;\n        case Integer.MIN_VALUE:\n            return MIN_VALUE;\n        default:\n            return new Seconds(seconds);\n    }\n}", "repo_id": "7", "comment": "/**\n * Obtains an instance of <code>Seconds</code> that may be cached.\n * <code>Seconds</code> is immutable, so instances can be cached and shared.\n * This factory method provides access to shared instances.\n *\n * @param seconds  the number of seconds to obtain an instance for\n * @return the instance of Seconds\n */\n", "repo_name": "joda-time-main/", "id": 774, "method_signature": "Seconds seconds(int)"}, "Seconds.secondsBetween": {"callee_method_names": ["ReadablePartial.getChronology", "Chronology.seconds"], "method_name": "Seconds.secondsBetween", "method_implementation": "{\n    if (start instanceof LocalTime && end instanceof LocalTime) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(((LocalTime) end).getLocalMillis(), ((LocalTime) start).getLocalMillis());\n        return Seconds.seconds(seconds);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return Seconds.seconds(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Seconds</code> representing the number of whole seconds\n * between the two specified partial datetimes.\n * <p>\n * The two partials must contain the same fields, for example you can specify\n * two <code>LocalTime</code> objects.\n *\n * @param start  the start partial date, must not be null\n * @param end  the end partial date, must not be null\n * @return the period in seconds\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 775, "method_signature": "Seconds secondsBetween(ReadablePartial, ReadablePartial)"}, "Seconds.secondsIn": {"callee_method_names": ["ReadableInterval.getStart", "ReadableInterval.getEnd"], "method_name": "Seconds.secondsIn", "method_implementation": "{\n    if (interval == null) {\n        return Seconds.ZERO;\n    }\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.seconds());\n    return Seconds.seconds(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Seconds</code> representing the number of whole seconds\n * in the specified interval.\n *\n * @param interval  the interval to extract seconds from, null returns zero\n * @return the period in seconds\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 776, "method_signature": "Seconds secondsIn(ReadableInterval)"}, "Seconds.toString": {"callee_method_names": [], "method_name": "Seconds.toString", "method_implementation": "{\n    return \"PT\" + String.valueOf(getValue()) + \"S\";\n}", "repo_id": "7", "comment": "/**\n * Gets this instance as a String in the ISO8601 duration format.\n * <p>\n * For example, \"PT4S\" represents 4 seconds.\n *\n * @return the value as an ISO8601 string\n */\n", "repo_name": "joda-time-main/", "id": 784, "method_signature": "String toString()"}, "SkipDateTimeField.get": {"callee_method_names": [], "method_name": "SkipDateTimeField.get", "method_implementation": "{\n    int value = super.get(millis);\n    if (value <= iSkip) {\n        value--;\n    }\n    return value;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 27, "method_signature": "int get(long)"}, "SkipUndoDateTimeField.get": {"callee_method_names": [], "method_name": "SkipUndoDateTimeField.get", "method_implementation": "{\n    int value = super.get(millis);\n    if (value < iSkip) {\n        value++;\n    }\n    return value;\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 45, "method_signature": "int get(long)"}, "StandardDateTimeFieldType.equals": {"callee_method_names": [], "method_name": "StandardDateTimeFieldType.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof StandardDateTimeFieldType) {\n        return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal;\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * @inheritdoc\n */\n", "repo_name": "joda-time-main/", "id": 72, "method_signature": "boolean equals(Object)"}, "StandardDateTimeFieldType.getField": {"callee_method_names": ["Chronology.era", "Chronology.yearOfEra", "Chronology.centuryOfEra", "Chronology.yearOfCentury", "Chronology.year", "Chronology.dayOfYear", "Chronology.monthOfYear", "Chronology.dayOfMonth", "Chronology.weekyearOfCentury", "Chronology.weekyear", "Chronology.weekOfWeekyear", "Chronology.dayOfWeek", "Chronology.halfdayOfDay", "Chronology.hourOfHalfday", "Chronology.clockhourOfHalfday", "Chronology.clockhourOfDay", "Chronology.hourOfDay", "Chronology.minuteOfDay", "Chronology.minuteOfHour", "Chronology.secondOfDay", "Chronology.secondOfMinute", "Chronology.millisOfDay", "Chronology.millisOfSecond"], "method_name": "StandardDateTimeFieldType.getField", "method_implementation": "{\n    chronology = DateTimeUtils.getChronology(chronology);\n    switch(iOrdinal) {\n        case ERA:\n            return chronology.era();\n        case YEAR_OF_ERA:\n            return chronology.yearOfEra();\n        case CENTURY_OF_ERA:\n            return chronology.centuryOfEra();\n        case YEAR_OF_CENTURY:\n            return chronology.yearOfCentury();\n        case YEAR:\n            return chronology.year();\n        case DAY_OF_YEAR:\n            return chronology.dayOfYear();\n        case MONTH_OF_YEAR:\n            return chronology.monthOfYear();\n        case DAY_OF_MONTH:\n            return chronology.dayOfMonth();\n        case WEEKYEAR_OF_CENTURY:\n            return chronology.weekyearOfCentury();\n        case WEEKYEAR:\n            return chronology.weekyear();\n        case WEEK_OF_WEEKYEAR:\n            return chronology.weekOfWeekyear();\n        case DAY_OF_WEEK:\n            return chronology.dayOfWeek();\n        case HALFDAY_OF_DAY:\n            return chronology.halfdayOfDay();\n        case HOUR_OF_HALFDAY:\n            return chronology.hourOfHalfday();\n        case CLOCKHOUR_OF_HALFDAY:\n            return chronology.clockhourOfHalfday();\n        case CLOCKHOUR_OF_DAY:\n            return chronology.clockhourOfDay();\n        case HOUR_OF_DAY:\n            return chronology.hourOfDay();\n        case MINUTE_OF_DAY:\n            return chronology.minuteOfDay();\n        case MINUTE_OF_HOUR:\n            return chronology.minuteOfHour();\n        case SECOND_OF_DAY:\n            return chronology.secondOfDay();\n        case SECOND_OF_MINUTE:\n            return chronology.secondOfMinute();\n        case MILLIS_OF_DAY:\n            return chronology.millisOfDay();\n        case MILLIS_OF_SECOND:\n            return chronology.millisOfSecond();\n        default:\n            // Shouldn't happen.\n            throw new InternalError();\n    }\n}", "repo_id": "7", "comment": "/**\n * @inheritdoc\n */\n", "repo_name": "joda-time-main/", "id": 73, "method_signature": "DateTimeField getField(Chronology)"}, "StandardDateTimeFieldType.readResolve": {"callee_method_names": [], "method_name": "StandardDateTimeFieldType.readResolve", "method_implementation": "{\n    switch(iOrdinal) {\n        case ERA:\n            return ERA_TYPE;\n        case YEAR_OF_ERA:\n            return YEAR_OF_ERA_TYPE;\n        case CENTURY_OF_ERA:\n            return CENTURY_OF_ERA_TYPE;\n        case YEAR_OF_CENTURY:\n            return YEAR_OF_CENTURY_TYPE;\n        case YEAR:\n            return YEAR_TYPE;\n        case DAY_OF_YEAR:\n            return DAY_OF_YEAR_TYPE;\n        case MONTH_OF_YEAR:\n            return MONTH_OF_YEAR_TYPE;\n        case DAY_OF_MONTH:\n            return DAY_OF_MONTH_TYPE;\n        case WEEKYEAR_OF_CENTURY:\n            return WEEKYEAR_OF_CENTURY_TYPE;\n        case WEEKYEAR:\n            return WEEKYEAR_TYPE;\n        case WEEK_OF_WEEKYEAR:\n            return WEEK_OF_WEEKYEAR_TYPE;\n        case DAY_OF_WEEK:\n            return DAY_OF_WEEK_TYPE;\n        case HALFDAY_OF_DAY:\n            return HALFDAY_OF_DAY_TYPE;\n        case HOUR_OF_HALFDAY:\n            return HOUR_OF_HALFDAY_TYPE;\n        case CLOCKHOUR_OF_HALFDAY:\n            return CLOCKHOUR_OF_HALFDAY_TYPE;\n        case CLOCKHOUR_OF_DAY:\n            return CLOCKHOUR_OF_DAY_TYPE;\n        case HOUR_OF_DAY:\n            return HOUR_OF_DAY_TYPE;\n        case MINUTE_OF_DAY:\n            return MINUTE_OF_DAY_TYPE;\n        case MINUTE_OF_HOUR:\n            return MINUTE_OF_HOUR_TYPE;\n        case SECOND_OF_DAY:\n            return SECOND_OF_DAY_TYPE;\n        case SECOND_OF_MINUTE:\n            return SECOND_OF_MINUTE_TYPE;\n        case MILLIS_OF_DAY:\n            return MILLIS_OF_DAY_TYPE;\n        case MILLIS_OF_SECOND:\n            return MILLIS_OF_SECOND_TYPE;\n        default:\n            // Shouldn't happen.\n            return this;\n    }\n}", "repo_id": "7", "comment": "/**\n * Ensure a singleton is returned.\n *\n * @return the singleton type\n */\n", "repo_name": "joda-time-main/", "id": 74, "method_signature": "Object readResolve()"}, "StandardDurationFieldType.equals": {"callee_method_names": [], "method_name": "StandardDurationFieldType.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof StandardDurationFieldType) {\n        return iOrdinal == ((StandardDurationFieldType) obj).iOrdinal;\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * @inheritdoc\n */\n", "repo_name": "joda-time-main/", "id": 787, "method_signature": "boolean equals(Object)"}, "StandardDurationFieldType.readResolve": {"callee_method_names": [], "method_name": "StandardDurationFieldType.readResolve", "method_implementation": "{\n    switch(iOrdinal) {\n        case ERAS:\n            return ERAS_TYPE;\n        case CENTURIES:\n            return CENTURIES_TYPE;\n        case WEEKYEARS:\n            return WEEKYEARS_TYPE;\n        case YEARS:\n            return YEARS_TYPE;\n        case MONTHS:\n            return MONTHS_TYPE;\n        case WEEKS:\n            return WEEKS_TYPE;\n        case DAYS:\n            return DAYS_TYPE;\n        case HALFDAYS:\n            return HALFDAYS_TYPE;\n        case HOURS:\n            return HOURS_TYPE;\n        case MINUTES:\n            return MINUTES_TYPE;\n        case SECONDS:\n            return SECONDS_TYPE;\n        case MILLIS:\n            return MILLIS_TYPE;\n        default:\n            // Shouldn't happen.\n            return this;\n    }\n}", "repo_id": "7", "comment": "/**\n * Ensure a singleton is returned.\n *\n * @return the singleton type\n */\n", "repo_name": "joda-time-main/", "id": 788, "method_signature": "Object readResolve()"}, "StrictChronology.equals": {"callee_method_names": ["StrictChronology.getBase"], "method_name": "StrictChronology.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof StrictChronology == false) {\n        return false;\n    }\n    StrictChronology chrono = (StrictChronology) obj;\n    return getBase().equals(chrono.getBase());\n}", "repo_id": "7", "comment": "/**\n * A strict chronology is only equal to a strict chronology with the\n * same base chronology.\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 1.4\n */\n", "repo_name": "joda-time-main/", "id": 352, "method_signature": "boolean equals(Object)"}, "StrictChronology.getInstance": {"callee_method_names": [], "method_name": "StrictChronology.getInstance", "method_implementation": "{\n    if (base == null) {\n        throw new IllegalArgumentException(\"Must supply a chronology\");\n    }\n    return new StrictChronology(base);\n}", "repo_id": "7", "comment": "/**\n * Create a StrictChronology for any chronology.\n *\n * @param base the chronology to wrap\n * @return the chronology, not null\n * @throws IllegalArgumentException if chronology is null\n */\n", "repo_name": "joda-time-main/", "id": 351, "method_signature": "StrictChronology getInstance(Chronology)"}, "StrictDateTimeField.getInstance": {"callee_method_names": ["DateTimeField.isLenient"], "method_name": "StrictDateTimeField.getInstance", "method_implementation": "{\n    if (field == null) {\n        return null;\n    }\n    if (field instanceof LenientDateTimeField) {\n        field = ((LenientDateTimeField) field).getWrappedField();\n    }\n    if (!field.isLenient()) {\n        return field;\n    }\n    return new StrictDateTimeField(field);\n}", "repo_id": "7", "comment": "/**\n * Returns a strict version of the given field. If it is already strict,\n * then it is returned as-is. Otherwise, a new StrictDateTimeField is returned.\n *\n * @param field  the field, null returns null\n * @return the field. may be null\n */\n", "repo_name": "joda-time-main/", "id": 52, "method_signature": "DateTimeField getInstance(DateTimeField)"}, "StrictDateTimeField.set": {"callee_method_names": [], "method_name": "StrictDateTimeField.set", "method_implementation": "{\n    FieldUtils.verifyValueBounds(this, value, getMinimumValue(instant), getMaximumValue(instant));\n    return super.set(instant, value);\n}", "repo_id": "7", "comment": "/**\n * Does a bounds check before setting the value.\n *\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 53, "method_signature": "long set(long, int)"}, "StringConverter.getDurationMillis": {"callee_method_names": ["String.length", "String.charAt", "String.charAt", "String.charAt", "String.charAt", "String.charAt", "String.charAt", "String.substring", "String.length", "String.charAt", "String.charAt", "String.charAt", "String.charAt", "String.substring", "String.substring", "String.length", "String.substring", "String.length"], "method_name": "StringConverter.getDurationMillis", "method_implementation": "{\n    // parse here because duration could be bigger than the int supported\n    // by the period parser\n    String original = (String) object;\n    String str = original;\n    int len = str.length();\n    if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) {\n        // ok\n    } else {\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + original + '\"');\n    }\n    str = str.substring(2, len - 1);\n    int dot = -1;\n    boolean negative = false;\n    for (int i = 0; i < str.length(); i++) {\n        if (str.charAt(i) >= '0' && str.charAt(i) <= '9') {\n            // ok\n        } else if (i == 0 && str.charAt(0) == '-') {\n            // ok\n            negative = true;\n        } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) {\n            // ok\n            dot = i;\n        } else {\n            throw new IllegalArgumentException(\"Invalid format: \\\"\" + original + '\"');\n        }\n    }\n    long millis = 0, seconds = 0;\n    int firstDigit = negative ? 1 : 0;\n    if (dot > 0) {\n        seconds = Long.parseLong(str.substring(firstDigit, dot));\n        str = str.substring(dot + 1);\n        if (str.length() != 3) {\n            str = (str + \"000\").substring(0, 3);\n        }\n        millis = Integer.parseInt(str);\n    } else if (negative) {\n        seconds = Long.parseLong(str.substring(firstDigit, str.length()));\n    } else {\n        seconds = Long.parseLong(str);\n    }\n    if (negative) {\n        return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis);\n    } else {\n        return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the duration of the string using the standard type.\n * This matches the toString() method of ReadableDuration.\n *\n * @param object  the String to convert, must not be null\n * @throws ClassCastException if the object is invalid\n */\n", "repo_name": "joda-time-main/", "id": 590, "method_signature": "long getDurationMillis(Object)"}, "StringConverter.getInstantMillis": {"callee_method_ids": [842], "callee_method_names": ["DateTimeFormatter.withChronology"], "method_name": "StringConverter.getInstantMillis", "method_implementation": "{\n    String str = (String) object;\n    DateTimeFormatter p = ISODateTimeFormat.dateTimeParser();\n    return p.withChronology(chrono).parseMillis(str);\n}", "repo_id": "7", "comment": "/**\n * Gets the millis, which is the ISO parsed string value.\n *\n * @param object  the String to convert, must not be null\n * @param chrono  the chronology to use, non-null result of getChronology\n * @return the millisecond value\n * @throws IllegalArgumentException if the value if invalid\n */\n", "repo_name": "joda-time-main/", "id": 588, "method_signature": "long getInstantMillis(Object, Chronology)"}, "StringConverter.getPartialValues": {"callee_method_ids": [842], "callee_method_names": ["DateTimeFormatter.getZone", "Chronology.withZone", "DateTimeFormatter.getZone", "DateTimeFormatter.withChronology", "Chronology.get"], "method_name": "StringConverter.getPartialValues", "method_implementation": "{\n    if (parser.getZone() != null) {\n        chrono = chrono.withZone(parser.getZone());\n    }\n    long millis = parser.withChronology(chrono).parseMillis((String) object);\n    return chrono.get(fieldSource, millis);\n}", "repo_id": "7", "comment": "/**\n * Extracts the values of the partial from an object of this converter's type.\n * This method checks if the parser has a zone, and uses it if present.\n * This is most useful for parsing local times with UTC.\n *\n * @param fieldSource  a partial that provides access to the fields.\n *  This partial may be incomplete and only getFieldType(int) should be used\n * @param object  the object to convert\n * @param chrono  the chronology to use, which is the non-null result of getChronology()\n * @param parser the parser to use, may be null\n * @return the array of field values that match the fieldSource, must be non-null valid\n * @throws ClassCastException if the object is invalid\n * @throws IllegalArgumentException if the value if invalid\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 589, "method_signature": "int[] getPartialValues(ReadablePartial, Object, Chronology, DateTimeFormatter)"}, "StringConverter.setInto": {"callee_method_ids": [842, 901, 860, 901, 860], "callee_method_names": ["String.indexOf", "String.substring", "String.length", "String.substring", "String.length", "DateTimeFormatter.withChronology", "String.charAt", "PeriodFormatter.withParseType", "DateTimeFormatter.parseDateTime", "DateTime.getMillis", "DateTime.getChronology", "String.charAt", "PeriodFormatter.withParseType", "Chronology.add", "DateTimeFormatter.parseDateTime", "DateTime.getMillis", "DateTime.getChronology", "Chronology.add", "ReadWritableInterval.setInterval", "ReadWritableInterval.setChronology"], "method_name": "StringConverter.setInto", "method_implementation": "{\n    String str = (String) object;\n    int separator = str.indexOf('/');\n    if (separator < 0) {\n        throw new IllegalArgumentException(\"Format requires a '/' separator: \" + str);\n    }\n    String leftStr = str.substring(0, separator);\n    if (leftStr.length() <= 0) {\n        throw new IllegalArgumentException(\"Format invalid: \" + str);\n    }\n    String rightStr = str.substring(separator + 1);\n    if (rightStr.length() <= 0) {\n        throw new IllegalArgumentException(\"Format invalid: \" + str);\n    }\n    DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser();\n    dateTimeParser = dateTimeParser.withChronology(chrono);\n    PeriodFormatter periodParser = ISOPeriodFormat.standard();\n    long startInstant = 0, endInstant = 0;\n    Period period = null;\n    Chronology parsedChrono = null;\n    // before slash\n    char c = leftStr.charAt(0);\n    if (c == 'P' || c == 'p') {\n        period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr);\n    } else {\n        DateTime start = dateTimeParser.parseDateTime(leftStr);\n        startInstant = start.getMillis();\n        parsedChrono = start.getChronology();\n    }\n    // after slash\n    c = rightStr.charAt(0);\n    if (c == 'P' || c == 'p') {\n        if (period != null) {\n            throw new IllegalArgumentException(\"Interval composed of two durations: \" + str);\n        }\n        period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr);\n        chrono = (chrono != null ? chrono : parsedChrono);\n        endInstant = chrono.add(period, startInstant, 1);\n    } else {\n        DateTime end = dateTimeParser.parseDateTime(rightStr);\n        endInstant = end.getMillis();\n        parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology());\n        chrono = (chrono != null ? chrono : parsedChrono);\n        if (period != null) {\n            startInstant = chrono.add(period, endInstant, -1);\n        }\n    }\n    writableInterval.setInterval(startInstant, endInstant);\n    writableInterval.setChronology(chrono);\n}", "repo_id": "7", "comment": "/**\n * Sets the value of the mutable interval from the string.\n *\n * @param writableInterval  the interval to set\n * @param object  the String to convert, must not be null\n * @param chrono  the chronology to use, may be null\n */\n", "repo_name": "joda-time-main/", "id": 592, "method_signature": "void setInto(ReadWritableInterval, Object, Chronology)"}, "TestAbstractPartial.testGetValue": {"callee_method_names": ["MockPartial.getValue", "MockPartial.getValue", "MockPartial.getValue", "MockPartial.getValue"], "method_name": "TestAbstractPartial.testGetValue", "method_implementation": "{\n    MockPartial mock = new MockPartial();\n    assertEquals(1970, mock.getValue(0));\n    assertEquals(1, mock.getValue(1));\n    try {\n        mock.getValue(-1);\n        fail();\n    } catch (IndexOutOfBoundsException ex) {\n    }\n    try {\n        mock.getValue(2);\n        fail();\n    } catch (IndexOutOfBoundsException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1190, "method_signature": "void testGetValue()"}, "TestBaseDateTimeField.test_addWrapField_long_int": {"callee_method_ids": [3, 3, 3], "callee_method_names": ["BaseDateTimeField.addWrapField", "BaseDateTimeField.addWrapField", "BaseDateTimeField.addWrapField"], "method_name": "TestBaseDateTimeField.test_addWrapField_long_int", "method_implementation": "{\n    BaseDateTimeField field = new MockBaseDateTimeField();\n    assertEquals(1029, field.addWrapField(60L * 29, 0));\n    assertEquals(1059, field.addWrapField(60L * 29, 30));\n    assertEquals(1000, field.addWrapField(60L * 29, 31));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1146, "method_signature": "void test_addWrapField_long_int()"}, "TestBaseDateTimeField.test_add_long_int": {"callee_method_ids": [0], "callee_method_names": ["BaseDateTimeField.add"], "method_name": "TestBaseDateTimeField.test_add_long_int", "method_implementation": "{\n    MockCountingDurationField.add_int = 0;\n    BaseDateTimeField field = new MockBaseDateTimeField();\n    assertEquals(61, field.add(1L, 1));\n    assertEquals(1, MockCountingDurationField.add_int);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1145, "method_signature": "void test_add_long_int()"}, "TestBaseDateTimeField.test_constructor": {"callee_method_names": ["BaseDateTimeField.getType"], "method_name": "TestBaseDateTimeField.test_constructor", "method_implementation": "{\n    BaseDateTimeField field = new MockBaseDateTimeField();\n    assertEquals(DateTimeFieldType.secondOfMinute(), field.getType());\n    try {\n        field = new MockBaseDateTimeField(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1142, "method_signature": "void test_constructor()"}, "TestBaseDateTimeField.test_getAsShortText_long_Locale": {"callee_method_names": ["BaseDateTimeField.getAsShortText", "BaseDateTimeField.getAsShortText"], "method_name": "TestBaseDateTimeField.test_getAsShortText_long_Locale", "method_implementation": "{\n    BaseDateTimeField field = new MockBaseDateTimeField();\n    assertEquals(\"29\", field.getAsShortText(60L * 29, Locale.ENGLISH));\n    assertEquals(\"29\", field.getAsShortText(60L * 29, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1144, "method_signature": "void test_getAsShortText_long_Locale()"}, "TestBaseDateTimeField.test_getAsText_long_Locale": {"callee_method_names": ["BaseDateTimeField.getAsText", "BaseDateTimeField.getAsText"], "method_name": "TestBaseDateTimeField.test_getAsText_long_Locale", "method_implementation": "{\n    BaseDateTimeField field = new MockBaseDateTimeField();\n    assertEquals(\"29\", field.getAsText(60L * 29, Locale.ENGLISH));\n    assertEquals(\"29\", field.getAsText(60L * 29, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1143, "method_signature": "void test_getAsText_long_Locale()"}, "TestBaseDateTimeField.test_getDifference_long_long": {"callee_method_names": ["BaseDateTimeField.getDifference"], "method_name": "TestBaseDateTimeField.test_getDifference_long_long", "method_implementation": "{\n    MockCountingDurationField.difference_long = 0;\n    BaseDateTimeField field = new MockBaseDateTimeField();\n    assertEquals(30, field.getDifference(0L, 0L));\n    assertEquals(1, MockCountingDurationField.difference_long);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1147, "method_signature": "void test_getDifference_long_long()"}, "TestBaseDateTimeField.test_getMaximumTextLength_Locale": {"callee_method_ids": [8, 8, 8, 8, 8], "callee_method_names": ["BaseDateTimeField.getMaximumTextLength", "BaseDateTimeField.getMaximumTextLength", "BaseDateTimeField.getMaximumTextLength", "BaseDateTimeField.getMaximumTextLength", "BaseDateTimeField.getMaximumTextLength"], "method_name": "TestBaseDateTimeField.test_getMaximumTextLength_Locale", "method_implementation": "{\n    BaseDateTimeField field = new MockBaseDateTimeField();\n    assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));\n    field = new MockBaseDateTimeField() {\n\n        @Override\n        public int getMaximumValue() {\n            return 5;\n        }\n    };\n    assertEquals(1, field.getMaximumTextLength(Locale.ENGLISH));\n    field = new MockBaseDateTimeField() {\n\n        @Override\n        public int getMaximumValue() {\n            return 555;\n        }\n    };\n    assertEquals(3, field.getMaximumTextLength(Locale.ENGLISH));\n    field = new MockBaseDateTimeField() {\n\n        @Override\n        public int getMaximumValue() {\n            return 5555;\n        }\n    };\n    assertEquals(4, field.getMaximumTextLength(Locale.ENGLISH));\n    field = new MockBaseDateTimeField() {\n\n        @Override\n        public int getMaximumValue() {\n            return -1;\n        }\n    };\n    assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1149, "method_signature": "void test_getMaximumTextLength_Locale()"}, "TestBaseDateTimeField.test_roundFloor_long": {"callee_method_names": ["BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor"], "method_name": "TestBaseDateTimeField.test_roundFloor_long", "method_implementation": "{\n    BaseDateTimeField field = new MockBaseDateTimeField();\n    assertEquals(0L, field.roundFloor(0L));\n    assertEquals(0L, field.roundFloor(29L));\n    assertEquals(0L, field.roundFloor(30L));\n    assertEquals(0L, field.roundFloor(31L));\n    assertEquals(60L, field.roundFloor(60L));\n}", "repo_id": "7", "comment": "//------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1150, "method_signature": "void test_roundFloor_long()"}, "TestBaseDateTimeField.test_set_long_int": {"callee_method_ids": [6, 6], "callee_method_names": ["BaseDateTimeField.set", "BaseDateTimeField.set"], "method_name": "TestBaseDateTimeField.test_set_long_int", "method_implementation": "{\n    BaseDateTimeField field = new MockBaseDateTimeField();\n    assertEquals(1000, field.set(0L, 0));\n    assertEquals(1029, field.set(0L, 29));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1148, "method_signature": "void test_set_long_int()"}, "TestBasePartial.testSetMethods": {"callee_method_names": ["MockPartial.getYear", "MockPartial.getMonthOfYear", "MockPartial.setYear", "MockPartial.getYear", "MockPartial.getMonthOfYear", "MockPartial.setMonthOfYear", "MockPartial.getYear", "MockPartial.getMonthOfYear", "MockPartial.set", "MockPartial.getYear", "MockPartial.getMonthOfYear", "MockPartial.setMonthOfYear", "MockPartial.getYear", "MockPartial.getMonthOfYear", "MockPartial.setMonthOfYear", "MockPartial.getYear", "MockPartial.getMonthOfYear"], "method_name": "TestBasePartial.testSetMethods", "method_implementation": "{\n    MockPartial mock = new MockPartial();\n    assertEquals(1970, mock.getYear());\n    assertEquals(1, mock.getMonthOfYear());\n    mock.setYear(2004);\n    assertEquals(2004, mock.getYear());\n    assertEquals(1, mock.getMonthOfYear());\n    mock.setMonthOfYear(6);\n    assertEquals(2004, mock.getYear());\n    assertEquals(6, mock.getMonthOfYear());\n    mock.set(2005, 5);\n    assertEquals(2005, mock.getYear());\n    assertEquals(5, mock.getMonthOfYear());\n    try {\n        mock.setMonthOfYear(0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    assertEquals(2005, mock.getYear());\n    assertEquals(5, mock.getMonthOfYear());\n    try {\n        mock.setMonthOfYear(13);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    assertEquals(2005, mock.getYear());\n    assertEquals(5, mock.getMonthOfYear());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2193, "method_signature": "void testSetMethods()"}, "TestBaseSingleFieldPeriod.testEqualsHashCode": {"callee_method_names": ["Single.equals", "Single.equals", "Single.equals", "Single.equals", "Single.hashCode", "Single.hashCode", "Single.hashCode", "Single.hashCode", "Single.hashCode", "Single.hashCode", "Single.equals", "Single.equals", "Single.equals", "Single.equals", "Single.hashCode", "Single.hashCode", "Single.hashCode", "Single.hashCode", "Single.equals", "Single.equals", "Single.equals", "Single.equals", "Single.equals", "Single.equals"], "method_name": "TestBaseSingleFieldPeriod.testEqualsHashCode", "method_implementation": "{\n    Single testA = new Single(20);\n    Single testB = new Single(20);\n    assertEquals(true, testA.equals(testB));\n    assertEquals(true, testB.equals(testA));\n    assertEquals(true, testA.equals(testA));\n    assertEquals(true, testB.equals(testB));\n    assertEquals(true, testA.hashCode() == testB.hashCode());\n    assertEquals(true, testA.hashCode() == testA.hashCode());\n    assertEquals(true, testB.hashCode() == testB.hashCode());\n    Single testC = new Single(30);\n    assertEquals(false, testA.equals(testC));\n    assertEquals(false, testB.equals(testC));\n    assertEquals(false, testC.equals(testA));\n    assertEquals(false, testC.equals(testB));\n    assertEquals(false, testA.hashCode() == testC.hashCode());\n    assertEquals(false, testB.hashCode() == testC.hashCode());\n    assertEquals(true, testA.equals(Days.days(20)));\n    assertEquals(true, testA.equals(new Period(0, 0, 0, 20, 0, 0, 0, 0, PeriodType.days())));\n    assertEquals(false, testA.equals(Period.days(2)));\n    assertEquals(false, testA.equals(\"Hello\"));\n    assertEquals(false, testA.equals(Hours.hours(2)));\n    assertEquals(false, testA.equals(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1872, "method_signature": "void testEqualsHashCode()"}, "TestBaseSingleFieldPeriod.testFactory_between_RInstant": {"callee_method_names": [], "method_name": "TestBaseSingleFieldPeriod.testFactory_between_RInstant", "method_implementation": "{\n    // test using Days\n    DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n    DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS);\n    DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS);\n    assertEquals(3, Single.between(start, end1, DurationFieldType.days()));\n    assertEquals(0, Single.between(start, start, DurationFieldType.days()));\n    assertEquals(0, Single.between(end1, end1, DurationFieldType.days()));\n    assertEquals(-3, Single.between(end1, start, DurationFieldType.days()));\n    assertEquals(6, Single.between(start, end2, DurationFieldType.days()));\n    try {\n        Single.between(start, (ReadableInstant) null, DurationFieldType.days());\n        fail();\n    } catch (IllegalArgumentException ex) {\n        // expected\n    }\n    try {\n        Single.between((ReadableInstant) null, end1, DurationFieldType.days());\n        fail();\n    } catch (IllegalArgumentException ex) {\n        // expected\n    }\n    try {\n        Single.between((ReadableInstant) null, (ReadableInstant) null, DurationFieldType.days());\n        fail();\n    } catch (IllegalArgumentException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1870, "method_signature": "void testFactory_between_RInstant()"}, "TestBaseSingleFieldPeriod.testGetSetValue": {"callee_method_names": ["Single.getValue", "Single.setValue", "Single.getValue"], "method_name": "TestBaseSingleFieldPeriod.testGetSetValue", "method_implementation": "{\n    Single test = new Single(20);\n    assertEquals(20, test.getValue());\n    test.setValue(10);\n    assertEquals(10, test.getValue());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1874, "method_signature": "void testGetSetValue()"}, "TestBaseSingleFieldPeriod.testToPeriod": {"callee_method_names": ["Single.toPeriod"], "method_name": "TestBaseSingleFieldPeriod.testToPeriod", "method_implementation": "{\n    Single test = new Single(20);\n    Period expected = Period.days(20);\n    assertEquals(expected, test.toPeriod());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1873, "method_signature": "void testToPeriod()"}, "TestBaseSingleFieldPeriod.testValueIndexMethods": {"callee_method_names": ["Single.size", "Single.getValue", "Single.getValue"], "method_name": "TestBaseSingleFieldPeriod.testValueIndexMethods", "method_implementation": "{\n    Single test = new Single(20);\n    assertEquals(1, test.size());\n    assertEquals(20, test.getValue(0));\n    try {\n        test.getValue(1);\n        fail();\n    } catch (IndexOutOfBoundsException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1871, "method_signature": "void testValueIndexMethods()"}, "TestBuddhistChronology.testDurationFields": {"callee_method_names": ["BuddhistChronology.eras", "BuddhistChronology.centuries", "BuddhistChronology.years", "BuddhistChronology.weekyears", "BuddhistChronology.months", "BuddhistChronology.weeks", "BuddhistChronology.days", "BuddhistChronology.hours", "BuddhistChronology.minutes", "BuddhistChronology.seconds", "BuddhistChronology.millis", "BuddhistChronology.eras", "BuddhistChronology.centuries", "BuddhistChronology.years", "BuddhistChronology.weekyears", "BuddhistChronology.months", "BuddhistChronology.weeks", "BuddhistChronology.days", "BuddhistChronology.halfdays", "BuddhistChronology.hours", "BuddhistChronology.minutes", "BuddhistChronology.seconds", "BuddhistChronology.millis", "BuddhistChronology.centuries", "BuddhistChronology.years", "BuddhistChronology.weekyears", "BuddhistChronology.months", "BuddhistChronology.weeks", "BuddhistChronology.days", "BuddhistChronology.halfdays", "BuddhistChronology.hours", "BuddhistChronology.minutes", "BuddhistChronology.seconds", "BuddhistChronology.millis", "BuddhistChronology.centuries", "BuddhistChronology.years", "BuddhistChronology.weekyears", "BuddhistChronology.months", "BuddhistChronology.weeks", "BuddhistChronology.days", "BuddhistChronology.halfdays", "BuddhistChronology.hours", "BuddhistChronology.minutes", "BuddhistChronology.seconds", "BuddhistChronology.millis", "BuddhistChronology.centuries", "BuddhistChronology.years", "BuddhistChronology.weekyears", "BuddhistChronology.months", "BuddhistChronology.weeks", "BuddhistChronology.days", "BuddhistChronology.halfdays", "BuddhistChronology.hours", "BuddhistChronology.minutes", "BuddhistChronology.seconds", "BuddhistChronology.millis"], "method_name": "TestBuddhistChronology.testDurationFields", "method_implementation": "{\n    final BuddhistChronology buddhist = BuddhistChronology.getInstance();\n    assertEquals(\"eras\", buddhist.eras().getName());\n    assertEquals(\"centuries\", buddhist.centuries().getName());\n    assertEquals(\"years\", buddhist.years().getName());\n    assertEquals(\"weekyears\", buddhist.weekyears().getName());\n    assertEquals(\"months\", buddhist.months().getName());\n    assertEquals(\"weeks\", buddhist.weeks().getName());\n    assertEquals(\"days\", buddhist.days().getName());\n    assertEquals(\"halfdays\", GregorianChronology.getInstance().halfdays().getName());\n    assertEquals(\"hours\", buddhist.hours().getName());\n    assertEquals(\"minutes\", buddhist.minutes().getName());\n    assertEquals(\"seconds\", buddhist.seconds().getName());\n    assertEquals(\"millis\", buddhist.millis().getName());\n    assertEquals(false, buddhist.eras().isSupported());\n    assertEquals(true, buddhist.centuries().isSupported());\n    assertEquals(true, buddhist.years().isSupported());\n    assertEquals(true, buddhist.weekyears().isSupported());\n    assertEquals(true, buddhist.months().isSupported());\n    assertEquals(true, buddhist.weeks().isSupported());\n    assertEquals(true, buddhist.days().isSupported());\n    assertEquals(true, buddhist.halfdays().isSupported());\n    assertEquals(true, buddhist.hours().isSupported());\n    assertEquals(true, buddhist.minutes().isSupported());\n    assertEquals(true, buddhist.seconds().isSupported());\n    assertEquals(true, buddhist.millis().isSupported());\n    assertEquals(false, buddhist.centuries().isPrecise());\n    assertEquals(false, buddhist.years().isPrecise());\n    assertEquals(false, buddhist.weekyears().isPrecise());\n    assertEquals(false, buddhist.months().isPrecise());\n    assertEquals(false, buddhist.weeks().isPrecise());\n    assertEquals(false, buddhist.days().isPrecise());\n    assertEquals(false, buddhist.halfdays().isPrecise());\n    assertEquals(true, buddhist.hours().isPrecise());\n    assertEquals(true, buddhist.minutes().isPrecise());\n    assertEquals(true, buddhist.seconds().isPrecise());\n    assertEquals(true, buddhist.millis().isPrecise());\n    final BuddhistChronology buddhistUTC = BuddhistChronology.getInstanceUTC();\n    assertEquals(false, buddhistUTC.centuries().isPrecise());\n    assertEquals(false, buddhistUTC.years().isPrecise());\n    assertEquals(false, buddhistUTC.weekyears().isPrecise());\n    assertEquals(false, buddhistUTC.months().isPrecise());\n    assertEquals(true, buddhistUTC.weeks().isPrecise());\n    assertEquals(true, buddhistUTC.days().isPrecise());\n    assertEquals(true, buddhistUTC.halfdays().isPrecise());\n    assertEquals(true, buddhistUTC.hours().isPrecise());\n    assertEquals(true, buddhistUTC.minutes().isPrecise());\n    assertEquals(true, buddhistUTC.seconds().isPrecise());\n    assertEquals(true, buddhistUTC.millis().isPrecise());\n    final DateTimeZone gmt = DateTimeZone.forID(\"Etc/GMT\");\n    final BuddhistChronology buddhistGMT = BuddhistChronology.getInstance(gmt);\n    assertEquals(false, buddhistGMT.centuries().isPrecise());\n    assertEquals(false, buddhistGMT.years().isPrecise());\n    assertEquals(false, buddhistGMT.weekyears().isPrecise());\n    assertEquals(false, buddhistGMT.months().isPrecise());\n    assertEquals(true, buddhistGMT.weeks().isPrecise());\n    assertEquals(true, buddhistGMT.days().isPrecise());\n    assertEquals(true, buddhistGMT.halfdays().isPrecise());\n    assertEquals(true, buddhistGMT.hours().isPrecise());\n    assertEquals(true, buddhistGMT.minutes().isPrecise());\n    assertEquals(true, buddhistGMT.seconds().isPrecise());\n    assertEquals(true, buddhistGMT.millis().isPrecise());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1948, "method_signature": "void testDurationFields()"}, "TestBuddhistChronology.testEquality": {"callee_method_names": [], "method_name": "TestBuddhistChronology.testEquality", "method_implementation": "{\n    assertSame(BuddhistChronology.getInstance(TOKYO), BuddhistChronology.getInstance(TOKYO));\n    assertSame(BuddhistChronology.getInstance(LONDON), BuddhistChronology.getInstance(LONDON));\n    assertSame(BuddhistChronology.getInstance(PARIS), BuddhistChronology.getInstance(PARIS));\n    assertSame(BuddhistChronology.getInstanceUTC(), BuddhistChronology.getInstanceUTC());\n    assertSame(BuddhistChronology.getInstance(), BuddhistChronology.getInstance(LONDON));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1947, "method_signature": "void testEquality()"}, "TestCachedDateTimeZone.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestCachedDateTimeZone.testSerialization", "method_implementation": "{\n    CachedDateTimeZone test = CachedDateTimeZone.forZone(DateTimeZone.forID(\"Europe/Paris\"));\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    CachedDateTimeZone result = (CachedDateTimeZone) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2124, "method_signature": "void testSerialization()"}, "TestCalendarConverter.testGetChronology_Object_Zone": {"callee_method_names": ["GregorianCalendar.setGregorianChange", "GregorianCalendar.setGregorianChange", "GregorianCalendar.setGregorianChange", "Calendar.setTimeZone"], "method_name": "TestCalendarConverter.testGetChronology_Object_Zone", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Paris\"));\n    assertEquals(GJChronology.getInstance(MOSCOW), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));\n    cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n    assertEquals(GJChronology.getInstance(), CalendarConverter.INSTANCE.getChronology(cal, (DateTimeZone) null));\n    cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n    cal.setGregorianChange(new Date(0L));\n    assertEquals(GJChronology.getInstance(MOSCOW, 0L, 4), CalendarConverter.INSTANCE.getChronology(cal, MOSCOW));\n    cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n    cal.setGregorianChange(new Date(Long.MAX_VALUE));\n    assertEquals(JulianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));\n    cal = new GregorianCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n    cal.setGregorianChange(new Date(Long.MIN_VALUE));\n    assertEquals(GregorianChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(cal, PARIS));\n    Calendar uc = new MockUnknownCalendar(TimeZone.getTimeZone(\"Europe/Moscow\"));\n    assertEquals(ISOChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(uc, PARIS));\n    try {\n        Calendar bc = (Calendar) Class.forName(\"sun.util.BuddhistCalendar\").newInstance();\n        bc.setTimeZone(TimeZone.getTimeZone(\"Europe/Moscow\"));\n        assertEquals(BuddhistChronology.getInstance(PARIS), CalendarConverter.INSTANCE.getChronology(bc, PARIS));\n    } catch (ClassNotFoundException ex) {\n        // ignore not Sun JDK\n    } catch (IllegalAccessException ex) {\n        // ignore JDK 9 modules\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2084, "method_signature": "void testGetChronology_Object_Zone()"}, "TestCalendarConverter.testGetInstantMillis_Object_Chronology": {"callee_method_names": ["GregorianCalendar.setTime", "GregorianCalendar.getTime"], "method_name": "TestCalendarConverter.testGetInstantMillis_Object_Chronology", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(new Date(123L));\n    assertEquals(123L, CalendarConverter.INSTANCE.getInstantMillis(cal, JULIAN));\n    assertEquals(123L, cal.getTime().getTime());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2083, "method_signature": "void testGetInstantMillis_Object_Chronology()"}, "TestCalendarConverter.testGetPartialValues": {"callee_method_names": ["GregorianCalendar.setTime", "Chronology.get"], "method_name": "TestCalendarConverter.testGetPartialValues", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar();\n    cal.setTime(new Date(12345678L));\n    TimeOfDay tod = new TimeOfDay();\n    int[] expected = ISO.get(tod, 12345678L);\n    int[] actual = CalendarConverter.INSTANCE.getPartialValues(tod, cal, ISO);\n    assertEquals(true, Arrays.equals(expected, actual));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2085, "method_signature": "void testGetPartialValues()"}, "TestCalendarConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestCalendarConverter.testSingleton", "method_implementation": "{\n    Class cls = CalendarConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2082, "method_signature": "void testSingleton()"}, "TestChronology.testEqualsHashCode_ISO": {"callee_method_names": ["Chronology.equals", "Chronology.equals", "DateTime.equals", "DateTime.equals", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode"], "method_name": "TestChronology.testEqualsHashCode_ISO", "method_implementation": "{\n    Chronology chrono1 = ISOChronology.getInstanceUTC();\n    Chronology chrono2 = ISOChronology.getInstanceUTC();\n    Chronology chrono3 = ISOChronology.getInstance();\n    assertEquals(true, chrono1.equals(chrono2));\n    assertEquals(false, chrono1.equals(chrono3));\n    DateTime dt1 = new DateTime(0L, chrono1);\n    DateTime dt2 = new DateTime(0L, chrono2);\n    DateTime dt3 = new DateTime(0L, chrono3);\n    assertEquals(true, dt1.equals(dt2));\n    assertEquals(false, dt1.equals(dt3));\n    assertEquals(true, chrono1.hashCode() == chrono2.hashCode());\n    assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1222, "method_signature": "void testEqualsHashCode_ISO()"}, "TestChronology.testEqualsHashCode_Lenient": {"callee_method_names": ["Chronology.equals", "Chronology.equals", "DateTime.equals", "DateTime.equals", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode"], "method_name": "TestChronology.testEqualsHashCode_Lenient", "method_implementation": "{\n    Chronology chrono1 = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n    Chronology chrono2 = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n    Chronology chrono3 = LenientChronology.getInstance(ISOChronology.getInstance());\n    assertEquals(true, chrono1.equals(chrono2));\n    assertEquals(false, chrono1.equals(chrono3));\n    DateTime dt1 = new DateTime(0L, chrono1);\n    DateTime dt2 = new DateTime(0L, chrono2);\n    DateTime dt3 = new DateTime(0L, chrono3);\n    assertEquals(true, dt1.equals(dt2));\n    assertEquals(false, dt1.equals(dt3));\n    assertEquals(true, chrono1.hashCode() == chrono2.hashCode());\n    assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1223, "method_signature": "void testEqualsHashCode_Lenient()"}, "TestChronology.testEqualsHashCode_Limit": {"callee_method_names": ["Chronology.equals", "Chronology.equals", "Chronology.equals", "DateTime.equals", "DateTime.equals", "DateTime.equals", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode"], "method_name": "TestChronology.testEqualsHashCode_Limit", "method_implementation": "{\n    DateTime lower = new DateTime(0L);\n    DateTime higherA = new DateTime(1000000L);\n    DateTime higherB = new DateTime(2000000L);\n    Chronology chrono1 = LimitChronology.getInstance(ISOChronology.getInstanceUTC(), lower, higherA);\n    Chronology chrono2A = LimitChronology.getInstance(ISOChronology.getInstanceUTC(), lower, higherA);\n    Chronology chrono2B = LimitChronology.getInstance(ISOChronology.getInstanceUTC(), lower, higherB);\n    Chronology chrono3 = LimitChronology.getInstance(ISOChronology.getInstance(), lower, higherA);\n    assertEquals(true, chrono1.equals(chrono2A));\n    assertEquals(false, chrono1.equals(chrono2B));\n    assertEquals(false, chrono1.equals(chrono3));\n    DateTime dt1 = new DateTime(0L, chrono1);\n    DateTime dt2A = new DateTime(0L, chrono2A);\n    DateTime dt2B = new DateTime(0L, chrono2B);\n    DateTime dt3 = new DateTime(0L, chrono3);\n    assertEquals(true, dt1.equals(dt2A));\n    assertEquals(false, dt1.equals(dt2B));\n    assertEquals(false, dt1.equals(dt3));\n    assertEquals(true, chrono1.hashCode() == chrono2A.hashCode());\n    assertEquals(false, chrono1.hashCode() == chrono2B.hashCode());\n    assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1225, "method_signature": "void testEqualsHashCode_Limit()"}, "TestChronology.testEqualsHashCode_Strict": {"callee_method_names": ["Chronology.equals", "Chronology.equals", "DateTime.equals", "DateTime.equals", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode"], "method_name": "TestChronology.testEqualsHashCode_Strict", "method_implementation": "{\n    Chronology chrono1 = StrictChronology.getInstance(ISOChronology.getInstanceUTC());\n    Chronology chrono2 = StrictChronology.getInstance(ISOChronology.getInstanceUTC());\n    Chronology chrono3 = StrictChronology.getInstance(ISOChronology.getInstance());\n    assertEquals(true, chrono1.equals(chrono2));\n    assertEquals(false, chrono1.equals(chrono3));\n    DateTime dt1 = new DateTime(0L, chrono1);\n    DateTime dt2 = new DateTime(0L, chrono2);\n    DateTime dt3 = new DateTime(0L, chrono3);\n    assertEquals(true, dt1.equals(dt2));\n    assertEquals(false, dt1.equals(dt3));\n    assertEquals(true, chrono1.hashCode() == chrono2.hashCode());\n    assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1224, "method_signature": "void testEqualsHashCode_Strict()"}, "TestChronology.testEqualsHashCode_Zoned": {"callee_method_names": ["Chronology.equals", "Chronology.equals", "DateTime.equals", "DateTime.equals", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode", "Chronology.hashCode"], "method_name": "TestChronology.testEqualsHashCode_Zoned", "method_implementation": "{\n    DateTimeZone zoneA = DateTimeZone.forID(\"Europe/Paris\");\n    DateTimeZone zoneB = DateTimeZone.forID(\"Asia/Tokyo\");\n    Chronology chrono1 = ZonedChronology.getInstance(ISOChronology.getInstanceUTC(), zoneA);\n    Chronology chrono2 = ZonedChronology.getInstance(ISOChronology.getInstanceUTC(), zoneA);\n    Chronology chrono3 = ZonedChronology.getInstance(ISOChronology.getInstanceUTC(), zoneB);\n    assertEquals(true, chrono1.equals(chrono2));\n    assertEquals(false, chrono1.equals(chrono3));\n    DateTime dt1 = new DateTime(0L, chrono1);\n    DateTime dt2 = new DateTime(0L, chrono2);\n    DateTime dt3 = new DateTime(0L, chrono3);\n    assertEquals(true, dt1.equals(dt2));\n    assertEquals(false, dt1.equals(dt3));\n    assertEquals(true, chrono1.hashCode() == chrono2.hashCode());\n    assertEquals(false, chrono1.hashCode() == chrono3.hashCode());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1226, "method_signature": "void testEqualsHashCode_Zoned()"}, "TestChronology.testTest": {"callee_method_names": [], "method_name": "TestChronology.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1221, "method_signature": "void testTest()"}, "TestChronology.testToString": {"callee_method_ids": [333], "callee_method_names": ["ISOChronology.toString"], "method_name": "TestChronology.testToString", "method_implementation": "{\n    DateTimeZone paris = DateTimeZone.forID(\"Europe/Paris\");\n    ISOChronology isoParis = ISOChronology.getInstance(paris);\n    assertEquals(\"ISOChronology[Europe/Paris]\", isoParis.toString());\n    assertEquals(\"GJChronology[Europe/Paris]\", GJChronology.getInstance(paris).toString());\n    assertEquals(\"GregorianChronology[Europe/Paris]\", GregorianChronology.getInstance(paris).toString());\n    assertEquals(\"JulianChronology[Europe/Paris]\", JulianChronology.getInstance(paris).toString());\n    assertEquals(\"BuddhistChronology[Europe/Paris]\", BuddhistChronology.getInstance(paris).toString());\n    assertEquals(\"CopticChronology[Europe/Paris]\", CopticChronology.getInstance(paris).toString());\n    assertEquals(\"EthiopicChronology[Europe/Paris]\", EthiopicChronology.getInstance(paris).toString());\n    assertEquals(\"IslamicChronology[Europe/Paris]\", IslamicChronology.getInstance(paris).toString());\n    assertEquals(\"LenientChronology[ISOChronology[Europe/Paris]]\", LenientChronology.getInstance(isoParis).toString());\n    assertEquals(\"StrictChronology[ISOChronology[Europe/Paris]]\", StrictChronology.getInstance(isoParis).toString());\n    assertEquals(\"LimitChronology[ISOChronology[Europe/Paris], NoLimit, NoLimit]\", LimitChronology.getInstance(isoParis, null, null).toString());\n    assertEquals(\"ZonedChronology[ISOChronology[UTC], Europe/Paris]\", ZonedChronology.getInstance(isoParis, paris).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1227, "method_signature": "void testToString()"}, "TestCompiler.testCompile": {"callee_method_names": ["Provider.getZone", "DateTimeZone.getID", "DateTimeZone.isFixed"], "method_name": "TestCompiler.testCompile", "method_implementation": "{\n    Provider provider = compileAndLoad(AMERICA_LOS_ANGELES_FILE);\n    DateTimeZone tz = provider.getZone(\"America/Los_Angeles\");\n    assertEquals(\"America/Los_Angeles\", tz.getID());\n    assertEquals(false, tz.isFixed());\n    TestBuilder.testForwardTransitions(tz, TestBuilder.AMERICA_LOS_ANGELES_DATA);\n    TestBuilder.testReverseTransitions(tz, TestBuilder.AMERICA_LOS_ANGELES_DATA);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2126, "method_signature": "void testCompile()"}, "TestCompiler.testDateTimeZoneBuilder": {"callee_method_names": ["Thread.start", "Thread.join"], "method_name": "TestCompiler.testDateTimeZoneBuilder", "method_implementation": "{\n    // test multithreading, issue #18\n    getTestDataTimeZoneBuilder().toDateTimeZone(\"TestDTZ1\", true);\n    final DateTimeZone[] zone = new DateTimeZone[1];\n    Thread t = new Thread(new Runnable() {\n\n        public void run() {\n            zone[0] = getTestDataTimeZoneBuilder().toDateTimeZone(\"TestDTZ2\", true);\n        }\n    });\n    t.start();\n    t.join();\n    assertNotNull(zone[0]);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2125, "method_signature": "void testDateTimeZoneBuilder()"}, "TestCompiler.test_2400_fromDay": {"callee_method_names": [], "method_name": "TestCompiler.test_2400_fromDay", "method_implementation": "{\n    StringTokenizer st = new StringTokenizer(\"Apr Sun>=1  24:00\");\n    DateTimeOfYear test = new DateTimeOfYear(st);\n    // Apr\n    assertEquals(4, test.iMonthOfYear);\n    // 2nd\n    assertEquals(2, test.iDayOfMonth);\n    // Mon\n    assertEquals(1, test.iDayOfWeek);\n    // 00:00\n    assertEquals(0, test.iMillisOfDay);\n    assertEquals(true, test.iAdvanceDayOfWeek);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2127, "method_signature": "void test_2400_fromDay()"}, "TestConverterManager.testAddDurationConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testAddDurationConverter1", "method_implementation": "{\n    DurationConverter c = new DurationConverter() {\n\n        public long getDurationMillis(Object object) {\n            return 0;\n        }\n\n        public Class getSupportedType() {\n            return Boolean.class;\n        }\n    };\n    try {\n        DurationConverter removed = ConverterManager.getInstance().addDurationConverter(c);\n        assertEquals(null, removed);\n        assertEquals(Boolean.class, ConverterManager.getInstance().getDurationConverter(Boolean.TRUE).getSupportedType());\n        assertEquals(DURATION_SIZE + 1, ConverterManager.getInstance().getDurationConverters().length);\n    } finally {\n        ConverterManager.getInstance().removeDurationConverter(c);\n    }\n    assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2101, "method_signature": "void testAddDurationConverter1()"}, "TestConverterManager.testAddInstantConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testAddInstantConverter1", "method_implementation": "{\n    InstantConverter c = new InstantConverter() {\n\n        public long getInstantMillis(Object object, Chronology chrono) {\n            return 0;\n        }\n\n        public Chronology getChronology(Object object, DateTimeZone zone) {\n            return null;\n        }\n\n        public Chronology getChronology(Object object, Chronology chrono) {\n            return null;\n        }\n\n        public Class getSupportedType() {\n            return Boolean.class;\n        }\n    };\n    try {\n        InstantConverter removed = ConverterManager.getInstance().addInstantConverter(c);\n        assertEquals(null, removed);\n        assertEquals(Boolean.class, ConverterManager.getInstance().getInstantConverter(Boolean.TRUE).getSupportedType());\n        assertEquals(7, ConverterManager.getInstance().getInstantConverters().length);\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(c);\n    }\n    assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2097, "method_signature": "void testAddInstantConverter1()"}, "TestConverterManager.testAddIntervalConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testAddIntervalConverter1", "method_implementation": "{\n    IntervalConverter c = new IntervalConverter() {\n\n        public boolean isReadableInterval(Object object, Chronology chrono) {\n            return false;\n        }\n\n        public void setInto(ReadWritableInterval interval, Object object, Chronology chrono) {\n        }\n\n        public Class getSupportedType() {\n            return Boolean.class;\n        }\n    };\n    try {\n        IntervalConverter removed = ConverterManager.getInstance().addIntervalConverter(c);\n        assertEquals(null, removed);\n        assertEquals(Boolean.class, ConverterManager.getInstance().getIntervalConverter(Boolean.TRUE).getSupportedType());\n        assertEquals(INTERVAL_SIZE + 1, ConverterManager.getInstance().getIntervalConverters().length);\n    } finally {\n        ConverterManager.getInstance().removeIntervalConverter(c);\n    }\n    assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2105, "method_signature": "void testAddIntervalConverter1()"}, "TestConverterManager.testAddPartialConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testAddPartialConverter1", "method_implementation": "{\n    PartialConverter c = new PartialConverter() {\n\n        public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono) {\n            return null;\n        }\n\n        public int[] getPartialValues(ReadablePartial partial, Object object, Chronology chrono, DateTimeFormatter parser) {\n            return null;\n        }\n\n        public Chronology getChronology(Object object, DateTimeZone zone) {\n            return null;\n        }\n\n        public Chronology getChronology(Object object, Chronology chrono) {\n            return null;\n        }\n\n        public Class getSupportedType() {\n            return Boolean.class;\n        }\n    };\n    try {\n        PartialConverter removed = ConverterManager.getInstance().addPartialConverter(c);\n        assertEquals(null, removed);\n        assertEquals(Boolean.class, ConverterManager.getInstance().getPartialConverter(Boolean.TRUE).getSupportedType());\n        assertEquals(PARTIAL_SIZE + 1, ConverterManager.getInstance().getPartialConverters().length);\n    } finally {\n        ConverterManager.getInstance().removePartialConverter(c);\n    }\n    assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2099, "method_signature": "void testAddPartialConverter1()"}, "TestConverterManager.testAddPeriodConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testAddPeriodConverter1", "method_implementation": "{\n    PeriodConverter c = new PeriodConverter() {\n\n        public void setInto(ReadWritablePeriod duration, Object object, Chronology c) {\n        }\n\n        public PeriodType getPeriodType(Object object) {\n            return null;\n        }\n\n        public Class getSupportedType() {\n            return Boolean.class;\n        }\n    };\n    try {\n        PeriodConverter removed = ConverterManager.getInstance().addPeriodConverter(c);\n        assertEquals(null, removed);\n        assertEquals(Boolean.class, ConverterManager.getInstance().getPeriodConverter(Boolean.TRUE).getSupportedType());\n        assertEquals(PERIOD_SIZE + 1, ConverterManager.getInstance().getPeriodConverters().length);\n    } finally {\n        ConverterManager.getInstance().removePeriodConverter(c);\n    }\n    assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2103, "method_signature": "void testAddPeriodConverter1()"}, "TestConverterManager.testGetInstantConverter": {"callee_method_names": ["InstantConverter.getSupportedType", "InstantConverter.getSupportedType", "InstantConverter.getSupportedType", "InstantConverter.getSupportedType", "InstantConverter.getSupportedType", "InstantConverter.getSupportedType"], "method_name": "TestConverterManager.testGetInstantConverter", "method_implementation": "{\n    InstantConverter c = ConverterManager.getInstance().getInstantConverter(new Long(0L));\n    assertEquals(Long.class, c.getSupportedType());\n    c = ConverterManager.getInstance().getInstantConverter(new DateTime());\n    assertEquals(ReadableInstant.class, c.getSupportedType());\n    c = ConverterManager.getInstance().getInstantConverter(\"\");\n    assertEquals(String.class, c.getSupportedType());\n    c = ConverterManager.getInstance().getInstantConverter(new Date());\n    assertEquals(Date.class, c.getSupportedType());\n    c = ConverterManager.getInstance().getInstantConverter(new GregorianCalendar());\n    assertEquals(Calendar.class, c.getSupportedType());\n    c = ConverterManager.getInstance().getInstantConverter(null);\n    assertEquals(null, c.getSupportedType());\n    try {\n        ConverterManager.getInstance().getInstantConverter(Boolean.TRUE);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2096, "method_signature": "void testGetInstantConverter()"}, "TestConverterManager.testRemoveDurationConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testRemoveDurationConverter1", "method_implementation": "{\n    try {\n        DurationConverter removed = ConverterManager.getInstance().removeDurationConverter(StringConverter.INSTANCE);\n        assertEquals(StringConverter.INSTANCE, removed);\n        assertEquals(DURATION_SIZE - 1, ConverterManager.getInstance().getDurationConverters().length);\n    } finally {\n        ConverterManager.getInstance().addDurationConverter(StringConverter.INSTANCE);\n    }\n    assertEquals(DURATION_SIZE, ConverterManager.getInstance().getDurationConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2102, "method_signature": "void testRemoveDurationConverter1()"}, "TestConverterManager.testRemoveInstantConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testRemoveInstantConverter1", "method_implementation": "{\n    try {\n        InstantConverter removed = ConverterManager.getInstance().removeInstantConverter(StringConverter.INSTANCE);\n        assertEquals(StringConverter.INSTANCE, removed);\n        assertEquals(5, ConverterManager.getInstance().getInstantConverters().length);\n    } finally {\n        ConverterManager.getInstance().addInstantConverter(StringConverter.INSTANCE);\n    }\n    assertEquals(6, ConverterManager.getInstance().getInstantConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2098, "method_signature": "void testRemoveInstantConverter1()"}, "TestConverterManager.testRemoveIntervalConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testRemoveIntervalConverter1", "method_implementation": "{\n    try {\n        IntervalConverter removed = ConverterManager.getInstance().removeIntervalConverter(StringConverter.INSTANCE);\n        assertEquals(StringConverter.INSTANCE, removed);\n        assertEquals(INTERVAL_SIZE - 1, ConverterManager.getInstance().getIntervalConverters().length);\n    } finally {\n        ConverterManager.getInstance().addIntervalConverter(StringConverter.INSTANCE);\n    }\n    assertEquals(INTERVAL_SIZE, ConverterManager.getInstance().getIntervalConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2106, "method_signature": "void testRemoveIntervalConverter1()"}, "TestConverterManager.testRemovePartialConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testRemovePartialConverter1", "method_implementation": "{\n    try {\n        PartialConverter removed = ConverterManager.getInstance().removePartialConverter(StringConverter.INSTANCE);\n        assertEquals(StringConverter.INSTANCE, removed);\n        assertEquals(PARTIAL_SIZE - 1, ConverterManager.getInstance().getPartialConverters().length);\n    } finally {\n        ConverterManager.getInstance().addPartialConverter(StringConverter.INSTANCE);\n    }\n    assertEquals(PARTIAL_SIZE, ConverterManager.getInstance().getPartialConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2100, "method_signature": "void testRemovePartialConverter1()"}, "TestConverterManager.testRemovePeriodConverter1": {"callee_method_names": [], "method_name": "TestConverterManager.testRemovePeriodConverter1", "method_implementation": "{\n    try {\n        PeriodConverter removed = ConverterManager.getInstance().removePeriodConverter(StringConverter.INSTANCE);\n        assertEquals(StringConverter.INSTANCE, removed);\n        assertEquals(PERIOD_SIZE - 1, ConverterManager.getInstance().getPeriodConverters().length);\n    } finally {\n        ConverterManager.getInstance().addPeriodConverter(StringConverter.INSTANCE);\n    }\n    assertEquals(PERIOD_SIZE, ConverterManager.getInstance().getPeriodConverters().length);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2104, "method_signature": "void testRemovePeriodConverter1()"}, "TestConverterManager.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers"], "method_name": "TestConverterManager.testSingleton", "method_implementation": "{\n    Class cls = ConverterManager.class;\n    assertEquals(true, Modifier.isPublic(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(true, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2095, "method_signature": "void testSingleton()"}, "TestConverterSet.testAddNullRemoved1": {"callee_method_ids": [577], "callee_method_names": ["ConverterSet.add", "ConverterSet.size", "ConverterSet.size"], "method_name": "TestConverterSet.testAddNullRemoved1", "method_implementation": "{\n    Converter[] array = new Converter[] { c1, c2, c3, c4 };\n    ConverterSet set = new ConverterSet(array);\n    ConverterSet result = set.add(c5, null);\n    assertEquals(4, set.size());\n    assertEquals(5, result.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2066, "method_signature": "void testAddNullRemoved1()"}, "TestConverterSet.testBigHashtable": {"callee_method_ids": [576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576], "callee_method_names": ["ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.select", "ConverterSet.size"], "method_name": "TestConverterSet.testBigHashtable", "method_implementation": "{\n    Converter[] array = new Converter[] { c1, c2, c3, c4 };\n    ConverterSet set = new ConverterSet(array);\n    set.select(Boolean.class);\n    set.select(Character.class);\n    set.select(Byte.class);\n    set.select(Short.class);\n    set.select(Integer.class);\n    set.select(Long.class);\n    set.select(Float.class);\n    set.select(Double.class);\n    set.select(null);\n    set.select(Calendar.class);\n    set.select(GregorianCalendar.class);\n    set.select(DateTime.class);\n    set.select(DateMidnight.class);\n    set.select(ReadableInstant.class);\n    set.select(ReadableDateTime.class);\n    // 16\n    set.select(ReadWritableInstant.class);\n    set.select(ReadWritableDateTime.class);\n    set.select(DateTime.class);\n    assertEquals(4, set.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2065, "method_signature": "void testBigHashtable()"}, "TestConverterSet.testClass": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructors", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Constructor.getModifiers", "Constructor.getModifiers"], "method_name": "TestConverterSet.testClass", "method_implementation": "{\n    Class cls = ConverterSet.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    Constructor con = cls.getDeclaredConstructors()[0];\n    assertEquals(false, Modifier.isPublic(con.getModifiers()));\n    assertEquals(false, Modifier.isProtected(con.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(con.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2064, "method_signature": "void testClass()"}, "TestConverterSet.testRemoveBadIndex1": {"callee_method_ids": [579], "callee_method_names": ["ConverterSet.remove", "ConverterSet.size"], "method_name": "TestConverterSet.testRemoveBadIndex1", "method_implementation": "{\n    Converter[] array = new Converter[] { c1, c2, c3, c4 };\n    ConverterSet set = new ConverterSet(array);\n    try {\n        set.remove(200, null);\n        fail();\n    } catch (IndexOutOfBoundsException ex) {\n    }\n    assertEquals(4, set.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2068, "method_signature": "void testRemoveBadIndex1()"}, "TestConverterSet.testRemoveNullRemoved1": {"callee_method_ids": [579], "callee_method_names": ["ConverterSet.remove", "ConverterSet.size", "ConverterSet.size"], "method_name": "TestConverterSet.testRemoveNullRemoved1", "method_implementation": "{\n    Converter[] array = new Converter[] { c1, c2, c3, c4 };\n    ConverterSet set = new ConverterSet(array);\n    ConverterSet result = set.remove(c3, null);\n    assertEquals(4, set.size());\n    assertEquals(3, result.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2067, "method_signature": "void testRemoveNullRemoved1()"}, "TestCopticChronology.testCalendar": {"callee_method_names": ["DateTime.getMillis", "Chronology.dayOfWeek", "Chronology.dayOfYear", "Chronology.dayOfMonth", "Chronology.monthOfYear", "Chronology.year", "Chronology.yearOfEra", "Chronology.era", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.getMaximumValue", "DateTimeField.get", "DateTimeField.getAsText", "DateTimeField.getAsShortText", "DateTimeField.isLeap", "DateTimeField.isLeap"], "method_name": "TestCopticChronology.testCalendar", "method_implementation": "{\n    if (TestAll.FAST) {\n        return;\n    }\n    System.out.println(\"\\nTestCopticChronology.testCalendar\");\n    DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, COPTIC_UTC);\n    long millis = epoch.getMillis();\n    long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();\n    DateTimeField dayOfWeek = COPTIC_UTC.dayOfWeek();\n    DateTimeField dayOfYear = COPTIC_UTC.dayOfYear();\n    DateTimeField dayOfMonth = COPTIC_UTC.dayOfMonth();\n    DateTimeField monthOfYear = COPTIC_UTC.monthOfYear();\n    DateTimeField year = COPTIC_UTC.year();\n    DateTimeField yearOfEra = COPTIC_UTC.yearOfEra();\n    DateTimeField era = COPTIC_UTC.era();\n    int expectedDOW = new DateTime(284, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();\n    int expectedDOY = 1;\n    int expectedDay = 1;\n    int expectedMonth = 1;\n    int expectedYear = 1;\n    while (millis < end) {\n        int dowValue = dayOfWeek.get(millis);\n        int doyValue = dayOfYear.get(millis);\n        int dayValue = dayOfMonth.get(millis);\n        int monthValue = monthOfYear.get(millis);\n        int yearValue = year.get(millis);\n        int yearOfEraValue = yearOfEra.get(millis);\n        int monthLen = dayOfMonth.getMaximumValue(millis);\n        if (monthValue < 1 || monthValue > 13) {\n            fail(\"Bad month: \" + millis);\n        }\n        // test era\n        assertEquals(1, era.get(millis));\n        assertEquals(\"AM\", era.getAsText(millis));\n        assertEquals(\"AM\", era.getAsShortText(millis));\n        // test date\n        assertEquals(expectedYear, yearValue);\n        assertEquals(expectedYear, yearOfEraValue);\n        assertEquals(expectedMonth, monthValue);\n        assertEquals(expectedDay, dayValue);\n        assertEquals(expectedDOW, dowValue);\n        assertEquals(expectedDOY, doyValue);\n        // test leap year\n        assertEquals(yearValue % 4 == 3, year.isLeap(millis));\n        // test month length\n        if (monthValue == 13) {\n            assertEquals(yearValue % 4 == 3, monthOfYear.isLeap(millis));\n            if (yearValue % 4 == 3) {\n                assertEquals(6, monthLen);\n            } else {\n                assertEquals(5, monthLen);\n            }\n        } else {\n            assertEquals(30, monthLen);\n        }\n        // recalculate date\n        expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;\n        expectedDay++;\n        expectedDOY++;\n        if (expectedDay == 31 && expectedMonth < 13) {\n            expectedDay = 1;\n            expectedMonth++;\n        } else if (expectedMonth == 13) {\n            if (expectedYear % 4 == 3 && expectedDay == 7) {\n                expectedDay = 1;\n                expectedMonth = 1;\n                expectedYear++;\n                expectedDOY = 1;\n            } else if (expectedYear % 4 != 3 && expectedDay == 6) {\n                expectedDay = 1;\n                expectedMonth = 1;\n                expectedYear++;\n                expectedDOY = 1;\n            }\n        }\n        millis += SKIP;\n    }\n}", "repo_id": "7", "comment": "/**\n * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.\n */\n", "repo_name": "joda-time-main/", "id": 1955, "method_signature": "void testCalendar()"}, "TestCopticChronology.testDurationFields": {"callee_method_names": ["CopticChronology.eras", "CopticChronology.centuries", "CopticChronology.years", "CopticChronology.weekyears", "CopticChronology.months", "CopticChronology.weeks", "CopticChronology.days", "CopticChronology.halfdays", "CopticChronology.hours", "CopticChronology.minutes", "CopticChronology.seconds", "CopticChronology.millis", "CopticChronology.eras", "CopticChronology.centuries", "CopticChronology.years", "CopticChronology.weekyears", "CopticChronology.months", "CopticChronology.weeks", "CopticChronology.days", "CopticChronology.halfdays", "CopticChronology.hours", "CopticChronology.minutes", "CopticChronology.seconds", "CopticChronology.millis", "CopticChronology.centuries", "CopticChronology.years", "CopticChronology.weekyears", "CopticChronology.months", "CopticChronology.weeks", "CopticChronology.days", "CopticChronology.halfdays", "CopticChronology.hours", "CopticChronology.minutes", "CopticChronology.seconds", "CopticChronology.millis", "CopticChronology.centuries", "CopticChronology.years", "CopticChronology.weekyears", "CopticChronology.months", "CopticChronology.weeks", "CopticChronology.days", "CopticChronology.halfdays", "CopticChronology.hours", "CopticChronology.minutes", "CopticChronology.seconds", "CopticChronology.millis", "CopticChronology.centuries", "CopticChronology.years", "CopticChronology.weekyears", "CopticChronology.months", "CopticChronology.weeks", "CopticChronology.days", "CopticChronology.halfdays", "CopticChronology.hours", "CopticChronology.minutes", "CopticChronology.seconds", "CopticChronology.millis"], "method_name": "TestCopticChronology.testDurationFields", "method_implementation": "{\n    final CopticChronology coptic = CopticChronology.getInstance();\n    assertEquals(\"eras\", coptic.eras().getName());\n    assertEquals(\"centuries\", coptic.centuries().getName());\n    assertEquals(\"years\", coptic.years().getName());\n    assertEquals(\"weekyears\", coptic.weekyears().getName());\n    assertEquals(\"months\", coptic.months().getName());\n    assertEquals(\"weeks\", coptic.weeks().getName());\n    assertEquals(\"days\", coptic.days().getName());\n    assertEquals(\"halfdays\", coptic.halfdays().getName());\n    assertEquals(\"hours\", coptic.hours().getName());\n    assertEquals(\"minutes\", coptic.minutes().getName());\n    assertEquals(\"seconds\", coptic.seconds().getName());\n    assertEquals(\"millis\", coptic.millis().getName());\n    assertEquals(false, coptic.eras().isSupported());\n    assertEquals(true, coptic.centuries().isSupported());\n    assertEquals(true, coptic.years().isSupported());\n    assertEquals(true, coptic.weekyears().isSupported());\n    assertEquals(true, coptic.months().isSupported());\n    assertEquals(true, coptic.weeks().isSupported());\n    assertEquals(true, coptic.days().isSupported());\n    assertEquals(true, coptic.halfdays().isSupported());\n    assertEquals(true, coptic.hours().isSupported());\n    assertEquals(true, coptic.minutes().isSupported());\n    assertEquals(true, coptic.seconds().isSupported());\n    assertEquals(true, coptic.millis().isSupported());\n    assertEquals(false, coptic.centuries().isPrecise());\n    assertEquals(false, coptic.years().isPrecise());\n    assertEquals(false, coptic.weekyears().isPrecise());\n    assertEquals(false, coptic.months().isPrecise());\n    assertEquals(false, coptic.weeks().isPrecise());\n    assertEquals(false, coptic.days().isPrecise());\n    assertEquals(false, coptic.halfdays().isPrecise());\n    assertEquals(true, coptic.hours().isPrecise());\n    assertEquals(true, coptic.minutes().isPrecise());\n    assertEquals(true, coptic.seconds().isPrecise());\n    assertEquals(true, coptic.millis().isPrecise());\n    final CopticChronology copticUTC = CopticChronology.getInstanceUTC();\n    assertEquals(false, copticUTC.centuries().isPrecise());\n    assertEquals(false, copticUTC.years().isPrecise());\n    assertEquals(false, copticUTC.weekyears().isPrecise());\n    assertEquals(false, copticUTC.months().isPrecise());\n    assertEquals(true, copticUTC.weeks().isPrecise());\n    assertEquals(true, copticUTC.days().isPrecise());\n    assertEquals(true, copticUTC.halfdays().isPrecise());\n    assertEquals(true, copticUTC.hours().isPrecise());\n    assertEquals(true, copticUTC.minutes().isPrecise());\n    assertEquals(true, copticUTC.seconds().isPrecise());\n    assertEquals(true, copticUTC.millis().isPrecise());\n    final DateTimeZone gmt = DateTimeZone.forID(\"Etc/GMT\");\n    final CopticChronology copticGMT = CopticChronology.getInstance(gmt);\n    assertEquals(false, copticGMT.centuries().isPrecise());\n    assertEquals(false, copticGMT.years().isPrecise());\n    assertEquals(false, copticGMT.weekyears().isPrecise());\n    assertEquals(false, copticGMT.months().isPrecise());\n    assertEquals(true, copticGMT.weeks().isPrecise());\n    assertEquals(true, copticGMT.days().isPrecise());\n    assertEquals(true, copticGMT.halfdays().isPrecise());\n    assertEquals(true, copticGMT.hours().isPrecise());\n    assertEquals(true, copticGMT.minutes().isPrecise());\n    assertEquals(true, copticGMT.seconds().isPrecise());\n    assertEquals(true, copticGMT.millis().isPrecise());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1954, "method_signature": "void testDurationFields()"}, "TestCopticChronology.testEquality": {"callee_method_names": [], "method_name": "TestCopticChronology.testEquality", "method_implementation": "{\n    assertSame(CopticChronology.getInstance(TOKYO), CopticChronology.getInstance(TOKYO));\n    assertSame(CopticChronology.getInstance(LONDON), CopticChronology.getInstance(LONDON));\n    assertSame(CopticChronology.getInstance(PARIS), CopticChronology.getInstance(PARIS));\n    assertSame(CopticChronology.getInstanceUTC(), CopticChronology.getInstanceUTC());\n    assertSame(CopticChronology.getInstance(), CopticChronology.getInstance(LONDON));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1953, "method_signature": "void testEquality()"}, "TestDateConverter.testGetInstantMillis_Object_Chronology": {"callee_method_names": [], "method_name": "TestDateConverter.testGetInstantMillis_Object_Chronology", "method_implementation": "{\n    Date date = new Date(123L);\n    long millis = DateConverter.INSTANCE.getInstantMillis(date, JULIAN);\n    assertEquals(123L, millis);\n    assertEquals(123L, DateConverter.INSTANCE.getInstantMillis(date, (Chronology) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2062, "method_signature": "void testGetInstantMillis_Object_Chronology()"}, "TestDateConverter.testGetPartialValues": {"callee_method_names": ["Chronology.get"], "method_name": "TestDateConverter.testGetPartialValues", "method_implementation": "{\n    TimeOfDay tod = new TimeOfDay();\n    int[] expected = COPTIC.get(tod, 12345678L);\n    int[] actual = DateConverter.INSTANCE.getPartialValues(tod, new Date(12345678L), COPTIC);\n    assertEquals(true, Arrays.equals(expected, actual));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2063, "method_signature": "void testGetPartialValues()"}, "TestDateConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestDateConverter.testSingleton", "method_implementation": "{\n    Class cls = DateConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2061, "method_signature": "void testSingleton()"}, "TestDateMidnight_Basics.check": {"callee_method_names": ["DateMidnight.getYear", "DateMidnight.getMonthOfYear", "DateMidnight.getDayOfMonth"], "method_name": "TestDateMidnight_Basics.check", "method_implementation": "{\n    assertEquals(year, test.getYear());\n    assertEquals(month, test.getMonthOfYear());\n    assertEquals(day, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1311, "method_signature": "void check(DateMidnight, int, int, int)"}, "TestDateMidnight_Basics.testEqualsHashCode": {"callee_method_names": ["DateMidnight.equals", "DateMidnight.equals", "DateMidnight.equals", "DateMidnight.equals", "DateMidnight.hashCode", "DateMidnight.hashCode", "DateMidnight.hashCode", "DateMidnight.hashCode", "DateMidnight.hashCode", "DateMidnight.hashCode", "DateMidnight.equals", "DateMidnight.equals", "DateMidnight.equals", "DateMidnight.equals", "DateMidnight.hashCode", "DateMidnight.hashCode", "DateMidnight.hashCode", "DateMidnight.hashCode", "DateMidnight.equals", "DateMidnight.equals", "DateMidnight.equals"], "method_name": "TestDateMidnight_Basics.testEqualsHashCode", "method_implementation": "{\n    DateMidnight test1 = new DateMidnight(TEST_TIME1_UTC);\n    DateMidnight test2 = new DateMidnight(TEST_TIME1_UTC);\n    assertEquals(true, test1.equals(test2));\n    assertEquals(true, test2.equals(test1));\n    assertEquals(true, test1.equals(test1));\n    assertEquals(true, test2.equals(test2));\n    assertEquals(true, test1.hashCode() == test2.hashCode());\n    assertEquals(true, test1.hashCode() == test1.hashCode());\n    assertEquals(true, test2.hashCode() == test2.hashCode());\n    DateMidnight test3 = new DateMidnight(TEST_TIME2_UTC);\n    assertEquals(false, test1.equals(test3));\n    assertEquals(false, test2.equals(test3));\n    assertEquals(false, test3.equals(test1));\n    assertEquals(false, test3.equals(test2));\n    assertEquals(false, test1.hashCode() == test3.hashCode());\n    assertEquals(false, test2.hashCode() == test3.hashCode());\n    assertEquals(false, test1.equals(\"Hello\"));\n    assertEquals(true, test1.equals(new MockInstant()));\n    assertEquals(false, test1.equals(new DateMidnight(TEST_TIME1_UTC, GREGORIAN_DEFAULT)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1296, "method_signature": "void testEqualsHashCode()"}, "TestDateMidnight_Basics.testGet_DateTimeField": {"callee_method_names": ["DateMidnight.get", "ISOChronology.era", "DateMidnight.get", "ISOChronology.centuryOfEra", "DateMidnight.get", "ISOChronology.yearOfCentury", "DateMidnight.get", "ISOChronology.yearOfEra", "DateMidnight.get", "ISOChronology.year", "DateMidnight.get", "ISOChronology.monthOfYear", "DateMidnight.get", "ISOChronology.dayOfMonth", "DateMidnight.get", "ISOChronology.weekyear", "DateMidnight.get", "ISOChronology.weekOfWeekyear", "DateMidnight.get", "ISOChronology.dayOfWeek", "DateMidnight.get", "ISOChronology.dayOfYear", "DateMidnight.get", "ISOChronology.halfdayOfDay", "DateMidnight.get", "ISOChronology.hourOfHalfday", "DateMidnight.get", "ISOChronology.clockhourOfDay", "DateMidnight.get", "ISOChronology.clockhourOfHalfday", "DateMidnight.get", "ISOChronology.hourOfDay", "DateMidnight.get", "ISOChronology.minuteOfHour", "DateMidnight.get", "ISOChronology.minuteOfDay", "DateMidnight.get", "ISOChronology.secondOfMinute", "DateMidnight.get", "ISOChronology.secondOfDay", "DateMidnight.get", "ISOChronology.millisOfSecond", "DateMidnight.get", "ISOChronology.millisOfDay", "DateMidnight.get"], "method_name": "TestDateMidnight_Basics.testGet_DateTimeField", "method_implementation": "{\n    DateMidnight test = new DateMidnight();\n    assertEquals(1, test.get(ISO_DEFAULT.era()));\n    assertEquals(20, test.get(ISO_DEFAULT.centuryOfEra()));\n    assertEquals(2, test.get(ISO_DEFAULT.yearOfCentury()));\n    assertEquals(2002, test.get(ISO_DEFAULT.yearOfEra()));\n    assertEquals(2002, test.get(ISO_DEFAULT.year()));\n    assertEquals(6, test.get(ISO_DEFAULT.monthOfYear()));\n    assertEquals(9, test.get(ISO_DEFAULT.dayOfMonth()));\n    assertEquals(2002, test.get(ISO_DEFAULT.weekyear()));\n    assertEquals(23, test.get(ISO_DEFAULT.weekOfWeekyear()));\n    assertEquals(7, test.get(ISO_DEFAULT.dayOfWeek()));\n    assertEquals(160, test.get(ISO_DEFAULT.dayOfYear()));\n    assertEquals(0, test.get(ISO_DEFAULT.halfdayOfDay()));\n    assertEquals(0, test.get(ISO_DEFAULT.hourOfHalfday()));\n    assertEquals(24, test.get(ISO_DEFAULT.clockhourOfDay()));\n    assertEquals(12, test.get(ISO_DEFAULT.clockhourOfHalfday()));\n    assertEquals(0, test.get(ISO_DEFAULT.hourOfDay()));\n    assertEquals(0, test.get(ISO_DEFAULT.minuteOfHour()));\n    assertEquals(0, test.get(ISO_DEFAULT.minuteOfDay()));\n    assertEquals(0, test.get(ISO_DEFAULT.secondOfMinute()));\n    assertEquals(0, test.get(ISO_DEFAULT.secondOfDay()));\n    assertEquals(0, test.get(ISO_DEFAULT.millisOfSecond()));\n    assertEquals(0, test.get(ISO_DEFAULT.millisOfDay()));\n    try {\n        test.get((DateTimeField) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1294, "method_signature": "void testGet_DateTimeField()"}, "TestDateMidnight_Basics.testGetters": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getZone", "DateMidnight.getMillis", "DateMidnight.getEra", "DateMidnight.getCenturyOfEra", "DateMidnight.getYearOfCentury", "DateMidnight.getYearOfEra", "DateMidnight.getYear", "DateMidnight.getMonthOfYear", "DateMidnight.getDayOfMonth", "DateMidnight.getWeekyear", "DateMidnight.getWeekOfWeekyear", "DateMidnight.getDayOfWeek", "DateMidnight.getDayOfYear", "DateMidnight.getHourOfDay", "DateMidnight.getMinuteOfHour", "DateMidnight.getMinuteOfDay", "DateMidnight.getSecondOfMinute", "DateMidnight.getSecondOfDay", "DateMidnight.getMillisOfSecond", "DateMidnight.getMillisOfDay"], "method_name": "TestDateMidnight_Basics.testGetters", "method_implementation": "{\n    DateMidnight test = new DateMidnight();\n    assertEquals(ISO_DEFAULT, test.getChronology());\n    assertEquals(LONDON, test.getZone());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    assertEquals(1, test.getEra());\n    assertEquals(20, test.getCenturyOfEra());\n    assertEquals(2, test.getYearOfCentury());\n    assertEquals(2002, test.getYearOfEra());\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(2002, test.getWeekyear());\n    assertEquals(23, test.getWeekOfWeekyear());\n    assertEquals(7, test.getDayOfWeek());\n    assertEquals(160, test.getDayOfYear());\n    assertEquals(0, test.getHourOfDay());\n    assertEquals(0, test.getMinuteOfHour());\n    assertEquals(0, test.getMinuteOfDay());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getSecondOfDay());\n    assertEquals(0, test.getMillisOfSecond());\n    assertEquals(0, test.getMillisOfDay());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1295, "method_signature": "void testGetters()"}, "TestDateMidnight_Basics.testMinus_long": {"callee_method_names": ["DateMidnight.minus", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Basics.testMinus_long", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT);\n    DateMidnight result = test.minus(123456789L);\n    DateMidnight expected = new DateMidnight(test.getMillis() - 123456789L, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1309, "method_signature": "void testMinus_long()"}, "TestDateMidnight_Basics.testPlus_long": {"callee_method_names": ["DateMidnight.plus", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Basics.testPlus_long", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT);\n    DateMidnight result = test.plus(123456789L);\n    DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1308, "method_signature": "void testPlus_long()"}, "TestDateMidnight_Basics.testProperty": {"callee_method_ids": [268, 268, 268, 268, 268, 268, 268], "callee_method_names": ["DateMidnight.year", "DateMidnight.property", "DateMidnight.dayOfWeek", "DateMidnight.property", "DateMidnight.weekOfWeekyear", "DateMidnight.property", "DateMidnight.property", "DateMidnight.property", "DateMidnight.property", "DateMidnight.property"], "method_name": "TestDateMidnight_Basics.testProperty", "method_implementation": "{\n    DateMidnight test = new DateMidnight();\n    assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n    assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek()));\n    assertEquals(test.weekOfWeekyear(), test.property(DateTimeFieldType.weekOfWeekyear()));\n    assertEquals(test.property(DateTimeFieldType.millisOfSecond()), test.property(DateTimeFieldType.millisOfSecond()));\n    DateTimeFieldType bad = new DateTimeFieldType(\"bad\") {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public DurationFieldType getDurationType() {\n            return DurationFieldType.weeks();\n        }\n\n        @Override\n        public DurationFieldType getRangeDurationType() {\n            return null;\n        }\n\n        @Override\n        public DateTimeField getField(Chronology chronology) {\n            return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType()));\n        }\n    };\n    try {\n        test.property(bad);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1310, "method_signature": "void testProperty()"}, "TestDateMidnight_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestDateMidnight_Basics.testSerialization", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    DateMidnight result = (DateMidnight) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1297, "method_signature": "void testSerialization()"}, "TestDateMidnight_Basics.testTest": {"callee_method_names": [], "method_name": "TestDateMidnight_Basics.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW_UTC).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1_UTC).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2_UTC).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1293, "method_signature": "void testTest()"}, "TestDateMidnight_Basics.testToInstant": {"callee_method_names": ["DateMidnight.toInstant", "Instant.getMillis"], "method_name": "TestDateMidnight_Basics.testToInstant", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n    Instant result = test.toInstant();\n    assertEquals(TEST_TIME1_LONDON, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1299, "method_signature": "void testToInstant()"}, "TestDateMidnight_Basics.testToString": {"callee_method_names": ["DateMidnight.toString", "DateMidnight.toString", "DateMidnight.toString"], "method_name": "TestDateMidnight_Basics.testToString", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME_NOW_UTC);\n    assertEquals(\"2002-06-09T00:00:00.000+01:00\", test.toString());\n    test = new DateMidnight(TEST_TIME_NOW_UTC, PARIS);\n    assertEquals(\"2002-06-09T00:00:00.000+02:00\", test.toString());\n    test = new DateMidnight(TEST_TIME_NOW_UTC, NEWYORK);\n    // the 8th\n    assertEquals(\"2002-06-08T00:00:00.000-04:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1298, "method_signature": "void testToString()"}, "TestDateMidnight_Basics.testToYearMonthDay": {"callee_method_names": ["DateMidnight.toYearMonthDay"], "method_name": "TestDateMidnight_Basics.testToYearMonthDay", "method_implementation": "{\n    DateMidnight base = new DateMidnight(TEST_TIME1_UTC, COPTIC_DEFAULT);\n    YearMonthDay test = base.toYearMonthDay();\n    assertEquals(new YearMonthDay(TEST_TIME1_UTC, COPTIC_DEFAULT), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1300, "method_signature": "void testToYearMonthDay()"}, "TestDateMidnight_Basics.testWithDurationAdded_RD_int": {"callee_method_ids": [258, 258, 258, 258, 258], "callee_method_names": ["DateMidnight.withDurationAdded", "DateMidnight.getMillis", "DateMidnight.withDurationAdded", "DateMidnight.withDurationAdded", "DateMidnight.withDurationAdded", "DateMidnight.getMillis", "DateMidnight.withDurationAdded", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Basics.testWithDurationAdded_RD_int", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT);\n    DateMidnight result = test.withDurationAdded(new Duration(123456789L), 1);\n    DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(null, 1);\n    assertSame(test, result);\n    result = test.withDurationAdded(new Duration(123456789L), 0);\n    assertSame(test, result);\n    result = test.withDurationAdded(new Duration(123456789L), 2);\n    expected = new DateMidnight(test.getMillis() + (2L * 123456789L), BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(new Duration(123456789L), -3);\n    expected = new DateMidnight(test.getMillis() - (3L * 123456789L), BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1306, "method_signature": "void testWithDurationAdded_RD_int()"}, "TestDateMidnight_Basics.testWithDurationAdded_RP_int": {"callee_method_ids": [259, 259, 259, 259, 259], "callee_method_names": ["DateMidnight.withPeriodAdded", "DateMidnight.withPeriodAdded", "DateMidnight.withPeriodAdded", "DateMidnight.withPeriodAdded", "DateMidnight.withPeriodAdded"], "method_name": "TestDateMidnight_Basics.testWithDurationAdded_RP_int", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2002, 5, 3, BUDDHIST_DEFAULT);\n    DateMidnight result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 1);\n    DateMidnight expected = new DateMidnight(2003, 7, 28, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withPeriodAdded(null, 1);\n    assertSame(test, result);\n    result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 0);\n    assertSame(test, result);\n    result = test.withPeriodAdded(new Period(1, 2, 0, 4, 5, 6, 7, 8), 3);\n    expected = new DateMidnight(2005, 11, 15, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withPeriodAdded(new Period(1, 2, 0, 1, 1, 2, 3, 4), -1);\n    expected = new DateMidnight(2001, 3, 1, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1307, "method_signature": "void testWithDurationAdded_RP_int()"}, "TestDateMidnight_Basics.testWithDurationAdded_long_int": {"callee_method_ids": [258, 258, 258, 258], "callee_method_names": ["DateMidnight.withDurationAdded", "DateMidnight.getMillis", "DateMidnight.withDurationAdded", "DateMidnight.withDurationAdded", "DateMidnight.getMillis", "DateMidnight.withDurationAdded", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Basics.testWithDurationAdded_long_int", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC, BUDDHIST_DEFAULT);\n    DateMidnight result = test.withDurationAdded(123456789L, 1);\n    DateMidnight expected = new DateMidnight(test.getMillis() + 123456789L, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(123456789L, 0);\n    assertSame(test, result);\n    result = test.withDurationAdded(123456789L, 2);\n    expected = new DateMidnight(test.getMillis() + (2L * 123456789L), BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(123456789L, -3);\n    expected = new DateMidnight(test.getMillis() - (3L * 123456789L), BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1305, "method_signature": "void testWithDurationAdded_long_int()"}, "TestDateMidnight_Basics.testWithField1": {"callee_method_ids": [255], "callee_method_names": ["DateMidnight.withField"], "method_name": "TestDateMidnight_Basics.testWithField1", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    DateMidnight result = test.withField(DateTimeFieldType.year(), 2006);\n    assertEquals(new DateMidnight(2004, 6, 9), test);\n    assertEquals(new DateMidnight(2006, 6, 9), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1303, "method_signature": "void testWithField1()"}, "TestDateMidnight_Basics.testWithFieldAdded1": {"callee_method_ids": [256], "callee_method_names": ["DateMidnight.withFieldAdded"], "method_name": "TestDateMidnight_Basics.testWithFieldAdded1", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    DateMidnight result = test.withFieldAdded(DurationFieldType.years(), 6);\n    assertEquals(new DateMidnight(2004, 6, 9), test);\n    assertEquals(new DateMidnight(2010, 6, 9), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1304, "method_signature": "void testWithFieldAdded1()"}, "TestDateMidnight_Basics.testWithFields_RPartial": {"callee_method_ids": [254, 254], "callee_method_names": ["DateMidnight.withFields", "DateMidnight.withFields"], "method_name": "TestDateMidnight_Basics.testWithFields_RPartial", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 5, 6);\n    DateMidnight result = test.withFields(new YearMonthDay(2003, 4, 5));\n    DateMidnight expected = new DateMidnight(2003, 4, 5);\n    assertEquals(expected, result);\n    test = new DateMidnight(TEST_TIME1_UTC);\n    result = test.withFields(null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1302, "method_signature": "void testWithFields_RPartial()"}, "TestDateMidnight_Basics.testWithMillis_long": {"callee_method_ids": [252, 252, 252], "callee_method_names": ["DateMidnight.withMillis", "DateMidnight.getMillis", "DateMidnight.getChronology", "DateMidnight.getChronology", "DateMidnight.withMillis", "DateMidnight.getMillis", "DateMidnight.getChronology", "DateMidnight.getChronology", "DateMidnight.withMillis"], "method_name": "TestDateMidnight_Basics.testWithMillis_long", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n    DateMidnight result = test.withMillis(TEST_TIME2_UTC);\n    assertEquals(TEST_TIME2_LONDON, result.getMillis());\n    assertEquals(test.getChronology(), result.getChronology());\n    test = new DateMidnight(TEST_TIME1_UTC, GREGORIAN_PARIS);\n    result = test.withMillis(TEST_TIME2_UTC);\n    assertEquals(TEST_TIME2_PARIS, result.getMillis());\n    assertEquals(test.getChronology(), result.getChronology());\n    test = new DateMidnight(TEST_TIME1_UTC);\n    result = test.withMillis(TEST_TIME1_UTC);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1301, "method_signature": "void testWithMillis_long()"}, "TestDateMidnight_Constructors.testConstructor": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis", "DateMidnight.getYear", "DateMidnight.getMonthOfYear", "DateMidnight.getDayOfMonth"], "method_name": "TestDateMidnight_Constructors.testConstructor", "method_implementation": "{\n    DateMidnight test = new DateMidnight();\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1365, "method_signature": "void testConstructor()"}, "TestDateMidnight_Constructors.testConstructor_Chronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_Chronology", "method_implementation": "{\n    DateMidnight test = new DateMidnight(GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1368, "method_signature": "void testConstructor_Chronology()"}, "TestDateMidnight_Constructors.testConstructor_DateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_DateTimeZone", "method_implementation": "{\n    DateMidnight test = new DateMidnight(PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1366, "method_signature": "void testConstructor_DateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_Object": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_Object", "method_implementation": "{\n    Date date = new Date(TEST_TIME1_UTC);\n    DateMidnight test = new DateMidnight(date);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1378, "method_signature": "void testConstructor_Object()"}, "TestDateMidnight_Constructors.testConstructor_Object_Chronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_Object_Chronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1_UTC);\n    DateMidnight test = new DateMidnight(date, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1388, "method_signature": "void testConstructor_Object_Chronology()"}, "TestDateMidnight_Constructors.testConstructor_Object_DateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_Object_DateTimeZone", "method_implementation": "{\n    Date date = new Date(TEST_TIME1_UTC);\n    DateMidnight test = new DateMidnight(date, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME1_PARIS, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1382, "method_signature": "void testConstructor_Object_DateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_Object_nullChronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_Object_nullChronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1_UTC);\n    DateMidnight test = new DateMidnight(date, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1391, "method_signature": "void testConstructor_Object_nullChronology()"}, "TestDateMidnight_Constructors.testConstructor_Object_nullDateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_Object_nullDateTimeZone", "method_implementation": "{\n    Date date = new Date(TEST_TIME1_UTC);\n    DateMidnight test = new DateMidnight(date, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1385, "method_signature": "void testConstructor_Object_nullDateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_badconverterObject": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_badconverterObject", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        DateMidnight test = new DateMidnight(new Integer(0));\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null)\n */\n", "repo_name": "joda-time-main/", "id": 1381, "method_signature": "void testConstructor_badconverterObject()"}, "TestDateMidnight_Constructors.testConstructor_badconverterObject_Chronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_badconverterObject_Chronology", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1393, "method_signature": "void testConstructor_badconverterObject_Chronology()"}, "TestDateMidnight_Constructors.testConstructor_badconverterObject_DateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_badconverterObject_DateTimeZone", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        DateMidnight test = new DateMidnight(new Integer(0), GregorianChronology.getInstance());\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(0L - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1387, "method_signature": "void testConstructor_badconverterObject_DateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_int_int_int": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getZone", "DateMidnight.getMillis", "DateMidnight.getYear", "DateMidnight.getMonthOfYear", "DateMidnight.getDayOfMonth"], "method_name": "TestDateMidnight_Constructors.testConstructor_int_int_int", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2002, 6, 9);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(LONDON, test.getZone());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    try {\n        new DateMidnight(Integer.MIN_VALUE, 6, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(Integer.MAX_VALUE, 6, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 0, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 13, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 6, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 6, 31);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new DateMidnight(2002, 7, 31);\n    try {\n        new DateMidnight(2002, 7, 32);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1394, "method_signature": "void testConstructor_int_int_int()"}, "TestDateMidnight_Constructors.testConstructor_int_int_int_Chronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis", "DateMidnight.getYear", "DateMidnight.getMonthOfYear", "DateMidnight.getDayOfMonth"], "method_name": "TestDateMidnight_Constructors.testConstructor_int_int_int_Chronology", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2002, 6, 9, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    try {\n        new DateMidnight(Integer.MIN_VALUE, 6, 9, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(Integer.MAX_VALUE, 6, 9, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 0, 9, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 13, 9, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 6, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 6, 31, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new DateMidnight(2002, 7, 31, GregorianChronology.getInstance());\n    try {\n        new DateMidnight(2002, 7, 32, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1397, "method_signature": "void testConstructor_int_int_int_Chronology()"}, "TestDateMidnight_Constructors.testConstructor_int_int_int_DateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis", "DateMidnight.getYear", "DateMidnight.getMonthOfYear", "DateMidnight.getDayOfMonth"], "method_name": "TestDateMidnight_Constructors.testConstructor_int_int_int_DateTimeZone", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2002, 6, 9, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    try {\n        new DateMidnight(Integer.MIN_VALUE, 6, 9, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(Integer.MAX_VALUE, 6, 9, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 0, 9, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 13, 9, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 6, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateMidnight(2002, 6, 31, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new DateMidnight(2002, 7, 31, PARIS);\n    try {\n        new DateMidnight(2002, 7, 32, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1395, "method_signature": "void testConstructor_int_int_int_DateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_int_int_int_nullChronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis", "DateMidnight.getYear", "DateMidnight.getMonthOfYear", "DateMidnight.getDayOfMonth"], "method_name": "TestDateMidnight_Constructors.testConstructor_int_int_int_nullChronology", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2002, 6, 9, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1398, "method_signature": "void testConstructor_int_int_int_nullChronology()"}, "TestDateMidnight_Constructors.testConstructor_int_int_int_nullDateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis", "DateMidnight.getYear", "DateMidnight.getMonthOfYear", "DateMidnight.getDayOfMonth"], "method_name": "TestDateMidnight_Constructors.testConstructor_int_int_int_nullDateTimeZone", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2002, 6, 9, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1396, "method_signature": "void testConstructor_int_int_int_nullDateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_invalidObject": {"callee_method_names": [], "method_name": "TestDateMidnight_Constructors.testConstructor_invalidObject", "method_implementation": "{\n    try {\n        new DateMidnight(new Object());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1379, "method_signature": "void testConstructor_invalidObject()"}, "TestDateMidnight_Constructors.testConstructor_invalidObject_Chronology": {"callee_method_names": [], "method_name": "TestDateMidnight_Constructors.testConstructor_invalidObject_Chronology", "method_implementation": "{\n    try {\n        new DateMidnight(new Object(), GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1389, "method_signature": "void testConstructor_invalidObject_Chronology()"}, "TestDateMidnight_Constructors.testConstructor_invalidObject_DateTimeZone": {"callee_method_names": [], "method_name": "TestDateMidnight_Constructors.testConstructor_invalidObject_DateTimeZone", "method_implementation": "{\n    try {\n        new DateMidnight(new Object(), PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1383, "method_signature": "void testConstructor_invalidObject_DateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_long1": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_long1", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1370, "method_signature": "void testConstructor_long1()"}, "TestDateMidnight_Constructors.testConstructor_long1_Chronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_long1_Chronology", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1375, "method_signature": "void testConstructor_long1_Chronology()"}, "TestDateMidnight_Constructors.testConstructor_long1_DateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_long1_DateTimeZone", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME1_PARIS, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1372, "method_signature": "void testConstructor_long1_DateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_long2": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_long2", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME2_UTC);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME2_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1371, "method_signature": "void testConstructor_long2()"}, "TestDateMidnight_Constructors.testConstructor_long2_Chronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_long2_Chronology", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME2_UTC, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME2_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1376, "method_signature": "void testConstructor_long2_Chronology()"}, "TestDateMidnight_Constructors.testConstructor_long2_DateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_long2_DateTimeZone", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME2_UTC, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME2_PARIS, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1373, "method_signature": "void testConstructor_long2_DateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_long_nullChronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_long_nullChronology", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1377, "method_signature": "void testConstructor_long_nullChronology()"}, "TestDateMidnight_Constructors.testConstructor_long_nullDateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_long_nullDateTimeZone", "method_implementation": "{\n    DateMidnight test = new DateMidnight(TEST_TIME1_UTC, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1374, "method_signature": "void testConstructor_long_nullDateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_nullChronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_nullChronology", "method_implementation": "{\n    DateMidnight test = new DateMidnight((Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1369, "method_signature": "void testConstructor_nullChronology()"}, "TestDateMidnight_Constructors.testConstructor_nullDateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_nullDateTimeZone", "method_implementation": "{\n    DateMidnight test = new DateMidnight((DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1367, "method_signature": "void testConstructor_nullDateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_nullObject": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_nullObject", "method_implementation": "{\n    DateMidnight test = new DateMidnight((Object) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null)\n */\n", "repo_name": "joda-time-main/", "id": 1380, "method_signature": "void testConstructor_nullObject()"}, "TestDateMidnight_Constructors.testConstructor_nullObject_Chronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_nullObject_Chronology", "method_implementation": "{\n    DateMidnight test = new DateMidnight((Object) null, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1390, "method_signature": "void testConstructor_nullObject_Chronology()"}, "TestDateMidnight_Constructors.testConstructor_nullObject_DateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_nullObject_DateTimeZone", "method_implementation": "{\n    DateMidnight test = new DateMidnight((Object) null, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1384, "method_signature": "void testConstructor_nullObject_DateTimeZone()"}, "TestDateMidnight_Constructors.testConstructor_nullObject_nullChronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_nullObject_nullChronology", "method_implementation": "{\n    DateMidnight test = new DateMidnight((Object) null, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1392, "method_signature": "void testConstructor_nullObject_nullChronology()"}, "TestDateMidnight_Constructors.testConstructor_nullObject_nullDateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.testConstructor_nullObject_nullDateTimeZone", "method_implementation": "{\n    DateMidnight test = new DateMidnight((Object) null, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1386, "method_signature": "void testConstructor_nullObject_nullDateTimeZone()"}, "TestDateMidnight_Constructors.testTest": {"callee_method_names": [], "method_name": "TestDateMidnight_Constructors.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW_UTC).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1_UTC).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2_UTC).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1359, "method_signature": "void testTest()"}, "TestDateMidnight_Constructors.test_now": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis", "DateMidnight.getYear", "DateMidnight.getMonthOfYear", "DateMidnight.getDayOfMonth"], "method_name": "TestDateMidnight_Constructors.test_now", "method_implementation": "{\n    DateMidnight test = DateMidnight.now();\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test now ()\n */\n", "repo_name": "joda-time-main/", "id": 1360, "method_signature": "void test_now()"}, "TestDateMidnight_Constructors.test_now_Chronology": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.test_now_Chronology", "method_implementation": "{\n    DateMidnight test = DateMidnight.now(GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW_LONDON, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test now (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1363, "method_signature": "void test_now_Chronology()"}, "TestDateMidnight_Constructors.test_now_DateTimeZone": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.getMillis"], "method_name": "TestDateMidnight_Constructors.test_now_DateTimeZone", "method_implementation": "{\n    DateMidnight test = DateMidnight.now(PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW_PARIS, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test now (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1361, "method_signature": "void test_now_DateTimeZone()"}, "TestDateMidnight_Constructors.test_now_nullChronology": {"callee_method_names": [], "method_name": "TestDateMidnight_Constructors.test_now_nullChronology", "method_implementation": "{\n    try {\n        DateMidnight.now((Chronology) null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test now (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1364, "method_signature": "void test_now_nullChronology()"}, "TestDateMidnight_Constructors.test_now_nullDateTimeZone": {"callee_method_names": [], "method_name": "TestDateMidnight_Constructors.test_now_nullDateTimeZone", "method_implementation": "{\n    try {\n        DateMidnight.now((DateTimeZone) null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test now (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1362, "method_signature": "void test_now_nullDateTimeZone()"}, "TestDateMidnight_Properties.testPropertyGetCenturyOfEra": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra", "DateMidnight.getChronology", "DateMidnight.centuryOfEra", "DateMidnight.getChronology", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra", "DateMidnight.centuryOfEra"], "method_name": "TestDateMidnight_Properties.testPropertyGetCenturyOfEra", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());\n    assertEquals(\"centuryOfEra\", test.centuryOfEra().getName());\n    assertEquals(\"Property[centuryOfEra]\", test.centuryOfEra().toString());\n    assertSame(test, test.centuryOfEra().getDateMidnight());\n    assertEquals(20, test.centuryOfEra().get());\n    assertEquals(\"20\", test.centuryOfEra().getAsText());\n    assertEquals(\"20\", test.centuryOfEra().getAsText(Locale.FRENCH));\n    assertEquals(\"20\", test.centuryOfEra().getAsShortText());\n    assertEquals(\"20\", test.centuryOfEra().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());\n    assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField());\n    assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));\n    assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1629, "method_signature": "void testPropertyGetCenturyOfEra()"}, "TestDateMidnight_Properties.testPropertyGetDayOfMonth": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.getChronology", "DateMidnight.dayOfMonth", "DateMidnight.getChronology", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth", "DateMidnight.dayOfMonth"], "method_name": "TestDateMidnight_Properties.testPropertyGetDayOfMonth", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n    assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n    assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n    assertSame(test, test.dayOfMonth().getDateMidnight());\n    assertEquals(9, test.dayOfMonth().get());\n    assertEquals(\"9\", test.dayOfMonth().getAsText());\n    assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText());\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n    assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n    assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n    assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n    assertEquals(1, test.dayOfMonth().getMinimumValue());\n    assertEquals(1, test.dayOfMonth().getMinimumValueOverall());\n    assertEquals(30, test.dayOfMonth().getMaximumValue());\n    assertEquals(31, test.dayOfMonth().getMaximumValueOverall());\n    assertEquals(false, test.dayOfMonth().isLeap());\n    assertEquals(0, test.dayOfMonth().getLeapAmount());\n    assertEquals(null, test.dayOfMonth().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1634, "method_signature": "void testPropertyGetDayOfMonth()"}, "TestDateMidnight_Properties.testPropertyGetDayOfWeek": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.getChronology", "DateMidnight.dayOfWeek", "DateMidnight.getChronology", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek", "DateMidnight.dayOfWeek"], "method_name": "TestDateMidnight_Properties.testPropertyGetDayOfWeek", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());\n    assertEquals(\"dayOfWeek\", test.dayOfWeek().getName());\n    assertEquals(\"Property[dayOfWeek]\", test.dayOfWeek().toString());\n    assertSame(test, test.dayOfWeek().getDateMidnight());\n    assertEquals(3, test.dayOfWeek().get());\n    assertEquals(\"3\", test.dayOfWeek().getAsString());\n    assertEquals(\"Wednesday\", test.dayOfWeek().getAsText());\n    assertEquals(\"mercredi\", test.dayOfWeek().getAsText(Locale.FRENCH));\n    assertEquals(\"Wed\", test.dayOfWeek().getAsShortText());\n    assertEquals(\"mer.\", test.dayOfWeek().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());\n    assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());\n    assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));\n    assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));\n    assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));\n    assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));\n    assertEquals(1, test.dayOfWeek().getMinimumValue());\n    assertEquals(1, test.dayOfWeek().getMinimumValueOverall());\n    assertEquals(7, test.dayOfWeek().getMaximumValue());\n    assertEquals(7, test.dayOfWeek().getMaximumValueOverall());\n    assertEquals(false, test.dayOfWeek().isLeap());\n    assertEquals(0, test.dayOfWeek().getLeapAmount());\n    assertEquals(null, test.dayOfWeek().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1637, "method_signature": "void testPropertyGetDayOfWeek()"}, "TestDateMidnight_Properties.testPropertyGetDayOfYear": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.getChronology", "DateMidnight.dayOfYear", "DateMidnight.getChronology", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear", "DateMidnight.dayOfYear"], "method_name": "TestDateMidnight_Properties.testPropertyGetDayOfYear", "method_implementation": "{\n    // 31+29+31+30+31+9 = 161\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());\n    assertEquals(\"dayOfYear\", test.dayOfYear().getName());\n    assertEquals(\"Property[dayOfYear]\", test.dayOfYear().toString());\n    assertSame(test, test.dayOfYear().getDateMidnight());\n    assertEquals(161, test.dayOfYear().get());\n    assertEquals(\"161\", test.dayOfYear().getAsText());\n    assertEquals(\"161\", test.dayOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"161\", test.dayOfYear().getAsShortText());\n    assertEquals(\"161\", test.dayOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());\n    assertEquals(3, test.dayOfYear().getMaximumTextLength(null));\n    assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));\n    assertEquals(false, test.dayOfYear().isLeap());\n    assertEquals(0, test.dayOfYear().getLeapAmount());\n    assertEquals(null, test.dayOfYear().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1635, "method_signature": "void testPropertyGetDayOfYear()"}, "TestDateMidnight_Properties.testPropertyGetEra": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.getChronology", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era", "DateMidnight.era"], "method_name": "TestDateMidnight_Properties.testPropertyGetEra", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().era(), test.era().getField());\n    assertEquals(\"era\", test.era().getName());\n    assertEquals(\"Property[era]\", test.era().toString());\n    assertSame(test, test.era().getDateMidnight());\n    assertEquals(1, test.era().get());\n    assertEquals(\"AD\", test.era().getAsText());\n    assertEquals(\"ap. J.-C.\", test.era().getAsText(Locale.FRENCH));\n    assertEquals(\"AD\", test.era().getAsShortText());\n    assertEquals(\"ap. J.-C.\", test.era().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().eras(), test.era().getDurationField());\n    assertEquals(null, test.era().getRangeDurationField());\n    assertEquals(2, test.era().getMaximumTextLength(null));\n    assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));\n    assertEquals(2, test.era().getMaximumShortTextLength(null));\n    assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1627, "method_signature": "void testPropertyGetEra()"}, "TestDateMidnight_Properties.testPropertyGetMonthOfYear": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.getChronology", "DateMidnight.monthOfYear", "DateMidnight.getChronology", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear", "DateMidnight.monthOfYear"], "method_name": "TestDateMidnight_Properties.testPropertyGetMonthOfYear", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n    assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n    assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n    assertSame(test, test.monthOfYear().getDateMidnight());\n    assertEquals(6, test.monthOfYear().get());\n    assertEquals(\"6\", test.monthOfYear().getAsString());\n    assertEquals(\"June\", test.monthOfYear().getAsText());\n    assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n    assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n    assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n    int max = test.monthOfYear().getMaximumShortTextLength(null);\n    // for JDK17+\n    assertTrue(max == 3 || max == 4);\n    test = new DateMidnight(2004, 7, 9);\n    assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(1, test.monthOfYear().getMinimumValue());\n    assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n    assertEquals(12, test.monthOfYear().getMaximumValue());\n    assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n    assertEquals(1, test.monthOfYear().getMinimumValue());\n    assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n    assertEquals(12, test.monthOfYear().getMaximumValue());\n    assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1633, "method_signature": "void testPropertyGetMonthOfYear()"}, "TestDateMidnight_Properties.testPropertyGetWeekOfWeekyear": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.getChronology", "DateMidnight.weekOfWeekyear", "DateMidnight.getChronology", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear", "DateMidnight.weekOfWeekyear"], "method_name": "TestDateMidnight_Properties.testPropertyGetWeekOfWeekyear", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());\n    assertEquals(\"weekOfWeekyear\", test.weekOfWeekyear().getName());\n    assertEquals(\"Property[weekOfWeekyear]\", test.weekOfWeekyear().toString());\n    assertSame(test, test.weekOfWeekyear().getDateMidnight());\n    assertEquals(24, test.weekOfWeekyear().get());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsText());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsText(Locale.FRENCH));\n    assertEquals(\"24\", test.weekOfWeekyear().getAsShortText());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());\n    assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());\n    assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));\n    assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));\n    assertEquals(false, test.weekOfWeekyear().isLeap());\n    assertEquals(0, test.weekOfWeekyear().getLeapAmount());\n    assertEquals(null, test.weekOfWeekyear().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1636, "method_signature": "void testPropertyGetWeekOfWeekyear()"}, "TestDateMidnight_Properties.testPropertyGetWeekyear": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.getChronology", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.weekyear", "DateMidnight.weekyear"], "method_name": "TestDateMidnight_Properties.testPropertyGetWeekyear", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().weekyear(), test.weekyear().getField());\n    assertEquals(\"weekyear\", test.weekyear().getName());\n    assertEquals(\"Property[weekyear]\", test.weekyear().toString());\n    assertSame(test, test.weekyear().getDateMidnight());\n    assertEquals(2004, test.weekyear().get());\n    assertEquals(\"2004\", test.weekyear().getAsText());\n    assertEquals(\"2004\", test.weekyear().getAsText(Locale.FRENCH));\n    assertEquals(\"2004\", test.weekyear().getAsShortText());\n    assertEquals(\"2004\", test.weekyear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());\n    assertEquals(null, test.weekyear().getRangeDurationField());\n    assertEquals(9, test.weekyear().getMaximumTextLength(null));\n    assertEquals(9, test.weekyear().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1631, "method_signature": "void testPropertyGetWeekyear()"}, "TestDateMidnight_Properties.testPropertyGetYear": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.getChronology", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year", "DateMidnight.year"], "method_name": "TestDateMidnight_Properties.testPropertyGetYear", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().year(), test.year().getField());\n    assertEquals(\"year\", test.year().getName());\n    assertEquals(\"Property[year]\", test.year().toString());\n    assertSame(test, test.year().getDateMidnight());\n    assertEquals(2004, test.year().get());\n    assertEquals(\"2004\", test.year().getAsText());\n    assertEquals(\"2004\", test.year().getAsText(Locale.FRENCH));\n    assertEquals(\"2004\", test.year().getAsShortText());\n    assertEquals(\"2004\", test.year().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.year().getDurationField());\n    assertEquals(null, test.year().getRangeDurationField());\n    assertEquals(9, test.year().getMaximumTextLength(null));\n    assertEquals(9, test.year().getMaximumShortTextLength(null));\n    assertEquals(-292275054, test.year().getMinimumValue());\n    assertEquals(-292275054, test.year().getMinimumValueOverall());\n    assertEquals(292278993, test.year().getMaximumValue());\n    assertEquals(292278993, test.year().getMaximumValueOverall());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1632, "method_signature": "void testPropertyGetYear()"}, "TestDateMidnight_Properties.testPropertyGetYearOfCentury": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury", "DateMidnight.getChronology", "DateMidnight.yearOfCentury", "DateMidnight.getChronology", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury", "DateMidnight.yearOfCentury"], "method_name": "TestDateMidnight_Properties.testPropertyGetYearOfCentury", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());\n    assertEquals(\"yearOfCentury\", test.yearOfCentury().getName());\n    assertEquals(\"Property[yearOfCentury]\", test.yearOfCentury().toString());\n    assertSame(test, test.yearOfCentury().getDateMidnight());\n    assertEquals(4, test.yearOfCentury().get());\n    assertEquals(\"4\", test.yearOfCentury().getAsText());\n    assertEquals(\"4\", test.yearOfCentury().getAsText(Locale.FRENCH));\n    assertEquals(\"4\", test.yearOfCentury().getAsShortText());\n    assertEquals(\"4\", test.yearOfCentury().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());\n    assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());\n    assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));\n    assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1630, "method_signature": "void testPropertyGetYearOfCentury()"}, "TestDateMidnight_Properties.testPropertyGetYearOfEra": {"callee_method_names": ["DateMidnight.getChronology", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra", "DateMidnight.getChronology", "DateMidnight.yearOfEra", "DateMidnight.getChronology", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra", "DateMidnight.yearOfEra"], "method_name": "TestDateMidnight_Properties.testPropertyGetYearOfEra", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());\n    assertEquals(\"yearOfEra\", test.yearOfEra().getName());\n    assertEquals(\"Property[yearOfEra]\", test.yearOfEra().toString());\n    assertSame(test, test.yearOfEra().getDateMidnight());\n    assertEquals(2004, test.yearOfEra().get());\n    assertEquals(\"2004\", test.yearOfEra().getAsText());\n    assertEquals(\"2004\", test.yearOfEra().getAsText(Locale.FRENCH));\n    assertEquals(\"2004\", test.yearOfEra().getAsShortText());\n    assertEquals(\"2004\", test.yearOfEra().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());\n    assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField());\n    assertEquals(9, test.yearOfEra().getMaximumTextLength(null));\n    assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1628, "method_signature": "void testPropertyGetYearOfEra()"}, "TestDateMidnight_Properties.testPropertyToIntervalYearOfEra": {"callee_method_names": ["DateMidnight.yearOfEra", "Interval.getStart", "Interval.getEnd"], "method_name": "TestDateMidnight_Properties.testPropertyToIntervalYearOfEra", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2004, 6, 9);\n    Interval testInterval = test.yearOfEra().toInterval();\n    assertEquals(new DateMidnight(2004, 1, 1), testInterval.getStart());\n    assertEquals(new DateMidnight(2005, 1, 1), testInterval.getEnd());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1638, "method_signature": "void testPropertyToIntervalYearOfEra()"}, "TestDateMidnight_Properties.testTest": {"callee_method_names": [], "method_name": "TestDateMidnight_Properties.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1626, "method_signature": "void testTest()"}, "TestDateTimeComparator.getADate": {"callee_method_names": [], "method_name": "TestDateTimeComparator.getADate", "method_implementation": "{\n    DateTime retDT = null;\n    try {\n        retDT = new DateTime(s, DateTimeZone.UTC);\n    } catch (IllegalArgumentException pe) {\n        pe.printStackTrace();\n    }\n    return retDT;\n}", "repo_id": "7", "comment": "/**\n * Creates a date to test with.\n */\n", "repo_name": "joda-time-main/", "id": 1491, "method_signature": "DateTime getADate(String)"}, "TestDateTimeComparator.isListSorted": {"callee_method_names": ["List.get", "DateTime.getMillis", "List.size", "List.get", "DateTime.getMillis", "Long.compareTo"], "method_name": "TestDateTimeComparator.isListSorted", "method_implementation": "{\n    // tl must be populated with DateTime objects.\n    DateTime lhDT = (DateTime) tl.get(0);\n    DateTime rhDT = null;\n    Long lhVal = new Long(lhDT.getMillis());\n    Long rhVal = null;\n    for (int i = 1; i < tl.size(); ++i) {\n        rhDT = (DateTime) tl.get(i);\n        rhVal = new Long(rhDT.getMillis());\n        if (lhVal.compareTo(rhVal) > 0)\n            return false;\n        //\n        // swap for next iteration\n        lhVal = rhVal;\n        // swap for next iteration\n        lhDT = rhDT;\n    }\n    return true;\n}", "repo_id": "7", "comment": "/**\n * Check if the list is sorted.\n */\n", "repo_name": "joda-time-main/", "id": 1493, "method_signature": "boolean isListSorted(List)"}, "TestDateTimeComparator.loadAList": {"callee_method_names": ["List.add"], "method_name": "TestDateTimeComparator.loadAList", "method_implementation": "{\n    List newList = new ArrayList();\n    try {\n        for (int i = 0; i < someStrs.length; ++i) {\n            newList.add(new DateTime(someStrs[i], DateTimeZone.UTC));\n        }\n        // end of the for\n    } catch (IllegalArgumentException pe) {\n        pe.printStackTrace();\n    }\n    return newList;\n}", "repo_id": "7", "comment": "/**\n * Load a string array.\n */\n", "repo_name": "joda-time-main/", "id": 1492, "method_signature": "List loadAList(String[])"}, "TestDateTimeComparator.setUp": {"callee_method_names": [], "method_name": "TestDateTimeComparator.setUp", "method_implementation": "/* throws Exception */\n{\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    // super.setUp();\n    // Obtain comparator's\n    cMillis = DateTimeComparator.getInstance(null, DateTimeFieldType.secondOfMinute());\n    cSecond = DateTimeComparator.getInstance(DateTimeFieldType.secondOfMinute(), DateTimeFieldType.minuteOfHour());\n    cMinute = DateTimeComparator.getInstance(DateTimeFieldType.minuteOfHour(), DateTimeFieldType.hourOfDay());\n    cHour = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());\n    cDayOfWeek = DateTimeComparator.getInstance(DateTimeFieldType.dayOfWeek(), DateTimeFieldType.weekOfWeekyear());\n    cDayOfMonth = DateTimeComparator.getInstance(DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear());\n    cDayOfYear = DateTimeComparator.getInstance(DateTimeFieldType.dayOfYear(), DateTimeFieldType.year());\n    cWeekOfWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.weekyear());\n    cWeekyear = DateTimeComparator.getInstance(DateTimeFieldType.weekyear());\n    cMonth = DateTimeComparator.getInstance(DateTimeFieldType.monthOfYear(), DateTimeFieldType.year());\n    cYear = DateTimeComparator.getInstance(DateTimeFieldType.year());\n    cDate = DateTimeComparator.getDateOnlyInstance();\n    cTime = DateTimeComparator.getTimeOnlyInstance();\n}", "repo_id": "7", "comment": "/**\n * Junit <code>setUp()</code> method.\n */\n", "repo_name": "joda-time-main/", "id": 1452, "method_signature": "void setUp()"}, "TestDateTimeComparator.tearDown": {"callee_method_names": [], "method_name": "TestDateTimeComparator.tearDown", "method_implementation": "/* throws Exception */\n{\n    // super.tearDown();\n    aDateTime = null;\n    bDateTime = null;\n    //\n    cMillis = null;\n    cSecond = null;\n    cMinute = null;\n    cHour = null;\n    cDayOfWeek = null;\n    cDayOfMonth = null;\n    cDayOfYear = null;\n    cWeekOfWeekyear = null;\n    cWeekyear = null;\n    cMonth = null;\n    cYear = null;\n    cDate = null;\n    cTime = null;\n}", "repo_id": "7", "comment": "/**\n * Junit <code>tearDown()</code> method.\n */\n", "repo_name": "joda-time-main/", "id": 1453, "method_signature": "void tearDown()"}, "TestDateTimeComparator.testBasicComps1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testBasicComps1", "method_implementation": "{\n    aDateTime = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC);\n    bDateTime = new DateTime(aDateTime.getMillis(), DateTimeZone.UTC);\n    assertEquals(\"getMillis\", aDateTime.getMillis(), bDateTime.getMillis());\n    assertEquals(\"MILLIS\", 0, cMillis.compare(aDateTime, bDateTime));\n    assertEquals(\"SECOND\", 0, cSecond.compare(aDateTime, bDateTime));\n    assertEquals(\"MINUTE\", 0, cMinute.compare(aDateTime, bDateTime));\n    assertEquals(\"HOUR\", 0, cHour.compare(aDateTime, bDateTime));\n    assertEquals(\"DOW\", 0, cDayOfWeek.compare(aDateTime, bDateTime));\n    assertEquals(\"DOM\", 0, cDayOfMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"DOY\", 0, cDayOfYear.compare(aDateTime, bDateTime));\n    assertEquals(\"WOW\", 0, cWeekOfWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"WY\", 0, cWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"MONTH\", 0, cMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"YEAR\", 0, cYear.compare(aDateTime, bDateTime));\n    assertEquals(\"DATE\", 0, cDate.compare(aDateTime, bDateTime));\n    assertEquals(\"TIME\", 0, cTime.compare(aDateTime, bDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test all basic comparator operation with DateTime objects.\n */\n", "repo_name": "joda-time-main/", "id": 1459, "method_signature": "void testBasicComps1()"}, "TestDateTimeComparator.testBasicComps2": {"callee_method_names": ["ReadableInstant.getMillis", "ReadableInstant.getMillis", "ReadableInstant.getMillis", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testBasicComps2", "method_implementation": "{\n    ReadableInstant aDateTime = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC);\n    ReadableInstant bDateTime = new DateTime(aDateTime.getMillis(), DateTimeZone.UTC);\n    assertEquals(\"getMillis\", aDateTime.getMillis(), bDateTime.getMillis());\n    assertEquals(\"MILLIS\", 0, cMillis.compare(aDateTime, bDateTime));\n    assertEquals(\"SECOND\", 0, cSecond.compare(aDateTime, bDateTime));\n    assertEquals(\"MINUTE\", 0, cMinute.compare(aDateTime, bDateTime));\n    assertEquals(\"HOUR\", 0, cHour.compare(aDateTime, bDateTime));\n    assertEquals(\"DOW\", 0, cDayOfWeek.compare(aDateTime, bDateTime));\n    assertEquals(\"DOM\", 0, cDayOfMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"DOY\", 0, cDayOfYear.compare(aDateTime, bDateTime));\n    assertEquals(\"WOW\", 0, cWeekOfWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"WY\", 0, cWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"MONTH\", 0, cMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"YEAR\", 0, cYear.compare(aDateTime, bDateTime));\n    assertEquals(\"DATE\", 0, cDate.compare(aDateTime, bDateTime));\n    assertEquals(\"TIME\", 0, cTime.compare(aDateTime, bDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test all basic comparator operation with ReadableInstant objects.\n */\n", "repo_name": "joda-time-main/", "id": 1460, "method_signature": "void testBasicComps2()"}, "TestDateTimeComparator.testBasicComps3": {"callee_method_names": ["Date.getTime", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testBasicComps3", "method_implementation": "{\n    Date aDateTime = new Date(System.currentTimeMillis());\n    Date bDateTime = new Date(aDateTime.getTime());\n    assertEquals(\"MILLIS\", 0, cMillis.compare(aDateTime, bDateTime));\n    assertEquals(\"SECOND\", 0, cSecond.compare(aDateTime, bDateTime));\n    assertEquals(\"MINUTE\", 0, cMinute.compare(aDateTime, bDateTime));\n    assertEquals(\"HOUR\", 0, cHour.compare(aDateTime, bDateTime));\n    assertEquals(\"DOW\", 0, cDayOfWeek.compare(aDateTime, bDateTime));\n    assertEquals(\"DOM\", 0, cDayOfMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"DOY\", 0, cDayOfYear.compare(aDateTime, bDateTime));\n    assertEquals(\"WOW\", 0, cWeekOfWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"WY\", 0, cWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"MONTH\", 0, cMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"YEAR\", 0, cYear.compare(aDateTime, bDateTime));\n    assertEquals(\"DATE\", 0, cDate.compare(aDateTime, bDateTime));\n    assertEquals(\"TIME\", 0, cTime.compare(aDateTime, bDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test all basic comparator operation with java Date objects.\n */\n", "repo_name": "joda-time-main/", "id": 1461, "method_signature": "void testBasicComps3()"}, "TestDateTimeComparator.testBasicComps4": {"callee_method_names": ["Long.longValue", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testBasicComps4", "method_implementation": "{\n    Long aDateTime = new Long(System.currentTimeMillis());\n    Long bDateTime = new Long(aDateTime.longValue());\n    assertEquals(\"MILLIS\", 0, cMillis.compare(aDateTime, bDateTime));\n    assertEquals(\"SECOND\", 0, cSecond.compare(aDateTime, bDateTime));\n    assertEquals(\"MINUTE\", 0, cMinute.compare(aDateTime, bDateTime));\n    assertEquals(\"HOUR\", 0, cHour.compare(aDateTime, bDateTime));\n    assertEquals(\"DOW\", 0, cDayOfWeek.compare(aDateTime, bDateTime));\n    assertEquals(\"DOM\", 0, cDayOfMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"DOY\", 0, cDayOfYear.compare(aDateTime, bDateTime));\n    assertEquals(\"WOW\", 0, cWeekOfWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"WY\", 0, cWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"MONTH\", 0, cMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"YEAR\", 0, cYear.compare(aDateTime, bDateTime));\n    assertEquals(\"DATE\", 0, cDate.compare(aDateTime, bDateTime));\n    assertEquals(\"TIME\", 0, cTime.compare(aDateTime, bDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test all basic comparator operation with Long objects.\n */\n", "repo_name": "joda-time-main/", "id": 1462, "method_signature": "void testBasicComps4()"}, "TestDateTimeComparator.testBasicComps5": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testBasicComps5", "method_implementation": "{\n    Calendar aDateTime = // right now\n    Calendar.getInstance();\n    Calendar bDateTime = aDateTime;\n    assertEquals(\"MILLIS\", 0, cMillis.compare(aDateTime, bDateTime));\n    assertEquals(\"SECOND\", 0, cSecond.compare(aDateTime, bDateTime));\n    assertEquals(\"MINUTE\", 0, cMinute.compare(aDateTime, bDateTime));\n    assertEquals(\"HOUR\", 0, cHour.compare(aDateTime, bDateTime));\n    assertEquals(\"DOW\", 0, cDayOfWeek.compare(aDateTime, bDateTime));\n    assertEquals(\"DOM\", 0, cDayOfMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"DOY\", 0, cDayOfYear.compare(aDateTime, bDateTime));\n    assertEquals(\"WOW\", 0, cWeekOfWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"WY\", 0, cWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"MONTH\", 0, cMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"YEAR\", 0, cYear.compare(aDateTime, bDateTime));\n    assertEquals(\"DATE\", 0, cDate.compare(aDateTime, bDateTime));\n    assertEquals(\"TIME\", 0, cTime.compare(aDateTime, bDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test all basic comparator operation with Calendar objects.\n */\n", "repo_name": "joda-time-main/", "id": 1463, "method_signature": "void testBasicComps5()"}, "TestDateTimeComparator.testClass": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testClass", "method_implementation": "{\n    assertEquals(true, Modifier.isPublic(DateTimeComparator.class.getModifiers()));\n    assertEquals(false, Modifier.isFinal(DateTimeComparator.class.getModifiers()));\n    assertEquals(1, DateTimeComparator.class.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(DateTimeComparator.class.getDeclaredConstructors()[0].getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1454, "method_signature": "void testClass()"}, "TestDateTimeComparator.testDOM": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testDOM", "method_implementation": "{\n    aDateTime = getADate(\"2002-04-12T00:00:00\");\n    bDateTime = getADate(\"2002-04-13T00:00:00\");\n    assertEquals(\"DOMM1a\", -1, cDayOfMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"DOMP1a\", 1, cDayOfMonth.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"2000-12-01T00:00:00\");\n    bDateTime = getADate(\"1814-04-30T00:00:00\");\n    assertEquals(\"DOMM1b\", -1, cDayOfMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"DOMP1b\", 1, cDayOfMonth.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with day of month comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1469, "method_signature": "void testDOM()"}, "TestDateTimeComparator.testDOW": {"callee_method_names": ["Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testDOW", "method_implementation": "{\n    /*\n         * Dates chosen when I wrote the code, so I know what day of\n         * the week it is.\n         */\n    aDateTime = getADate(\"2002-04-12T00:00:00\");\n    bDateTime = getADate(\"2002-04-13T00:00:00\");\n    assertEquals(\"DOWM1a\", -1, cDayOfWeek.compare(aDateTime, bDateTime));\n    assertEquals(\"DOWP1a\", 1, cDayOfWeek.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with day of week comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1468, "method_signature": "void testDOW()"}, "TestDateTimeComparator.testDOY": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testDOY", "method_implementation": "{\n    aDateTime = getADate(\"2002-04-12T00:00:00\");\n    bDateTime = getADate(\"2002-04-13T00:00:00\");\n    assertEquals(\"DOYM1a\", -1, cDayOfYear.compare(aDateTime, bDateTime));\n    assertEquals(\"DOYP1a\", 1, cDayOfYear.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"2000-02-29T00:00:00\");\n    bDateTime = getADate(\"1814-11-30T00:00:00\");\n    assertEquals(\"DOYM1b\", -1, cDayOfYear.compare(aDateTime, bDateTime));\n    assertEquals(\"DOYP1b\", 1, cDayOfYear.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with day of year comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1470, "method_signature": "void testDOY()"}, "TestDateTimeComparator.testEqualsHashCode": {"callee_method_ids": [235, 235, 236, 236, 235, 235, 235, 235, 236, 236, 235, 235, 235, 235, 235, 236, 236, 236, 236, 236, 236], "callee_method_names": ["DateTimeComparator.equals", "DateTimeComparator.equals", "DateTimeComparator.hashCode", "DateTimeComparator.hashCode", "DateTimeComparator.equals", "DateTimeComparator.equals", "DateTimeComparator.equals", "DateTimeComparator.equals", "DateTimeComparator.hashCode", "DateTimeComparator.hashCode", "DateTimeComparator.equals", "DateTimeComparator.equals", "DateTimeComparator.equals", "DateTimeComparator.equals", "DateTimeComparator.equals", "DateTimeComparator.hashCode", "DateTimeComparator.hashCode", "DateTimeComparator.hashCode", "DateTimeComparator.hashCode", "DateTimeComparator.hashCode", "DateTimeComparator.hashCode"], "method_name": "TestDateTimeComparator.testEqualsHashCode", "method_implementation": "{\n    DateTimeComparator c1 = DateTimeComparator.getInstance();\n    assertEquals(true, c1.equals(c1));\n    assertEquals(false, c1.equals(null));\n    assertEquals(true, c1.hashCode() == c1.hashCode());\n    DateTimeComparator c2 = DateTimeComparator.getTimeOnlyInstance();\n    assertEquals(true, c2.equals(c2));\n    assertEquals(false, c2.equals(c1));\n    assertEquals(false, c1.equals(c2));\n    assertEquals(false, c2.equals(null));\n    assertEquals(false, c1.hashCode() == c2.hashCode());\n    DateTimeComparator c3 = DateTimeComparator.getTimeOnlyInstance();\n    assertEquals(true, c3.equals(c3));\n    assertEquals(false, c3.equals(c1));\n    assertEquals(true, c3.equals(c2));\n    assertEquals(false, c1.equals(c3));\n    assertEquals(true, c2.equals(c3));\n    assertEquals(false, c1.hashCode() == c3.hashCode());\n    assertEquals(true, c2.hashCode() == c3.hashCode());\n    DateTimeComparator c4 = DateTimeComparator.getDateOnlyInstance();\n    assertEquals(false, c4.hashCode() == c3.hashCode());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1456, "method_signature": "void testEqualsHashCode()"}, "TestDateTimeComparator.testHour": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testHour", "method_implementation": "{\n    aDateTime = getADate(\"1969-12-31T22:00:00\");\n    bDateTime = getADate(\"1969-12-31T23:00:00\");\n    assertEquals(\"HourM1a\", -1, cHour.compare(aDateTime, bDateTime));\n    assertEquals(\"HourP1a\", 1, cHour.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"1970-01-01T00:00:00\");\n    bDateTime = getADate(\"1970-01-01T01:00:00\");\n    assertEquals(\"HourM1b\", -1, cHour.compare(aDateTime, bDateTime));\n    assertEquals(\"HourP1b\", 1, cHour.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"1969-12-31T23:59:59\");\n    bDateTime = getADate(\"1970-01-01T00:00:00\");\n    assertEquals(\"HourP1c\", 1, cHour.compare(aDateTime, bDateTime));\n    assertEquals(\"HourM1c\", -1, cHour.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with hour comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1467, "method_signature": "void testHour()"}, "TestDateTimeComparator.testInvalidObj": {"callee_method_names": ["Comparator.compare"], "method_name": "TestDateTimeComparator.testInvalidObj", "method_implementation": "{\n    aDateTime = getADate(\"2000-01-01T00:00:00\");\n    try {\n        cYear.compare(\"FreeBird\", aDateTime);\n        fail(\"Invalid object failed\");\n    } catch (IllegalArgumentException cce) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test comparator operation with an invalid object type.\n */\n", "repo_name": "joda-time-main/", "id": 1490, "method_signature": "void testInvalidObj()"}, "TestDateTimeComparator.testListBasic": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListBasic", "method_implementation": "{\n    String[] dtStrs = { \"1999-02-01T00:00:00\", \"1998-01-20T00:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListBasic\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with full default comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1475, "method_signature": "void testListBasic()"}, "TestDateTimeComparator.testListDOM": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListDOM", "method_implementation": "{\n    String[] dtStrs = { /* 2002-04-14 = Sunday */\n    \"2002-04-20T10:00:00\", \"2002-04-16T10:00:00\", \"2002-04-15T10:00:00\", \"2002-04-17T10:00:00\", \"2002-04-19T10:00:00\", \"2002-04-18T10:00:00\", \"2002-04-14T10:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cDayOfMonth);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListDOM\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with day of month comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1481, "method_signature": "void testListDOM()"}, "TestDateTimeComparator.testListDOW": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListDOW", "method_implementation": "{\n    String[] dtStrs = { /* 2002-04-15 = Monday */\n    \"2002-04-21T10:00:00\", \"2002-04-16T10:00:00\", \"2002-04-15T10:00:00\", \"2002-04-17T10:00:00\", \"2002-04-19T10:00:00\", \"2002-04-18T10:00:00\", \"2002-04-20T10:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cDayOfWeek);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListDOW\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with day of week comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1480, "method_signature": "void testListDOW()"}, "TestDateTimeComparator.testListDOY": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListDOY", "method_implementation": "{\n    String[] dtStrs = { \"2002-04-20T10:00:00\", \"2002-01-16T10:00:00\", \"2002-12-31T10:00:00\", \"2002-09-14T10:00:00\", \"2002-09-19T10:00:00\", \"2002-02-14T10:00:00\", \"2002-10-30T10:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cDayOfYear);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListDOY\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with day of year comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1482, "method_signature": "void testListDOY()"}, "TestDateTimeComparator.testListDate": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListDate", "method_implementation": "{\n    String[] dtStrs = { \"1999-02-01T00:00:00\", \"1998-10-03T00:00:00\", \"2525-05-20T00:00:00\", \"1776-12-25T00:00:00\", \"1863-01-31T00:00:00\", \"1066-09-22T00:00:00\", \"2100-07-04T00:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cDate);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListDate\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with date only comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1487, "method_signature": "void testListDate()"}, "TestDateTimeComparator.testListHour": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListHour", "method_implementation": "{\n    String[] dtStrs = { \"1999-02-01T10:00:00\", \"1999-02-01T23:00:00\", \"1999-02-01T01:00:00\", \"1999-02-01T15:00:00\", \"1999-02-01T05:00:00\", \"1999-02-01T20:00:00\", \"1999-02-01T17:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cHour);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListHour\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with hour comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1479, "method_signature": "void testListHour()"}, "TestDateTimeComparator.testListMillis": {"callee_method_names": ["List.add", "List.add", "List.add", "List.add", "List.add", "List.add"], "method_name": "TestDateTimeComparator.testListMillis", "method_implementation": "{\n    //\n    List sl = new ArrayList();\n    long base = 12345L * 1000L;\n    sl.add(new DateTime(base + 999L, DateTimeZone.UTC));\n    sl.add(new DateTime(base + 222L, DateTimeZone.UTC));\n    sl.add(new DateTime(base + 456L, DateTimeZone.UTC));\n    sl.add(new DateTime(base + 888L, DateTimeZone.UTC));\n    sl.add(new DateTime(base + 123L, DateTimeZone.UTC));\n    sl.add(new DateTime(base + 000L, DateTimeZone.UTC));\n    //\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cMillis);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListLillis\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with millis of second comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1476, "method_signature": "void testListMillis()"}, "TestDateTimeComparator.testListMinute": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListMinute", "method_implementation": "{\n    String[] dtStrs = { \"1999-02-01T00:10:00\", \"1999-02-01T00:30:00\", \"1999-02-01T00:25:00\", \"1999-02-01T00:18:00\", \"1999-02-01T00:01:00\", \"1999-02-01T00:59:00\", \"1999-02-01T00:22:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cMinute);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListMinute\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with minute comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1478, "method_signature": "void testListMinute()"}, "TestDateTimeComparator.testListMonth": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListMonth", "method_implementation": "{\n    String[] dtStrs = { \"2002-04-01T10:00:00\", \"2002-01-01T10:00:00\", \"2002-12-01T10:00:00\", \"2002-09-01T10:00:00\", \"2002-09-01T10:00:00\", \"2002-02-01T10:00:00\", \"2002-10-01T10:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cMonth);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListMonth\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with month comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1485, "method_signature": "void testListMonth()"}, "TestDateTimeComparator.testListSecond": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListSecond", "method_implementation": "{\n    String[] dtStrs = { \"1999-02-01T00:00:10\", \"1999-02-01T00:00:30\", \"1999-02-01T00:00:25\", \"1999-02-01T00:00:18\", \"1999-02-01T00:00:01\", \"1999-02-01T00:00:59\", \"1999-02-01T00:00:22\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cSecond);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListSecond\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with second comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1477, "method_signature": "void testListSecond()"}, "TestDateTimeComparator.testListTime": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListTime", "method_implementation": "{\n    String[] dtStrs = { \"1999-02-01T01:02:05\", \"1999-02-01T22:22:22\", \"1999-02-01T05:30:45\", \"1999-02-01T09:17:59\", \"1999-02-01T09:17:58\", \"1999-02-01T15:30:00\", \"1999-02-01T17:00:44\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cTime);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListTime\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with time only comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1488, "method_signature": "void testListTime()"}, "TestDateTimeComparator.testListWOW": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListWOW", "method_implementation": "{\n    String[] dtStrs = { \"2002-04-01T10:00:00\", \"2002-01-01T10:00:00\", \"2002-12-01T10:00:00\", \"2002-09-01T10:00:00\", \"2002-09-01T10:00:00\", \"2002-02-01T10:00:00\", \"2002-10-01T10:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cWeekOfWeekyear);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListWOW\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with week of weekyear comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1483, "method_signature": "void testListWOW()"}, "TestDateTimeComparator.testListYOYY": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListYOYY", "method_implementation": "{\n    // ?? How to catch end conditions ??\n    String[] dtStrs = { \"2010-04-01T10:00:00\", \"2002-01-01T10:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cWeekyear);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListYOYY\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with year (given week) comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1484, "method_signature": "void testListYOYY()"}, "TestDateTimeComparator.testListYear": {"callee_method_names": [], "method_name": "TestDateTimeComparator.testListYear", "method_implementation": "{\n    String[] dtStrs = { \"1999-02-01T00:00:00\", \"1998-02-01T00:00:00\", \"2525-02-01T00:00:00\", \"1776-02-01T00:00:00\", \"1863-02-01T00:00:00\", \"1066-02-01T00:00:00\", \"2100-02-01T00:00:00\" };\n    //\n    List sl = loadAList(dtStrs);\n    boolean isSorted1 = isListSorted(sl);\n    Collections.sort(sl, cYear);\n    boolean isSorted2 = isListSorted(sl);\n    assertEquals(\"ListYear\", !isSorted1, isSorted2);\n}", "repo_id": "7", "comment": "/**\n * Test sorting with year comparator.\n */\n", "repo_name": "joda-time-main/", "id": 1486, "method_signature": "void testListYear()"}, "TestDateTimeComparator.testMillis": {"callee_method_names": ["Calendar.getMillis", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testMillis", "method_implementation": "{\n    aDateTime = new DateTime(System.currentTimeMillis(), DateTimeZone.UTC);\n    bDateTime = new DateTime(aDateTime.getMillis() + 1, DateTimeZone.UTC);\n    assertEquals(\"MillisM1\", -1, cMillis.compare(aDateTime, bDateTime));\n    assertEquals(\"MillisP1\", 1, cMillis.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with millis of second comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1464, "method_signature": "void testMillis()"}, "TestDateTimeComparator.testMinute": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testMinute", "method_implementation": "{\n    aDateTime = getADate(\"1969-12-31T23:58:00\");\n    bDateTime = getADate(\"1969-12-31T23:59:00\");\n    assertEquals(\"MinuteM1a\", -1, cMinute.compare(aDateTime, bDateTime));\n    assertEquals(\"MinuteP1a\", 1, cMinute.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"1970-01-01T00:00:00\");\n    bDateTime = getADate(\"1970-01-01T00:01:00\");\n    assertEquals(\"MinuteM1b\", -1, cMinute.compare(aDateTime, bDateTime));\n    assertEquals(\"MinuteP1b\", 1, cMinute.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with minute comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1466, "method_signature": "void testMinute()"}, "TestDateTimeComparator.testMonth": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testMonth", "method_implementation": "{\n    aDateTime = getADate(\"2002-04-30T00:00:00\");\n    bDateTime = getADate(\"2002-05-01T00:00:00\");\n    assertEquals(\"MONTHM1a\", -1, cMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"MONTHP1a\", 1, cMonth.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"1900-01-01T00:00:00\");\n    bDateTime = getADate(\"1899-12-31T00:00:00\");\n    assertEquals(\"MONTHM1b\", -1, cMonth.compare(aDateTime, bDateTime));\n    assertEquals(\"MONTHP1b\", 1, cMonth.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with month comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1473, "method_signature": "void testMonth()"}, "TestDateTimeComparator.testNullDT": {"callee_method_names": ["Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testNullDT", "method_implementation": "{\n    // null means now\n    aDateTime = getADate(\"2000-01-01T00:00:00\");\n    assertTrue(cYear.compare(null, aDateTime) > 0);\n    assertTrue(cYear.compare(aDateTime, null) < 0);\n}", "repo_id": "7", "comment": "/**\n * Test comparator operation with null object(s).\n */\n", "repo_name": "joda-time-main/", "id": 1489, "method_signature": "void testNullDT()"}, "TestDateTimeComparator.testSecond": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testSecond", "method_implementation": "{\n    aDateTime = getADate(\"1969-12-31T23:59:58\");\n    bDateTime = getADate(\"1969-12-31T23:50:59\");\n    assertEquals(\"SecondM1a\", -1, cSecond.compare(aDateTime, bDateTime));\n    assertEquals(\"SecondP1a\", 1, cSecond.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"1970-01-01T00:00:00\");\n    bDateTime = getADate(\"1970-01-01T00:00:01\");\n    assertEquals(\"SecondM1b\", -1, cSecond.compare(aDateTime, bDateTime));\n    assertEquals(\"SecondP1b\", 1, cSecond.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with second comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1465, "method_signature": "void testSecond()"}, "TestDateTimeComparator.testSerialization1": {"callee_method_names": ["Chronology.dayOfYear", "DateTimeField.toString", "ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestDateTimeComparator.testSerialization1", "method_implementation": "{\n    DateTimeField f = ISO.dayOfYear();\n    f.toString();\n    DateTimeComparator c = DateTimeComparator.getInstance(DateTimeFieldType.hourOfDay(), DateTimeFieldType.dayOfYear());\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(c);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    DateTimeComparator result = (DateTimeComparator) ois.readObject();\n    ois.close();\n    assertEquals(c, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1457, "method_signature": "void testSerialization1()"}, "TestDateTimeComparator.testSerialization2": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestDateTimeComparator.testSerialization2", "method_implementation": "{\n    DateTimeComparator c = DateTimeComparator.getInstance();\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(c);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    DateTimeComparator result = (DateTimeComparator) ois.readObject();\n    ois.close();\n    assertSame(c, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1458, "method_signature": "void testSerialization2()"}, "TestDateTimeComparator.testStaticGetInstance": {"callee_method_ids": [237], "callee_method_names": ["DateTimeComparator.getLowerLimit", "DateTimeComparator.getUpperLimit", "DateTimeComparator.toString"], "method_name": "TestDateTimeComparator.testStaticGetInstance", "method_implementation": "{\n    DateTimeComparator c = DateTimeComparator.getInstance();\n    assertEquals(null, c.getLowerLimit());\n    assertEquals(null, c.getUpperLimit());\n    assertEquals(\"DateTimeComparator[]\", c.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1455, "method_signature": "void testStaticGetInstance()"}, "TestDateTimeComparator.testWOW": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testWOW", "method_implementation": "{\n    // 1st week of year contains Jan 04.\n    aDateTime = getADate(\"2000-01-04T00:00:00\");\n    bDateTime = getADate(\"2000-01-11T00:00:00\");\n    assertEquals(\"WOWM1a\", -1, cWeekOfWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"WOWP1a\", 1, cWeekOfWeekyear.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"2000-01-04T00:00:00\");\n    bDateTime = getADate(\"1999-12-31T00:00:00\");\n    assertEquals(\"WOWM1b\", -1, cWeekOfWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"WOWP1b\", 1, cWeekOfWeekyear.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with week of weekyear comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1471, "method_signature": "void testWOW()"}, "TestDateTimeComparator.testWOYY": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testWOYY", "method_implementation": "{\n    // How do I test the end conditions of this?\n    // Don't understand ......\n    aDateTime = getADate(\"1998-12-31T23:59:59\");\n    bDateTime = getADate(\"1999-01-01T00:00:00\");\n    assertEquals(\"YOYYZ\", 0, cWeekyear.compare(aDateTime, bDateTime));\n    bDateTime = getADate(\"1999-01-04T00:00:00\");\n    assertEquals(\"YOYYM1\", -1, cWeekyear.compare(aDateTime, bDateTime));\n    assertEquals(\"YOYYP1\", 1, cWeekyear.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with year given the week comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1472, "method_signature": "void testWOYY()"}, "TestDateTimeComparator.testYear": {"callee_method_names": ["Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare", "Comparator.compare"], "method_name": "TestDateTimeComparator.testYear", "method_implementation": "{\n    aDateTime = getADate(\"2000-01-01T00:00:00\");\n    bDateTime = getADate(\"2001-01-01T00:00:00\");\n    assertEquals(\"YEARM1a\", -1, cYear.compare(aDateTime, bDateTime));\n    assertEquals(\"YEARP1a\", 1, cYear.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"1968-12-31T23:59:59\");\n    bDateTime = getADate(\"1970-01-01T00:00:00\");\n    assertEquals(\"YEARM1b\", -1, cYear.compare(aDateTime, bDateTime));\n    assertEquals(\"YEARP1b\", 1, cYear.compare(bDateTime, aDateTime));\n    aDateTime = getADate(\"1969-12-31T23:59:59\");\n    bDateTime = getADate(\"1970-01-01T00:00:00\");\n    assertEquals(\"YEARM1c\", -1, cYear.compare(aDateTime, bDateTime));\n    assertEquals(\"YEARP1c\", 1, cYear.compare(bDateTime, aDateTime));\n}", "repo_id": "7", "comment": "/**\n * Test unequal comparisons with year comparators.\n */\n", "repo_name": "joda-time-main/", "id": 1474, "method_signature": "void testYear()"}, "TestDateTimeConstants.testConstructor": {"callee_method_names": ["DateTimeConstants.toString"], "method_name": "TestDateTimeConstants.testConstructor", "method_implementation": "{\n    DateTimeConstants c = new DateTimeConstants() {\n    };\n    c.toString();\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2627, "method_signature": "void testConstructor()"}, "TestDateTimeFieldType.test_era": {"callee_method_names": [], "method_name": "TestDateTimeFieldType.test_era", "method_implementation": "{\n    assertEquals(DateTimeFieldType.era(), DateTimeFieldType.era());\n    assertEquals(\"era\", DateTimeFieldType.era().getName());\n    assertEquals(DurationFieldType.eras(), DateTimeFieldType.era().getDurationType());\n    assertEquals(null, DateTimeFieldType.era().getRangeDurationType());\n    assertEquals(CopticChronology.getInstanceUTC().era(), DateTimeFieldType.era().getField(CopticChronology.getInstanceUTC()));\n    assertEquals(CopticChronology.getInstanceUTC().era().isSupported(), DateTimeFieldType.era().isSupported(CopticChronology.getInstanceUTC()));\n    assertSerialization(DateTimeFieldType.era());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2198, "method_signature": "void test_era()"}, "TestDateTimeFormat.check": {"callee_method_names": ["DateTime.getYear", "DateTime.getMonthOfYear", "DateTime.getDayOfMonth"], "method_name": "TestDateTimeFormat.check", "method_implementation": "{\n    assertEquals(hour, test.getYear());\n    assertEquals(min, test.getMonthOfYear());\n    assertEquals(sec, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2255, "method_signature": "void check(DateTime, int, int, int)"}, "TestDateTimeFormat.testFormatParse_textAdjoiningHelloWorld_UK": {"callee_method_ids": [860], "callee_method_names": ["DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormat.testFormatParse_textAdjoiningHelloWorld_UK", "method_implementation": "{\n    DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder().appendLiteral('$').appendDayOfMonth(2).appendMonthOfYearShortText().appendLiteral(\"HelloWorld\").toFormatter().withLocale(Locale.UK).withZoneUTC();\n    String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n    assertEquals(\"$23JunHelloWorld\", str);\n    dateFormatter.parseDateTime(str);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2253, "method_signature": "void testFormatParse_textAdjoiningHelloWorld_UK()"}, "TestDateTimeFormat.testFormatParse_textEraAD_UK": {"callee_method_ids": [860], "callee_method_names": ["DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormat.testFormatParse_textEraAD_UK", "method_implementation": "{\n    DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder().appendLiteral('$').appendEraText().appendYear(4, 4).toFormatter().withLocale(Locale.UK).withZoneUTC();\n    String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n    assertEquals(\"$AD2007\", str);\n    DateTime date = dateFormatter.parseDateTime(str);\n    check(date, 2007, 1, 1);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2251, "method_signature": "void testFormatParse_textEraAD_UK()"}, "TestDateTimeFormat.testFormatParse_textHalfdayAM_UK": {"callee_method_ids": [860], "callee_method_names": ["String.toUpperCase", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormat.testFormatParse_textHalfdayAM_UK", "method_implementation": "{\n    DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder().appendLiteral('$').appendClockhourOfHalfday(2).appendLiteral('-').appendHalfdayOfDayText().appendLiteral('-').appendYear(4, 4).toFormatter().withLocale(Locale.UK).withZoneUTC();\n    String str = new DateTime(2007, 6, 23, 18, 0, 0, 0, UTC).toString(dateFormatter);\n    assertEquals(\"$06-PM-2007\", str.toUpperCase(Locale.ENGLISH));\n    DateTime date = dateFormatter.parseDateTime(str);\n    check(date, 2007, 1, 1);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2250, "method_signature": "void testFormatParse_textHalfdayAM_UK()"}, "TestDateTimeFormat.testFormatParse_textMonthJanShort_UK": {"callee_method_ids": [860], "callee_method_names": ["DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormat.testFormatParse_textMonthJanShort_UK", "method_implementation": "{\n    DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd MMM yyyy\").withLocale(Locale.UK).withZoneUTC();\n    String str = new DateTime(2007, 1, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n    assertEquals(str, \"23 Jan 2007\");\n    DateTime date = dateFormatter.parseDateTime(str);\n    check(date, 2007, 1, 23);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2249, "method_signature": "void testFormatParse_textMonthJanShort_UK()"}, "TestDateTimeFormat.testFormatParse_textYear_UK": {"callee_method_ids": [860], "callee_method_names": ["DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormat.testFormatParse_textYear_UK", "method_implementation": "{\n    DateTimeFormatter dateFormatter = new DateTimeFormatterBuilder().appendLiteral('$').appendText(DateTimeFieldType.year()).toFormatter().withLocale(Locale.UK).withZoneUTC();\n    String str = new DateTime(2007, 6, 23, 0, 0, 0, 0, UTC).toString(dateFormatter);\n    assertEquals(\"$2007\", str);\n    try {\n        dateFormatter.parseDateTime(str);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2252, "method_signature": "void testFormatParse_textYear_UK()"}, "TestDateTimeFormat.testFormatParse_zoneId_noColon": {"callee_method_ids": [860], "callee_method_names": ["DateTimeFormatter.parseDateTime", "DateTime.getHourOfDay", "DateTime.getMinuteOfHour"], "method_name": "TestDateTimeFormat.testFormatParse_zoneId_noColon", "method_implementation": "{\n    DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"HH:mm Z\").withZoneUTC();\n    String str = new DateTime(2007, 6, 23, 1, 2, 0, 0, UTC).toString(dateFormatter);\n    assertEquals(\"01:02 +0000\", str);\n    DateTime parsed = dateFormatter.parseDateTime(str);\n    assertEquals(1, parsed.getHourOfDay());\n    assertEquals(2, parsed.getMinuteOfHour());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2254, "method_signature": "void testFormatParse_zoneId_noColon()"}, "TestDateTimeFormat.testFormat_centuryOfEra": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_centuryOfEra", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"C\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"20\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"20\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"20\", f.print(dt));\n    dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(dt.toString(), \"1\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2223, "method_signature": "void testFormat_centuryOfEra()"}, "TestDateTimeFormat.testFormat_clockhourOfDay": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_clockhourOfDay", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"k\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"10\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"6\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"19\", f.print(dt));\n    dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, UTC);\n    assertEquals(dt.toString(), \"24\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2240, "method_signature": "void testFormat_clockhourOfDay()"}, "TestDateTimeFormat.testFormat_clockhourOfHalfday": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_clockhourOfHalfday", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"h\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"10\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"6\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"7\", f.print(dt));\n    dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, UTC);\n    assertEquals(dt.toString(), \"12\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2238, "method_signature": "void testFormat_clockhourOfHalfday()"}, "TestDateTimeFormat.testFormat_dayOfMonth": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_dayOfMonth", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"d\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"9\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"9\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"9\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2235, "method_signature": "void testFormat_dayOfMonth()"}, "TestDateTimeFormat.testFormat_dayOfWeek": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_dayOfWeek", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"e\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"3\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"3\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"3\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2228, "method_signature": "void testFormat_dayOfWeek()"}, "TestDateTimeFormat.testFormat_dayOfWeekShortText": {"callee_method_ids": [855, 855, 855, 840, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTimeFormatter.withLocale", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_dayOfWeekShortText", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"E\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"Wed\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"Wed\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"Wed\", f.print(dt));\n    f = f.withLocale(Locale.FRENCH);\n    assertEquals(dt.toString(), \"mer.\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2229, "method_signature": "void testFormat_dayOfWeekShortText()"}, "TestDateTimeFormat.testFormat_dayOfWeekText": {"callee_method_ids": [855, 855, 855, 840, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTimeFormatter.withLocale", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_dayOfWeekText", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"EEEE\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"Wednesday\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"Wednesday\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"Wednesday\", f.print(dt));\n    f = f.withLocale(Locale.FRENCH);\n    assertEquals(dt.toString(), \"mercredi\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2230, "method_signature": "void testFormat_dayOfWeekText()"}, "TestDateTimeFormat.testFormat_dayOfYearText": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_dayOfYearText", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"D\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"161\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"161\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"161\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2231, "method_signature": "void testFormat_dayOfYearText()"}, "TestDateTimeFormat.testFormat_era": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_era", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"G\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"AD\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"AD\", f.print(dt));\n    dt = dt.withZone(PARIS);\n    assertEquals(dt.toString(), \"AD\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2222, "method_signature": "void testFormat_era()"}, "TestDateTimeFormat.testFormat_fractionOfSecond": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_fractionOfSecond", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"SSS\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"040\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"040\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"040\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2243, "method_signature": "void testFormat_fractionOfSecond()"}, "TestDateTimeFormat.testFormat_fractionOfSecondLong": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_fractionOfSecondLong", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"SSSSSS\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"040000\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"040000\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"040000\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2244, "method_signature": "void testFormat_fractionOfSecondLong()"}, "TestDateTimeFormat.testFormat_halfdayOfDay": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_halfdayOfDay", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"a\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"AM\", f.print(dt).toUpperCase(Locale.ENGLISH));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"AM\", f.print(dt).toUpperCase(Locale.ENGLISH));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"PM\", f.print(dt).toUpperCase(Locale.ENGLISH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2236, "method_signature": "void testFormat_halfdayOfDay()"}, "TestDateTimeFormat.testFormat_hourOfDay": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_hourOfDay", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"H\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"10\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"6\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"19\", f.print(dt));\n    dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, UTC);\n    assertEquals(dt.toString(), \"0\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2239, "method_signature": "void testFormat_hourOfDay()"}, "TestDateTimeFormat.testFormat_hourOfHalfday": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_hourOfHalfday", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"K\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"10\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"6\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"7\", f.print(dt));\n    dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, UTC);\n    assertEquals(dt.toString(), \"0\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2237, "method_signature": "void testFormat_hourOfHalfday()"}, "TestDateTimeFormat.testFormat_minute": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_minute", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"m\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"20\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"20\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"20\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2241, "method_signature": "void testFormat_minute()"}, "TestDateTimeFormat.testFormat_monthOfYear": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_monthOfYear", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"6\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"6\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"6\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2232, "method_signature": "void testFormat_monthOfYear()"}, "TestDateTimeFormat.testFormat_monthOfYearShortText": {"callee_method_ids": [855, 855, 855, 840, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTimeFormatter.withLocale", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_monthOfYearShortText", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"MMM\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"Jun\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"Jun\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"Jun\", f.print(dt));\n    f = f.withLocale(Locale.FRENCH);\n    assertEquals(dt.toString(), \"juin\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2233, "method_signature": "void testFormat_monthOfYearShortText()"}, "TestDateTimeFormat.testFormat_monthOfYearText": {"callee_method_ids": [855, 855, 855, 840, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTimeFormatter.withLocale", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_monthOfYearText", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"MMMM\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"June\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"June\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"June\", f.print(dt));\n    f = f.withLocale(Locale.FRENCH);\n    assertEquals(dt.toString(), \"juin\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2234, "method_signature": "void testFormat_monthOfYearText()"}, "TestDateTimeFormat.testFormat_other": {"callee_method_ids": [855], "callee_method_names": ["DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_other", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"'Hello' ''\");\n    assertEquals(\"Hello '\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2247, "method_signature": "void testFormat_other()"}, "TestDateTimeFormat.testFormat_second": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_second", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"s\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"30\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"30\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"30\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2242, "method_signature": "void testFormat_second()"}, "TestDateTimeFormat.testFormat_weekOfWeekyear": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_weekOfWeekyear", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"w\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"24\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"24\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"24\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2227, "method_signature": "void testFormat_weekOfWeekyear()"}, "TestDateTimeFormat.testFormat_weekyear": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_weekyear", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"x\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"2004\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"2004\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"2004\", f.print(dt));\n    dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(dt.toString(), \"-123\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2226, "method_signature": "void testFormat_weekyear()"}, "TestDateTimeFormat.testFormat_year": {"callee_method_ids": [855, 855, 855, 855, 860, 860], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.toString", "DateTimeFormatter.print", "DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormat.testFormat_year", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"y\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"2004\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"2004\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"2004\", f.print(dt));\n    dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(dt.toString(), \"-123\", f.print(dt));\n    // Added tests to ensure single sign digit parse fails properly\n    try {\n        f.parseDateTime(\"-\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        f.parseDateTime(\"+\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2225, "method_signature": "void testFormat_year()"}, "TestDateTimeFormat.testFormat_yearOfEra": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_yearOfEra", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"Y\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"2004\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"2004\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"2004\", f.print(dt));\n    dt = new DateTime(-123, 6, 9, 10, 20, 30, 40, UTC);\n    // 124th year of BCE\n    assertEquals(dt.toString(), \"124\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2224, "method_signature": "void testFormat_yearOfEra()"}, "TestDateTimeFormat.testFormat_zoneAmount": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_zoneAmount", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"Z\").withLocale(Locale.UK);\n    assertEquals(dt.toString(), \"+0000\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"-0400\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"+0900\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2246, "method_signature": "void testFormat_zoneAmount()"}, "TestDateTimeFormat.testFormat_zoneText": {"callee_method_ids": [855, 855, 855], "callee_method_names": ["DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print", "DateTime.withZone", "DateTime.toString", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormat.testFormat_zoneText", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    DateTimeFormatter f = DateTimeFormat.forPattern(\"z\").withLocale(Locale.ENGLISH);\n    assertEquals(dt.toString(), \"UTC\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(dt.toString(), \"EDT\", f.print(dt));\n    dt = dt.withZone(TOKYO);\n    assertEquals(dt.toString(), \"JST\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2245, "method_signature": "void testFormat_zoneText()"}, "TestDateTimeFormat.testParse_pivotYear": {"callee_method_ids": [860, 860, 860], "callee_method_names": ["DateTimeFormatter.parseDateTime", "DateTime.getYear", "DateTimeFormatter.parseDateTime", "DateTime.getYear", "DateTimeFormatter.parseDateTime", "DateTime.getYear"], "method_name": "TestDateTimeFormat.testParse_pivotYear", "method_implementation": "{\n    DateTimeFormatter dateFormatter = DateTimeFormat.forPattern(\"dd.MM.yy\").withPivotYear(2050).withZoneUTC();\n    DateTime date = dateFormatter.parseDateTime(\"25.12.15\");\n    assertEquals(date.getYear(), 2015);\n    date = dateFormatter.parseDateTime(\"25.12.00\");\n    assertEquals(date.getYear(), 2000);\n    date = dateFormatter.parseDateTime(\"25.12.99\");\n    assertEquals(date.getYear(), 2099);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2248, "method_signature": "void testParse_pivotYear()"}, "TestDateTimeFormat.testSubclassableConstructor": {"callee_method_names": [], "method_name": "TestDateTimeFormat.testSubclassableConstructor", "method_implementation": "{\n    DateTimeFormat f = new DateTimeFormat() {\n    };\n    assertNotNull(f);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2221, "method_signature": "void testSubclassableConstructor()"}, "TestDateTimeFormatStyle.testForStyle_fullDate": {"callee_method_ids": [855, 840, 840], "callee_method_names": ["DateTime.toDate", "DateTimeFormatter.print", "DateTime.toDate", "DateTimeFormatter.withLocale", "DateTime.toDate", "DateTimeFormatter.withLocale"], "method_name": "TestDateTimeFormatStyle.testForStyle_fullDate", "method_implementation": "{\n    DateTimeFormatter f = DateTimeFormat.fullDate();\n    DateTimeFormatter g = DateTimeFormat.forStyle(\"F-\");\n    assertSame(g, f);\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n    String expect = DateFormat.getDateInstance(DateFormat.FULL, UK).format(dt.toDate());\n    assertEquals(expect, f.print(dt));\n    expect = DateFormat.getDateInstance(DateFormat.FULL, US).format(dt.toDate());\n    assertEquals(expect, f.withLocale(US).print(dt));\n    expect = DateFormat.getDateInstance(DateFormat.FULL, FRANCE).format(dt.toDate());\n    assertEquals(expect, f.withLocale(FRANCE).print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2218, "method_signature": "void testForStyle_fullDate()"}, "TestDateTimeFormatStyle.testForStyle_longDate": {"callee_method_ids": [855, 840, 840], "callee_method_names": ["DateTime.toDate", "DateTimeFormatter.print", "DateTime.toDate", "DateTimeFormatter.withLocale", "DateTime.toDate", "DateTimeFormatter.withLocale"], "method_name": "TestDateTimeFormatStyle.testForStyle_longDate", "method_implementation": "{\n    DateTimeFormatter f = DateTimeFormat.longDate();\n    DateTimeFormatter g = DateTimeFormat.forStyle(\"L-\");\n    assertSame(g, f);\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n    String expect = DateFormat.getDateInstance(DateFormat.LONG, UK).format(dt.toDate());\n    assertEquals(expect, f.print(dt));\n    expect = DateFormat.getDateInstance(DateFormat.LONG, US).format(dt.toDate());\n    assertEquals(expect, f.withLocale(US).print(dt));\n    expect = DateFormat.getDateInstance(DateFormat.LONG, FRANCE).format(dt.toDate());\n    assertEquals(expect, f.withLocale(FRANCE).print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2217, "method_signature": "void testForStyle_longDate()"}, "TestDateTimeFormatStyle.testForStyle_mediumDate": {"callee_method_ids": [855, 840, 840], "callee_method_names": ["DateTime.toDate", "DateTimeFormatter.print", "DateTime.toDate", "DateTimeFormatter.withLocale", "DateTime.toDate", "DateTimeFormatter.withLocale"], "method_name": "TestDateTimeFormatStyle.testForStyle_mediumDate", "method_implementation": "{\n    DateTimeFormatter f = DateTimeFormat.mediumDate();\n    DateTimeFormatter g = DateTimeFormat.forStyle(\"M-\");\n    assertSame(g, f);\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n    String expect = DateFormat.getDateInstance(DateFormat.MEDIUM, UK).format(dt.toDate());\n    assertEquals(expect, f.print(dt));\n    expect = DateFormat.getDateInstance(DateFormat.MEDIUM, US).format(dt.toDate());\n    assertEquals(expect, f.withLocale(US).print(dt));\n    expect = DateFormat.getDateInstance(DateFormat.MEDIUM, FRANCE).format(dt.toDate());\n    assertEquals(expect, f.withLocale(FRANCE).print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2216, "method_signature": "void testForStyle_mediumDate()"}, "TestDateTimeFormatStyle.testForStyle_mediumShortDateTime": {"callee_method_ids": [855, 840, 840], "callee_method_names": ["DateTime.toDate", "DateTimeFormatter.print", "DateTime.toDate", "DateTimeFormatter.withLocale", "DateTime.toDate", "DateTimeFormatter.withLocale"], "method_name": "TestDateTimeFormatStyle.testForStyle_mediumShortDateTime", "method_implementation": "{\n    DateTimeFormatter f = DateTimeFormat.forStyle(\"MS\");\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n    String expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, UK).format(dt.toDate());\n    assertEquals(expect, f.print(dt));\n    expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, US).format(dt.toDate());\n    assertEquals(expect, f.withLocale(US).print(dt));\n    expect = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT, FRANCE).format(dt.toDate());\n    assertEquals(expect, f.withLocale(FRANCE).print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2220, "method_signature": "void testForStyle_mediumShortDateTime()"}, "TestDateTimeFormatStyle.testForStyle_shortDate": {"callee_method_ids": [855, 840, 840, 840], "callee_method_names": ["DateTime.toDate", "DateTimeFormatter.print", "DateTime.toDate", "DateTimeFormatter.withLocale", "DateTime.toDate", "DateTimeFormatter.withLocale", "DateTimeFormatter.withLocale"], "method_name": "TestDateTimeFormatStyle.testForStyle_shortDate", "method_implementation": "{\n    DateTimeFormatter f = DateTimeFormat.shortDate();\n    DateTimeFormatter g = DateTimeFormat.forStyle(\"S-\");\n    assertSame(g, f);\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n    String expect = DateFormat.getDateInstance(DateFormat.SHORT, UK).format(dt.toDate());\n    assertEquals(expect, f.print(dt));\n    expect = DateFormat.getDateInstance(DateFormat.SHORT, US).format(dt.toDate());\n    assertEquals(expect, f.withLocale(US).print(dt));\n    expect = DateFormat.getDateInstance(DateFormat.SHORT, FRANCE).format(dt.toDate());\n    assertEquals(expect, f.withLocale(FRANCE).print(dt));\n    DateTime date = new DateTime(DateFormat.getDateInstance(DateFormat.SHORT, FRANCE).parse(expect));\n    assertEquals(date, f.withLocale(FRANCE).parseDateTime(expect));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2215, "method_signature": "void testForStyle_shortDate()"}, "TestDateTimeFormatStyle.testForStyle_shortMediumDateTime": {"callee_method_ids": [855, 840, 840], "callee_method_names": ["DateTime.toDate", "DateTimeFormatter.print", "DateTime.toDate", "DateTimeFormatter.withLocale", "DateTime.toDate", "DateTimeFormatter.withLocale"], "method_name": "TestDateTimeFormatStyle.testForStyle_shortMediumDateTime", "method_implementation": "{\n    DateTimeFormatter f = DateTimeFormat.forStyle(\"SM\");\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 0);\n    String expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, UK).format(dt.toDate());\n    assertEquals(expect, f.print(dt));\n    expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, US).format(dt.toDate());\n    assertEquals(expect, f.withLocale(US).print(dt));\n    expect = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, FRANCE).format(dt.toDate());\n    assertEquals(expect, f.withLocale(FRANCE).print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2219, "method_signature": "void testForStyle_shortMediumDateTime()"}, "TestDateTimeFormatStyle.testForStyle_stringLengths": {"callee_method_names": [], "method_name": "TestDateTimeFormatStyle.testForStyle_stringLengths", "method_implementation": "{\n    try {\n        DateTimeFormat.forStyle(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeFormat.forStyle(\"\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeFormat.forStyle(\"S\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeFormat.forStyle(\"SSS\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2214, "method_signature": "void testForStyle_stringLengths()"}, "TestDateTimeFormatter.testParseDateTime_simple": {"callee_method_ids": [860, 860], "callee_method_names": ["DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormatter.testParseDateTime_simple", "method_implementation": "{\n    DateTime expect = null;\n    expect = new DateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n    assertEquals(expect, g.parseDateTime(\"2004-06-09T10:20:30Z\"));\n    try {\n        g.parseDateTime(\"ABC\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2268, "method_signature": "void testParseDateTime_simple()"}, "TestDateTimeFormatter.testParseInto_simple": {"callee_method_ids": [857, 857, 857, 857, 857], "callee_method_names": ["DateTimeFormatter.parseInto", "DateTimeFormatter.parseInto", "DateTimeFormatter.parseInto", "DateTimeFormatter.parseInto", "DateTimeFormatter.parseInto"], "method_name": "TestDateTimeFormatter.testParseInto_simple", "method_implementation": "{\n    MutableDateTime expect = null;\n    expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n    MutableDateTime result = new MutableDateTime(0L);\n    assertEquals(20, g.parseInto(result, \"2004-06-09T10:20:30Z\", 0));\n    assertEquals(expect, result);\n    try {\n        g.parseInto(null, \"2004-06-09T10:20:30Z\", 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    assertEquals(~0, g.parseInto(result, \"ABC\", 0));\n    assertEquals(~10, g.parseInto(result, \"2004-06-09\", 0));\n    assertEquals(~13, g.parseInto(result, \"XX2004-06-09T\", 2));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2270, "method_signature": "void testParseInto_simple()"}, "TestDateTimeFormatter.testParseLocalDateTime_simple": {"callee_method_ids": [859, 859, 859, 842, 860], "callee_method_names": ["DateTimeFormatter.parseLocalDateTime", "DateTimeFormatter.parseLocalDateTime", "DateTimeFormatter.parseLocalDateTime", "DateTimeFormatter.withChronology", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormatter.testParseLocalDateTime_simple", "method_implementation": "{\n    assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30), g.parseLocalDateTime(\"2004-06-09T10:20:30Z\"));\n    assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30), g.parseLocalDateTime(\"2004-06-09T10:20:30+18:00\"));\n    assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30), g.parseLocalDateTime(\"2004-06-09T10:20:30-18:00\"));\n    assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30, 0, BUDDHIST_PARIS), g.withChronology(BUDDHIST_PARIS).parseLocalDateTime(\"2004-06-09T10:20:30Z\"));\n    try {\n        g.parseDateTime(\"ABC\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2267, "method_signature": "void testParseLocalDateTime_simple()"}, "TestDateTimeFormatter.testParseLocalDate_simple": {"callee_method_ids": [842, 860], "callee_method_names": ["DateTimeFormatter.parseLocalDate", "DateTimeFormatter.parseLocalDate", "DateTimeFormatter.parseLocalDate", "DateTimeFormatter.withChronology", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormatter.testParseLocalDate_simple", "method_implementation": "{\n    assertEquals(new LocalDate(2004, 6, 9), g.parseLocalDate(\"2004-06-09T10:20:30Z\"));\n    assertEquals(new LocalDate(2004, 6, 9), g.parseLocalDate(\"2004-06-09T10:20:30+18:00\"));\n    assertEquals(new LocalDate(2004, 6, 9), g.parseLocalDate(\"2004-06-09T10:20:30-18:00\"));\n    assertEquals(new LocalDate(2004, 6, 9, BUDDHIST_PARIS), g.withChronology(BUDDHIST_PARIS).parseLocalDate(\"2004-06-09T10:20:30Z\"));\n    try {\n        g.parseDateTime(\"ABC\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2265, "method_signature": "void testParseLocalDate_simple()"}, "TestDateTimeFormatter.testParseLocalTime_simple": {"callee_method_ids": [842, 860], "callee_method_names": ["DateTimeFormatter.parseLocalTime", "DateTimeFormatter.parseLocalTime", "DateTimeFormatter.parseLocalTime", "DateTimeFormatter.withChronology", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormatter.testParseLocalTime_simple", "method_implementation": "{\n    assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime(\"2004-06-09T10:20:30Z\"));\n    assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime(\"2004-06-09T10:20:30+18:00\"));\n    assertEquals(new LocalTime(10, 20, 30), g.parseLocalTime(\"2004-06-09T10:20:30-18:00\"));\n    assertEquals(new LocalTime(10, 20, 30, 0, BUDDHIST_PARIS), g.withChronology(BUDDHIST_PARIS).parseLocalTime(\"2004-06-09T10:20:30Z\"));\n    try {\n        g.parseDateTime(\"ABC\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2266, "method_signature": "void testParseLocalTime_simple()"}, "TestDateTimeFormatter.testParseMutableDateTime_simple": {"callee_method_ids": [861, 861], "callee_method_names": ["DateTimeFormatter.parseMutableDateTime", "DateTimeFormatter.parseMutableDateTime"], "method_name": "TestDateTimeFormatter.testParseMutableDateTime_simple", "method_implementation": "{\n    MutableDateTime expect = null;\n    expect = new MutableDateTime(2004, 6, 9, 11, 20, 30, 0, LONDON);\n    assertEquals(expect, g.parseMutableDateTime(\"2004-06-09T10:20:30Z\"));\n    try {\n        g.parseMutableDateTime(\"ABC\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2269, "method_signature": "void testParseMutableDateTime_simple()"}, "TestDateTimeFormatter.testPrint_appendableMethods": {"callee_method_ids": [852, 852], "callee_method_names": ["DateTimeFormatter.printTo", "StringBuilder.toString", "DateTimeFormatter.printTo", "DateTime.getMillis", "StringBuilder.toString", "DateTime.toLocalDate", "StringBuilder.toString"], "method_name": "TestDateTimeFormatter.testPrint_appendableMethods", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    StringBuilder buf = new StringBuilder();\n    f.printTo(buf, dt);\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", buf.toString());\n    buf = new StringBuilder();\n    f.printTo(buf, dt.getMillis());\n    assertEquals(\"Wed 2004-06-09T11:20:30+01:00\", buf.toString());\n    buf = new StringBuilder();\n    ISODateTimeFormat.yearMonthDay().printTo(buf, dt.toLocalDate());\n    assertEquals(\"2004-06-09\", buf.toString());\n    buf = new StringBuilder();\n    try {\n        ISODateTimeFormat.yearMonthDay().printTo(buf, (ReadablePartial) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2263, "method_signature": "void testPrint_appendableMethods()"}, "TestDateTimeFormatter.testPrint_bufferMethods": {"callee_method_ids": [852, 852], "callee_method_names": ["DateTimeFormatter.printTo", "StringBuffer.toString", "DateTimeFormatter.printTo", "DateTime.getMillis", "StringBuffer.toString", "DateTime.toYearMonthDay", "StringBuffer.toString"], "method_name": "TestDateTimeFormatter.testPrint_bufferMethods", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    StringBuffer buf = new StringBuffer();\n    f.printTo(buf, dt);\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", buf.toString());\n    buf = new StringBuffer();\n    f.printTo(buf, dt.getMillis());\n    assertEquals(\"Wed 2004-06-09T11:20:30+01:00\", buf.toString());\n    buf = new StringBuffer();\n    ISODateTimeFormat.yearMonthDay().printTo(buf, dt.toYearMonthDay());\n    assertEquals(\"2004-06-09\", buf.toString());\n    buf = new StringBuffer();\n    try {\n        ISODateTimeFormat.yearMonthDay().printTo(buf, (ReadablePartial) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2260, "method_signature": "void testPrint_bufferMethods()"}, "TestDateTimeFormatter.testPrint_builderMethods": {"callee_method_ids": [852, 852], "callee_method_names": ["DateTimeFormatter.printTo", "StringBuilder.toString", "DateTimeFormatter.printTo", "DateTime.getMillis", "StringBuilder.toString", "DateTime.toYearMonthDay", "StringBuilder.toString"], "method_name": "TestDateTimeFormatter.testPrint_builderMethods", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    StringBuilder buf = new StringBuilder();\n    f.printTo(buf, dt);\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", buf.toString());\n    buf = new StringBuilder();\n    f.printTo(buf, dt.getMillis());\n    assertEquals(\"Wed 2004-06-09T11:20:30+01:00\", buf.toString());\n    buf = new StringBuilder();\n    ISODateTimeFormat.yearMonthDay().printTo(buf, dt.toYearMonthDay());\n    assertEquals(\"2004-06-09\", buf.toString());\n    buf = new StringBuilder();\n    try {\n        ISODateTimeFormat.yearMonthDay().printTo(buf, (ReadablePartial) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2261, "method_signature": "void testPrint_builderMethods()"}, "TestDateTimeFormatter.testPrint_chrono": {"callee_method_ids": [842, 842, 842, 842, 842, 842, 842], "callee_method_names": ["DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTime.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology"], "method_name": "TestDateTimeFormatter.testPrint_chrono", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).print(dt));\n    assertEquals(\"Wed 2547-06-09T12:20:30+02:00\", f.withChronology(BUDDHIST_PARIS).print(dt));\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withChronology(null).print(dt));\n    dt = dt.withChronology(BUDDHIST_PARIS);\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).print(dt));\n    assertEquals(\"Wed 2547-06-09T12:20:30+02:00\", f.withChronology(BUDDHIST_PARIS).print(dt));\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withChronology(ISO_UTC).print(dt));\n    assertEquals(\"Wed 2547-06-09T12:20:30+02:00\", f.withChronology(null).print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2259, "method_signature": "void testPrint_chrono()"}, "TestDateTimeFormatter.testPrint_chrono_and_zone": {"callee_method_ids": [842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842, 842], "callee_method_names": ["DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTime.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTime.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology", "DateTimeFormatter.withChronology"], "method_name": "TestDateTimeFormatter.testPrint_chrono_and_zone", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withChronology(null).withZone(null).print(dt));\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).withZone(null).print(dt));\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).withZone(PARIS).print(dt));\n    assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt));\n    assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withChronology(null).withZone(NEWYORK).print(dt));\n    dt = dt.withChronology(ISO_PARIS);\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(null).withZone(null).print(dt));\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).withZone(null).print(dt));\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).withZone(PARIS).print(dt));\n    assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt));\n    assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withChronology(null).withZone(NEWYORK).print(dt));\n    dt = dt.withChronology(BUDDHIST_PARIS);\n    assertEquals(\"Wed 2547-06-09T12:20:30+02:00\", f.withChronology(null).withZone(null).print(dt));\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).withZone(null).print(dt));\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withChronology(ISO_PARIS).withZone(PARIS).print(dt));\n    assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withChronology(ISO_PARIS).withZone(NEWYORK).print(dt));\n    assertEquals(\"Wed 2547-06-09T06:20:30-04:00\", f.withChronology(null).withZone(NEWYORK).print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2264, "method_signature": "void testPrint_chrono_and_zone()"}, "TestDateTimeFormatter.testPrint_locale": {"callee_method_ids": [840, 840], "callee_method_names": ["DateTimeFormatter.withLocale", "DateTimeFormatter.withLocale"], "method_name": "TestDateTimeFormatter.testPrint_locale", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"mer. 2004-06-09T10:20:30Z\", f.withLocale(Locale.FRENCH).print(dt));\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withLocale(null).print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2257, "method_signature": "void testPrint_locale()"}, "TestDateTimeFormatter.testPrint_simple": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "DateTime.withZone", "DateTimeFormatter.print", "DateTime.withZone", "DateTimeFormatter.print", "DateTime.withChronology", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormatter.testPrint_simple", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.print(dt));\n    dt = dt.withZone(PARIS);\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.print(dt));\n    dt = dt.withChronology(BUDDHIST_PARIS);\n    assertEquals(\"Wed 2547-06-09T12:20:30+02:00\", f.print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2256, "method_signature": "void testPrint_simple()"}, "TestDateTimeFormatter.testPrint_writerMethods": {"callee_method_ids": [852, 852], "callee_method_names": ["DateTimeFormatter.printTo", "CharArrayWriter.toString", "DateTimeFormatter.printTo", "DateTime.getMillis", "CharArrayWriter.toString", "DateTime.toYearMonthDay", "CharArrayWriter.toString"], "method_name": "TestDateTimeFormatter.testPrint_writerMethods", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    CharArrayWriter out = new CharArrayWriter();\n    f.printTo(out, dt);\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", out.toString());\n    out = new CharArrayWriter();\n    f.printTo(out, dt.getMillis());\n    assertEquals(\"Wed 2004-06-09T11:20:30+01:00\", out.toString());\n    out = new CharArrayWriter();\n    ISODateTimeFormat.yearMonthDay().printTo(out, dt.toYearMonthDay());\n    assertEquals(\"2004-06-09\", out.toString());\n    out = new CharArrayWriter();\n    try {\n        ISODateTimeFormat.yearMonthDay().printTo(out, (ReadablePartial) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2262, "method_signature": "void testPrint_writerMethods()"}, "TestDateTimeFormatter.testPrint_zone": {"callee_method_ids": [843, 843, 843, 843, 843, 843], "callee_method_names": ["DateTimeFormatter.withZone", "DateTimeFormatter.withZone", "DateTimeFormatter.withZone", "DateTime.withZone", "DateTimeFormatter.withZone", "DateTimeFormatter.withZone", "DateTimeFormatter.withZoneUTC", "DateTimeFormatter.withZone"], "method_name": "TestDateTimeFormatter.testPrint_zone", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withZone(NEWYORK).print(dt));\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withZone(PARIS).print(dt));\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withZone(null).print(dt));\n    dt = dt.withZone(NEWYORK);\n    assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withZone(NEWYORK).print(dt));\n    assertEquals(\"Wed 2004-06-09T12:20:30+02:00\", f.withZone(PARIS).print(dt));\n    assertEquals(\"Wed 2004-06-09T10:20:30Z\", f.withZoneUTC().print(dt));\n    assertEquals(\"Wed 2004-06-09T06:20:30-04:00\", f.withZone(null).print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2258, "method_signature": "void testPrint_zone()"}, "TestDateTimeFormatter.testZoneNameNearTransition": {"callee_method_ids": [855, 855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormatter.testZoneNameNearTransition", "method_implementation": "{\n    DateTime inDST_1 = new DateTime(2005, 10, 30, 1, 0, 0, 0, NEWYORK);\n    DateTime inDST_2 = new DateTime(2005, 10, 30, 1, 59, 59, 999, NEWYORK);\n    DateTime onDST = new DateTime(2005, 10, 30, 2, 0, 0, 0, NEWYORK);\n    DateTime outDST = new DateTime(2005, 10, 30, 2, 0, 0, 1, NEWYORK);\n    DateTime outDST_2 = new DateTime(2005, 10, 30, 2, 0, 1, 0, NEWYORK);\n    DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyy-MM-dd HH:mm:ss.S zzzz\");\n    assertEquals(\"2005-10-30 01:00:00.0 Eastern Daylight Time\", fmt.print(inDST_1));\n    assertEquals(\"2005-10-30 01:59:59.9 Eastern Daylight Time\", fmt.print(inDST_2));\n    assertEquals(\"2005-10-30 02:00:00.0 Eastern Standard Time\", fmt.print(onDST));\n    assertEquals(\"2005-10-30 02:00:00.0 Eastern Standard Time\", fmt.print(outDST));\n    assertEquals(\"2005-10-30 02:00:01.0 Eastern Standard Time\", fmt.print(outDST_2));\n}", "repo_id": "7", "comment": "// Ensure time zone name switches properly at the zone DST transition.\n", "repo_name": "joda-time-main/", "id": 2271, "method_signature": "void testZoneNameNearTransition()"}, "TestDateTimeFormatter.testZoneShortNameNearTransition": {"callee_method_ids": [855, 855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormatter.testZoneShortNameNearTransition", "method_implementation": "{\n    DateTime inDST_1 = new DateTime(2005, 10, 30, 1, 0, 0, 0, NEWYORK);\n    DateTime inDST_2 = new DateTime(2005, 10, 30, 1, 59, 59, 999, NEWYORK);\n    DateTime onDST = new DateTime(2005, 10, 30, 2, 0, 0, 0, NEWYORK);\n    DateTime outDST = new DateTime(2005, 10, 30, 2, 0, 0, 1, NEWYORK);\n    DateTime outDST_2 = new DateTime(2005, 10, 30, 2, 0, 1, 0, NEWYORK);\n    DateTimeFormatter fmt = DateTimeFormat.forPattern(\"yyy-MM-dd HH:mm:ss.S z\").withLocale(Locale.ENGLISH);\n    assertEquals(\"2005-10-30 01:00:00.0 EDT\", fmt.print(inDST_1));\n    assertEquals(\"2005-10-30 01:59:59.9 EDT\", fmt.print(inDST_2));\n    assertEquals(\"2005-10-30 02:00:00.0 EST\", fmt.print(onDST));\n    assertEquals(\"2005-10-30 02:00:00.0 EST\", fmt.print(outDST));\n    assertEquals(\"2005-10-30 02:00:01.0 EST\", fmt.print(outDST_2));\n}", "repo_id": "7", "comment": "// Ensure time zone name switches properly at the zone DST transition.\n", "repo_name": "joda-time-main/", "id": 2272, "method_signature": "void testZoneShortNameNearTransition()"}, "TestDateTimeFormatterBuilder.test_appendFixedDecimal": {"callee_method_ids": [922, 911, 855, 855, 855, 855, 855, 855, 860, 860, 860, 860, 922, 920, 922, 920, 922, 911, 855, 860, 860, 860], "callee_method_names": ["DateTimeFormatterBuilder.appendFixedDecimal", "DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime", "DateTimeFormatterBuilder.appendFixedDecimal", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendFixedDecimal", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendFixedDecimal", "DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.print", "DateTimeFormatter.parseDateTime", "DateTime.getHourOfDay", "DateTime.getMinuteOfHour", "DateTime.getSecondOfMinute", "DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormatterBuilder.test_appendFixedDecimal", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    bld.appendFixedDecimal(DateTimeFieldType.year(), 4);\n    DateTimeFormatter f = bld.toFormatter();\n    assertEquals(\"2007\", f.print(new DateTime(\"2007-01-01\")));\n    assertEquals(\"0123\", f.print(new DateTime(\"123-01-01\")));\n    assertEquals(\"0001\", f.print(new DateTime(\"1-2-3\")));\n    assertEquals(\"99999\", f.print(new DateTime(\"99999-2-3\")));\n    assertEquals(\"-0099\", f.print(new DateTime(\"-99-2-3\")));\n    assertEquals(\"0000\", f.print(new DateTime(\"0-2-3\")));\n    assertEquals(2001, f.parseDateTime(\"2001\").getYear());\n    try {\n        f.parseDateTime(\"-2001\");\n        fail();\n    } catch (IllegalArgumentException e) {\n    }\n    try {\n        f.parseDateTime(\"200\");\n        fail();\n    } catch (IllegalArgumentException e) {\n    }\n    try {\n        f.parseDateTime(\"20016\");\n        fail();\n    } catch (IllegalArgumentException e) {\n    }\n    bld = new DateTimeFormatterBuilder();\n    bld.appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2);\n    bld.appendLiteral(':');\n    bld.appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2);\n    bld.appendLiteral(':');\n    bld.appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2);\n    f = bld.toFormatter();\n    assertEquals(\"01:02:34\", f.print(new DateTime(\"T1:2:34\")));\n    DateTime dt = f.parseDateTime(\"01:02:34\");\n    assertEquals(1, dt.getHourOfDay());\n    assertEquals(2, dt.getMinuteOfHour());\n    assertEquals(34, dt.getSecondOfMinute());\n    try {\n        f.parseDateTime(\"0145:02:34\");\n        fail();\n    } catch (IllegalArgumentException e) {\n    }\n    try {\n        f.parseDateTime(\"01:0:34\");\n        fail();\n    } catch (IllegalArgumentException e) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2326, "method_signature": "void test_appendFixedDecimal()"}, "TestDateTimeFormatterBuilder.test_appendFixedSignedDecimal": {"callee_method_ids": [924, 911, 855, 855, 855, 855, 855, 855, 860, 860, 860, 860], "callee_method_names": ["DateTimeFormatterBuilder.appendFixedSignedDecimal", "DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormatterBuilder.test_appendFixedSignedDecimal", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    bld.appendFixedSignedDecimal(DateTimeFieldType.year(), 4);\n    DateTimeFormatter f = bld.toFormatter();\n    assertEquals(\"2007\", f.print(new DateTime(\"2007-01-01\")));\n    assertEquals(\"0123\", f.print(new DateTime(\"123-01-01\")));\n    assertEquals(\"0001\", f.print(new DateTime(\"1-2-3\")));\n    assertEquals(\"99999\", f.print(new DateTime(\"99999-2-3\")));\n    assertEquals(\"-0099\", f.print(new DateTime(\"-99-2-3\")));\n    assertEquals(\"0000\", f.print(new DateTime(\"0-2-3\")));\n    assertEquals(2001, f.parseDateTime(\"2001\").getYear());\n    assertEquals(-2001, f.parseDateTime(\"-2001\").getYear());\n    assertEquals(2001, f.parseDateTime(\"+2001\").getYear());\n    try {\n        f.parseDateTime(\"20016\");\n        fail();\n    } catch (IllegalArgumentException e) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2327, "method_signature": "void test_appendFixedSignedDecimal()"}, "TestDateTimeFormatterBuilder.test_appendOptional_Parser": {"callee_method_ids": [920, 913, 920, 917, 920, 911], "callee_method_names": ["DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toParser", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.appendOptional", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.isPrinter", "DateTimeFormatter.isParser", "DateTimeFormatter.withZoneUTC"], "method_name": "TestDateTimeFormatterBuilder.test_appendOptional_Parser", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    bld.appendLiteral('Y');\n    DateTimeParser p = bld.toParser();\n    DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder();\n    bld2.appendLiteral('X');\n    bld2.appendOptional(p);\n    bld2.appendLiteral('Z');\n    DateTimeFormatter f = bld2.toFormatter();\n    assertEquals(false, f.isPrinter());\n    assertEquals(true, f.isParser());\n    assertEquals(0, f.withZoneUTC().parseMillis(\"XYZ\"));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2325, "method_signature": "void test_appendOptional_Parser()"}, "TestDateTimeFormatterBuilder.test_appendTimeZoneId": {"callee_method_ids": [911, 855, 860, 860], "callee_method_names": ["DateTimeFormatterBuilder.appendTimeZoneId", "DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.print", "DateTimeFormatter.parseDateTime", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormatterBuilder.test_appendTimeZoneId", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    bld.appendTimeZoneId();\n    DateTimeFormatter f = bld.toFormatter();\n    assertEquals(\"Asia/Tokyo\", f.print(new DateTime(2007, 3, 4, 0, 0, 0, TOKYO)));\n    assertEquals(TOKYO, f.parseDateTime(\"Asia/Tokyo\").getZone());\n    try {\n        f.parseDateTime(\"Nonsense\");\n        fail();\n    } catch (IllegalArgumentException e) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2329, "method_signature": "void test_appendTimeZoneId()"}, "TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_parse": {"callee_method_ids": [929, 911, 841, 841, 841, 841], "callee_method_names": ["DateTimeFormatterBuilder.appendTimeZoneOffset", "DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.withOffsetParsed", "DateTimeFormatter.withOffsetParsed", "DateTimeFormatter.withOffsetParsed", "DateTimeFormatter.withOffsetParsed"], "method_name": "TestDateTimeFormatterBuilder.test_appendTimeZoneOffset_parse", "method_implementation": "{\n    for (int i = 1; i <= 4; i++) {\n        for (int j = i; j <= 4; j++) {\n            DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n            bld.appendTimeZoneOffset(\"Z\", true, i, j);\n            DateTimeFormatter f = bld.toFormatter();\n            // parse\n            assertEquals(OFFSET_0200, f.withOffsetParsed().parseDateTime(\"+02\").getZone());\n            assertEquals(OFFSET_0200, f.withOffsetParsed().parseDateTime(\"+02:00\").getZone());\n            assertEquals(OFFSET_0200, f.withOffsetParsed().parseDateTime(\"+02:00:00\").getZone());\n            assertEquals(OFFSET_0200, f.withOffsetParsed().parseDateTime(\"+02:00:00.000\").getZone());\n        }\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2328, "method_signature": "void test_appendTimeZoneOffset_parse()"}, "TestDateTimeFormatterBuilder.test_append_Formatter": {"callee_method_ids": [920, 911, 920, 916, 920, 911], "callee_method_names": ["DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toFormatter", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.append", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toFormatter"], "method_name": "TestDateTimeFormatterBuilder.test_append_Formatter", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    bld.appendLiteral('Y');\n    DateTimeFormatter f = bld.toFormatter();\n    DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder();\n    bld2.appendLiteral('X');\n    bld2.append(f);\n    bld2.appendLiteral('Z');\n    assertEquals(\"XYZ\", bld2.toFormatter().print(0L));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2321, "method_signature": "void test_append_Formatter()"}, "TestDateTimeFormatterBuilder.test_append_Parser": {"callee_method_ids": [920, 913, 920, 916, 920, 911], "callee_method_names": ["DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toParser", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.append", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.isPrinter", "DateTimeFormatter.isParser", "DateTimeFormatter.withZoneUTC"], "method_name": "TestDateTimeFormatterBuilder.test_append_Parser", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    bld.appendLiteral('Y');\n    DateTimeParser p = bld.toParser();\n    DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder();\n    bld2.appendLiteral('X');\n    bld2.append(p);\n    bld2.appendLiteral('Z');\n    DateTimeFormatter f = bld2.toFormatter();\n    assertEquals(false, f.isPrinter());\n    assertEquals(true, f.isParser());\n    assertEquals(0, f.withZoneUTC().parseMillis(\"XYZ\"));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2323, "method_signature": "void test_append_Parser()"}, "TestDateTimeFormatterBuilder.test_append_Printer": {"callee_method_ids": [920, 912, 920, 916, 920, 911, 855], "callee_method_names": ["DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toPrinter", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.append", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.isPrinter", "DateTimeFormatter.isParser", "DateTimeFormatter.print"], "method_name": "TestDateTimeFormatterBuilder.test_append_Printer", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    bld.appendLiteral('Y');\n    DateTimePrinter p = bld.toPrinter();\n    DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder();\n    bld2.appendLiteral('X');\n    bld2.append(p);\n    bld2.appendLiteral('Z');\n    DateTimeFormatter f = bld2.toFormatter();\n    assertEquals(true, f.isPrinter());\n    assertEquals(false, f.isParser());\n    assertEquals(\"XYZ\", f.print(0L));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2322, "method_signature": "void test_append_Printer()"}, "TestDateTimeFormatterBuilder.test_append_Printer_nullParser": {"callee_method_ids": [920, 912, 916], "callee_method_names": ["DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toPrinter", "DateTimeFormatterBuilder.append"], "method_name": "TestDateTimeFormatterBuilder.test_append_Printer_nullParser", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    bld.appendLiteral('Y');\n    DateTimePrinter p = bld.toPrinter();\n    try {\n        DateTimeFormatterBuilder bld2 = new DateTimeFormatterBuilder();\n        bld2.append(p, (DateTimeParser) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2324, "method_signature": "void test_append_Printer_nullParser()"}, "TestDateTimeFormatterBuilder.test_canBuildFormatter": {"callee_method_ids": [920], "callee_method_names": ["DateTimeFormatterBuilder.canBuildFormatter", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.canBuildFormatter"], "method_name": "TestDateTimeFormatterBuilder.test_canBuildFormatter", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    assertEquals(false, bld.canBuildFormatter());\n    bld.appendLiteral('X');\n    assertEquals(true, bld.canBuildFormatter());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2320, "method_signature": "void test_canBuildFormatter()"}, "TestDateTimeFormatterBuilder.test_localPrintParseZoneTokyo": {"callee_method_ids": [911, 855, 859], "callee_method_names": ["DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.print", "DateTimeFormatter.parseLocalDateTime"], "method_name": "TestDateTimeFormatterBuilder.test_localPrintParseZoneTokyo", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder().appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n    DateTimeFormatter f = bld.toFormatter();\n    DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, TOKYO);\n    assertEquals(\"2007-03-04 12:30 Asia/Tokyo\", f.print(dt));\n    LocalDateTime expected = new LocalDateTime(2007, 3, 4, 12, 30);\n    assertEquals(expected, f.parseLocalDateTime(\"2007-03-04 12:30 Asia/Tokyo\"));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2330, "method_signature": "void test_localPrintParseZoneTokyo()"}, "TestDateTimeFormatterBuilder.test_printParseLongName": {"callee_method_ids": [911, 855, 855, 860], "callee_method_names": ["DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.isPrinter", "DateTimeFormatter.isParser", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormatterBuilder.test_printParseLongName", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder().appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneName();\n    DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n    assertEquals(true, f.isPrinter());\n    assertEquals(false, f.isParser());\n    DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n    assertEquals(\"2011-01-04 12:30 Greenwich Mean Time\", f.print(dt1));\n    DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n    assertEquals(\"2011-07-04 12:30 British Summer Time\", f.print(dt2));\n    try {\n        f.parseDateTime(\"2007-03-04 12:30 GMT\");\n        fail();\n    } catch (UnsupportedOperationException e) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2332, "method_signature": "void test_printParseLongName()"}, "TestDateTimeFormatterBuilder.test_printParseShortName": {"callee_method_ids": [911, 855, 855, 860], "callee_method_names": ["DateTimeFormatterBuilder.toFormatter", "DateTimeFormatter.isPrinter", "DateTimeFormatter.isParser", "DateTimeFormatter.print", "DateTimeFormatter.print", "DateTimeFormatter.parseDateTime"], "method_name": "TestDateTimeFormatterBuilder.test_printParseShortName", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder().appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneShortName();\n    DateTimeFormatter f = bld.toFormatter().withLocale(Locale.ENGLISH);\n    assertEquals(true, f.isPrinter());\n    assertEquals(false, f.isParser());\n    DateTime dt1 = new DateTime(2011, 1, 4, 12, 30, 0, LONDON);\n    assertEquals(\"2011-01-04 12:30 GMT\", f.print(dt1));\n    DateTime dt2 = new DateTime(2011, 7, 4, 12, 30, 0, LONDON);\n    assertEquals(\"2011-07-04 12:30 BST\", f.print(dt2));\n    try {\n        f.parseDateTime(\"2007-03-04 12:30 GMT\");\n        fail();\n    } catch (UnsupportedOperationException e) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2331, "method_signature": "void test_printParseShortName()"}, "TestDateTimeFormatterBuilder.test_toFormatter": {"callee_method_ids": [911, 920, 911], "callee_method_names": ["DateTimeFormatterBuilder.toFormatter", "DateTimeFormatterBuilder.appendLiteral", "DateTimeFormatterBuilder.toFormatter"], "method_name": "TestDateTimeFormatterBuilder.test_toFormatter", "method_implementation": "{\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    try {\n        bld.toFormatter();\n        fail();\n    } catch (UnsupportedOperationException ex) {\n    }\n    bld.appendLiteral('X');\n    assertNotNull(bld.toFormatter());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2319, "method_signature": "void test_toFormatter()"}, "TestDateTimeParserBucket.testConstructor_3arg": {"callee_method_names": ["DateTimeParserBucket.getChronology", "DateTimeParserBucket.getLocale", "DateTimeParserBucket.getPivotYear", "DateTimeParserBucket.getOffsetInteger", "DateTimeParserBucket.getZone"], "method_name": "TestDateTimeParserBucket.testConstructor_3arg", "method_implementation": "{\n    DateTimeParserBucket test = new DateTimeParserBucket(100, BUDDHIST_PARIS, LOCALE);\n    assertEquals(BUDDHIST_UTC, test.getChronology());\n    assertEquals(LOCALE, test.getLocale());\n    assertEquals(null, test.getPivotYear());\n    assertEquals(null, test.getOffsetInteger());\n    assertEquals(PARIS, test.getZone());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2211, "method_signature": "void testConstructor_3arg()"}, "TestDateTimeParserBucket.testReset": {"callee_method_ids": [803, 806, 802, 806], "callee_method_names": ["DateTimeParserBucket.getChronology", "DateTimeParserBucket.getLocale", "DateTimeParserBucket.getPivotYear", "DateTimeParserBucket.getOffsetInteger", "DateTimeParserBucket.getZone", "DateTimeParserBucket.setOffset", "DateTimeParserBucket.setZone", "DateTimeParserBucket.saveField", "DateTimeParserBucket.computeMillis", "DateTimeParserBucket.getOffsetInteger", "DateTimeParserBucket.getZone", "DateTimeParserBucket.reset", "DateTimeParserBucket.getChronology", "DateTimeParserBucket.getLocale", "DateTimeParserBucket.getPivotYear", "DateTimeParserBucket.getOffsetInteger", "DateTimeParserBucket.getZone", "DateTimeParserBucket.computeMillis"], "method_name": "TestDateTimeParserBucket.testReset", "method_implementation": "{\n    DateTimeParserBucket test = new DateTimeParserBucket(100, ISO_0400, LOCALE, 2000, 2000);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(LOCALE, test.getLocale());\n    assertEquals((Integer) 2000, test.getPivotYear());\n    assertEquals(null, test.getOffsetInteger());\n    assertEquals(ZONE_0400, test.getZone());\n    test.setOffset((Integer) 200);\n    test.setZone(LONDON);\n    test.saveField(DateTimeFieldType.hourOfDay(), 2);\n    assertEquals(2 * MILLIS_PER_HOUR + 100 - 200, test.computeMillis(false));\n    assertEquals((Integer) 200, test.getOffsetInteger());\n    assertEquals(LONDON, test.getZone());\n    test.reset();\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(LOCALE, test.getLocale());\n    assertEquals((Integer) 2000, test.getPivotYear());\n    assertEquals(null, test.getOffsetInteger());\n    assertEquals(ZONE_0400, test.getZone());\n    assertEquals(100 - OFFSET_0400, test.computeMillis(false));\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2212, "method_signature": "void testReset()"}, "TestDateTimeUtils.testClass": {"callee_method_names": ["Class<?>.getModifiers", "Class<?>.getModifiers", "Class<?>.getDeclaredConstructors", "Class<?>.getDeclaredConstructors"], "method_name": "TestDateTimeUtils.testClass", "method_implementation": "{\n    Class<?> cls = DateTimeUtils.class;\n    assertEquals(true, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isFinal(cls.getModifiers()));\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(cls.getDeclaredConstructors()[0].getModifiers()));\n    new DateTimeUtils() {\n    };\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1759, "method_signature": "void testClass()"}, "TestDateTimeUtils.testFixedMillis": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testFixedMillis", "method_implementation": "{\n    try {\n        DateTimeUtils.setCurrentMillisFixed(0L);\n        assertEquals(0L, DateTimeUtils.currentTimeMillis());\n        assertEquals(0L, DateTimeUtils.currentTimeMillis());\n        assertEquals(0L, DateTimeUtils.currentTimeMillis());\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n    long nowSystem = System.currentTimeMillis();\n    long now = DateTimeUtils.currentTimeMillis();\n    assertTrue((now >= nowSystem));\n    assertTrue((now - nowSystem) < 10000L);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1762, "method_signature": "void testFixedMillis()"}, "TestDateTimeUtils.testFixedMillisSecurity": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testFixedMillisSecurity", "method_implementation": "{\n    if (OLD_JDK) {\n        return;\n    }\n    try {\n        try {\n            Policy.setPolicy(RESTRICT);\n            System.setSecurityManager(new SecurityManager());\n            DateTimeUtils.setCurrentMillisFixed(0L);\n            fail();\n        } catch (SecurityException ex) {\n            // ok\n        } finally {\n            System.setSecurityManager(null);\n            Policy.setPolicy(ALLOW);\n        }\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1763, "method_signature": "void testFixedMillisSecurity()"}, "TestDateTimeUtils.testGetDurationMillis_RI": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testGetDurationMillis_RI", "method_implementation": "{\n    Duration dur = new Duration(123L);\n    assertEquals(123L, DateTimeUtils.getDurationMillis(dur));\n    assertEquals(0L, DateTimeUtils.getDurationMillis(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1774, "method_signature": "void testGetDurationMillis_RI()"}, "TestDateTimeUtils.testGetInstantChronology_RI": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testGetInstantChronology_RI", "method_implementation": "{\n    DateTime dt = new DateTime(123L, BuddhistChronology.getInstance());\n    assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getInstantChronology(dt));\n    Instant i = new Instant(123L);\n    assertEquals(ISOChronology.getInstanceUTC(), DateTimeUtils.getInstantChronology(i));\n    AbstractInstant ai = new AbstractInstant() {\n\n        public long getMillis() {\n            return 0L;\n        }\n\n        public Chronology getChronology() {\n            // testing for this\n            return null;\n        }\n    };\n    assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(ai));\n    assertEquals(ISOChronology.getInstance(), DateTimeUtils.getInstantChronology(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1770, "method_signature": "void testGetInstantChronology_RI()"}, "TestDateTimeUtils.testGetInstantMillis_RI": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testGetInstantMillis_RI", "method_implementation": "{\n    Instant i = new Instant(123L);\n    assertEquals(123L, DateTimeUtils.getInstantMillis(i));\n    try {\n        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n        assertEquals(TEST_TIME_NOW, DateTimeUtils.getInstantMillis(null));\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1769, "method_signature": "void testGetInstantMillis_RI()"}, "TestDateTimeUtils.testGetIntervalChronology_RI_RI": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testGetIntervalChronology_RI_RI", "method_implementation": "{\n    DateTime dt1 = new DateTime(123L, BuddhistChronology.getInstance());\n    DateTime dt2 = new DateTime(123L, CopticChronology.getInstance());\n    assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getIntervalChronology(dt1, dt2));\n    assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getIntervalChronology(dt1, null));\n    assertEquals(CopticChronology.getInstance(), DateTimeUtils.getIntervalChronology(null, dt2));\n    assertEquals(ISOChronology.getInstance(), DateTimeUtils.getIntervalChronology(null, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1772, "method_signature": "void testGetIntervalChronology_RI_RI()"}, "TestDateTimeUtils.testGetIntervalChronology_RInterval": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testGetIntervalChronology_RInterval", "method_implementation": "{\n    Interval dt = new Interval(123L, 456L, BuddhistChronology.getInstance());\n    assertEquals(BuddhistChronology.getInstance(), DateTimeUtils.getIntervalChronology(dt));\n    assertEquals(ISOChronology.getInstance(), DateTimeUtils.getIntervalChronology(null));\n    MutableInterval ai = new MutableInterval() {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public Chronology getChronology() {\n            // testing for this\n            return null;\n        }\n    };\n    assertEquals(ISOChronology.getInstance(), DateTimeUtils.getIntervalChronology(ai));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1771, "method_signature": "void testGetIntervalChronology_RInterval()"}, "TestDateTimeUtils.testGetReadableInterval_ReadableInterval": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testGetReadableInterval_ReadableInterval", "method_implementation": "{\n    ReadableInterval input = new Interval(0, 100L);\n    assertEquals(input, DateTimeUtils.getReadableInterval(input));\n    try {\n        DateTimeUtils.setCurrentMillisFixed(TEST_TIME_NOW);\n        assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME_NOW), DateTimeUtils.getReadableInterval(null));\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1773, "method_signature": "void testGetReadableInterval_ReadableInterval()"}, "TestDateTimeUtils.testIsContiguous_RP": {"callee_method_ids": [129], "callee_method_names": ["Partial.with"], "method_name": "TestDateTimeUtils.testIsContiguous_RP", "method_implementation": "{\n    YearMonthDay ymd = new YearMonthDay(2005, 6, 9);\n    assertEquals(true, DateTimeUtils.isContiguous(ymd));\n    TimeOfDay tod = new TimeOfDay(12, 20, 30, 0);\n    assertEquals(true, DateTimeUtils.isContiguous(tod));\n    Partial year = new Partial(DateTimeFieldType.year(), 2005);\n    assertEquals(true, DateTimeUtils.isContiguous(year));\n    Partial hourOfDay = new Partial(DateTimeFieldType.hourOfDay(), 12);\n    assertEquals(true, DateTimeUtils.isContiguous(hourOfDay));\n    Partial yearHour = year.with(DateTimeFieldType.hourOfDay(), 12);\n    assertEquals(false, DateTimeUtils.isContiguous(yearHour));\n    Partial ymdd = new Partial(ymd).with(DateTimeFieldType.dayOfWeek(), 2);\n    assertEquals(false, DateTimeUtils.isContiguous(ymdd));\n    Partial dd = new Partial(DateTimeFieldType.dayOfMonth(), 13).with(DateTimeFieldType.dayOfWeek(), 5);\n    assertEquals(false, DateTimeUtils.isContiguous(dd));\n    try {\n        DateTimeUtils.isContiguous((ReadablePartial) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1775, "method_signature": "void testIsContiguous_RP()"}, "TestDateTimeUtils.testIsContiguous_RP_GJChronology": {"callee_method_ids": [129], "callee_method_names": ["Partial.with"], "method_name": "TestDateTimeUtils.testIsContiguous_RP_GJChronology", "method_implementation": "{\n    YearMonthDay ymd = new YearMonthDay(2005, 6, 9, GJ);\n    assertEquals(true, DateTimeUtils.isContiguous(ymd));\n    TimeOfDay tod = new TimeOfDay(12, 20, 30, 0, GJ);\n    assertEquals(true, DateTimeUtils.isContiguous(tod));\n    Partial year = new Partial(DateTimeFieldType.year(), 2005, GJ);\n    assertEquals(true, DateTimeUtils.isContiguous(year));\n    Partial hourOfDay = new Partial(DateTimeFieldType.hourOfDay(), 12, GJ);\n    assertEquals(true, DateTimeUtils.isContiguous(hourOfDay));\n    Partial yearHour = year.with(DateTimeFieldType.hourOfDay(), 12);\n    assertEquals(false, DateTimeUtils.isContiguous(yearHour));\n    Partial ymdd = new Partial(ymd).with(DateTimeFieldType.dayOfWeek(), 2);\n    assertEquals(false, DateTimeUtils.isContiguous(ymdd));\n    Partial dd = new Partial(DateTimeFieldType.dayOfMonth(), 13).with(DateTimeFieldType.dayOfWeek(), 5);\n    assertEquals(false, DateTimeUtils.isContiguous(dd));\n    try {\n        DateTimeUtils.isContiguous((ReadablePartial) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1776, "method_signature": "void testIsContiguous_RP_GJChronology()"}, "TestDateTimeUtils.testMillisProvider": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testMillisProvider", "method_implementation": "{\n    try {\n        DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {\n\n            public long getMillis() {\n                return 1L;\n            }\n        });\n        assertEquals(1L, DateTimeUtils.currentTimeMillis());\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1767, "method_signature": "void testMillisProvider()"}, "TestDateTimeUtils.testMillisProviderSecurity": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testMillisProviderSecurity", "method_implementation": "{\n    if (OLD_JDK) {\n        return;\n    }\n    try {\n        try {\n            Policy.setPolicy(RESTRICT);\n            System.setSecurityManager(new SecurityManager());\n            DateTimeUtils.setCurrentMillisProvider(new MillisProvider() {\n\n                public long getMillis() {\n                    return 0L;\n                }\n            });\n            fail();\n        } catch (SecurityException ex) {\n            // ok\n        } finally {\n            System.setSecurityManager(null);\n            Policy.setPolicy(ALLOW);\n        }\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1768, "method_signature": "void testMillisProviderSecurity()"}, "TestDateTimeUtils.testOffsetMillis": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testOffsetMillis", "method_implementation": "{\n    try {\n        // set time to one day ago\n        DateTimeUtils.setCurrentMillisOffset(-24 * 60 * 60 * 1000);\n        long nowSystem = System.currentTimeMillis();\n        long now = DateTimeUtils.currentTimeMillis();\n        long nowAdjustDay = now + (24 * 60 * 60 * 1000);\n        assertTrue((now < nowSystem));\n        assertTrue((nowAdjustDay >= nowSystem));\n        assertTrue((nowAdjustDay - nowSystem) < 10000L);\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n    long nowSystem = System.currentTimeMillis();\n    long now = DateTimeUtils.currentTimeMillis();\n    assertTrue((now >= nowSystem));\n    assertTrue((now - nowSystem) < 10000L);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1764, "method_signature": "void testOffsetMillis()"}, "TestDateTimeUtils.testOffsetMillisSecurity": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testOffsetMillisSecurity", "method_implementation": "{\n    if (OLD_JDK) {\n        return;\n    }\n    try {\n        try {\n            Policy.setPolicy(RESTRICT);\n            System.setSecurityManager(new SecurityManager());\n            DateTimeUtils.setCurrentMillisOffset(-24 * 60 * 60 * 1000);\n            fail();\n        } catch (SecurityException ex) {\n            // ok\n        } finally {\n            System.setSecurityManager(null);\n            Policy.setPolicy(ALLOW);\n        }\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1766, "method_signature": "void testOffsetMillisSecurity()"}, "TestDateTimeUtils.testOffsetMillisToZero": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testOffsetMillisToZero", "method_implementation": "{\n    long now1 = 0L;\n    try {\n        // set time to one day ago\n        DateTimeUtils.setCurrentMillisOffset(0);\n        now1 = DateTimeUtils.currentTimeMillis();\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n    long now2 = DateTimeUtils.currentTimeMillis();\n    assertEquals(Math.abs(now1 - now2) < 100, true);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1765, "method_signature": "void testOffsetMillisToZero()"}, "TestDateTimeUtils.testSystemMillis": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testSystemMillis", "method_implementation": "{\n    long nowSystem = System.currentTimeMillis();\n    long now = DateTimeUtils.currentTimeMillis();\n    assertTrue((now >= nowSystem));\n    assertTrue((now - nowSystem) < 10000L);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1760, "method_signature": "void testSystemMillis()"}, "TestDateTimeUtils.testSystemMillisSecurity": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testSystemMillisSecurity", "method_implementation": "{\n    if (OLD_JDK) {\n        return;\n    }\n    try {\n        try {\n            Policy.setPolicy(RESTRICT);\n            System.setSecurityManager(new SecurityManager());\n            DateTimeUtils.setCurrentMillisSystem();\n            fail();\n        } catch (SecurityException ex) {\n            // ok\n        } finally {\n            System.setSecurityManager(null);\n            Policy.setPolicy(ALLOW);\n        }\n    } finally {\n        DateTimeUtils.setCurrentMillisSystem();\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1761, "method_signature": "void testSystemMillisSecurity()"}, "TestDateTimeUtils.testTest": {"callee_method_names": [], "method_name": "TestDateTimeUtils.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1758, "method_signature": "void testTest()"}, "TestDateTimeUtils.test_julianDay": {"callee_method_ids": [443, 443, 443, 443], "callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.plusHours", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.plusHours", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.plusHours", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.plusHours", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis"], "method_name": "TestDateTimeUtils.test_julianDay", "method_implementation": "{\n    DateTime base = new DateTime(1970, 1, 1, 0, 0, DateTimeZone.UTC);\n    assertEquals(2440587.5d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d);\n    assertEquals(2440588, DateTimeUtils.toJulianDayNumber(base.getMillis()));\n    assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440587.5d));\n    base = base.plusHours(6);\n    assertEquals(2440587.75d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d);\n    assertEquals(2440588, DateTimeUtils.toJulianDayNumber(base.getMillis()));\n    assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440587.75d));\n    base = base.plusHours(6);\n    assertEquals(2440588d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d);\n    assertEquals(2440588, DateTimeUtils.toJulianDayNumber(base.getMillis()));\n    assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440588d));\n    base = base.plusHours(6);\n    assertEquals(2440588.25d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d);\n    assertEquals(2440588, DateTimeUtils.toJulianDayNumber(base.getMillis()));\n    assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440588.25d));\n    base = base.plusHours(6);\n    assertEquals(2440588.5d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d);\n    assertEquals(2440589, DateTimeUtils.toJulianDayNumber(base.getMillis()));\n    assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(2440588.5d));\n    base = new DateTime(2012, 8, 31, 23, 50, DateTimeZone.UTC);\n    assertEquals(2456171.4930555555, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d);\n    assertEquals(2456171, DateTimeUtils.toJulianDayNumber(base.getMillis()));\n    base = new DateTime(-4713, 1, 1, 12, 0, JulianChronology.getInstanceUTC());\n    assertEquals(0d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d);\n    assertEquals(0, DateTimeUtils.toJulianDayNumber(base.getMillis()));\n    assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(0d));\n    base = new DateTime(-4713, 1, 1, 0, 0, JulianChronology.getInstanceUTC());\n    assertEquals(-0.5d, DateTimeUtils.toJulianDay(base.getMillis()), 0.0001d);\n    assertEquals(0, DateTimeUtils.toJulianDayNumber(base.getMillis()));\n    assertEquals(base.getMillis(), DateTimeUtils.fromJulianDay(-0.5d));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1777, "method_signature": "void test_julianDay()"}, "TestDateTimeZone.testConstructor": {"callee_method_names": [], "method_name": "TestDateTimeZone.testConstructor", "method_implementation": "{\n    assertEquals(1, DateTimeZone.class.getDeclaredConstructors().length);\n    assertTrue(Modifier.isProtected(DateTimeZone.class.getDeclaredConstructors()[0].getModifiers()));\n    try {\n        new DateTimeZone(null) {\n\n            @Override\n            public String getNameKey(long instant) {\n                return null;\n            }\n\n            @Override\n            public int getOffset(long instant) {\n                return 0;\n            }\n\n            @Override\n            public int getStandardOffset(long instant) {\n                return 0;\n            }\n\n            @Override\n            public boolean isFixed() {\n                return false;\n            }\n\n            @Override\n            public long nextTransition(long instant) {\n                return 0;\n            }\n\n            @Override\n            public long previousTransition(long instant) {\n                return 0;\n            }\n\n            @Override\n            public boolean equals(Object object) {\n                return false;\n            }\n        };\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1581, "method_signature": "void testConstructor()"}, "TestDateTimeZone.testDefault": {"callee_method_names": [], "method_name": "TestDateTimeZone.testDefault", "method_implementation": "{\n    assertNotNull(DateTimeZone.getDefault());\n    DateTimeZone.setDefault(PARIS);\n    assertSame(PARIS, DateTimeZone.getDefault());\n    try {\n        DateTimeZone.setDefault(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1573, "method_signature": "void testDefault()"}, "TestDateTimeZone.testDublin": {"callee_method_ids": [114, 113, 440, 114, 113], "callee_method_names": ["DateTimeZone.getStandardOffset", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTimeZone.isStandardOffset", "DateTime.getMillis", "DateTimeZone.getName", "DateTime.getMillis", "DateTimeZone.getNameKey", "DateTime.getMillis", "DateTime.plusMonths", "DateTimeZone.getStandardOffset", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTimeZone.isStandardOffset", "DateTime.getMillis", "DateTimeZone.getName", "DateTime.getMillis", "DateTimeZone.getNameKey", "DateTime.getMillis"], "method_name": "TestDateTimeZone.testDublin", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/Dublin\");\n    DateTime winter = new DateTime(2018, 1, 1, 0, 0, 0, 0, zone);\n    assertEquals(0, zone.getStandardOffset(winter.getMillis()));\n    assertEquals(0, zone.getOffset(winter.getMillis()));\n    assertEquals(true, zone.isStandardOffset(winter.getMillis()));\n    assertEquals(\"Greenwich Mean Time\", zone.getName(winter.getMillis()));\n    assertEquals(\"GMT\", zone.getNameKey(winter.getMillis()));\n    DateTime summer = winter.plusMonths(6);\n    assertEquals(0, zone.getStandardOffset(summer.getMillis()));\n    assertEquals(3600000, zone.getOffset(summer.getMillis()));\n    assertEquals(false, zone.isStandardOffset(summer.getMillis()));\n    assertEquals(true, zone.getName(summer.getMillis()).startsWith(\"Irish \"));\n    assertEquals(\"IST\", zone.getNameKey(summer.getMillis()));\n}", "repo_id": "7", "comment": "// rule with negative SAVE value\n", "repo_name": "joda-time-main/", "id": 1591, "method_signature": "void testDublin()"}, "TestDateTimeZone.testEqualsHashCode": {"callee_method_names": ["DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.hashCode", "DateTimeZone.hashCode", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.hashCode", "DateTimeZone.hashCode", "DateTimeZone.hashCode", "DateTimeZone.hashCode", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.hashCode", "DateTimeZone.hashCode", "DateTimeZone.hashCode", "DateTimeZone.hashCode", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.equals", "DateTimeZone.hashCode", "DateTimeZone.hashCode", "DateTimeZone.hashCode", "DateTimeZone.hashCode"], "method_name": "TestDateTimeZone.testEqualsHashCode", "method_implementation": "{\n    DateTimeZone zone1 = DateTimeZone.forID(\"Europe/Paris\");\n    DateTimeZone zone2 = DateTimeZone.forID(\"Europe/Paris\");\n    assertEquals(true, zone1.equals(zone1));\n    assertEquals(true, zone1.equals(zone2));\n    assertEquals(true, zone2.equals(zone1));\n    assertEquals(true, zone2.equals(zone2));\n    assertEquals(true, zone1.hashCode() == zone2.hashCode());\n    DateTimeZone zone3 = DateTimeZone.forID(\"Europe/London\");\n    assertEquals(true, zone3.equals(zone3));\n    assertEquals(false, zone1.equals(zone3));\n    assertEquals(false, zone2.equals(zone3));\n    assertEquals(false, zone3.equals(zone1));\n    assertEquals(false, zone3.equals(zone2));\n    assertEquals(false, zone1.hashCode() == zone3.hashCode());\n    assertEquals(true, zone3.hashCode() == zone3.hashCode());\n    DateTimeZone zone4 = DateTimeZone.forID(\"+01:00\");\n    assertEquals(true, zone4.equals(zone4));\n    assertEquals(false, zone1.equals(zone4));\n    assertEquals(false, zone2.equals(zone4));\n    assertEquals(false, zone3.equals(zone4));\n    assertEquals(false, zone4.equals(zone1));\n    assertEquals(false, zone4.equals(zone2));\n    assertEquals(false, zone4.equals(zone3));\n    assertEquals(false, zone1.hashCode() == zone4.hashCode());\n    assertEquals(true, zone4.hashCode() == zone4.hashCode());\n    DateTimeZone zone5 = DateTimeZone.forID(\"+02:00\");\n    assertEquals(true, zone5.equals(zone5));\n    assertEquals(false, zone1.equals(zone5));\n    assertEquals(false, zone2.equals(zone5));\n    assertEquals(false, zone3.equals(zone5));\n    assertEquals(false, zone4.equals(zone5));\n    assertEquals(false, zone5.equals(zone1));\n    assertEquals(false, zone5.equals(zone2));\n    assertEquals(false, zone5.equals(zone3));\n    assertEquals(false, zone5.equals(zone4));\n    assertEquals(false, zone1.hashCode() == zone5.hashCode());\n    assertEquals(true, zone5.hashCode() == zone5.hashCode());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1589, "method_signature": "void testEqualsHashCode()"}, "TestDateTimeZone.testForID_String": {"callee_method_ids": [114, 114, 114, 114, 114, 114], "callee_method_names": ["DateTimeZone.getID", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getID", "DateTimeZone.getOffset"], "method_name": "TestDateTimeZone.testForID_String", "method_implementation": "{\n    assertEquals(DateTimeZone.getDefault(), DateTimeZone.forID((String) null));\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/London\");\n    assertEquals(\"Europe/London\", zone.getID());\n    zone = DateTimeZone.forID(\"UTC\");\n    assertSame(DateTimeZone.UTC, zone);\n    zone = DateTimeZone.forID(\"UT\");\n    assertSame(DateTimeZone.UTC, zone);\n    zone = DateTimeZone.forID(\"Z\");\n    assertSame(DateTimeZone.UTC, zone);\n    zone = DateTimeZone.forID(\"GMT\");\n    // depends if the default time-zone provider has been changed or not\n    assertTrue(zone == DateTimeZone.forID(\"Etc/GMT\") || zone == DateTimeZone.UTC);\n    zone = DateTimeZone.forID(\"+00:00\");\n    assertSame(DateTimeZone.UTC, zone);\n    zone = DateTimeZone.forID(\"+00\");\n    assertSame(DateTimeZone.UTC, zone);\n    long expected = DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE);\n    zone = DateTimeZone.forID(\"+01:23\");\n    assertEquals(\"+01:23\", zone.getID());\n    assertEquals(expected, zone.getOffset(TEST_TIME_SUMMER));\n    zone = DateTimeZone.forID(\"GMT+01:23\");\n    assertEquals(\"+01:23\", zone.getID());\n    assertEquals(expected, zone.getOffset(TEST_TIME_SUMMER));\n    zone = DateTimeZone.forID(\"UTC+01:23\");\n    assertEquals(\"+01:23\", zone.getID());\n    assertEquals(expected, zone.getOffset(TEST_TIME_SUMMER));\n    zone = DateTimeZone.forID(\"UT+01:23\");\n    assertEquals(\"+01:23\", zone.getID());\n    assertEquals(expected, zone.getOffset(TEST_TIME_SUMMER));\n    zone = DateTimeZone.forID(\"-02:00\");\n    assertEquals(\"-02:00\", zone.getID());\n    assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER));\n    zone = DateTimeZone.forID(\"-07:05:34.0\");\n    assertEquals(\"-07:05:34\", zone.getID());\n    assertEquals((-7L * DateTimeConstants.MILLIS_PER_HOUR) + (-5L * DateTimeConstants.MILLIS_PER_MINUTE) + (-34L * DateTimeConstants.MILLIS_PER_SECOND), zone.getOffset(TEST_TIME_SUMMER));\n    try {\n        DateTimeZone.forID(\"SST\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeZone.forID(\"europe/london\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeZone.forID(\"Europe/UK\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeZone.forID(\"+\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeZone.forID(\"+0\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1574, "method_signature": "void testForID_String()"}, "TestDateTimeZone.testForOffsetHoursMinutes_int_int": {"callee_method_names": [], "method_name": "TestDateTimeZone.testForOffsetHoursMinutes_int_int", "method_implementation": "{\n    assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0));\n    assertEquals(DateTimeZone.forID(\"+23:59\"), DateTimeZone.forOffsetHoursMinutes(23, 59));\n    assertEquals(DateTimeZone.forID(\"+02:15\"), DateTimeZone.forOffsetHoursMinutes(2, 15));\n    assertEquals(DateTimeZone.forID(\"+02:00\"), DateTimeZone.forOffsetHoursMinutes(2, 0));\n    try {\n        DateTimeZone.forOffsetHoursMinutes(2, -15);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    assertEquals(DateTimeZone.forID(\"+00:15\"), DateTimeZone.forOffsetHoursMinutes(0, 15));\n    assertEquals(DateTimeZone.forID(\"+00:00\"), DateTimeZone.forOffsetHoursMinutes(0, 0));\n    assertEquals(DateTimeZone.forID(\"-00:15\"), DateTimeZone.forOffsetHoursMinutes(0, -15));\n    assertEquals(DateTimeZone.forID(\"-02:00\"), DateTimeZone.forOffsetHoursMinutes(-2, 0));\n    assertEquals(DateTimeZone.forID(\"-02:15\"), DateTimeZone.forOffsetHoursMinutes(-2, -15));\n    assertEquals(DateTimeZone.forID(\"-02:15\"), DateTimeZone.forOffsetHoursMinutes(-2, 15));\n    assertEquals(DateTimeZone.forID(\"-23:59\"), DateTimeZone.forOffsetHoursMinutes(-23, 59));\n    try {\n        DateTimeZone.forOffsetHoursMinutes(2, 60);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeZone.forOffsetHoursMinutes(-2, 60);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeZone.forOffsetHoursMinutes(24, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        DateTimeZone.forOffsetHoursMinutes(-24, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1576, "method_signature": "void testForOffsetHoursMinutes_int_int()"}, "TestDateTimeZone.testForOffsetHours_int": {"callee_method_names": [], "method_name": "TestDateTimeZone.testForOffsetHours_int", "method_implementation": "{\n    assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHours(0));\n    assertEquals(DateTimeZone.forID(\"+03:00\"), DateTimeZone.forOffsetHours(3));\n    assertEquals(DateTimeZone.forID(\"-02:00\"), DateTimeZone.forOffsetHours(-2));\n    try {\n        DateTimeZone.forOffsetHours(999999);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1575, "method_signature": "void testForOffsetHours_int()"}, "TestDateTimeZone.testForOffsetMillis_int": {"callee_method_names": [], "method_name": "TestDateTimeZone.testForOffsetMillis_int", "method_implementation": "{\n    assertSame(DateTimeZone.UTC, DateTimeZone.forOffsetMillis(0));\n    assertEquals(DateTimeZone.forID(\"+23:59:59.999\"), DateTimeZone.forOffsetMillis((24 * 60 * 60 * 1000) - 1));\n    assertEquals(DateTimeZone.forID(\"+03:00\"), DateTimeZone.forOffsetMillis(3 * 60 * 60 * 1000));\n    assertEquals(DateTimeZone.forID(\"-02:00\"), DateTimeZone.forOffsetMillis(-2 * 60 * 60 * 1000));\n    assertEquals(DateTimeZone.forID(\"-23:59:59.999\"), DateTimeZone.forOffsetMillis((-24 * 60 * 60 * 1000) + 1));\n    assertEquals(DateTimeZone.forID(\"+04:45:17.045\"), DateTimeZone.forOffsetMillis(4 * 60 * 60 * 1000 + 45 * 60 * 1000 + 17 * 1000 + 45));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1577, "method_signature": "void testForOffsetMillis_int()"}, "TestDateTimeZone.testForTimeZone_TimeZone": {"callee_method_ids": [114, 114, 114, 114], "callee_method_names": ["DateTimeZone.getID", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getID", "TimeZone.setID", "DateTimeZone.getID"], "method_name": "TestDateTimeZone.testForTimeZone_TimeZone", "method_implementation": "{\n    assertEquals(DateTimeZone.getDefault(), DateTimeZone.forTimeZone((TimeZone) null));\n    DateTimeZone zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"Europe/London\"));\n    assertEquals(\"Europe/London\", zone.getID());\n    assertSame(DateTimeZone.UTC, DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"UTC\")));\n    zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"+00:00\"));\n    assertSame(DateTimeZone.UTC, zone);\n    zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"GMT+00:00\"));\n    assertSame(DateTimeZone.UTC, zone);\n    zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"GMT+00:00\"));\n    assertSame(DateTimeZone.UTC, zone);\n    zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"GMT+00\"));\n    assertSame(DateTimeZone.UTC, zone);\n    zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"GMT+01:23\"));\n    assertEquals(\"+01:23\", zone.getID());\n    assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE), zone.getOffset(TEST_TIME_SUMMER));\n    zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"GMT+1:23\"));\n    assertEquals(\"+01:23\", zone.getID());\n    assertEquals(DateTimeConstants.MILLIS_PER_HOUR + (23L * DateTimeConstants.MILLIS_PER_MINUTE), zone.getOffset(TEST_TIME_SUMMER));\n    zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"GMT-02:00\"));\n    assertEquals(\"-02:00\", zone.getID());\n    assertEquals((-2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER));\n    zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"GMT+2\"));\n    assertEquals(\"+02:00\", zone.getID());\n    assertEquals((2L * DateTimeConstants.MILLIS_PER_HOUR), zone.getOffset(TEST_TIME_SUMMER));\n    zone = DateTimeZone.forTimeZone(TimeZone.getTimeZone(\"EST\"));\n    assertEquals(\"America/New_York\", zone.getID());\n    TimeZone tz = TimeZone.getTimeZone(\"GMT-08:00\");\n    tz.setID(\"GMT-\\u0660\\u0668:\\u0660\\u0660\");\n    zone = DateTimeZone.forTimeZone(tz);\n    assertEquals(\"-08:00\", zone.getID());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1578, "method_signature": "void testForTimeZone_TimeZone()"}, "TestDateTimeZone.testGetMillisKeepLocal": {"callee_method_ids": [119, 119, 119, 119, 119, 119, 119], "callee_method_names": ["DateTimeZone.getMillisKeepLocal", "DateTimeZone.getMillisKeepLocal", "DateTimeZone.getMillisKeepLocal", "DateTimeZone.getMillisKeepLocal", "DateTimeZone.getMillisKeepLocal", "DateTimeZone.getMillisKeepLocal", "DateTimeZone.getMillisKeepLocal"], "method_name": "TestDateTimeZone.testGetMillisKeepLocal", "method_implementation": "{\n    long millisLondon = TEST_TIME_SUMMER;\n    long millisParis = TEST_TIME_SUMMER - 1L * DateTimeConstants.MILLIS_PER_HOUR;\n    assertEquals(millisLondon, LONDON.getMillisKeepLocal(LONDON, millisLondon));\n    assertEquals(millisParis, LONDON.getMillisKeepLocal(LONDON, millisParis));\n    assertEquals(millisLondon, PARIS.getMillisKeepLocal(PARIS, millisLondon));\n    assertEquals(millisParis, PARIS.getMillisKeepLocal(PARIS, millisParis));\n    assertEquals(millisParis, LONDON.getMillisKeepLocal(PARIS, millisLondon));\n    assertEquals(millisLondon, PARIS.getMillisKeepLocal(LONDON, millisParis));\n    DateTimeZone zone = DateTimeZone.getDefault();\n    try {\n        DateTimeZone.setDefault(LONDON);\n        assertEquals(millisLondon, PARIS.getMillisKeepLocal(null, millisParis));\n    } finally {\n        DateTimeZone.setDefault(zone);\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1583, "method_signature": "void testGetMillisKeepLocal()"}, "TestDateTimeZone.testGetOffset_long": {"callee_method_ids": [114, 114, 115, 115], "callee_method_names": ["DateTimeZone.getOffset", "DateTimeZone.getOffset", "DateTimeZone.getStandardOffset", "DateTimeZone.getStandardOffset", "DateTimeZone.getOffsetFromLocal", "DateTimeZone.getOffsetFromLocal", "DateTimeZone.isStandardOffset", "DateTimeZone.isStandardOffset"], "method_name": "TestDateTimeZone.testGetOffset_long", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n    assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_SUMMER));\n    assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffset(TEST_TIME_WINTER));\n    assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_SUMMER));\n    assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getStandardOffset(TEST_TIME_WINTER));\n    assertEquals(2L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_SUMMER));\n    assertEquals(1L * DateTimeConstants.MILLIS_PER_HOUR, zone.getOffsetFromLocal(TEST_TIME_WINTER));\n    assertEquals(false, zone.isStandardOffset(TEST_TIME_SUMMER));\n    assertEquals(true, zone.isStandardOffset(TEST_TIME_WINTER));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1582, "method_signature": "void testGetOffset_long()"}, "TestDateTimeZone.testIdNotAutoMapped_Asia_Yangon": {"callee_method_names": ["DateTimeZone.getID", "DateTimeZone.getID"], "method_name": "TestDateTimeZone.testIdNotAutoMapped_Asia_Yangon", "method_implementation": "{\n    DateTimeZone zoneOld = DateTimeZone.forID(\"Asia/Rangoon\");\n    assertEquals(zoneOld.getID(), \"Asia/Yangon\");\n    DateTimeZone zoneNew = DateTimeZone.forID(\"Asia/Yangon\");\n    assertEquals(zoneNew.getID(), \"Asia/Yangon\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1597, "method_signature": "void testIdNotAutoMapped_Asia_Yangon()"}, "TestDateTimeZone.testIsFixed": {"callee_method_names": ["DateTimeZone.isFixed"], "method_name": "TestDateTimeZone.testIsFixed", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n    assertEquals(false, zone.isFixed());\n    assertEquals(true, DateTimeZone.UTC.isFixed());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1584, "method_signature": "void testIsFixed()"}, "TestDateTimeZone.testIsLocalDateTimeGap_Berlin": {"callee_method_ids": [120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120], "callee_method_names": ["DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap"], "method_name": "TestDateTimeZone.testIsLocalDateTimeGap_Berlin", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/Berlin\");\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 1, 0)));\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 1, 59, 59, 99)));\n    assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 2, 0)));\n    assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 2, 30)));\n    assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 2, 59, 59, 99)));\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 3, 0)));\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 25, 4, 0)));\n    // before overlap\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 10, 28, 1, 30)));\n    // overlap\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 10, 28, 2, 30)));\n    // after overlap\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 10, 28, 3, 30)));\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 12, 24, 12, 34)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1586, "method_signature": "void testIsLocalDateTimeGap_Berlin()"}, "TestDateTimeZone.testIsLocalDateTimeGap_NewYork": {"callee_method_ids": [120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120], "callee_method_names": ["DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap", "DateTimeZone.isLocalDateTimeGap"], "method_name": "TestDateTimeZone.testIsLocalDateTimeGap_NewYork", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"America/New_York\");\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 1, 0)));\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 1, 59, 59, 99)));\n    assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 2, 0)));\n    assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 2, 30)));\n    assertEquals(true, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 2, 59, 59, 99)));\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 3, 0)));\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 3, 11, 4, 0)));\n    // before overlap\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 11, 4, 0, 30)));\n    // overlap\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 11, 4, 1, 30)));\n    // after overlap\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 11, 4, 2, 30)));\n    assertEquals(false, zone.isLocalDateTimeGap(new LocalDateTime(2007, 12, 24, 12, 34)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1587, "method_signature": "void testIsLocalDateTimeGap_NewYork()"}, "TestDateTimeZone.testJerusalem": {"callee_method_names": ["DateTimeZone.isStandardOffset", "DateTime.getMillis", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.isStandardOffset", "DateTime.getMillis", "DateTime.getDayOfWeek", "DateTime.getDayOfMonth", "DateTime.getMonthOfYear"], "method_name": "TestDateTimeZone.testJerusalem", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Asia/Jerusalem\");\n    DateTime winter = new DateTime(2006, 1, 1, 0, 0, 0, 0, zone);\n    assertEquals(true, zone.isStandardOffset(winter.getMillis()));\n    DateTime cutover = new DateTime(zone.nextTransition(winter.getMillis()), zone);\n    assertEquals(false, zone.isStandardOffset(cutover.getMillis()));\n    assertEquals(5, cutover.getDayOfWeek());\n    assertEquals(31, cutover.getDayOfMonth());\n    assertEquals(3, cutover.getMonthOfYear());\n}", "repo_id": "7", "comment": "// rule of style \"Fri <= 1\"\n", "repo_name": "joda-time-main/", "id": 1594, "method_signature": "void testJerusalem()"}, "TestDateTimeZone.testNameProvider": {"callee_method_names": ["NameProvider.getClass"], "method_name": "TestDateTimeZone.testNameProvider", "method_implementation": "{\n    try {\n        assertNotNull(DateTimeZone.getNameProvider());\n        NameProvider provider = DateTimeZone.getNameProvider();\n        DateTimeZone.setNameProvider(null);\n        assertEquals(provider.getClass(), DateTimeZone.getNameProvider().getClass());\n        provider = new MockOKButNullNameProvider();\n        DateTimeZone.setNameProvider(provider);\n        assertSame(provider, DateTimeZone.getNameProvider());\n        assertEquals(\"+00:00\", DateTimeZone.UTC.getShortName(TEST_TIME_SUMMER));\n        assertEquals(\"+00:00\", DateTimeZone.UTC.getName(TEST_TIME_SUMMER));\n    } finally {\n        DateTimeZone.setNameProvider(null);\n    }\n    try {\n        System.setProperty(\"org.joda.time.DateTimeZone.NameProvider\", \"org.joda.time.tz.DefaultNameProvider\");\n        DateTimeZone.setNameProvider(null);\n        assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());\n    } finally {\n        System.getProperties().remove(\"org.joda.time.DateTimeZone.NameProvider\");\n        DateTimeZone.setNameProvider(null);\n        assertEquals(DefaultNameProvider.class, DateTimeZone.getNameProvider().getClass());\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1580, "method_signature": "void testNameProvider()"}, "TestDateTimeZone.testProvider": {"callee_method_names": ["Provider.getClass"], "method_name": "TestDateTimeZone.testProvider", "method_implementation": "{\n    try {\n        assertNotNull(DateTimeZone.getProvider());\n        Provider provider = DateTimeZone.getProvider();\n        DateTimeZone.setProvider(null);\n        assertEquals(provider.getClass(), DateTimeZone.getProvider().getClass());\n        try {\n            DateTimeZone.setProvider(new MockNullIDSProvider());\n            fail();\n        } catch (IllegalArgumentException ex) {\n        }\n        try {\n            DateTimeZone.setProvider(new MockEmptyIDSProvider());\n            fail();\n        } catch (IllegalArgumentException ex) {\n        }\n        try {\n            DateTimeZone.setProvider(new MockNoUTCProvider());\n            fail();\n        } catch (IllegalArgumentException ex) {\n        }\n        try {\n            DateTimeZone.setProvider(new MockBadUTCProvider());\n            fail();\n        } catch (IllegalArgumentException ex) {\n        }\n        Provider prov = new MockOKProvider();\n        DateTimeZone.setProvider(prov);\n        assertSame(prov, DateTimeZone.getProvider());\n        assertEquals(2, DateTimeZone.getAvailableIDs().size());\n        assertTrue(DateTimeZone.getAvailableIDs().contains(\"UTC\"));\n        assertTrue(DateTimeZone.getAvailableIDs().contains(\"Europe/London\"));\n    } finally {\n        DateTimeZone.setProvider(null);\n        assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());\n    }\n    try {\n        System.setProperty(\"org.joda.time.DateTimeZone.Provider\", \"org.joda.time.tz.UTCProvider\");\n        DateTimeZone.setProvider(null);\n        assertEquals(UTCProvider.class, DateTimeZone.getProvider().getClass());\n    } finally {\n        System.getProperties().remove(\"org.joda.time.DateTimeZone.Provider\");\n        DateTimeZone.setProvider(null);\n        assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());\n    }\n    try {\n        System.setProperty(\"org.joda.time.DateTimeZone.Folder\", \"src/test/resources/tzdata\");\n        DateTimeZone.setProvider(null);\n        assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());\n        assertEquals(2, DateTimeZone.getAvailableIDs().size());\n        assertEquals(true, DateTimeZone.getAvailableIDs().contains(\"UTC\"));\n        assertEquals(true, DateTimeZone.getAvailableIDs().contains(\"CET\"));\n    } finally {\n        System.getProperties().remove(\"org.joda.time.DateTimeZone.Folder\");\n        DateTimeZone.setProvider(null);\n        assertEquals(ZoneInfoProvider.class, DateTimeZone.getProvider().getClass());\n        assertEquals(true, DateTimeZone.getAvailableIDs().size() > 2);\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1579, "method_signature": "void testProvider()"}, "TestDateTimeZone.testSerialization1": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestDateTimeZone.testSerialization1", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(zone);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    DateTimeZone result = (DateTimeZone) ois.readObject();\n    ois.close();\n    assertSame(zone, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1595, "method_signature": "void testSerialization1()"}, "TestDateTimeZone.testSerialization2": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestDateTimeZone.testSerialization2", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"+01:00\");\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(zone);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    DateTimeZone result = (DateTimeZone) ois.readObject();\n    ois.close();\n    assertEquals(zone, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1596, "method_signature": "void testSerialization2()"}, "TestDateTimeZone.testToString": {"callee_method_names": ["DateTimeZone.toString"], "method_name": "TestDateTimeZone.testToString", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n    assertEquals(\"Europe/Paris\", zone.toString());\n    assertEquals(\"UTC\", DateTimeZone.UTC.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1590, "method_signature": "void testToString()"}, "TestDateTimeZone.testToTimeZone": {"callee_method_names": ["DateTimeZone.toTimeZone", "TimeZone.getID"], "method_name": "TestDateTimeZone.testToTimeZone", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n    TimeZone tz = zone.toTimeZone();\n    assertEquals(\"Europe/Paris\", tz.getID());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1588, "method_signature": "void testToTimeZone()"}, "TestDateTimeZone.testToronto": {"callee_method_ids": [114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114, 114], "callee_method_names": ["DateTimeZone.getStandardOffset", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek", "DateTimeZone.nextTransition", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTime.toLocalDate", "DateTime.getDayOfWeek"], "method_name": "TestDateTimeZone.testToronto", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"America/Toronto\");\n    DateTime start = new DateTime(1927, 1, 1, 0, 0, 0, 0, zone);\n    assertEquals(-5 * 3600000, zone.getStandardOffset(start.getMillis()));\n    assertEquals(-5 * 3600000, zone.getOffset(start.getMillis()));\n    DateTime summer1927 = new DateTime(zone.nextTransition(start.getMillis()), zone);\n    assertEquals(-4 * 3600000, zone.getOffset(summer1927.getMillis()));\n    assertEquals(new LocalDate(1927, 5, 1), summer1927.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, summer1927.getDayOfWeek());\n    DateTime winter1927 = new DateTime(zone.nextTransition(summer1927.getMillis()), zone);\n    assertEquals(-5 * 3600000, zone.getOffset(winter1927.getMillis()));\n    assertEquals(new LocalDate(1927, 9, 25), winter1927.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, winter1927.getDayOfWeek());\n    DateTime summer1928 = new DateTime(zone.nextTransition(winter1927.getMillis()), zone);\n    assertEquals(-4 * 3600000, zone.getOffset(summer1928.getMillis()));\n    assertEquals(new LocalDate(1928, 4, 29), summer1928.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, summer1928.getDayOfWeek());\n    DateTime winter1928 = new DateTime(zone.nextTransition(summer1928.getMillis()), zone);\n    assertEquals(-5 * 3600000, zone.getOffset(winter1928.getMillis()));\n    assertEquals(new LocalDate(1928, 9, 30), winter1928.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, winter1928.getDayOfWeek());\n    DateTime summer1929 = new DateTime(zone.nextTransition(winter1928.getMillis()), zone);\n    assertEquals(-4 * 3600000, zone.getOffset(summer1929.getMillis()));\n    assertEquals(new LocalDate(1929, 4, 28), summer1929.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, summer1929.getDayOfWeek());\n    DateTime winter1929 = new DateTime(zone.nextTransition(summer1929.getMillis()), zone);\n    assertEquals(-5 * 3600000, zone.getOffset(winter1929.getMillis()));\n    assertEquals(new LocalDate(1929, 9, 29), winter1929.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, winter1929.getDayOfWeek());\n    DateTime summer1930 = new DateTime(zone.nextTransition(winter1929.getMillis()), zone);\n    assertEquals(-4 * 3600000, zone.getOffset(summer1930.getMillis()));\n    assertEquals(new LocalDate(1930, 4, 27), summer1930.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, summer1930.getDayOfWeek());\n    DateTime winter1930 = new DateTime(zone.nextTransition(summer1930.getMillis()), zone);\n    assertEquals(-5 * 3600000, zone.getOffset(winter1930.getMillis()));\n    assertEquals(new LocalDate(1930, 9, 28), winter1930.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, winter1930.getDayOfWeek());\n    DateTime summer1931 = new DateTime(zone.nextTransition(winter1930.getMillis()), zone);\n    assertEquals(-4 * 3600000, zone.getOffset(summer1931.getMillis()));\n    assertEquals(new LocalDate(1931, 4, 26), summer1931.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, summer1931.getDayOfWeek());\n    DateTime winter1931 = new DateTime(zone.nextTransition(summer1931.getMillis()), zone);\n    assertEquals(-5 * 3600000, zone.getOffset(winter1931.getMillis()));\n    assertEquals(new LocalDate(1931, 9, 27), winter1931.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, winter1931.getDayOfWeek());\n    DateTime summer1932 = new DateTime(zone.nextTransition(winter1931.getMillis()), zone);\n    assertEquals(-4 * 3600000, zone.getOffset(summer1932.getMillis()));\n    assertEquals(new LocalDate(1932, 5, 1), summer1932.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, summer1932.getDayOfWeek());\n    DateTime winter1932 = new DateTime(zone.nextTransition(summer1932.getMillis()), zone);\n    assertEquals(-5 * 3600000, zone.getOffset(winter1932.getMillis()));\n    assertEquals(new LocalDate(1932, 9, 25), winter1932.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, winter1932.getDayOfWeek());\n    DateTime summer1933 = new DateTime(zone.nextTransition(winter1932.getMillis()), zone);\n    assertEquals(-4 * 3600000, zone.getOffset(summer1933.getMillis()));\n    assertEquals(new LocalDate(1933, 4, 30), summer1933.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, summer1933.getDayOfWeek());\n    DateTime winter1933 = new DateTime(zone.nextTransition(summer1933.getMillis()), zone);\n    assertEquals(-5 * 3600000, zone.getOffset(winter1933.getMillis()));\n    assertEquals(new LocalDate(1933, 10, 1), winter1933.toLocalDate());\n    assertEquals(DateTimeConstants.SUNDAY, winter1933.getDayOfWeek());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1593, "method_signature": "void testToronto()"}, "TestDateTimeZone.testTransitionFixed": {"callee_method_names": ["DateTimeZone.nextTransition", "DateTimeZone.nextTransition", "DateTimeZone.previousTransition", "DateTimeZone.previousTransition"], "method_name": "TestDateTimeZone.testTransitionFixed", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"+01:00\");\n    assertEquals(TEST_TIME_SUMMER, zone.nextTransition(TEST_TIME_SUMMER));\n    assertEquals(TEST_TIME_WINTER, zone.nextTransition(TEST_TIME_WINTER));\n    assertEquals(TEST_TIME_SUMMER, zone.previousTransition(TEST_TIME_SUMMER));\n    assertEquals(TEST_TIME_WINTER, zone.previousTransition(TEST_TIME_WINTER));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1585, "method_signature": "void testTransitionFixed()"}, "TestDateTimeZone.testWindhoek": {"callee_method_ids": [114, 114, 114], "callee_method_names": ["DateTimeZone.getStandardOffset", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTimeZone.isStandardOffset", "DateTime.getMillis", "DateTimeZone.getStandardOffset", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTimeZone.isStandardOffset", "DateTime.getMillis", "DateTimeZone.getStandardOffset", "DateTime.getMillis", "DateTimeZone.getOffset", "DateTime.getMillis", "DateTimeZone.isStandardOffset", "DateTime.getMillis"], "method_name": "TestDateTimeZone.testWindhoek", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Africa/Windhoek\");\n    DateTime dtDec1990 = new DateTime(1990, 12, 1, 0, 0, 0, 0, zone);\n    assertEquals(3600000, zone.getStandardOffset(dtDec1990.getMillis()));\n    assertEquals(7200000, zone.getOffset(dtDec1990.getMillis()));\n    assertEquals(false, zone.isStandardOffset(dtDec1990.getMillis()));\n    DateTime dtDec1994 = new DateTime(1994, 12, 1, 0, 0, 0, 0, zone);\n    assertEquals(3600000, zone.getStandardOffset(dtDec1994.getMillis()));\n    assertEquals(7200000, zone.getOffset(dtDec1994.getMillis()));\n    assertEquals(false, zone.isStandardOffset(dtDec1994.getMillis()));\n    DateTime dtJun1995 = new DateTime(1995, 6, 1, 0, 0, 0, 0, zone);\n    assertEquals(3600000, zone.getStandardOffset(dtJun1995.getMillis()));\n    assertEquals(3600000, zone.getOffset(dtJun1995.getMillis()));\n    assertEquals(true, zone.isStandardOffset(dtJun1995.getMillis()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1592, "method_signature": "void testWindhoek()"}, "TestDateTimeZoneCutover.testBug3192457_adjustOffset": {"callee_method_ids": [451, 451], "callee_method_names": ["DateTime.minusHours", "DateTime.minusHours", "DateTime.withEarlierOffsetAtOverlap", "DateTime.withLaterOffsetAtOverlap", "DateTime.withEarlierOffsetAtOverlap", "DateTime.withLaterOffsetAtOverlap", "DateTime.withLaterOffsetAtOverlap", "DateTime.withEarlierOffsetAtOverlap"], "method_name": "TestDateTimeZoneCutover.testBug3192457_adjustOffset", "method_implementation": "{\n    final DateTimeZone zone = DateTimeZone.forID(\"Europe/Paris\");\n    DateTime base = new DateTime(2007, 10, 28, 3, 15, zone);\n    DateTime baseBefore = base.minusHours(2);\n    DateTime baseAfter = base.minusHours(1);\n    assertSame(base, base.withEarlierOffsetAtOverlap());\n    assertSame(base, base.withLaterOffsetAtOverlap());\n    assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n    assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n    assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n    assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2119, "method_signature": "void testBug3192457_adjustOffset()"}, "TestDateTimeZoneCutover.testDateTimeCreation_athens": {"callee_method_ids": [443], "callee_method_names": ["DateTime.toString", "DateTime.plusHours"], "method_name": "TestDateTimeZoneCutover.testDateTimeCreation_athens", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.forID(\"Europe/Athens\");\n    DateTime base = new DateTime(2011, 10, 30, 3, 15, zone);\n    assertEquals(\"2011-10-30T03:15:00.000+03:00\", base.toString());\n    assertEquals(\"2011-10-30T03:15:00.000+02:00\", base.plusHours(1).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2120, "method_signature": "void testDateTimeCreation_athens()"}, "TestDateTimeZoneCutover.test_DateTime_roundCeiling_day_NewYork_Autumn_preCutover": {"callee_method_names": ["DateTime.toString", "DateTime.dayOfMonth", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_DateTime_roundCeiling_day_NewYork_Autumn_preCutover", "method_implementation": "{\n    DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK);\n    assertEquals(\"2007-11-04T01:30:00.000-04:00\", dt.toString());\n    DateTime rounded = dt.dayOfMonth().roundCeilingCopy();\n    assertEquals(\"2007-11-05T00:00:00.000-05:00\", rounded.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2114, "method_signature": "void test_DateTime_roundCeiling_day_NewYork_Autumn_preCutover()"}, "TestDateTimeZoneCutover.test_DateTime_roundCeiling_day_NewYork_Spring_preCutover": {"callee_method_names": ["DateTime.toString", "DateTime.dayOfMonth", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_DateTime_roundCeiling_day_NewYork_Spring_preCutover", "method_implementation": "{\n    DateTime dt = new DateTime(2007, 3, 11, 1, 30, 0, 0, ZONE_NEW_YORK);\n    assertEquals(\"2007-03-11T01:30:00.000-05:00\", dt.toString());\n    DateTime rounded = dt.dayOfMonth().roundCeilingCopy();\n    assertEquals(\"2007-03-12T00:00:00.000-04:00\", rounded.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2111, "method_signature": "void test_DateTime_roundCeiling_day_NewYork_Spring_preCutover()"}, "TestDateTimeZoneCutover.test_DateTime_roundFloor_day_NewYork_Autumn_preCutover": {"callee_method_names": ["DateTime.toString", "DateTime.dayOfMonth", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_DateTime_roundFloor_day_NewYork_Autumn_preCutover", "method_implementation": "{\n    DateTime dt = new DateTime(2007, 11, 4, 1, 30, 0, 0, ZONE_NEW_YORK);\n    assertEquals(\"2007-11-04T01:30:00.000-04:00\", dt.toString());\n    DateTime rounded = dt.dayOfMonth().roundFloorCopy();\n    assertEquals(\"2007-11-04T00:00:00.000-04:00\", rounded.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2113, "method_signature": "void test_DateTime_roundFloor_day_NewYork_Autumn_preCutover()"}, "TestDateTimeZoneCutover.test_DateTime_roundFloor_day_NewYork_Spring_preCutover": {"callee_method_names": ["DateTime.toString", "DateTime.dayOfMonth", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_DateTime_roundFloor_day_NewYork_Spring_preCutover", "method_implementation": "{\n    DateTime dt = new DateTime(2007, 3, 11, 1, 30, 0, 0, ZONE_NEW_YORK);\n    assertEquals(\"2007-03-11T01:30:00.000-05:00\", dt.toString());\n    DateTime rounded = dt.dayOfMonth().roundFloorCopy();\n    assertEquals(\"2007-03-11T00:00:00.000-05:00\", rounded.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2110, "method_signature": "void test_DateTime_roundFloor_day_NewYork_Spring_preCutover()"}, "TestDateTimeZoneCutover.test_GuatemataIsCorrect_Autumn": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_GuatemataIsCorrect_Autumn", "method_implementation": "{\n    DateTime pre = new DateTime(CUTOVER_GUATEMALA_AUTUMN - 1L, ZONE_GUATEMALA);\n    assertEquals(\"2006-09-30T23:59:59.999-05:00\", pre.toString());\n    DateTime at = new DateTime(CUTOVER_GUATEMALA_AUTUMN, ZONE_GUATEMALA);\n    assertEquals(\"2006-09-30T23:00:00.000-06:00\", at.toString());\n    DateTime post = new DateTime(CUTOVER_GUATEMALA_AUTUMN + 1L, ZONE_GUATEMALA);\n    assertEquals(\"2006-09-30T23:00:00.001-06:00\", post.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2117, "method_signature": "void test_GuatemataIsCorrect_Autumn()"}, "TestDateTimeZoneCutover.test_MockGazaIsCorrect": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_MockGazaIsCorrect", "method_implementation": "{\n    DateTime pre = new DateTime(CUTOVER_GAZA - 1L, MOCK_GAZA);\n    assertEquals(\"2007-03-31T23:59:59.999+02:00\", pre.toString());\n    DateTime at = new DateTime(CUTOVER_GAZA, MOCK_GAZA);\n    assertEquals(\"2007-04-01T01:00:00.000+03:00\", at.toString());\n    DateTime post = new DateTime(CUTOVER_GAZA + 1L, MOCK_GAZA);\n    assertEquals(\"2007-04-01T01:00:00.001+03:00\", post.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2107, "method_signature": "void test_MockGazaIsCorrect()"}, "TestDateTimeZoneCutover.test_MockTurkIsCorrect": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_MockTurkIsCorrect", "method_implementation": "{\n    DateTime pre = new DateTime(CUTOVER_TURK - 1L, MOCK_TURK);\n    assertEquals(\"2007-03-31T23:59:59.999-05:00\", pre.toString());\n    DateTime at = new DateTime(CUTOVER_TURK, MOCK_TURK);\n    assertEquals(\"2007-04-01T01:00:00.000-04:00\", at.toString());\n    DateTime post = new DateTime(CUTOVER_TURK + 1L, MOCK_TURK);\n    assertEquals(\"2007-04-01T01:00:00.001-04:00\", post.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2108, "method_signature": "void test_MockTurkIsCorrect()"}, "TestDateTimeZoneCutover.test_MoscowIsCorrect_Autumn": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_MoscowIsCorrect_Autumn", "method_implementation": "{\n    DateTime pre = new DateTime(CUTOVER_MOSCOW_AUTUMN - 1L, ZONE_MOSCOW);\n    assertEquals(\"2007-10-28T02:59:59.999+04:00\", pre.toString());\n    DateTime at = new DateTime(CUTOVER_MOSCOW_AUTUMN, ZONE_MOSCOW);\n    assertEquals(\"2007-10-28T02:00:00.000+03:00\", at.toString());\n    DateTime post = new DateTime(CUTOVER_MOSCOW_AUTUMN + 1L, ZONE_MOSCOW);\n    assertEquals(\"2007-10-28T02:00:00.001+03:00\", post.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2116, "method_signature": "void test_MoscowIsCorrect_Autumn()"}, "TestDateTimeZoneCutover.test_MoscowIsCorrect_Spring": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_MoscowIsCorrect_Spring", "method_implementation": "{\n    //      DateTime x = new DateTime(2007, 7, 1, 0, 0, 0, 0, ZONE_MOSCOW);\n    //      System.out.println(ZONE_MOSCOW.nextTransition(x.getMillis()));\n    //      DateTime y = new DateTime(ZONE_MOSCOW.nextTransition(x.getMillis()), ZONE_MOSCOW);\n    //      System.out.println(y);\n    DateTime pre = new DateTime(CUTOVER_MOSCOW_SPRING - 1L, ZONE_MOSCOW);\n    assertEquals(\"2007-03-25T01:59:59.999+03:00\", pre.toString());\n    DateTime at = new DateTime(CUTOVER_MOSCOW_SPRING, ZONE_MOSCOW);\n    assertEquals(\"2007-03-25T03:00:00.000+04:00\", at.toString());\n    DateTime post = new DateTime(CUTOVER_MOSCOW_SPRING + 1L, ZONE_MOSCOW);\n    assertEquals(\"2007-03-25T03:00:00.001+04:00\", post.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2115, "method_signature": "void test_MoscowIsCorrect_Spring()"}, "TestDateTimeZoneCutover.test_NewYorkIsCorrect_Autumn": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_NewYorkIsCorrect_Autumn", "method_implementation": "{\n    DateTime pre = new DateTime(CUTOVER_NEW_YORK_AUTUMN - 1L, ZONE_NEW_YORK);\n    assertEquals(\"2007-11-04T01:59:59.999-04:00\", pre.toString());\n    DateTime at = new DateTime(CUTOVER_NEW_YORK_AUTUMN, ZONE_NEW_YORK);\n    assertEquals(\"2007-11-04T01:00:00.000-05:00\", at.toString());\n    DateTime post = new DateTime(CUTOVER_NEW_YORK_AUTUMN + 1L, ZONE_NEW_YORK);\n    assertEquals(\"2007-11-04T01:00:00.001-05:00\", post.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2112, "method_signature": "void test_NewYorkIsCorrect_Autumn()"}, "TestDateTimeZoneCutover.test_NewYorkIsCorrect_Spring": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_NewYorkIsCorrect_Spring", "method_implementation": "{\n    DateTime pre = new DateTime(CUTOVER_NEW_YORK_SPRING - 1L, ZONE_NEW_YORK);\n    assertEquals(\"2007-03-11T01:59:59.999-05:00\", pre.toString());\n    DateTime at = new DateTime(CUTOVER_NEW_YORK_SPRING, ZONE_NEW_YORK);\n    assertEquals(\"2007-03-11T03:00:00.000-04:00\", at.toString());\n    DateTime post = new DateTime(CUTOVER_NEW_YORK_SPRING + 1L, ZONE_NEW_YORK);\n    assertEquals(\"2007-03-11T03:00:00.001-04:00\", post.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2109, "method_signature": "void test_NewYorkIsCorrect_Spring()"}, "TestDateTimeZoneCutover.test_RioBrancoIsCorrect_Spring": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.toString"], "method_name": "TestDateTimeZoneCutover.test_RioBrancoIsCorrect_Spring", "method_implementation": "{\n    DateTime pre = new DateTime(CUTOVER_RIO_BRANCO_AUTUMN - 1L, ZONE_RIO_BRANCO);\n    assertEquals(\"2008-06-23T23:59:59.999-05:00\", pre.toString());\n    DateTime at = new DateTime(CUTOVER_RIO_BRANCO_AUTUMN, ZONE_RIO_BRANCO);\n    assertEquals(\"2008-06-24T01:00:00.000-04:00\", at.toString());\n    DateTime post = new DateTime(CUTOVER_RIO_BRANCO_AUTUMN + 1L, ZONE_RIO_BRANCO);\n    assertEquals(\"2008-06-24T01:00:00.001-04:00\", post.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2118, "method_signature": "void test_RioBrancoIsCorrect_Spring()"}, "TestDateTime_Basics.check": {"callee_method_names": ["DateTime.getYear", "DateTime.getMonthOfYear", "DateTime.getDayOfMonth", "DateTime.getHourOfDay", "DateTime.getMinuteOfHour", "DateTime.getSecondOfMinute", "DateTime.getMillisOfSecond"], "method_name": "TestDateTime_Basics.check", "method_implementation": "{\n    assertEquals(year, test.getYear());\n    assertEquals(month, test.getMonthOfYear());\n    assertEquals(day, test.getDayOfMonth());\n    assertEquals(hour, test.getHourOfDay());\n    assertEquals(min, test.getMinuteOfHour());\n    assertEquals(sec, test.getSecondOfMinute());\n    assertEquals(mil, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1358, "method_signature": "void check(DateTime, int, int, int, int, int, int, int)"}, "TestDateTime_Basics.testEqualsHashCode": {"callee_method_names": ["DateTime.equals", "DateTime.equals", "DateTime.equals", "DateTime.equals", "DateTime.hashCode", "DateTime.hashCode", "DateTime.hashCode", "DateTime.hashCode", "DateTime.hashCode", "DateTime.hashCode", "DateTime.equals", "DateTime.equals", "DateTime.equals", "DateTime.equals", "DateTime.hashCode", "DateTime.hashCode", "DateTime.hashCode", "DateTime.hashCode", "DateTime.equals", "DateTime.equals", "DateTime.equals"], "method_name": "TestDateTime_Basics.testEqualsHashCode", "method_implementation": "{\n    DateTime test1 = new DateTime(TEST_TIME1);\n    DateTime test2 = new DateTime(TEST_TIME1);\n    assertEquals(true, test1.equals(test2));\n    assertEquals(true, test2.equals(test1));\n    assertEquals(true, test1.equals(test1));\n    assertEquals(true, test2.equals(test2));\n    assertEquals(true, test1.hashCode() == test2.hashCode());\n    assertEquals(true, test1.hashCode() == test1.hashCode());\n    assertEquals(true, test2.hashCode() == test2.hashCode());\n    DateTime test3 = new DateTime(TEST_TIME2);\n    assertEquals(false, test1.equals(test3));\n    assertEquals(false, test2.equals(test3));\n    assertEquals(false, test3.equals(test1));\n    assertEquals(false, test3.equals(test2));\n    assertEquals(false, test1.hashCode() == test3.hashCode());\n    assertEquals(false, test2.hashCode() == test3.hashCode());\n    assertEquals(false, test1.equals(\"Hello\"));\n    assertEquals(true, test1.equals(new MockInstant()));\n    assertEquals(false, test1.equals(new DateTime(TEST_TIME1, GREGORIAN_DEFAULT)));\n    assertEquals(true, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, new MockEqualsChronology())));\n    assertEquals(false, new DateTime(TEST_TIME1, new MockEqualsChronology()).equals(new DateTime(TEST_TIME1, ISO_DEFAULT)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1339, "method_signature": "void testEqualsHashCode()"}, "TestDateTime_Basics.testGet_DateTimeField": {"callee_method_names": ["DateTime.get", "ISOChronology.era", "DateTime.get", "ISOChronology.centuryOfEra", "DateTime.get", "ISOChronology.yearOfCentury", "DateTime.get", "ISOChronology.yearOfEra", "DateTime.get", "ISOChronology.year", "DateTime.get", "ISOChronology.monthOfYear", "DateTime.get", "ISOChronology.dayOfMonth", "DateTime.get", "ISOChronology.weekyear", "DateTime.get", "ISOChronology.weekOfWeekyear", "DateTime.get", "ISOChronology.dayOfWeek", "DateTime.get", "ISOChronology.dayOfYear", "DateTime.get", "ISOChronology.halfdayOfDay", "DateTime.get", "ISOChronology.hourOfHalfday", "DateTime.get", "ISOChronology.clockhourOfDay", "DateTime.get", "ISOChronology.clockhourOfHalfday", "DateTime.get", "ISOChronology.hourOfDay", "DateTime.get", "ISOChronology.minuteOfHour", "DateTime.get", "ISOChronology.minuteOfDay", "DateTime.get", "ISOChronology.secondOfMinute", "DateTime.get", "ISOChronology.secondOfDay", "DateTime.get", "ISOChronology.millisOfSecond", "DateTime.get", "ISOChronology.millisOfDay", "DateTime.get"], "method_name": "TestDateTime_Basics.testGet_DateTimeField", "method_implementation": "{\n    DateTime test = new DateTime();\n    assertEquals(1, test.get(ISO_DEFAULT.era()));\n    assertEquals(20, test.get(ISO_DEFAULT.centuryOfEra()));\n    assertEquals(2, test.get(ISO_DEFAULT.yearOfCentury()));\n    assertEquals(2002, test.get(ISO_DEFAULT.yearOfEra()));\n    assertEquals(2002, test.get(ISO_DEFAULT.year()));\n    assertEquals(6, test.get(ISO_DEFAULT.monthOfYear()));\n    assertEquals(9, test.get(ISO_DEFAULT.dayOfMonth()));\n    assertEquals(2002, test.get(ISO_DEFAULT.weekyear()));\n    assertEquals(23, test.get(ISO_DEFAULT.weekOfWeekyear()));\n    assertEquals(7, test.get(ISO_DEFAULT.dayOfWeek()));\n    assertEquals(160, test.get(ISO_DEFAULT.dayOfYear()));\n    assertEquals(0, test.get(ISO_DEFAULT.halfdayOfDay()));\n    assertEquals(1, test.get(ISO_DEFAULT.hourOfHalfday()));\n    assertEquals(1, test.get(ISO_DEFAULT.clockhourOfDay()));\n    assertEquals(1, test.get(ISO_DEFAULT.clockhourOfHalfday()));\n    assertEquals(1, test.get(ISO_DEFAULT.hourOfDay()));\n    assertEquals(0, test.get(ISO_DEFAULT.minuteOfHour()));\n    assertEquals(60, test.get(ISO_DEFAULT.minuteOfDay()));\n    assertEquals(0, test.get(ISO_DEFAULT.secondOfMinute()));\n    assertEquals(60 * 60, test.get(ISO_DEFAULT.secondOfDay()));\n    assertEquals(0, test.get(ISO_DEFAULT.millisOfSecond()));\n    assertEquals(60 * 60 * 1000, test.get(ISO_DEFAULT.millisOfDay()));\n    try {\n        test.get((DateTimeField) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1337, "method_signature": "void testGet_DateTimeField()"}, "TestDateTime_Basics.testGetters": {"callee_method_names": ["DateTime.getChronology", "DateTime.getZone", "DateTime.getMillis", "DateTime.getEra", "DateTime.getCenturyOfEra", "DateTime.getYearOfCentury", "DateTime.getYearOfEra", "DateTime.getYear", "DateTime.getMonthOfYear", "DateTime.getDayOfMonth", "DateTime.getWeekyear", "DateTime.getWeekOfWeekyear", "DateTime.getDayOfWeek", "DateTime.getDayOfYear", "DateTime.getHourOfDay", "DateTime.getMinuteOfHour", "DateTime.getMinuteOfDay", "DateTime.getSecondOfMinute", "DateTime.getSecondOfDay", "DateTime.getMillisOfSecond", "DateTime.getMillisOfDay"], "method_name": "TestDateTime_Basics.testGetters", "method_implementation": "{\n    DateTime test = new DateTime();\n    assertEquals(ISO_DEFAULT, test.getChronology());\n    assertEquals(LONDON, test.getZone());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n    assertEquals(1, test.getEra());\n    assertEquals(20, test.getCenturyOfEra());\n    assertEquals(2, test.getYearOfCentury());\n    assertEquals(2002, test.getYearOfEra());\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(2002, test.getWeekyear());\n    assertEquals(23, test.getWeekOfWeekyear());\n    assertEquals(7, test.getDayOfWeek());\n    assertEquals(160, test.getDayOfYear());\n    assertEquals(1, test.getHourOfDay());\n    assertEquals(0, test.getMinuteOfHour());\n    assertEquals(60, test.getMinuteOfDay());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(60 * 60, test.getSecondOfDay());\n    assertEquals(0, test.getMillisOfSecond());\n    assertEquals(60 * 60 * 1000, test.getMillisOfDay());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1338, "method_signature": "void testGetters()"}, "TestDateTime_Basics.testIsAfter_long": {"callee_method_names": [], "method_name": "TestDateTime_Basics.testIsAfter_long", "method_implementation": "{\n    assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME2));\n    assertEquals(false, new DateTime(TEST_TIME1).isAfter(TEST_TIME1));\n    assertEquals(true, new DateTime(TEST_TIME2).isAfter(TEST_TIME1));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1342, "method_signature": "void testIsAfter_long()"}, "TestDateTime_Basics.testIsBefore_long": {"callee_method_names": [], "method_name": "TestDateTime_Basics.testIsBefore_long", "method_implementation": "{\n    assertEquals(true, new DateTime(TEST_TIME1).isBefore(TEST_TIME2));\n    assertEquals(false, new DateTime(TEST_TIME1).isBefore(TEST_TIME1));\n    assertEquals(false, new DateTime(TEST_TIME2).isBefore(TEST_TIME1));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1341, "method_signature": "void testIsBefore_long()"}, "TestDateTime_Basics.testIsEqual_long": {"callee_method_names": [], "method_name": "TestDateTime_Basics.testIsEqual_long", "method_implementation": "{\n    assertEquals(false, new DateTime(TEST_TIME1).isEqual(TEST_TIME2));\n    assertEquals(true, new DateTime(TEST_TIME1).isEqual(TEST_TIME1));\n    assertEquals(false, new DateTime(TEST_TIME2).isEqual(TEST_TIME1));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1340, "method_signature": "void testIsEqual_long()"}, "TestDateTime_Basics.testMinus_long": {"callee_method_names": ["DateTime.minus"], "method_name": "TestDateTime_Basics.testMinus_long", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT);\n    DateTime result = test.minus(123456789L);\n    DateTime expected = new DateTime(TEST_TIME1 - 123456789L, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1356, "method_signature": "void testMinus_long()"}, "TestDateTime_Basics.testPlus_long": {"callee_method_names": ["DateTime.plus"], "method_name": "TestDateTime_Basics.testPlus_long", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT);\n    DateTime result = test.plus(123456789L);\n    DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1355, "method_signature": "void testPlus_long()"}, "TestDateTime_Basics.testProperty": {"callee_method_ids": [455, 455, 455, 455, 455, 455], "callee_method_names": ["DateTime.year", "DateTime.property", "DateTime.dayOfWeek", "DateTime.property", "DateTime.secondOfMinute", "DateTime.property", "DateTime.millisOfSecond", "DateTime.property", "DateTime.property", "DateTime.property"], "method_name": "TestDateTime_Basics.testProperty", "method_implementation": "{\n    DateTime test = new DateTime();\n    assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n    assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek()));\n    assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute()));\n    assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond()));\n    DateTimeFieldType bad = new DateTimeFieldType(\"bad\") {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public DurationFieldType getDurationType() {\n            return DurationFieldType.weeks();\n        }\n\n        @Override\n        public DurationFieldType getRangeDurationType() {\n            return null;\n        }\n\n        @Override\n        public DateTimeField getField(Chronology chronology) {\n            return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType()));\n        }\n    };\n    try {\n        test.property(bad);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1357, "method_signature": "void testProperty()"}, "TestDateTime_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestDateTime_Basics.testSerialization", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME_NOW);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    DateTime result = (DateTime) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1343, "method_signature": "void testSerialization()"}, "TestDateTime_Basics.testTest": {"callee_method_names": [], "method_name": "TestDateTime_Basics.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1336, "method_signature": "void testTest()"}, "TestDateTime_Basics.testToDateMidnight": {"callee_method_names": ["DateTime.toDateMidnight"], "method_name": "TestDateTime_Basics.testToDateMidnight", "method_implementation": "{\n    DateTime base = new DateTime(TEST_TIME1, COPTIC_DEFAULT);\n    DateMidnight test = base.toDateMidnight();\n    assertEquals(new DateMidnight(base, COPTIC_DEFAULT), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1346, "method_signature": "void testToDateMidnight()"}, "TestDateTime_Basics.testToInstant": {"callee_method_names": ["DateTime.toInstant", "Instant.getMillis"], "method_name": "TestDateTime_Basics.testToInstant", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1);\n    Instant result = test.toInstant();\n    assertEquals(TEST_TIME1, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1345, "method_signature": "void testToInstant()"}, "TestDateTime_Basics.testToString": {"callee_method_names": ["DateTime.toString", "DateTime.toString"], "method_name": "TestDateTime_Basics.testToString", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME_NOW);\n    assertEquals(\"2002-06-09T01:00:00.000+01:00\", test.toString());\n    test = new DateTime(TEST_TIME_NOW, PARIS);\n    assertEquals(\"2002-06-09T02:00:00.000+02:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1344, "method_signature": "void testToString()"}, "TestDateTime_Basics.testWithDate_int_int_int": {"callee_method_ids": [431, 431], "callee_method_names": ["DateTime.withDate", "DateTime.withDate"], "method_name": "TestDateTime_Basics.testWithDate_int_int_int", "method_implementation": "{\n    DateTime test = new DateTime(2002, 4, 5, 1, 2, 3, 4, ISO_UTC);\n    DateTime result = test.withDate(2003, 5, 6);\n    DateTime expected = new DateTime(2003, 5, 6, 1, 2, 3, 4, ISO_UTC);\n    assertEquals(expected, result);\n    test = new DateTime(TEST_TIME1);\n    try {\n        test.withDate(2003, 13, 1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1348, "method_signature": "void testWithDate_int_int_int()"}, "TestDateTime_Basics.testWithDurationAdded_RD_int": {"callee_method_ids": [437, 437, 437, 437, 437], "callee_method_names": ["DateTime.withDurationAdded", "DateTime.withDurationAdded", "DateTime.withDurationAdded", "DateTime.withDurationAdded", "DateTime.withDurationAdded"], "method_name": "TestDateTime_Basics.testWithDurationAdded_RD_int", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT);\n    DateTime result = test.withDurationAdded(new Duration(123456789L), 1);\n    DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(null, 1);\n    assertSame(test, result);\n    result = test.withDurationAdded(new Duration(123456789L), 0);\n    assertSame(test, result);\n    result = test.withDurationAdded(new Duration(123456789L), 2);\n    expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(new Duration(123456789L), -3);\n    expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1353, "method_signature": "void testWithDurationAdded_RD_int()"}, "TestDateTime_Basics.testWithDurationAdded_RP_int": {"callee_method_ids": [438, 438, 438, 438, 438], "callee_method_names": ["DateTime.withPeriodAdded", "DateTime.withPeriodAdded", "DateTime.withPeriodAdded", "DateTime.withPeriodAdded", "DateTime.withPeriodAdded"], "method_name": "TestDateTime_Basics.testWithDurationAdded_RP_int", "method_implementation": "{\n    DateTime test = new DateTime(2002, 5, 3, 1, 2, 3, 4, BUDDHIST_DEFAULT);\n    DateTime result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 1);\n    DateTime expected = new DateTime(2003, 7, 28, 6, 8, 10, 12, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withPeriodAdded(null, 1);\n    assertSame(test, result);\n    result = test.withPeriodAdded(new Period(1, 2, 3, 4, 5, 6, 7, 8), 0);\n    assertSame(test, result);\n    result = test.withPeriodAdded(new Period(1, 2, 0, 4, 5, 6, 7, 8), 3);\n    expected = new DateTime(2005, 11, 15, 16, 20, 24, 28, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withPeriodAdded(new Period(1, 2, 0, 1, 1, 2, 3, 4), -1);\n    expected = new DateTime(2001, 3, 2, 0, 0, 0, 0, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1354, "method_signature": "void testWithDurationAdded_RP_int()"}, "TestDateTime_Basics.testWithDurationAdded_long_int": {"callee_method_ids": [437, 437, 437, 437], "callee_method_names": ["DateTime.withDurationAdded", "DateTime.withDurationAdded", "DateTime.withDurationAdded", "DateTime.withDurationAdded"], "method_name": "TestDateTime_Basics.testWithDurationAdded_long_int", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1, BUDDHIST_DEFAULT);\n    DateTime result = test.withDurationAdded(123456789L, 1);\n    DateTime expected = new DateTime(TEST_TIME1 + 123456789L, BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(123456789L, 0);\n    assertSame(test, result);\n    result = test.withDurationAdded(123456789L, 2);\n    expected = new DateTime(TEST_TIME1 + (2L * 123456789L), BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(123456789L, -3);\n    expected = new DateTime(TEST_TIME1 - (3L * 123456789L), BUDDHIST_DEFAULT);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1352, "method_signature": "void testWithDurationAdded_long_int()"}, "TestDateTime_Basics.testWithField1": {"callee_method_ids": [434], "callee_method_names": ["DateTime.withField"], "method_name": "TestDateTime_Basics.testWithField1", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime result = test.withField(DateTimeFieldType.year(), 2006);\n    assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), test);\n    assertEquals(new DateTime(2006, 6, 9, 0, 0, 0, 0), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1350, "method_signature": "void testWithField1()"}, "TestDateTime_Basics.testWithFieldAdded1": {"callee_method_ids": [435], "callee_method_names": ["DateTime.withFieldAdded"], "method_name": "TestDateTime_Basics.testWithFieldAdded1", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime result = test.withFieldAdded(DurationFieldType.years(), 6);\n    assertEquals(new DateTime(2004, 6, 9, 0, 0, 0, 0), test);\n    assertEquals(new DateTime(2010, 6, 9, 0, 0, 0, 0), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1351, "method_signature": "void testWithFieldAdded1()"}, "TestDateTime_Basics.testWithMillis_long": {"callee_method_names": ["DateTime.withMillis", "DateTime.getMillis", "DateTime.getChronology", "DateTime.getChronology", "DateTime.withMillis", "DateTime.getMillis", "DateTime.getChronology", "DateTime.getChronology", "DateTime.withMillis"], "method_name": "TestDateTime_Basics.testWithMillis_long", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1);\n    DateTime result = test.withMillis(TEST_TIME2);\n    assertEquals(TEST_TIME2, result.getMillis());\n    assertEquals(test.getChronology(), result.getChronology());\n    test = new DateTime(TEST_TIME1, GREGORIAN_PARIS);\n    result = test.withMillis(TEST_TIME2);\n    assertEquals(TEST_TIME2, result.getMillis());\n    assertEquals(test.getChronology(), result.getChronology());\n    test = new DateTime(TEST_TIME1);\n    result = test.withMillis(TEST_TIME1);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1347, "method_signature": "void testWithMillis_long()"}, "TestDateTime_Basics.testWithTime_int_int_int_int": {"callee_method_ids": [432, 432], "callee_method_names": ["DateTime.withTime", "DateTime.getMillis", "DateTime.getChronology", "DateTime.withTime"], "method_name": "TestDateTime_Basics.testWithTime_int_int_int_int", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1 - 12345L, BUDDHIST_UTC);\n    DateTime result = test.withTime(12, 24, 0, 0);\n    assertEquals(TEST_TIME1, result.getMillis());\n    assertEquals(BUDDHIST_UTC, result.getChronology());\n    test = new DateTime(TEST_TIME1);\n    try {\n        test.withTime(25, 1, 1, 1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1349, "method_signature": "void testWithTime_int_int_int_int()"}, "TestDateTime_Constructors.testConstructor": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor", "method_implementation": "{\n    DateTime test = new DateTime();\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1708, "method_signature": "void testConstructor()"}, "TestDateTime_Constructors.testConstructor_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_Chronology", "method_implementation": "{\n    DateTime test = new DateTime(GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1711, "method_signature": "void testConstructor_Chronology()"}, "TestDateTime_Constructors.testConstructor_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_DateTimeZone", "method_implementation": "{\n    DateTime test = new DateTime(PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1709, "method_signature": "void testConstructor_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_Object": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_Object", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    DateTime test = new DateTime(date);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1721, "method_signature": "void testConstructor_Object()"}, "TestDateTime_Constructors.testConstructor_Object_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_Object_Chronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    DateTime test = new DateTime(date, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1731, "method_signature": "void testConstructor_Object_Chronology()"}, "TestDateTime_Constructors.testConstructor_Object_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_Object_DateTimeZone", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    DateTime test = new DateTime(date, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1725, "method_signature": "void testConstructor_Object_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_Object_nullChronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_Object_nullChronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    DateTime test = new DateTime(date, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1734, "method_signature": "void testConstructor_Object_nullChronology()"}, "TestDateTime_Constructors.testConstructor_Object_nullDateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_Object_nullDateTimeZone", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    DateTime test = new DateTime(date, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1728, "method_signature": "void testConstructor_Object_nullDateTimeZone()"}, "TestDateTime_Constructors.testConstructor_badconverterObject": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_badconverterObject", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        DateTime test = new DateTime(new Integer(0));\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(0L, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null)\n */\n", "repo_name": "joda-time-main/", "id": 1724, "method_signature": "void testConstructor_badconverterObject()"}, "TestDateTime_Constructors.testConstructor_badconverterObject_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_badconverterObject_Chronology", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(0L, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1736, "method_signature": "void testConstructor_badconverterObject_Chronology()"}, "TestDateTime_Constructors.testConstructor_badconverterObject_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_badconverterObject_DateTimeZone", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        DateTime test = new DateTime(new Integer(0), GregorianChronology.getInstance());\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(0L, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1730, "method_signature": "void testConstructor_badconverterObject_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int": {"callee_method_names": ["DateTime.getChronology", "DateTime.getZone", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(LONDON, test.getZone());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1737, "method_signature": "void testConstructor_int_int_int_int_int()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_Chronology", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1740, "method_signature": "void testConstructor_int_int_int_int_int_Chronology()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_DateTimeZone", "method_implementation": "{\n    // +02:00\n    DateTime test = new DateTime(2002, 6, 9, 2, 0, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1738, "method_signature": "void testConstructor_int_int_int_int_int_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int": {"callee_method_names": ["DateTime.getChronology", "DateTime.getZone", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, 0);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(LONDON, test.getZone());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1742, "method_signature": "void testConstructor_int_int_int_int_int_int()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_Chronology", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1745, "method_signature": "void testConstructor_int_int_int_int_int_int_Chronology()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_DateTimeZone", "method_implementation": "{\n    // +02:00\n    DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int, int, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1743, "method_signature": "void testConstructor_int_int_int_int_int_int_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int": {"callee_method_names": ["DateTime.getChronology", "DateTime.getZone", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(LONDON, test.getZone());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n    try {\n        new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 0, 9, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 13, 9, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 6, 0, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 6, 31, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new DateTime(2002, 7, 31, 0, 0, 0, 0);\n    try {\n        new DateTime(2002, 7, 32, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1747, "method_signature": "void testConstructor_int_int_int_int_int_int_int()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_Chronology", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n    try {\n        new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new DateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n    try {\n        new DateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1750, "method_signature": "void testConstructor_int_int_int_int_int_int_int_Chronology()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_DateTimeZone", "method_implementation": "{\n    // +02:00\n    DateTime test = new DateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n    try {\n        new DateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new DateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new DateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);\n    try {\n        new DateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1748, "method_signature": "void testConstructor_int_int_int_int_int_int_int_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullChronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullChronology", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1751, "method_signature": "void testConstructor_int_int_int_int_int_int_int_nullChronology()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullDateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullDateTimeZone", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1749, "method_signature": "void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_nullChronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_nullChronology", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1746, "method_signature": "void testConstructor_int_int_int_int_int_int_nullChronology()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_nullDateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_int_nullDateTimeZone", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, 0, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int, int, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1744, "method_signature": "void testConstructor_int_int_int_int_int_int_nullDateTimeZone()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_nullChronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_nullChronology", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1741, "method_signature": "void testConstructor_int_int_int_int_int_nullChronology()"}, "TestDateTime_Constructors.testConstructor_int_int_int_int_int_nullDateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_int_int_int_int_int_nullDateTimeZone", "method_implementation": "{\n    // +01:00\n    DateTime test = new DateTime(2002, 6, 9, 1, 0, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, int, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1739, "method_signature": "void testConstructor_int_int_int_int_int_nullDateTimeZone()"}, "TestDateTime_Constructors.testConstructor_invalidObject": {"callee_method_names": [], "method_name": "TestDateTime_Constructors.testConstructor_invalidObject", "method_implementation": "{\n    try {\n        new DateTime(new Object());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1722, "method_signature": "void testConstructor_invalidObject()"}, "TestDateTime_Constructors.testConstructor_invalidObject_Chronology": {"callee_method_names": [], "method_name": "TestDateTime_Constructors.testConstructor_invalidObject_Chronology", "method_implementation": "{\n    try {\n        new DateTime(new Object(), GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1732, "method_signature": "void testConstructor_invalidObject_Chronology()"}, "TestDateTime_Constructors.testConstructor_invalidObject_DateTimeZone": {"callee_method_names": [], "method_name": "TestDateTime_Constructors.testConstructor_invalidObject_DateTimeZone", "method_implementation": "{\n    try {\n        new DateTime(new Object(), PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1726, "method_signature": "void testConstructor_invalidObject_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_long1": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_long1", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1713, "method_signature": "void testConstructor_long1()"}, "TestDateTime_Constructors.testConstructor_long1_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_long1_Chronology", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1718, "method_signature": "void testConstructor_long1_Chronology()"}, "TestDateTime_Constructors.testConstructor_long1_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_long1_DateTimeZone", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1715, "method_signature": "void testConstructor_long1_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_long2": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_long2", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME2);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME2, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1714, "method_signature": "void testConstructor_long2()"}, "TestDateTime_Constructors.testConstructor_long2_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_long2_Chronology", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME2, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME2, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1719, "method_signature": "void testConstructor_long2_Chronology()"}, "TestDateTime_Constructors.testConstructor_long2_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_long2_DateTimeZone", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME2, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME2, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1716, "method_signature": "void testConstructor_long2_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_long_nullChronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_long_nullChronology", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1720, "method_signature": "void testConstructor_long_nullChronology()"}, "TestDateTime_Constructors.testConstructor_long_nullDateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_long_nullDateTimeZone", "method_implementation": "{\n    DateTime test = new DateTime(TEST_TIME1, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1717, "method_signature": "void testConstructor_long_nullDateTimeZone()"}, "TestDateTime_Constructors.testConstructor_nullChronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_nullChronology", "method_implementation": "{\n    DateTime test = new DateTime((Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1712, "method_signature": "void testConstructor_nullChronology()"}, "TestDateTime_Constructors.testConstructor_nullDateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_nullDateTimeZone", "method_implementation": "{\n    DateTime test = new DateTime((DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1710, "method_signature": "void testConstructor_nullDateTimeZone()"}, "TestDateTime_Constructors.testConstructor_nullObject": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_nullObject", "method_implementation": "{\n    DateTime test = new DateTime((Object) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null)\n */\n", "repo_name": "joda-time-main/", "id": 1723, "method_signature": "void testConstructor_nullObject()"}, "TestDateTime_Constructors.testConstructor_nullObject_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_nullObject_Chronology", "method_implementation": "{\n    DateTime test = new DateTime((Object) null, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1733, "method_signature": "void testConstructor_nullObject_Chronology()"}, "TestDateTime_Constructors.testConstructor_nullObject_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_nullObject_DateTimeZone", "method_implementation": "{\n    DateTime test = new DateTime((Object) null, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1727, "method_signature": "void testConstructor_nullObject_DateTimeZone()"}, "TestDateTime_Constructors.testConstructor_nullObject_nullChronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_nullObject_nullChronology", "method_implementation": "{\n    DateTime test = new DateTime((Object) null, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1735, "method_signature": "void testConstructor_nullObject_nullChronology()"}, "TestDateTime_Constructors.testConstructor_nullObject_nullDateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.testConstructor_nullObject_nullDateTimeZone", "method_implementation": "{\n    DateTime test = new DateTime((Object) null, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1729, "method_signature": "void testConstructor_nullObject_nullDateTimeZone()"}, "TestDateTime_Constructors.testTest": {"callee_method_names": [], "method_name": "TestDateTime_Constructors.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1702, "method_signature": "void testTest()"}, "TestDateTime_Constructors.test_now": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.test_now", "method_implementation": "{\n    DateTime test = DateTime.now();\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test now ()\n */\n", "repo_name": "joda-time-main/", "id": 1703, "method_signature": "void test_now()"}, "TestDateTime_Constructors.test_now_Chronology": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.test_now_Chronology", "method_implementation": "{\n    DateTime test = DateTime.now(GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test now (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1706, "method_signature": "void test_now_Chronology()"}, "TestDateTime_Constructors.test_now_DateTimeZone": {"callee_method_names": ["DateTime.getChronology", "DateTime.getMillis"], "method_name": "TestDateTime_Constructors.test_now_DateTimeZone", "method_implementation": "{\n    DateTime test = DateTime.now(PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test now (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1704, "method_signature": "void test_now_DateTimeZone()"}, "TestDateTime_Constructors.test_now_nullChronology": {"callee_method_names": [], "method_name": "TestDateTime_Constructors.test_now_nullChronology", "method_implementation": "{\n    try {\n        DateTime.now((Chronology) null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test now (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1707, "method_signature": "void test_now_nullChronology()"}, "TestDateTime_Constructors.test_now_nullDateTimeZone": {"callee_method_names": [], "method_name": "TestDateTime_Constructors.test_now_nullDateTimeZone", "method_implementation": "{\n    try {\n        DateTime.now((DateTimeZone) null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test now (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1705, "method_signature": "void test_now_nullDateTimeZone()"}, "TestDateTime_Properties.testPropertyGetCenturyOfEra": {"callee_method_names": ["DateTime.getChronology", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.getChronology", "DateTime.centuryOfEra", "DateTime.getChronology", "DateTime.centuryOfEra", "DateTime.centuryOfEra", "DateTime.centuryOfEra"], "method_name": "TestDateTime_Properties.testPropertyGetCenturyOfEra", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());\n    assertEquals(\"centuryOfEra\", test.centuryOfEra().getName());\n    assertEquals(\"Property[centuryOfEra]\", test.centuryOfEra().toString());\n    assertSame(test, test.centuryOfEra().getDateTime());\n    assertEquals(20, test.centuryOfEra().get());\n    assertEquals(\"20\", test.centuryOfEra().getAsString());\n    assertEquals(\"20\", test.centuryOfEra().getAsText());\n    assertEquals(\"20\", test.centuryOfEra().getAsText(Locale.FRENCH));\n    assertEquals(\"20\", test.centuryOfEra().getAsShortText());\n    assertEquals(\"20\", test.centuryOfEra().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());\n    assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField());\n    assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));\n    assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2132, "method_signature": "void testPropertyGetCenturyOfEra()"}, "TestDateTime_Properties.testPropertyGetDayOfMonth": {"callee_method_names": ["DateTime.getChronology", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.getChronology", "DateTime.dayOfMonth", "DateTime.getChronology", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth", "DateTime.dayOfMonth"], "method_name": "TestDateTime_Properties.testPropertyGetDayOfMonth", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n    assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n    assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n    assertSame(test, test.dayOfMonth().getDateTime());\n    assertEquals(9, test.dayOfMonth().get());\n    assertEquals(\"9\", test.dayOfMonth().getAsString());\n    assertEquals(\"9\", test.dayOfMonth().getAsText());\n    assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText());\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n    assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n    assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n    assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n    assertEquals(1, test.dayOfMonth().getMinimumValue());\n    assertEquals(1, test.dayOfMonth().getMinimumValueOverall());\n    assertEquals(30, test.dayOfMonth().getMaximumValue());\n    assertEquals(31, test.dayOfMonth().getMaximumValueOverall());\n    assertEquals(false, test.dayOfMonth().isLeap());\n    assertEquals(0, test.dayOfMonth().getLeapAmount());\n    assertEquals(null, test.dayOfMonth().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2137, "method_signature": "void testPropertyGetDayOfMonth()"}, "TestDateTime_Properties.testPropertyGetDayOfWeek": {"callee_method_names": ["DateTime.getChronology", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.getChronology", "DateTime.dayOfWeek", "DateTime.getChronology", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek", "DateTime.dayOfWeek"], "method_name": "TestDateTime_Properties.testPropertyGetDayOfWeek", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());\n    assertEquals(\"dayOfWeek\", test.dayOfWeek().getName());\n    assertEquals(\"Property[dayOfWeek]\", test.dayOfWeek().toString());\n    assertSame(test, test.dayOfWeek().getDateTime());\n    assertEquals(3, test.dayOfWeek().get());\n    assertEquals(\"3\", test.dayOfWeek().getAsString());\n    assertEquals(\"Wednesday\", test.dayOfWeek().getAsText());\n    assertEquals(\"Wednesday\", test.dayOfWeek().getField().getAsText(3, Locale.ENGLISH));\n    assertEquals(\"mercredi\", test.dayOfWeek().getAsText(Locale.FRENCH));\n    assertEquals(\"mercredi\", test.dayOfWeek().getField().getAsText(3, Locale.FRENCH));\n    assertEquals(\"Wed\", test.dayOfWeek().getAsShortText());\n    assertEquals(\"Wed\", test.dayOfWeek().getField().getAsShortText(3, Locale.ENGLISH));\n    assertEquals(\"mer.\", test.dayOfWeek().getAsShortText(Locale.FRENCH));\n    assertEquals(\"mer.\", test.dayOfWeek().getField().getAsShortText(3, Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());\n    assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());\n    assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));\n    assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));\n    assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));\n    assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));\n    assertEquals(1, test.dayOfWeek().getMinimumValue());\n    assertEquals(1, test.dayOfWeek().getMinimumValueOverall());\n    assertEquals(7, test.dayOfWeek().getMaximumValue());\n    assertEquals(7, test.dayOfWeek().getMaximumValueOverall());\n    assertEquals(false, test.dayOfWeek().isLeap());\n    assertEquals(0, test.dayOfWeek().getLeapAmount());\n    assertEquals(null, test.dayOfWeek().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2140, "method_signature": "void testPropertyGetDayOfWeek()"}, "TestDateTime_Properties.testPropertyGetDayOfYear": {"callee_method_names": ["DateTime.getChronology", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.getChronology", "DateTime.dayOfYear", "DateTime.getChronology", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear", "DateTime.dayOfYear"], "method_name": "TestDateTime_Properties.testPropertyGetDayOfYear", "method_implementation": "{\n    // 31+29+31+30+31+9 = 161\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());\n    assertEquals(\"dayOfYear\", test.dayOfYear().getName());\n    assertEquals(\"Property[dayOfYear]\", test.dayOfYear().toString());\n    assertSame(test, test.dayOfYear().getDateTime());\n    assertEquals(161, test.dayOfYear().get());\n    assertEquals(\"161\", test.dayOfYear().getAsString());\n    assertEquals(\"161\", test.dayOfYear().getAsText());\n    assertEquals(\"161\", test.dayOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"161\", test.dayOfYear().getAsShortText());\n    assertEquals(\"161\", test.dayOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());\n    assertEquals(3, test.dayOfYear().getMaximumTextLength(null));\n    assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));\n    assertEquals(false, test.dayOfYear().isLeap());\n    assertEquals(0, test.dayOfYear().getLeapAmount());\n    assertEquals(null, test.dayOfYear().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2138, "method_signature": "void testPropertyGetDayOfYear()"}, "TestDateTime_Properties.testPropertyGetEra": {"callee_method_names": ["DateTime.getChronology", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.getChronology", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era", "DateTime.era"], "method_name": "TestDateTime_Properties.testPropertyGetEra", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().era(), test.era().getField());\n    assertEquals(\"era\", test.era().getName());\n    assertEquals(\"Property[era]\", test.era().toString());\n    assertSame(test, test.era().getDateTime());\n    assertEquals(1, test.era().get());\n    assertEquals(\"1\", test.era().getAsString());\n    assertEquals(\"AD\", test.era().getAsText());\n    assertEquals(\"AD\", test.era().getField().getAsText(1, Locale.ENGLISH));\n    assertEquals(\"ap. J.-C.\", test.era().getAsText(Locale.FRENCH));\n    assertEquals(\"ap. J.-C.\", test.era().getField().getAsText(1, Locale.FRENCH));\n    assertEquals(\"AD\", test.era().getAsShortText());\n    assertEquals(\"AD\", test.era().getField().getAsShortText(1, Locale.ENGLISH));\n    assertEquals(\"ap. J.-C.\", test.era().getAsShortText(Locale.FRENCH));\n    assertEquals(\"ap. J.-C.\", test.era().getField().getAsShortText(1, Locale.FRENCH));\n    assertEquals(test.getChronology().eras(), test.era().getDurationField());\n    assertEquals(null, test.era().getRangeDurationField());\n    assertEquals(2, test.era().getMaximumTextLength(null));\n    assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));\n    assertEquals(2, test.era().getMaximumShortTextLength(null));\n    assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2130, "method_signature": "void testPropertyGetEra()"}, "TestDateTime_Properties.testPropertyGetHourOfDay": {"callee_method_names": ["DateTime.getChronology", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.getChronology", "DateTime.hourOfDay", "DateTime.getChronology", "DateTime.hourOfDay", "DateTime.hourOfDay", "DateTime.hourOfDay"], "method_name": "TestDateTime_Properties.testPropertyGetHourOfDay", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n    assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n    assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n    assertSame(test, test.hourOfDay().getDateTime());\n    assertEquals(13, test.hourOfDay().get());\n    assertEquals(\"13\", test.hourOfDay().getAsString());\n    assertEquals(\"13\", test.hourOfDay().getAsText());\n    assertEquals(\"13\", test.hourOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"13\", test.hourOfDay().getAsShortText());\n    assertEquals(\"13\", test.hourOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());\n    assertEquals(2, test.hourOfDay().getMaximumTextLength(null));\n    assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2141, "method_signature": "void testPropertyGetHourOfDay()"}, "TestDateTime_Properties.testPropertyGetMillisOfDay": {"callee_method_names": ["DateTime.getChronology", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.getChronology", "DateTime.millisOfDay", "DateTime.getChronology", "DateTime.millisOfDay", "DateTime.millisOfDay", "DateTime.millisOfDay"], "method_name": "TestDateTime_Properties.testPropertyGetMillisOfDay", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField());\n    assertEquals(\"millisOfDay\", test.millisOfDay().getName());\n    assertEquals(\"Property[millisOfDay]\", test.millisOfDay().toString());\n    assertSame(test, test.millisOfDay().getDateTime());\n    assertEquals(48223053, test.millisOfDay().get());\n    assertEquals(\"48223053\", test.millisOfDay().getAsString());\n    assertEquals(\"48223053\", test.millisOfDay().getAsText());\n    assertEquals(\"48223053\", test.millisOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"48223053\", test.millisOfDay().getAsShortText());\n    assertEquals(\"48223053\", test.millisOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField());\n    assertEquals(8, test.millisOfDay().getMaximumTextLength(null));\n    assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2147, "method_signature": "void testPropertyGetMillisOfDay()"}, "TestDateTime_Properties.testPropertyGetMillisOfSecond": {"callee_method_names": ["DateTime.getChronology", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.getChronology", "DateTime.millisOfSecond", "DateTime.getChronology", "DateTime.millisOfSecond", "DateTime.millisOfSecond", "DateTime.millisOfSecond"], "method_name": "TestDateTime_Properties.testPropertyGetMillisOfSecond", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n    assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n    assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n    assertSame(test, test.millisOfSecond().getDateTime());\n    assertEquals(53, test.millisOfSecond().get());\n    assertEquals(\"53\", test.millisOfSecond().getAsString());\n    assertEquals(\"53\", test.millisOfSecond().getAsText());\n    assertEquals(\"53\", test.millisOfSecond().getAsText(Locale.FRENCH));\n    assertEquals(\"53\", test.millisOfSecond().getAsShortText());\n    assertEquals(\"53\", test.millisOfSecond().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());\n    assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());\n    assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));\n    assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2146, "method_signature": "void testPropertyGetMillisOfSecond()"}, "TestDateTime_Properties.testPropertyGetMinuteOfDay": {"callee_method_names": ["DateTime.getChronology", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.getChronology", "DateTime.minuteOfDay", "DateTime.getChronology", "DateTime.minuteOfDay", "DateTime.minuteOfDay", "DateTime.minuteOfDay"], "method_name": "TestDateTime_Properties.testPropertyGetMinuteOfDay", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField());\n    assertEquals(\"minuteOfDay\", test.minuteOfDay().getName());\n    assertEquals(\"Property[minuteOfDay]\", test.minuteOfDay().toString());\n    assertSame(test, test.minuteOfDay().getDateTime());\n    assertEquals(803, test.minuteOfDay().get());\n    assertEquals(\"803\", test.minuteOfDay().getAsString());\n    assertEquals(\"803\", test.minuteOfDay().getAsText());\n    assertEquals(\"803\", test.minuteOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"803\", test.minuteOfDay().getAsShortText());\n    assertEquals(\"803\", test.minuteOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField());\n    assertEquals(4, test.minuteOfDay().getMaximumTextLength(null));\n    assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2143, "method_signature": "void testPropertyGetMinuteOfDay()"}, "TestDateTime_Properties.testPropertyGetMinuteOfHour": {"callee_method_names": ["DateTime.getChronology", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.getChronology", "DateTime.minuteOfHour", "DateTime.getChronology", "DateTime.minuteOfHour", "DateTime.minuteOfHour", "DateTime.minuteOfHour"], "method_name": "TestDateTime_Properties.testPropertyGetMinuteOfHour", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n    assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n    assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n    assertSame(test, test.minuteOfHour().getDateTime());\n    assertEquals(23, test.minuteOfHour().get());\n    assertEquals(\"23\", test.minuteOfHour().getAsString());\n    assertEquals(\"23\", test.minuteOfHour().getAsText());\n    assertEquals(\"23\", test.minuteOfHour().getAsText(Locale.FRENCH));\n    assertEquals(\"23\", test.minuteOfHour().getAsShortText());\n    assertEquals(\"23\", test.minuteOfHour().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());\n    assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());\n    assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));\n    assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2142, "method_signature": "void testPropertyGetMinuteOfHour()"}, "TestDateTime_Properties.testPropertyGetMonthOfYear": {"callee_method_names": ["DateTime.getChronology", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.getChronology", "DateTime.monthOfYear", "DateTime.getChronology", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear", "DateTime.monthOfYear"], "method_name": "TestDateTime_Properties.testPropertyGetMonthOfYear", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n    assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n    assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n    assertSame(test, test.monthOfYear().getDateTime());\n    assertEquals(6, test.monthOfYear().get());\n    assertEquals(\"6\", test.monthOfYear().getAsString());\n    assertEquals(\"June\", test.monthOfYear().getAsText());\n    assertEquals(\"June\", test.monthOfYear().getField().getAsText(6, Locale.ENGLISH));\n    assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"juin\", test.monthOfYear().getField().getAsText(6, Locale.FRENCH));\n    assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n    assertEquals(\"Jun\", test.monthOfYear().getField().getAsShortText(6, Locale.ENGLISH));\n    assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(\"juin\", test.monthOfYear().getField().getAsShortText(6, Locale.FRENCH));\n    assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n    assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n    int max = test.monthOfYear().getMaximumShortTextLength(null);\n    // for JDK17+\n    assertTrue(max == 3 || max == 4);\n    test = new DateTime(2004, 7, 9, 0, 0, 0, 0);\n    assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"juillet\", test.monthOfYear().getField().getAsText(7, Locale.FRENCH));\n    assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(\"juil.\", test.monthOfYear().getField().getAsShortText(7, Locale.FRENCH));\n    assertEquals(1, test.monthOfYear().getMinimumValue());\n    assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n    assertEquals(12, test.monthOfYear().getMaximumValue());\n    assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n    assertEquals(1, test.monthOfYear().getMinimumValue());\n    assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n    assertEquals(12, test.monthOfYear().getMaximumValue());\n    assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2136, "method_signature": "void testPropertyGetMonthOfYear()"}, "TestDateTime_Properties.testPropertyGetSecondOfDay": {"callee_method_names": ["DateTime.getChronology", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.getChronology", "DateTime.secondOfDay", "DateTime.getChronology", "DateTime.secondOfDay", "DateTime.secondOfDay", "DateTime.secondOfDay"], "method_name": "TestDateTime_Properties.testPropertyGetSecondOfDay", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField());\n    assertEquals(\"secondOfDay\", test.secondOfDay().getName());\n    assertEquals(\"Property[secondOfDay]\", test.secondOfDay().toString());\n    assertSame(test, test.secondOfDay().getDateTime());\n    assertEquals(48223, test.secondOfDay().get());\n    assertEquals(\"48223\", test.secondOfDay().getAsString());\n    assertEquals(\"48223\", test.secondOfDay().getAsText());\n    assertEquals(\"48223\", test.secondOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"48223\", test.secondOfDay().getAsShortText());\n    assertEquals(\"48223\", test.secondOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField());\n    assertEquals(5, test.secondOfDay().getMaximumTextLength(null));\n    assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2145, "method_signature": "void testPropertyGetSecondOfDay()"}, "TestDateTime_Properties.testPropertyGetSecondOfMinute": {"callee_method_names": ["DateTime.getChronology", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.getChronology", "DateTime.secondOfMinute", "DateTime.getChronology", "DateTime.secondOfMinute", "DateTime.secondOfMinute", "DateTime.secondOfMinute"], "method_name": "TestDateTime_Properties.testPropertyGetSecondOfMinute", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n    assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n    assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n    assertSame(test, test.secondOfMinute().getDateTime());\n    assertEquals(43, test.secondOfMinute().get());\n    assertEquals(\"43\", test.secondOfMinute().getAsString());\n    assertEquals(\"43\", test.secondOfMinute().getAsText());\n    assertEquals(\"43\", test.secondOfMinute().getAsText(Locale.FRENCH));\n    assertEquals(\"43\", test.secondOfMinute().getAsShortText());\n    assertEquals(\"43\", test.secondOfMinute().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());\n    assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());\n    assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));\n    assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2144, "method_signature": "void testPropertyGetSecondOfMinute()"}, "TestDateTime_Properties.testPropertyGetWeekOfWeekyear": {"callee_method_names": ["DateTime.getChronology", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.getChronology", "DateTime.weekOfWeekyear", "DateTime.getChronology", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear", "DateTime.weekOfWeekyear"], "method_name": "TestDateTime_Properties.testPropertyGetWeekOfWeekyear", "method_implementation": "{\n    // 2002-01-01 = Thu\n    // 2002-12-31 = Thu (+364 days)\n    // 2003-12-30 = Thu (+364 days)\n    // 2004-01-03 = Mon             W1\n    // 2004-01-31 = Mon (+28 days)  W5\n    // 2004-02-28 = Mon (+28 days)  W9\n    // 2004-03-27 = Mon (+28 days)  W13\n    // 2004-04-24 = Mon (+28 days)  W17\n    // 2004-05-23 = Mon (+28 days)  W21\n    // 2004-06-05 = Mon (+14 days)  W23\n    // 2004-06-09 = Fri\n    // 2004-12-25 = Mon             W52\n    // 2005-01-01 = Mon             W1\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());\n    assertEquals(\"weekOfWeekyear\", test.weekOfWeekyear().getName());\n    assertEquals(\"Property[weekOfWeekyear]\", test.weekOfWeekyear().toString());\n    assertSame(test, test.weekOfWeekyear().getDateTime());\n    assertEquals(24, test.weekOfWeekyear().get());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsString());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsText());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsText(Locale.FRENCH));\n    assertEquals(\"24\", test.weekOfWeekyear().getAsShortText());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());\n    assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());\n    assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));\n    assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));\n    assertEquals(false, test.weekOfWeekyear().isLeap());\n    assertEquals(0, test.weekOfWeekyear().getLeapAmount());\n    assertEquals(null, test.weekOfWeekyear().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2139, "method_signature": "void testPropertyGetWeekOfWeekyear()"}, "TestDateTime_Properties.testPropertyGetWeekyear": {"callee_method_names": ["DateTime.getChronology", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear", "DateTime.getChronology", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear", "DateTime.weekyear"], "method_name": "TestDateTime_Properties.testPropertyGetWeekyear", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().weekyear(), test.weekyear().getField());\n    assertEquals(\"weekyear\", test.weekyear().getName());\n    assertEquals(\"Property[weekyear]\", test.weekyear().toString());\n    assertSame(test, test.weekyear().getDateTime());\n    assertEquals(2004, test.weekyear().get());\n    assertEquals(\"2004\", test.weekyear().getAsString());\n    assertEquals(\"2004\", test.weekyear().getAsText());\n    assertEquals(\"2004\", test.weekyear().getAsText(Locale.FRENCH));\n    assertEquals(\"2004\", test.weekyear().getAsShortText());\n    assertEquals(\"2004\", test.weekyear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());\n    assertEquals(null, test.weekyear().getRangeDurationField());\n    assertEquals(9, test.weekyear().getMaximumTextLength(null));\n    assertEquals(9, test.weekyear().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2134, "method_signature": "void testPropertyGetWeekyear()"}, "TestDateTime_Properties.testPropertyGetYear": {"callee_method_names": ["DateTime.getChronology", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.getChronology", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year", "DateTime.year"], "method_name": "TestDateTime_Properties.testPropertyGetYear", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().year(), test.year().getField());\n    assertEquals(\"year\", test.year().getName());\n    assertEquals(\"Property[year]\", test.year().toString());\n    assertSame(test, test.year().getDateTime());\n    assertEquals(2004, test.year().get());\n    assertEquals(\"2004\", test.year().getAsString());\n    assertEquals(\"2004\", test.year().getAsText());\n    assertEquals(\"2004\", test.year().getAsText(Locale.FRENCH));\n    assertEquals(\"2004\", test.year().getAsShortText());\n    assertEquals(\"2004\", test.year().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.year().getDurationField());\n    assertEquals(null, test.year().getRangeDurationField());\n    assertEquals(9, test.year().getMaximumTextLength(null));\n    assertEquals(9, test.year().getMaximumShortTextLength(null));\n    assertEquals(-292275054, test.year().getMinimumValue());\n    assertEquals(-292275054, test.year().getMinimumValueOverall());\n    assertEquals(292278993, test.year().getMaximumValue());\n    assertEquals(292278993, test.year().getMaximumValueOverall());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2135, "method_signature": "void testPropertyGetYear()"}, "TestDateTime_Properties.testPropertyGetYearOfCentury": {"callee_method_names": ["DateTime.getChronology", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.getChronology", "DateTime.yearOfCentury", "DateTime.getChronology", "DateTime.yearOfCentury", "DateTime.yearOfCentury", "DateTime.yearOfCentury"], "method_name": "TestDateTime_Properties.testPropertyGetYearOfCentury", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());\n    assertEquals(\"yearOfCentury\", test.yearOfCentury().getName());\n    assertEquals(\"Property[yearOfCentury]\", test.yearOfCentury().toString());\n    assertSame(test, test.yearOfCentury().getDateTime());\n    assertEquals(4, test.yearOfCentury().get());\n    assertEquals(\"4\", test.yearOfCentury().getAsString());\n    assertEquals(\"4\", test.yearOfCentury().getAsText());\n    assertEquals(\"4\", test.yearOfCentury().getAsText(Locale.FRENCH));\n    assertEquals(\"4\", test.yearOfCentury().getAsShortText());\n    assertEquals(\"4\", test.yearOfCentury().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());\n    assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());\n    assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));\n    assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2133, "method_signature": "void testPropertyGetYearOfCentury()"}, "TestDateTime_Properties.testPropertyGetYearOfEra": {"callee_method_names": ["DateTime.getChronology", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.getChronology", "DateTime.yearOfEra", "DateTime.getChronology", "DateTime.yearOfEra", "DateTime.yearOfEra", "DateTime.yearOfEra"], "method_name": "TestDateTime_Properties.testPropertyGetYearOfEra", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());\n    assertEquals(\"yearOfEra\", test.yearOfEra().getName());\n    assertEquals(\"Property[yearOfEra]\", test.yearOfEra().toString());\n    assertSame(test, test.yearOfEra().getDateTime());\n    assertEquals(2004, test.yearOfEra().get());\n    assertEquals(\"2004\", test.yearOfEra().getAsString());\n    assertEquals(\"2004\", test.yearOfEra().getAsText());\n    assertEquals(\"2004\", test.yearOfEra().getAsText(Locale.FRENCH));\n    assertEquals(\"2004\", test.yearOfEra().getAsShortText());\n    assertEquals(\"2004\", test.yearOfEra().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());\n    assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField());\n    assertEquals(9, test.yearOfEra().getMaximumTextLength(null));\n    assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2131, "method_signature": "void testPropertyGetYearOfEra()"}, "TestDateTime_Properties.testPropertyToIntervalYearOfEra": {"callee_method_names": ["DateTime.yearOfEra", "Interval.getStart", "Interval.getEnd"], "method_name": "TestDateTime_Properties.testPropertyToIntervalYearOfEra", "method_implementation": "{\n    DateTime test = new DateTime(2004, 6, 9, 13, 23, 43, 53);\n    Interval testInterval = test.yearOfEra().toInterval();\n    assertEquals(new DateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart());\n    assertEquals(new DateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2148, "method_signature": "void testPropertyToIntervalYearOfEra()"}, "TestDateTime_Properties.testTest": {"callee_method_names": [], "method_name": "TestDateTime_Properties.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2129, "method_signature": "void testTest()"}, "TestDays.testAddToLocalDate": {"callee_method_names": ["LocalDate.plus"], "method_name": "TestDays.testAddToLocalDate", "method_implementation": "{\n    Days test = Days.days(20);\n    LocalDate date = new LocalDate(2006, 6, 1);\n    LocalDate expected = new LocalDate(2006, 6, 21);\n    assertEquals(expected, date.plus(test));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1572, "method_signature": "void testAddToLocalDate()"}, "TestDays.testConstants": {"callee_method_names": [], "method_name": "TestDays.testConstants", "method_implementation": "{\n    assertEquals(0, Days.ZERO.getDays());\n    assertEquals(1, Days.ONE.getDays());\n    assertEquals(2, Days.TWO.getDays());\n    assertEquals(3, Days.THREE.getDays());\n    assertEquals(4, Days.FOUR.getDays());\n    assertEquals(5, Days.FIVE.getDays());\n    assertEquals(6, Days.SIX.getDays());\n    assertEquals(7, Days.SEVEN.getDays());\n    assertEquals(Integer.MAX_VALUE, Days.MAX_VALUE.getDays());\n    assertEquals(Integer.MIN_VALUE, Days.MIN_VALUE.getDays());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1561, "method_signature": "void testConstants()"}, "TestDays.testFactory_daysBetween_RInstant": {"callee_method_names": [], "method_name": "TestDays.testFactory_daysBetween_RInstant", "method_implementation": "{\n    DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n    DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS);\n    DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS);\n    assertEquals(3, Days.daysBetween(start, end1).getDays());\n    assertEquals(0, Days.daysBetween(start, start).getDays());\n    assertEquals(0, Days.daysBetween(end1, end1).getDays());\n    assertEquals(-3, Days.daysBetween(end1, start).getDays());\n    assertEquals(6, Days.daysBetween(start, end2).getDays());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1563, "method_signature": "void testFactory_daysBetween_RInstant()"}, "TestDays.testFactory_daysBetween_RPartial_LocalDate": {"callee_method_names": [], "method_name": "TestDays.testFactory_daysBetween_RPartial_LocalDate", "method_implementation": "{\n    LocalDate start = new LocalDate(2006, 6, 9);\n    LocalDate end1 = new LocalDate(2006, 6, 12);\n    YearMonthDay end2 = new YearMonthDay(2006, 6, 15);\n    assertEquals(3, Days.daysBetween(start, end1).getDays());\n    assertEquals(0, Days.daysBetween(start, start).getDays());\n    assertEquals(0, Days.daysBetween(end1, end1).getDays());\n    assertEquals(-3, Days.daysBetween(end1, start).getDays());\n    assertEquals(6, Days.daysBetween(start, end2).getDays());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1564, "method_signature": "void testFactory_daysBetween_RPartial_LocalDate()"}, "TestDays.testFactory_daysIn_RInterval": {"callee_method_names": [], "method_name": "TestDays.testFactory_daysIn_RInterval", "method_implementation": "{\n    DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n    DateTime end1 = new DateTime(2006, 6, 12, 12, 0, 0, 0, PARIS);\n    DateTime end2 = new DateTime(2006, 6, 15, 18, 0, 0, 0, PARIS);\n    assertEquals(0, Days.daysIn((ReadableInterval) null).getDays());\n    assertEquals(3, Days.daysIn(new Interval(start, end1)).getDays());\n    assertEquals(0, Days.daysIn(new Interval(start, start)).getDays());\n    assertEquals(0, Days.daysIn(new Interval(end1, end1)).getDays());\n    assertEquals(6, Days.daysIn(new Interval(start, end2)).getDays());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1565, "method_signature": "void testFactory_daysIn_RInterval()"}, "TestDays.testFactory_days_int": {"callee_method_names": [], "method_name": "TestDays.testFactory_days_int", "method_implementation": "{\n    assertSame(Days.ZERO, Days.days(0));\n    assertSame(Days.ONE, Days.days(1));\n    assertSame(Days.TWO, Days.days(2));\n    assertSame(Days.THREE, Days.days(3));\n    assertSame(Days.FOUR, Days.days(4));\n    assertSame(Days.FIVE, Days.days(5));\n    assertSame(Days.SIX, Days.days(6));\n    assertSame(Days.SEVEN, Days.days(7));\n    assertSame(Days.MAX_VALUE, Days.days(Integer.MAX_VALUE));\n    assertSame(Days.MIN_VALUE, Days.days(Integer.MIN_VALUE));\n    assertEquals(-1, Days.days(-1).getDays());\n    assertEquals(8, Days.days(8).getDays());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1562, "method_signature": "void testFactory_days_int()"}, "TestDays.testFactory_standardDaysIn_RPeriod": {"callee_method_names": [], "method_name": "TestDays.testFactory_standardDaysIn_RPeriod", "method_implementation": "{\n    assertEquals(0, Days.standardDaysIn((ReadablePeriod) null).getDays());\n    assertEquals(0, Days.standardDaysIn(Period.ZERO).getDays());\n    assertEquals(1, Days.standardDaysIn(new Period(0, 0, 0, 1, 0, 0, 0, 0)).getDays());\n    assertEquals(123, Days.standardDaysIn(Period.days(123)).getDays());\n    assertEquals(-987, Days.standardDaysIn(Period.days(-987)).getDays());\n    assertEquals(1, Days.standardDaysIn(Period.hours(47)).getDays());\n    assertEquals(2, Days.standardDaysIn(Period.hours(48)).getDays());\n    assertEquals(2, Days.standardDaysIn(Period.hours(49)).getDays());\n    assertEquals(14, Days.standardDaysIn(Period.weeks(2)).getDays());\n    try {\n        Days.standardDaysIn(Period.months(1));\n        fail();\n    } catch (IllegalArgumentException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1566, "method_signature": "void testFactory_standardDaysIn_RPeriod()"}, "TestDays.testIsGreaterThan": {"callee_method_names": [], "method_name": "TestDays.testIsGreaterThan", "method_implementation": "{\n    assertEquals(true, Days.THREE.isGreaterThan(Days.TWO));\n    assertEquals(false, Days.THREE.isGreaterThan(Days.THREE));\n    assertEquals(false, Days.TWO.isGreaterThan(Days.THREE));\n    assertEquals(true, Days.ONE.isGreaterThan(null));\n    assertEquals(false, Days.days(-1).isGreaterThan(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1567, "method_signature": "void testIsGreaterThan()"}, "TestDays.testPlus_int": {"callee_method_ids": [940], "callee_method_names": ["Days.plus", "Days.getDays", "Days.getDays"], "method_name": "TestDays.testPlus_int", "method_implementation": "{\n    Days test2 = Days.days(2);\n    Days result = test2.plus(3);\n    assertEquals(2, test2.getDays());\n    assertEquals(5, result.getDays());\n    assertEquals(1, Days.ONE.plus(0).getDays());\n    try {\n        Days.MAX_VALUE.plus(1);\n        fail();\n    } catch (ArithmeticException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1571, "method_signature": "void testPlus_int()"}, "TestDays.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestDays.testSerialization", "method_implementation": "{\n    Days test = Days.SEVEN;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Days result = (Days) ois.readObject();\n    ois.close();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1569, "method_signature": "void testSerialization()"}, "TestDays.testToStandardWeeks": {"callee_method_names": ["Days.toStandardWeeks"], "method_name": "TestDays.testToStandardWeeks", "method_implementation": "{\n    Days test = Days.days(14);\n    Weeks expected = Weeks.weeks(2);\n    assertEquals(expected, test.toStandardWeeks());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1570, "method_signature": "void testToStandardWeeks()"}, "TestDays.testToString": {"callee_method_ids": [945, 945], "callee_method_names": ["Days.toString", "Days.toString"], "method_name": "TestDays.testToString", "method_implementation": "{\n    Days test = Days.days(20);\n    assertEquals(\"P20D\", test.toString());\n    test = Days.days(-20);\n    assertEquals(\"P-20D\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1568, "method_signature": "void testToString()"}, "TestDurationField.test_subtract": {"callee_method_ids": [127, 127, 127, 127, 127, 127], "callee_method_names": ["DurationField.subtract", "DurationField.subtract", "DurationField.subtract", "DurationField.subtract", "DurationField.subtract", "DurationField.subtract"], "method_name": "TestDurationField.test_subtract", "method_implementation": "{\n    DurationField fld = ISOChronology.getInstanceUTC().millis();\n    assertEquals(900, fld.subtract(1000L, 100));\n    assertEquals(900L, fld.subtract(1000L, 100L));\n    assertEquals((1000L - Integer.MAX_VALUE), fld.subtract(1000L, Integer.MAX_VALUE));\n    assertEquals((1000L - Integer.MIN_VALUE), fld.subtract(1000L, Integer.MIN_VALUE));\n    assertEquals((1000L - Long.MAX_VALUE), fld.subtract(1000L, Long.MAX_VALUE));\n    try {\n        fld.subtract(-1000L, Long.MIN_VALUE);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2060, "method_signature": "void test_subtract()"}, "TestDurationFieldType.test_eras": {"callee_method_names": [], "method_name": "TestDurationFieldType.test_eras", "method_implementation": "{\n    assertEquals(DurationFieldType.eras(), DurationFieldType.eras());\n    assertEquals(\"eras\", DurationFieldType.eras().getName());\n    assertEquals(CopticChronology.getInstanceUTC().eras(), DurationFieldType.eras().getField(CopticChronology.getInstanceUTC()));\n    assertEquals(CopticChronology.getInstanceUTC().eras().isSupported(), DurationFieldType.eras().isSupported(CopticChronology.getInstanceUTC()));\n    assertSerialization(DurationFieldType.eras());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2194, "method_signature": "void test_eras()"}, "TestDuration_Basics.testAbs": {"callee_method_names": [], "method_name": "TestDuration_Basics.testAbs", "method_implementation": "{\n    assertEquals(246L, new Duration(246L).abs().getMillis());\n    assertEquals(0L, new Duration(0L).abs().getMillis());\n    assertEquals(246L, new Duration(-246L).abs().getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2566, "method_signature": "void testAbs()"}, "TestDuration_Basics.testDividedByRoundingMode_long1": {"callee_method_ids": [570], "callee_method_names": ["Duration.dividedBy", "Duration.getMillis"], "method_name": "TestDuration_Basics.testDividedByRoundingMode_long1", "method_implementation": "{\n    Duration test = new Duration(246L);\n    Duration result = test.dividedBy(2L, RoundingMode.UNNECESSARY);\n    assertEquals(123L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2564, "method_signature": "void testDividedByRoundingMode_long1()"}, "TestDuration_Basics.testDividedBy_long1": {"callee_method_ids": [570], "callee_method_names": ["Duration.dividedBy", "Duration.getMillis"], "method_name": "TestDuration_Basics.testDividedBy_long1", "method_implementation": "{\n    Duration test = new Duration(246L);\n    Duration result = test.dividedBy(2L);\n    assertEquals(123L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2563, "method_signature": "void testDividedBy_long1()"}, "TestDuration_Basics.testGetMillis": {"callee_method_names": ["Duration.getMillis", "Duration.getMillis"], "method_name": "TestDuration_Basics.testGetMillis", "method_implementation": "{\n    Duration test = new Duration(0L);\n    assertEquals(0, test.getMillis());\n    test = new Duration(1234567890L);\n    assertEquals(1234567890L, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2539, "method_signature": "void testGetMillis()"}, "TestDuration_Basics.testGetStandardSeconds": {"callee_method_names": ["Duration.getStandardSeconds", "Duration.getStandardSeconds", "Duration.getStandardSeconds", "Duration.getStandardSeconds", "Duration.getStandardSeconds", "Duration.getStandardSeconds", "Duration.getStandardSeconds", "Duration.getStandardSeconds", "Duration.getStandardSeconds", "Duration.getStandardSeconds"], "method_name": "TestDuration_Basics.testGetStandardSeconds", "method_implementation": "{\n    Duration test = new Duration(0L);\n    assertEquals(0, test.getStandardSeconds());\n    test = new Duration(1L);\n    assertEquals(0, test.getStandardSeconds());\n    test = new Duration(999L);\n    assertEquals(0, test.getStandardSeconds());\n    test = new Duration(1000L);\n    assertEquals(1, test.getStandardSeconds());\n    test = new Duration(1001L);\n    assertEquals(1, test.getStandardSeconds());\n    test = new Duration(1999L);\n    assertEquals(1, test.getStandardSeconds());\n    test = new Duration(2000L);\n    assertEquals(2, test.getStandardSeconds());\n    test = new Duration(-1L);\n    assertEquals(0, test.getStandardSeconds());\n    test = new Duration(-999L);\n    assertEquals(0, test.getStandardSeconds());\n    test = new Duration(-1000L);\n    assertEquals(-1, test.getStandardSeconds());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2541, "method_signature": "void testGetStandardSeconds()"}, "TestDuration_Basics.testMinus_RD1": {"callee_method_ids": [567], "callee_method_names": ["Duration.minus", "Duration.getMillis"], "method_name": "TestDuration_Basics.testMinus_RD1", "method_implementation": "{\n    Duration test = new Duration(123L);\n    Duration result = test.minus(new Duration(8000L));\n    assertEquals(123L - 8000L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2569, "method_signature": "void testMinus_RD1()"}, "TestDuration_Basics.testMinus_long1": {"callee_method_ids": [567], "callee_method_names": ["Duration.minus", "Duration.getMillis"], "method_name": "TestDuration_Basics.testMinus_long1", "method_implementation": "{\n    Duration test = new Duration(123L);\n    Duration result = test.minus(8000L);\n    assertEquals(123L - 8000L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2561, "method_signature": "void testMinus_long1()"}, "TestDuration_Basics.testMultipliedBy_long1": {"callee_method_ids": [568], "callee_method_names": ["Duration.multipliedBy", "Duration.getMillis"], "method_name": "TestDuration_Basics.testMultipliedBy_long1", "method_implementation": "{\n    Duration test = new Duration(123L);\n    Duration result = test.multipliedBy(2L);\n    assertEquals(246L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2562, "method_signature": "void testMultipliedBy_long1()"}, "TestDuration_Basics.testMutableDuration": {"callee_method_names": ["MockMutableDuration.getMillis", "MockMutableDuration.setMillis", "MockMutableDuration.getMillis"], "method_name": "TestDuration_Basics.testMutableDuration", "method_implementation": "{\n    // no MutableDuration, so...\n    MockMutableDuration test = new MockMutableDuration(123L);\n    assertEquals(123L, test.getMillis());\n    test.setMillis(2345L);\n    assertEquals(2345L, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2570, "method_signature": "void testMutableDuration()"}, "TestDuration_Basics.testNegated_long1": {"callee_method_ids": [571], "callee_method_names": ["Duration.negated", "Duration.getMillis"], "method_name": "TestDuration_Basics.testNegated_long1", "method_implementation": "{\n    Duration test = new Duration(246L);\n    Duration result = test.negated();\n    assertEquals(-246L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2565, "method_signature": "void testNegated_long1()"}, "TestDuration_Basics.testPlus_RD1": {"callee_method_ids": [566], "callee_method_names": ["Duration.plus", "Duration.getMillis"], "method_name": "TestDuration_Basics.testPlus_RD1", "method_implementation": "{\n    Duration test = new Duration(123L);\n    Duration result = test.plus(new Duration(8000L));\n    assertEquals(8123L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2568, "method_signature": "void testPlus_RD1()"}, "TestDuration_Basics.testPlus_long1": {"callee_method_ids": [566], "callee_method_names": ["Duration.plus", "Duration.getMillis"], "method_name": "TestDuration_Basics.testPlus_long1", "method_implementation": "{\n    Duration test = new Duration(123L);\n    Duration result = test.plus(8000L);\n    assertEquals(8123L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2560, "method_signature": "void testPlus_long1()"}, "TestDuration_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestDuration_Basics.testSerialization", "method_implementation": "{\n    Duration test = new Duration(123L);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Duration result = (Duration) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2540, "method_signature": "void testSerialization()"}, "TestDuration_Basics.testTest": {"callee_method_names": [], "method_name": "TestDuration_Basics.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2538, "method_signature": "void testTest()"}, "TestDuration_Basics.testToDuration1": {"callee_method_names": ["Duration.toDuration"], "method_name": "TestDuration_Basics.testToDuration1", "method_implementation": "{\n    Duration test = new Duration(123L);\n    Duration result = test.toDuration();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2543, "method_signature": "void testToDuration1()"}, "TestDuration_Basics.testToIntervalFrom": {"callee_method_names": ["Duration.toIntervalFrom"], "method_name": "TestDuration_Basics.testToIntervalFrom", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    Duration test = new Duration(length);\n    DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    Interval result = test.toIntervalFrom(dt);\n    assertEquals(new Interval(dt, test), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2556, "method_signature": "void testToIntervalFrom()"}, "TestDuration_Basics.testToIntervalTo": {"callee_method_names": ["Duration.toIntervalTo"], "method_name": "TestDuration_Basics.testToIntervalTo", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    Duration test = new Duration(length);\n    DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    Interval result = test.toIntervalTo(dt);\n    assertEquals(new Interval(test, dt), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2557, "method_signature": "void testToIntervalTo()"}, "TestDuration_Basics.testToPeriod": {"callee_method_names": ["Duration.toPeriod", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestDuration_Basics.testToPeriod", "method_implementation": "{\n    DateTimeZone zone = DateTimeZone.getDefault();\n    try {\n        DateTimeZone.setDefault(DateTimeZone.forID(\"Europe/Paris\"));\n        long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n        Duration dur = new Duration(length);\n        Period test = dur.toPeriod();\n        // (4 + (3 * 7) + (2 * 30) + 365) == 450\n        assertEquals(0, test.getYears());\n        assertEquals(0, test.getMonths());\n        assertEquals(0, test.getWeeks());\n        assertEquals(0, test.getDays());\n        assertEquals((450 * 24) + 5, test.getHours());\n        assertEquals(6, test.getMinutes());\n        assertEquals(7, test.getSeconds());\n        assertEquals(8, test.getMillis());\n    } finally {\n        DateTimeZone.setDefault(zone);\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2548, "method_signature": "void testToPeriod()"}, "TestDuration_Basics.testToPeriodFrom": {"callee_method_names": ["Duration.toPeriodFrom"], "method_name": "TestDuration_Basics.testToPeriodFrom", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    Duration test = new Duration(length);\n    DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    Period result = test.toPeriodFrom(dt);\n    assertEquals(new Period(dt, test), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2552, "method_signature": "void testToPeriodFrom()"}, "TestDuration_Basics.testToPeriodFrom_PeriodType": {"callee_method_names": ["Duration.toPeriodFrom"], "method_name": "TestDuration_Basics.testToPeriodFrom_PeriodType", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    Duration test = new Duration(length);\n    DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    Period result = test.toPeriodFrom(dt, PeriodType.standard().withMillisRemoved());\n    assertEquals(new Period(dt, test, PeriodType.standard().withMillisRemoved()), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2553, "method_signature": "void testToPeriodFrom_PeriodType()"}, "TestDuration_Basics.testToPeriodTo": {"callee_method_names": ["Duration.toPeriodTo"], "method_name": "TestDuration_Basics.testToPeriodTo", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    Duration test = new Duration(length);\n    DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    Period result = test.toPeriodTo(dt);\n    assertEquals(new Period(test, dt), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2554, "method_signature": "void testToPeriodTo()"}, "TestDuration_Basics.testToPeriodTo_PeriodType": {"callee_method_names": ["Duration.toPeriodTo"], "method_name": "TestDuration_Basics.testToPeriodTo_PeriodType", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    Duration test = new Duration(length);\n    DateTime dt = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    Period result = test.toPeriodTo(dt, PeriodType.standard().withMillisRemoved());\n    assertEquals(new Period(test, dt, PeriodType.standard().withMillisRemoved()), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2555, "method_signature": "void testToPeriodTo_PeriodType()"}, "TestDuration_Basics.testToPeriod_Chronology": {"callee_method_names": ["Duration.toPeriod", "Duration.getMillis"], "method_name": "TestDuration_Basics.testToPeriod_Chronology", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    Duration test = new Duration(length);\n    Period result = test.toPeriod(ISOChronology.getInstanceUTC());\n    assertEquals(new Period(test, ISOChronology.getInstanceUTC()), result);\n    assertEquals(new Period(test.getMillis(), ISOChronology.getInstanceUTC()), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2550, "method_signature": "void testToPeriod_Chronology()"}, "TestDuration_Basics.testToPeriod_PeriodType": {"callee_method_names": ["Duration.toPeriod", "Duration.getMillis"], "method_name": "TestDuration_Basics.testToPeriod_PeriodType", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    Duration test = new Duration(length);\n    Period result = test.toPeriod(PeriodType.standard().withMillisRemoved());\n    assertEquals(new Period(test, PeriodType.standard().withMillisRemoved()), result);\n    assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved()), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2549, "method_signature": "void testToPeriod_PeriodType()"}, "TestDuration_Basics.testToPeriod_PeriodType_Chronology": {"callee_method_names": ["Duration.toPeriod", "Duration.getMillis"], "method_name": "TestDuration_Basics.testToPeriod_PeriodType_Chronology", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    Duration test = new Duration(length);\n    Period result = test.toPeriod(PeriodType.standard().withMillisRemoved(), ISOChronology.getInstanceUTC());\n    assertEquals(new Period(test, PeriodType.standard().withMillisRemoved(), ISOChronology.getInstanceUTC()), result);\n    assertEquals(new Period(test.getMillis(), PeriodType.standard().withMillisRemoved(), ISOChronology.getInstanceUTC()), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2551, "method_signature": "void testToPeriod_PeriodType_Chronology()"}, "TestDuration_Basics.testToStandardDays": {"callee_method_names": ["Duration.toStandardDays", "Duration.toStandardDays", "Duration.toStandardDays", "Duration.toStandardDays", "Duration.toStandardDays", "Duration.toStandardDays", "Duration.toStandardDays", "Duration.toStandardDays", "Duration.toStandardDays", "Duration.toStandardDays"], "method_name": "TestDuration_Basics.testToStandardDays", "method_implementation": "{\n    Duration test = new Duration(0L);\n    assertEquals(Days.days(0), test.toStandardDays());\n    test = new Duration(1L);\n    assertEquals(Days.days(0), test.toStandardDays());\n    test = new Duration(24 * 60 * 60000L - 1);\n    assertEquals(Days.days(0), test.toStandardDays());\n    test = new Duration(24 * 60 * 60000L);\n    assertEquals(Days.days(1), test.toStandardDays());\n    test = new Duration(24 * 60 * 60000L + 1);\n    assertEquals(Days.days(1), test.toStandardDays());\n    test = new Duration(2 * 24 * 60 * 60000L - 1);\n    assertEquals(Days.days(1), test.toStandardDays());\n    test = new Duration(2 * 24 * 60 * 60000L);\n    assertEquals(Days.days(2), test.toStandardDays());\n    test = new Duration(-1L);\n    assertEquals(Days.days(0), test.toStandardDays());\n    test = new Duration(-24 * 60 * 60000L + 1);\n    assertEquals(Days.days(0), test.toStandardDays());\n    test = new Duration(-24 * 60 * 60000L);\n    assertEquals(Days.days(-1), test.toStandardDays());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2544, "method_signature": "void testToStandardDays()"}, "TestDuration_Basics.testToStandardHours": {"callee_method_names": ["Duration.toStandardHours", "Duration.toStandardHours", "Duration.toStandardHours", "Duration.toStandardHours", "Duration.toStandardHours", "Duration.toStandardHours", "Duration.toStandardHours", "Duration.toStandardHours", "Duration.toStandardHours", "Duration.toStandardHours"], "method_name": "TestDuration_Basics.testToStandardHours", "method_implementation": "{\n    Duration test = new Duration(0L);\n    assertEquals(Hours.hours(0), test.toStandardHours());\n    test = new Duration(1L);\n    assertEquals(Hours.hours(0), test.toStandardHours());\n    test = new Duration(3600000L - 1);\n    assertEquals(Hours.hours(0), test.toStandardHours());\n    test = new Duration(3600000L);\n    assertEquals(Hours.hours(1), test.toStandardHours());\n    test = new Duration(3600000L + 1);\n    assertEquals(Hours.hours(1), test.toStandardHours());\n    test = new Duration(2 * 3600000L - 1);\n    assertEquals(Hours.hours(1), test.toStandardHours());\n    test = new Duration(2 * 3600000L);\n    assertEquals(Hours.hours(2), test.toStandardHours());\n    test = new Duration(-1L);\n    assertEquals(Hours.hours(0), test.toStandardHours());\n    test = new Duration(-3600000L + 1);\n    assertEquals(Hours.hours(0), test.toStandardHours());\n    test = new Duration(-3600000L);\n    assertEquals(Hours.hours(-1), test.toStandardHours());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2545, "method_signature": "void testToStandardHours()"}, "TestDuration_Basics.testToStandardMinutes": {"callee_method_names": ["Duration.toStandardMinutes", "Duration.toStandardMinutes", "Duration.toStandardMinutes", "Duration.toStandardMinutes", "Duration.toStandardMinutes", "Duration.toStandardMinutes", "Duration.toStandardMinutes", "Duration.toStandardMinutes", "Duration.toStandardMinutes", "Duration.toStandardMinutes"], "method_name": "TestDuration_Basics.testToStandardMinutes", "method_implementation": "{\n    Duration test = new Duration(0L);\n    assertEquals(Minutes.minutes(0), test.toStandardMinutes());\n    test = new Duration(1L);\n    assertEquals(Minutes.minutes(0), test.toStandardMinutes());\n    test = new Duration(60000L - 1);\n    assertEquals(Minutes.minutes(0), test.toStandardMinutes());\n    test = new Duration(60000L);\n    assertEquals(Minutes.minutes(1), test.toStandardMinutes());\n    test = new Duration(60000L + 1);\n    assertEquals(Minutes.minutes(1), test.toStandardMinutes());\n    test = new Duration(2 * 60000L - 1);\n    assertEquals(Minutes.minutes(1), test.toStandardMinutes());\n    test = new Duration(2 * 60000L);\n    assertEquals(Minutes.minutes(2), test.toStandardMinutes());\n    test = new Duration(-1L);\n    assertEquals(Minutes.minutes(0), test.toStandardMinutes());\n    test = new Duration(-60000L + 1);\n    assertEquals(Minutes.minutes(0), test.toStandardMinutes());\n    test = new Duration(-60000L);\n    assertEquals(Minutes.minutes(-1), test.toStandardMinutes());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2546, "method_signature": "void testToStandardMinutes()"}, "TestDuration_Basics.testToStandardSeconds": {"callee_method_names": ["Duration.toStandardSeconds", "Duration.toStandardSeconds", "Duration.toStandardSeconds", "Duration.toStandardSeconds", "Duration.toStandardSeconds", "Duration.toStandardSeconds", "Duration.toStandardSeconds", "Duration.toStandardSeconds", "Duration.toStandardSeconds", "Duration.toStandardSeconds"], "method_name": "TestDuration_Basics.testToStandardSeconds", "method_implementation": "{\n    Duration test = new Duration(0L);\n    assertEquals(Seconds.seconds(0), test.toStandardSeconds());\n    test = new Duration(1L);\n    assertEquals(Seconds.seconds(0), test.toStandardSeconds());\n    test = new Duration(999L);\n    assertEquals(Seconds.seconds(0), test.toStandardSeconds());\n    test = new Duration(1000L);\n    assertEquals(Seconds.seconds(1), test.toStandardSeconds());\n    test = new Duration(1001L);\n    assertEquals(Seconds.seconds(1), test.toStandardSeconds());\n    test = new Duration(1999L);\n    assertEquals(Seconds.seconds(1), test.toStandardSeconds());\n    test = new Duration(2000L);\n    assertEquals(Seconds.seconds(2), test.toStandardSeconds());\n    test = new Duration(-1L);\n    assertEquals(Seconds.seconds(0), test.toStandardSeconds());\n    test = new Duration(-999L);\n    assertEquals(Seconds.seconds(0), test.toStandardSeconds());\n    test = new Duration(-1000L);\n    assertEquals(Seconds.seconds(-1), test.toStandardSeconds());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2547, "method_signature": "void testToStandardSeconds()"}, "TestDuration_Basics.testToString": {"callee_method_names": ["Duration.toString"], "method_name": "TestDuration_Basics.testToString", "method_implementation": "{\n    long length = (365L + 2L * 30L + 3L * 7L + 4L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 845L;\n    Duration test = new Duration(length);\n    assertEquals(\"PT\" + (length / 1000) + \".\" + (length % 1000) + \"S\", test.toString());\n    assertEquals(\"PT0S\", new Duration(0L).toString());\n    assertEquals(\"PT10S\", new Duration(10000L).toString());\n    assertEquals(\"PT1S\", new Duration(1000L).toString());\n    assertEquals(\"PT12.345S\", new Duration(12345L).toString());\n    assertEquals(\"PT-12.345S\", new Duration(-12345L).toString());\n    assertEquals(\"PT-1.123S\", new Duration(-1123L).toString());\n    assertEquals(\"PT-0.123S\", new Duration(-123L).toString());\n    assertEquals(\"PT-0.012S\", new Duration(-12L).toString());\n    assertEquals(\"PT-0.001S\", new Duration(-1L).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2542, "method_signature": "void testToString()"}, "TestDuration_Basics.testWithDurationAdded_RD_int1": {"callee_method_ids": [565], "callee_method_names": ["Duration.withDurationAdded", "Duration.getMillis"], "method_name": "TestDuration_Basics.testWithDurationAdded_RD_int1", "method_implementation": "{\n    Duration test = new Duration(123L);\n    Duration result = test.withDurationAdded(new Duration(8000L), 1);\n    assertEquals(8123L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2567, "method_signature": "void testWithDurationAdded_RD_int1()"}, "TestDuration_Basics.testWithDurationAdded_long_int1": {"callee_method_ids": [565], "callee_method_names": ["Duration.withDurationAdded", "Duration.getMillis"], "method_name": "TestDuration_Basics.testWithDurationAdded_long_int1", "method_implementation": "{\n    Duration test = new Duration(123L);\n    Duration result = test.withDurationAdded(8000L, 1);\n    assertEquals(8123L, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2559, "method_signature": "void testWithDurationAdded_long_int1()"}, "TestDuration_Basics.testWithMillis1": {"callee_method_ids": [563], "callee_method_names": ["Duration.withMillis"], "method_name": "TestDuration_Basics.testWithMillis1", "method_implementation": "{\n    Duration test = new Duration(123L);\n    Duration result = test.withMillis(123L);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2558, "method_signature": "void testWithMillis1()"}, "TestDuration_Constructors.testConstructor_Overflow1": {"callee_method_names": [], "method_name": "TestDuration_Constructors.testConstructor_Overflow1", "method_implementation": "{\n    try {\n        Duration test = new Duration(-1, Long.MAX_VALUE);\n        fail();\n    } catch (ArithmeticException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor overflow\n */\n", "repo_name": "joda-time-main/", "id": 2183, "method_signature": "void testConstructor_Overflow1()"}, "TestDuration_Constructors.testConstructor_RI_RI1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "Duration.getMillis"], "method_name": "TestDuration_Constructors.testConstructor_RI_RI1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Duration test = new Duration(dt1, dt2);\n    assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2182, "method_signature": "void testConstructor_RI_RI1()"}, "TestDuration_Constructors.testConstructor_long1": {"callee_method_names": ["Duration.getMillis"], "method_name": "TestDuration_Constructors.testConstructor_long1", "method_implementation": "{\n    long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n    Duration test = new Duration(length);\n    assertEquals(length, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2180, "method_signature": "void testConstructor_long1()"}, "TestDuration_Constructors.testConstructor_long_long1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "Duration.getMillis"], "method_name": "TestDuration_Constructors.testConstructor_long_long1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Duration test = new Duration(dt1.getMillis(), dt2.getMillis());\n    assertEquals(dt2.getMillis() - dt1.getMillis(), test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2181, "method_signature": "void testConstructor_long_long1()"}, "TestDuration_Constructors.testFactory_millis_long": {"callee_method_names": ["Duration.getMillis", "Duration.getMillis"], "method_name": "TestDuration_Constructors.testFactory_millis_long", "method_implementation": "{\n    Duration test = Duration.millis(1);\n    assertEquals(1L, test.getMillis());\n    test = Duration.millis(2);\n    assertEquals(2L, test.getMillis());\n    test = Duration.millis(0);\n    assertSame(Duration.ZERO, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2179, "method_signature": "void testFactory_millis_long()"}, "TestDuration_Constructors.testFactory_standardDays_long": {"callee_method_names": ["Duration.getMillis", "Duration.getMillis"], "method_name": "TestDuration_Constructors.testFactory_standardDays_long", "method_implementation": "{\n    Duration test = Duration.standardDays(1);\n    assertEquals(24L * 60L * 60L * 1000L, test.getMillis());\n    test = Duration.standardDays(2);\n    assertEquals(2L * 24L * 60L * 60L * 1000L, test.getMillis());\n    test = Duration.standardDays(0);\n    assertSame(Duration.ZERO, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2175, "method_signature": "void testFactory_standardDays_long()"}, "TestDuration_Constructors.testFactory_standardHours_long": {"callee_method_names": ["Duration.getMillis", "Duration.getMillis"], "method_name": "TestDuration_Constructors.testFactory_standardHours_long", "method_implementation": "{\n    Duration test = Duration.standardHours(1);\n    assertEquals(60L * 60L * 1000L, test.getMillis());\n    test = Duration.standardHours(2);\n    assertEquals(2L * 60L * 60L * 1000L, test.getMillis());\n    test = Duration.standardHours(0);\n    assertSame(Duration.ZERO, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2176, "method_signature": "void testFactory_standardHours_long()"}, "TestDuration_Constructors.testFactory_standardMinutes_long": {"callee_method_names": ["Duration.getMillis", "Duration.getMillis"], "method_name": "TestDuration_Constructors.testFactory_standardMinutes_long", "method_implementation": "{\n    Duration test = Duration.standardMinutes(1);\n    assertEquals(60L * 1000L, test.getMillis());\n    test = Duration.standardMinutes(2);\n    assertEquals(2L * 60L * 1000L, test.getMillis());\n    test = Duration.standardMinutes(0);\n    assertSame(Duration.ZERO, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2177, "method_signature": "void testFactory_standardMinutes_long()"}, "TestDuration_Constructors.testFactory_standardSeconds_long": {"callee_method_names": ["Duration.getMillis", "Duration.getMillis"], "method_name": "TestDuration_Constructors.testFactory_standardSeconds_long", "method_implementation": "{\n    Duration test = Duration.standardSeconds(1);\n    assertEquals(1000L, test.getMillis());\n    test = Duration.standardSeconds(2);\n    assertEquals(2L * 1000L, test.getMillis());\n    test = Duration.standardSeconds(0);\n    assertSame(Duration.ZERO, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2178, "method_signature": "void testFactory_standardSeconds_long()"}, "TestEthiopicChronology.testCalendar": {"callee_method_names": ["DateTime.getMillis", "Chronology.dayOfWeek", "Chronology.dayOfYear", "Chronology.dayOfMonth", "Chronology.monthOfYear", "Chronology.year", "Chronology.yearOfEra", "Chronology.era", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.getMaximumValue", "DateTimeField.get", "DateTimeField.getAsText", "DateTimeField.getAsShortText", "DateTimeField.isLeap", "DateTimeField.isLeap"], "method_name": "TestEthiopicChronology.testCalendar", "method_implementation": "{\n    if (TestAll.FAST) {\n        return;\n    }\n    System.out.println(\"\\nTestEthiopicChronology.testCalendar\");\n    DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ETHIOPIC_UTC);\n    long millis = epoch.getMillis();\n    long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();\n    DateTimeField dayOfWeek = ETHIOPIC_UTC.dayOfWeek();\n    DateTimeField dayOfYear = ETHIOPIC_UTC.dayOfYear();\n    DateTimeField dayOfMonth = ETHIOPIC_UTC.dayOfMonth();\n    DateTimeField monthOfYear = ETHIOPIC_UTC.monthOfYear();\n    DateTimeField year = ETHIOPIC_UTC.year();\n    DateTimeField yearOfEra = ETHIOPIC_UTC.yearOfEra();\n    DateTimeField era = ETHIOPIC_UTC.era();\n    int expectedDOW = new DateTime(8, 8, 29, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();\n    int expectedDOY = 1;\n    int expectedDay = 1;\n    int expectedMonth = 1;\n    int expectedYear = 1;\n    while (millis < end) {\n        int dowValue = dayOfWeek.get(millis);\n        int doyValue = dayOfYear.get(millis);\n        int dayValue = dayOfMonth.get(millis);\n        int monthValue = monthOfYear.get(millis);\n        int yearValue = year.get(millis);\n        int yearOfEraValue = yearOfEra.get(millis);\n        int monthLen = dayOfMonth.getMaximumValue(millis);\n        if (monthValue < 1 || monthValue > 13) {\n            fail(\"Bad month: \" + millis);\n        }\n        // test era\n        assertEquals(1, era.get(millis));\n        assertEquals(\"EE\", era.getAsText(millis));\n        assertEquals(\"EE\", era.getAsShortText(millis));\n        // test date\n        assertEquals(expectedYear, yearValue);\n        assertEquals(expectedYear, yearOfEraValue);\n        assertEquals(expectedMonth, monthValue);\n        assertEquals(expectedDay, dayValue);\n        assertEquals(expectedDOW, dowValue);\n        assertEquals(expectedDOY, doyValue);\n        // test leap year\n        assertEquals(yearValue % 4 == 3, year.isLeap(millis));\n        // test month length\n        if (monthValue == 13) {\n            assertEquals(yearValue % 4 == 3, monthOfYear.isLeap(millis));\n            if (yearValue % 4 == 3) {\n                assertEquals(6, monthLen);\n            } else {\n                assertEquals(5, monthLen);\n            }\n        } else {\n            assertEquals(30, monthLen);\n        }\n        // recalculate date\n        expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;\n        expectedDay++;\n        expectedDOY++;\n        if (expectedDay == 31 && expectedMonth < 13) {\n            expectedDay = 1;\n            expectedMonth++;\n        } else if (expectedMonth == 13) {\n            if (expectedYear % 4 == 3 && expectedDay == 7) {\n                expectedDay = 1;\n                expectedMonth = 1;\n                expectedYear++;\n                expectedDOY = 1;\n            } else if (expectedYear % 4 != 3 && expectedDay == 6) {\n                expectedDay = 1;\n                expectedMonth = 1;\n                expectedYear++;\n                expectedDOY = 1;\n            }\n        }\n        millis += SKIP;\n    }\n}", "repo_id": "7", "comment": "/**\n * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.\n */\n", "repo_name": "joda-time-main/", "id": 1975, "method_signature": "void testCalendar()"}, "TestEthiopicChronology.testDurationFields": {"callee_method_names": ["EthiopicChronology.eras", "EthiopicChronology.centuries", "EthiopicChronology.years", "EthiopicChronology.weekyears", "EthiopicChronology.months", "EthiopicChronology.weeks", "EthiopicChronology.days", "EthiopicChronology.halfdays", "EthiopicChronology.hours", "EthiopicChronology.minutes", "EthiopicChronology.seconds", "EthiopicChronology.millis", "EthiopicChronology.eras", "EthiopicChronology.centuries", "EthiopicChronology.years", "EthiopicChronology.weekyears", "EthiopicChronology.months", "EthiopicChronology.weeks", "EthiopicChronology.days", "EthiopicChronology.halfdays", "EthiopicChronology.hours", "EthiopicChronology.minutes", "EthiopicChronology.seconds", "EthiopicChronology.millis", "EthiopicChronology.centuries", "EthiopicChronology.years", "EthiopicChronology.weekyears", "EthiopicChronology.months", "EthiopicChronology.weeks", "EthiopicChronology.days", "EthiopicChronology.halfdays", "EthiopicChronology.hours", "EthiopicChronology.minutes", "EthiopicChronology.seconds", "EthiopicChronology.millis", "EthiopicChronology.centuries", "EthiopicChronology.years", "EthiopicChronology.weekyears", "EthiopicChronology.months", "EthiopicChronology.weeks", "EthiopicChronology.days", "EthiopicChronology.halfdays", "EthiopicChronology.hours", "EthiopicChronology.minutes", "EthiopicChronology.seconds", "EthiopicChronology.millis", "EthiopicChronology.centuries", "EthiopicChronology.years", "EthiopicChronology.weekyears", "EthiopicChronology.months", "EthiopicChronology.weeks", "EthiopicChronology.days", "EthiopicChronology.halfdays", "EthiopicChronology.hours", "EthiopicChronology.minutes", "EthiopicChronology.seconds", "EthiopicChronology.millis"], "method_name": "TestEthiopicChronology.testDurationFields", "method_implementation": "{\n    final EthiopicChronology ethiopic = EthiopicChronology.getInstance();\n    assertEquals(\"eras\", ethiopic.eras().getName());\n    assertEquals(\"centuries\", ethiopic.centuries().getName());\n    assertEquals(\"years\", ethiopic.years().getName());\n    assertEquals(\"weekyears\", ethiopic.weekyears().getName());\n    assertEquals(\"months\", ethiopic.months().getName());\n    assertEquals(\"weeks\", ethiopic.weeks().getName());\n    assertEquals(\"days\", ethiopic.days().getName());\n    assertEquals(\"halfdays\", ethiopic.halfdays().getName());\n    assertEquals(\"hours\", ethiopic.hours().getName());\n    assertEquals(\"minutes\", ethiopic.minutes().getName());\n    assertEquals(\"seconds\", ethiopic.seconds().getName());\n    assertEquals(\"millis\", ethiopic.millis().getName());\n    assertEquals(false, ethiopic.eras().isSupported());\n    assertEquals(true, ethiopic.centuries().isSupported());\n    assertEquals(true, ethiopic.years().isSupported());\n    assertEquals(true, ethiopic.weekyears().isSupported());\n    assertEquals(true, ethiopic.months().isSupported());\n    assertEquals(true, ethiopic.weeks().isSupported());\n    assertEquals(true, ethiopic.days().isSupported());\n    assertEquals(true, ethiopic.halfdays().isSupported());\n    assertEquals(true, ethiopic.hours().isSupported());\n    assertEquals(true, ethiopic.minutes().isSupported());\n    assertEquals(true, ethiopic.seconds().isSupported());\n    assertEquals(true, ethiopic.millis().isSupported());\n    assertEquals(false, ethiopic.centuries().isPrecise());\n    assertEquals(false, ethiopic.years().isPrecise());\n    assertEquals(false, ethiopic.weekyears().isPrecise());\n    assertEquals(false, ethiopic.months().isPrecise());\n    assertEquals(false, ethiopic.weeks().isPrecise());\n    assertEquals(false, ethiopic.days().isPrecise());\n    assertEquals(false, ethiopic.halfdays().isPrecise());\n    assertEquals(true, ethiopic.hours().isPrecise());\n    assertEquals(true, ethiopic.minutes().isPrecise());\n    assertEquals(true, ethiopic.seconds().isPrecise());\n    assertEquals(true, ethiopic.millis().isPrecise());\n    final EthiopicChronology ethiopicUTC = EthiopicChronology.getInstanceUTC();\n    assertEquals(false, ethiopicUTC.centuries().isPrecise());\n    assertEquals(false, ethiopicUTC.years().isPrecise());\n    assertEquals(false, ethiopicUTC.weekyears().isPrecise());\n    assertEquals(false, ethiopicUTC.months().isPrecise());\n    assertEquals(true, ethiopicUTC.weeks().isPrecise());\n    assertEquals(true, ethiopicUTC.days().isPrecise());\n    assertEquals(true, ethiopicUTC.halfdays().isPrecise());\n    assertEquals(true, ethiopicUTC.hours().isPrecise());\n    assertEquals(true, ethiopicUTC.minutes().isPrecise());\n    assertEquals(true, ethiopicUTC.seconds().isPrecise());\n    assertEquals(true, ethiopicUTC.millis().isPrecise());\n    final DateTimeZone gmt = DateTimeZone.forID(\"Etc/GMT\");\n    final EthiopicChronology ethiopicGMT = EthiopicChronology.getInstance(gmt);\n    assertEquals(false, ethiopicGMT.centuries().isPrecise());\n    assertEquals(false, ethiopicGMT.years().isPrecise());\n    assertEquals(false, ethiopicGMT.weekyears().isPrecise());\n    assertEquals(false, ethiopicGMT.months().isPrecise());\n    assertEquals(true, ethiopicGMT.weeks().isPrecise());\n    assertEquals(true, ethiopicGMT.days().isPrecise());\n    assertEquals(true, ethiopicGMT.halfdays().isPrecise());\n    assertEquals(true, ethiopicGMT.hours().isPrecise());\n    assertEquals(true, ethiopicGMT.minutes().isPrecise());\n    assertEquals(true, ethiopicGMT.seconds().isPrecise());\n    assertEquals(true, ethiopicGMT.millis().isPrecise());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1974, "method_signature": "void testDurationFields()"}, "TestEthiopicChronology.testEquality": {"callee_method_names": [], "method_name": "TestEthiopicChronology.testEquality", "method_implementation": "{\n    assertSame(EthiopicChronology.getInstance(TOKYO), EthiopicChronology.getInstance(TOKYO));\n    assertSame(EthiopicChronology.getInstance(LONDON), EthiopicChronology.getInstance(LONDON));\n    assertSame(EthiopicChronology.getInstance(PARIS), EthiopicChronology.getInstance(PARIS));\n    assertSame(EthiopicChronology.getInstanceUTC(), EthiopicChronology.getInstanceUTC());\n    assertSame(EthiopicChronology.getInstance(), EthiopicChronology.getInstance(LONDON));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1973, "method_signature": "void testEquality()"}, "TestFieldUtils.testSafeDivideLongLong": {"callee_method_names": [], "method_name": "TestFieldUtils.testSafeDivideLongLong", "method_implementation": "{\n    assertEquals(1L, FieldUtils.safeDivide(1L, 1L));\n    assertEquals(1L, FieldUtils.safeDivide(3L, 3L));\n    assertEquals(0L, FieldUtils.safeDivide(1L, 3L));\n    assertEquals(3L, FieldUtils.safeDivide(3L, 1L));\n    assertEquals(1L, FieldUtils.safeDivide(5L, 3L));\n    assertEquals(-1L, FieldUtils.safeDivide(5L, -3L));\n    assertEquals(-1L, FieldUtils.safeDivide(-5L, 3L));\n    assertEquals(1L, FieldUtils.safeDivide(-5L, -3L));\n    assertEquals(2L, FieldUtils.safeDivide(6L, 3L));\n    assertEquals(-2L, FieldUtils.safeDivide(6L, -3L));\n    assertEquals(-2L, FieldUtils.safeDivide(-6L, 3L));\n    assertEquals(2L, FieldUtils.safeDivide(-6L, -3L));\n    assertEquals(2L, FieldUtils.safeDivide(7L, 3L));\n    assertEquals(-2L, FieldUtils.safeDivide(7L, -3L));\n    assertEquals(-2L, FieldUtils.safeDivide(-7L, 3L));\n    assertEquals(2L, FieldUtils.safeDivide(-7L, -3L));\n    assertEquals(Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, 1L));\n    assertEquals(Long.MIN_VALUE, FieldUtils.safeDivide(Long.MIN_VALUE, 1L));\n    assertEquals(-Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, -1L));\n    try {\n        FieldUtils.safeDivide(Long.MIN_VALUE, -1L);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n    try {\n        FieldUtils.safeDivide(1L, 0L);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1140, "method_signature": "void testSafeDivideLongLong()"}, "TestFieldUtils.testSafeDivideRoundingModeLong": {"callee_method_names": [], "method_name": "TestFieldUtils.testSafeDivideRoundingModeLong", "method_implementation": "{\n    assertEquals(3L, FieldUtils.safeDivide(15L, 5L, RoundingMode.UNNECESSARY));\n    assertEquals(59L, FieldUtils.safeDivide(179L, 3L, RoundingMode.FLOOR));\n    assertEquals(60L, FieldUtils.safeDivide(179L, 3L, RoundingMode.CEILING));\n    assertEquals(60L, FieldUtils.safeDivide(179L, 3L, RoundingMode.HALF_UP));\n    assertEquals(-60L, FieldUtils.safeDivide(-179L, 3L, RoundingMode.HALF_UP));\n    assertEquals(60L, FieldUtils.safeDivide(179L, 3L, RoundingMode.HALF_DOWN));\n    assertEquals(-60L, FieldUtils.safeDivide(-179L, 3L, RoundingMode.HALF_DOWN));\n    assertEquals(Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, 1L, RoundingMode.UNNECESSARY));\n    assertEquals(Long.MIN_VALUE, FieldUtils.safeDivide(Long.MIN_VALUE, 1L, RoundingMode.UNNECESSARY));\n    assertEquals(-Long.MAX_VALUE, FieldUtils.safeDivide(Long.MAX_VALUE, -1L, RoundingMode.UNNECESSARY));\n    try {\n        FieldUtils.safeDivide(Long.MIN_VALUE, -1L, RoundingMode.UNNECESSARY);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n    try {\n        FieldUtils.safeDivide(1L, 0L, RoundingMode.UNNECESSARY);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1141, "method_signature": "void testSafeDivideRoundingModeLong()"}, "TestFieldUtils.testSafeMultiplyLongInt": {"callee_method_names": [], "method_name": "TestFieldUtils.testSafeMultiplyLongInt", "method_implementation": "{\n    assertEquals(0L, FieldUtils.safeMultiply(0L, 0));\n    assertEquals(1L, FieldUtils.safeMultiply(1L, 1));\n    assertEquals(3L, FieldUtils.safeMultiply(1L, 3));\n    assertEquals(3L, FieldUtils.safeMultiply(3L, 1));\n    assertEquals(6L, FieldUtils.safeMultiply(2L, 3));\n    assertEquals(-6L, FieldUtils.safeMultiply(2L, -3));\n    assertEquals(-6L, FieldUtils.safeMultiply(-2L, 3));\n    assertEquals(6L, FieldUtils.safeMultiply(-2L, -3));\n    assertEquals(-1L * Integer.MIN_VALUE, FieldUtils.safeMultiply(-1L, Integer.MIN_VALUE));\n    assertEquals(Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, 1));\n    assertEquals(Long.MIN_VALUE, FieldUtils.safeMultiply(Long.MIN_VALUE, 1));\n    assertEquals(-Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, -1));\n    try {\n        FieldUtils.safeMultiply(Long.MIN_VALUE, -1);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n    try {\n        FieldUtils.safeMultiply(Long.MIN_VALUE, 100);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n    try {\n        FieldUtils.safeMultiply(Long.MIN_VALUE, Integer.MAX_VALUE);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n    try {\n        FieldUtils.safeMultiply(Long.MAX_VALUE, Integer.MIN_VALUE);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1139, "method_signature": "void testSafeMultiplyLongInt()"}, "TestFieldUtils.testSafeMultiplyLongLong": {"callee_method_names": [], "method_name": "TestFieldUtils.testSafeMultiplyLongLong", "method_implementation": "{\n    assertEquals(0L, FieldUtils.safeMultiply(0L, 0L));\n    assertEquals(1L, FieldUtils.safeMultiply(1L, 1L));\n    assertEquals(3L, FieldUtils.safeMultiply(1L, 3L));\n    assertEquals(3L, FieldUtils.safeMultiply(3L, 1L));\n    assertEquals(6L, FieldUtils.safeMultiply(2L, 3L));\n    assertEquals(-6L, FieldUtils.safeMultiply(2L, -3L));\n    assertEquals(-6L, FieldUtils.safeMultiply(-2L, 3L));\n    assertEquals(6L, FieldUtils.safeMultiply(-2L, -3L));\n    assertEquals(Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, 1L));\n    assertEquals(Long.MIN_VALUE, FieldUtils.safeMultiply(Long.MIN_VALUE, 1L));\n    assertEquals(-Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, -1L));\n    try {\n        FieldUtils.safeMultiply(Long.MIN_VALUE, -1L);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n    try {\n        FieldUtils.safeMultiply(-1L, Long.MIN_VALUE);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n    try {\n        FieldUtils.safeMultiply(Long.MIN_VALUE, 100L);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n    try {\n        FieldUtils.safeMultiply(Long.MIN_VALUE, Long.MAX_VALUE);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n    try {\n        FieldUtils.safeMultiply(Long.MAX_VALUE, Long.MIN_VALUE);\n        fail();\n    } catch (ArithmeticException e) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1138, "method_signature": "void testSafeMultiplyLongLong()"}, "TestFixedDateTimeZone.getOffset": {"callee_method_names": ["TimeZone.inDaylightTime", "TimeZone.getRawOffset", "TimeZone.getRawOffset"], "method_name": "TestFixedDateTimeZone.getOffset", "method_implementation": "{\n    Date date = new Date(millis);\n    if (zone.inDaylightTime(date)) {\n        return zone.getRawOffset() + 3600000;\n    }\n    return zone.getRawOffset();\n}", "repo_id": "7", "comment": "/**\n * Make test compile on JDK 1.3.\n */\n", "repo_name": "joda-time-main/", "id": 2128, "method_signature": "int getOffset(TimeZone, long)"}, "TestGJChronology.div": {"callee_method_names": [], "method_name": "TestGJChronology.div", "method_implementation": "{\n    if (divisor < 0) {\n        throw new IllegalArgumentException(\"divisor must be positive: \" + divisor);\n    }\n    if (dividend >= 0) {\n        return dividend / divisor;\n    } else {\n        return (dividend + 1) / divisor - 1;\n    }\n}", "repo_id": "7", "comment": "/**\n * Divide with round-negative behavior.\n *\n * @param divisor must be positive\n */\n", "repo_name": "joda-time-main/", "id": 1992, "method_signature": "long div(long, long)"}, "TestGJChronology.mod": {"callee_method_names": [], "method_name": "TestGJChronology.mod", "method_implementation": "{\n    if (divisor < 0) {\n        throw new IllegalArgumentException(\"divisor must be positive: \" + divisor);\n    }\n    if (dividend >= 0) {\n        return dividend % divisor;\n    } else {\n        return (dividend + 1) % divisor - 1 + divisor;\n    }\n}", "repo_id": "7", "comment": "/**\n * Modulus with round-negative behavior, result is always positive.\n *\n * @param divisor must be positive\n */\n", "repo_name": "joda-time-main/", "id": 1993, "method_signature": "long mod(long, long)"}, "TestGJChronology.testDurationFields": {"callee_method_names": ["GJChronology.eras", "GJChronology.centuries", "GJChronology.years", "GJChronology.weekyears", "GJChronology.months", "GJChronology.weeks", "GJChronology.halfdays", "GJChronology.days", "GJChronology.hours", "GJChronology.minutes", "GJChronology.seconds", "GJChronology.millis", "GJChronology.eras", "GJChronology.centuries", "GJChronology.years", "GJChronology.weekyears", "GJChronology.months", "GJChronology.weeks", "GJChronology.days", "GJChronology.halfdays", "GJChronology.hours", "GJChronology.minutes", "GJChronology.seconds", "GJChronology.millis", "GJChronology.centuries", "GJChronology.years", "GJChronology.weekyears", "GJChronology.months", "GJChronology.weeks", "GJChronology.days", "GJChronology.halfdays", "GJChronology.hours", "GJChronology.minutes", "GJChronology.seconds", "GJChronology.millis", "GJChronology.centuries", "GJChronology.years", "GJChronology.weekyears", "GJChronology.months", "GJChronology.weeks", "GJChronology.days", "GJChronology.halfdays", "GJChronology.hours", "GJChronology.minutes", "GJChronology.seconds", "GJChronology.millis", "GJChronology.centuries", "GJChronology.years", "GJChronology.weekyears", "GJChronology.months", "GJChronology.weeks", "GJChronology.days", "GJChronology.halfdays", "GJChronology.hours", "GJChronology.minutes", "GJChronology.seconds", "GJChronology.millis"], "method_name": "TestGJChronology.testDurationFields", "method_implementation": "{\n    final GJChronology gj = GJChronology.getInstance();\n    assertEquals(\"eras\", gj.eras().getName());\n    assertEquals(\"centuries\", gj.centuries().getName());\n    assertEquals(\"years\", gj.years().getName());\n    assertEquals(\"weekyears\", gj.weekyears().getName());\n    assertEquals(\"months\", gj.months().getName());\n    assertEquals(\"weeks\", gj.weeks().getName());\n    assertEquals(\"halfdays\", gj.halfdays().getName());\n    assertEquals(\"days\", gj.days().getName());\n    assertEquals(\"hours\", gj.hours().getName());\n    assertEquals(\"minutes\", gj.minutes().getName());\n    assertEquals(\"seconds\", gj.seconds().getName());\n    assertEquals(\"millis\", gj.millis().getName());\n    assertEquals(false, gj.eras().isSupported());\n    assertEquals(true, gj.centuries().isSupported());\n    assertEquals(true, gj.years().isSupported());\n    assertEquals(true, gj.weekyears().isSupported());\n    assertEquals(true, gj.months().isSupported());\n    assertEquals(true, gj.weeks().isSupported());\n    assertEquals(true, gj.days().isSupported());\n    assertEquals(true, gj.halfdays().isSupported());\n    assertEquals(true, gj.hours().isSupported());\n    assertEquals(true, gj.minutes().isSupported());\n    assertEquals(true, gj.seconds().isSupported());\n    assertEquals(true, gj.millis().isSupported());\n    assertEquals(false, gj.centuries().isPrecise());\n    assertEquals(false, gj.years().isPrecise());\n    assertEquals(false, gj.weekyears().isPrecise());\n    assertEquals(false, gj.months().isPrecise());\n    assertEquals(false, gj.weeks().isPrecise());\n    assertEquals(false, gj.days().isPrecise());\n    assertEquals(false, gj.halfdays().isPrecise());\n    assertEquals(true, gj.hours().isPrecise());\n    assertEquals(true, gj.minutes().isPrecise());\n    assertEquals(true, gj.seconds().isPrecise());\n    assertEquals(true, gj.millis().isPrecise());\n    final GJChronology gjUTC = GJChronology.getInstanceUTC();\n    assertEquals(false, gjUTC.centuries().isPrecise());\n    assertEquals(false, gjUTC.years().isPrecise());\n    assertEquals(false, gjUTC.weekyears().isPrecise());\n    assertEquals(false, gjUTC.months().isPrecise());\n    assertEquals(true, gjUTC.weeks().isPrecise());\n    assertEquals(true, gjUTC.days().isPrecise());\n    assertEquals(true, gjUTC.halfdays().isPrecise());\n    assertEquals(true, gjUTC.hours().isPrecise());\n    assertEquals(true, gjUTC.minutes().isPrecise());\n    assertEquals(true, gjUTC.seconds().isPrecise());\n    assertEquals(true, gjUTC.millis().isPrecise());\n    final DateTimeZone gmt = DateTimeZone.forID(\"Etc/GMT\");\n    final GJChronology gjGMT = GJChronology.getInstance(gmt);\n    assertEquals(false, gjGMT.centuries().isPrecise());\n    assertEquals(false, gjGMT.years().isPrecise());\n    assertEquals(false, gjGMT.weekyears().isPrecise());\n    assertEquals(false, gjGMT.months().isPrecise());\n    assertEquals(true, gjGMT.weeks().isPrecise());\n    assertEquals(true, gjGMT.days().isPrecise());\n    assertEquals(true, gjGMT.halfdays().isPrecise());\n    assertEquals(true, gjGMT.hours().isPrecise());\n    assertEquals(true, gjGMT.minutes().isPrecise());\n    assertEquals(true, gjGMT.seconds().isPrecise());\n    assertEquals(true, gjGMT.millis().isPrecise());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1961, "method_signature": "void testDurationFields()"}, "TestGJChronology.testEquality": {"callee_method_names": [], "method_name": "TestGJChronology.testEquality", "method_implementation": "{\n    assertSame(GJChronology.getInstance(TOKYO), GJChronology.getInstance(TOKYO));\n    assertSame(GJChronology.getInstance(LONDON), GJChronology.getInstance(LONDON));\n    assertSame(GJChronology.getInstance(PARIS), GJChronology.getInstance(PARIS));\n    assertSame(GJChronology.getInstanceUTC(), GJChronology.getInstanceUTC());\n    assertSame(GJChronology.getInstance(), GJChronology.getInstance(LONDON));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1960, "method_signature": "void testEquality()"}, "TestGJDate.test_cutoverPreZero": {"callee_method_names": [], "method_name": "TestGJDate.test_cutoverPreZero", "method_implementation": "{\n    DateTime cutover = new LocalDate(-2, 6, 30, ISOChronology.getInstanceUTC()).toDateTimeAtStartOfDay(DateTimeZone.UTC);\n    try {\n        GJChronology.getInstance(DateTimeZone.UTC, cutover);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1966, "method_signature": "void test_cutoverPreZero()"}, "TestGJDate.test_plusWeekyears_positiveToZero_crossCutover": {"callee_method_names": ["LocalDate.getWeekOfWeekyear", "LocalDate.getDayOfWeek", "LocalDate.weekyear"], "method_name": "TestGJDate.test_plusWeekyears_positiveToZero_crossCutover", "method_implementation": "{\n    LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n    LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek());\n    assertEquals(expected, date.weekyear().addToCopy(-2003));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1965, "method_signature": "void test_plusWeekyears_positiveToZero_crossCutover()"}, "TestGJDate.test_plusYears_negativeToNegative": {"callee_method_ids": [709], "callee_method_names": ["LocalDate.plusYears"], "method_name": "TestGJDate.test_plusYears_negativeToNegative", "method_implementation": "{\n    LocalDate date = new LocalDate(-3, 6, 30, GJ_CHRONOLOGY);\n    LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY);\n    assertEquals(expected, date.plusYears(2));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1963, "method_signature": "void test_plusYears_negativeToNegative()"}, "TestGJDate.test_plusYears_positiveToPositive": {"callee_method_ids": [709], "callee_method_names": ["LocalDate.plusYears"], "method_name": "TestGJDate.test_plusYears_positiveToPositive", "method_implementation": "{\n    LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY);\n    LocalDate expected = new LocalDate(7, 6, 30, GJ_CHRONOLOGY);\n    assertEquals(expected, date.plusYears(4));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1962, "method_signature": "void test_plusYears_positiveToPositive()"}, "TestGJDate.test_plusYears_positiveToPositive_crossCutover": {"callee_method_ids": [709], "callee_method_names": ["LocalDate.plusYears"], "method_name": "TestGJDate.test_plusYears_positiveToPositive_crossCutover", "method_implementation": "{\n    LocalDate date = new LocalDate(3, 6, 30, GJ_CHRONOLOGY);\n    LocalDate expected = new LocalDate(2007, 6, 30, GJ_CHRONOLOGY);\n    assertEquals(expected, date.plusYears(2004));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1964, "method_signature": "void test_plusYears_positiveToPositive_crossCutover()"}, "TestGregorianChronology.fixedFromGJ": {"callee_method_names": [], "method_name": "TestGregorianChronology.fixedFromGJ", "method_implementation": "{\n    long year_m1 = year - 1;\n    long f = 365 * year_m1 + div(year_m1, 4) - div(year_m1, 100) + div(year_m1, 400) + div(367 * monthOfYear - 362, 12) + dayOfMonth;\n    if (monthOfYear > 2) {\n        f += isLeapYear(year) ? -1 : -2;\n    }\n    return f;\n}", "repo_id": "7", "comment": "/**\n * @return days from 0001-01-01\n */\n", "repo_name": "joda-time-main/", "id": 1985, "method_signature": "long fixedFromGJ(int, int, int)"}, "TestGregorianChronology.gjFromFixed": {"callee_method_names": [], "method_name": "TestGregorianChronology.gjFromFixed", "method_implementation": "{\n    int year = gjYearFromFixed(date);\n    long priorDays = date - fixedFromGJ(year, 1, 1);\n    long correction;\n    if (date < fixedFromGJ(year, 3, 1)) {\n        correction = 0;\n    } else if (isLeapYear(year)) {\n        correction = 1;\n    } else {\n        correction = 2;\n    }\n    int monthOfYear = (int) div(12 * (priorDays + correction) + 373, 367);\n    int day = (int) (date - fixedFromGJ(year, monthOfYear, 1) + 1);\n    return new int[] { year, monthOfYear, day };\n}", "repo_id": "7", "comment": "/**\n * @param date days from 0001-01-01\n * @return gj year, monthOfYear, dayOfMonth\n */\n", "repo_name": "joda-time-main/", "id": 1987, "method_signature": "int[] gjFromFixed(long)"}, "TestGregorianChronology.gjYearFromFixed": {"callee_method_names": [], "method_name": "TestGregorianChronology.gjYearFromFixed", "method_implementation": "{\n    long d0 = date - 1;\n    long n400 = div(d0, 146097);\n    long d1 = mod(d0, 146097);\n    long n100 = div(d1, 36524);\n    long d2 = mod(d1, 36524);\n    long n4 = div(d2, 1461);\n    long d3 = mod(d2, 1461);\n    long n1 = div(d3, 365);\n    long year = 400 * n400 + 100 * n100 + 4 * n4 + n1;\n    if (!(n100 == 4 || n1 == 4)) {\n        year += 1;\n    }\n    int year_i = (int) year;\n    if (year_i == year) {\n        return year_i;\n    } else {\n        throw new RuntimeException(\"year cannot be cast to an int: \" + year);\n    }\n}", "repo_id": "7", "comment": "/**\n * @param date days from 0001-01-01\n * @return gj year\n */\n", "repo_name": "joda-time-main/", "id": 1986, "method_signature": "int gjYearFromFixed(long)"}, "TestGregorianChronology.isoFromFixed": {"callee_method_names": [], "method_name": "TestGregorianChronology.isoFromFixed", "method_implementation": "{\n    int weekyear = gjYearFromFixed(date - 3);\n    if (date >= fixedFromISO(weekyear + 1, 1, 1)) {\n        weekyear += 1;\n    }\n    int weekOfWeekyear = (int) (div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);\n    int dayOfWeek = (int) amod(date, 7);\n    return new int[] { weekyear, weekOfWeekyear, dayOfWeek };\n}", "repo_id": "7", "comment": "/**\n * @param date days from 0001-01-01\n * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n */\n", "repo_name": "joda-time-main/", "id": 1988, "method_signature": "int[] isoFromFixed(long)"}, "TestGregorianChronology.testDurationFields": {"callee_method_names": ["GregorianChronology.eras", "GregorianChronology.centuries", "GregorianChronology.years", "GregorianChronology.weekyears", "GregorianChronology.months", "GregorianChronology.weeks", "GregorianChronology.days", "GregorianChronology.halfdays", "GregorianChronology.hours", "GregorianChronology.minutes", "GregorianChronology.seconds", "GregorianChronology.millis", "GregorianChronology.eras", "GregorianChronology.centuries", "GregorianChronology.years", "GregorianChronology.weekyears", "GregorianChronology.months", "GregorianChronology.weeks", "GregorianChronology.days", "GregorianChronology.halfdays", "GregorianChronology.hours", "GregorianChronology.minutes", "GregorianChronology.seconds", "GregorianChronology.millis", "GregorianChronology.centuries", "GregorianChronology.years", "GregorianChronology.weekyears", "GregorianChronology.months", "GregorianChronology.weeks", "GregorianChronology.days", "GregorianChronology.halfdays", "GregorianChronology.hours", "GregorianChronology.minutes", "GregorianChronology.seconds", "GregorianChronology.millis", "GregorianChronology.centuries", "GregorianChronology.years", "GregorianChronology.weekyears", "GregorianChronology.months", "GregorianChronology.weeks", "GregorianChronology.days", "GregorianChronology.halfdays", "GregorianChronology.hours", "GregorianChronology.minutes", "GregorianChronology.seconds", "GregorianChronology.millis", "GregorianChronology.centuries", "GregorianChronology.years", "GregorianChronology.weekyears", "GregorianChronology.months", "GregorianChronology.weeks", "GregorianChronology.days", "GregorianChronology.halfdays", "GregorianChronology.hours", "GregorianChronology.minutes", "GregorianChronology.seconds", "GregorianChronology.millis"], "method_name": "TestGregorianChronology.testDurationFields", "method_implementation": "{\n    final GregorianChronology greg = GregorianChronology.getInstance();\n    assertEquals(\"eras\", greg.eras().getName());\n    assertEquals(\"centuries\", greg.centuries().getName());\n    assertEquals(\"years\", greg.years().getName());\n    assertEquals(\"weekyears\", greg.weekyears().getName());\n    assertEquals(\"months\", greg.months().getName());\n    assertEquals(\"weeks\", greg.weeks().getName());\n    assertEquals(\"days\", greg.days().getName());\n    assertEquals(\"halfdays\", greg.halfdays().getName());\n    assertEquals(\"hours\", greg.hours().getName());\n    assertEquals(\"minutes\", greg.minutes().getName());\n    assertEquals(\"seconds\", greg.seconds().getName());\n    assertEquals(\"millis\", greg.millis().getName());\n    assertEquals(false, greg.eras().isSupported());\n    assertEquals(true, greg.centuries().isSupported());\n    assertEquals(true, greg.years().isSupported());\n    assertEquals(true, greg.weekyears().isSupported());\n    assertEquals(true, greg.months().isSupported());\n    assertEquals(true, greg.weeks().isSupported());\n    assertEquals(true, greg.days().isSupported());\n    assertEquals(true, greg.halfdays().isSupported());\n    assertEquals(true, greg.hours().isSupported());\n    assertEquals(true, greg.minutes().isSupported());\n    assertEquals(true, greg.seconds().isSupported());\n    assertEquals(true, greg.millis().isSupported());\n    assertEquals(false, greg.centuries().isPrecise());\n    assertEquals(false, greg.years().isPrecise());\n    assertEquals(false, greg.weekyears().isPrecise());\n    assertEquals(false, greg.months().isPrecise());\n    assertEquals(false, greg.weeks().isPrecise());\n    assertEquals(false, greg.days().isPrecise());\n    assertEquals(false, greg.halfdays().isPrecise());\n    assertEquals(true, greg.hours().isPrecise());\n    assertEquals(true, greg.minutes().isPrecise());\n    assertEquals(true, greg.seconds().isPrecise());\n    assertEquals(true, greg.millis().isPrecise());\n    final GregorianChronology gregUTC = GregorianChronology.getInstanceUTC();\n    assertEquals(false, gregUTC.centuries().isPrecise());\n    assertEquals(false, gregUTC.years().isPrecise());\n    assertEquals(false, gregUTC.weekyears().isPrecise());\n    assertEquals(false, gregUTC.months().isPrecise());\n    assertEquals(true, gregUTC.weeks().isPrecise());\n    assertEquals(true, gregUTC.days().isPrecise());\n    assertEquals(true, gregUTC.halfdays().isPrecise());\n    assertEquals(true, gregUTC.hours().isPrecise());\n    assertEquals(true, gregUTC.minutes().isPrecise());\n    assertEquals(true, gregUTC.seconds().isPrecise());\n    assertEquals(true, gregUTC.millis().isPrecise());\n    final DateTimeZone gmt = DateTimeZone.forID(\"Etc/GMT\");\n    final GregorianChronology gregGMT = GregorianChronology.getInstance(gmt);\n    assertEquals(false, gregGMT.centuries().isPrecise());\n    assertEquals(false, gregGMT.years().isPrecise());\n    assertEquals(false, gregGMT.weekyears().isPrecise());\n    assertEquals(false, gregGMT.months().isPrecise());\n    assertEquals(true, gregGMT.weeks().isPrecise());\n    assertEquals(true, gregGMT.days().isPrecise());\n    assertEquals(true, gregGMT.halfdays().isPrecise());\n    assertEquals(true, gregGMT.hours().isPrecise());\n    assertEquals(true, gregGMT.minutes().isPrecise());\n    assertEquals(true, gregGMT.seconds().isPrecise());\n    assertEquals(true, gregGMT.millis().isPrecise());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1952, "method_signature": "void testDurationFields()"}, "TestGregorianChronology.testEquality": {"callee_method_names": [], "method_name": "TestGregorianChronology.testEquality", "method_implementation": "{\n    assertSame(GregorianChronology.getInstance(TOKYO), GregorianChronology.getInstance(TOKYO));\n    assertSame(GregorianChronology.getInstance(LONDON), GregorianChronology.getInstance(LONDON));\n    assertSame(GregorianChronology.getInstance(PARIS), GregorianChronology.getInstance(PARIS));\n    assertSame(GregorianChronology.getInstanceUTC(), GregorianChronology.getInstanceUTC());\n    assertSame(GregorianChronology.getInstance(), GregorianChronology.getInstance(LONDON));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1951, "method_signature": "void testEquality()"}, "TestHours.testAddToLocalDate": {"callee_method_names": ["LocalDateTime.plus"], "method_name": "TestHours.testAddToLocalDate", "method_implementation": "{\n    Hours test = Hours.hours(26);\n    LocalDateTime date = new LocalDateTime(2006, 6, 1, 0, 0, 0, 0);\n    LocalDateTime expected = new LocalDateTime(2006, 6, 2, 2, 0, 0, 0);\n    assertEquals(expected, date.plus(test));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2192, "method_signature": "void testAddToLocalDate()"}, "TestHours.testConstants": {"callee_method_names": [], "method_name": "TestHours.testConstants", "method_implementation": "{\n    assertEquals(0, Hours.ZERO.getHours());\n    assertEquals(1, Hours.ONE.getHours());\n    assertEquals(2, Hours.TWO.getHours());\n    assertEquals(3, Hours.THREE.getHours());\n    assertEquals(4, Hours.FOUR.getHours());\n    assertEquals(5, Hours.FIVE.getHours());\n    assertEquals(6, Hours.SIX.getHours());\n    assertEquals(7, Hours.SEVEN.getHours());\n    assertEquals(8, Hours.EIGHT.getHours());\n    assertEquals(Integer.MAX_VALUE, Hours.MAX_VALUE.getHours());\n    assertEquals(Integer.MIN_VALUE, Hours.MIN_VALUE.getHours());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2184, "method_signature": "void testConstants()"}, "TestHours.testFactory_hoursBetween_RInstant": {"callee_method_names": [], "method_name": "TestHours.testFactory_hoursBetween_RInstant", "method_implementation": "{\n    DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n    DateTime end1 = new DateTime(2006, 6, 9, 15, 0, 0, 0, PARIS);\n    DateTime end2 = new DateTime(2006, 6, 9, 18, 0, 0, 0, PARIS);\n    assertEquals(3, Hours.hoursBetween(start, end1).getHours());\n    assertEquals(0, Hours.hoursBetween(start, start).getHours());\n    assertEquals(0, Hours.hoursBetween(end1, end1).getHours());\n    assertEquals(-3, Hours.hoursBetween(end1, start).getHours());\n    assertEquals(6, Hours.hoursBetween(start, end2).getHours());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2186, "method_signature": "void testFactory_hoursBetween_RInstant()"}, "TestHours.testFactory_hours_int": {"callee_method_names": [], "method_name": "TestHours.testFactory_hours_int", "method_implementation": "{\n    assertSame(Hours.ZERO, Hours.hours(0));\n    assertSame(Hours.ONE, Hours.hours(1));\n    assertSame(Hours.TWO, Hours.hours(2));\n    assertSame(Hours.THREE, Hours.hours(3));\n    assertSame(Hours.FOUR, Hours.hours(4));\n    assertSame(Hours.FIVE, Hours.hours(5));\n    assertSame(Hours.SIX, Hours.hours(6));\n    assertSame(Hours.SEVEN, Hours.hours(7));\n    assertSame(Hours.EIGHT, Hours.hours(8));\n    assertSame(Hours.MAX_VALUE, Hours.hours(Integer.MAX_VALUE));\n    assertSame(Hours.MIN_VALUE, Hours.hours(Integer.MIN_VALUE));\n    assertEquals(-1, Hours.hours(-1).getHours());\n    assertEquals(9, Hours.hours(9).getHours());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2185, "method_signature": "void testFactory_hours_int()"}, "TestHours.testIsGreaterThan": {"callee_method_names": [], "method_name": "TestHours.testIsGreaterThan", "method_implementation": "{\n    assertEquals(true, Hours.THREE.isGreaterThan(Hours.TWO));\n    assertEquals(false, Hours.THREE.isGreaterThan(Hours.THREE));\n    assertEquals(false, Hours.TWO.isGreaterThan(Hours.THREE));\n    assertEquals(true, Hours.ONE.isGreaterThan(null));\n    assertEquals(false, Hours.hours(-1).isGreaterThan(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2187, "method_signature": "void testIsGreaterThan()"}, "TestHours.testPlus_int": {"callee_method_ids": [91], "callee_method_names": ["Hours.plus", "Hours.getHours", "Hours.getHours"], "method_name": "TestHours.testPlus_int", "method_implementation": "{\n    Hours test2 = Hours.hours(2);\n    Hours result = test2.plus(3);\n    assertEquals(2, test2.getHours());\n    assertEquals(5, result.getHours());\n    assertEquals(1, Hours.ONE.plus(0).getHours());\n    try {\n        Hours.MAX_VALUE.plus(1);\n        fail();\n    } catch (ArithmeticException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2191, "method_signature": "void testPlus_int()"}, "TestHours.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestHours.testSerialization", "method_implementation": "{\n    Hours test = Hours.SEVEN;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Hours result = (Hours) ois.readObject();\n    ois.close();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2189, "method_signature": "void testSerialization()"}, "TestHours.testToStandardWeeks": {"callee_method_names": ["Hours.toStandardWeeks"], "method_name": "TestHours.testToStandardWeeks", "method_implementation": "{\n    Hours test = Hours.hours(24 * 7 * 2);\n    Weeks expected = Weeks.weeks(2);\n    assertEquals(expected, test.toStandardWeeks());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2190, "method_signature": "void testToStandardWeeks()"}, "TestHours.testToString": {"callee_method_ids": [96, 96], "callee_method_names": ["Hours.toString", "Hours.toString"], "method_name": "TestHours.testToString", "method_implementation": "{\n    Hours test = Hours.hours(20);\n    assertEquals(\"PT20H\", test.toString());\n    test = Hours.hours(-20);\n    assertEquals(\"PT-20H\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2188, "method_signature": "void testToString()"}, "TestISOChronology.testDurationFields": {"callee_method_names": ["ISOChronology.eras", "ISOChronology.centuries", "ISOChronology.years", "ISOChronology.weekyears", "ISOChronology.months", "ISOChronology.weeks", "ISOChronology.days", "ISOChronology.halfdays", "ISOChronology.hours", "ISOChronology.minutes", "ISOChronology.seconds", "ISOChronology.millis", "ISOChronology.eras", "ISOChronology.centuries", "ISOChronology.years", "ISOChronology.weekyears", "ISOChronology.months", "ISOChronology.weeks", "ISOChronology.days", "ISOChronology.halfdays", "ISOChronology.hours", "ISOChronology.minutes", "ISOChronology.seconds", "ISOChronology.millis", "ISOChronology.centuries", "ISOChronology.years", "ISOChronology.weekyears", "ISOChronology.months", "ISOChronology.weeks", "ISOChronology.days", "ISOChronology.halfdays", "ISOChronology.hours", "ISOChronology.minutes", "ISOChronology.seconds", "ISOChronology.millis", "ISOChronology.centuries", "ISOChronology.years", "ISOChronology.weekyears", "ISOChronology.months", "ISOChronology.weeks", "ISOChronology.days", "ISOChronology.halfdays", "ISOChronology.hours", "ISOChronology.minutes", "ISOChronology.seconds", "ISOChronology.millis", "ISOChronology.centuries", "ISOChronology.years", "ISOChronology.weekyears", "ISOChronology.months", "ISOChronology.weeks", "ISOChronology.days", "ISOChronology.halfdays", "ISOChronology.hours", "ISOChronology.minutes", "ISOChronology.seconds", "ISOChronology.millis", "ISOChronology.centuries", "ISOChronology.years", "ISOChronology.weekyears", "ISOChronology.months", "ISOChronology.weeks", "ISOChronology.days", "ISOChronology.halfdays", "ISOChronology.hours", "ISOChronology.minutes", "ISOChronology.seconds", "ISOChronology.millis"], "method_name": "TestISOChronology.testDurationFields", "method_implementation": "{\n    final ISOChronology iso = ISOChronology.getInstance();\n    assertEquals(\"eras\", iso.eras().getName());\n    assertEquals(\"centuries\", iso.centuries().getName());\n    assertEquals(\"years\", iso.years().getName());\n    assertEquals(\"weekyears\", iso.weekyears().getName());\n    assertEquals(\"months\", iso.months().getName());\n    assertEquals(\"weeks\", iso.weeks().getName());\n    assertEquals(\"days\", iso.days().getName());\n    assertEquals(\"halfdays\", iso.halfdays().getName());\n    assertEquals(\"hours\", iso.hours().getName());\n    assertEquals(\"minutes\", iso.minutes().getName());\n    assertEquals(\"seconds\", iso.seconds().getName());\n    assertEquals(\"millis\", iso.millis().getName());\n    assertEquals(false, iso.eras().isSupported());\n    assertEquals(true, iso.centuries().isSupported());\n    assertEquals(true, iso.years().isSupported());\n    assertEquals(true, iso.weekyears().isSupported());\n    assertEquals(true, iso.months().isSupported());\n    assertEquals(true, iso.weeks().isSupported());\n    assertEquals(true, iso.days().isSupported());\n    assertEquals(true, iso.halfdays().isSupported());\n    assertEquals(true, iso.hours().isSupported());\n    assertEquals(true, iso.minutes().isSupported());\n    assertEquals(true, iso.seconds().isSupported());\n    assertEquals(true, iso.millis().isSupported());\n    assertEquals(false, iso.centuries().isPrecise());\n    assertEquals(false, iso.years().isPrecise());\n    assertEquals(false, iso.weekyears().isPrecise());\n    assertEquals(false, iso.months().isPrecise());\n    assertEquals(false, iso.weeks().isPrecise());\n    assertEquals(false, iso.days().isPrecise());\n    assertEquals(false, iso.halfdays().isPrecise());\n    assertEquals(true, iso.hours().isPrecise());\n    assertEquals(true, iso.minutes().isPrecise());\n    assertEquals(true, iso.seconds().isPrecise());\n    assertEquals(true, iso.millis().isPrecise());\n    final ISOChronology isoUTC = ISOChronology.getInstanceUTC();\n    assertEquals(false, isoUTC.centuries().isPrecise());\n    assertEquals(false, isoUTC.years().isPrecise());\n    assertEquals(false, isoUTC.weekyears().isPrecise());\n    assertEquals(false, isoUTC.months().isPrecise());\n    assertEquals(true, isoUTC.weeks().isPrecise());\n    assertEquals(true, isoUTC.days().isPrecise());\n    assertEquals(true, isoUTC.halfdays().isPrecise());\n    assertEquals(true, isoUTC.hours().isPrecise());\n    assertEquals(true, isoUTC.minutes().isPrecise());\n    assertEquals(true, isoUTC.seconds().isPrecise());\n    assertEquals(true, isoUTC.millis().isPrecise());\n    final DateTimeZone gmt = DateTimeZone.forID(\"Etc/GMT\");\n    final ISOChronology isoGMT = ISOChronology.getInstance(gmt);\n    assertEquals(false, isoGMT.centuries().isPrecise());\n    assertEquals(false, isoGMT.years().isPrecise());\n    assertEquals(false, isoGMT.weekyears().isPrecise());\n    assertEquals(false, isoGMT.months().isPrecise());\n    assertEquals(true, isoGMT.weeks().isPrecise());\n    assertEquals(true, isoGMT.days().isPrecise());\n    assertEquals(true, isoGMT.halfdays().isPrecise());\n    assertEquals(true, isoGMT.hours().isPrecise());\n    assertEquals(true, isoGMT.minutes().isPrecise());\n    assertEquals(true, isoGMT.seconds().isPrecise());\n    assertEquals(true, isoGMT.millis().isPrecise());\n    final DateTimeZone offset = DateTimeZone.forOffsetHours(1);\n    final ISOChronology isoOffset1 = ISOChronology.getInstance(offset);\n    assertEquals(false, isoOffset1.centuries().isPrecise());\n    assertEquals(false, isoOffset1.years().isPrecise());\n    assertEquals(false, isoOffset1.weekyears().isPrecise());\n    assertEquals(false, isoOffset1.months().isPrecise());\n    assertEquals(true, isoOffset1.weeks().isPrecise());\n    assertEquals(true, isoOffset1.days().isPrecise());\n    assertEquals(true, isoOffset1.halfdays().isPrecise());\n    assertEquals(true, isoOffset1.hours().isPrecise());\n    assertEquals(true, isoOffset1.minutes().isPrecise());\n    assertEquals(true, isoOffset1.seconds().isPrecise());\n    assertEquals(true, isoOffset1.millis().isPrecise());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1957, "method_signature": "void testDurationFields()"}, "TestISOChronology.testEquality": {"callee_method_names": [], "method_name": "TestISOChronology.testEquality", "method_implementation": "{\n    assertSame(ISOChronology.getInstance(TOKYO), ISOChronology.getInstance(TOKYO));\n    assertSame(ISOChronology.getInstance(LONDON), ISOChronology.getInstance(LONDON));\n    assertSame(ISOChronology.getInstance(PARIS), ISOChronology.getInstance(PARIS));\n    assertSame(ISOChronology.getInstanceUTC(), ISOChronology.getInstanceUTC());\n    assertSame(ISOChronology.getInstance(), ISOChronology.getInstance(LONDON));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1956, "method_signature": "void testEquality()"}, "TestISODateTimeFormat.testFormat_basicDate": {"callee_method_names": ["DateTime.withZone", "DateTime.withZone"], "method_name": "TestISODateTimeFormat.testFormat_basicDate", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"20040609\", ISODateTimeFormat.basicDate().print(dt));\n    dt = dt.withZone(LONDON);\n    assertEquals(\"20040609\", ISODateTimeFormat.basicDate().print(dt));\n    dt = dt.withZone(PARIS);\n    assertEquals(\"20040609\", ISODateTimeFormat.basicDate().print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2315, "method_signature": "void testFormat_basicDate()"}, "TestISODateTimeFormat.testFormat_date": {"callee_method_names": ["DateTime.withZone", "DateTime.withZone"], "method_name": "TestISODateTimeFormat.testFormat_date", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"2004-06-09\", ISODateTimeFormat.date().print(dt));\n    dt = dt.withZone(LONDON);\n    assertEquals(\"2004-06-09\", ISODateTimeFormat.date().print(dt));\n    dt = dt.withZone(PARIS);\n    assertEquals(\"2004-06-09\", ISODateTimeFormat.date().print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2314, "method_signature": "void testFormat_date()"}, "TestISODateTimeFormat.testFormat_dateHour": {"callee_method_names": ["DateTime.withZone", "DateTime.withZone"], "method_name": "TestISODateTimeFormat.testFormat_dateHour", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"2004-06-09T10\", ISODateTimeFormat.dateHour().print(dt));\n    dt = dt.withZone(LONDON);\n    assertEquals(\"2004-06-09T11\", ISODateTimeFormat.dateHour().print(dt));\n    dt = dt.withZone(PARIS);\n    assertEquals(\"2004-06-09T12\", ISODateTimeFormat.dateHour().print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2318, "method_signature": "void testFormat_dateHour()"}, "TestISODateTimeFormat.testFormat_hour": {"callee_method_names": ["DateTime.withZone", "DateTime.withZone"], "method_name": "TestISODateTimeFormat.testFormat_hour", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"10\", ISODateTimeFormat.hour().print(dt));\n    dt = dt.withZone(LONDON);\n    assertEquals(\"11\", ISODateTimeFormat.hour().print(dt));\n    dt = dt.withZone(PARIS);\n    assertEquals(\"12\", ISODateTimeFormat.hour().print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2317, "method_signature": "void testFormat_hour()"}, "TestISODateTimeFormat.testFormat_year": {"callee_method_names": ["DateTime.withZone", "DateTime.withZone"], "method_name": "TestISODateTimeFormat.testFormat_year", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 10, 20, 30, 40, UTC);\n    assertEquals(\"2004\", ISODateTimeFormat.year().print(dt));\n    dt = dt.withZone(LONDON);\n    assertEquals(\"2004\", ISODateTimeFormat.year().print(dt));\n    dt = dt.withZone(PARIS);\n    assertEquals(\"2004\", ISODateTimeFormat.year().print(dt));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2316, "method_signature": "void testFormat_year()"}, "TestISODateTimeFormat.testSubclassableConstructor": {"callee_method_names": [], "method_name": "TestISODateTimeFormat.testSubclassableConstructor", "method_implementation": "{\n    ISODateTimeFormat f = new ISODateTimeFormat() {\n    };\n    assertNotNull(f);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2313, "method_signature": "void testSubclassableConstructor()"}, "TestISODateTimeFormatParsing.assertParse": {"callee_method_ids": [858, 858], "callee_method_names": ["DateTimeFormatter.parseMillis", "DateTimeFormatter.parseMillis"], "method_name": "TestISODateTimeFormatParsing.assertParse", "method_implementation": "{\n    if (expected) {\n        parser.parseMillis(str);\n    } else {\n        try {\n            parser.parseMillis(str);\n            fail();\n        } catch (IllegalArgumentException ex) {\n            // expected\n        }\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2388, "method_signature": "void assertParse(DateTimeFormatter, boolean, String)"}, "TestISODateTimeFormatParsing.test_basicDate": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicDate", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.basicDate();\n    assertParse(parser, \"20060204\", new DateTime(2006, 2, 4, 0, 0, 0, 0));\n    assertParse(parser, \"+20060204\", new DateTime(2006, 2, 4, 0, 0, 0, 0));\n    assertParse(parser, false, \"2006024\");\n    assertParse(parser, false, \"200602\");\n    assertParse(parser, false, \"20061\");\n    assertParse(parser, false, \"2006\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2371, "method_signature": "void test_basicDate()"}, "TestISODateTimeFormatParsing.test_basicDateTime": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicDateTime", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicDateTime();\n    assertParse(parser, \"20061204T102030.400999999Z\", new DateTime(2006, 12, 4, 10, 20, 30, 400));\n    assertParse(parser, \"20061204T102030.400Z\", new DateTime(2006, 12, 4, 10, 20, 30, 400));\n    assertParse(parser, \"20061204T102030.40Z\", new DateTime(2006, 12, 4, 10, 20, 30, 400));\n    assertParse(parser, \"20061204T102030.4Z\", new DateTime(2006, 12, 4, 10, 20, 30, 400));\n    assertParse(parser, \"+20061204T102030.4Z\", new DateTime(2006, 12, 4, 10, 20, 30, 400));\n    assertParse(parser, false, \"2006120T102030.400Z\");\n    assertParse(parser, false, \"200612T102030.400Z\");\n    assertParse(parser, false, \"20061T102030.400Z\");\n    assertParse(parser, false, \"2006T102030.400Z\");\n    assertParse(parser, false, \"200T102030.400Z\");\n    assertParse(parser, false, \"20T102030.400Z\");\n    assertParse(parser, false, \"2T102030.400Z\");\n    assertParse(parser, false, \"20061204T10203.400Z\");\n    assertParse(parser, false, \"20061204T1020.400Z\");\n    assertParse(parser, false, \"20061204T102.400Z\");\n    assertParse(parser, false, \"20061204T10.400Z\");\n    assertParse(parser, false, \"20061204T1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2376, "method_signature": "void test_basicDateTime()"}, "TestISODateTimeFormatParsing.test_basicDateTimeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicDateTimeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicDateTimeNoMillis();\n    assertParse(parser, \"20061204T102030Z\", new DateTime(2006, 12, 4, 10, 20, 30, 0));\n    assertParse(parser, \"+20061204T102030Z\", new DateTime(2006, 12, 4, 10, 20, 30, 0));\n    assertParse(parser, false, \"2006120T102030Z\");\n    assertParse(parser, false, \"200612T102030Z\");\n    assertParse(parser, false, \"20061T102030Z\");\n    assertParse(parser, false, \"2006T102030Z\");\n    assertParse(parser, false, \"200T102030Z\");\n    assertParse(parser, false, \"20T102030Z\");\n    assertParse(parser, false, \"2T102030Z\");\n    assertParse(parser, false, \"20061204T10203Z\");\n    assertParse(parser, false, \"20061204T1020Z\");\n    assertParse(parser, false, \"20061204T102Z\");\n    assertParse(parser, false, \"20061204T10Z\");\n    assertParse(parser, false, \"20061204T1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2377, "method_signature": "void test_basicDateTimeNoMillis()"}, "TestISODateTimeFormatParsing.test_basicOrdinalDate": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicOrdinalDate", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.basicOrdinalDate();\n    assertParse(parser, \"2006123\", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(123));\n    assertParse(parser, \"+2006123\", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(123));\n    assertParse(parser, false, \"200612\");\n    assertParse(parser, false, \"20061\");\n    assertParse(parser, false, \"2006\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2378, "method_signature": "void test_basicOrdinalDate()"}, "TestISODateTimeFormatParsing.test_basicOrdinalDateTime": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicOrdinalDateTime", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicOrdinalDateTime();\n    assertParse(parser, \"2006123T102030.400999999Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123));\n    assertParse(parser, \"2006123T102030.400Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123));\n    assertParse(parser, \"2006123T102030.40Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123));\n    assertParse(parser, \"2006123T102030.4Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123));\n    assertParse(parser, \"+2006123T102030.4Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123));\n    assertParse(parser, false, \"200612T102030.400Z\");\n    assertParse(parser, false, \"20061T102030.400Z\");\n    assertParse(parser, false, \"2006T102030.400Z\");\n    assertParse(parser, false, \"200T102030.400Z\");\n    assertParse(parser, false, \"20T102030.400Z\");\n    assertParse(parser, false, \"2T102030.400Z\");\n    assertParse(parser, false, \"2006123T10203.400Z\");\n    assertParse(parser, false, \"2006123T1020.400Z\");\n    assertParse(parser, false, \"2006123T102.400Z\");\n    assertParse(parser, false, \"2006123T10.400Z\");\n    assertParse(parser, false, \"2006123T1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2379, "method_signature": "void test_basicOrdinalDateTime()"}, "TestISODateTimeFormatParsing.test_basicOrdinalDateTimeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicOrdinalDateTimeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicOrdinalDateTimeNoMillis();\n    assertParse(parser, \"2006123T102030Z\", new DateTime(2006, 1, 1, 10, 20, 30, 0).withDayOfYear(123));\n    assertParse(parser, \"+2006123T102030Z\", new DateTime(2006, 1, 1, 10, 20, 30, 0).withDayOfYear(123));\n    assertParse(parser, false, \"200612T102030Z\");\n    assertParse(parser, false, \"20061T102030Z\");\n    assertParse(parser, false, \"2006T102030Z\");\n    assertParse(parser, false, \"200T102030Z\");\n    assertParse(parser, false, \"20T102030Z\");\n    assertParse(parser, false, \"2T102030Z\");\n    assertParse(parser, false, \"2006123T10203Z\");\n    assertParse(parser, false, \"2006123T1020Z\");\n    assertParse(parser, false, \"2006123T102Z\");\n    assertParse(parser, false, \"2006123T10Z\");\n    assertParse(parser, false, \"2006123T1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2380, "method_signature": "void test_basicOrdinalDateTimeNoMillis()"}, "TestISODateTimeFormatParsing.test_basicTTime": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicTTime", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicTTime();\n    assertParse(parser, \"T102030.400999999Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"T102030.400Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"T102030.40Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"T102030.4Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, false, \"T10203.400Z\");\n    assertParse(parser, false, \"T1020.400Z\");\n    assertParse(parser, false, \"T102.400Z\");\n    assertParse(parser, false, \"T10.400Z\");\n    assertParse(parser, false, \"T1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2374, "method_signature": "void test_basicTTime()"}, "TestISODateTimeFormatParsing.test_basicTTimeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicTTimeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicTTimeNoMillis();\n    assertParse(parser, \"T102030Z\", new DateTime(1970, 1, 1, 10, 20, 30, 0));\n    assertParse(parser, false, \"T10203Z\");\n    assertParse(parser, false, \"T1020Z\");\n    assertParse(parser, false, \"T102Z\");\n    assertParse(parser, false, \"T10Z\");\n    assertParse(parser, false, \"T1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2375, "method_signature": "void test_basicTTimeNoMillis()"}, "TestISODateTimeFormatParsing.test_basicTime": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicTime", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicTime();\n    assertParse(parser, \"102030.400999999Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"102030.400Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"102030.40Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"102030.4Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, false, \"10203.400Z\");\n    assertParse(parser, false, \"1020.400Z\");\n    assertParse(parser, false, \"102.400Z\");\n    assertParse(parser, false, \"10.400Z\");\n    assertParse(parser, false, \"1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2372, "method_signature": "void test_basicTime()"}, "TestISODateTimeFormatParsing.test_basicTimeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicTimeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicTimeNoMillis();\n    assertParse(parser, \"102030Z\", new DateTime(1970, 1, 1, 10, 20, 30, 0));\n    assertParse(parser, false, \"10203Z\");\n    assertParse(parser, false, \"1020Z\");\n    assertParse(parser, false, \"102Z\");\n    assertParse(parser, false, \"10Z\");\n    assertParse(parser, false, \"1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2373, "method_signature": "void test_basicTimeNoMillis()"}, "TestISODateTimeFormatParsing.test_basicWeekDate": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicWeekDate", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.basicWeekDate();\n    assertParse(parser, \"2006W273\", new DateTime(2006, 6, 1, 0, 0, 0, 0).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"+2006W273\", new DateTime(2006, 6, 1, 0, 0, 0, 0).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, false, \"2006W27\");\n    assertParse(parser, false, \"2006W2\");\n    assertParse(parser, false, \"2006W\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2381, "method_signature": "void test_basicWeekDate()"}, "TestISODateTimeFormatParsing.test_basicWeekDateTime": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicWeekDateTime", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicWeekDateTime();\n    assertParse(parser, \"2006W273T102030.400999999Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"2006W273T102030.400Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"2006W273T102030.40Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"2006W273T102030.4Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"+2006W273T102030.4Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, false, \"2006W27T102030.400Z\");\n    assertParse(parser, false, \"2006W2T102030.400Z\");\n    assertParse(parser, false, \"2006W273T10203.400Z\");\n    assertParse(parser, false, \"2006W273T1020.400Z\");\n    assertParse(parser, false, \"2006W273T102.400Z\");\n    assertParse(parser, false, \"2006W273T10.400Z\");\n    assertParse(parser, false, \"2006W273T1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2382, "method_signature": "void test_basicWeekDateTime()"}, "TestISODateTimeFormatParsing.test_basicWeekDateTimeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_basicWeekDateTimeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.basicWeekDateTimeNoMillis();\n    assertParse(parser, \"2006W273T102030Z\", new DateTime(2006, 6, 1, 10, 20, 30, 0).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"+2006W273T102030Z\", new DateTime(2006, 6, 1, 10, 20, 30, 0).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, false, \"2006W27T102030Z\");\n    assertParse(parser, false, \"2006W2T102030Z\");\n    assertParse(parser, false, \"2006W273T10203Z\");\n    assertParse(parser, false, \"2006W273T1020Z\");\n    assertParse(parser, false, \"2006W273T102Z\");\n    assertParse(parser, false, \"2006W273T10Z\");\n    assertParse(parser, false, \"2006W273T1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2383, "method_signature": "void test_basicWeekDateTimeNoMillis()"}, "TestISODateTimeFormatParsing.test_date": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_date", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.date();\n    assertParse(parser, \"2006-02-04\", new DateTime(2006, 2, 4, 0, 0, 0, 0));\n    assertParse(parser, \"2006-2-04\", new DateTime(2006, 2, 4, 0, 0, 0, 0));\n    assertParse(parser, \"2006-02-4\", new DateTime(2006, 2, 4, 0, 0, 0, 0));\n    assertParse(parser, \"2006-2-4\", new DateTime(2006, 2, 4, 0, 0, 0, 0));\n    assertParse(parser, \"+2006-02-04\", new DateTime(2006, 2, 4, 0, 0, 0, 0));\n    assertParse(parser, false, \"2006-02-\");\n    assertParse(parser, false, \"2006-02\");\n    assertParse(parser, false, \"2006--4\");\n    assertParse(parser, false, \"2006-1\");\n    assertParse(parser, false, \"2006\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2358, "method_signature": "void test_date()"}, "TestISODateTimeFormatParsing.test_dateElementParser": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_dateElementParser", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.dateElementParser();\n    assertParse(parser, \"2006-06-09\", new DateTime(2006, 6, 9, 0, 0, 0, 0));\n    assertParse(parser, \"2006-06-9\", new DateTime(2006, 6, 9, 0, 0, 0, 0));\n    assertParse(parser, \"2006-6-09\", new DateTime(2006, 6, 9, 0, 0, 0, 0));\n    assertParse(parser, \"2006-6-9\", new DateTime(2006, 6, 9, 0, 0, 0, 0));\n    assertParse(parser, \"+2006-06-09\", new DateTime(2006, 6, 9, 0, 0, 0, 0));\n    assertParse(parser, true, \"2006-W27-3\");\n    assertParse(parser, true, \"2006-123\");\n    assertParse(parser, false, \"2006-06-09T+02:00\");\n    assertParse(parser, false, \"2006-W27-3T+02:00\");\n    assertParse(parser, false, \"2006-123T+02:00\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040\");\n    assertParse(parser, false, \"2006-123T10:20:30.040\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-123T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10:20:30.040\");\n    assertParse(parser, false, \"T10.5\");\n    assertParse(parser, false, \"T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10.5+02:00\");\n    assertParse(parser, false, \"10:20:30.040\");\n    assertParse(parser, false, \"10.5\");\n    assertParse(parser, false, \"10:20:30.040+02:00\");\n    assertParse(parser, false, \"10.5+02:00\");\n    assertNoPrint(parser);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2351, "method_signature": "void test_dateElementParser()"}, "TestISODateTimeFormatParsing.test_dateOptionalTimeParser": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_dateOptionalTimeParser", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.dateOptionalTimeParser();\n    assertParse(parser, true, \"2006-06-09\");\n    assertParse(parser, true, \"2006-W27-3\");\n    assertParse(parser, true, \"2006-123\");\n    assertParse(parser, true, \"2006-06-09T+02:00\");\n    assertParse(parser, true, \"2006-W27-3T+02:00\");\n    assertParse(parser, true, \"2006-123T+02:00\");\n    assertParse(parser, true, \"2006-06-09T10:20:30.040\");\n    assertParse(parser, true, \"2006-W27-3T10:20:30.040\");\n    assertParse(parser, true, \"2006-123T10:20:30.040\");\n    assertParse(parser, true, \"2006-06-09T10:20:30.040+02:00\");\n    assertParse(parser, true, \"2006-W27-3T10:20:30.040+02:00\");\n    assertParse(parser, true, \"2006-123T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10:20:30.040\");\n    assertParse(parser, false, \"T10.5\");\n    assertParse(parser, false, \"T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10.5+02:00\");\n    assertParse(parser, false, \"10:20:30.040\");\n    assertParse(parser, false, \"10.5\");\n    assertParse(parser, false, \"10:20:30.040+02:00\");\n    assertParse(parser, false, \"10.5+02:00\");\n    assertNoPrint(parser);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2356, "method_signature": "void test_dateOptionalTimeParser()"}, "TestISODateTimeFormatParsing.test_dateParser": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_dateParser", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.dateParser();\n    assertParse(parser, true, \"2006-06-09\");\n    assertParse(parser, true, \"+2006-06-09\");\n    assertParse(parser, true, \"2006-W27-3\");\n    assertParse(parser, true, \"2006-123\");\n    assertParse(parser, true, \"2006-06-09T+02:00\");\n    assertParse(parser, true, \"2006-W27-3T+02:00\");\n    assertParse(parser, true, \"2006-123T+02:00\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040\");\n    assertParse(parser, false, \"+2006-06-09T10:20:30.040\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040\");\n    assertParse(parser, false, \"2006-123T10:20:30.040\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-123T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10:20:30.040\");\n    assertParse(parser, false, \"T10.5\");\n    assertParse(parser, false, \"T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10.5+02:00\");\n    assertParse(parser, false, \"10:20:30.040\");\n    assertParse(parser, false, \"10.5\");\n    assertParse(parser, false, \"10:20:30.040+02:00\");\n    assertParse(parser, false, \"10.5+02:00\");\n    assertNoPrint(parser);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2349, "method_signature": "void test_dateParser()"}, "TestISODateTimeFormatParsing.test_dateTime": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_dateTime", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.dateTime();\n    assertParse(parser, \"2006-02-04T10:20:30.400999999Z\", new DateTime(2006, 2, 4, 10, 20, 30, 400));\n    assertParse(parser, \"2006-02-04T10:20:30.400Z\", new DateTime(2006, 2, 4, 10, 20, 30, 400));\n    assertParse(parser, \"2006-02-04T10:20:30.40Z\", new DateTime(2006, 2, 4, 10, 20, 30, 400));\n    assertParse(parser, \"2006-02-04T10:20:30.4Z\", new DateTime(2006, 2, 4, 10, 20, 30, 400));\n    assertParse(parser, \"2006-02-4T10:20:30.400Z\", new DateTime(2006, 2, 4, 10, 20, 30, 400));\n    assertParse(parser, \"2006-2-04T10:20:30.400Z\", new DateTime(2006, 2, 4, 10, 20, 30, 400));\n    assertParse(parser, \"2006-2-4T10:20:30.400Z\", new DateTime(2006, 2, 4, 10, 20, 30, 400));\n    assertParse(parser, \"2006-02-04T5:6:7.800Z\", new DateTime(2006, 2, 4, 5, 6, 7, 800));\n    assertParse(parser, \"+2006-02-04T5:6:7.800Z\", new DateTime(2006, 2, 4, 5, 6, 7, 800));\n    assertParse(parser, false, \"2006-02-T10:20:30.400Z\");\n    assertParse(parser, false, \"2006-12T10:20:30.400Z\");\n    assertParse(parser, false, \"2006-1T10:20:30.400Z\");\n    assertParse(parser, false, \"2006T10:20:30.400Z\");\n    assertParse(parser, false, \"200T10:20:30.400Z\");\n    assertParse(parser, false, \"20T10:20:30.400Z\");\n    assertParse(parser, false, \"2T10:20:30.400Z\");\n    assertParse(parser, false, \"2006-02-04T10:20.400Z\");\n    assertParse(parser, false, \"2006-02-04T10:2.400Z\");\n    assertParse(parser, false, \"2006-02-04T10.400Z\");\n    assertParse(parser, false, \"2006-02-04T1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2363, "method_signature": "void test_dateTime()"}, "TestISODateTimeFormatParsing.test_dateTimeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_dateTimeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.dateTimeNoMillis();\n    assertParse(parser, \"2006-02-04T10:20:30Z\", new DateTime(2006, 2, 4, 10, 20, 30, 0));\n    assertParse(parser, \"2006-02-4T10:20:30Z\", new DateTime(2006, 2, 4, 10, 20, 30, 0));\n    assertParse(parser, \"2006-2-04T10:20:30Z\", new DateTime(2006, 2, 4, 10, 20, 30, 0));\n    assertParse(parser, \"2006-2-4T10:20:30Z\", new DateTime(2006, 2, 4, 10, 20, 30, 0));\n    assertParse(parser, \"2006-02-04T5:6:7Z\", new DateTime(2006, 2, 4, 5, 6, 7, 0));\n    assertParse(parser, \"+2006-02-04T5:6:7Z\", new DateTime(2006, 2, 4, 5, 6, 7, 0));\n    assertParse(parser, false, \"2006-02-T10:20:30Z\");\n    assertParse(parser, false, \"2006-12T10:20:30Z\");\n    assertParse(parser, false, \"2006-1T10:20:30Z\");\n    assertParse(parser, false, \"2006T10:20:30Z\");\n    assertParse(parser, false, \"200T10:20:30Z\");\n    assertParse(parser, false, \"20T10:20:30Z\");\n    assertParse(parser, false, \"2T10:20:30Z\");\n    assertParse(parser, false, \"2006-02-04T10:20Z\");\n    assertParse(parser, false, \"2006-02-04T10:2Z\");\n    assertParse(parser, false, \"2006-02-04T10Z\");\n    assertParse(parser, false, \"2006-02-04T1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2364, "method_signature": "void test_dateTimeNoMillis()"}, "TestISODateTimeFormatParsing.test_dateTimeParser": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_dateTimeParser", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.dateTimeParser();\n    assertParse(parser, true, \"2006-06-09\");\n    assertParse(parser, true, \"2006-W27-3\");\n    assertParse(parser, true, \"2006-123\");\n    assertParse(parser, true, \"2006-06-09T+02:00\");\n    assertParse(parser, true, \"2006-W27-3T+02:00\");\n    assertParse(parser, true, \"2006-123T+02:00\");\n    assertParse(parser, true, \"2006-06-09T10:20:30.040\");\n    assertParse(parser, true, \"2006-W27-3T10:20:30.040\");\n    assertParse(parser, true, \"2006-123T10:20:30.040\");\n    assertParse(parser, true, \"2006-06-09T10:20:30.040+02:00\");\n    assertParse(parser, true, \"2006-W27-3T10:20:30.040+02:00\");\n    assertParse(parser, true, \"2006-123T10:20:30.040+02:00\");\n    assertParse(parser, true, \"T10:20:30.040\");\n    assertParse(parser, true, \"T10.5\");\n    assertParse(parser, true, \"T10:20:30.040+02:00\");\n    assertParse(parser, true, \"T10.5+02:00\");\n    assertParse(parser, false, \"10:20:30.040\");\n    assertParse(parser, false, \"10.5\");\n    assertParse(parser, false, \"10:20:30.040+02:00\");\n    assertParse(parser, false, \"10.5+02:00\");\n    assertNoPrint(parser);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2355, "method_signature": "void test_dateTimeParser()"}, "TestISODateTimeFormatParsing.test_hourMinute": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_hourMinute", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.hourMinute();\n    assertParse(parser, \"10:20\", new DateTime(1970, 1, 1, 10, 20, 0, 0));\n    assertParse(parser, \"5:6\", new DateTime(1970, 1, 1, 5, 6, 0, 0));\n    assertParse(parser, false, \"10:20:30.400999999\");\n    assertParse(parser, false, \"10:20:30.400\");\n    assertParse(parser, false, \"10:20:30\");\n    assertParse(parser, false, \"10:20.400\");\n    assertParse(parser, false, \"10:2.400\");\n    assertParse(parser, false, \"10.400\");\n    assertParse(parser, false, \"1.400\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2384, "method_signature": "void test_hourMinute()"}, "TestISODateTimeFormatParsing.test_hourMinuteSecond": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_hourMinuteSecond", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.hourMinuteSecond();\n    assertParse(parser, \"10:20:30\", new DateTime(1970, 1, 1, 10, 20, 30, 0));\n    assertParse(parser, \"5:6:7\", new DateTime(1970, 1, 1, 5, 6, 7, 0));\n    assertParse(parser, false, \"10:20:30.400999999\");\n    assertParse(parser, false, \"10:20:30.400\");\n    assertParse(parser, false, \"10:20:30.4\");\n    assertParse(parser, false, \"10:20.400\");\n    assertParse(parser, false, \"10:2.400\");\n    assertParse(parser, false, \"10.400\");\n    assertParse(parser, false, \"1.400\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2385, "method_signature": "void test_hourMinuteSecond()"}, "TestISODateTimeFormatParsing.test_hourMinuteSecondFraction": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_hourMinuteSecondFraction", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.hourMinuteSecondFraction();\n    assertParse(parser, \"10:20:30.400999999\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"10:20:30.400\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"10:20:30.40\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"10:20:30.4\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"5:6:7.8\", new DateTime(1970, 1, 1, 5, 6, 7, 800));\n    assertParse(parser, false, \"10:20.400\");\n    assertParse(parser, false, \"10:2.400\");\n    assertParse(parser, false, \"10.400\");\n    assertParse(parser, false, \"1.400\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2387, "method_signature": "void test_hourMinuteSecondFraction()"}, "TestISODateTimeFormatParsing.test_hourMinuteSecondMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_hourMinuteSecondMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.hourMinuteSecondMillis();\n    assertParse(parser, \"10:20:30.400\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"10:20:30.40\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"10:20:30.4\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"5:6:7.8\", new DateTime(1970, 1, 1, 5, 6, 7, 800));\n    assertParse(parser, false, \"10:20:30.400999999\");\n    assertParse(parser, false, \"10:20.400\");\n    assertParse(parser, false, \"10:2.400\");\n    assertParse(parser, false, \"10.400\");\n    assertParse(parser, false, \"1.400\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2386, "method_signature": "void test_hourMinuteSecondMillis()"}, "TestISODateTimeFormatParsing.test_localDateOptionalTimeParser": {"callee_method_names": ["DateTimeFormatter.getZone"], "method_name": "TestISODateTimeFormatParsing.test_localDateOptionalTimeParser", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.localDateOptionalTimeParser();\n    assertEquals(DateTimeZone.UTC, parser.getZone());\n    assertParse(parser, true, \"2006-06-09\");\n    assertParse(parser, true, \"2006-W27-3\");\n    assertParse(parser, true, \"2006-123\");\n    assertParse(parser, false, \"2006-06-09T+02:00\");\n    assertParse(parser, false, \"2006-W27-3T+02:00\");\n    assertParse(parser, false, \"2006-123T+02:00\");\n    assertParse(parser, true, \"2006-06-09T10:20:30.040\");\n    assertParse(parser, true, \"2006-W27-3T10:20:30.040\");\n    assertParse(parser, true, \"2006-123T10:20:30.040\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-123T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10:20:30.040\");\n    assertParse(parser, false, \"T10.5\");\n    assertParse(parser, false, \"T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10.5+02:00\");\n    assertParse(parser, false, \"10:20:30.040\");\n    assertParse(parser, false, \"10.5\");\n    assertParse(parser, false, \"10:20:30.040+02:00\");\n    assertParse(parser, false, \"10.5+02:00\");\n    assertNoPrint(parser);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2357, "method_signature": "void test_localDateOptionalTimeParser()"}, "TestISODateTimeFormatParsing.test_localDateParser": {"callee_method_names": ["DateTimeFormatter.getZone"], "method_name": "TestISODateTimeFormatParsing.test_localDateParser", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.localDateParser();\n    assertEquals(DateTimeZone.UTC, parser.getZone());\n    assertParse(parser, true, \"2006-06-09\");\n    assertParse(parser, true, \"+2006-06-09\");\n    assertParse(parser, true, \"2006-W27-3\");\n    assertParse(parser, true, \"2006-123\");\n    assertParse(parser, false, \"2006-06-09T+02:00\");\n    assertParse(parser, false, \"2006-W27-3T+02:00\");\n    assertParse(parser, false, \"2006-123T+02:00\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040\");\n    assertParse(parser, false, \"2006-123T10:20:30.040\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-123T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10:20:30.040\");\n    assertParse(parser, false, \"T10.5\");\n    assertParse(parser, false, \"T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10.5+02:00\");\n    assertParse(parser, false, \"10:20:30.040\");\n    assertParse(parser, false, \"10.5\");\n    assertParse(parser, false, \"10:20:30.040+02:00\");\n    assertParse(parser, false, \"10.5+02:00\");\n    assertNoPrint(parser);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2350, "method_signature": "void test_localDateParser()"}, "TestISODateTimeFormatParsing.test_localTimeParser": {"callee_method_ids": [858], "callee_method_names": ["DateTimeFormatter.getZone", "DateTimeFormatter.parseMillis"], "method_name": "TestISODateTimeFormatParsing.test_localTimeParser", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.localTimeParser();\n    assertEquals(DateTimeZone.UTC, parser.getZone());\n    assertParse(parser, false, \"2006-06-09\");\n    assertParse(parser, false, \"2006-W27-3\");\n    assertParse(parser, false, \"2006-123\");\n    assertParse(parser, false, \"2006-06-09T+02:00\");\n    assertParse(parser, false, \"2006-W27-3T+02:00\");\n    assertParse(parser, false, \"2006-123T+02:00\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040\");\n    assertParse(parser, false, \"2006-123T10:20:30.040\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-123T10:20:30.040+02:00\");\n    assertParse(parser, true, \"T10:20:30.040\");\n    assertParse(parser, true, \"T10.5\");\n    assertParse(parser, false, \"T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10.5+02:00\");\n    assertParse(parser, true, \"10:20:30.040\");\n    assertParse(parser, true, \"10.5\");\n    assertParse(parser, false, \"10:20:30.040+02:00\");\n    assertParse(parser, false, \"10.5+02:00\");\n    assertParse(parser, true, \"00:00:10.512345678\");\n    assertEquals(10512, parser.parseMillis(\"00:00:10.512345678\"));\n    assertNoPrint(parser);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2353, "method_signature": "void test_localTimeParser()"}, "TestISODateTimeFormatParsing.test_ordinalDate": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_ordinalDate", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.ordinalDate();\n    assertParse(parser, \"2006-123\", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(123));\n    assertParse(parser, \"2006-12\", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(12));\n    assertParse(parser, \"2006-1\", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(1));\n    assertParse(parser, \"+2006-123\", new DateTime(2006, 1, 1, 0, 0, 0, 0).withDayOfYear(123));\n    assertParse(parser, false, \"2006-\");\n    assertParse(parser, false, \"2006\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2365, "method_signature": "void test_ordinalDate()"}, "TestISODateTimeFormatParsing.test_ordinalDateTime": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_ordinalDateTime", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.ordinalDateTime();\n    assertParse(parser, \"2006-123T10:20:30.400999999Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123));\n    assertParse(parser, \"2006-123T10:20:30.400Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123));\n    assertParse(parser, \"2006-123T10:20:30.40Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123));\n    assertParse(parser, \"2006-123T10:20:30.4Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(123));\n    assertParse(parser, \"2006-12T10:20:30.400Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(12));\n    assertParse(parser, \"2006-1T10:20:30.400Z\", new DateTime(2006, 1, 1, 10, 20, 30, 400).withDayOfYear(1));\n    assertParse(parser, \"2006-123T5:6:7.800Z\", new DateTime(2006, 1, 1, 5, 6, 7, 800).withDayOfYear(123));\n    assertParse(parser, \"+2006-123T5:6:7.800Z\", new DateTime(2006, 1, 1, 5, 6, 7, 800).withDayOfYear(123));\n    assertParse(parser, false, \"2006-T10:20:30.400Z\");\n    assertParse(parser, false, \"2006T10:20:30.400Z\");\n    assertParse(parser, false, \"2006-123T10:20.400Z\");\n    assertParse(parser, false, \"2006-123T10:2.400Z\");\n    assertParse(parser, false, \"2006-123T10.400Z\");\n    assertParse(parser, false, \"2006-123T1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2366, "method_signature": "void test_ordinalDateTime()"}, "TestISODateTimeFormatParsing.test_ordinalDateTimeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_ordinalDateTimeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.ordinalDateTimeNoMillis();\n    assertParse(parser, \"2006-123T10:20:30Z\", new DateTime(2006, 1, 1, 10, 20, 30, 0).withDayOfYear(123));\n    assertParse(parser, \"2006-12T10:20:30Z\", new DateTime(2006, 1, 1, 10, 20, 30, 0).withDayOfYear(12));\n    assertParse(parser, \"2006-1T10:20:30Z\", new DateTime(2006, 1, 1, 10, 20, 30, 0).withDayOfYear(1));\n    assertParse(parser, \"2006-123T5:6:7Z\", new DateTime(2006, 1, 1, 5, 6, 7, 0).withDayOfYear(123));\n    assertParse(parser, \"+2006-123T5:6:7Z\", new DateTime(2006, 1, 1, 5, 6, 7, 0).withDayOfYear(123));\n    assertParse(parser, false, \"2006-T10:20:30Z\");\n    assertParse(parser, false, \"2006T10:20:30Z\");\n    assertParse(parser, false, \"2006-123T10:20Z\");\n    assertParse(parser, false, \"2006-123T10:2Z\");\n    assertParse(parser, false, \"2006-123T10Z\");\n    assertParse(parser, false, \"2006-123T1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2367, "method_signature": "void test_ordinalDateTimeNoMillis()"}, "TestISODateTimeFormatParsing.test_tTime": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_tTime", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.tTime();\n    assertParse(parser, \"T10:20:30.400999999Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"T10:20:30.400Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"T10:20:30.40Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"T10:20:30.4Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"T5:6:7.8Z\", new DateTime(1970, 1, 1, 5, 6, 7, 800));\n    assertParse(parser, false, \"T10:20.400Z\");\n    assertParse(parser, false, \"T102.400Z\");\n    assertParse(parser, false, \"T10.400Z\");\n    assertParse(parser, false, \"T1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2361, "method_signature": "void test_tTime()"}, "TestISODateTimeFormatParsing.test_tTimeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_tTimeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.tTimeNoMillis();\n    assertParse(parser, \"T10:20:30Z\", new DateTime(1970, 1, 1, 10, 20, 30, 0));\n    assertParse(parser, \"T5:6:7Z\", new DateTime(1970, 1, 1, 5, 6, 7, 0));\n    assertParse(parser, false, \"T10:20Z\");\n    assertParse(parser, false, \"T10:2Z\");\n    assertParse(parser, false, \"T10Z\");\n    assertParse(parser, false, \"T1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2362, "method_signature": "void test_tTimeNoMillis()"}, "TestISODateTimeFormatParsing.test_time": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_time", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.time();\n    assertParse(parser, \"10:20:30.400999999Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"10:20:30.400Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"10:20:30.40Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"10:20:30.4Z\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"5:6:7.8Z\", new DateTime(1970, 1, 1, 5, 6, 7, 800));\n    assertParse(parser, false, \"10:20.400Z\");\n    assertParse(parser, false, \"10:2.400Z\");\n    assertParse(parser, false, \"10.400Z\");\n    assertParse(parser, false, \"1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2359, "method_signature": "void test_time()"}, "TestISODateTimeFormatParsing.test_timeElementParser": {"callee_method_ids": [858], "callee_method_names": ["DateTimeFormatter.parseMillis"], "method_name": "TestISODateTimeFormatParsing.test_timeElementParser", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.timeElementParser();\n    assertParse(parser, false, \"2006-06-09\");\n    assertParse(parser, false, \"2006-W27-3\");\n    assertParse(parser, false, \"2006-123\");\n    assertParse(parser, false, \"2006-06-09T+02:00\");\n    assertParse(parser, false, \"2006-W27-3T+02:00\");\n    assertParse(parser, false, \"2006-123T+02:00\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040\");\n    assertParse(parser, false, \"2006-123T10:20:30.040\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-123T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10:20:30.040\");\n    assertParse(parser, false, \"T10.5\");\n    assertParse(parser, false, \"T10:20:30.040+02:00\");\n    assertParse(parser, false, \"T10.5+02:00\");\n    assertParse(parser, true, \"10:20:30.040\");\n    assertParse(parser, true, \"10.5\");\n    assertParse(parser, false, \"10:20:30.040+02:00\");\n    assertParse(parser, false, \"10.5+02:00\");\n    assertParse(parser, true, \"00:00:10.512345678\");\n    // result is offset by London DST in 1970-01-01\n    assertEquals(10512, parser.parseMillis(\"00:00:10.512345678\") + DateTimeZone.getDefault().getOffset(0L));\n    assertNoPrint(parser);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2354, "method_signature": "void test_timeElementParser()"}, "TestISODateTimeFormatParsing.test_timeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_timeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.timeNoMillis();\n    assertParse(parser, \"10:20:30Z\", new DateTime(1970, 1, 1, 10, 20, 30, 0));\n    assertParse(parser, \"5:6:7Z\", new DateTime(1970, 1, 1, 5, 6, 7, 0));\n    assertParse(parser, false, \"10:20Z\");\n    assertParse(parser, false, \"10:2Z\");\n    assertParse(parser, false, \"10Z\");\n    assertParse(parser, false, \"1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2360, "method_signature": "void test_timeNoMillis()"}, "TestISODateTimeFormatParsing.test_timeParser": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_timeParser", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.timeParser();\n    assertParse(parser, false, \"2006-06-09\");\n    assertParse(parser, false, \"2006-W27-3\");\n    assertParse(parser, false, \"2006-123\");\n    assertParse(parser, false, \"2006-06-09T+02:00\");\n    assertParse(parser, false, \"2006-W27-3T+02:00\");\n    assertParse(parser, false, \"2006-123T+02:00\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040\");\n    assertParse(parser, false, \"2006-123T10:20:30.040\");\n    assertParse(parser, false, \"2006-06-09T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-W27-3T10:20:30.040+02:00\");\n    assertParse(parser, false, \"2006-123T10:20:30.040+02:00\");\n    assertParse(parser, \"T10:20:30.040000000\", new DateTime(1970, 1, 1, 10, 20, 30, 40));\n    assertParse(parser, \"T10:20:30.004\", new DateTime(1970, 1, 1, 10, 20, 30, 4));\n    assertParse(parser, \"T10:20:30.040\", new DateTime(1970, 1, 1, 10, 20, 30, 40));\n    assertParse(parser, \"T10:20:30.400\", new DateTime(1970, 1, 1, 10, 20, 30, 400));\n    assertParse(parser, \"T10.5\", new DateTime(1970, 1, 1, 10, 30, 0, 0));\n    assertParse(parser, \"T10:20:30.040+02:00\", new DateTime(1970, 1, 1, 8, 20, 30, 40));\n    assertParse(parser, \"T10.5+02:00\", new DateTime(1970, 1, 1, 8, 30, 0, 0));\n    assertParse(parser, true, \"10:20:30.040\");\n    assertParse(parser, true, \"10.5\");\n    assertParse(parser, true, \"10:20:30.040+02:00\");\n    assertParse(parser, true, \"10.5+02:00\");\n    assertNoPrint(parser);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2352, "method_signature": "void test_timeParser()"}, "TestISODateTimeFormatParsing.test_weekDate": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_weekDate", "method_implementation": "{\n    DateTimeFormatter parser = ISODateTimeFormat.weekDate();\n    assertParse(parser, \"2006-W27-3\", new DateTime(2006, 6, 1, 0, 0, 0, 0).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"2006-W2-3\", new DateTime(2006, 6, 1, 0, 0, 0, 0).withWeekOfWeekyear(2).withDayOfWeek(3));\n    assertParse(parser, \"+2006-W27-3\", new DateTime(2006, 6, 1, 0, 0, 0, 0).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, false, \"2006-W-3\");\n    assertParse(parser, false, \"2006-W27-\");\n    assertParse(parser, false, \"2006-W27\");\n    assertParse(parser, false, \"2006-W2\");\n    assertParse(parser, false, \"2006-W\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2368, "method_signature": "void test_weekDate()"}, "TestISODateTimeFormatParsing.test_weekDateTime": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_weekDateTime", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.weekDateTime();\n    assertParse(parser, \"2006-W27-3T10:20:30.400999999Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"2006-W27-3T10:20:30.400Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"2006-W27-3T10:20:30.40Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"2006-W27-3T10:20:30.4Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"2006-W2-3T10:20:30.400Z\", new DateTime(2006, 6, 1, 10, 20, 30, 400).withWeekOfWeekyear(2).withDayOfWeek(3));\n    assertParse(parser, \"2006-W27-3T5:6:7.800Z\", new DateTime(2006, 6, 1, 5, 6, 7, 800).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"+2006-W27-3T5:6:7.800Z\", new DateTime(2006, 6, 1, 5, 6, 7, 800).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, false, \"2006-W27-T10:20:30.400Z\");\n    assertParse(parser, false, \"2006-W27T10:20:30.400Z\");\n    assertParse(parser, false, \"2006-W2T10:20:30.400Z\");\n    assertParse(parser, false, \"2006-W-3T10:20:30.400Z\");\n    assertParse(parser, false, \"2006-W27-3T10:20.400Z\");\n    assertParse(parser, false, \"2006-W27-3T10:2.400Z\");\n    assertParse(parser, false, \"2006-W27-3T10.400Z\");\n    assertParse(parser, false, \"2006-W27-3T1.400Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2369, "method_signature": "void test_weekDateTime()"}, "TestISODateTimeFormatParsing.test_weekDateTimeNoMillis": {"callee_method_names": [], "method_name": "TestISODateTimeFormatParsing.test_weekDateTimeNoMillis", "method_implementation": "{\n    DateTimeZone.setDefault(DateTimeZone.UTC);\n    DateTimeFormatter parser = ISODateTimeFormat.weekDateTimeNoMillis();\n    assertParse(parser, \"2006-W27-3T10:20:30Z\", new DateTime(2006, 6, 1, 10, 20, 30, 0).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"2006-W2-3T10:20:30Z\", new DateTime(2006, 6, 1, 10, 20, 30, 0).withWeekOfWeekyear(2).withDayOfWeek(3));\n    assertParse(parser, \"2006-W27-3T5:6:7Z\", new DateTime(2006, 6, 1, 5, 6, 7, 0).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, \"+2006-W27-3T5:6:7Z\", new DateTime(2006, 6, 1, 5, 6, 7, 0).withWeekOfWeekyear(27).withDayOfWeek(3));\n    assertParse(parser, false, \"2006-W27-T10:20:30Z\");\n    assertParse(parser, false, \"2006-W27T10:20:30Z\");\n    assertParse(parser, false, \"2006-W2T10:20:30Z\");\n    assertParse(parser, false, \"2006-W-3T10:20:30Z\");\n    assertParse(parser, false, \"2006-W27-3T10:20Z\");\n    assertParse(parser, false, \"2006-W27-3T10:2Z\");\n    assertParse(parser, false, \"2006-W27-3T10Z\");\n    assertParse(parser, false, \"2006-W27-3T1Z\");\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2370, "method_signature": "void test_weekDateTimeNoMillis()"}, "TestISODateTimeFormat_Fields.testForFields_calBased_D": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_calBased_D", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth() };\n    int[] values = new int[] { 25 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"---25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"---25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"---25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"---25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2280, "method_signature": "void testForFields_calBased_D()"}, "TestISODateTimeFormat_Fields.testForFields_calBased_M": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_calBased_M", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.monthOfYear() };\n    int[] values = new int[] { 6 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"--06\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"--06\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"--06\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"--06\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2279, "method_signature": "void testForFields_calBased_M()"}, "TestISODateTimeFormat_Fields.testForFields_calBased_MD": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_calBased_MD", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };\n    int[] values = new int[] { 6, 25 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"--06-25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"--06-25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"--0625\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"--0625\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2282, "method_signature": "void testForFields_calBased_MD()"}, "TestISODateTimeFormat_Fields.testForFields_calBased_Y": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_calBased_Y", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year() };\n    int[] values = new int[] { 2005 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2278, "method_signature": "void testForFields_calBased_Y()"}, "TestISODateTimeFormat_Fields.testForFields_calBased_YD": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_calBased_YD", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth() };\n    int[] values = new int[] { 2005, 25 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005--25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005--25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2283, "method_signature": "void testForFields_calBased_YD()"}, "TestISODateTimeFormat_Fields.testForFields_calBased_YM": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_calBased_YM", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n    int[] values = new int[] { 2005, 6 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-06\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005-06\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"2005-06\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005-06\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2281, "method_signature": "void testForFields_calBased_YM()"}, "TestISODateTimeFormat_Fields.testForFields_calBased_YMD": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_calBased_YMD", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };\n    int[] values = new int[] { 2005, 6, 25 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"20050625\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"20050625\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2275, "method_signature": "void testForFields_calBased_YMD()"}, "TestISODateTimeFormat_Fields.testForFields_calBased_YMD_duplicates": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_calBased_YMD_duplicates", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };\n    DateTimeFieldType[] dupFields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };\n    int[] values = new int[] { 2005, 6, 25 };\n    List types = new ArrayList(Arrays.asList(dupFields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = Arrays.asList(dupFields);\n    f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n    assertEquals(4, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2277, "method_signature": "void testForFields_calBased_YMD_duplicates()"}, "TestISODateTimeFormat_Fields.testForFields_calBased_YMD_unmodifiable": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_calBased_YMD_unmodifiable", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };\n    int[] values = new int[] { 2005, 6, 25 };\n    List types = Collections.unmodifiableList(new ArrayList(Arrays.asList(fields)));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n    assertEquals(3, types.size());\n    types = Arrays.asList(fields);\n    f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-06-25\", f.print(new Partial(fields, values)));\n    assertEquals(3, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2276, "method_signature": "void testForFields_calBased_YMD_unmodifiable()"}, "TestISODateTimeFormat_Fields.testForFields_datetime_DH": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_datetime_DH", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.hourOfDay() };\n    int[] values = new int[] { 25, 12 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"---25T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"---25T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"---25T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"---25T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2310, "method_signature": "void testForFields_datetime_DH()"}, "TestISODateTimeFormat_Fields.testForFields_datetime_DM": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_datetime_DM", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.minuteOfHour() };\n    int[] values = new int[] { 25, 20 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"---25T-20\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"---25T-20\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2312, "method_signature": "void testForFields_datetime_DM()"}, "TestISODateTimeFormat_Fields.testForFields_datetime_YH": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_datetime_YH", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.hourOfDay() };\n    int[] values = new int[] { 2005, 12 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2311, "method_signature": "void testForFields_datetime_YH()"}, "TestISODateTimeFormat_Fields.testForFields_datetime_YMDH": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_datetime_YMDH", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.hourOfDay() };\n    int[] values = new int[] { 2005, 6, 25, 12 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-06-25T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005-06-25T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"20050625T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"20050625T12\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2309, "method_signature": "void testForFields_datetime_YMDH()"}, "TestISODateTimeFormat_Fields.testForFields_empty": {"callee_method_names": [], "method_name": "TestISODateTimeFormat_Fields.testForFields_empty", "method_implementation": "{\n    try {\n        ISODateTimeFormat.forFields(new ArrayList(), true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2274, "method_signature": "void testForFields_empty()"}, "TestISODateTimeFormat_Fields.testForFields_null": {"callee_method_names": [], "method_name": "TestISODateTimeFormat_Fields.testForFields_null", "method_implementation": "{\n    try {\n        ISODateTimeFormat.forFields((Collection) null, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2273, "method_signature": "void testForFields_null()"}, "TestISODateTimeFormat_Fields.testForFields_ordinalBased_D": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_ordinalBased_D", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfYear() };\n    int[] values = new int[] { 177 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"-177\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"-177\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"-177\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"-177\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2293, "method_signature": "void testForFields_ordinalBased_D()"}, "TestISODateTimeFormat_Fields.testForFields_ordinalBased_Y": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_ordinalBased_Y", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year() };\n    int[] values = new int[] { 2005 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2292, "method_signature": "void testForFields_ordinalBased_Y()"}, "TestISODateTimeFormat_Fields.testForFields_ordinalBased_YD": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_ordinalBased_YD", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n    int[] values = new int[] { 2005, 177 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-177\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005-177\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"2005177\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005177\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2291, "method_signature": "void testForFields_ordinalBased_YD()"}, "TestISODateTimeFormat_Fields.testForFields_time_H": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_H", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay() };\n    int[] values = new int[] { 10 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"10\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"10\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"10\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"10\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2297, "method_signature": "void testForFields_time_H()"}, "TestISODateTimeFormat_Fields.testForFields_time_HM": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_HM", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour() };\n    int[] values = new int[] { 10, 20 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"10:20\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"10:20\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"1020\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"1020\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2296, "method_signature": "void testForFields_time_HM()"}, "TestISODateTimeFormat_Fields.testForFields_time_HMS": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_HMS", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute() };\n    int[] values = new int[] { 10, 20, 30 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"10:20:30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"10:20:30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"102030\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"102030\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2295, "method_signature": "void testForFields_time_HMS()"}, "TestISODateTimeFormat_Fields.testForFields_time_HMSm": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_HMSm", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 10, 20, 30, 40 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"10:20:30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"10:20:30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"102030.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"102030.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2294, "method_signature": "void testForFields_time_HMSm()"}, "TestISODateTimeFormat_Fields.testForFields_time_HMm": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_HMm", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 10, 20, 40 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"10:20-.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"1020-.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2308, "method_signature": "void testForFields_time_HMm()"}, "TestISODateTimeFormat_Fields.testForFields_time_HS": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_HS", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.secondOfMinute() };\n    int[] values = new int[] { 10, 30 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"10-30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"10-30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2305, "method_signature": "void testForFields_time_HS()"}, "TestISODateTimeFormat_Fields.testForFields_time_HSm": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_HSm", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 10, 30, 40 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"10-30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"10-30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2307, "method_signature": "void testForFields_time_HSm()"}, "TestISODateTimeFormat_Fields.testForFields_time_Hm": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_Hm", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 10, 40 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"10--.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"10--.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2304, "method_signature": "void testForFields_time_Hm()"}, "TestISODateTimeFormat_Fields.testForFields_time_M": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_M", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.minuteOfHour() };\n    int[] values = new int[] { 20 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"-20\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"-20\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"-20\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"-20\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2300, "method_signature": "void testForFields_time_M()"}, "TestISODateTimeFormat_Fields.testForFields_time_MS": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_MS", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute() };\n    int[] values = new int[] { 20, 30 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"-20:30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"-20:30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"-2030\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"-2030\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2299, "method_signature": "void testForFields_time_MS()"}, "TestISODateTimeFormat_Fields.testForFields_time_MSm": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_MSm", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 20, 30, 40 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"-20:30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"-20:30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"-2030.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"-2030.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2298, "method_signature": "void testForFields_time_MSm()"}, "TestISODateTimeFormat_Fields.testForFields_time_Mm": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_Mm", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.minuteOfHour(), DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 20, 40 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"-20-.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"-20-.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2306, "method_signature": "void testForFields_time_Mm()"}, "TestISODateTimeFormat_Fields.testForFields_time_S": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_S", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.secondOfMinute() };\n    int[] values = new int[] { 30 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"--30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"--30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"--30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"--30\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2302, "method_signature": "void testForFields_time_S()"}, "TestISODateTimeFormat_Fields.testForFields_time_Sm": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_Sm", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 30, 40 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"--30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"--30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"--30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"--30.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2301, "method_signature": "void testForFields_time_Sm()"}, "TestISODateTimeFormat_Fields.testForFields_time_m": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_time_m", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 40 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"---.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"---.040\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2303, "method_signature": "void testForFields_time_m()"}, "TestISODateTimeFormat_Fields.testForFields_weekBased_D": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_weekBased_D", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.dayOfWeek() };\n    int[] values = new int[] { 5 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"-W-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"-W-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"-W-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"-W-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2287, "method_signature": "void testForFields_weekBased_D()"}, "TestISODateTimeFormat_Fields.testForFields_weekBased_W": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_weekBased_W", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekOfWeekyear() };\n    int[] values = new int[] { 8 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"-W08\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"-W08\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"-W08\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"-W08\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2286, "method_signature": "void testForFields_weekBased_W()"}, "TestISODateTimeFormat_Fields.testForFields_weekBased_WD": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_weekBased_WD", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.dayOfWeek() };\n    int[] values = new int[] { 8, 5 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"-W08-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"-W08-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"-W085\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"-W085\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2289, "method_signature": "void testForFields_weekBased_WD()"}, "TestISODateTimeFormat_Fields.testForFields_weekBased_Y": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_weekBased_Y", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekyear() };\n    int[] values = new int[] { 2005 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2285, "method_signature": "void testForFields_weekBased_Y()"}, "TestISODateTimeFormat_Fields.testForFields_weekBased_YD": {"callee_method_ids": [855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_weekBased_YD", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekyear(), DateTimeFieldType.dayOfWeek() };\n    int[] values = new int[] { 2005, 5 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005-W-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005W-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, true, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    types = new ArrayList(Arrays.asList(fields));\n    try {\n        ISODateTimeFormat.forFields(types, false, true);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2290, "method_signature": "void testForFields_weekBased_YD()"}, "TestISODateTimeFormat_Fields.testForFields_weekBased_YW": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_weekBased_YW", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekyear(), DateTimeFieldType.weekOfWeekyear() };\n    int[] values = new int[] { 2005, 8 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-W08\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005-W08\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"2005W08\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005W08\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2288, "method_signature": "void testForFields_weekBased_YW()"}, "TestISODateTimeFormat_Fields.testForFields_weekBased_YWD": {"callee_method_ids": [855, 855, 855, 855], "callee_method_names": ["DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size", "DateTimeFormatter.print", "List.size"], "method_name": "TestISODateTimeFormat_Fields.testForFields_weekBased_YWD", "method_implementation": "{\n    DateTimeFieldType[] fields = new DateTimeFieldType[] { DateTimeFieldType.weekyear(), DateTimeFieldType.weekOfWeekyear(), DateTimeFieldType.dayOfWeek() };\n    int[] values = new int[] { 2005, 8, 5 };\n    List types = new ArrayList(Arrays.asList(fields));\n    DateTimeFormatter f = ISODateTimeFormat.forFields(types, true, true);\n    assertEquals(\"2005-W08-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, true, false);\n    assertEquals(\"2005-W08-5\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, true);\n    assertEquals(\"2005W085\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n    types = new ArrayList(Arrays.asList(fields));\n    f = ISODateTimeFormat.forFields(types, false, false);\n    assertEquals(\"2005W085\", f.print(new Partial(fields, values)));\n    assertEquals(0, types.size());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2284, "method_signature": "void testForFields_weekBased_YWD()"}, "TestISOPeriodFormat.testFormatAlternate": {"callee_method_names": [], "method_name": "TestISOPeriodFormat.testFormatAlternate", "method_implementation": "{\n    Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(\"P00010204T050607.008\", ISOPeriodFormat.alternate().print(p));\n    p = new Period(1, 2, 3, 4, 5, 6, 7, 0);\n    assertEquals(\"P00010204T050607\", ISOPeriodFormat.alternate().print(p));\n    p = new Period(0);\n    assertEquals(\"P00000000T000000\", ISOPeriodFormat.alternate().print(p));\n    p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n    assertEquals(\"P00000000T000000\", ISOPeriodFormat.alternate().print(p));\n    assertEquals(\"P00010004T050607.008\", ISOPeriodFormat.alternate().print(YEAR_DAY_PERIOD));\n    assertEquals(\"P00000000T000000\", ISOPeriodFormat.alternate().print(EMPTY_YEAR_DAY_PERIOD));\n    assertEquals(\"P00010204T000000\", ISOPeriodFormat.alternate().print(DATE_PERIOD));\n    assertEquals(\"P00000000T050607.008\", ISOPeriodFormat.alternate().print(TIME_PERIOD));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2345, "method_signature": "void testFormatAlternate()"}, "TestISOPeriodFormat.testFormatAlternateExtended": {"callee_method_names": [], "method_name": "TestISOPeriodFormat.testFormatAlternateExtended", "method_implementation": "{\n    Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(\"P0001-02-04T05:06:07.008\", ISOPeriodFormat.alternateExtended().print(p));\n    p = new Period(1, 2, 3, 4, 5, 6, 7, 0);\n    assertEquals(\"P0001-02-04T05:06:07\", ISOPeriodFormat.alternateExtended().print(p));\n    p = new Period(0);\n    assertEquals(\"P0000-00-00T00:00:00\", ISOPeriodFormat.alternateExtended().print(p));\n    p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n    assertEquals(\"P0000-00-00T00:00:00\", ISOPeriodFormat.alternateExtended().print(p));\n    assertEquals(\"P0001-00-04T05:06:07.008\", ISOPeriodFormat.alternateExtended().print(YEAR_DAY_PERIOD));\n    assertEquals(\"P0000-00-00T00:00:00\", ISOPeriodFormat.alternateExtended().print(EMPTY_YEAR_DAY_PERIOD));\n    assertEquals(\"P0001-02-04T00:00:00\", ISOPeriodFormat.alternateExtended().print(DATE_PERIOD));\n    assertEquals(\"P0000-00-00T05:06:07.008\", ISOPeriodFormat.alternateExtended().print(TIME_PERIOD));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2346, "method_signature": "void testFormatAlternateExtended()"}, "TestISOPeriodFormat.testFormatAlternateExtendedWithWeeks": {"callee_method_names": [], "method_name": "TestISOPeriodFormat.testFormatAlternateExtendedWithWeeks", "method_implementation": "{\n    Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(\"P0001-W03-04T05:06:07.008\", ISOPeriodFormat.alternateExtendedWithWeeks().print(p));\n    p = new Period(1, 2, 3, 4, 5, 6, 7, 0);\n    assertEquals(\"P0001-W03-04T05:06:07\", ISOPeriodFormat.alternateExtendedWithWeeks().print(p));\n    p = new Period(0);\n    assertEquals(\"P0000-W00-00T00:00:00\", ISOPeriodFormat.alternateExtendedWithWeeks().print(p));\n    p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n    assertEquals(\"P0000-W00-00T00:00:00\", ISOPeriodFormat.alternateExtendedWithWeeks().print(p));\n    assertEquals(\"P0001-W00-04T05:06:07.008\", ISOPeriodFormat.alternateExtendedWithWeeks().print(YEAR_DAY_PERIOD));\n    assertEquals(\"P0000-W00-00T00:00:00\", ISOPeriodFormat.alternateExtendedWithWeeks().print(EMPTY_YEAR_DAY_PERIOD));\n    assertEquals(\"P0001-W03-04T00:00:00\", ISOPeriodFormat.alternateExtendedWithWeeks().print(DATE_PERIOD));\n    assertEquals(\"P0000-W00-00T05:06:07.008\", ISOPeriodFormat.alternateExtendedWithWeeks().print(TIME_PERIOD));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2348, "method_signature": "void testFormatAlternateExtendedWithWeeks()"}, "TestISOPeriodFormat.testFormatAlternateWithWeeks": {"callee_method_names": [], "method_name": "TestISOPeriodFormat.testFormatAlternateWithWeeks", "method_implementation": "{\n    Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(\"P0001W0304T050607.008\", ISOPeriodFormat.alternateWithWeeks().print(p));\n    p = new Period(1, 2, 3, 4, 5, 6, 7, 0);\n    assertEquals(\"P0001W0304T050607\", ISOPeriodFormat.alternateWithWeeks().print(p));\n    p = new Period(0);\n    assertEquals(\"P0000W0000T000000\", ISOPeriodFormat.alternateWithWeeks().print(p));\n    p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n    assertEquals(\"P0000W0000T000000\", ISOPeriodFormat.alternateWithWeeks().print(p));\n    assertEquals(\"P0001W0004T050607.008\", ISOPeriodFormat.alternateWithWeeks().print(YEAR_DAY_PERIOD));\n    assertEquals(\"P0000W0000T000000\", ISOPeriodFormat.alternateWithWeeks().print(EMPTY_YEAR_DAY_PERIOD));\n    assertEquals(\"P0001W0304T000000\", ISOPeriodFormat.alternateWithWeeks().print(DATE_PERIOD));\n    assertEquals(\"P0000W0000T050607.008\", ISOPeriodFormat.alternateWithWeeks().print(TIME_PERIOD));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2347, "method_signature": "void testFormatAlternateWithWeeks()"}, "TestISOPeriodFormat.testFormatStandard": {"callee_method_names": [], "method_name": "TestISOPeriodFormat.testFormatStandard", "method_implementation": "{\n    Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(\"P1Y2M3W4DT5H6M7.008S\", ISOPeriodFormat.standard().print(p));\n    p = new Period(1, 2, 3, 4, 5, 6, 7, 0);\n    assertEquals(\"P1Y2M3W4DT5H6M7S\", ISOPeriodFormat.standard().print(p));\n    p = new Period(0);\n    assertEquals(\"PT0S\", ISOPeriodFormat.standard().print(p));\n    p = new Period(0, PeriodType.standard().withMillisRemoved().withSecondsRemoved());\n    assertEquals(\"PT0M\", ISOPeriodFormat.standard().print(p));\n    assertEquals(\"P1Y4DT5H6M7.008S\", ISOPeriodFormat.standard().print(YEAR_DAY_PERIOD));\n    assertEquals(\"PT0S\", ISOPeriodFormat.standard().print(EMPTY_YEAR_DAY_PERIOD));\n    assertEquals(\"P1Y2M3W4D\", ISOPeriodFormat.standard().print(DATE_PERIOD));\n    assertEquals(\"PT5H6M7.008S\", ISOPeriodFormat.standard().print(TIME_PERIOD));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2344, "method_signature": "void testFormatStandard()"}, "TestISOPeriodFormat.testSubclassableConstructor": {"callee_method_names": [], "method_name": "TestISOPeriodFormat.testSubclassableConstructor", "method_implementation": "{\n    ISOPeriodFormat f = new ISOPeriodFormat() {\n    };\n    assertNotNull(f);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2343, "method_signature": "void testSubclassableConstructor()"}, "TestISOPeriodFormatParsing.testParseStandard1": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard1", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"P1Y2M3W4DT5H6M7.008S\");\n    assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2407, "method_signature": "void testParseStandard1()"}, "TestISOPeriodFormatParsing.testParseStandard10": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard10", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"P0D\");\n    assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 0), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2416, "method_signature": "void testParseStandard10()"}, "TestISOPeriodFormatParsing.testParseStandard11": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard11", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"P0Y\");\n    assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 0), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2417, "method_signature": "void testParseStandard11()"}, "TestISOPeriodFormatParsing.testParseStandard2": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard2", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"P0Y0M0W0DT5H6M7.008S\");\n    assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 8), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2408, "method_signature": "void testParseStandard2()"}, "TestISOPeriodFormatParsing.testParseStandard3": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard3", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"P0DT5H6M7.008S\");\n    assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 8), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2409, "method_signature": "void testParseStandard3()"}, "TestISOPeriodFormatParsing.testParseStandard4": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard4", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"P2Y3DT5H6M7.008S\");\n    assertEquals(new Period(2, 0, 0, 3, 5, 6, 7, 8), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2410, "method_signature": "void testParseStandard4()"}, "TestISOPeriodFormatParsing.testParseStandard5": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard5", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"P2YT5H6M7.008S\");\n    assertEquals(new Period(2, 0, 0, 0, 5, 6, 7, 8), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2411, "method_signature": "void testParseStandard5()"}, "TestISOPeriodFormatParsing.testParseStandard6": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard6", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"PT5H6M7.008S\");\n    assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 8), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2412, "method_signature": "void testParseStandard6()"}, "TestISOPeriodFormatParsing.testParseStandard7": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard7", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"P1Y2M3W4D\");\n    assertEquals(new Period(1, 2, 3, 4, 0, 0, 0, 0), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2413, "method_signature": "void testParseStandard7()"}, "TestISOPeriodFormatParsing.testParseStandard8": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard8", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"PT5H6M7S\");\n    assertEquals(new Period(0, 0, 0, 0, 5, 6, 7, 0), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2414, "method_signature": "void testParseStandard8()"}, "TestISOPeriodFormatParsing.testParseStandard9": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandard9", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    Period p = parser.parsePeriod(\"PT0S\");\n    assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 0), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2415, "method_signature": "void testParseStandard9()"}, "TestISOPeriodFormatParsing.testParseStandardFail1": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandardFail1", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    try {\n        parser.parsePeriod(\"P1Y2S\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2418, "method_signature": "void testParseStandardFail1()"}, "TestISOPeriodFormatParsing.testParseStandardFail2": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandardFail2", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    try {\n        parser.parsePeriod(\"PS\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2419, "method_signature": "void testParseStandardFail2()"}, "TestISOPeriodFormatParsing.testParseStandardFail3": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandardFail3", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    try {\n        parser.parsePeriod(\"PTS\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2420, "method_signature": "void testParseStandardFail3()"}, "TestISOPeriodFormatParsing.testParseStandardFail4": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestISOPeriodFormatParsing.testParseStandardFail4", "method_implementation": "{\n    PeriodFormatter parser = ISOPeriodFormat.standard();\n    try {\n        parser.parsePeriod(\"PXS\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2421, "method_signature": "void testParseStandardFail4()"}, "TestIllegalFieldValueException.testOtherConstructors": {"callee_method_ids": [124, 124, 124], "callee_method_names": ["IllegalFieldValueException.getDateTimeFieldType", "IllegalFieldValueException.getDurationFieldType", "IllegalFieldValueException.getFieldName", "IllegalFieldValueException.getIllegalNumberValue", "IllegalFieldValueException.getIllegalStringValue", "IllegalFieldValueException.getIllegalValueAsString", "IllegalFieldValueException.getLowerBound", "IllegalFieldValueException.getUpperBound", "IllegalFieldValueException.getDateTimeFieldType", "IllegalFieldValueException.getDurationFieldType", "IllegalFieldValueException.getFieldName", "IllegalFieldValueException.getIllegalNumberValue", "IllegalFieldValueException.getIllegalStringValue", "IllegalFieldValueException.getIllegalValueAsString", "IllegalFieldValueException.getLowerBound", "IllegalFieldValueException.getUpperBound", "IllegalFieldValueException.getDateTimeFieldType", "IllegalFieldValueException.getDurationFieldType", "IllegalFieldValueException.getFieldName", "IllegalFieldValueException.getIllegalNumberValue", "IllegalFieldValueException.getIllegalStringValue", "IllegalFieldValueException.getIllegalValueAsString", "IllegalFieldValueException.getLowerBound", "IllegalFieldValueException.getUpperBound"], "method_name": "TestIllegalFieldValueException.testOtherConstructors", "method_implementation": "{\n    IllegalFieldValueException e = new IllegalFieldValueException(DurationFieldType.days(), new Integer(1), new Integer(2), new Integer(3));\n    assertEquals(null, e.getDateTimeFieldType());\n    assertEquals(DurationFieldType.days(), e.getDurationFieldType());\n    assertEquals(\"days\", e.getFieldName());\n    assertEquals(new Integer(1), e.getIllegalNumberValue());\n    assertEquals(null, e.getIllegalStringValue());\n    assertEquals(\"1\", e.getIllegalValueAsString());\n    assertEquals(new Integer(2), e.getLowerBound());\n    assertEquals(new Integer(3), e.getUpperBound());\n    e = new IllegalFieldValueException(DurationFieldType.months(), \"five\");\n    assertEquals(null, e.getDateTimeFieldType());\n    assertEquals(DurationFieldType.months(), e.getDurationFieldType());\n    assertEquals(\"months\", e.getFieldName());\n    assertEquals(null, e.getIllegalNumberValue());\n    assertEquals(\"five\", e.getIllegalStringValue());\n    assertEquals(\"five\", e.getIllegalValueAsString());\n    assertEquals(null, e.getLowerBound());\n    assertEquals(null, e.getUpperBound());\n    e = new IllegalFieldValueException(\"months\", \"five\");\n    assertEquals(null, e.getDateTimeFieldType());\n    assertEquals(null, e.getDurationFieldType());\n    assertEquals(\"months\", e.getFieldName());\n    assertEquals(null, e.getIllegalNumberValue());\n    assertEquals(\"five\", e.getIllegalStringValue());\n    assertEquals(\"five\", e.getIllegalValueAsString());\n    assertEquals(null, e.getLowerBound());\n    assertEquals(null, e.getUpperBound());\n}", "repo_id": "7", "comment": "// Test extra constructors not currently called by anything\n", "repo_name": "joda-time-main/", "id": 2207, "method_signature": "void testOtherConstructors()"}, "TestInstant_Basics.testGet_DateTimeFieldType": {"callee_method_names": ["Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get", "Instant.get"], "method_name": "TestInstant_Basics.testGet_DateTimeFieldType", "method_implementation": "{\n    // 2002-06-09\n    Instant test = new Instant();\n    assertEquals(1, test.get(DateTimeFieldType.era()));\n    assertEquals(20, test.get(DateTimeFieldType.centuryOfEra()));\n    assertEquals(2, test.get(DateTimeFieldType.yearOfCentury()));\n    assertEquals(2002, test.get(DateTimeFieldType.yearOfEra()));\n    assertEquals(2002, test.get(DateTimeFieldType.year()));\n    assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n    assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n    assertEquals(2002, test.get(DateTimeFieldType.weekyear()));\n    assertEquals(23, test.get(DateTimeFieldType.weekOfWeekyear()));\n    assertEquals(7, test.get(DateTimeFieldType.dayOfWeek()));\n    assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));\n    assertEquals(0, test.get(DateTimeFieldType.halfdayOfDay()));\n    // UTC zone\n    assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday()));\n    // UTC zone\n    assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay()));\n    // UTC zone\n    assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday()));\n    // UTC zone\n    assertEquals(0, test.get(DateTimeFieldType.hourOfDay()));\n    assertEquals(0, test.get(DateTimeFieldType.minuteOfHour()));\n    assertEquals(0, test.get(DateTimeFieldType.minuteOfDay()));\n    assertEquals(0, test.get(DateTimeFieldType.secondOfMinute()));\n    assertEquals(0, test.get(DateTimeFieldType.secondOfDay()));\n    assertEquals(0, test.get(DateTimeFieldType.millisOfSecond()));\n    assertEquals(0, test.get(DateTimeFieldType.millisOfDay()));\n    try {\n        test.get((DateTimeFieldType) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1909, "method_signature": "void testGet_DateTimeFieldType()"}, "TestInstant_Basics.testIsAfter_long": {"callee_method_names": [], "method_name": "TestInstant_Basics.testIsAfter_long", "method_implementation": "{\n    assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME2));\n    assertEquals(false, new Instant(TEST_TIME1).isAfter(TEST_TIME1));\n    assertEquals(true, new Instant(TEST_TIME2).isAfter(TEST_TIME1));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1912, "method_signature": "void testIsAfter_long()"}, "TestInstant_Basics.testIsBefore_long": {"callee_method_names": [], "method_name": "TestInstant_Basics.testIsBefore_long", "method_implementation": "{\n    assertEquals(true, new Instant(TEST_TIME1).isBefore(TEST_TIME2));\n    assertEquals(false, new Instant(TEST_TIME1).isBefore(TEST_TIME1));\n    assertEquals(false, new Instant(TEST_TIME2).isBefore(TEST_TIME1));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1911, "method_signature": "void testIsBefore_long()"}, "TestInstant_Basics.testIsEqual_long": {"callee_method_names": [], "method_name": "TestInstant_Basics.testIsEqual_long", "method_implementation": "{\n    assertEquals(false, new Instant(TEST_TIME1).isEqual(TEST_TIME2));\n    assertEquals(true, new Instant(TEST_TIME1).isEqual(TEST_TIME1));\n    assertEquals(false, new Instant(TEST_TIME2).isEqual(TEST_TIME1));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1910, "method_signature": "void testIsEqual_long()"}, "TestInstant_Basics.testMinus_long": {"callee_method_names": ["Instant.minus"], "method_name": "TestInstant_Basics.testMinus_long", "method_implementation": "{\n    Instant test = new Instant(TEST_TIME1);\n    Instant result = test.minus(123456789L);\n    Instant expected = new Instant(TEST_TIME1 - 123456789L);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1919, "method_signature": "void testMinus_long()"}, "TestInstant_Basics.testPlus_long": {"callee_method_names": ["Instant.plus"], "method_name": "TestInstant_Basics.testPlus_long", "method_implementation": "{\n    Instant test = new Instant(TEST_TIME1);\n    Instant result = test.plus(123456789L);\n    Instant expected = new Instant(TEST_TIME1 + 123456789L);\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1918, "method_signature": "void testPlus_long()"}, "TestInstant_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestInstant_Basics.testSerialization", "method_implementation": "{\n    Instant test = new Instant(TEST_TIME_NOW);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Instant result = (Instant) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1913, "method_signature": "void testSerialization()"}, "TestInstant_Basics.testTest": {"callee_method_names": [], "method_name": "TestInstant_Basics.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1908, "method_signature": "void testTest()"}, "TestInstant_Basics.testToInstant": {"callee_method_names": ["Instant.toInstant"], "method_name": "TestInstant_Basics.testToInstant", "method_implementation": "{\n    Instant test = new Instant(TEST_TIME1);\n    Instant result = test.toInstant();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1914, "method_signature": "void testToInstant()"}, "TestInstant_Basics.testWithDurationAdded_RD_int": {"callee_method_ids": [398, 398, 398, 398, 398], "callee_method_names": ["Instant.withDurationAdded", "Instant.withDurationAdded", "Instant.withDurationAdded", "Instant.withDurationAdded", "Instant.withDurationAdded"], "method_name": "TestInstant_Basics.testWithDurationAdded_RD_int", "method_implementation": "{\n    Instant test = new Instant(TEST_TIME1);\n    Instant result = test.withDurationAdded(new Duration(123456789L), 1);\n    Instant expected = new Instant(TEST_TIME1 + 123456789L);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(null, 1);\n    assertSame(test, result);\n    result = test.withDurationAdded(new Duration(123456789L), 0);\n    assertSame(test, result);\n    result = test.withDurationAdded(new Duration(123456789L), 2);\n    expected = new Instant(TEST_TIME1 + (2L * 123456789L));\n    assertEquals(expected, result);\n    result = test.withDurationAdded(new Duration(123456789L), -3);\n    expected = new Instant(TEST_TIME1 - (3L * 123456789L));\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1917, "method_signature": "void testWithDurationAdded_RD_int()"}, "TestInstant_Basics.testWithDurationAdded_long_int": {"callee_method_ids": [398, 398, 398, 398], "callee_method_names": ["Instant.withDurationAdded", "Instant.withDurationAdded", "Instant.withDurationAdded", "Instant.withDurationAdded"], "method_name": "TestInstant_Basics.testWithDurationAdded_long_int", "method_implementation": "{\n    Instant test = new Instant(TEST_TIME1);\n    Instant result = test.withDurationAdded(123456789L, 1);\n    Instant expected = new Instant(TEST_TIME1 + 123456789L);\n    assertEquals(expected, result);\n    result = test.withDurationAdded(123456789L, 0);\n    assertSame(test, result);\n    result = test.withDurationAdded(123456789L, 2);\n    expected = new Instant(TEST_TIME1 + (2L * 123456789L));\n    assertEquals(expected, result);\n    result = test.withDurationAdded(123456789L, -3);\n    expected = new Instant(TEST_TIME1 - (3L * 123456789L));\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1916, "method_signature": "void testWithDurationAdded_long_int()"}, "TestInstant_Basics.testWithMillis_long": {"callee_method_names": ["Instant.withMillis", "Instant.getMillis", "Instant.getChronology", "Instant.getChronology", "Instant.withMillis"], "method_name": "TestInstant_Basics.testWithMillis_long", "method_implementation": "{\n    Instant test = new Instant(TEST_TIME1);\n    Instant result = test.withMillis(TEST_TIME2);\n    assertEquals(TEST_TIME2, result.getMillis());\n    assertEquals(test.getChronology(), result.getChronology());\n    test = new Instant(TEST_TIME1);\n    result = test.withMillis(TEST_TIME1);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1915, "method_signature": "void testWithMillis_long()"}, "TestInstant_Constructors.testConstructor": {"callee_method_names": ["Instant.getChronology", "Instant.getMillis"], "method_name": "TestInstant_Constructors.testConstructor", "method_implementation": "{\n    Instant test = new Instant();\n    assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1497, "method_signature": "void testConstructor()"}, "TestInstant_Constructors.testConstructor_Object": {"callee_method_names": ["Instant.getChronology", "Instant.getMillis"], "method_name": "TestInstant_Constructors.testConstructor_Object", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    Instant test = new Instant(date);\n    assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1500, "method_signature": "void testConstructor_Object()"}, "TestInstant_Constructors.testConstructor_badconverterObject": {"callee_method_names": ["Instant.getChronology", "Instant.getMillis"], "method_name": "TestInstant_Constructors.testConstructor_badconverterObject", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        Instant test = new Instant(new Integer(0));\n        assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n        assertEquals(0L, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null)\n */\n", "repo_name": "joda-time-main/", "id": 1503, "method_signature": "void testConstructor_badconverterObject()"}, "TestInstant_Constructors.testConstructor_invalidObject": {"callee_method_names": [], "method_name": "TestInstant_Constructors.testConstructor_invalidObject", "method_implementation": "{\n    try {\n        new Instant(new Object());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1501, "method_signature": "void testConstructor_invalidObject()"}, "TestInstant_Constructors.testConstructor_long1": {"callee_method_names": ["Instant.getChronology", "Instant.getMillis"], "method_name": "TestInstant_Constructors.testConstructor_long1", "method_implementation": "{\n    Instant test = new Instant(TEST_TIME1);\n    assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1498, "method_signature": "void testConstructor_long1()"}, "TestInstant_Constructors.testConstructor_long2": {"callee_method_names": ["Instant.getChronology", "Instant.getMillis"], "method_name": "TestInstant_Constructors.testConstructor_long2", "method_implementation": "{\n    Instant test = new Instant(TEST_TIME2);\n    assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(TEST_TIME2, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1499, "method_signature": "void testConstructor_long2()"}, "TestInstant_Constructors.testConstructor_nullObject": {"callee_method_names": ["Instant.getChronology", "Instant.getMillis"], "method_name": "TestInstant_Constructors.testConstructor_nullObject", "method_implementation": "{\n    Instant test = new Instant((Object) null);\n    assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null)\n */\n", "repo_name": "joda-time-main/", "id": 1502, "method_signature": "void testConstructor_nullObject()"}, "TestInstant_Constructors.test_epoch": {"callee_method_names": ["Instant.getChronology", "Instant.getMillis"], "method_name": "TestInstant_Constructors.test_epoch", "method_implementation": "{\n    Instant test = Instant.EPOCH;\n    assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(0L, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test EPOCH\n */\n", "repo_name": "joda-time-main/", "id": 1494, "method_signature": "void test_epoch()"}, "TestInstant_Constructors.test_now": {"callee_method_names": ["Instant.getChronology", "Instant.getMillis"], "method_name": "TestInstant_Constructors.test_now", "method_implementation": "{\n    Instant test = Instant.now();\n    assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test now()\n */\n", "repo_name": "joda-time-main/", "id": 1495, "method_signature": "void test_now()"}, "TestInstant_Constructors.test_ofEpochMilli": {"callee_method_names": ["Instant.getChronology", "Instant.getMillis"], "method_name": "TestInstant_Constructors.test_ofEpochMilli", "method_implementation": "{\n    Instant test = Instant.ofEpochMilli(TEST_TIME1);\n    assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test ofEpochMilli() and ofEpochSecond()\n */\n", "repo_name": "joda-time-main/", "id": 1496, "method_signature": "void test_ofEpochMilli()"}, "TestInterval_Basics.testAbuts_RInterval": {"callee_method_ids": [625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625, 625], "callee_method_names": ["Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts", "Interval.abuts"], "method_name": "TestInterval_Basics.testAbuts_RInterval", "method_implementation": "{\n    // gap before\n    assertEquals(false, interval37.abuts(new Interval(1, 2)));\n    // gap before\n    assertEquals(false, interval37.abuts(new Interval(2, 2)));\n    assertEquals(true, interval37.abuts(new Interval(2, 3)));\n    assertEquals(true, interval37.abuts(new Interval(3, 3)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(2, 4)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(3, 4)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(4, 4)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(2, 6)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(3, 6)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(4, 6)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(5, 6)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(6, 6)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(2, 7)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(3, 7)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(4, 7)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(5, 7)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(6, 7)));\n    assertEquals(true, interval37.abuts(new Interval(7, 7)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(2, 8)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(3, 8)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(4, 8)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(5, 8)));\n    // overlaps\n    assertEquals(false, interval37.abuts(new Interval(6, 8)));\n    assertEquals(true, interval37.abuts(new Interval(7, 8)));\n    // gap after\n    assertEquals(false, interval37.abuts(new Interval(8, 8)));\n    // gap after\n    assertEquals(false, interval37.abuts(new Interval(8, 9)));\n    // gap after\n    assertEquals(false, interval37.abuts(new Interval(9, 9)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1203, "method_signature": "void testAbuts_RInterval()"}, "TestInterval_Basics.testContainsNow": {"callee_method_names": ["Interval.containsNow", "Interval.containsNow", "Interval.containsNow", "Interval.containsNow", "Interval.containsNow", "Interval.containsNow", "Interval.containsNow", "Interval.containsNow", "Interval.containsNow"], "method_name": "TestInterval_Basics.testContainsNow", "method_implementation": "{\n    DateTimeUtils.setCurrentMillisFixed(2);\n    // value before\n    assertEquals(false, interval37.containsNow());\n    DateTimeUtils.setCurrentMillisFixed(3);\n    assertEquals(true, interval37.containsNow());\n    DateTimeUtils.setCurrentMillisFixed(4);\n    assertEquals(true, interval37.containsNow());\n    DateTimeUtils.setCurrentMillisFixed(6);\n    assertEquals(true, interval37.containsNow());\n    DateTimeUtils.setCurrentMillisFixed(7);\n    // value after\n    assertEquals(false, interval37.containsNow());\n    DateTimeUtils.setCurrentMillisFixed(8);\n    // value after\n    assertEquals(false, interval37.containsNow());\n    DateTimeUtils.setCurrentMillisFixed(2);\n    // value before\n    assertEquals(false, interval33.containsNow());\n    DateTimeUtils.setCurrentMillisFixed(3);\n    // zero length duration contains nothing\n    assertEquals(false, interval33.containsNow());\n    DateTimeUtils.setCurrentMillisFixed(4);\n    // value after\n    assertEquals(false, interval33.containsNow());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1197, "method_signature": "void testContainsNow()"}, "TestInterval_Basics.testContains_RI": {"callee_method_names": ["Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains"], "method_name": "TestInterval_Basics.testContains_RI", "method_implementation": "{\n    // value before\n    assertEquals(false, interval37.contains(new Instant(2)));\n    assertEquals(true, interval37.contains(new Instant(3)));\n    assertEquals(true, interval37.contains(new Instant(4)));\n    assertEquals(true, interval37.contains(new Instant(5)));\n    assertEquals(true, interval37.contains(new Instant(6)));\n    // value after\n    assertEquals(false, interval37.contains(new Instant(7)));\n    // value after\n    assertEquals(false, interval37.contains(new Instant(8)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1198, "method_signature": "void testContains_RI()"}, "TestInterval_Basics.testContains_RInterval": {"callee_method_names": ["Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains"], "method_name": "TestInterval_Basics.testContains_RInterval", "method_implementation": "{\n    // gap before\n    assertEquals(false, interval37.contains(new Interval(1, 2)));\n    // gap before\n    assertEquals(false, interval37.contains(new Interval(2, 2)));\n    // abuts before\n    assertEquals(false, interval37.contains(new Interval(2, 3)));\n    assertEquals(true, interval37.contains(new Interval(3, 3)));\n    // starts before\n    assertEquals(false, interval37.contains(new Interval(2, 4)));\n    assertEquals(true, interval37.contains(new Interval(3, 4)));\n    assertEquals(true, interval37.contains(new Interval(4, 4)));\n    // starts before\n    assertEquals(false, interval37.contains(new Interval(2, 6)));\n    assertEquals(true, interval37.contains(new Interval(3, 6)));\n    assertEquals(true, interval37.contains(new Interval(4, 6)));\n    assertEquals(true, interval37.contains(new Interval(5, 6)));\n    assertEquals(true, interval37.contains(new Interval(6, 6)));\n    // starts before\n    assertEquals(false, interval37.contains(new Interval(2, 7)));\n    assertEquals(true, interval37.contains(new Interval(3, 7)));\n    assertEquals(true, interval37.contains(new Interval(4, 7)));\n    assertEquals(true, interval37.contains(new Interval(5, 7)));\n    assertEquals(true, interval37.contains(new Interval(6, 7)));\n    // abuts after\n    assertEquals(false, interval37.contains(new Interval(7, 7)));\n    // ends after\n    assertEquals(false, interval37.contains(new Interval(2, 8)));\n    // ends after\n    assertEquals(false, interval37.contains(new Interval(3, 8)));\n    // ends after\n    assertEquals(false, interval37.contains(new Interval(4, 8)));\n    // ends after\n    assertEquals(false, interval37.contains(new Interval(5, 8)));\n    // ends after\n    assertEquals(false, interval37.contains(new Interval(6, 8)));\n    // abuts after\n    assertEquals(false, interval37.contains(new Interval(7, 8)));\n    // gap after\n    assertEquals(false, interval37.contains(new Interval(8, 8)));\n    // gap after\n    assertEquals(false, interval37.contains(new Interval(8, 9)));\n    // gap after\n    assertEquals(false, interval37.contains(new Interval(9, 9)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1199, "method_signature": "void testContains_RInterval()"}, "TestInterval_Basics.testContains_long": {"callee_method_names": ["Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains", "Interval.contains"], "method_name": "TestInterval_Basics.testContains_long", "method_implementation": "{\n    // value before\n    assertEquals(false, interval37.contains(2));\n    assertEquals(true, interval37.contains(3));\n    assertEquals(true, interval37.contains(4));\n    assertEquals(true, interval37.contains(5));\n    assertEquals(true, interval37.contains(6));\n    // value after\n    assertEquals(false, interval37.contains(7));\n    // value after\n    assertEquals(false, interval37.contains(8));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1196, "method_signature": "void testContains_long()"}, "TestInterval_Basics.testGap_RInterval": {"callee_method_ids": [624, 624, 624, 624, 624, 624, 624, 624, 624, 624, 624, 624, 624, 624, 624], "callee_method_names": ["Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap", "Interval.gap"], "method_name": "TestInterval_Basics.testGap_RInterval", "method_implementation": "{\n    assertEquals(new Interval(1, 3), interval37.gap(new Interval(0, 1)));\n    assertEquals(new Interval(1, 3), interval37.gap(new Interval(1, 1)));\n    // abuts before\n    assertEquals(null, interval37.gap(new Interval(2, 3)));\n    // abuts before\n    assertEquals(null, interval37.gap(new Interval(3, 3)));\n    // overlaps\n    assertEquals(null, interval37.gap(new Interval(4, 6)));\n    // overlaps\n    assertEquals(null, interval37.gap(new Interval(3, 7)));\n    // overlaps\n    assertEquals(null, interval37.gap(new Interval(6, 7)));\n    // abuts after\n    assertEquals(null, interval37.gap(new Interval(7, 7)));\n    // overlaps\n    assertEquals(null, interval37.gap(new Interval(6, 8)));\n    // abuts after\n    assertEquals(null, interval37.gap(new Interval(7, 8)));\n    assertEquals(new Interval(7, 8), interval37.gap(new Interval(8, 8)));\n    // overlaps\n    assertEquals(null, interval37.gap(new Interval(6, 9)));\n    // abuts after\n    assertEquals(null, interval37.gap(new Interval(7, 9)));\n    assertEquals(new Interval(7, 8), interval37.gap(new Interval(8, 9)));\n    assertEquals(new Interval(7, 9), interval37.gap(new Interval(9, 9)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1202, "method_signature": "void testGap_RInterval()"}, "TestInterval_Basics.testGetMillis": {"callee_method_names": ["Interval.getStartMillis", "Interval.getStart", "Interval.getEndMillis", "Interval.getEnd", "Interval.toDurationMillis", "Interval.toDuration"], "method_name": "TestInterval_Basics.testGetMillis", "method_implementation": "{\n    Interval test = new Interval(TEST_TIME1, TEST_TIME2);\n    assertEquals(TEST_TIME1, test.getStartMillis());\n    assertEquals(TEST_TIME1, test.getStart().getMillis());\n    assertEquals(TEST_TIME2, test.getEndMillis());\n    assertEquals(TEST_TIME2, test.getEnd().getMillis());\n    assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());\n    assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1192, "method_signature": "void testGetMillis()"}, "TestInterval_Basics.testIsAfter_long": {"callee_method_names": ["Interval.isAfter", "Interval.isAfter", "Interval.isAfter", "Interval.isAfter", "Interval.isAfter", "Interval.isAfter", "Interval.isAfter"], "method_name": "TestInterval_Basics.testIsAfter_long", "method_implementation": "{\n    assertEquals(true, interval37.isAfter(2));\n    assertEquals(false, interval37.isAfter(3));\n    assertEquals(false, interval37.isAfter(4));\n    assertEquals(false, interval37.isAfter(5));\n    assertEquals(false, interval37.isAfter(6));\n    assertEquals(false, interval37.isAfter(7));\n    assertEquals(false, interval37.isAfter(8));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1205, "method_signature": "void testIsAfter_long()"}, "TestInterval_Basics.testIsBefore_long": {"callee_method_names": ["Interval.isBefore", "Interval.isBefore", "Interval.isBefore", "Interval.isBefore", "Interval.isBefore", "Interval.isBefore", "Interval.isBefore"], "method_name": "TestInterval_Basics.testIsBefore_long", "method_implementation": "{\n    assertEquals(false, interval37.isBefore(2));\n    assertEquals(false, interval37.isBefore(3));\n    assertEquals(false, interval37.isBefore(4));\n    assertEquals(false, interval37.isBefore(5));\n    assertEquals(false, interval37.isBefore(6));\n    assertEquals(true, interval37.isBefore(7));\n    assertEquals(true, interval37.isBefore(8));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1204, "method_signature": "void testIsBefore_long()"}, "TestInterval_Basics.testOverlap_RInterval": {"callee_method_ids": [623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623, 623], "callee_method_names": ["Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap", "Interval.overlap"], "method_name": "TestInterval_Basics.testOverlap_RInterval", "method_implementation": "{\n    // gap before\n    assertEquals(null, interval37.overlap(new Interval(1, 2)));\n    // gap before\n    assertEquals(null, interval37.overlap(new Interval(2, 2)));\n    // abuts before\n    assertEquals(null, interval37.overlap(new Interval(2, 3)));\n    // abuts before\n    assertEquals(null, interval37.overlap(new Interval(3, 3)));\n    // truncated start\n    assertEquals(new Interval(3, 4), interval37.overlap(new Interval(2, 4)));\n    assertEquals(new Interval(3, 4), interval37.overlap(new Interval(3, 4)));\n    assertEquals(new Interval(4, 4), interval37.overlap(new Interval(4, 4)));\n    // truncated start\n    assertEquals(new Interval(3, 7), interval37.overlap(new Interval(2, 7)));\n    assertEquals(new Interval(3, 7), interval37.overlap(new Interval(3, 7)));\n    assertEquals(new Interval(4, 7), interval37.overlap(new Interval(4, 7)));\n    assertEquals(new Interval(5, 7), interval37.overlap(new Interval(5, 7)));\n    assertEquals(new Interval(6, 7), interval37.overlap(new Interval(6, 7)));\n    // abuts after\n    assertEquals(null, interval37.overlap(new Interval(7, 7)));\n    // truncated start and end\n    assertEquals(new Interval(3, 7), interval37.overlap(new Interval(2, 8)));\n    // truncated end\n    assertEquals(new Interval(3, 7), interval37.overlap(new Interval(3, 8)));\n    // truncated end\n    assertEquals(new Interval(4, 7), interval37.overlap(new Interval(4, 8)));\n    // truncated end\n    assertEquals(new Interval(5, 7), interval37.overlap(new Interval(5, 8)));\n    // truncated end\n    assertEquals(new Interval(6, 7), interval37.overlap(new Interval(6, 8)));\n    // abuts after\n    assertEquals(null, interval37.overlap(new Interval(7, 8)));\n    // gap after\n    assertEquals(null, interval37.overlap(new Interval(8, 8)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1201, "method_signature": "void testOverlap_RInterval()"}, "TestInterval_Basics.testOverlaps_RInterval": {"callee_method_names": ["Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps", "Interval.overlaps"], "method_name": "TestInterval_Basics.testOverlaps_RInterval", "method_implementation": "{\n    // gap before\n    assertEquals(false, interval37.overlaps(new Interval(1, 2)));\n    // gap before\n    assertEquals(false, interval37.overlaps(new Interval(2, 2)));\n    // abuts before\n    assertEquals(false, interval37.overlaps(new Interval(2, 3)));\n    // abuts before\n    assertEquals(false, interval37.overlaps(new Interval(3, 3)));\n    assertEquals(true, interval37.overlaps(new Interval(2, 4)));\n    assertEquals(true, interval37.overlaps(new Interval(3, 4)));\n    assertEquals(true, interval37.overlaps(new Interval(4, 4)));\n    assertEquals(true, interval37.overlaps(new Interval(2, 6)));\n    assertEquals(true, interval37.overlaps(new Interval(3, 6)));\n    assertEquals(true, interval37.overlaps(new Interval(4, 6)));\n    assertEquals(true, interval37.overlaps(new Interval(5, 6)));\n    assertEquals(true, interval37.overlaps(new Interval(6, 6)));\n    assertEquals(true, interval37.overlaps(new Interval(2, 7)));\n    assertEquals(true, interval37.overlaps(new Interval(3, 7)));\n    assertEquals(true, interval37.overlaps(new Interval(4, 7)));\n    assertEquals(true, interval37.overlaps(new Interval(5, 7)));\n    assertEquals(true, interval37.overlaps(new Interval(6, 7)));\n    // abuts after\n    assertEquals(false, interval37.overlaps(new Interval(7, 7)));\n    assertEquals(true, interval37.overlaps(new Interval(2, 8)));\n    assertEquals(true, interval37.overlaps(new Interval(3, 8)));\n    assertEquals(true, interval37.overlaps(new Interval(4, 8)));\n    assertEquals(true, interval37.overlaps(new Interval(5, 8)));\n    assertEquals(true, interval37.overlaps(new Interval(6, 8)));\n    // abuts after\n    assertEquals(false, interval37.overlaps(new Interval(7, 8)));\n    // gap after\n    assertEquals(false, interval37.overlaps(new Interval(8, 8)));\n    // gap after\n    assertEquals(false, interval37.overlaps(new Interval(8, 9)));\n    // gap after\n    assertEquals(false, interval37.overlaps(new Interval(9, 9)));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1200, "method_signature": "void testOverlaps_RInterval()"}, "TestInterval_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestInterval_Basics.testSerialization", "method_implementation": "{\n    Interval test = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Interval result = (Interval) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1210, "method_signature": "void testSerialization()"}, "TestInterval_Basics.testTest": {"callee_method_names": [], "method_name": "TestInterval_Basics.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1191, "method_signature": "void testTest()"}, "TestInterval_Basics.testToInterval1": {"callee_method_names": ["Interval.toInterval"], "method_name": "TestInterval_Basics.testToInterval1", "method_implementation": "{\n    Interval test = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    Interval result = test.toInterval();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1206, "method_signature": "void testToInterval1()"}, "TestInterval_Basics.testToMutableInterval1": {"callee_method_names": ["Interval.toMutableInterval"], "method_name": "TestInterval_Basics.testToMutableInterval1", "method_implementation": "{\n    Interval test = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    MutableInterval result = test.toMutableInterval();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1207, "method_signature": "void testToMutableInterval1()"}, "TestInterval_Basics.testToPeriod": {"callee_method_names": ["Interval.toPeriod"], "method_name": "TestInterval_Basics.testToPeriod", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS);\n    DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS);\n    Interval base = new Interval(dt1, dt2);\n    Period test = base.toPeriod();\n    Period expected = new Period(dt1, dt2, PeriodType.standard());\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1208, "method_signature": "void testToPeriod()"}, "TestInterval_Basics.testToPeriod_PeriodType1": {"callee_method_names": ["Interval.toPeriod"], "method_name": "TestInterval_Basics.testToPeriod_PeriodType1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS);\n    DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS);\n    Interval base = new Interval(dt1, dt2);\n    Period test = base.toPeriod(null);\n    Period expected = new Period(dt1, dt2, PeriodType.standard());\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1209, "method_signature": "void testToPeriod_PeriodType1()"}, "TestInterval_Basics.testToString": {"callee_method_names": ["Interval.toString"], "method_name": "TestInterval_Basics.testToString", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);\n    DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);\n    Interval test = new Interval(dt1, dt2);\n    assertEquals(\"2004-06-09T07:08:09.010Z/2005-08-13T12:14:16.018Z\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1211, "method_signature": "void testToString()"}, "TestInterval_Basics.testWithChronology1": {"callee_method_ids": [626], "callee_method_names": ["Interval.withChronology"], "method_name": "TestInterval_Basics.testWithChronology1", "method_implementation": "{\n    Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    Interval test = base.withChronology(BuddhistChronology.getInstance());\n    assertEquals(new Interval(TEST_TIME1, TEST_TIME2, BuddhistChronology.getInstance()), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1212, "method_signature": "void testWithChronology1()"}, "TestInterval_Basics.testWithDurationAfterStart1": {"callee_method_ids": [629], "callee_method_names": ["Interval.withDurationAfterStart"], "method_name": "TestInterval_Basics.testWithDurationAfterStart1", "method_implementation": "{\n    Duration dur = new Duration(TEST_TIME2 - TEST_TIME_NOW);\n    Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS);\n    Interval test = base.withDurationAfterStart(dur);\n    assertEquals(new Interval(TEST_TIME_NOW, TEST_TIME2, COPTIC_PARIS), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1217, "method_signature": "void testWithDurationAfterStart1()"}, "TestInterval_Basics.testWithDurationBeforeEnd1": {"callee_method_ids": [630], "callee_method_names": ["Interval.withDurationBeforeEnd"], "method_name": "TestInterval_Basics.testWithDurationBeforeEnd1", "method_implementation": "{\n    Duration dur = new Duration(TEST_TIME_NOW - TEST_TIME1);\n    Interval base = new Interval(TEST_TIME_NOW, TEST_TIME_NOW, COPTIC_PARIS);\n    Interval test = base.withDurationBeforeEnd(dur);\n    assertEquals(new Interval(TEST_TIME1, TEST_TIME_NOW, COPTIC_PARIS), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1218, "method_signature": "void testWithDurationBeforeEnd1()"}, "TestInterval_Basics.testWithEndInstant_RI1": {"callee_method_names": ["Interval.withEnd"], "method_name": "TestInterval_Basics.testWithEndInstant_RI1", "method_implementation": "{\n    Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    Interval test = base.withEnd(new Instant(TEST_TIME2 - 1));\n    assertEquals(new Interval(TEST_TIME1, TEST_TIME2 - 1, COPTIC_PARIS), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1216, "method_signature": "void testWithEndInstant_RI1()"}, "TestInterval_Basics.testWithEndMillis_long1": {"callee_method_ids": [628], "callee_method_names": ["Interval.withEndMillis"], "method_name": "TestInterval_Basics.testWithEndMillis_long1", "method_implementation": "{\n    Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    Interval test = base.withEndMillis(TEST_TIME2 - 1);\n    assertEquals(new Interval(TEST_TIME1, TEST_TIME2 - 1, COPTIC_PARIS), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1215, "method_signature": "void testWithEndMillis_long1()"}, "TestInterval_Basics.testWithPeriodAfterStart1": {"callee_method_ids": [631], "callee_method_names": ["Interval.withPeriodAfterStart"], "method_name": "TestInterval_Basics.testWithPeriodAfterStart1", "method_implementation": "{\n    DateTime dt = new DateTime(TEST_TIME_NOW, COPTIC_PARIS);\n    Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n    Interval base = new Interval(dt, dt);\n    Interval test = base.withPeriodAfterStart(dur);\n    assertEquals(new Interval(dt, dur), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1219, "method_signature": "void testWithPeriodAfterStart1()"}, "TestInterval_Basics.testWithPeriodBeforeEnd1": {"callee_method_ids": [632], "callee_method_names": ["Interval.withPeriodBeforeEnd"], "method_name": "TestInterval_Basics.testWithPeriodBeforeEnd1", "method_implementation": "{\n    DateTime dt = new DateTime(TEST_TIME_NOW, COPTIC_PARIS);\n    Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n    Interval base = new Interval(dt, dt);\n    Interval test = base.withPeriodBeforeEnd(dur);\n    assertEquals(new Interval(dur, dt), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1220, "method_signature": "void testWithPeriodBeforeEnd1()"}, "TestInterval_Basics.testWithStartInstant_RI1": {"callee_method_names": ["Interval.withStart"], "method_name": "TestInterval_Basics.testWithStartInstant_RI1", "method_implementation": "{\n    Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    Interval test = base.withStart(new Instant(TEST_TIME1 - 1));\n    assertEquals(new Interval(TEST_TIME1 - 1, TEST_TIME2, COPTIC_PARIS), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1214, "method_signature": "void testWithStartInstant_RI1()"}, "TestInterval_Basics.testWithStartMillis_long1": {"callee_method_ids": [627], "callee_method_names": ["Interval.withStartMillis"], "method_name": "TestInterval_Basics.testWithStartMillis_long1", "method_implementation": "{\n    Interval base = new Interval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    Interval test = base.withStartMillis(TEST_TIME1 - 1);\n    assertEquals(new Interval(TEST_TIME1 - 1, TEST_TIME2, COPTIC_PARIS), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1213, "method_signature": "void testWithStartMillis_long1()"}, "TestInterval_Basics.test_useCase_ContainsOverlapAbutGap": {"callee_method_ids": [624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625], "callee_method_names": ["Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains"], "method_name": "TestInterval_Basics.test_useCase_ContainsOverlapAbutGap", "method_implementation": "{\n    // this is a simple test to ensure that the use case of these methods is OK\n    // when comparing any two intervals they can be in one and only one of these states\n    // (a) have a gap between them, (b) abut or (c) overlap\n    // contains is a subset of overlap\n    Interval test1020 = new Interval(10, 20);\n    // [4,8) [10,20) - gap\n    Interval interval = new Interval(4, 8);\n    assertNotNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(interval));\n    assertEquals(false, test1020.overlaps(interval));\n    assertEquals(false, test1020.contains(interval));\n    assertNotNull(interval.gap(test1020));\n    assertEquals(false, interval.abuts(test1020));\n    assertEquals(false, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n    // [6,10) [10,20) - abuts\n    interval = new Interval(6, 10);\n    assertNull(test1020.gap(interval));\n    assertEquals(true, test1020.abuts(interval));\n    assertEquals(false, test1020.overlaps(interval));\n    assertEquals(false, test1020.contains(interval));\n    assertNull(interval.gap(test1020));\n    assertEquals(true, interval.abuts(test1020));\n    assertEquals(false, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n    // [8,12) [10,20) - overlaps\n    interval = new Interval(8, 12);\n    assertNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(interval));\n    assertEquals(true, test1020.overlaps(interval));\n    assertEquals(false, test1020.contains(interval));\n    assertNull(interval.gap(test1020));\n    assertEquals(false, interval.abuts(test1020));\n    assertEquals(true, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n    // [10,14) [10,20) - overlaps and contains-one-way\n    interval = new Interval(10, 14);\n    assertNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(interval));\n    assertEquals(true, test1020.overlaps(interval));\n    assertEquals(true, test1020.contains(interval));\n    assertNull(interval.gap(test1020));\n    assertEquals(false, interval.abuts(test1020));\n    assertEquals(true, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n    // [10,20) [10,20) - overlaps and contains-both-ways\n    assertNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(test1020));\n    assertEquals(true, test1020.overlaps(test1020));\n    assertEquals(true, test1020.contains(test1020));\n    // [10,20) [16,20) - overlaps and contains-one-way\n    interval = new Interval(16, 20);\n    assertNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(interval));\n    assertEquals(true, test1020.overlaps(interval));\n    assertEquals(true, test1020.contains(interval));\n    assertNull(interval.gap(test1020));\n    assertEquals(false, interval.abuts(test1020));\n    assertEquals(true, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n    // [10,20) [18,22) - overlaps\n    interval = new Interval(18, 22);\n    assertNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(interval));\n    assertEquals(true, test1020.overlaps(interval));\n    assertEquals(false, test1020.contains(interval));\n    assertNull(interval.gap(test1020));\n    assertEquals(false, interval.abuts(test1020));\n    assertEquals(true, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n    // [10,20) [20,24) - abuts\n    interval = new Interval(20, 24);\n    assertNull(test1020.gap(interval));\n    assertEquals(true, test1020.abuts(interval));\n    assertEquals(false, test1020.overlaps(interval));\n    assertEquals(false, test1020.contains(interval));\n    assertNull(interval.gap(test1020));\n    assertEquals(true, interval.abuts(test1020));\n    assertEquals(false, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n    // [10,20) [22,26) - gap\n    interval = new Interval(22, 26);\n    assertNotNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(interval));\n    assertEquals(false, test1020.overlaps(interval));\n    assertEquals(false, test1020.contains(interval));\n    assertNotNull(interval.gap(test1020));\n    assertEquals(false, interval.abuts(test1020));\n    assertEquals(false, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1193, "method_signature": "void test_useCase_ContainsOverlapAbutGap()"}, "TestInterval_Basics.test_useCase_ContainsOverlapAbutGap_bothZeroDuration": {"callee_method_ids": [624, 625, 624, 625, 624, 625], "callee_method_names": ["Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains"], "method_name": "TestInterval_Basics.test_useCase_ContainsOverlapAbutGap_bothZeroDuration", "method_implementation": "{\n    // this is a simple test to ensure that the use case of these methods\n    // is OK when considering two zero duration inervals\n    // this is the simplest case, as the two intervals either have a gap or not\n    // if not, then they are equal and abut\n    Interval test0808 = new Interval(8, 8);\n    Interval test1010 = new Interval(10, 10);\n    // [8,8) [10,10) - gap\n    assertNotNull(test1010.gap(test0808));\n    assertEquals(false, test1010.abuts(test0808));\n    assertEquals(false, test1010.overlaps(test0808));\n    assertEquals(false, test1010.contains(test0808));\n    assertNotNull(test0808.gap(test1010));\n    assertEquals(false, test0808.abuts(test1010));\n    assertEquals(false, test0808.overlaps(test1010));\n    assertEquals(false, test0808.contains(test1010));\n    // [10,10) [10,10) - abuts\n    assertNull(test1010.gap(test1010));\n    assertEquals(true, test1010.abuts(test1010));\n    assertEquals(false, test1010.overlaps(test1010));\n    assertEquals(false, test1010.contains(test1010));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1195, "method_signature": "void test_useCase_ContainsOverlapAbutGap_bothZeroDuration()"}, "TestInterval_Basics.test_useCase_ContainsOverlapAbutGap_zeroDuration": {"callee_method_ids": [624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625, 624, 625], "callee_method_names": ["Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains", "Interval.gap", "Interval.abuts", "Interval.overlaps", "Interval.contains"], "method_name": "TestInterval_Basics.test_useCase_ContainsOverlapAbutGap_zeroDuration", "method_implementation": "{\n    // this is a simple test to ensure that the use case of these methods\n    // is OK when considering a zero duration inerval\n    // when comparing any two intervals they can be in one and only one of these states\n    // (a) have a gap between them, (b) abut or (c) overlap\n    // contains is a subset of overlap\n    Interval test1020 = new Interval(10, 20);\n    // [8,8) [10,20) - gap\n    Interval interval = new Interval(8, 8);\n    assertNotNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(interval));\n    assertEquals(false, test1020.overlaps(interval));\n    assertEquals(false, test1020.contains(interval));\n    assertNotNull(interval.gap(test1020));\n    assertEquals(false, interval.abuts(test1020));\n    assertEquals(false, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n    // [10,10) [10,20) - abuts and contains-one-way\n    interval = new Interval(10, 10);\n    assertNull(test1020.gap(interval));\n    assertEquals(true, test1020.abuts(interval));\n    // abuts, so can't overlap\n    assertEquals(false, test1020.overlaps(interval));\n    // normal contains zero-duration\n    assertEquals(true, test1020.contains(interval));\n    assertNull(interval.gap(test1020));\n    assertEquals(true, interval.abuts(test1020));\n    // abuts, so can't overlap\n    assertEquals(false, interval.overlaps(test1020));\n    // zero-duration does not contain normal\n    assertEquals(false, interval.contains(test1020));\n    // [12,12) [10,20) - contains-one-way and overlaps\n    interval = new Interval(12, 12);\n    assertNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(interval));\n    assertEquals(true, test1020.overlaps(interval));\n    // normal contains zero-duration\n    assertEquals(true, test1020.contains(interval));\n    assertNull(interval.gap(test1020));\n    assertEquals(false, interval.abuts(test1020));\n    assertEquals(true, interval.overlaps(test1020));\n    // zero-duration does not contain normal\n    assertEquals(false, interval.contains(test1020));\n    // [10,20) [20,20) - abuts\n    interval = new Interval(20, 20);\n    assertNull(test1020.gap(interval));\n    assertEquals(true, test1020.abuts(interval));\n    assertEquals(false, test1020.overlaps(interval));\n    assertEquals(false, test1020.contains(interval));\n    assertNull(interval.gap(test1020));\n    assertEquals(true, interval.abuts(test1020));\n    assertEquals(false, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n    // [10,20) [22,22) - gap\n    interval = new Interval(22, 22);\n    assertNotNull(test1020.gap(interval));\n    assertEquals(false, test1020.abuts(interval));\n    assertEquals(false, test1020.overlaps(interval));\n    assertEquals(false, test1020.contains(interval));\n    assertNotNull(interval.gap(test1020));\n    assertEquals(false, interval.abuts(test1020));\n    assertEquals(false, interval.overlaps(test1020));\n    assertEquals(false, interval.contains(test1020));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1194, "method_signature": "void test_useCase_ContainsOverlapAbutGap_zeroDuration()"}, "TestInterval_Constructors.testConstructor_Object1": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.getMillis", "Interval.getStartMillis", "DateTime.getMillis", "Interval.getEndMillis"], "method_name": "TestInterval_Constructors.testConstructor_Object1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Interval test = new Interval(dt1.toString() + '/' + dt2.toString());\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2625, "method_signature": "void testConstructor_Object1()"}, "TestInterval_Constructors.testConstructor_Object_Chronology1": {"callee_method_names": ["DateTime.getMillis", "Interval.getStartMillis", "DateTime.getMillis", "Interval.getEndMillis", "Interval.getChronology"], "method_name": "TestInterval_Constructors.testConstructor_Object_Chronology1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Interval base = new Interval(dt1, dt2);\n    Interval test = new Interval(base, BuddhistChronology.getInstance());\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n    assertEquals(BuddhistChronology.getInstance(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2626, "method_signature": "void testConstructor_Object_Chronology1()"}, "TestInterval_Constructors.testConstructor_RD_RI1": {"callee_method_names": ["Interval.getStartMillis", "DateTime.getMillis", "Interval.getEndMillis"], "method_name": "TestInterval_Constructors.testConstructor_RD_RI1", "method_implementation": "{\n    long result = TEST_TIME_NOW;\n    result = ISOChronology.getInstance().months().add(result, -6);\n    result = ISOChronology.getInstance().hours().add(result, -1);\n    DateTime dt = new DateTime(TEST_TIME_NOW);\n    Duration dur = new Duration(TEST_TIME_NOW - result);\n    Interval test = new Interval(dur, dt);\n    assertEquals(result, test.getStartMillis());\n    assertEquals(dt.getMillis(), test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2624, "method_signature": "void testConstructor_RD_RI1()"}, "TestInterval_Constructors.testConstructor_RI_RD1": {"callee_method_names": ["DateTime.getMillis", "Interval.getStartMillis", "Interval.getEndMillis"], "method_name": "TestInterval_Constructors.testConstructor_RI_RD1", "method_implementation": "{\n    long result = TEST_TIME_NOW;\n    result = ISOChronology.getInstance().months().add(result, 6);\n    result = ISOChronology.getInstance().hours().add(result, 1);\n    DateTime dt = new DateTime(TEST_TIME_NOW);\n    Duration dur = new Duration(result - TEST_TIME_NOW);\n    Interval test = new Interval(dt, dur);\n    assertEquals(dt.getMillis(), test.getStartMillis());\n    assertEquals(result, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2623, "method_signature": "void testConstructor_RI_RD1()"}, "TestInterval_Constructors.testConstructor_RI_RI1": {"callee_method_names": ["DateTime.getMillis", "Interval.getStartMillis", "DateTime.getMillis", "Interval.getEndMillis"], "method_name": "TestInterval_Constructors.testConstructor_RI_RI1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Interval test = new Interval(dt1, dt2);\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2620, "method_signature": "void testConstructor_RI_RI1()"}, "TestInterval_Constructors.testConstructor_RI_RP1": {"callee_method_names": ["DateTime.getMillis", "Interval.getStartMillis", "Interval.getEndMillis"], "method_name": "TestInterval_Constructors.testConstructor_RI_RP1", "method_implementation": "{\n    DateTime dt = new DateTime(TEST_TIME_NOW);\n    Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n    long result = TEST_TIME_NOW;\n    result = ISOChronology.getInstance().months().add(result, 6);\n    result = ISOChronology.getInstance().hours().add(result, 1);\n    Interval test = new Interval(dt, dur);\n    assertEquals(dt.getMillis(), test.getStartMillis());\n    assertEquals(result, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2621, "method_signature": "void testConstructor_RI_RP1()"}, "TestInterval_Constructors.testConstructor_RP_RI1": {"callee_method_names": ["Interval.getStartMillis", "DateTime.getMillis", "Interval.getEndMillis"], "method_name": "TestInterval_Constructors.testConstructor_RP_RI1", "method_implementation": "{\n    DateTime dt = new DateTime(TEST_TIME_NOW);\n    Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n    long result = TEST_TIME_NOW;\n    result = ISOChronology.getInstance().months().add(result, -6);\n    result = ISOChronology.getInstance().hours().add(result, -1);\n    Interval test = new Interval(dur, dt);\n    assertEquals(result, test.getStartMillis());\n    assertEquals(dt.getMillis(), test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2622, "method_signature": "void testConstructor_RP_RI1()"}, "TestInterval_Constructors.testConstructor_long_long1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "Interval.getStartMillis", "DateTime.getMillis", "Interval.getEndMillis", "Interval.getChronology"], "method_name": "TestInterval_Constructors.testConstructor_long_long1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Interval test = new Interval(dt1.getMillis(), dt2.getMillis());\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2617, "method_signature": "void testConstructor_long_long1()"}, "TestInterval_Constructors.testConstructor_long_long_Chronology": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "Interval.getStartMillis", "DateTime.getMillis", "Interval.getEndMillis", "Interval.getChronology"], "method_name": "TestInterval_Constructors.testConstructor_long_long_Chronology", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), GJChronology.getInstance());\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n    assertEquals(GJChronology.getInstance(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2619, "method_signature": "void testConstructor_long_long_Chronology()"}, "TestInterval_Constructors.testConstructor_long_long_Zone": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "Interval.getStartMillis", "DateTime.getMillis", "Interval.getEndMillis", "Interval.getChronology"], "method_name": "TestInterval_Constructors.testConstructor_long_long_Zone", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Interval test = new Interval(dt1.getMillis(), dt2.getMillis(), LONDON);\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n    assertEquals(ISOChronology.getInstance(LONDON), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2618, "method_signature": "void testConstructor_long_long_Zone()"}, "TestInterval_Constructors.testParse_noOffsetInString": {"callee_method_names": [], "method_name": "TestInterval_Constructors.testParse_noOffsetInString", "method_implementation": "{\n    DateTime start = new DateTime(2010, 6, 30, 12, 30, ISOChronology.getInstance(PARIS));\n    DateTime end = new DateTime(2010, 7, 1, 14, 30, ISOChronology.getInstance(PARIS));\n    assertEquals(new Interval(start, end), Interval.parse(\"2010-06-30T12:30/2010-07-01T14:30\"));\n    assertEquals(new Interval(start, end), Interval.parse(\"2010-06-30T12:30/P1DT2H\"));\n    assertEquals(new Interval(start, end), Interval.parse(\"P1DT2H/2010-07-01T14:30\"));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2616, "method_signature": "void testParse_noOffsetInString()"}, "TestIslamicChronology.testCalendar": {"callee_method_names": ["DateTime.getMillis", "Chronology.dayOfWeek", "Chronology.dayOfYear", "Chronology.dayOfMonth", "Chronology.monthOfYear", "Chronology.year", "Chronology.yearOfEra", "Chronology.era", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.get", "DateTimeField.getMaximumValue", "DateTimeField.getMaximumValue", "DateTimeField.get", "DateTimeField.getAsText", "DateTimeField.getAsShortText", "DateTimeField.isLeap"], "method_name": "TestIslamicChronology.testCalendar", "method_implementation": "{\n    if (TestAll.FAST) {\n        return;\n    }\n    System.out.println(\"\\nTestIslamicChronology.testCalendar\");\n    DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ISLAMIC_UTC);\n    long millis = epoch.getMillis();\n    long end = new DateTime(3000, 1, 1, 0, 0, 0, 0, ISO_UTC).getMillis();\n    DateTimeField dayOfWeek = ISLAMIC_UTC.dayOfWeek();\n    DateTimeField dayOfYear = ISLAMIC_UTC.dayOfYear();\n    DateTimeField dayOfMonth = ISLAMIC_UTC.dayOfMonth();\n    DateTimeField monthOfYear = ISLAMIC_UTC.monthOfYear();\n    DateTimeField year = ISLAMIC_UTC.year();\n    DateTimeField yearOfEra = ISLAMIC_UTC.yearOfEra();\n    DateTimeField era = ISLAMIC_UTC.era();\n    int expectedDOW = new DateTime(622, 7, 16, 0, 0, 0, 0, JULIAN_UTC).getDayOfWeek();\n    int expectedDOY = 1;\n    int expectedDay = 1;\n    int expectedMonth = 1;\n    int expectedYear = 1;\n    while (millis < end) {\n        int dowValue = dayOfWeek.get(millis);\n        int doyValue = dayOfYear.get(millis);\n        int dayValue = dayOfMonth.get(millis);\n        int monthValue = monthOfYear.get(millis);\n        int yearValue = year.get(millis);\n        int yearOfEraValue = yearOfEra.get(millis);\n        int dayOfYearLen = dayOfYear.getMaximumValue(millis);\n        int monthLen = dayOfMonth.getMaximumValue(millis);\n        if (monthValue < 1 || monthValue > 12) {\n            fail(\"Bad month: \" + millis);\n        }\n        // test era\n        assertEquals(1, era.get(millis));\n        assertEquals(\"AH\", era.getAsText(millis));\n        assertEquals(\"AH\", era.getAsShortText(millis));\n        // test date\n        assertEquals(expectedDOY, doyValue);\n        assertEquals(expectedMonth, monthValue);\n        assertEquals(expectedDay, dayValue);\n        assertEquals(expectedDOW, dowValue);\n        assertEquals(expectedYear, yearValue);\n        assertEquals(expectedYear, yearOfEraValue);\n        // test leap year\n        boolean leap = ((11 * yearValue + 14) % 30) < 11;\n        assertEquals(leap, year.isLeap(millis));\n        // test month length\n        switch(monthValue) {\n            case 1:\n            case 3:\n            case 5:\n            case 7:\n            case 9:\n            case 11:\n                assertEquals(30, monthLen);\n                break;\n            case 2:\n            case 4:\n            case 6:\n            case 8:\n            case 10:\n                assertEquals(29, monthLen);\n                break;\n            case 12:\n                assertEquals((leap ? 30 : 29), monthLen);\n                break;\n        }\n        // test year length\n        assertEquals((leap ? 355 : 354), dayOfYearLen);\n        // recalculate date\n        expectedDOW = (((expectedDOW + 1) - 1) % 7) + 1;\n        expectedDay++;\n        expectedDOY++;\n        if (expectedDay > monthLen) {\n            expectedDay = 1;\n            expectedMonth++;\n            if (expectedMonth == 13) {\n                expectedMonth = 1;\n                expectedDOY = 1;\n                expectedYear++;\n            }\n        }\n        millis += SKIP;\n    }\n}", "repo_id": "7", "comment": "/**\n * Tests era, year, monthOfYear, dayOfMonth and dayOfWeek.\n */\n", "repo_name": "joda-time-main/", "id": 1980, "method_signature": "void testCalendar()"}, "TestIslamicChronology.testDurationFields": {"callee_method_names": ["IslamicChronology.eras", "IslamicChronology.centuries", "IslamicChronology.years", "IslamicChronology.weekyears", "IslamicChronology.months", "IslamicChronology.weeks", "IslamicChronology.days", "IslamicChronology.halfdays", "IslamicChronology.hours", "IslamicChronology.minutes", "IslamicChronology.seconds", "IslamicChronology.millis", "IslamicChronology.eras", "IslamicChronology.centuries", "IslamicChronology.years", "IslamicChronology.weekyears", "IslamicChronology.months", "IslamicChronology.weeks", "IslamicChronology.days", "IslamicChronology.halfdays", "IslamicChronology.hours", "IslamicChronology.minutes", "IslamicChronology.seconds", "IslamicChronology.millis", "IslamicChronology.centuries", "IslamicChronology.years", "IslamicChronology.weekyears", "IslamicChronology.months", "IslamicChronology.weeks", "IslamicChronology.days", "IslamicChronology.halfdays", "IslamicChronology.hours", "IslamicChronology.minutes", "IslamicChronology.seconds", "IslamicChronology.millis", "IslamicChronology.centuries", "IslamicChronology.years", "IslamicChronology.weekyears", "IslamicChronology.months", "IslamicChronology.weeks", "IslamicChronology.days", "IslamicChronology.halfdays", "IslamicChronology.hours", "IslamicChronology.minutes", "IslamicChronology.seconds", "IslamicChronology.millis", "IslamicChronology.centuries", "IslamicChronology.years", "IslamicChronology.weekyears", "IslamicChronology.months", "IslamicChronology.weeks", "IslamicChronology.days", "IslamicChronology.halfdays", "IslamicChronology.hours", "IslamicChronology.minutes", "IslamicChronology.seconds", "IslamicChronology.millis"], "method_name": "TestIslamicChronology.testDurationFields", "method_implementation": "{\n    final IslamicChronology islamic = IslamicChronology.getInstance();\n    assertEquals(\"eras\", islamic.eras().getName());\n    assertEquals(\"centuries\", islamic.centuries().getName());\n    assertEquals(\"years\", islamic.years().getName());\n    assertEquals(\"weekyears\", islamic.weekyears().getName());\n    assertEquals(\"months\", islamic.months().getName());\n    assertEquals(\"weeks\", islamic.weeks().getName());\n    assertEquals(\"days\", islamic.days().getName());\n    assertEquals(\"halfdays\", islamic.halfdays().getName());\n    assertEquals(\"hours\", islamic.hours().getName());\n    assertEquals(\"minutes\", islamic.minutes().getName());\n    assertEquals(\"seconds\", islamic.seconds().getName());\n    assertEquals(\"millis\", islamic.millis().getName());\n    assertEquals(false, islamic.eras().isSupported());\n    assertEquals(true, islamic.centuries().isSupported());\n    assertEquals(true, islamic.years().isSupported());\n    assertEquals(true, islamic.weekyears().isSupported());\n    assertEquals(true, islamic.months().isSupported());\n    assertEquals(true, islamic.weeks().isSupported());\n    assertEquals(true, islamic.days().isSupported());\n    assertEquals(true, islamic.halfdays().isSupported());\n    assertEquals(true, islamic.hours().isSupported());\n    assertEquals(true, islamic.minutes().isSupported());\n    assertEquals(true, islamic.seconds().isSupported());\n    assertEquals(true, islamic.millis().isSupported());\n    assertEquals(false, islamic.centuries().isPrecise());\n    assertEquals(false, islamic.years().isPrecise());\n    assertEquals(false, islamic.weekyears().isPrecise());\n    assertEquals(false, islamic.months().isPrecise());\n    assertEquals(false, islamic.weeks().isPrecise());\n    assertEquals(false, islamic.days().isPrecise());\n    assertEquals(false, islamic.halfdays().isPrecise());\n    assertEquals(true, islamic.hours().isPrecise());\n    assertEquals(true, islamic.minutes().isPrecise());\n    assertEquals(true, islamic.seconds().isPrecise());\n    assertEquals(true, islamic.millis().isPrecise());\n    final IslamicChronology islamicUTC = IslamicChronology.getInstanceUTC();\n    assertEquals(false, islamicUTC.centuries().isPrecise());\n    assertEquals(false, islamicUTC.years().isPrecise());\n    assertEquals(false, islamicUTC.weekyears().isPrecise());\n    assertEquals(false, islamicUTC.months().isPrecise());\n    assertEquals(true, islamicUTC.weeks().isPrecise());\n    assertEquals(true, islamicUTC.days().isPrecise());\n    assertEquals(true, islamicUTC.halfdays().isPrecise());\n    assertEquals(true, islamicUTC.hours().isPrecise());\n    assertEquals(true, islamicUTC.minutes().isPrecise());\n    assertEquals(true, islamicUTC.seconds().isPrecise());\n    assertEquals(true, islamicUTC.millis().isPrecise());\n    final DateTimeZone gmt = DateTimeZone.forID(\"Etc/GMT\");\n    final IslamicChronology islamicGMT = IslamicChronology.getInstance(gmt);\n    assertEquals(false, islamicGMT.centuries().isPrecise());\n    assertEquals(false, islamicGMT.years().isPrecise());\n    assertEquals(false, islamicGMT.weekyears().isPrecise());\n    assertEquals(false, islamicGMT.months().isPrecise());\n    assertEquals(true, islamicGMT.weeks().isPrecise());\n    assertEquals(true, islamicGMT.days().isPrecise());\n    assertEquals(true, islamicGMT.halfdays().isPrecise());\n    assertEquals(true, islamicGMT.hours().isPrecise());\n    assertEquals(true, islamicGMT.minutes().isPrecise());\n    assertEquals(true, islamicGMT.seconds().isPrecise());\n    assertEquals(true, islamicGMT.millis().isPrecise());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1977, "method_signature": "void testDurationFields()"}, "TestIslamicChronology.testEpoch": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis"], "method_name": "TestIslamicChronology.testEpoch", "method_implementation": "{\n    DateTime epoch = new DateTime(1, 1, 1, 0, 0, 0, 0, ISLAMIC_UTC);\n    DateTime expectedEpoch = new DateTime(622, 7, 16, 0, 0, 0, 0, JULIAN_UTC);\n    assertEquals(expectedEpoch.getMillis(), epoch.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1978, "method_signature": "void testEpoch()"}, "TestIslamicChronology.testEquality": {"callee_method_names": [], "method_name": "TestIslamicChronology.testEquality", "method_implementation": "{\n    assertSame(IslamicChronology.getInstance(TOKYO), IslamicChronology.getInstance(TOKYO));\n    assertSame(IslamicChronology.getInstance(LONDON), IslamicChronology.getInstance(LONDON));\n    assertSame(IslamicChronology.getInstance(PARIS), IslamicChronology.getInstance(PARIS));\n    assertSame(IslamicChronology.getInstanceUTC(), IslamicChronology.getInstanceUTC());\n    assertSame(IslamicChronology.getInstance(), IslamicChronology.getInstance(LONDON));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1976, "method_signature": "void testEquality()"}, "TestIslamicChronology.testFieldConstructor": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis"], "method_name": "TestIslamicChronology.testFieldConstructor", "method_implementation": "{\n    DateTime date = new DateTime(1364, 12, 6, 0, 0, 0, 0, ISLAMIC_UTC);\n    DateTime expectedDate = new DateTime(1945, 11, 12, 0, 0, 0, 0, ISO_UTC);\n    assertEquals(expectedDate.getMillis(), date.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1979, "method_signature": "void testFieldConstructor()"}, "TestJulianChronology.fixedFromGJ": {"callee_method_names": [], "method_name": "TestJulianChronology.fixedFromGJ", "method_implementation": "{\n    if (year == 0) {\n        throw new IllegalArgumentException(\"Illegal year: \" + year);\n    }\n    int y = (year < 0) ? year + 1 : year;\n    long y_m1 = y - 1;\n    long f = JULIAN_EPOCH - 1 + 365 * y_m1 + div(y_m1, 4) + div(367 * monthOfYear - 362, 12) + dayOfMonth;\n    if (monthOfYear > 2) {\n        f += isLeapYear(year) ? -1 : -2;\n    }\n    return f;\n}", "repo_id": "7", "comment": "/**\n * @return days from 0001-01-01\n */\n", "repo_name": "joda-time-main/", "id": 1989, "method_signature": "long fixedFromGJ(int, int, int)"}, "TestJulianChronology.gjFromFixed": {"callee_method_names": [], "method_name": "TestJulianChronology.gjFromFixed", "method_implementation": "{\n    long approx = div(4 * (date - JULIAN_EPOCH) + 1464, 1461);\n    long year = (approx <= 0) ? approx - 1 : approx;\n    int year_i = (int) year;\n    if (year_i != year) {\n        throw new RuntimeException(\"year cannot be cast to an int: \" + year);\n    }\n    long priorDays = date - fixedFromGJ(year_i, 1, 1);\n    long correction;\n    if (date < fixedFromGJ(year_i, 3, 1)) {\n        correction = 0;\n    } else if (isLeapYear(year_i)) {\n        correction = 1;\n    } else {\n        correction = 2;\n    }\n    int monthOfYear = (int) div(12 * (priorDays + correction) + 373, 367);\n    int day = (int) (date - fixedFromGJ(year_i, monthOfYear, 1) + 1);\n    return new int[] { year_i, monthOfYear, day };\n}", "repo_id": "7", "comment": "/**\n * @param date days from 0001-01-01\n * @return gj year, monthOfYear, dayOfMonth\n */\n", "repo_name": "joda-time-main/", "id": 1990, "method_signature": "int[] gjFromFixed(long)"}, "TestJulianChronology.isoFromFixed": {"callee_method_names": [], "method_name": "TestJulianChronology.isoFromFixed", "method_implementation": "{\n    int weekyear = gjYearFromFixed(date - 3);\n    int nextWeekyear;\n    if (weekyear == -1) {\n        nextWeekyear = 1;\n    } else {\n        nextWeekyear = weekyear + 1;\n    }\n    if (date >= fixedFromISO(nextWeekyear, 1, 1)) {\n        weekyear = nextWeekyear;\n    }\n    int weekOfWeekyear = (int) (div(date - fixedFromISO(weekyear, 1, 1), 7) + 1);\n    int dayOfWeek = (int) amod(date, 7);\n    return new int[] { weekyear, weekOfWeekyear, dayOfWeek };\n}", "repo_id": "7", "comment": "/**\n * @param date days from 0001-01-01\n * @return iso weekyear, weekOfWeekyear, dayOfWeek (1=Monday to 7)\n */\n", "repo_name": "joda-time-main/", "id": 1991, "method_signature": "int[] isoFromFixed(long)"}, "TestJulianChronology.testDurationFields": {"callee_method_names": ["JulianChronology.eras", "JulianChronology.centuries", "JulianChronology.years", "JulianChronology.weekyears", "JulianChronology.months", "JulianChronology.weeks", "JulianChronology.days", "JulianChronology.halfdays", "JulianChronology.hours", "JulianChronology.minutes", "JulianChronology.seconds", "JulianChronology.millis", "JulianChronology.eras", "JulianChronology.centuries", "JulianChronology.years", "JulianChronology.weekyears", "JulianChronology.months", "JulianChronology.weeks", "JulianChronology.days", "JulianChronology.halfdays", "JulianChronology.hours", "JulianChronology.minutes", "JulianChronology.seconds", "JulianChronology.millis", "JulianChronology.centuries", "JulianChronology.years", "JulianChronology.weekyears", "JulianChronology.months", "JulianChronology.weeks", "JulianChronology.days", "JulianChronology.halfdays", "JulianChronology.hours", "JulianChronology.minutes", "JulianChronology.seconds", "JulianChronology.millis", "JulianChronology.centuries", "JulianChronology.years", "JulianChronology.weekyears", "JulianChronology.months", "JulianChronology.weeks", "JulianChronology.days", "JulianChronology.halfdays", "JulianChronology.hours", "JulianChronology.minutes", "JulianChronology.seconds", "JulianChronology.millis", "JulianChronology.centuries", "JulianChronology.years", "JulianChronology.weekyears", "JulianChronology.months", "JulianChronology.weeks", "JulianChronology.days", "JulianChronology.halfdays", "JulianChronology.hours", "JulianChronology.minutes", "JulianChronology.seconds", "JulianChronology.millis"], "method_name": "TestJulianChronology.testDurationFields", "method_implementation": "{\n    final JulianChronology julian = JulianChronology.getInstance();\n    assertEquals(\"eras\", julian.eras().getName());\n    assertEquals(\"centuries\", julian.centuries().getName());\n    assertEquals(\"years\", julian.years().getName());\n    assertEquals(\"weekyears\", julian.weekyears().getName());\n    assertEquals(\"months\", julian.months().getName());\n    assertEquals(\"weeks\", julian.weeks().getName());\n    assertEquals(\"days\", julian.days().getName());\n    assertEquals(\"halfdays\", julian.halfdays().getName());\n    assertEquals(\"hours\", julian.hours().getName());\n    assertEquals(\"minutes\", julian.minutes().getName());\n    assertEquals(\"seconds\", julian.seconds().getName());\n    assertEquals(\"millis\", julian.millis().getName());\n    assertEquals(false, julian.eras().isSupported());\n    assertEquals(true, julian.centuries().isSupported());\n    assertEquals(true, julian.years().isSupported());\n    assertEquals(true, julian.weekyears().isSupported());\n    assertEquals(true, julian.months().isSupported());\n    assertEquals(true, julian.weeks().isSupported());\n    assertEquals(true, julian.days().isSupported());\n    assertEquals(true, julian.halfdays().isSupported());\n    assertEquals(true, julian.hours().isSupported());\n    assertEquals(true, julian.minutes().isSupported());\n    assertEquals(true, julian.seconds().isSupported());\n    assertEquals(true, julian.millis().isSupported());\n    assertEquals(false, julian.centuries().isPrecise());\n    assertEquals(false, julian.years().isPrecise());\n    assertEquals(false, julian.weekyears().isPrecise());\n    assertEquals(false, julian.months().isPrecise());\n    assertEquals(false, julian.weeks().isPrecise());\n    assertEquals(false, julian.days().isPrecise());\n    assertEquals(false, julian.halfdays().isPrecise());\n    assertEquals(true, julian.hours().isPrecise());\n    assertEquals(true, julian.minutes().isPrecise());\n    assertEquals(true, julian.seconds().isPrecise());\n    assertEquals(true, julian.millis().isPrecise());\n    final JulianChronology julianUTC = JulianChronology.getInstanceUTC();\n    assertEquals(false, julianUTC.centuries().isPrecise());\n    assertEquals(false, julianUTC.years().isPrecise());\n    assertEquals(false, julianUTC.weekyears().isPrecise());\n    assertEquals(false, julianUTC.months().isPrecise());\n    assertEquals(true, julianUTC.weeks().isPrecise());\n    assertEquals(true, julianUTC.days().isPrecise());\n    assertEquals(true, julianUTC.halfdays().isPrecise());\n    assertEquals(true, julianUTC.hours().isPrecise());\n    assertEquals(true, julianUTC.minutes().isPrecise());\n    assertEquals(true, julianUTC.seconds().isPrecise());\n    assertEquals(true, julianUTC.millis().isPrecise());\n    final DateTimeZone gmt = DateTimeZone.forID(\"Etc/GMT\");\n    final JulianChronology julianGMT = JulianChronology.getInstance(gmt);\n    assertEquals(false, julianGMT.centuries().isPrecise());\n    assertEquals(false, julianGMT.years().isPrecise());\n    assertEquals(false, julianGMT.weekyears().isPrecise());\n    assertEquals(false, julianGMT.months().isPrecise());\n    assertEquals(true, julianGMT.weeks().isPrecise());\n    assertEquals(true, julianGMT.days().isPrecise());\n    assertEquals(true, julianGMT.halfdays().isPrecise());\n    assertEquals(true, julianGMT.hours().isPrecise());\n    assertEquals(true, julianGMT.minutes().isPrecise());\n    assertEquals(true, julianGMT.seconds().isPrecise());\n    assertEquals(true, julianGMT.millis().isPrecise());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1959, "method_signature": "void testDurationFields()"}, "TestJulianChronology.testEquality": {"callee_method_names": [], "method_name": "TestJulianChronology.testEquality", "method_implementation": "{\n    assertSame(JulianChronology.getInstance(TOKYO), JulianChronology.getInstance(TOKYO));\n    assertSame(JulianChronology.getInstance(LONDON), JulianChronology.getInstance(LONDON));\n    assertSame(JulianChronology.getInstance(PARIS), JulianChronology.getInstance(PARIS));\n    assertSame(JulianChronology.getInstanceUTC(), JulianChronology.getInstanceUTC());\n    assertSame(JulianChronology.getInstance(), JulianChronology.getInstance(LONDON));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1958, "method_signature": "void testEquality()"}, "TestLenientChronology.testNearDstTransition": {"callee_method_names": ["DateTime.getHourOfDay", "DateTime.getHourOfDay", "DateTime.getHourOfDay"], "method_name": "TestLenientChronology.testNearDstTransition", "method_implementation": "{\n    // This is just a regression test. Test case provided by Blair Martin.\n    int hour = 23;\n    DateTime dt;\n    dt = new DateTime(2006, 10, 29, hour, 0, 0, 0, ISOChronology.getInstance(DateTimeZone.forID(\"America/Los_Angeles\")));\n    // OK - no LenientChronology\n    assertEquals(hour, dt.getHourOfDay());\n    dt = new DateTime(2006, 10, 29, hour, 0, 0, 0, LenientChronology.getInstance(ISOChronology.getInstance(DateTimeZone.forOffsetHours(-8))));\n    // OK - no TZ ID\n    assertEquals(hour, dt.getHourOfDay());\n    dt = new DateTime(2006, 10, 29, hour, 0, 0, 0, LenientChronology.getInstance(ISOChronology.getInstance(DateTimeZone.forID(\"America/Los_Angeles\"))));\n    // Used to fail - hour was 22\n    assertEquals(hour, dt.getHourOfDay());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1971, "method_signature": "void testNearDstTransition()"}, "TestLenientChronology.test_MockTurkIsCorrect": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.toString"], "method_name": "TestLenientChronology.test_MockTurkIsCorrect", "method_implementation": "{\n    DateTime pre = new DateTime(CUTOVER_TURK - 1L, MOCK_TURK);\n    assertEquals(\"2007-03-31T23:59:59.999-05:00\", pre.toString());\n    DateTime at = new DateTime(CUTOVER_TURK, MOCK_TURK);\n    assertEquals(\"2007-04-01T01:00:00.000-04:00\", at.toString());\n    DateTime post = new DateTime(CUTOVER_TURK + 1L, MOCK_TURK);\n    assertEquals(\"2007-04-01T01:00:00.001-04:00\", post.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1972, "method_signature": "void test_MockTurkIsCorrect()"}, "TestLenientChronology.test_setDayOfMonth": {"callee_method_names": ["DateTime.toString", "DateTime.withDayOfMonth", "DateTime.toString", "DateTime.withDayOfMonth", "DateTime.toString"], "method_name": "TestLenientChronology.test_setDayOfMonth", "method_implementation": "{\n    Chronology zone = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n    DateTime dt = new DateTime(2007, 1, 1, 0, 0, 0, 0, zone);\n    assertEquals(\"2007-01-01T00:00:00.000Z\", dt.toString());\n    dt = dt.withDayOfMonth(32);\n    assertEquals(\"2007-02-01T00:00:00.000Z\", dt.toString());\n    dt = dt.withDayOfMonth(0);\n    assertEquals(\"2007-01-31T00:00:00.000Z\", dt.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1969, "method_signature": "void test_setDayOfMonth()"}, "TestLenientChronology.test_setHourOfDay": {"callee_method_names": ["DateTime.toString", "DateTime.withHourOfDay", "DateTime.toString", "DateTime.withHourOfDay", "DateTime.toString"], "method_name": "TestLenientChronology.test_setHourOfDay", "method_implementation": "{\n    Chronology zone = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n    DateTime dt = new DateTime(2007, 1, 1, 0, 0, 0, 0, zone);\n    assertEquals(\"2007-01-01T00:00:00.000Z\", dt.toString());\n    dt = dt.withHourOfDay(24);\n    assertEquals(\"2007-01-02T00:00:00.000Z\", dt.toString());\n    dt = dt.withHourOfDay(-1);\n    assertEquals(\"2007-01-01T23:00:00.000Z\", dt.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1970, "method_signature": "void test_setHourOfDay()"}, "TestLenientChronology.test_setMonthOfYear": {"callee_method_names": ["DateTime.toString", "DateTime.withMonthOfYear", "DateTime.toString", "DateTime.withMonthOfYear", "DateTime.toString"], "method_name": "TestLenientChronology.test_setMonthOfYear", "method_implementation": "{\n    Chronology zone = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n    DateTime dt = new DateTime(2007, 1, 1, 0, 0, 0, 0, zone);\n    assertEquals(\"2007-01-01T00:00:00.000Z\", dt.toString());\n    dt = dt.withMonthOfYear(13);\n    assertEquals(\"2008-01-01T00:00:00.000Z\", dt.toString());\n    dt = dt.withMonthOfYear(0);\n    assertEquals(\"2007-12-01T00:00:00.000Z\", dt.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1968, "method_signature": "void test_setMonthOfYear()"}, "TestLenientChronology.test_setYear": {"callee_method_names": ["DateTime.toString", "DateTime.withYear", "DateTime.toString"], "method_name": "TestLenientChronology.test_setYear", "method_implementation": "{\n    Chronology zone = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n    DateTime dt = new DateTime(2007, 1, 1, 0, 0, 0, 0, zone);\n    assertEquals(\"2007-01-01T00:00:00.000Z\", dt.toString());\n    dt = dt.withYear(2008);\n    assertEquals(\"2008-01-01T00:00:00.000Z\", dt.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1967, "method_signature": "void test_setYear()"}, "TestLocalDateTime_Basics.check": {"callee_method_names": ["LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Basics.check", "method_implementation": "{\n    assertEquals(year, test.getYear());\n    assertEquals(month, test.getMonthOfYear());\n    assertEquals(day, test.getDayOfMonth());\n    assertEquals(hour, test.getHourOfDay());\n    assertEquals(min, test.getMinuteOfHour());\n    assertEquals(sec, test.getSecondOfMinute());\n    assertEquals(mil, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1423, "method_signature": "void check(LocalDateTime, int, int, int, int, int, int, int)"}, "TestLocalDateTime_Basics.testCompareTo": {"callee_method_ids": [957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957, 957], "callee_method_names": ["LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo", "LocalDateTime.compareTo"], "method_name": "TestLocalDateTime_Basics.testCompareTo", "method_implementation": "{\n    LocalDateTime test1 = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40);\n    LocalDateTime test1a = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40);\n    assertEquals(0, test1.compareTo(test1a));\n    assertEquals(0, test1a.compareTo(test1));\n    assertEquals(0, test1.compareTo(test1));\n    assertEquals(0, test1a.compareTo(test1a));\n    LocalDateTime test2 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40);\n    assertEquals(-1, test1.compareTo(test2));\n    assertEquals(+1, test2.compareTo(test1));\n    LocalDateTime test3 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40, GREGORIAN_UTC);\n    assertEquals(-1, test1.compareTo(test3));\n    assertEquals(+1, test3.compareTo(test1));\n    assertEquals(0, test3.compareTo(test2));\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.millisOfDay() };\n    int[] values = new int[] { 2005, 6, 2, MILLIS_OF_DAY_UTC };\n    Partial p = new Partial(types, values);\n    assertEquals(0, test1.compareTo(p));\n    try {\n        test1.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n    //        try {\n    //            test1.compareTo(new Date());\n    //            fail();\n    //        } catch (ClassCastException ex) {}\n    try {\n        @SuppressWarnings(\"deprecation\")\n        YearMonthDay ymd = new YearMonthDay();\n        test1.compareTo(ymd);\n        fail();\n    } catch (ClassCastException ex) {\n    }\n    try {\n        @SuppressWarnings(\"deprecation\")\n        TimeOfDay tod = new TimeOfDay();\n        test1.compareTo(tod);\n        fail();\n    } catch (ClassCastException ex) {\n    }\n    Partial partial = new Partial().with(DateTimeFieldType.centuryOfEra(), 1).with(DateTimeFieldType.halfdayOfDay(), 0).with(DateTimeFieldType.dayOfMonth(), 9);\n    try {\n        new LocalDateTime(1970, 6, 9, 10, 20, 30, 40).compareTo(partial);\n        fail();\n    } catch (ClassCastException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1400, "method_signature": "void testCompareTo()"}, "TestLocalDateTime_Basics.testGet_DateTimeFieldType": {"callee_method_ids": [953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953], "callee_method_names": ["LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get", "LocalDateTime.get"], "method_name": "TestLocalDateTime_Basics.testGet_DateTimeFieldType", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40);\n    assertEquals(1970, test.get(DateTimeFieldType.year()));\n    assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n    assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n    assertEquals(2, test.get(DateTimeFieldType.dayOfWeek()));\n    assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));\n    assertEquals(24, test.get(DateTimeFieldType.weekOfWeekyear()));\n    assertEquals(1970, test.get(DateTimeFieldType.weekyear()));\n    assertEquals(10, test.get(DateTimeFieldType.hourOfDay()));\n    assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));\n    assertEquals(30, test.get(DateTimeFieldType.secondOfMinute()));\n    assertEquals(40, test.get(DateTimeFieldType.millisOfSecond()));\n    assertEquals(MILLIS_OF_DAY_UTC / 60000, test.get(DateTimeFieldType.minuteOfDay()));\n    assertEquals(MILLIS_OF_DAY_UTC / 1000, test.get(DateTimeFieldType.secondOfDay()));\n    assertEquals(MILLIS_OF_DAY_UTC, test.get(DateTimeFieldType.millisOfDay()));\n    assertEquals(10, test.get(DateTimeFieldType.hourOfHalfday()));\n    assertEquals(DateTimeConstants.AM, test.get(DateTimeFieldType.halfdayOfDay()));\n    test = new LocalDateTime(1970, 6, 9, 12, 30);\n    assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday()));\n    assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday()));\n    assertEquals(12, test.get(DateTimeFieldType.clockhourOfDay()));\n    assertEquals(DateTimeConstants.PM, test.get(DateTimeFieldType.halfdayOfDay()));\n    test = new LocalDateTime(1970, 6, 9, 14, 30);\n    assertEquals(2, test.get(DateTimeFieldType.hourOfHalfday()));\n    assertEquals(2, test.get(DateTimeFieldType.clockhourOfHalfday()));\n    assertEquals(14, test.get(DateTimeFieldType.clockhourOfDay()));\n    assertEquals(DateTimeConstants.PM, test.get(DateTimeFieldType.halfdayOfDay()));\n    test = new LocalDateTime(1970, 6, 9, 0, 30);\n    assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday()));\n    assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday()));\n    assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay()));\n    assertEquals(DateTimeConstants.AM, test.get(DateTimeFieldType.halfdayOfDay()));\n    try {\n        test.get(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1399, "method_signature": "void testGet_DateTimeFieldType()"}, "TestLocalDateTime_Basics.testGetters": {"callee_method_names": ["LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getDayOfYear", "LocalDateTime.getDayOfWeek", "LocalDateTime.getWeekOfWeekyear", "LocalDateTime.getWeekyear", "LocalDateTime.getYearOfCentury", "LocalDateTime.getCenturyOfEra", "LocalDateTime.getYearOfEra", "LocalDateTime.getEra", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond", "LocalDateTime.getMillisOfDay"], "method_name": "TestLocalDateTime_Basics.testGetters", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40, GJ_UTC);\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(160, test.getDayOfYear());\n    assertEquals(2, test.getDayOfWeek());\n    assertEquals(24, test.getWeekOfWeekyear());\n    assertEquals(1970, test.getWeekyear());\n    assertEquals(70, test.getYearOfCentury());\n    assertEquals(20, test.getCenturyOfEra());\n    assertEquals(1970, test.getYearOfEra());\n    assertEquals(DateTimeConstants.AD, test.getEra());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    assertEquals(MILLIS_OF_DAY_UTC, test.getMillisOfDay());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1410, "method_signature": "void testGetters()"}, "TestLocalDateTime_Basics.testIsAfter_LocalDateTime": {"callee_method_names": ["LocalDateTime.isAfter", "LocalDateTime.isAfter", "LocalDateTime.isAfter", "LocalDateTime.isAfter", "LocalDateTime.isAfter", "LocalDateTime.isAfter", "LocalDateTime.isAfter", "LocalDateTime.isAfter", "LocalDateTime.isAfter"], "method_name": "TestLocalDateTime_Basics.testIsAfter_LocalDateTime", "method_implementation": "{\n    LocalDateTime test1 = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40);\n    LocalDateTime test1a = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40);\n    assertEquals(false, test1.isAfter(test1a));\n    assertEquals(false, test1a.isAfter(test1));\n    assertEquals(false, test1.isAfter(test1));\n    assertEquals(false, test1a.isAfter(test1a));\n    LocalDateTime test2 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40);\n    assertEquals(false, test1.isAfter(test2));\n    assertEquals(true, test2.isAfter(test1));\n    LocalDateTime test3 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40, GREGORIAN_UTC);\n    assertEquals(false, test1.isAfter(test3));\n    assertEquals(true, test3.isAfter(test1));\n    assertEquals(false, test3.isAfter(test2));\n    try {\n        new LocalDateTime(2005, 7, 2, 10, 20, 30, 40).isAfter(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1403, "method_signature": "void testIsAfter_LocalDateTime()"}, "TestLocalDateTime_Basics.testIsBefore_LocalDateTime": {"callee_method_names": ["LocalDateTime.isBefore", "LocalDateTime.isBefore", "LocalDateTime.isBefore", "LocalDateTime.isBefore", "LocalDateTime.isBefore", "LocalDateTime.isBefore", "LocalDateTime.isBefore", "LocalDateTime.isBefore", "LocalDateTime.isBefore"], "method_name": "TestLocalDateTime_Basics.testIsBefore_LocalDateTime", "method_implementation": "{\n    LocalDateTime test1 = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40);\n    LocalDateTime test1a = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40);\n    assertEquals(false, test1.isBefore(test1a));\n    assertEquals(false, test1a.isBefore(test1));\n    assertEquals(false, test1.isBefore(test1));\n    assertEquals(false, test1a.isBefore(test1a));\n    LocalDateTime test2 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40);\n    assertEquals(true, test1.isBefore(test2));\n    assertEquals(false, test2.isBefore(test1));\n    LocalDateTime test3 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40, GREGORIAN_UTC);\n    assertEquals(true, test1.isBefore(test3));\n    assertEquals(false, test3.isBefore(test1));\n    assertEquals(false, test3.isBefore(test2));\n    try {\n        new LocalDateTime(2005, 7, 2, 10, 20, 30, 40).isBefore(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1402, "method_signature": "void testIsBefore_LocalDateTime()"}, "TestLocalDateTime_Basics.testIsEqual_LocalDateTime": {"callee_method_names": ["LocalDateTime.isEqual", "LocalDateTime.isEqual", "LocalDateTime.isEqual", "LocalDateTime.isEqual", "LocalDateTime.isEqual", "LocalDateTime.isEqual", "LocalDateTime.isEqual", "LocalDateTime.isEqual", "LocalDateTime.isEqual"], "method_name": "TestLocalDateTime_Basics.testIsEqual_LocalDateTime", "method_implementation": "{\n    LocalDateTime test1 = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40);\n    LocalDateTime test1a = new LocalDateTime(2005, 6, 2, 10, 20, 30, 40);\n    assertEquals(true, test1.isEqual(test1a));\n    assertEquals(true, test1a.isEqual(test1));\n    assertEquals(true, test1.isEqual(test1));\n    assertEquals(true, test1a.isEqual(test1a));\n    LocalDateTime test2 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40);\n    assertEquals(false, test1.isEqual(test2));\n    assertEquals(false, test2.isEqual(test1));\n    LocalDateTime test3 = new LocalDateTime(2005, 7, 2, 10, 20, 30, 40, GREGORIAN_UTC);\n    assertEquals(false, test1.isEqual(test3));\n    assertEquals(false, test3.isEqual(test1));\n    assertEquals(true, test3.isEqual(test2));\n    try {\n        new LocalDateTime(2005, 7, 2, 10, 20, 30, 40).isEqual(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1401, "method_signature": "void testIsEqual_LocalDateTime()"}, "TestLocalDateTime_Basics.testMinus_RP": {"callee_method_names": ["LocalDateTime.minus", "LocalDateTime.minus"], "method_name": "TestLocalDateTime_Basics.testMinus_RP", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON);\n    LocalDateTime result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n    LocalDateTime expected = new LocalDateTime(2001, 3, 26, 9, 19, 29, 39, BUDDHIST_LONDON);\n    assertEquals(expected, result);\n    result = test.minus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1409, "method_signature": "void testMinus_RP()"}, "TestLocalDateTime_Basics.testPlus_RP": {"callee_method_names": ["LocalDateTime.plus", "LocalDateTime.plus"], "method_name": "TestLocalDateTime_Basics.testPlus_RP", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2002, 5, 3, 10, 20, 30, 40, BUDDHIST_LONDON);\n    LocalDateTime result = test.plus(new Period(1, 2, 3, 4, 29, 6, 7, 8));\n    LocalDateTime expected = new LocalDateTime(2003, 7, 29, 15, 26, 37, 48, BUDDHIST_LONDON);\n    assertEquals(expected, result);\n    result = test.plus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1408, "method_signature": "void testPlus_RP()"}, "TestLocalDateTime_Basics.testProperty": {"callee_method_ids": [985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985], "callee_method_names": ["LocalDateTime.year", "LocalDateTime.property", "LocalDateTime.monthOfYear", "LocalDateTime.property", "LocalDateTime.dayOfMonth", "LocalDateTime.property", "LocalDateTime.dayOfWeek", "LocalDateTime.property", "LocalDateTime.dayOfYear", "LocalDateTime.property", "LocalDateTime.weekOfWeekyear", "LocalDateTime.property", "LocalDateTime.weekyear", "LocalDateTime.property", "LocalDateTime.yearOfCentury", "LocalDateTime.property", "LocalDateTime.yearOfEra", "LocalDateTime.property", "LocalDateTime.centuryOfEra", "LocalDateTime.property", "LocalDateTime.era", "LocalDateTime.property", "LocalDateTime.hourOfDay", "LocalDateTime.property", "LocalDateTime.minuteOfHour", "LocalDateTime.property", "LocalDateTime.secondOfMinute", "LocalDateTime.property", "LocalDateTime.millisOfSecond", "LocalDateTime.property", "LocalDateTime.millisOfDay", "LocalDateTime.property", "LocalDateTime.property", "LocalDateTime.property"], "method_name": "TestLocalDateTime_Basics.testProperty", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40, GJ_UTC);\n    assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n    assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));\n    assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth()));\n    assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek()));\n    assertEquals(test.dayOfYear(), test.property(DateTimeFieldType.dayOfYear()));\n    assertEquals(test.weekOfWeekyear(), test.property(DateTimeFieldType.weekOfWeekyear()));\n    assertEquals(test.weekyear(), test.property(DateTimeFieldType.weekyear()));\n    assertEquals(test.yearOfCentury(), test.property(DateTimeFieldType.yearOfCentury()));\n    assertEquals(test.yearOfEra(), test.property(DateTimeFieldType.yearOfEra()));\n    assertEquals(test.centuryOfEra(), test.property(DateTimeFieldType.centuryOfEra()));\n    assertEquals(test.era(), test.property(DateTimeFieldType.era()));\n    assertEquals(test.hourOfDay(), test.property(DateTimeFieldType.hourOfDay()));\n    assertEquals(test.minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour()));\n    assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute()));\n    assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond()));\n    assertEquals(test.millisOfDay(), test.property(DateTimeFieldType.millisOfDay()));\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    assertEquals(test, test.property(DateTimeFieldType.minuteOfDay()).getLocalDateTime());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1418, "method_signature": "void testProperty()"}, "TestLocalDateTime_Basics.testSerialization": {"callee_method_ids": [955], "callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close", "LocalDateTime.getValues", "LocalDateTime.getValues", "LocalDateTime.getFields", "LocalDateTime.getFields", "LocalDateTime.getChronology", "LocalDateTime.getChronology", "LocalDateTime.isSupported"], "method_name": "TestLocalDateTime_Basics.testSerialization", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40, COPTIC_PARIS);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    LocalDateTime result = (LocalDateTime) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n    assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n    assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n    assertEquals(test.getChronology(), result.getChronology());\n    // check deserialization\n    assertTrue(result.isSupported(DateTimeFieldType.dayOfMonth()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1419, "method_signature": "void testSerialization()"}, "TestLocalDateTime_Basics.testToDateTime": {"callee_method_ids": [958], "callee_method_names": ["LocalDateTime.toDateTime"], "method_name": "TestLocalDateTime_Basics.testToDateTime", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDateTime base = new LocalDateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_PARIS);\n    DateTime test = base.toDateTime();\n    check(base, 2005, 6, 9, 6, 7, 8, 9);\n    DateTime expected = new DateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_LONDON);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1412, "method_signature": "void testToDateTime()"}, "TestLocalDateTime_Basics.testToDateTime_RI": {"callee_method_ids": [958], "callee_method_names": ["LocalDateTime.toDateTime"], "method_name": "TestLocalDateTime_Basics.testToDateTime_RI", "method_implementation": "{\n    LocalDateTime base = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40, COPTIC_PARIS);\n    DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7, BUDDHIST_TOKYO);\n    DateTime test = base.toDateTime(dt);\n    check(base, 2005, 6, 9, 10, 20, 30, 40);\n    DateTime expected = new DateTime(2005, 6, 9, 10, 20, 30, 40, BUDDHIST_TOKYO);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1415, "method_signature": "void testToDateTime_RI()"}, "TestLocalDateTime_Basics.testToDateTime_Zone": {"callee_method_ids": [958], "callee_method_names": ["LocalDateTime.toDateTime"], "method_name": "TestLocalDateTime_Basics.testToDateTime_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDateTime base = new LocalDateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_PARIS);\n    DateTime test = base.toDateTime(TOKYO);\n    check(base, 2005, 6, 9, 6, 7, 8, 9);\n    DateTime expected = new DateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_TOKYO);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1413, "method_signature": "void testToDateTime_Zone()"}, "TestLocalDateTime_Basics.testToDate_summer": {"callee_method_ids": [960], "callee_method_names": ["LocalDateTime.toDate", "GregorianCalendar.clear", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestLocalDateTime_Basics.testToDate_summer", "method_implementation": "{\n    LocalDateTime base = new LocalDateTime(2005, 7, 9, 10, 20, 30, 40, COPTIC_PARIS);\n    Date test = base.toDate();\n    check(base, 2005, 7, 9, 10, 20, 30, 40);\n    GregorianCalendar gcal = new GregorianCalendar();\n    gcal.clear();\n    gcal.set(Calendar.YEAR, 2005);\n    gcal.set(Calendar.MONTH, Calendar.JULY);\n    gcal.set(Calendar.DAY_OF_MONTH, 9);\n    gcal.set(Calendar.HOUR_OF_DAY, 10);\n    gcal.set(Calendar.MINUTE, 20);\n    gcal.set(Calendar.SECOND, 30);\n    gcal.set(Calendar.MILLISECOND, 40);\n    assertEquals(gcal.getTime(), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1416, "method_signature": "void testToDate_summer()"}, "TestLocalDateTime_Basics.testToDate_summer_Zone": {"callee_method_ids": [960], "callee_method_names": ["LocalDateTime.toDate", "GregorianCalendar.clear", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestLocalDateTime_Basics.testToDate_summer_Zone", "method_implementation": "{\n    LocalDateTime base = new LocalDateTime(2005, 7, 9, 10, 20, 30, 40, COPTIC_PARIS);\n    Date test = base.toDate(TimeZone.getDefault());\n    check(base, 2005, 7, 9, 10, 20, 30, 40);\n    GregorianCalendar gcal = new GregorianCalendar();\n    gcal.clear();\n    gcal.set(Calendar.YEAR, 2005);\n    gcal.set(Calendar.MONTH, Calendar.JULY);\n    gcal.set(Calendar.DAY_OF_MONTH, 9);\n    gcal.set(Calendar.HOUR_OF_DAY, 10);\n    gcal.set(Calendar.MINUTE, 20);\n    gcal.set(Calendar.SECOND, 30);\n    gcal.set(Calendar.MILLISECOND, 40);\n    assertEquals(gcal.getTime(), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1417, "method_signature": "void testToDate_summer_Zone()"}, "TestLocalDateTime_Basics.testToLocalDate": {"callee_method_names": ["LocalDateTime.toLocalDate"], "method_name": "TestLocalDateTime_Basics.testToLocalDate", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDateTime base = new LocalDateTime(2005, 6, 9, 6, 7, 8, 9, COPTIC_PARIS);\n    LocalDate expected = new LocalDate(2005, 6, 9, COPTIC_LONDON);\n    assertEquals(expected, base.toLocalDate());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1414, "method_signature": "void testToLocalDate()"}, "TestLocalDateTime_Basics.testToString_DTFormatter": {"callee_method_ids": [988, 988], "callee_method_names": ["LocalDateTime.toString", "LocalDateTime.toString"], "method_name": "TestLocalDateTime_Basics.testToString_DTFormatter", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2002, 6, 9, 10, 20, 30, 40);\n    assertEquals(\"2002 10\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n    assertEquals(\"2002-06-09T10:20:30.040\", test.toString((DateTimeFormatter) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1422, "method_signature": "void testToString_DTFormatter()"}, "TestLocalDateTime_Basics.testToString_String": {"callee_method_ids": [988, 988], "callee_method_names": ["LocalDateTime.toString", "LocalDateTime.toString"], "method_name": "TestLocalDateTime_Basics.testToString_String", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2002, 6, 9, 10, 20, 30, 40);\n    assertEquals(\"2002 10\", test.toString(\"yyyy HH\"));\n    assertEquals(\"2002-06-09T10:20:30.040\", test.toString((String) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1420, "method_signature": "void testToString_String()"}, "TestLocalDateTime_Basics.testToString_String_Locale": {"callee_method_ids": [988, 988, 988, 988, 988], "callee_method_names": ["LocalDateTime.toString", "LocalDateTime.toString", "LocalDateTime.toString", "LocalDateTime.toString", "LocalDateTime.toString"], "method_name": "TestLocalDateTime_Basics.testToString_String_Locale", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40);\n    assertEquals(\"Tue 9/6\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n    assertEquals(\"mar. 9/6\", test.toString(\"EEE d/M\", Locale.FRENCH));\n    assertEquals(\"1970-06-09T10:20:30.040\", test.toString(null, Locale.ENGLISH));\n    assertEquals(\"Tue 9/6\", test.toString(\"EEE d/M\", null));\n    assertEquals(\"1970-06-09T10:20:30.040\", test.toString(null, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1421, "method_signature": "void testToString_String_Locale()"}, "TestLocalDateTime_Basics.testWithDate": {"callee_method_ids": [962], "callee_method_names": ["LocalDateTime.withDate"], "method_name": "TestLocalDateTime_Basics.testWithDate", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40);\n    LocalDateTime result = test.withDate(2006, 2, 1);\n    check(test, 2004, 6, 9, 10, 20, 30, 40);\n    check(result, 2006, 2, 1, 10, 20, 30, 40);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1404, "method_signature": "void testWithDate()"}, "TestLocalDateTime_Basics.testWithFieldAdded_DurationFieldType_int_1": {"callee_method_ids": [966], "callee_method_names": ["LocalDateTime.withFieldAdded"], "method_name": "TestLocalDateTime_Basics.testWithFieldAdded_DurationFieldType_int_1", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40);\n    LocalDateTime result = test.withFieldAdded(DurationFieldType.years(), 6);\n    assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30, 40), test);\n    assertEquals(new LocalDateTime(2010, 6, 9, 10, 20, 30, 40), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1407, "method_signature": "void testWithFieldAdded_DurationFieldType_int_1()"}, "TestLocalDateTime_Basics.testWithField_DateTimeFieldType_int_1": {"callee_method_ids": [965], "callee_method_names": ["LocalDateTime.withField"], "method_name": "TestLocalDateTime_Basics.testWithField_DateTimeFieldType_int_1", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40);\n    LocalDateTime result = test.withField(DateTimeFieldType.year(), 2006);\n    assertEquals(new LocalDateTime(2004, 6, 9, 10, 20, 30, 40), test);\n    assertEquals(new LocalDateTime(2006, 6, 9, 10, 20, 30, 40), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1406, "method_signature": "void testWithField_DateTimeFieldType_int_1()"}, "TestLocalDateTime_Basics.testWithTime": {"callee_method_ids": [963], "callee_method_names": ["LocalDateTime.withTime"], "method_name": "TestLocalDateTime_Basics.testWithTime", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2004, 6, 9, 10, 20, 30, 40);\n    LocalDateTime result = test.withTime(9, 8, 7, 6);\n    check(test, 2004, 6, 9, 10, 20, 30, 40);\n    check(result, 2004, 6, 9, 9, 8, 7, 6);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1405, "method_signature": "void testWithTime()"}, "TestLocalDateTime_Basics.testWithers": {"callee_method_names": ["LocalDateTime.withYear", "LocalDateTime.withMonthOfYear", "LocalDateTime.withDayOfMonth", "LocalDateTime.withDayOfYear", "LocalDateTime.withDayOfWeek", "LocalDateTime.withWeekOfWeekyear", "LocalDateTime.withWeekyear", "LocalDateTime.withYearOfCentury", "LocalDateTime.withCenturyOfEra", "LocalDateTime.withYearOfEra", "LocalDateTime.withEra", "LocalDateTime.withHourOfDay", "LocalDateTime.withMinuteOfHour", "LocalDateTime.withSecondOfMinute", "LocalDateTime.withMillisOfSecond", "LocalDateTime.withMillisOfDay", "LocalDateTime.withMonthOfYear", "LocalDateTime.withMonthOfYear"], "method_name": "TestLocalDateTime_Basics.testWithers", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(1970, 6, 9, 10, 20, 30, 40, GJ_UTC);\n    check(test.withYear(2000), 2000, 6, 9, 10, 20, 30, 40);\n    check(test.withMonthOfYear(2), 1970, 2, 9, 10, 20, 30, 40);\n    check(test.withDayOfMonth(2), 1970, 6, 2, 10, 20, 30, 40);\n    check(test.withDayOfYear(6), 1970, 1, 6, 10, 20, 30, 40);\n    check(test.withDayOfWeek(6), 1970, 6, 13, 10, 20, 30, 40);\n    check(test.withWeekOfWeekyear(6), 1970, 2, 3, 10, 20, 30, 40);\n    check(test.withWeekyear(1971), 1971, 6, 15, 10, 20, 30, 40);\n    check(test.withYearOfCentury(60), 1960, 6, 9, 10, 20, 30, 40);\n    check(test.withCenturyOfEra(21), 2070, 6, 9, 10, 20, 30, 40);\n    check(test.withYearOfEra(1066), 1066, 6, 9, 10, 20, 30, 40);\n    check(test.withEra(DateTimeConstants.BC), -1970, 6, 9, 10, 20, 30, 40);\n    check(test.withHourOfDay(6), 1970, 6, 9, 6, 20, 30, 40);\n    check(test.withMinuteOfHour(6), 1970, 6, 9, 10, 6, 30, 40);\n    check(test.withSecondOfMinute(6), 1970, 6, 9, 10, 20, 6, 40);\n    check(test.withMillisOfSecond(6), 1970, 6, 9, 10, 20, 30, 6);\n    check(test.withMillisOfDay(61234), 1970, 6, 9, 0, 1, 1, 234);\n    try {\n        test.withMonthOfYear(0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.withMonthOfYear(13);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1411, "method_signature": "void testWithers()"}, "TestLocalDateTime_Constructors.testConstructor": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime();\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(10 + OFFSET_MOSCOW, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    assertEquals(test, LocalDateTime.now());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2163, "method_signature": "void testConstructor()"}, "TestLocalDateTime_Constructors.testConstructor_Chronology": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_Chronology", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(10 + OFFSET_PARIS, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    assertEquals(test, LocalDateTime.now(GREGORIAN_PARIS));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2165, "method_signature": "void testConstructor_Chronology()"}, "TestLocalDateTime_Constructors.testConstructor_DateTimeZone": {"callee_method_names": ["DateTime.getMillis", "LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond", "LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_DateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    LocalDateTime test = new LocalDateTime(LONDON);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(8, test.getDayOfMonth());\n    assertEquals(23, test.getHourOfDay());\n    assertEquals(59, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n    assertEquals(test, LocalDateTime.now(LONDON));\n    test = new LocalDateTime(PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(0, test.getHourOfDay());\n    assertEquals(59, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n    assertEquals(test, LocalDateTime.now(PARIS));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2164, "method_signature": "void testConstructor_DateTimeZone()"}, "TestLocalDateTime_Constructors.testConstructor_Object1": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_Object1", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    LocalDateTime test = new LocalDateTime(date);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n    assertEquals(12 + OFFSET_MOSCOW, test.getHourOfDay());\n    assertEquals(24, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2169, "method_signature": "void testConstructor_Object1()"}, "TestLocalDateTime_Constructors.testConstructor_Object_Chronology": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_Object_Chronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    LocalDateTime test = new LocalDateTime(date, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n    assertEquals(12 + OFFSET_PARIS, test.getHourOfDay());\n    assertEquals(24, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2171, "method_signature": "void testConstructor_Object_Chronology()"}, "TestLocalDateTime_Constructors.testConstructor_Object_DateTimeZone": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_Object_DateTimeZone", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    LocalDateTime test = new LocalDateTime(date, PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n    assertEquals(12 + OFFSET_PARIS, test.getHourOfDay());\n    assertEquals(24, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2170, "method_signature": "void testConstructor_Object_DateTimeZone()"}, "TestLocalDateTime_Constructors.testConstructor_int_int_int_int_int": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_int_int_int_int_int", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2172, "method_signature": "void testConstructor_int_int_int_int_int()"}, "TestLocalDateTime_Constructors.testConstructor_int_int_int_int_int_int": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_int_int_int_int_int_int", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2173, "method_signature": "void testConstructor_int_int_int_int_int_int()"}, "TestLocalDateTime_Constructors.testConstructor_int_int_int_int_int_int_int": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_int_int_int_int_int_int_int", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    try {\n        new LocalDateTime(Integer.MIN_VALUE, 6, 9, 10, 20, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new LocalDateTime(Integer.MAX_VALUE, 6, 9, 10, 20, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new LocalDateTime(2005, 0, 9, 10, 20, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new LocalDateTime(2005, 13, 9, 10, 20, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new LocalDateTime(2005, 6, 0, 10, 20, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new LocalDateTime(2005, 6, 31, 10, 20, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new LocalDateTime(2005, 7, 31, 10, 20, 30, 40);\n    try {\n        new LocalDateTime(2005, 7, 32, 10, 20, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2174, "method_signature": "void testConstructor_int_int_int_int_int_int_int()"}, "TestLocalDateTime_Constructors.testConstructor_long1": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_long1", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(TEST_TIME1);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n    assertEquals(12 + OFFSET_MOSCOW, test.getHourOfDay());\n    assertEquals(24, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2166, "method_signature": "void testConstructor_long1()"}, "TestLocalDateTime_Constructors.testConstructor_long1_Chronology": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_long1_Chronology", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(TEST_TIME1, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n    assertEquals(12 + OFFSET_PARIS, test.getHourOfDay());\n    assertEquals(24, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2168, "method_signature": "void testConstructor_long1_Chronology()"}, "TestLocalDateTime_Constructors.testConstructor_long1_DateTimeZone": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Constructors.testConstructor_long1_DateTimeZone", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(TEST_TIME1, PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n    assertEquals(12 + OFFSET_PARIS, test.getHourOfDay());\n    assertEquals(24, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2167, "method_signature": "void testConstructor_long1_DateTimeZone()"}, "TestLocalDateTime_Constructors.testFactory_fromCalendarFields": {"callee_method_names": ["GregorianCalendar.set"], "method_name": "TestLocalDateTime_Constructors.testFactory_fromCalendarFields", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    LocalDateTime expected = new LocalDateTime(1970, 2, 3, 4, 5, 6, 7);\n    assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2161, "method_signature": "void testFactory_fromCalendarFields()"}, "TestLocalDateTime_Constructors.testFactory_fromDateFields_after1970": {"callee_method_names": ["GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestLocalDateTime_Constructors.testFactory_fromDateFields_after1970", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    LocalDateTime expected = new LocalDateTime(1970, 2, 3, 4, 5, 6, 7);\n    assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2162, "method_signature": "void testFactory_fromDateFields_after1970()"}, "TestLocalDateTime_Properties.check": {"callee_method_names": ["LocalDateTime.getYear", "LocalDateTime.getMonthOfYear", "LocalDateTime.getDayOfMonth", "LocalDateTime.getHourOfDay", "LocalDateTime.getMinuteOfHour", "LocalDateTime.getSecondOfMinute", "LocalDateTime.getMillisOfSecond"], "method_name": "TestLocalDateTime_Properties.check", "method_implementation": "{\n    assertEquals(year, test.getYear());\n    assertEquals(month, test.getMonthOfYear());\n    assertEquals(day, test.getDayOfMonth());\n    assertEquals(hour, test.getHourOfDay());\n    assertEquals(min, test.getMinuteOfHour());\n    assertEquals(sec, test.getSecondOfMinute());\n    assertEquals(mil, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1431, "method_signature": "void check(LocalDateTime, int, int, int, int, int, int, int)"}, "TestLocalDateTime_Properties.testPropertyGetDay": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.getChronology", "LocalDateTime.dayOfMonth", "LocalDateTime.getChronology", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth", "LocalDateTime.dayOfMonth"], "method_name": "TestLocalDateTime_Properties.testPropertyGetDay", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40);\n    assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n    assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n    assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n    assertSame(test, test.dayOfMonth().getLocalDateTime());\n    assertEquals(9, test.dayOfMonth().get());\n    assertEquals(\"9\", test.dayOfMonth().getAsString());\n    assertEquals(\"9\", test.dayOfMonth().getAsText());\n    assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText());\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n    assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n    assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n    assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1426, "method_signature": "void testPropertyGetDay()"}, "TestLocalDateTime_Properties.testPropertyGetHour": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.getChronology", "LocalDateTime.hourOfDay", "LocalDateTime.getChronology", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay", "LocalDateTime.hourOfDay"], "method_name": "TestLocalDateTime_Properties.testPropertyGetHour", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40);\n    assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n    assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n    assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n    assertSame(test, test.hourOfDay().getLocalDateTime());\n    assertEquals(10, test.hourOfDay().get());\n    assertEquals(\"10\", test.hourOfDay().getAsString());\n    assertEquals(\"10\", test.hourOfDay().getAsText());\n    assertEquals(\"10\", test.hourOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"10\", test.hourOfDay().getAsShortText());\n    assertEquals(\"10\", test.hourOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());\n    assertEquals(2, test.hourOfDay().getMaximumTextLength(null));\n    assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1427, "method_signature": "void testPropertyGetHour()"}, "TestLocalDateTime_Properties.testPropertyGetMilli": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.getChronology", "LocalDateTime.millisOfSecond", "LocalDateTime.getChronology", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond", "LocalDateTime.millisOfSecond"], "method_name": "TestLocalDateTime_Properties.testPropertyGetMilli", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40);\n    assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n    assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n    assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n    assertSame(test, test.millisOfSecond().getLocalDateTime());\n    assertEquals(40, test.millisOfSecond().get());\n    assertEquals(\"40\", test.millisOfSecond().getAsString());\n    assertEquals(\"40\", test.millisOfSecond().getAsText());\n    assertEquals(\"40\", test.millisOfSecond().getAsText(Locale.FRENCH));\n    assertEquals(\"40\", test.millisOfSecond().getAsShortText());\n    assertEquals(\"40\", test.millisOfSecond().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());\n    assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());\n    assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));\n    assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1430, "method_signature": "void testPropertyGetMilli()"}, "TestLocalDateTime_Properties.testPropertyGetMinute": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.getChronology", "LocalDateTime.minuteOfHour", "LocalDateTime.getChronology", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour", "LocalDateTime.minuteOfHour"], "method_name": "TestLocalDateTime_Properties.testPropertyGetMinute", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40);\n    assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n    assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n    assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n    assertSame(test, test.minuteOfHour().getLocalDateTime());\n    assertEquals(20, test.minuteOfHour().get());\n    assertEquals(\"20\", test.minuteOfHour().getAsString());\n    assertEquals(\"20\", test.minuteOfHour().getAsText());\n    assertEquals(\"20\", test.minuteOfHour().getAsText(Locale.FRENCH));\n    assertEquals(\"20\", test.minuteOfHour().getAsShortText());\n    assertEquals(\"20\", test.minuteOfHour().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());\n    assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());\n    assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));\n    assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1428, "method_signature": "void testPropertyGetMinute()"}, "TestLocalDateTime_Properties.testPropertyGetMonth": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.getChronology", "LocalDateTime.monthOfYear", "LocalDateTime.getChronology", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear", "LocalDateTime.monthOfYear"], "method_name": "TestLocalDateTime_Properties.testPropertyGetMonth", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40);\n    assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n    assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n    assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n    assertSame(test, test.monthOfYear().getLocalDateTime());\n    assertEquals(6, test.monthOfYear().get());\n    assertEquals(\"6\", test.monthOfYear().getAsString());\n    assertEquals(\"June\", test.monthOfYear().getAsText());\n    assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n    assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n    assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n    assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));\n    test = new LocalDateTime(1972, 7, 9, 10, 20, 30, 40);\n    assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1425, "method_signature": "void testPropertyGetMonth()"}, "TestLocalDateTime_Properties.testPropertyGetSecond": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.getChronology", "LocalDateTime.secondOfMinute", "LocalDateTime.getChronology", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute", "LocalDateTime.secondOfMinute"], "method_name": "TestLocalDateTime_Properties.testPropertyGetSecond", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(2005, 6, 9, 10, 20, 30, 40);\n    assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n    assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n    assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n    assertSame(test, test.secondOfMinute().getLocalDateTime());\n    assertEquals(30, test.secondOfMinute().get());\n    assertEquals(\"30\", test.secondOfMinute().getAsString());\n    assertEquals(\"30\", test.secondOfMinute().getAsText());\n    assertEquals(\"30\", test.secondOfMinute().getAsText(Locale.FRENCH));\n    assertEquals(\"30\", test.secondOfMinute().getAsShortText());\n    assertEquals(\"30\", test.secondOfMinute().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());\n    assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());\n    assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));\n    assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1429, "method_signature": "void testPropertyGetSecond()"}, "TestLocalDateTime_Properties.testPropertyGetYear": {"callee_method_names": ["LocalDateTime.getChronology", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.getChronology", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year", "LocalDateTime.year"], "method_name": "TestLocalDateTime_Properties.testPropertyGetYear", "method_implementation": "{\n    LocalDateTime test = new LocalDateTime(1972, 6, 9, 10, 20, 30, 40);\n    assertSame(test.getChronology().year(), test.year().getField());\n    assertEquals(\"year\", test.year().getName());\n    assertEquals(\"Property[year]\", test.year().toString());\n    assertSame(test, test.year().getLocalDateTime());\n    assertEquals(1972, test.year().get());\n    assertEquals(\"1972\", test.year().getAsString());\n    assertEquals(\"1972\", test.year().getAsText());\n    assertEquals(\"1972\", test.year().getAsText(Locale.FRENCH));\n    assertEquals(\"1972\", test.year().getAsShortText());\n    assertEquals(\"1972\", test.year().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.year().getDurationField());\n    assertEquals(null, test.year().getRangeDurationField());\n    assertEquals(9, test.year().getMaximumTextLength(null));\n    assertEquals(9, test.year().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1424, "method_signature": "void testPropertyGetYear()"}, "TestLocalDate_Basics.check": {"callee_method_names": ["LocalDate.getYear", "LocalDate.getMonthOfYear", "LocalDate.getDayOfMonth"], "method_name": "TestLocalDate_Basics.check", "method_implementation": "{\n    assertEquals(hour, test.getYear());\n    assertEquals(min, test.getMonthOfYear());\n    assertEquals(sec, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1539, "method_signature": "void check(LocalDate, int, int, int)"}, "TestLocalDate_Basics.testCompareTo": {"callee_method_ids": [696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696, 696], "callee_method_names": ["LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo", "LocalDate.compareTo"], "method_name": "TestLocalDate_Basics.testCompareTo", "method_implementation": "{\n    LocalDate test1 = new LocalDate(2005, 6, 2);\n    LocalDate test1a = new LocalDate(2005, 6, 2);\n    assertEquals(0, test1.compareTo(test1a));\n    assertEquals(0, test1a.compareTo(test1));\n    assertEquals(0, test1.compareTo(test1));\n    assertEquals(0, test1a.compareTo(test1a));\n    LocalDate test2 = new LocalDate(2005, 7, 2);\n    assertEquals(-1, test1.compareTo(test2));\n    assertEquals(+1, test2.compareTo(test1));\n    LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC());\n    assertEquals(-1, test1.compareTo(test3));\n    assertEquals(+1, test3.compareTo(test1));\n    assertEquals(0, test3.compareTo(test2));\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };\n    int[] values = new int[] { 2005, 6, 2 };\n    Partial p = new Partial(types, values);\n    assertEquals(0, test1.compareTo(p));\n    assertEquals(0, test1.compareTo(new YearMonthDay(2005, 6, 2)));\n    try {\n        test1.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n    //        try {\n    //            test1.compareTo(new Date());\n    //            fail();\n    //        } catch (ClassCastException ex) {}\n    try {\n        test1.compareTo(new TimeOfDay());\n        fail();\n    } catch (ClassCastException ex) {\n    }\n    Partial partial = new Partial().with(DateTimeFieldType.centuryOfEra(), 1).with(DateTimeFieldType.halfdayOfDay(), 0).with(DateTimeFieldType.dayOfMonth(), 9);\n    try {\n        new LocalDate(1970, 6, 9).compareTo(partial);\n        fail();\n    } catch (ClassCastException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1509, "method_signature": "void testCompareTo()"}, "TestLocalDate_Basics.testGet_DateTimeFieldType": {"callee_method_ids": [691, 691, 691, 691, 691, 691, 691, 691, 691], "callee_method_names": ["LocalDate.get", "LocalDate.get", "LocalDate.get", "LocalDate.get", "LocalDate.get", "LocalDate.get", "LocalDate.get", "LocalDate.get", "LocalDate.get"], "method_name": "TestLocalDate_Basics.testGet_DateTimeFieldType", "method_implementation": "{\n    LocalDate test = new LocalDate();\n    assertEquals(1970, test.get(DateTimeFieldType.year()));\n    assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n    assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n    assertEquals(2, test.get(DateTimeFieldType.dayOfWeek()));\n    assertEquals(160, test.get(DateTimeFieldType.dayOfYear()));\n    assertEquals(24, test.get(DateTimeFieldType.weekOfWeekyear()));\n    assertEquals(1970, test.get(DateTimeFieldType.weekyear()));\n    try {\n        test.get(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.get(DateTimeFieldType.hourOfDay());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1508, "method_signature": "void testGet_DateTimeFieldType()"}, "TestLocalDate_Basics.testGetters": {"callee_method_names": ["LocalDate.getYear", "LocalDate.getMonthOfYear", "LocalDate.getDayOfMonth", "LocalDate.getDayOfYear", "LocalDate.getDayOfWeek", "LocalDate.getWeekOfWeekyear", "LocalDate.getWeekyear", "LocalDate.getYearOfCentury", "LocalDate.getCenturyOfEra", "LocalDate.getYearOfEra", "LocalDate.getEra"], "method_name": "TestLocalDate_Basics.testGetters", "method_implementation": "{\n    LocalDate test = new LocalDate(1970, 6, 9, GJ_UTC);\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(160, test.getDayOfYear());\n    assertEquals(2, test.getDayOfWeek());\n    assertEquals(24, test.getWeekOfWeekyear());\n    assertEquals(1970, test.getWeekyear());\n    assertEquals(70, test.getYearOfCentury());\n    assertEquals(20, test.getCenturyOfEra());\n    assertEquals(1970, test.getYearOfEra());\n    assertEquals(DateTimeConstants.AD, test.getEra());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1517, "method_signature": "void testGetters()"}, "TestLocalDate_Basics.testIsAfter_LocalDate": {"callee_method_names": ["LocalDate.isAfter", "LocalDate.isAfter", "LocalDate.isAfter", "LocalDate.isAfter", "LocalDate.isAfter", "LocalDate.isAfter", "LocalDate.isAfter", "LocalDate.isAfter", "LocalDate.isAfter"], "method_name": "TestLocalDate_Basics.testIsAfter_LocalDate", "method_implementation": "{\n    LocalDate test1 = new LocalDate(2005, 6, 2);\n    LocalDate test1a = new LocalDate(2005, 6, 2);\n    assertEquals(false, test1.isAfter(test1a));\n    assertEquals(false, test1a.isAfter(test1));\n    assertEquals(false, test1.isAfter(test1));\n    assertEquals(false, test1a.isAfter(test1a));\n    LocalDate test2 = new LocalDate(2005, 7, 2);\n    assertEquals(false, test1.isAfter(test2));\n    assertEquals(true, test2.isAfter(test1));\n    LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isAfter(test3));\n    assertEquals(true, test3.isAfter(test1));\n    assertEquals(false, test3.isAfter(test2));\n    try {\n        new LocalDate(2005, 7, 2).isAfter(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1512, "method_signature": "void testIsAfter_LocalDate()"}, "TestLocalDate_Basics.testIsBefore_LocalDate": {"callee_method_names": ["LocalDate.isBefore", "LocalDate.isBefore", "LocalDate.isBefore", "LocalDate.isBefore", "LocalDate.isBefore", "LocalDate.isBefore", "LocalDate.isBefore", "LocalDate.isBefore", "LocalDate.isBefore"], "method_name": "TestLocalDate_Basics.testIsBefore_LocalDate", "method_implementation": "{\n    LocalDate test1 = new LocalDate(2005, 6, 2);\n    LocalDate test1a = new LocalDate(2005, 6, 2);\n    assertEquals(false, test1.isBefore(test1a));\n    assertEquals(false, test1a.isBefore(test1));\n    assertEquals(false, test1.isBefore(test1));\n    assertEquals(false, test1a.isBefore(test1a));\n    LocalDate test2 = new LocalDate(2005, 7, 2);\n    assertEquals(true, test1.isBefore(test2));\n    assertEquals(false, test2.isBefore(test1));\n    LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC());\n    assertEquals(true, test1.isBefore(test3));\n    assertEquals(false, test3.isBefore(test1));\n    assertEquals(false, test3.isBefore(test2));\n    try {\n        new LocalDate(2005, 7, 2).isBefore(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1511, "method_signature": "void testIsBefore_LocalDate()"}, "TestLocalDate_Basics.testIsEqual_LocalDate": {"callee_method_names": ["LocalDate.isEqual", "LocalDate.isEqual", "LocalDate.isEqual", "LocalDate.isEqual", "LocalDate.isEqual", "LocalDate.isEqual", "LocalDate.isEqual", "LocalDate.isEqual", "LocalDate.isEqual"], "method_name": "TestLocalDate_Basics.testIsEqual_LocalDate", "method_implementation": "{\n    LocalDate test1 = new LocalDate(2005, 6, 2);\n    LocalDate test1a = new LocalDate(2005, 6, 2);\n    assertEquals(true, test1.isEqual(test1a));\n    assertEquals(true, test1a.isEqual(test1));\n    assertEquals(true, test1.isEqual(test1));\n    assertEquals(true, test1a.isEqual(test1a));\n    LocalDate test2 = new LocalDate(2005, 7, 2);\n    assertEquals(false, test1.isEqual(test2));\n    assertEquals(false, test2.isEqual(test1));\n    LocalDate test3 = new LocalDate(2005, 7, 2, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isEqual(test3));\n    assertEquals(false, test3.isEqual(test1));\n    assertEquals(true, test3.isEqual(test2));\n    try {\n        new LocalDate(2005, 7, 2).isEqual(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1510, "method_signature": "void testIsEqual_LocalDate()"}, "TestLocalDate_Basics.testMinus_RP": {"callee_method_names": ["LocalDate.minus", "LocalDate.minus"], "method_name": "TestLocalDate_Basics.testMinus_RP", "method_implementation": "{\n    LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n    LocalDate result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n    // TODO breaks because it subtracts millis now, and thus goes\n    // into the previous day\n    LocalDate expected = new LocalDate(2001, 3, 26, BUDDHIST_LONDON);\n    assertEquals(expected, result);\n    result = test.minus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1516, "method_signature": "void testMinus_RP()"}, "TestLocalDate_Basics.testPlus_RP": {"callee_method_names": ["LocalDate.plus", "LocalDate.plus"], "method_name": "TestLocalDate_Basics.testPlus_RP", "method_implementation": "{\n    LocalDate test = new LocalDate(2002, 5, 3, BUDDHIST_LONDON);\n    LocalDate result = test.plus(new Period(1, 2, 3, 4, 29, 6, 7, 8));\n    LocalDate expected = new LocalDate(2003, 7, 28, BUDDHIST_LONDON);\n    assertEquals(expected, result);\n    result = test.plus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1515, "method_signature": "void testPlus_RP()"}, "TestLocalDate_Basics.testProperty": {"callee_method_ids": [717, 717, 717, 717, 717, 717, 717, 717, 717, 717, 717, 717, 717], "callee_method_names": ["LocalDate.year", "LocalDate.property", "LocalDate.monthOfYear", "LocalDate.property", "LocalDate.dayOfMonth", "LocalDate.property", "LocalDate.dayOfWeek", "LocalDate.property", "LocalDate.dayOfYear", "LocalDate.property", "LocalDate.weekOfWeekyear", "LocalDate.property", "LocalDate.weekyear", "LocalDate.property", "LocalDate.yearOfCentury", "LocalDate.property", "LocalDate.yearOfEra", "LocalDate.property", "LocalDate.centuryOfEra", "LocalDate.property", "LocalDate.era", "LocalDate.property", "LocalDate.property", "LocalDate.property"], "method_name": "TestLocalDate_Basics.testProperty", "method_implementation": "{\n    LocalDate test = new LocalDate(2005, 6, 9, GJ_UTC);\n    assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n    assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));\n    assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth()));\n    assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek()));\n    assertEquals(test.dayOfYear(), test.property(DateTimeFieldType.dayOfYear()));\n    assertEquals(test.weekOfWeekyear(), test.property(DateTimeFieldType.weekOfWeekyear()));\n    assertEquals(test.weekyear(), test.property(DateTimeFieldType.weekyear()));\n    assertEquals(test.yearOfCentury(), test.property(DateTimeFieldType.yearOfCentury()));\n    assertEquals(test.yearOfEra(), test.property(DateTimeFieldType.yearOfEra()));\n    assertEquals(test.centuryOfEra(), test.property(DateTimeFieldType.centuryOfEra()));\n    assertEquals(test.era(), test.property(DateTimeFieldType.era()));\n    try {\n        test.property(DateTimeFieldType.millisOfDay());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1534, "method_signature": "void testProperty()"}, "TestLocalDate_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close", "LocalDate.getValues", "LocalDate.getValues", "LocalDate.getFields", "LocalDate.getFields", "LocalDate.getChronology", "LocalDate.getChronology"], "method_name": "TestLocalDate_Basics.testSerialization", "method_implementation": "{\n    LocalDate test = new LocalDate(1972, 6, 9, COPTIC_PARIS);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    LocalDate result = (LocalDate) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n    assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n    assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n    assertEquals(test.getChronology(), result.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1535, "method_signature": "void testSerialization()"}, "TestLocalDate_Basics.testToDateMidnight": {"callee_method_ids": [700], "callee_method_names": ["LocalDate.toDateMidnight"], "method_name": "TestLocalDate_Basics.testToDateMidnight", "method_implementation": "{\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    DateMidnight test = base.toDateMidnight();\n    check(base, 2005, 6, 9);\n    assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1528, "method_signature": "void testToDateMidnight()"}, "TestLocalDate_Basics.testToDateMidnight_Zone": {"callee_method_ids": [700], "callee_method_names": ["LocalDate.toDateMidnight"], "method_name": "TestLocalDate_Basics.testToDateMidnight_Zone", "method_implementation": "{\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    DateMidnight test = base.toDateMidnight(TOKYO);\n    check(base, 2005, 6, 9);\n    assertEquals(new DateMidnight(2005, 6, 9, COPTIC_TOKYO), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1529, "method_signature": "void testToDateMidnight_Zone()"}, "TestLocalDate_Basics.testToDateTimeAtCurrentTime": {"callee_method_ids": [699], "callee_method_names": ["DateTime.getMillis", "LocalDate.toDateTimeAtCurrentTime", "DateTime.getMillis", "DateTime.year", "DateTime.monthOfYear", "DateTime.dayOfMonth"], "method_name": "TestLocalDate_Basics.testToDateTimeAtCurrentTime", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    DateTime test = base.toDateTimeAtCurrentTime();\n    check(base, 2005, 6, 9);\n    DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n    expected = expected.year().setCopy(2005);\n    expected = expected.monthOfYear().setCopy(6);\n    expected = expected.dayOfMonth().setCopy(9);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1523, "method_signature": "void testToDateTimeAtCurrentTime()"}, "TestLocalDate_Basics.testToDateTimeAtCurrentTime_Zone": {"callee_method_ids": [699], "callee_method_names": ["DateTime.getMillis", "LocalDate.toDateTimeAtCurrentTime", "DateTime.getMillis", "DateTime.year", "DateTime.monthOfYear", "DateTime.dayOfMonth"], "method_name": "TestLocalDate_Basics.testToDateTimeAtCurrentTime_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    DateTime test = base.toDateTimeAtCurrentTime(TOKYO);\n    check(base, 2005, 6, 9);\n    DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);\n    expected = expected.year().setCopy(2005);\n    expected = expected.monthOfYear().setCopy(6);\n    expected = expected.dayOfMonth().setCopy(9);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1524, "method_signature": "void testToDateTimeAtCurrentTime_Zone()"}, "TestLocalDate_Basics.testToDateTimeAtMidnight": {"callee_method_ids": [698], "callee_method_names": ["LocalDate.toDateTimeAtMidnight"], "method_name": "TestLocalDate_Basics.testToDateTimeAtMidnight", "method_implementation": "{\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    DateTime test = base.toDateTimeAtMidnight();\n    check(base, 2005, 6, 9);\n    assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1521, "method_signature": "void testToDateTimeAtMidnight()"}, "TestLocalDate_Basics.testToDateTimeAtMidnight_Zone": {"callee_method_ids": [698], "callee_method_names": ["LocalDate.toDateTimeAtMidnight"], "method_name": "TestLocalDate_Basics.testToDateTimeAtMidnight_Zone", "method_implementation": "{\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    DateTime test = base.toDateTimeAtMidnight(TOKYO);\n    check(base, 2005, 6, 9);\n    assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1522, "method_signature": "void testToDateTimeAtMidnight_Zone()"}, "TestLocalDate_Basics.testToDateTimeAtStartOfDay": {"callee_method_ids": [697], "callee_method_names": ["LocalDate.toDateTimeAtStartOfDay"], "method_name": "TestLocalDate_Basics.testToDateTimeAtStartOfDay", "method_implementation": "{\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    DateTime test = base.toDateTimeAtStartOfDay();\n    check(base, 2005, 6, 9);\n    assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1519, "method_signature": "void testToDateTimeAtStartOfDay()"}, "TestLocalDate_Basics.testToDateTimeAtStartOfDay_Zone": {"callee_method_ids": [697], "callee_method_names": ["LocalDate.toDateTimeAtStartOfDay"], "method_name": "TestLocalDate_Basics.testToDateTimeAtStartOfDay_Zone", "method_implementation": "{\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    DateTime test = base.toDateTimeAtStartOfDay(TOKYO);\n    check(base, 2005, 6, 9);\n    assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1520, "method_signature": "void testToDateTimeAtStartOfDay_Zone()"}, "TestLocalDate_Basics.testToDateTime_LocalTime": {"callee_method_ids": [702], "callee_method_names": ["LocalDate.toDateTime"], "method_name": "TestLocalDate_Basics.testToDateTime_LocalTime", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO);\n    DateTime test = base.toDateTime(tod);\n    check(base, 2005, 6, 9);\n    DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1526, "method_signature": "void testToDateTime_LocalTime()"}, "TestLocalDate_Basics.testToDateTime_LocalTime_Zone": {"callee_method_ids": [702], "callee_method_names": ["LocalDate.toDateTime"], "method_name": "TestLocalDate_Basics.testToDateTime_LocalTime_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO);\n    DateTime test = base.toDateTime(tod, TOKYO);\n    check(base, 2005, 6, 9);\n    DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1527, "method_signature": "void testToDateTime_LocalTime_Zone()"}, "TestLocalDate_Basics.testToDateTime_RI": {"callee_method_ids": [702], "callee_method_names": ["LocalDate.toDateTime", "DateTime.year", "DateTime.monthOfYear", "DateTime.dayOfMonth"], "method_name": "TestLocalDate_Basics.testToDateTime_RI", "method_implementation": "{\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n    DateTime test = base.toDateTime(dt);\n    check(base, 2005, 6, 9);\n    DateTime expected = dt;\n    expected = expected.year().setCopy(2005);\n    expected = expected.monthOfYear().setCopy(6);\n    expected = expected.dayOfMonth().setCopy(9);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1530, "method_signature": "void testToDateTime_RI()"}, "TestLocalDate_Basics.testToDate_summer": {"callee_method_ids": [704], "callee_method_names": ["LocalDate.toDate", "GregorianCalendar.clear", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestLocalDate_Basics.testToDate_summer", "method_implementation": "{\n    LocalDate base = new LocalDate(2005, 7, 9, COPTIC_PARIS);\n    Date test = base.toDate();\n    check(base, 2005, 7, 9);\n    GregorianCalendar gcal = new GregorianCalendar();\n    gcal.clear();\n    gcal.set(Calendar.YEAR, 2005);\n    gcal.set(Calendar.MONTH, Calendar.JULY);\n    gcal.set(Calendar.DAY_OF_MONTH, 9);\n    assertEquals(gcal.getTime(), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1533, "method_signature": "void testToDate_summer()"}, "TestLocalDate_Basics.testToInterval": {"callee_method_ids": [703, 697], "callee_method_names": ["LocalDate.toInterval", "LocalDate.toDateTimeAtStartOfDay", "DateTime.plus"], "method_name": "TestLocalDate_Basics.testToInterval", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    Interval test = base.toInterval();\n    check(base, 2005, 6, 9);\n    DateTime start = base.toDateTimeAtStartOfDay();\n    DateTime end = start.plus(Period.days(1));\n    Interval expected = new Interval(start, end);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1531, "method_signature": "void testToInterval()"}, "TestLocalDate_Basics.testToInterval_Zone": {"callee_method_ids": [703, 697], "callee_method_names": ["LocalDate.toInterval", "LocalDate.toDateTimeAtStartOfDay", "DateTime.plus"], "method_name": "TestLocalDate_Basics.testToInterval_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    Interval test = base.toInterval(TOKYO);\n    check(base, 2005, 6, 9);\n    DateTime start = base.toDateTimeAtStartOfDay(TOKYO);\n    DateTime end = start.plus(Period.days(1));\n    Interval expected = new Interval(start, end);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1532, "method_signature": "void testToInterval_Zone()"}, "TestLocalDate_Basics.testToLocalDateTime_LocalTime": {"callee_method_ids": [701], "callee_method_names": ["LocalDate.toLocalDateTime"], "method_name": "TestLocalDate_Basics.testToLocalDateTime_LocalTime", "method_implementation": "{\n    // PARIS irrelevant\n    LocalDate base = new LocalDate(2005, 6, 9, COPTIC_PARIS);\n    LocalTime tod = new LocalTime(12, 13, 14, 15, COPTIC_TOKYO);\n    LocalDateTime test = base.toLocalDateTime(tod);\n    check(base, 2005, 6, 9);\n    LocalDateTime expected = new LocalDateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_UTC);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1525, "method_signature": "void testToLocalDateTime_LocalTime()"}, "TestLocalDate_Basics.testToString_DTFormatter": {"callee_method_ids": [720, 720], "callee_method_names": ["LocalDate.toString", "LocalDate.toString"], "method_name": "TestLocalDate_Basics.testToString_DTFormatter", "method_implementation": "{\n    LocalDate test = new LocalDate(2002, 6, 9);\n    assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n    assertEquals(\"2002-06-09\", test.toString((DateTimeFormatter) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1538, "method_signature": "void testToString_DTFormatter()"}, "TestLocalDate_Basics.testToString_String": {"callee_method_ids": [720, 720], "callee_method_names": ["LocalDate.toString", "LocalDate.toString"], "method_name": "TestLocalDate_Basics.testToString_String", "method_implementation": "{\n    LocalDate test = new LocalDate(2002, 6, 9);\n    assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(\"yyyy HH\"));\n    assertEquals(\"2002-06-09\", test.toString((String) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1536, "method_signature": "void testToString_String()"}, "TestLocalDate_Basics.testToString_String_Locale": {"callee_method_ids": [720, 720, 720, 720, 720], "callee_method_names": ["LocalDate.toString", "LocalDate.toString", "LocalDate.toString", "LocalDate.toString", "LocalDate.toString"], "method_name": "TestLocalDate_Basics.testToString_String_Locale", "method_implementation": "{\n    LocalDate test = new LocalDate(1970, 6, 9);\n    assertEquals(\"Tue 9/6\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n    assertEquals(\"mar. 9/6\", test.toString(\"EEE d/M\", Locale.FRENCH));\n    assertEquals(\"1970-06-09\", test.toString(null, Locale.ENGLISH));\n    assertEquals(\"Tue 9/6\", test.toString(\"EEE d/M\", null));\n    assertEquals(\"1970-06-09\", test.toString(null, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1537, "method_signature": "void testToString_String_Locale()"}, "TestLocalDate_Basics.testWithFieldAdded_DurationFieldType_int_1": {"callee_method_ids": [707], "callee_method_names": ["LocalDate.withFieldAdded"], "method_name": "TestLocalDate_Basics.testWithFieldAdded_DurationFieldType_int_1", "method_implementation": "{\n    LocalDate test = new LocalDate(2004, 6, 9);\n    LocalDate result = test.withFieldAdded(DurationFieldType.years(), 6);\n    assertEquals(new LocalDate(2004, 6, 9), test);\n    assertEquals(new LocalDate(2010, 6, 9), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1514, "method_signature": "void testWithFieldAdded_DurationFieldType_int_1()"}, "TestLocalDate_Basics.testWithField_DateTimeFieldType_int_1": {"callee_method_ids": [706], "callee_method_names": ["LocalDate.withField"], "method_name": "TestLocalDate_Basics.testWithField_DateTimeFieldType_int_1", "method_implementation": "{\n    LocalDate test = new LocalDate(2004, 6, 9);\n    LocalDate result = test.withField(DateTimeFieldType.year(), 2006);\n    assertEquals(new LocalDate(2004, 6, 9), test);\n    assertEquals(new LocalDate(2006, 6, 9), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1513, "method_signature": "void testWithField_DateTimeFieldType_int_1()"}, "TestLocalDate_Basics.testWithers": {"callee_method_names": ["LocalDate.withYear", "LocalDate.withMonthOfYear", "LocalDate.withDayOfMonth", "LocalDate.withDayOfYear", "LocalDate.withDayOfWeek", "LocalDate.withWeekOfWeekyear", "LocalDate.withWeekyear", "LocalDate.withYearOfCentury", "LocalDate.withCenturyOfEra", "LocalDate.withYearOfEra", "LocalDate.withEra", "LocalDate.withMonthOfYear", "LocalDate.withMonthOfYear"], "method_name": "TestLocalDate_Basics.testWithers", "method_implementation": "{\n    LocalDate test = new LocalDate(1970, 6, 9, GJ_UTC);\n    check(test.withYear(2000), 2000, 6, 9);\n    check(test.withMonthOfYear(2), 1970, 2, 9);\n    check(test.withDayOfMonth(2), 1970, 6, 2);\n    check(test.withDayOfYear(6), 1970, 1, 6);\n    check(test.withDayOfWeek(6), 1970, 6, 13);\n    check(test.withWeekOfWeekyear(6), 1970, 2, 3);\n    check(test.withWeekyear(1971), 1971, 6, 15);\n    check(test.withYearOfCentury(60), 1960, 6, 9);\n    check(test.withCenturyOfEra(21), 2070, 6, 9);\n    check(test.withYearOfEra(1066), 1066, 6, 9);\n    check(test.withEra(DateTimeConstants.BC), -1970, 6, 9);\n    try {\n        test.withMonthOfYear(0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.withMonthOfYear(13);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1518, "method_signature": "void testWithers()"}, "TestLocalDate_Constructors.testConstructor": {"callee_method_names": ["LocalDate.getChronology", "LocalDate.getYear", "LocalDate.getMonthOfYear", "LocalDate.getDayOfMonth"], "method_name": "TestLocalDate_Constructors.testConstructor", "method_implementation": "{\n    LocalDate test = new LocalDate();\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(test, LocalDate.now());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2587, "method_signature": "void testConstructor()"}, "TestLocalDate_Constructors.testConstructor_Object1": {"callee_method_names": ["LocalDate.getChronology", "LocalDate.getYear", "LocalDate.getMonthOfYear", "LocalDate.getDayOfMonth"], "method_name": "TestLocalDate_Constructors.testConstructor_Object1", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    LocalDate test = new LocalDate(date);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2589, "method_signature": "void testConstructor_Object1()"}, "TestLocalDate_Constructors.testConstructor_Object_DateTimeZone": {"callee_method_names": ["LocalDate.getChronology", "LocalDate.getYear", "LocalDate.getMonthOfYear", "LocalDate.getDayOfMonth"], "method_name": "TestLocalDate_Constructors.testConstructor_Object_DateTimeZone", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    LocalDate test = new LocalDate(date, PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2590, "method_signature": "void testConstructor_Object_DateTimeZone()"}, "TestLocalDate_Constructors.testConstructor_int_int_int": {"callee_method_names": ["LocalDate.getChronology", "LocalDate.getYear", "LocalDate.getMonthOfYear", "LocalDate.getDayOfMonth", "Exception.getMessage", "Exception.getMessage", "Exception.getMessage", "Exception.getMessage", "Exception.getMessage", "Exception.getMessage", "Exception.getMessage"], "method_name": "TestLocalDate_Constructors.testConstructor_int_int_int", "method_implementation": "{\n    LocalDate test = new LocalDate(1970, 6, 9);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    try {\n        new LocalDate(Integer.MIN_VALUE, 6, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertEquals(\"Value -2147483648 for year must be in the range [-292275055,292278994]\", ex.getMessage());\n    }\n    try {\n        new LocalDate(Integer.MAX_VALUE, 6, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertEquals(\"Value 2147483647 for year must be in the range [-292275055,292278994]\", ex.getMessage());\n    }\n    try {\n        new LocalDate(1970, 0, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertEquals(\"Value 0 for monthOfYear must be in the range [1,12]\", ex.getMessage());\n    }\n    try {\n        new LocalDate(1970, 13, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertEquals(\"Value 13 for monthOfYear must be in the range [1,12]\", ex.getMessage());\n    }\n    try {\n        new LocalDate(1970, 6, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertEquals(\"Value 0 for dayOfMonth must be in the range [1,30]: year: 1970 month: 6\", ex.getMessage());\n    }\n    try {\n        new LocalDate(1970, 6, 31);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertEquals(\"Value 31 for dayOfMonth must be in the range [1,30]: year: 1970 month: 6\", ex.getMessage());\n    }\n    new LocalDate(1970, 7, 31);\n    try {\n        new LocalDate(1970, 7, 32);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertEquals(\"Value 32 for dayOfMonth must be in the range [1,31]: year: 1970 month: 7\", ex.getMessage());\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2591, "method_signature": "void testConstructor_int_int_int()"}, "TestLocalDate_Constructors.testConstructor_long1": {"callee_method_names": ["LocalDate.getChronology", "LocalDate.getYear", "LocalDate.getMonthOfYear", "LocalDate.getDayOfMonth"], "method_name": "TestLocalDate_Constructors.testConstructor_long1", "method_implementation": "{\n    LocalDate test = new LocalDate(TEST_TIME1);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2588, "method_signature": "void testConstructor_long1()"}, "TestLocalDate_Constructors.testFactory_fromCalendarFields": {"callee_method_names": ["GregorianCalendar.set"], "method_name": "TestLocalDate_Constructors.testFactory_fromCalendarFields", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    LocalDate expected = new LocalDate(1970, 2, 3);\n    assertEquals(expected, LocalDate.fromCalendarFields(cal));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2585, "method_signature": "void testFactory_fromCalendarFields()"}, "TestLocalDate_Constructors.testFactory_fromDateFields_after1970": {"callee_method_names": ["GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestLocalDate_Constructors.testFactory_fromDateFields_after1970", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    LocalDate expected = new LocalDate(1970, 2, 3);\n    assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2586, "method_signature": "void testFactory_fromDateFields_after1970()"}, "TestLocalDate_Properties.check": {"callee_method_names": ["LocalDate.getYear", "LocalDate.getMonthOfYear", "LocalDate.getDayOfMonth"], "method_name": "TestLocalDate_Properties.check", "method_implementation": "{\n    assertEquals(year, test.getYear());\n    assertEquals(month, test.getMonthOfYear());\n    assertEquals(day, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1507, "method_signature": "void check(LocalDate, int, int, int)"}, "TestLocalDate_Properties.testPropertyGetDay": {"callee_method_names": ["LocalDate.getChronology", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.getChronology", "LocalDate.dayOfMonth", "LocalDate.getChronology", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth", "LocalDate.dayOfMonth"], "method_name": "TestLocalDate_Properties.testPropertyGetDay", "method_implementation": "{\n    LocalDate test = new LocalDate(1972, 6, 9);\n    assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n    assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n    assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n    assertSame(test, test.dayOfMonth().getLocalDate());\n    assertEquals(9, test.dayOfMonth().get());\n    assertEquals(\"9\", test.dayOfMonth().getAsString());\n    assertEquals(\"9\", test.dayOfMonth().getAsText());\n    assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText());\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n    assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n    assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n    assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1506, "method_signature": "void testPropertyGetDay()"}, "TestLocalDate_Properties.testPropertyGetMonth": {"callee_method_names": ["LocalDate.getChronology", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.getChronology", "LocalDate.monthOfYear", "LocalDate.getChronology", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear", "LocalDate.monthOfYear"], "method_name": "TestLocalDate_Properties.testPropertyGetMonth", "method_implementation": "{\n    LocalDate test = new LocalDate(1972, 6, 9);\n    assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n    assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n    assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n    assertSame(test, test.monthOfYear().getLocalDate());\n    assertEquals(6, test.monthOfYear().get());\n    assertEquals(\"6\", test.monthOfYear().getAsString());\n    assertEquals(\"June\", test.monthOfYear().getAsText());\n    assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n    assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n    assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n    assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));\n    test = new LocalDate(1972, 7, 9);\n    assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1505, "method_signature": "void testPropertyGetMonth()"}, "TestLocalDate_Properties.testPropertyGetYear": {"callee_method_names": ["LocalDate.getChronology", "LocalDate.year", "LocalDate.year", "LocalDate.year", "LocalDate.year", "LocalDate.year", "LocalDate.year", "LocalDate.year", "LocalDate.year", "LocalDate.year", "LocalDate.year", "LocalDate.getChronology", "LocalDate.year", "LocalDate.year", "LocalDate.year", "LocalDate.year"], "method_name": "TestLocalDate_Properties.testPropertyGetYear", "method_implementation": "{\n    LocalDate test = new LocalDate(1972, 6, 9);\n    assertSame(test.getChronology().year(), test.year().getField());\n    assertEquals(\"year\", test.year().getName());\n    assertEquals(\"Property[year]\", test.year().toString());\n    assertSame(test, test.year().getLocalDate());\n    assertEquals(1972, test.year().get());\n    assertEquals(\"1972\", test.year().getAsString());\n    assertEquals(\"1972\", test.year().getAsText());\n    assertEquals(\"1972\", test.year().getAsText(Locale.FRENCH));\n    assertEquals(\"1972\", test.year().getAsShortText());\n    assertEquals(\"1972\", test.year().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.year().getDurationField());\n    assertEquals(null, test.year().getRangeDurationField());\n    assertEquals(9, test.year().getMaximumTextLength(null));\n    assertEquals(9, test.year().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1504, "method_signature": "void testPropertyGetYear()"}, "TestLocalTime_Basics.check": {"callee_method_names": ["LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Basics.check", "method_implementation": "{\n    assertEquals(hour, test.getHourOfDay());\n    assertEquals(min, test.getMinuteOfHour());\n    assertEquals(sec, test.getSecondOfMinute());\n    assertEquals(milli, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2059, "method_signature": "void check(LocalTime, int, int, int, int)"}, "TestLocalTime_Basics.testCompareTo": {"callee_method_ids": [1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034], "callee_method_names": ["LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo", "LocalTime.compareTo"], "method_name": "TestLocalTime_Basics.testCompareTo", "method_implementation": "{\n    LocalTime test1 = new LocalTime(10, 20, 30, 40);\n    LocalTime test1a = new LocalTime(10, 20, 30, 40);\n    assertEquals(0, test1.compareTo(test1a));\n    assertEquals(0, test1a.compareTo(test1));\n    assertEquals(0, test1.compareTo(test1));\n    assertEquals(0, test1a.compareTo(test1a));\n    LocalTime test2 = new LocalTime(10, 20, 35, 40);\n    assertEquals(-1, test1.compareTo(test2));\n    assertEquals(+1, test2.compareTo(test1));\n    LocalTime test3 = new LocalTime(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n    assertEquals(-1, test1.compareTo(test3));\n    assertEquals(+1, test3.compareTo(test1));\n    assertEquals(0, test3.compareTo(test2));\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 10, 20, 30, 40 };\n    Partial p = new Partial(types, values);\n    assertEquals(0, test1.compareTo(p));\n    assertEquals(0, test1.compareTo(new TimeOfDay(10, 20, 30, 40)));\n    try {\n        test1.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n    //        try {\n    //            test1.compareTo(new Date());\n    //            fail();\n    //        } catch (ClassCastException ex) {}\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2041, "method_signature": "void testCompareTo()"}, "TestLocalTime_Basics.testGet_DateTimeFieldType": {"callee_method_ids": [1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030, 1030], "callee_method_names": ["LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get", "LocalTime.get"], "method_name": "TestLocalTime_Basics.testGet_DateTimeFieldType", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertEquals(10, test.get(DateTimeFieldType.hourOfDay()));\n    assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));\n    assertEquals(30, test.get(DateTimeFieldType.secondOfMinute()));\n    assertEquals(40, test.get(DateTimeFieldType.millisOfSecond()));\n    assertEquals(TEST_TIME_NOW / 60000, test.get(DateTimeFieldType.minuteOfDay()));\n    assertEquals(TEST_TIME_NOW / 1000, test.get(DateTimeFieldType.secondOfDay()));\n    assertEquals(TEST_TIME_NOW, test.get(DateTimeFieldType.millisOfDay()));\n    assertEquals(10, test.get(DateTimeFieldType.hourOfHalfday()));\n    assertEquals(DateTimeConstants.AM, test.get(DateTimeFieldType.halfdayOfDay()));\n    test = new LocalTime(12, 30);\n    assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday()));\n    assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday()));\n    assertEquals(12, test.get(DateTimeFieldType.clockhourOfDay()));\n    assertEquals(DateTimeConstants.PM, test.get(DateTimeFieldType.halfdayOfDay()));\n    test = new LocalTime(14, 30);\n    assertEquals(2, test.get(DateTimeFieldType.hourOfHalfday()));\n    assertEquals(2, test.get(DateTimeFieldType.clockhourOfHalfday()));\n    assertEquals(14, test.get(DateTimeFieldType.clockhourOfDay()));\n    assertEquals(DateTimeConstants.PM, test.get(DateTimeFieldType.halfdayOfDay()));\n    test = new LocalTime(0, 30);\n    assertEquals(0, test.get(DateTimeFieldType.hourOfHalfday()));\n    assertEquals(12, test.get(DateTimeFieldType.clockhourOfHalfday()));\n    assertEquals(24, test.get(DateTimeFieldType.clockhourOfDay()));\n    assertEquals(DateTimeConstants.AM, test.get(DateTimeFieldType.halfdayOfDay()));\n    try {\n        test.get(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.get(DateTimeFieldType.dayOfMonth());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2040, "method_signature": "void testGet_DateTimeFieldType()"}, "TestLocalTime_Basics.testGetters": {"callee_method_names": ["LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond", "LocalTime.getMillisOfDay"], "method_name": "TestLocalTime_Basics.testGetters", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    assertEquals(TEST_TIME_NOW, test.getMillisOfDay());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2049, "method_signature": "void testGetters()"}, "TestLocalTime_Basics.testIsAfter_LocalTime": {"callee_method_names": ["LocalTime.isAfter", "LocalTime.isAfter", "LocalTime.isAfter", "LocalTime.isAfter", "LocalTime.isAfter", "LocalTime.isAfter", "LocalTime.isAfter", "LocalTime.isAfter", "LocalTime.isAfter"], "method_name": "TestLocalTime_Basics.testIsAfter_LocalTime", "method_implementation": "{\n    LocalTime test1 = new LocalTime(10, 20, 30, 40);\n    LocalTime test1a = new LocalTime(10, 20, 30, 40);\n    assertEquals(false, test1.isAfter(test1a));\n    assertEquals(false, test1a.isAfter(test1));\n    assertEquals(false, test1.isAfter(test1));\n    assertEquals(false, test1a.isAfter(test1a));\n    LocalTime test2 = new LocalTime(10, 20, 35, 40);\n    assertEquals(false, test1.isAfter(test2));\n    assertEquals(true, test2.isAfter(test1));\n    LocalTime test3 = new LocalTime(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isAfter(test3));\n    assertEquals(true, test3.isAfter(test1));\n    assertEquals(false, test3.isAfter(test2));\n    try {\n        new LocalTime(10, 20, 35, 40).isAfter(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2044, "method_signature": "void testIsAfter_LocalTime()"}, "TestLocalTime_Basics.testIsBefore_LocalTime": {"callee_method_names": ["LocalTime.isBefore", "LocalTime.isBefore", "LocalTime.isBefore", "LocalTime.isBefore", "LocalTime.isBefore", "LocalTime.isBefore", "LocalTime.isBefore", "LocalTime.isBefore", "LocalTime.isBefore"], "method_name": "TestLocalTime_Basics.testIsBefore_LocalTime", "method_implementation": "{\n    LocalTime test1 = new LocalTime(10, 20, 30, 40);\n    LocalTime test1a = new LocalTime(10, 20, 30, 40);\n    assertEquals(false, test1.isBefore(test1a));\n    assertEquals(false, test1a.isBefore(test1));\n    assertEquals(false, test1.isBefore(test1));\n    assertEquals(false, test1a.isBefore(test1a));\n    LocalTime test2 = new LocalTime(10, 20, 35, 40);\n    assertEquals(true, test1.isBefore(test2));\n    assertEquals(false, test2.isBefore(test1));\n    LocalTime test3 = new LocalTime(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n    assertEquals(true, test1.isBefore(test3));\n    assertEquals(false, test3.isBefore(test1));\n    assertEquals(false, test3.isBefore(test2));\n    try {\n        new LocalTime(10, 20, 35, 40).isBefore(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2043, "method_signature": "void testIsBefore_LocalTime()"}, "TestLocalTime_Basics.testIsEqual_LocalTime": {"callee_method_names": ["LocalTime.isEqual", "LocalTime.isEqual", "LocalTime.isEqual", "LocalTime.isEqual", "LocalTime.isEqual", "LocalTime.isEqual", "LocalTime.isEqual", "LocalTime.isEqual", "LocalTime.isEqual"], "method_name": "TestLocalTime_Basics.testIsEqual_LocalTime", "method_implementation": "{\n    LocalTime test1 = new LocalTime(10, 20, 30, 40);\n    LocalTime test1a = new LocalTime(10, 20, 30, 40);\n    assertEquals(true, test1.isEqual(test1a));\n    assertEquals(true, test1a.isEqual(test1));\n    assertEquals(true, test1.isEqual(test1));\n    assertEquals(true, test1a.isEqual(test1a));\n    LocalTime test2 = new LocalTime(10, 20, 35, 40);\n    assertEquals(false, test1.isEqual(test2));\n    assertEquals(false, test2.isEqual(test1));\n    LocalTime test3 = new LocalTime(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isEqual(test3));\n    assertEquals(false, test3.isEqual(test1));\n    assertEquals(true, test3.isEqual(test2));\n    try {\n        new LocalTime(10, 20, 35, 40).isEqual(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2042, "method_signature": "void testIsEqual_LocalTime()"}, "TestLocalTime_Basics.testMinus_RP": {"callee_method_names": ["LocalTime.minus", "LocalTime.minus"], "method_name": "TestLocalTime_Basics.testMinus_RP", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40, BUDDHIST_LONDON);\n    LocalTime result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n    LocalTime expected = new LocalTime(9, 19, 29, 39, BUDDHIST_LONDON);\n    assertEquals(expected, result);\n    result = test.minus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2048, "method_signature": "void testMinus_RP()"}, "TestLocalTime_Basics.testPlus_RP": {"callee_method_names": ["LocalTime.plus", "LocalTime.plus"], "method_name": "TestLocalTime_Basics.testPlus_RP", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40, BUDDHIST_LONDON);\n    LocalTime result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n    LocalTime expected = new LocalTime(15, 26, 37, 48, BUDDHIST_LONDON);\n    assertEquals(expected, result);\n    result = test.plus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2047, "method_signature": "void testPlus_RP()"}, "TestLocalTime_Basics.testProperty": {"callee_method_ids": [1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047, 1047], "callee_method_names": ["LocalTime.hourOfDay", "LocalTime.property", "LocalTime.minuteOfHour", "LocalTime.property", "LocalTime.secondOfMinute", "LocalTime.property", "LocalTime.millisOfSecond", "LocalTime.property", "LocalTime.millisOfDay", "LocalTime.property", "LocalTime.property", "LocalTime.property", "LocalTime.property", "LocalTime.property", "LocalTime.property", "LocalTime.property", "LocalTime.property", "LocalTime.property", "LocalTime.property"], "method_name": "TestLocalTime_Basics.testProperty", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertEquals(test.hourOfDay(), test.property(DateTimeFieldType.hourOfDay()));\n    assertEquals(test.minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour()));\n    assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute()));\n    assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond()));\n    assertEquals(test.millisOfDay(), test.property(DateTimeFieldType.millisOfDay()));\n    assertEquals(test, test.property(DateTimeFieldType.minuteOfDay()).getLocalTime());\n    assertEquals(test, test.property(DateTimeFieldType.secondOfDay()).getLocalTime());\n    assertEquals(test, test.property(DateTimeFieldType.millisOfDay()).getLocalTime());\n    assertEquals(test, test.property(DateTimeFieldType.hourOfHalfday()).getLocalTime());\n    assertEquals(test, test.property(DateTimeFieldType.halfdayOfDay()).getLocalTime());\n    assertEquals(test, test.property(DateTimeFieldType.clockhourOfHalfday()).getLocalTime());\n    assertEquals(test, test.property(DateTimeFieldType.clockhourOfDay()).getLocalTime());\n    try {\n        test.property(DateTimeFieldType.dayOfWeek());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2054, "method_signature": "void testProperty()"}, "TestLocalTime_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close", "LocalTime.getValues", "LocalTime.getValues", "LocalTime.getFields", "LocalTime.getFields", "LocalTime.getChronology", "LocalTime.getChronology"], "method_name": "TestLocalTime_Basics.testSerialization", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40, COPTIC_PARIS);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    LocalTime result = (LocalTime) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n    assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n    assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n    assertEquals(test.getChronology(), result.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2055, "method_signature": "void testSerialization()"}, "TestLocalTime_Basics.testToDateTimeTodayDefaultZone": {"callee_method_ids": [1048], "callee_method_names": ["DateTime.getMillis", "LocalTime.toDateTimeToday", "DateTime.getMillis", "DateTime.hourOfDay", "DateTime.minuteOfHour", "DateTime.secondOfMinute", "DateTime.millisOfSecond"], "method_name": "TestLocalTime_Basics.testToDateTimeTodayDefaultZone", "method_implementation": "{\n    // PARIS irrelevant\n    LocalTime base = new LocalTime(10, 20, 30, 40, COPTIC_PARIS);\n    DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    DateTime test = base.toDateTimeToday();\n    check(base, 10, 20, 30, 40);\n    DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n    expected = expected.hourOfDay().setCopy(10);\n    expected = expected.minuteOfHour().setCopy(20);\n    expected = expected.secondOfMinute().setCopy(30);\n    expected = expected.millisOfSecond().setCopy(40);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2051, "method_signature": "void testToDateTimeTodayDefaultZone()"}, "TestLocalTime_Basics.testToDateTimeToday_Zone": {"callee_method_ids": [1048], "callee_method_names": ["DateTime.getMillis", "LocalTime.toDateTimeToday", "DateTime.getMillis", "DateTime.hourOfDay", "DateTime.minuteOfHour", "DateTime.secondOfMinute", "DateTime.millisOfSecond"], "method_name": "TestLocalTime_Basics.testToDateTimeToday_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    LocalTime base = new LocalTime(10, 20, 30, 40, COPTIC_PARIS);\n    DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    DateTime test = base.toDateTimeToday(TOKYO);\n    check(base, 10, 20, 30, 40);\n    DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);\n    expected = expected.hourOfDay().setCopy(10);\n    expected = expected.minuteOfHour().setCopy(20);\n    expected = expected.secondOfMinute().setCopy(30);\n    expected = expected.millisOfSecond().setCopy(40);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2052, "method_signature": "void testToDateTimeToday_Zone()"}, "TestLocalTime_Basics.testToDateTime_RI": {"callee_method_names": ["DateTime.toString", "LocalTime.toDateTime", "DateTime.toString", "DateTime.toString"], "method_name": "TestLocalTime_Basics.testToDateTime_RI", "method_implementation": "{\n    LocalTime base = new LocalTime(10, 20, 30, 40, COPTIC_PARIS);\n    // LONDON zone\n    DateTime dt = new DateTime(0L);\n    assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n    DateTime test = base.toDateTime(dt);\n    check(base, 10, 20, 30, 40);\n    assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n    assertEquals(\"1970-01-01T10:20:30.040+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2053, "method_signature": "void testToDateTime_RI()"}, "TestLocalTime_Basics.testToString_DTFormatter": {"callee_method_ids": [1051, 1051], "callee_method_names": ["LocalTime.toString", "LocalTime.toString"], "method_name": "TestLocalTime_Basics.testToString_DTFormatter", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertEquals(\"\\ufffd\\ufffd\\ufffd\\ufffd 10\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n    assertEquals(\"10:20:30.040\", test.toString((DateTimeFormatter) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2058, "method_signature": "void testToString_DTFormatter()"}, "TestLocalTime_Basics.testToString_String": {"callee_method_ids": [1051, 1051], "callee_method_names": ["LocalTime.toString", "LocalTime.toString"], "method_name": "TestLocalTime_Basics.testToString_String", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertEquals(\"\\ufffd\\ufffd\\ufffd\\ufffd 10\", test.toString(\"yyyy HH\"));\n    assertEquals(\"10:20:30.040\", test.toString((String) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2056, "method_signature": "void testToString_String()"}, "TestLocalTime_Basics.testToString_String_Locale": {"callee_method_ids": [1051, 1051, 1051, 1051], "callee_method_names": ["LocalTime.toString", "LocalTime.toString", "LocalTime.toString", "LocalTime.toString"], "method_name": "TestLocalTime_Basics.testToString_String_Locale", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertEquals(\"10 20\", test.toString(\"H m\", Locale.ENGLISH));\n    assertEquals(\"10:20:30.040\", test.toString(null, Locale.ENGLISH));\n    assertEquals(\"10 20\", test.toString(\"H m\", null));\n    assertEquals(\"10:20:30.040\", test.toString(null, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2057, "method_signature": "void testToString_String_Locale()"}, "TestLocalTime_Basics.testWithFieldAdded_DurationFieldType_int_1": {"callee_method_ids": [1037], "callee_method_names": ["LocalTime.withFieldAdded"], "method_name": "TestLocalTime_Basics.testWithFieldAdded_DurationFieldType_int_1", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    LocalTime result = test.withFieldAdded(DurationFieldType.hours(), 6);\n    assertEquals(new LocalTime(10, 20, 30, 40), test);\n    assertEquals(new LocalTime(16, 20, 30, 40), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2046, "method_signature": "void testWithFieldAdded_DurationFieldType_int_1()"}, "TestLocalTime_Basics.testWithField_DateTimeFieldType_int_1": {"callee_method_ids": [1036], "callee_method_names": ["LocalTime.withField"], "method_name": "TestLocalTime_Basics.testWithField_DateTimeFieldType_int_1", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    LocalTime result = test.withField(DateTimeFieldType.hourOfDay(), 15);\n    assertEquals(new LocalTime(10, 20, 30, 40), test);\n    assertEquals(new LocalTime(15, 20, 30, 40), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2045, "method_signature": "void testWithField_DateTimeFieldType_int_1()"}, "TestLocalTime_Basics.testWithers": {"callee_method_names": ["LocalTime.withHourOfDay", "LocalTime.withMinuteOfHour", "LocalTime.withSecondOfMinute", "LocalTime.withMillisOfSecond", "LocalTime.withMillisOfDay", "LocalTime.withHourOfDay", "LocalTime.withHourOfDay"], "method_name": "TestLocalTime_Basics.testWithers", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    check(test.withHourOfDay(6), 6, 20, 30, 40);\n    check(test.withMinuteOfHour(6), 10, 6, 30, 40);\n    check(test.withSecondOfMinute(6), 10, 20, 6, 40);\n    check(test.withMillisOfSecond(6), 10, 20, 30, 6);\n    check(test.withMillisOfDay(61234), 0, 1, 1, 234);\n    try {\n        test.withHourOfDay(-1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.withHourOfDay(24);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2050, "method_signature": "void testWithers()"}, "TestLocalTime_Constructors.testConstantMidnight": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstantMidnight", "method_implementation": "{\n    LocalTime test = LocalTime.MIDNIGHT;\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(0, test.getHourOfDay());\n    assertEquals(0, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1816, "method_signature": "void testConstantMidnight()"}, "TestLocalTime_Constructors.testConstructor": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor", "method_implementation": "{\n    LocalTime test = new LocalTime();\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10 + OFFSET_LONDON, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    assertEquals(test, LocalTime.now());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1821, "method_signature": "void testConstructor()"}, "TestLocalTime_Constructors.testConstructor_Chronology": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor_Chronology", "method_implementation": "{\n    LocalTime test = new LocalTime(JULIAN_LONDON);\n    assertEquals(JULIAN_UTC, test.getChronology());\n    assertEquals(10 + OFFSET_LONDON, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    assertEquals(test, LocalTime.now(JULIAN_LONDON));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1823, "method_signature": "void testConstructor_Chronology()"}, "TestLocalTime_Constructors.testConstructor_DateTimeZone": {"callee_method_names": ["DateTime.getMillis", "LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond", "LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor_DateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    LocalTime test = new LocalTime(LONDON);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(23, test.getHourOfDay());\n    assertEquals(59, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    assertEquals(test, LocalTime.now(LONDON));\n    test = new LocalTime(PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(0, test.getHourOfDay());\n    assertEquals(59, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    assertEquals(test, LocalTime.now(PARIS));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1822, "method_signature": "void testConstructor_DateTimeZone()"}, "TestLocalTime_Constructors.testConstructor_Object1": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor_Object1", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    LocalTime test = new LocalTime(date);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1 + OFFSET_LONDON, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1827, "method_signature": "void testConstructor_Object1()"}, "TestLocalTime_Constructors.testConstructor_Object1_Chronology": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor_Object1_Chronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    LocalTime test = new LocalTime(date, JULIAN_LONDON);\n    assertEquals(JULIAN_UTC, test.getChronology());\n    assertEquals(1 + OFFSET_LONDON, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1829, "method_signature": "void testConstructor_Object1_Chronology()"}, "TestLocalTime_Constructors.testConstructor_Object1_DateTimeZone": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor_Object1_DateTimeZone", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    LocalTime test = new LocalTime(date, PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1 + OFFSET_PARIS, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1828, "method_signature": "void testConstructor_Object1_DateTimeZone()"}, "TestLocalTime_Constructors.testConstructor_int_int": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor_int_int", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n    try {\n        new LocalTime(-1, 20);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new LocalTime(24, 20);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new LocalTime(10, -1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new LocalTime(10, 60);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1830, "method_signature": "void testConstructor_int_int()"}, "TestLocalTime_Constructors.testConstructor_long1": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor_long1", "method_implementation": "{\n    LocalTime test = new LocalTime(TEST_TIME1);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1 + OFFSET_LONDON, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1824, "method_signature": "void testConstructor_long1()"}, "TestLocalTime_Constructors.testConstructor_long1_Chronology": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor_long1_Chronology", "method_implementation": "{\n    LocalTime test = new LocalTime(TEST_TIME1, JULIAN_PARIS);\n    assertEquals(JULIAN_UTC, test.getChronology());\n    assertEquals(1 + OFFSET_PARIS, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1826, "method_signature": "void testConstructor_long1_Chronology()"}, "TestLocalTime_Constructors.testConstructor_long_DateTimeZone": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testConstructor_long_DateTimeZone", "method_implementation": "{\n    LocalTime test = new LocalTime(TEST_TIME1, PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1 + OFFSET_PARIS, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1825, "method_signature": "void testConstructor_long_DateTimeZone()"}, "TestLocalTime_Constructors.testFactoryMillisOfDay_long": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testFactoryMillisOfDay_long", "method_implementation": "{\n    LocalTime test = LocalTime.fromMillisOfDay(TEST_TIME1);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1819, "method_signature": "void testFactoryMillisOfDay_long()"}, "TestLocalTime_Constructors.testFactoryMillisOfDay_long_Chronology": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Constructors.testFactoryMillisOfDay_long_Chronology", "method_implementation": "{\n    LocalTime test = LocalTime.fromMillisOfDay(TEST_TIME1, JULIAN_LONDON);\n    assertEquals(JULIAN_UTC, test.getChronology());\n    assertEquals(1, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1820, "method_signature": "void testFactoryMillisOfDay_long_Chronology()"}, "TestLocalTime_Constructors.testFactory_FromCalendarFields_Calendar": {"callee_method_names": ["GregorianCalendar.set"], "method_name": "TestLocalTime_Constructors.testFactory_FromCalendarFields_Calendar", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    LocalTime expected = new LocalTime(4, 5, 6, 7);\n    assertEquals(expected, LocalTime.fromCalendarFields(cal));\n    try {\n        LocalTime.fromCalendarFields((Calendar) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1817, "method_signature": "void testFactory_FromCalendarFields_Calendar()"}, "TestLocalTime_Constructors.testFactory_FromDateFields_after1970": {"callee_method_names": ["GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestLocalTime_Constructors.testFactory_FromDateFields_after1970", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    LocalTime expected = new LocalTime(4, 5, 6, 7);\n    assertEquals(expected, LocalTime.fromDateFields(cal.getTime()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1818, "method_signature": "void testFactory_FromDateFields_after1970()"}, "TestLocalTime_Properties.check": {"callee_method_names": ["LocalTime.getHourOfDay", "LocalTime.getMinuteOfHour", "LocalTime.getSecondOfMinute", "LocalTime.getMillisOfSecond"], "method_name": "TestLocalTime_Properties.check", "method_implementation": "{\n    assertEquals(hour, test.getHourOfDay());\n    assertEquals(min, test.getMinuteOfHour());\n    assertEquals(sec, test.getSecondOfMinute());\n    assertEquals(milli, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1847, "method_signature": "void check(LocalTime, int, int, int, int)"}, "TestLocalTime_Properties.testPropertyGetHour": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.getChronology", "LocalTime.hourOfDay", "LocalTime.getChronology", "LocalTime.hourOfDay", "LocalTime.hourOfDay", "LocalTime.hourOfDay"], "method_name": "TestLocalTime_Properties.testPropertyGetHour", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n    assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n    assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n    assertSame(test, test.hourOfDay().getLocalTime());\n    assertEquals(10, test.hourOfDay().get());\n    assertEquals(\"10\", test.hourOfDay().getAsString());\n    assertEquals(\"10\", test.hourOfDay().getAsText());\n    assertEquals(\"10\", test.hourOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"10\", test.hourOfDay().getAsShortText());\n    assertEquals(\"10\", test.hourOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());\n    assertEquals(2, test.hourOfDay().getMaximumTextLength(null));\n    assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1843, "method_signature": "void testPropertyGetHour()"}, "TestLocalTime_Properties.testPropertyGetMilli": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.getChronology", "LocalTime.millisOfSecond", "LocalTime.getChronology", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond", "LocalTime.millisOfSecond"], "method_name": "TestLocalTime_Properties.testPropertyGetMilli", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n    assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n    assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n    assertSame(test, test.millisOfSecond().getLocalTime());\n    assertEquals(40, test.millisOfSecond().get());\n    assertEquals(\"40\", test.millisOfSecond().getAsString());\n    assertEquals(\"40\", test.millisOfSecond().getAsText());\n    assertEquals(\"40\", test.millisOfSecond().getAsText(Locale.FRENCH));\n    assertEquals(\"40\", test.millisOfSecond().getAsShortText());\n    assertEquals(\"40\", test.millisOfSecond().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());\n    assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());\n    assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));\n    assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1846, "method_signature": "void testPropertyGetMilli()"}, "TestLocalTime_Properties.testPropertyGetMinute": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.getChronology", "LocalTime.minuteOfHour", "LocalTime.getChronology", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour", "LocalTime.minuteOfHour"], "method_name": "TestLocalTime_Properties.testPropertyGetMinute", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n    assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n    assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n    assertSame(test, test.minuteOfHour().getLocalTime());\n    assertEquals(20, test.minuteOfHour().get());\n    assertEquals(\"20\", test.minuteOfHour().getAsString());\n    assertEquals(\"20\", test.minuteOfHour().getAsText());\n    assertEquals(\"20\", test.minuteOfHour().getAsText(Locale.FRENCH));\n    assertEquals(\"20\", test.minuteOfHour().getAsShortText());\n    assertEquals(\"20\", test.minuteOfHour().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());\n    assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());\n    assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));\n    assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1844, "method_signature": "void testPropertyGetMinute()"}, "TestLocalTime_Properties.testPropertyGetSecond": {"callee_method_names": ["LocalTime.getChronology", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.getChronology", "LocalTime.secondOfMinute", "LocalTime.getChronology", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute", "LocalTime.secondOfMinute"], "method_name": "TestLocalTime_Properties.testPropertyGetSecond", "method_implementation": "{\n    LocalTime test = new LocalTime(10, 20, 30, 40);\n    assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n    assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n    assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n    assertSame(test, test.secondOfMinute().getLocalTime());\n    assertEquals(30, test.secondOfMinute().get());\n    assertEquals(\"30\", test.secondOfMinute().getAsString());\n    assertEquals(\"30\", test.secondOfMinute().getAsText());\n    assertEquals(\"30\", test.secondOfMinute().getAsText(Locale.FRENCH));\n    assertEquals(\"30\", test.secondOfMinute().getAsShortText());\n    assertEquals(\"30\", test.secondOfMinute().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());\n    assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());\n    assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));\n    assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1845, "method_signature": "void testPropertyGetSecond()"}, "TestLongConverter.testGetPartialValues": {"callee_method_names": [], "method_name": "TestLongConverter.testGetPartialValues", "method_implementation": "{\n    TimeOfDay tod = new TimeOfDay();\n    int[] expected = ISOChronology.getInstance().get(tod, 12345678L);\n    int[] actual = LongConverter.INSTANCE.getPartialValues(tod, new Long(12345678L), ISOChronology.getInstance());\n    assertEquals(true, Arrays.equals(expected, actual));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2070, "method_signature": "void testGetPartialValues()"}, "TestLongConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestLongConverter.testSingleton", "method_implementation": "{\n    Class cls = LongConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2069, "method_signature": "void testSingleton()"}, "TestMillisDurationField.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestMillisDurationField.testSerialization", "method_implementation": "{\n    DurationField test = MillisDurationField.INSTANCE;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    DurationField result = (DurationField) ois.readObject();\n    ois.close();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1156, "method_signature": "void testSerialization()"}, "TestMillisDurationField.test_add_long_int": {"callee_method_names": [], "method_name": "TestMillisDurationField.test_add_long_int", "method_implementation": "{\n    assertEquals(567L, MillisDurationField.INSTANCE.add(567L, 0));\n    assertEquals(567L + 1234L, MillisDurationField.INSTANCE.add(567L, 1234));\n    assertEquals(567L - 1234L, MillisDurationField.INSTANCE.add(567L, -1234));\n    try {\n        MillisDurationField.INSTANCE.add(Long.MAX_VALUE, 1);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1153, "method_signature": "void test_add_long_int()"}, "TestMillisDurationField.test_compareTo": {"callee_method_names": [], "method_name": "TestMillisDurationField.test_compareTo", "method_implementation": "{\n    assertEquals(0, MillisDurationField.INSTANCE.compareTo(MillisDurationField.INSTANCE));\n    assertEquals(-1, MillisDurationField.INSTANCE.compareTo(ISOChronology.getInstance().seconds()));\n    DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0);\n    assertEquals(1, MillisDurationField.INSTANCE.compareTo(dummy));\n    //        try {\n    //            MillisDurationField.INSTANCE.compareTo(\"\");\n    //            fail();\n    //        } catch (ClassCastException ex) {}\n    try {\n        MillisDurationField.INSTANCE.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1155, "method_signature": "void test_compareTo()"}, "TestMillisDurationField.test_getDifference_long_int": {"callee_method_names": [], "method_name": "TestMillisDurationField.test_getDifference_long_int", "method_implementation": "{\n    assertEquals(567, MillisDurationField.INSTANCE.getDifference(567L, 0L));\n    assertEquals(567 - 1234, MillisDurationField.INSTANCE.getDifference(567L, 1234L));\n    assertEquals(567 + 1234, MillisDurationField.INSTANCE.getDifference(567L, -1234L));\n    try {\n        MillisDurationField.INSTANCE.getDifference(Long.MAX_VALUE, 1L);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1154, "method_signature": "void test_getDifference_long_int()"}, "TestMillisDurationField.test_getMillis_int": {"callee_method_names": [], "method_name": "TestMillisDurationField.test_getMillis_int", "method_implementation": "{\n    assertEquals(0, MillisDurationField.INSTANCE.getMillis(0));\n    assertEquals(1234, MillisDurationField.INSTANCE.getMillis(1234));\n    assertEquals(-1234, MillisDurationField.INSTANCE.getMillis(-1234));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1152, "method_signature": "void test_getMillis_int()"}, "TestMillisDurationField.test_getValue_long": {"callee_method_names": [], "method_name": "TestMillisDurationField.test_getValue_long", "method_implementation": "{\n    assertEquals(0, MillisDurationField.INSTANCE.getValue(0L));\n    assertEquals(1234, MillisDurationField.INSTANCE.getValue(1234L));\n    assertEquals(-1234, MillisDurationField.INSTANCE.getValue(-1234L));\n    try {\n        MillisDurationField.INSTANCE.getValue(((long) (Integer.MAX_VALUE)) + 1L);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1151, "method_signature": "void test_getValue_long()"}, "TestMinMaxLong.testDateTime_max": {"callee_method_names": ["DateTime.getMillis", "DateTime.getChronology", "DateTime.getMillis", "DateTime.getChronology"], "method_name": "TestMinMaxLong.testDateTime_max", "method_implementation": "{\n    // toString adjusts to UTC rather than overflow\n    DateTime dt = new DateTime(ACTUAL_MAX_YEAR, 8, 17, 7, 12, 55, 807, DateTimeZone.UTC);\n    assertEquals(Long.MAX_VALUE, dt.getMillis());\n    assertEquals(ISOChronology.getInstanceUTC(), dt.getChronology());\n    DateTime test = new DateTime(Long.MAX_VALUE);\n    assertEquals(Long.MAX_VALUE, test.getMillis());\n    assertEquals(ISOChronology.getInstanceUTC(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1114, "method_signature": "void testDateTime_max()"}, "TestMinMaxLong.testDateTime_min": {"callee_method_names": ["DateTime.getMillis", "DateTime.toString"], "method_name": "TestMinMaxLong.testDateTime_min", "method_implementation": "{\n    DateTime dt = new DateTime(-292275054, 1, 1, 0, 0);\n    DateTime test = new DateTime(dt.getMillis());\n    assertEquals(dt, test);\n    assertEquals(\"-292275054-01-01T00:00:00.000-00:01:15\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1115, "method_signature": "void testDateTime_min()"}, "TestMinutes.testAddToLocalDate": {"callee_method_names": ["LocalDateTime.plus"], "method_name": "TestMinutes.testAddToLocalDate", "method_implementation": "{\n    Minutes test = Minutes.minutes(26);\n    LocalDateTime date = new LocalDateTime(2006, 6, 1, 0, 0, 0, 0);\n    LocalDateTime expected = new LocalDateTime(2006, 6, 1, 0, 26, 0, 0);\n    assertEquals(expected, date.plus(test));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1189, "method_signature": "void testAddToLocalDate()"}, "TestMinutes.testConstants": {"callee_method_names": [], "method_name": "TestMinutes.testConstants", "method_implementation": "{\n    assertEquals(0, Minutes.ZERO.getMinutes());\n    assertEquals(1, Minutes.ONE.getMinutes());\n    assertEquals(2, Minutes.TWO.getMinutes());\n    assertEquals(3, Minutes.THREE.getMinutes());\n    assertEquals(Integer.MAX_VALUE, Minutes.MAX_VALUE.getMinutes());\n    assertEquals(Integer.MIN_VALUE, Minutes.MIN_VALUE.getMinutes());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1181, "method_signature": "void testConstants()"}, "TestMinutes.testFactory_minutesBetween_RInstant": {"callee_method_names": [], "method_name": "TestMinutes.testFactory_minutesBetween_RInstant", "method_implementation": "{\n    DateTime start = new DateTime(2006, 6, 9, 12, 3, 0, 0, PARIS);\n    DateTime end1 = new DateTime(2006, 6, 9, 12, 6, 0, 0, PARIS);\n    DateTime end2 = new DateTime(2006, 6, 9, 12, 9, 0, 0, PARIS);\n    assertEquals(3, Minutes.minutesBetween(start, end1).getMinutes());\n    assertEquals(0, Minutes.minutesBetween(start, start).getMinutes());\n    assertEquals(0, Minutes.minutesBetween(end1, end1).getMinutes());\n    assertEquals(-3, Minutes.minutesBetween(end1, start).getMinutes());\n    assertEquals(6, Minutes.minutesBetween(start, end2).getMinutes());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1183, "method_signature": "void testFactory_minutesBetween_RInstant()"}, "TestMinutes.testFactory_minutes_int": {"callee_method_names": [], "method_name": "TestMinutes.testFactory_minutes_int", "method_implementation": "{\n    assertSame(Minutes.ZERO, Minutes.minutes(0));\n    assertSame(Minutes.ONE, Minutes.minutes(1));\n    assertSame(Minutes.TWO, Minutes.minutes(2));\n    assertSame(Minutes.THREE, Minutes.minutes(3));\n    assertSame(Minutes.MAX_VALUE, Minutes.minutes(Integer.MAX_VALUE));\n    assertSame(Minutes.MIN_VALUE, Minutes.minutes(Integer.MIN_VALUE));\n    assertEquals(-1, Minutes.minutes(-1).getMinutes());\n    assertEquals(4, Minutes.minutes(4).getMinutes());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1182, "method_signature": "void testFactory_minutes_int()"}, "TestMinutes.testIsGreaterThan": {"callee_method_names": [], "method_name": "TestMinutes.testIsGreaterThan", "method_implementation": "{\n    assertEquals(true, Minutes.THREE.isGreaterThan(Minutes.TWO));\n    assertEquals(false, Minutes.THREE.isGreaterThan(Minutes.THREE));\n    assertEquals(false, Minutes.TWO.isGreaterThan(Minutes.THREE));\n    assertEquals(true, Minutes.ONE.isGreaterThan(null));\n    assertEquals(false, Minutes.minutes(-1).isGreaterThan(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1184, "method_signature": "void testIsGreaterThan()"}, "TestMinutes.testPlus_int": {"callee_method_ids": [155], "callee_method_names": ["Minutes.plus", "Minutes.getMinutes", "Minutes.getMinutes"], "method_name": "TestMinutes.testPlus_int", "method_implementation": "{\n    Minutes test2 = Minutes.minutes(2);\n    Minutes result = test2.plus(3);\n    assertEquals(2, test2.getMinutes());\n    assertEquals(5, result.getMinutes());\n    assertEquals(1, Minutes.ONE.plus(0).getMinutes());\n    try {\n        Minutes.MAX_VALUE.plus(1);\n        fail();\n    } catch (ArithmeticException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1188, "method_signature": "void testPlus_int()"}, "TestMinutes.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestMinutes.testSerialization", "method_implementation": "{\n    Minutes test = Minutes.THREE;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Minutes result = (Minutes) ois.readObject();\n    ois.close();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1186, "method_signature": "void testSerialization()"}, "TestMinutes.testToStandardWeeks": {"callee_method_names": ["Minutes.toStandardWeeks"], "method_name": "TestMinutes.testToStandardWeeks", "method_implementation": "{\n    Minutes test = Minutes.minutes(60 * 24 * 7 * 2);\n    Weeks expected = Weeks.weeks(2);\n    assertEquals(expected, test.toStandardWeeks());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1187, "method_signature": "void testToStandardWeeks()"}, "TestMinutes.testToString": {"callee_method_ids": [160, 160], "callee_method_names": ["Minutes.toString", "Minutes.toString"], "method_name": "TestMinutes.testToString", "method_implementation": "{\n    Minutes test = Minutes.minutes(20);\n    assertEquals(\"PT20M\", test.toString());\n    test = Minutes.minutes(-20);\n    assertEquals(\"PT-20M\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1185, "method_signature": "void testToString()"}, "TestMonthDay_Basics.testCompareTo": {"callee_method_names": ["MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo", "MonthDay.compareTo"], "method_name": "TestMonthDay_Basics.testCompareTo", "method_implementation": "{\n    MonthDay test1 = new MonthDay(6, 6);\n    MonthDay test1a = new MonthDay(6, 6);\n    assertEquals(0, test1.compareTo(test1a));\n    assertEquals(0, test1a.compareTo(test1));\n    assertEquals(0, test1.compareTo(test1));\n    assertEquals(0, test1a.compareTo(test1a));\n    MonthDay test2 = new MonthDay(6, 7);\n    assertEquals(-1, test1.compareTo(test2));\n    assertEquals(+1, test2.compareTo(test1));\n    MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC());\n    assertEquals(-1, test1.compareTo(test3));\n    assertEquals(+1, test3.compareTo(test1));\n    assertEquals(0, test3.compareTo(test2));\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };\n    int[] values = new int[] { 6, 6 };\n    Partial p = new Partial(types, values);\n    assertEquals(0, test1.compareTo(p));\n    try {\n        test1.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n    try {\n        test1.compareTo(new LocalTime());\n        fail();\n    } catch (ClassCastException ex) {\n    }\n    Partial partial = new Partial().with(DateTimeFieldType.centuryOfEra(), 1).with(DateTimeFieldType.halfdayOfDay(), 0).with(DateTimeFieldType.dayOfMonth(), 9);\n    try {\n        new MonthDay(10, 6).compareTo(partial);\n        fail();\n    } catch (ClassCastException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2423, "method_signature": "void testCompareTo()"}, "TestMonthDay_Basics.testGet": {"callee_method_names": ["MonthDay.get", "MonthDay.get", "MonthDay.get", "MonthDay.get"], "method_name": "TestMonthDay_Basics.testGet", "method_implementation": "{\n    MonthDay test = new MonthDay();\n    assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n    assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n    try {\n        test.get(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.get(DateTimeFieldType.year());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2422, "method_signature": "void testGet()"}, "TestMonthDay_Basics.testIsAfter_MD": {"callee_method_names": ["MonthDay.isAfter", "MonthDay.isAfter", "MonthDay.isAfter", "MonthDay.isAfter", "MonthDay.isAfter", "MonthDay.isAfter", "MonthDay.isAfter", "MonthDay.isAfter", "MonthDay.isAfter"], "method_name": "TestMonthDay_Basics.testIsAfter_MD", "method_implementation": "{\n    MonthDay test1 = new MonthDay(6, 6);\n    MonthDay test1a = new MonthDay(6, 6);\n    assertEquals(false, test1.isAfter(test1a));\n    assertEquals(false, test1a.isAfter(test1));\n    assertEquals(false, test1.isAfter(test1));\n    assertEquals(false, test1a.isAfter(test1a));\n    MonthDay test2 = new MonthDay(6, 7);\n    assertEquals(false, test1.isAfter(test2));\n    assertEquals(true, test2.isAfter(test1));\n    MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isAfter(test3));\n    assertEquals(true, test3.isAfter(test1));\n    assertEquals(false, test3.isAfter(test2));\n    try {\n        new MonthDay(6, 7).isAfter(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2426, "method_signature": "void testIsAfter_MD()"}, "TestMonthDay_Basics.testIsBefore_MD": {"callee_method_names": ["MonthDay.isBefore", "MonthDay.isBefore", "MonthDay.isBefore", "MonthDay.isBefore", "MonthDay.isBefore", "MonthDay.isBefore", "MonthDay.isBefore", "MonthDay.isBefore", "MonthDay.isBefore"], "method_name": "TestMonthDay_Basics.testIsBefore_MD", "method_implementation": "{\n    MonthDay test1 = new MonthDay(6, 6);\n    MonthDay test1a = new MonthDay(6, 6);\n    assertEquals(false, test1.isBefore(test1a));\n    assertEquals(false, test1a.isBefore(test1));\n    assertEquals(false, test1.isBefore(test1));\n    assertEquals(false, test1a.isBefore(test1a));\n    MonthDay test2 = new MonthDay(6, 7);\n    assertEquals(true, test1.isBefore(test2));\n    assertEquals(false, test2.isBefore(test1));\n    MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC());\n    assertEquals(true, test1.isBefore(test3));\n    assertEquals(false, test3.isBefore(test1));\n    assertEquals(false, test3.isBefore(test2));\n    try {\n        new MonthDay(6, 7).isBefore(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2425, "method_signature": "void testIsBefore_MD()"}, "TestMonthDay_Basics.testIsEqual_MD": {"callee_method_names": ["MonthDay.isEqual", "MonthDay.isEqual", "MonthDay.isEqual", "MonthDay.isEqual", "MonthDay.isEqual", "MonthDay.isEqual", "MonthDay.isEqual", "MonthDay.isEqual", "MonthDay.isEqual"], "method_name": "TestMonthDay_Basics.testIsEqual_MD", "method_implementation": "{\n    MonthDay test1 = new MonthDay(6, 6);\n    MonthDay test1a = new MonthDay(6, 6);\n    assertEquals(true, test1.isEqual(test1a));\n    assertEquals(true, test1a.isEqual(test1));\n    assertEquals(true, test1.isEqual(test1));\n    assertEquals(true, test1a.isEqual(test1a));\n    MonthDay test2 = new MonthDay(6, 7);\n    assertEquals(false, test1.isEqual(test2));\n    assertEquals(false, test2.isEqual(test1));\n    MonthDay test3 = new MonthDay(6, 7, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isEqual(test3));\n    assertEquals(false, test3.isEqual(test1));\n    assertEquals(true, test3.isEqual(test2));\n    try {\n        new MonthDay(6, 7).isEqual(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2424, "method_signature": "void testIsEqual_MD()"}, "TestMonthDay_Basics.testMinusDays_int": {"callee_method_names": ["MonthDay.minusDays"], "method_name": "TestMonthDay_Basics.testMinusDays_int", "method_implementation": "{\n    MonthDay test = new MonthDay(5, 11, BuddhistChronology.getInstance());\n    MonthDay result = test.minusDays(1);\n    MonthDay expected = new MonthDay(5, 10, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2433, "method_signature": "void testMinusDays_int()"}, "TestMonthDay_Basics.testMinus_RP": {"callee_method_names": ["MonthDay.minus", "MonthDay.minus"], "method_name": "TestMonthDay_Basics.testMinus_RP", "method_implementation": "{\n    MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance());\n    MonthDay result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n    MonthDay expected = new MonthDay(5, 4, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n    result = test.minus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2432, "method_signature": "void testMinus_RP()"}, "TestMonthDay_Basics.testPlusDays_int": {"callee_method_names": ["MonthDay.plusDays"], "method_name": "TestMonthDay_Basics.testPlusDays_int", "method_implementation": "{\n    MonthDay test = new MonthDay(5, 10, BuddhistChronology.getInstance());\n    MonthDay result = test.plusDays(1);\n    MonthDay expected = new MonthDay(5, 11, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2431, "method_signature": "void testPlusDays_int()"}, "TestMonthDay_Basics.testPlus_RP": {"callee_method_names": ["MonthDay.plus", "MonthDay.plus"], "method_name": "TestMonthDay_Basics.testPlus_RP", "method_implementation": "{\n    MonthDay test = new MonthDay(6, 5, BuddhistChronology.getInstance());\n    MonthDay result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n    MonthDay expected = new MonthDay(8, 9, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n    result = test.plus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2430, "method_signature": "void testPlus_RP()"}, "TestMonthDay_Basics.testProperty": {"callee_method_names": ["MonthDay.monthOfYear", "MonthDay.property", "MonthDay.dayOfMonth", "MonthDay.property", "MonthDay.property", "MonthDay.property"], "method_name": "TestMonthDay_Basics.testProperty", "method_implementation": "{\n    MonthDay test = new MonthDay(6, 6);\n    assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));\n    assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth()));\n    try {\n        test.property(DateTimeFieldType.millisOfDay());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2437, "method_signature": "void testProperty()"}, "TestMonthDay_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close", "MonthDay.getValues", "MonthDay.getValues", "MonthDay.getFields", "MonthDay.getFields", "MonthDay.getChronology", "MonthDay.getChronology"], "method_name": "TestMonthDay_Basics.testSerialization", "method_implementation": "{\n    MonthDay test = new MonthDay(5, 6, COPTIC_PARIS);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    MonthDay result = (MonthDay) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n    assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n    assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n    assertEquals(test.getChronology(), result.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2438, "method_signature": "void testSerialization()"}, "TestMonthDay_Basics.testToDateTime_RI": {"callee_method_names": ["MonthDay.toDateTime", "DateTime.monthOfYear", "DateTime.dayOfMonth"], "method_name": "TestMonthDay_Basics.testToDateTime_RI", "method_implementation": "{\n    MonthDay base = new MonthDay(6, 6, COPTIC_PARIS);\n    DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n    DateTime test = base.toDateTime(dt);\n    check(base, 6, 6);\n    DateTime expected = dt;\n    expected = expected.monthOfYear().setCopy(6);\n    expected = expected.dayOfMonth().setCopy(6);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2435, "method_signature": "void testToDateTime_RI()"}, "TestMonthDay_Basics.testToLocalDate": {"callee_method_names": ["MonthDay.toLocalDate", "MonthDay.toLocalDate"], "method_name": "TestMonthDay_Basics.testToLocalDate", "method_implementation": "{\n    MonthDay base = new MonthDay(6, 6, COPTIC_UTC);\n    LocalDate test = base.toLocalDate(2009);\n    assertEquals(new LocalDate(2009, 6, 6, COPTIC_UTC), test);\n    try {\n        base.toLocalDate(0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2434, "method_signature": "void testToLocalDate()"}, "TestMonthDay_Basics.testToString_DTFormatter": {"callee_method_ids": [175, 175], "callee_method_names": ["MonthDay.toString", "MonthDay.toString"], "method_name": "TestMonthDay_Basics.testToString_DTFormatter", "method_implementation": "{\n    MonthDay test = new MonthDay(5, 6);\n    assertEquals(\"05 \\ufffd\\ufffd\", test.toString(DateTimeFormat.forPattern(\"MM HH\")));\n    assertEquals(\"--05-06\", test.toString((DateTimeFormatter) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2441, "method_signature": "void testToString_DTFormatter()"}, "TestMonthDay_Basics.testToString_String": {"callee_method_ids": [175, 175], "callee_method_names": ["MonthDay.toString", "MonthDay.toString"], "method_name": "TestMonthDay_Basics.testToString_String", "method_implementation": "{\n    MonthDay test = new MonthDay(5, 6);\n    assertEquals(\"05 \\ufffd\\ufffd\", test.toString(\"MM HH\"));\n    assertEquals(\"--05-06\", test.toString((String) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2439, "method_signature": "void testToString_String()"}, "TestMonthDay_Basics.testToString_String_Locale": {"callee_method_ids": [175, 175, 175, 175, 175], "callee_method_names": ["MonthDay.toString", "MonthDay.toString", "MonthDay.toString", "MonthDay.toString", "MonthDay.toString"], "method_name": "TestMonthDay_Basics.testToString_String_Locale", "method_implementation": "{\n    MonthDay test = new MonthDay(5, 6);\n    assertEquals(\"\\ufffd 6/5\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n    assertEquals(\"\\ufffd 6/5\", test.toString(\"EEE d/M\", Locale.FRENCH));\n    assertEquals(\"--05-06\", test.toString(null, Locale.ENGLISH));\n    assertEquals(\"\\ufffd 6/5\", test.toString(\"EEE d/M\", null));\n    assertEquals(\"--05-06\", test.toString(null, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2440, "method_signature": "void testToString_String_Locale()"}, "TestMonthDay_Basics.testWithChronologyRetainFields_Chrono": {"callee_method_ids": [167], "callee_method_names": ["MonthDay.withChronologyRetainFields", "MonthDay.getChronology", "MonthDay.getChronology"], "method_name": "TestMonthDay_Basics.testWithChronologyRetainFields_Chrono", "method_implementation": "{\n    MonthDay base = new MonthDay(6, 6, COPTIC_PARIS);\n    MonthDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n    check(base, 6, 6);\n    assertEquals(COPTIC_UTC, base.getChronology());\n    check(test, 6, 6);\n    assertEquals(BUDDHIST_UTC, test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2427, "method_signature": "void testWithChronologyRetainFields_Chrono()"}, "TestMonthDay_Basics.testWithField": {"callee_method_ids": [168], "callee_method_names": ["MonthDay.withField"], "method_name": "TestMonthDay_Basics.testWithField", "method_implementation": "{\n    MonthDay test = new MonthDay(9, 6);\n    MonthDay result = test.withField(DateTimeFieldType.monthOfYear(), 10);\n    assertEquals(new MonthDay(9, 6), test);\n    assertEquals(new MonthDay(10, 6), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2428, "method_signature": "void testWithField()"}, "TestMonthDay_Basics.testWithFieldAdded": {"callee_method_ids": [169], "callee_method_names": ["MonthDay.withFieldAdded"], "method_name": "TestMonthDay_Basics.testWithFieldAdded", "method_implementation": "{\n    MonthDay test = new MonthDay(9, 6);\n    MonthDay result = test.withFieldAdded(DurationFieldType.months(), 1);\n    assertEquals(new MonthDay(9, 6), test);\n    assertEquals(new MonthDay(10, 6), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2429, "method_signature": "void testWithFieldAdded()"}, "TestMonthDay_Basics.testWithers": {"callee_method_ids": [171, 172, 171, 171], "callee_method_names": ["MonthDay.withMonthOfYear", "MonthDay.withDayOfMonth", "MonthDay.withMonthOfYear", "MonthDay.withMonthOfYear"], "method_name": "TestMonthDay_Basics.testWithers", "method_implementation": "{\n    MonthDay test = new MonthDay(10, 6);\n    check(test.withMonthOfYear(5), 5, 6);\n    check(test.withDayOfMonth(2), 10, 2);\n    try {\n        test.withMonthOfYear(0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.withMonthOfYear(13);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2436, "method_signature": "void testWithers()"}, "TestMonthDay_Constructors.testConstructor": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor", "method_implementation": "{\n    MonthDay test = new MonthDay();\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(test, MonthDay.now());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1543, "method_signature": "void testConstructor()"}, "TestMonthDay_Constructors.testConstructor_Chronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_Chronology", "method_implementation": "{\n    MonthDay test = new MonthDay(GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(test, MonthDay.now(GREGORIAN_PARIS));\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1546, "method_signature": "void testConstructor_Chronology()"}, "TestMonthDay_Constructors.testConstructor_DateTimeZone": {"callee_method_names": ["DateTime.getMillis", "MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth", "MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_DateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    MonthDay test = new MonthDay(LONDON);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(30, test.getDayOfMonth());\n    assertEquals(test, MonthDay.now(LONDON));\n    test = new MonthDay(PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(7, test.getMonthOfYear());\n    assertEquals(1, test.getDayOfMonth());\n    assertEquals(test, MonthDay.now(PARIS));\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1544, "method_signature": "void testConstructor_DateTimeZone()"}, "TestMonthDay_Constructors.testConstructor_Object": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_Object", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    MonthDay test = new MonthDay(date);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1553, "method_signature": "void testConstructor_Object()"}, "TestMonthDay_Constructors.testConstructor_Object_Chronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_Object_Chronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    MonthDay test = new MonthDay(date, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1554, "method_signature": "void testConstructor_Object_Chronology()"}, "TestMonthDay_Constructors.testConstructor_Object_nullChronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_Object_nullChronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    MonthDay test = new MonthDay(date, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1556, "method_signature": "void testConstructor_Object_nullChronology()"}, "TestMonthDay_Constructors.testConstructor_int_int": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_int_int", "method_implementation": "{\n    MonthDay test = new MonthDay(6, 30);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(30, test.getDayOfMonth());\n    try {\n        new MonthDay(Integer.MIN_VALUE, 6);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MonthDay(Integer.MAX_VALUE, 6);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MonthDay(1970, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MonthDay(1970, 13);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1558, "method_signature": "void testConstructor_int_int()"}, "TestMonthDay_Constructors.testConstructor_int_int_Chronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_int_int_Chronology", "method_implementation": "{\n    MonthDay test = new MonthDay(6, 30, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(30, test.getDayOfMonth());\n    try {\n        new MonthDay(Integer.MIN_VALUE, 6, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MonthDay(Integer.MAX_VALUE, 6, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MonthDay(1970, 0, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MonthDay(1970, 13, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1559, "method_signature": "void testConstructor_int_int_Chronology()"}, "TestMonthDay_Constructors.testConstructor_int_int_nullChronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_int_int_nullChronology", "method_implementation": "{\n    MonthDay test = new MonthDay(6, 30, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(30, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1560, "method_signature": "void testConstructor_int_int_nullChronology()"}, "TestMonthDay_Constructors.testConstructor_long1": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_long1", "method_implementation": "{\n    MonthDay test = new MonthDay(TEST_TIME1);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1548, "method_signature": "void testConstructor_long1()"}, "TestMonthDay_Constructors.testConstructor_long1_Chronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_long1_Chronology", "method_implementation": "{\n    MonthDay test = new MonthDay(TEST_TIME1, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1550, "method_signature": "void testConstructor_long1_Chronology()"}, "TestMonthDay_Constructors.testConstructor_long2": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_long2", "method_implementation": "{\n    MonthDay test = new MonthDay(TEST_TIME2);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(5, test.getMonthOfYear());\n    assertEquals(7, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1549, "method_signature": "void testConstructor_long2()"}, "TestMonthDay_Constructors.testConstructor_long2_Chronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_long2_Chronology", "method_implementation": "{\n    MonthDay test = new MonthDay(TEST_TIME2, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(5, test.getMonthOfYear());\n    assertEquals(7, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1551, "method_signature": "void testConstructor_long2_Chronology()"}, "TestMonthDay_Constructors.testConstructor_long_nullChronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_long_nullChronology", "method_implementation": "{\n    MonthDay test = new MonthDay(TEST_TIME1, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1552, "method_signature": "void testConstructor_long_nullChronology()"}, "TestMonthDay_Constructors.testConstructor_nullChronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_nullChronology", "method_implementation": "{\n    MonthDay test = new MonthDay((Chronology) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1547, "method_signature": "void testConstructor_nullChronology()"}, "TestMonthDay_Constructors.testConstructor_nullDateTimeZone": {"callee_method_names": ["DateTime.getMillis", "MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_nullDateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    MonthDay test = new MonthDay((DateTimeZone) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(30, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1545, "method_signature": "void testConstructor_nullDateTimeZone()"}, "TestMonthDay_Constructors.testConstructor_nullObject_Chronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_nullObject_Chronology", "method_implementation": "{\n    MonthDay test = new MonthDay((Object) null, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1555, "method_signature": "void testConstructor_nullObject_Chronology()"}, "TestMonthDay_Constructors.testConstructor_nullObject_nullChronology": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.getMonthOfYear", "MonthDay.getDayOfMonth"], "method_name": "TestMonthDay_Constructors.testConstructor_nullObject_nullChronology", "method_implementation": "{\n    MonthDay test = new MonthDay((Object) null, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1557, "method_signature": "void testConstructor_nullObject_nullChronology()"}, "TestMonthDay_Constructors.testFactory_FromCalendarFields": {"callee_method_names": ["GregorianCalendar.set"], "method_name": "TestMonthDay_Constructors.testFactory_FromCalendarFields", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    MonthDay expected = new MonthDay(2, 3);\n    assertEquals(expected, MonthDay.fromCalendarFields(cal));\n    try {\n        MonthDay.fromCalendarFields(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1541, "method_signature": "void testFactory_FromCalendarFields()"}, "TestMonthDay_Constructors.testFactory_FromDateFields": {"callee_method_names": ["GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestMonthDay_Constructors.testFactory_FromDateFields", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    MonthDay expected = new MonthDay(2, 3);\n    assertEquals(expected, MonthDay.fromDateFields(cal.getTime()));\n    try {\n        MonthDay.fromDateFields(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1542, "method_signature": "void testFactory_FromDateFields()"}, "TestMonthDay_Constructors.testParse_noFormatter": {"callee_method_names": [], "method_name": "TestMonthDay_Constructors.testParse_noFormatter", "method_implementation": "{\n    assertEquals(new MonthDay(6, 30), MonthDay.parse(\"--06-30\"));\n    assertEquals(new MonthDay(2, 29), MonthDay.parse(\"--02-29\"));\n    assertEquals(new MonthDay(6, 30), MonthDay.parse(\"2010-06-30\"));\n    assertEquals(new MonthDay(1, 2), MonthDay.parse(\"2010-002\"));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1540, "method_signature": "void testParse_noFormatter()"}, "TestMonthDay_Properties.testPropertyEquals": {"callee_method_names": ["MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.monthOfYear", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.dayOfMonth", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.dayOfMonth", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth"], "method_name": "TestMonthDay_Properties.testPropertyEquals", "method_implementation": "{\n    MonthDay test1 = new MonthDay(11, 11);\n    MonthDay test2 = new MonthDay(11, 12);\n    MonthDay test3 = new MonthDay(11, 11, CopticChronology.getInstanceUTC());\n    assertEquals(true, test1.dayOfMonth().equals(test1.dayOfMonth()));\n    assertEquals(false, test1.dayOfMonth().equals(test1.monthOfYear()));\n    assertEquals(false, test1.dayOfMonth().equals(test2.dayOfMonth()));\n    assertEquals(false, test1.dayOfMonth().equals(test2.monthOfYear()));\n    assertEquals(false, test1.monthOfYear().equals(test1.dayOfMonth()));\n    assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear()));\n    assertEquals(false, test1.monthOfYear().equals(test2.dayOfMonth()));\n    assertEquals(true, test1.monthOfYear().equals(test2.monthOfYear()));\n    assertEquals(false, test1.dayOfMonth().equals(null));\n    assertEquals(false, test1.dayOfMonth().equals(\"any\"));\n    // chrono\n    assertEquals(false, test1.dayOfMonth().equals(test3.dayOfMonth()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2197, "method_signature": "void testPropertyEquals()"}, "TestMonthDay_Properties.testPropertyGetDayOfMonth": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.getChronology", "MonthDay.dayOfMonth", "MonthDay.getChronology", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth", "MonthDay.dayOfMonth"], "method_name": "TestMonthDay_Properties.testPropertyGetDayOfMonth", "method_implementation": "{\n    MonthDay test = new MonthDay(4, 6);\n    assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n    assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n    assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n    assertSame(test, test.dayOfMonth().getReadablePartial());\n    assertSame(test, test.dayOfMonth().getMonthDay());\n    assertEquals(6, test.dayOfMonth().get());\n    assertEquals(\"6\", test.dayOfMonth().getAsString());\n    assertEquals(\"6\", test.dayOfMonth().getAsText());\n    assertEquals(\"6\", test.dayOfMonth().getAsText(Locale.FRENCH));\n    assertEquals(\"6\", test.dayOfMonth().getAsShortText());\n    assertEquals(\"6\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n    assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n    assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n    assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n    test = new MonthDay(4, 7);\n    assertEquals(\"7\", test.dayOfMonth().getAsText(Locale.FRENCH));\n    assertEquals(\"7\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2196, "method_signature": "void testPropertyGetDayOfMonth()"}, "TestMonthDay_Properties.testPropertyGetMonthOfYear": {"callee_method_names": ["MonthDay.getChronology", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "String.equals", "String.equals", "MonthDay.monthOfYear", "MonthDay.getChronology", "MonthDay.monthOfYear", "MonthDay.monthOfYear", "MonthDay.monthOfYear"], "method_name": "TestMonthDay_Properties.testPropertyGetMonthOfYear", "method_implementation": "{\n    MonthDay test = new MonthDay(9, 6);\n    assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n    assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n    assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n    assertSame(test, test.monthOfYear().getReadablePartial());\n    assertSame(test, test.monthOfYear().getMonthDay());\n    assertEquals(9, test.monthOfYear().get());\n    assertEquals(\"9\", test.monthOfYear().getAsString());\n    assertEquals(\"September\", test.monthOfYear().getAsText());\n    assertEquals(\"septembre\", test.monthOfYear().getAsText(Locale.FRENCH));\n    String text = test.monthOfYear().getAsShortText();\n    assertTrue(text.equals(\"Sep\") || text.equals(\"Sept\"));\n    assertEquals(\"sept.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n    // assertEquals(test.getChronology().days(), test.dayOfMonth().getRangeDurationField());\n    assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n    int max = test.monthOfYear().getMaximumShortTextLength(null);\n    // for JDK17+\n    assertTrue(max == 3 || max == 4);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2195, "method_signature": "void testPropertyGetMonthOfYear()"}, "TestMonths.testAddToLocalDate": {"callee_method_names": ["LocalDate.plus"], "method_name": "TestMonths.testAddToLocalDate", "method_implementation": "{\n    Months test = Months.months(3);\n    LocalDate date = new LocalDate(2006, 6, 1);\n    LocalDate expected = new LocalDate(2006, 9, 1);\n    assertEquals(expected, date.plus(test));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2514, "method_signature": "void testAddToLocalDate()"}, "TestMonths.testConstants": {"callee_method_names": [], "method_name": "TestMonths.testConstants", "method_implementation": "{\n    assertEquals(0, Months.ZERO.getMonths());\n    assertEquals(1, Months.ONE.getMonths());\n    assertEquals(2, Months.TWO.getMonths());\n    assertEquals(3, Months.THREE.getMonths());\n    assertEquals(4, Months.FOUR.getMonths());\n    assertEquals(5, Months.FIVE.getMonths());\n    assertEquals(6, Months.SIX.getMonths());\n    assertEquals(7, Months.SEVEN.getMonths());\n    assertEquals(8, Months.EIGHT.getMonths());\n    assertEquals(9, Months.NINE.getMonths());\n    assertEquals(10, Months.TEN.getMonths());\n    assertEquals(11, Months.ELEVEN.getMonths());\n    assertEquals(12, Months.TWELVE.getMonths());\n    assertEquals(Integer.MAX_VALUE, Months.MAX_VALUE.getMonths());\n    assertEquals(Integer.MIN_VALUE, Months.MIN_VALUE.getMonths());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2505, "method_signature": "void testConstants()"}, "TestMonths.testFactory_monthsBetween_RInstant": {"callee_method_names": [], "method_name": "TestMonths.testFactory_monthsBetween_RInstant", "method_implementation": "{\n    DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n    DateTime end1 = new DateTime(2006, 9, 9, 12, 0, 0, 0, PARIS);\n    DateTime end2 = new DateTime(2006, 12, 9, 12, 0, 0, 0, PARIS);\n    assertEquals(3, Months.monthsBetween(start, end1).getMonths());\n    assertEquals(0, Months.monthsBetween(start, start).getMonths());\n    assertEquals(0, Months.monthsBetween(end1, end1).getMonths());\n    assertEquals(-3, Months.monthsBetween(end1, start).getMonths());\n    assertEquals(6, Months.monthsBetween(start, end2).getMonths());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2507, "method_signature": "void testFactory_monthsBetween_RInstant()"}, "TestMonths.testFactory_monthsBetween_RPartial_LocalDate": {"callee_method_names": [], "method_name": "TestMonths.testFactory_monthsBetween_RPartial_LocalDate", "method_implementation": "{\n    LocalDate start = new LocalDate(2006, 6, 9);\n    LocalDate end1 = new LocalDate(2006, 9, 9);\n    YearMonthDay end2 = new YearMonthDay(2006, 12, 9);\n    assertEquals(3, Months.monthsBetween(start, end1).getMonths());\n    assertEquals(0, Months.monthsBetween(start, start).getMonths());\n    assertEquals(0, Months.monthsBetween(end1, end1).getMonths());\n    assertEquals(-3, Months.monthsBetween(end1, start).getMonths());\n    assertEquals(6, Months.monthsBetween(start, end2).getMonths());\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2508, "method_signature": "void testFactory_monthsBetween_RPartial_LocalDate()"}, "TestMonths.testFactory_monthsIn_RInterval": {"callee_method_names": [], "method_name": "TestMonths.testFactory_monthsIn_RInterval", "method_implementation": "{\n    DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n    DateTime end1 = new DateTime(2006, 9, 9, 12, 0, 0, 0, PARIS);\n    DateTime end2 = new DateTime(2006, 12, 9, 12, 0, 0, 0, PARIS);\n    assertEquals(0, Months.monthsIn((ReadableInterval) null).getMonths());\n    assertEquals(3, Months.monthsIn(new Interval(start, end1)).getMonths());\n    assertEquals(0, Months.monthsIn(new Interval(start, start)).getMonths());\n    assertEquals(0, Months.monthsIn(new Interval(end1, end1)).getMonths());\n    assertEquals(6, Months.monthsIn(new Interval(start, end2)).getMonths());\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2509, "method_signature": "void testFactory_monthsIn_RInterval()"}, "TestMonths.testFactory_months_int": {"callee_method_names": [], "method_name": "TestMonths.testFactory_months_int", "method_implementation": "{\n    assertSame(Months.ZERO, Months.months(0));\n    assertSame(Months.ONE, Months.months(1));\n    assertSame(Months.TWO, Months.months(2));\n    assertSame(Months.THREE, Months.months(3));\n    assertSame(Months.FOUR, Months.months(4));\n    assertSame(Months.FIVE, Months.months(5));\n    assertSame(Months.SIX, Months.months(6));\n    assertSame(Months.SEVEN, Months.months(7));\n    assertSame(Months.EIGHT, Months.months(8));\n    assertSame(Months.NINE, Months.months(9));\n    assertSame(Months.TEN, Months.months(10));\n    assertSame(Months.ELEVEN, Months.months(11));\n    assertSame(Months.TWELVE, Months.months(12));\n    assertSame(Months.MAX_VALUE, Months.months(Integer.MAX_VALUE));\n    assertSame(Months.MIN_VALUE, Months.months(Integer.MIN_VALUE));\n    assertEquals(-1, Months.months(-1).getMonths());\n    assertEquals(13, Months.months(13).getMonths());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2506, "method_signature": "void testFactory_months_int()"}, "TestMonths.testIsGreaterThan": {"callee_method_names": [], "method_name": "TestMonths.testIsGreaterThan", "method_implementation": "{\n    assertEquals(true, Months.THREE.isGreaterThan(Months.TWO));\n    assertEquals(false, Months.THREE.isGreaterThan(Months.THREE));\n    assertEquals(false, Months.TWO.isGreaterThan(Months.THREE));\n    assertEquals(true, Months.ONE.isGreaterThan(null));\n    assertEquals(false, Months.months(-1).isGreaterThan(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2510, "method_signature": "void testIsGreaterThan()"}, "TestMonths.testPlus_int": {"callee_method_ids": [552], "callee_method_names": ["Months.plus", "Months.getMonths", "Months.getMonths"], "method_name": "TestMonths.testPlus_int", "method_implementation": "{\n    Months test2 = Months.months(2);\n    Months result = test2.plus(3);\n    assertEquals(2, test2.getMonths());\n    assertEquals(5, result.getMonths());\n    assertEquals(1, Months.ONE.plus(0).getMonths());\n    try {\n        Months.MAX_VALUE.plus(1);\n        fail();\n    } catch (ArithmeticException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2513, "method_signature": "void testPlus_int()"}, "TestMonths.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestMonths.testSerialization", "method_implementation": "{\n    Months test = Months.THREE;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Months result = (Months) ois.readObject();\n    ois.close();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2512, "method_signature": "void testSerialization()"}, "TestMonths.testToString": {"callee_method_ids": [557, 557], "callee_method_names": ["Months.toString", "Months.toString"], "method_name": "TestMonths.testToString", "method_implementation": "{\n    Months test = Months.months(20);\n    assertEquals(\"P20M\", test.toString());\n    test = Months.months(-20);\n    assertEquals(\"P-20M\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2511, "method_signature": "void testToString()"}, "TestMutableDateTime_Adds.testAddDays_int1": {"callee_method_ids": [670], "callee_method_names": ["MutableDateTime.addDays", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAddDays_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.addDays(17);\n    assertEquals(\"2002-06-26T05:06:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2023, "method_signature": "void testAddDays_int1()"}, "TestMutableDateTime_Adds.testAddHours_int1": {"callee_method_ids": [671], "callee_method_names": ["MutableDateTime.addHours", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAddHours_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.addHours(13);\n    assertEquals(\"2002-06-09T18:06:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2026, "method_signature": "void testAddHours_int1()"}, "TestMutableDateTime_Adds.testAddMillis_int1": {"callee_method_ids": [674], "callee_method_names": ["MutableDateTime.addMillis", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAddMillis_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.addMillis(13);\n    assertEquals(\"2002-06-09T05:06:07.021+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2029, "method_signature": "void testAddMillis_int1()"}, "TestMutableDateTime_Adds.testAddMinutes_int1": {"callee_method_ids": [672], "callee_method_names": ["MutableDateTime.addMinutes", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAddMinutes_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.addMinutes(13);\n    assertEquals(\"2002-06-09T05:19:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2027, "method_signature": "void testAddMinutes_int1()"}, "TestMutableDateTime_Adds.testAddMonths_int1": {"callee_method_ids": [668], "callee_method_names": ["MutableDateTime.addMonths", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAddMonths_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.addMonths(6);\n    assertEquals(\"2002-12-09T05:06:07.008Z\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2022, "method_signature": "void testAddMonths_int1()"}, "TestMutableDateTime_Adds.testAddSeconds_int1": {"callee_method_ids": [673], "callee_method_names": ["MutableDateTime.addSeconds", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAddSeconds_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.addSeconds(13);\n    assertEquals(\"2002-06-09T05:06:20.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2028, "method_signature": "void testAddSeconds_int1()"}, "TestMutableDateTime_Adds.testAddWeeks_int1": {"callee_method_ids": [669], "callee_method_names": ["MutableDateTime.addWeeks", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAddWeeks_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.addWeeks(-21);\n    assertEquals(\"2002-01-13T05:06:07.008Z\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2025, "method_signature": "void testAddWeeks_int1()"}, "TestMutableDateTime_Adds.testAddWeekyears_int1": {"callee_method_ids": [667], "callee_method_names": ["MutableDateTime.addWeekyears", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAddWeekyears_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.addWeekyears(-1);\n    assertEquals(\"2001-06-10T05:06:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2024, "method_signature": "void testAddWeekyears_int1()"}, "TestMutableDateTime_Adds.testAddYears_int1": {"callee_method_ids": [666], "callee_method_names": ["MutableDateTime.addYears", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAddYears_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.addYears(8);\n    assertEquals(\"2010-06-09T05:06:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2021, "method_signature": "void testAddYears_int1()"}, "TestMutableDateTime_Adds.testAdd_DurationFieldType_int1": {"callee_method_ids": [665], "callee_method_names": ["MutableDateTime.add", "MutableDateTime.getYear"], "method_name": "TestMutableDateTime_Adds.testAdd_DurationFieldType_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.add(DurationFieldType.years(), 8);\n    assertEquals(2010, test.getYear());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2020, "method_signature": "void testAdd_DurationFieldType_int1()"}, "TestMutableDateTime_Adds.testAdd_RD1": {"callee_method_ids": [665], "callee_method_names": ["MutableDateTime.add", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Adds.testAdd_RD1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.add(new Duration(123456L));\n    assertEquals(TEST_TIME1 + 123456L, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2016, "method_signature": "void testAdd_RD1()"}, "TestMutableDateTime_Adds.testAdd_RD_int1": {"callee_method_ids": [665], "callee_method_names": ["MutableDateTime.add", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Adds.testAdd_RD_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.add(new Duration(123456L), -2);\n    assertEquals(TEST_TIME1 - (2L * 123456L), test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2017, "method_signature": "void testAdd_RD_int1()"}, "TestMutableDateTime_Adds.testAdd_RP1": {"callee_method_ids": [665], "callee_method_names": ["MutableDateTime.toString", "MutableDateTime.add", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Adds.testAdd_RP1", "method_implementation": "{\n    Period d = new Period(1, 1, 0, 1, 1, 1, 1, 1);\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    assertEquals(\"2002-06-09T05:06:07.008+01:00\", test.toString());\n    test.add(d);\n    assertEquals(\"2003-07-10T06:07:08.009+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2018, "method_signature": "void testAdd_RP1()"}, "TestMutableDateTime_Adds.testAdd_RP_int1": {"callee_method_ids": [665], "callee_method_names": ["MutableDateTime.add", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Adds.testAdd_RP_int1", "method_implementation": "{\n    Period d = new Period(0, 0, 0, 0, 0, 0, 1, 2);\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.add(d, -2);\n    assertEquals(TEST_TIME1 - (2L * 1002L), test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2019, "method_signature": "void testAdd_RP_int1()"}, "TestMutableDateTime_Adds.testAdd_long1": {"callee_method_ids": [665], "callee_method_names": ["MutableDateTime.add", "MutableDateTime.getMillis", "MutableDateTime.getChronology"], "method_name": "TestMutableDateTime_Adds.testAdd_long1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.add(123456L);\n    assertEquals(TEST_TIME1 + 123456L, test.getMillis());\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2015, "method_signature": "void testAdd_long1()"}, "TestMutableDateTime_Adds.testTest": {"callee_method_names": [], "method_name": "TestMutableDateTime_Adds.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2014, "method_signature": "void testTest()"}, "TestMutableDateTime_Basics.testGet_DateTimeField": {"callee_method_names": ["MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get", "MutableDateTime.get"], "method_name": "TestMutableDateTime_Basics.testGet_DateTimeField", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime();\n    assertEquals(1, test.get(ISOChronology.getInstance().era()));\n    assertEquals(20, test.get(ISOChronology.getInstance().centuryOfEra()));\n    assertEquals(2, test.get(ISOChronology.getInstance().yearOfCentury()));\n    assertEquals(2002, test.get(ISOChronology.getInstance().yearOfEra()));\n    assertEquals(2002, test.get(ISOChronology.getInstance().year()));\n    assertEquals(6, test.get(ISOChronology.getInstance().monthOfYear()));\n    assertEquals(9, test.get(ISOChronology.getInstance().dayOfMonth()));\n    assertEquals(2002, test.get(ISOChronology.getInstance().weekyear()));\n    assertEquals(23, test.get(ISOChronology.getInstance().weekOfWeekyear()));\n    assertEquals(7, test.get(ISOChronology.getInstance().dayOfWeek()));\n    assertEquals(160, test.get(ISOChronology.getInstance().dayOfYear()));\n    assertEquals(0, test.get(ISOChronology.getInstance().halfdayOfDay()));\n    assertEquals(1, test.get(ISOChronology.getInstance().hourOfHalfday()));\n    assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfDay()));\n    assertEquals(1, test.get(ISOChronology.getInstance().clockhourOfHalfday()));\n    assertEquals(1, test.get(ISOChronology.getInstance().hourOfDay()));\n    assertEquals(0, test.get(ISOChronology.getInstance().minuteOfHour()));\n    assertEquals(60, test.get(ISOChronology.getInstance().minuteOfDay()));\n    assertEquals(0, test.get(ISOChronology.getInstance().secondOfMinute()));\n    assertEquals(60 * 60, test.get(ISOChronology.getInstance().secondOfDay()));\n    assertEquals(0, test.get(ISOChronology.getInstance().millisOfSecond()));\n    assertEquals(60 * 60 * 1000, test.get(ISOChronology.getInstance().millisOfDay()));\n    try {\n        test.get((DateTimeField) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2443, "method_signature": "void testGet_DateTimeField()"}, "TestMutableDateTime_Basics.testProperty": {"callee_method_ids": [680, 680, 680, 680, 680, 680], "callee_method_names": ["MutableDateTime.year", "MutableDateTime.property", "MutableDateTime.dayOfWeek", "MutableDateTime.property", "MutableDateTime.secondOfMinute", "MutableDateTime.property", "MutableDateTime.millisOfSecond", "MutableDateTime.property", "MutableDateTime.property", "MutableDateTime.property"], "method_name": "TestMutableDateTime_Basics.testProperty", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime();\n    assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n    assertEquals(test.dayOfWeek(), test.property(DateTimeFieldType.dayOfWeek()));\n    assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute()));\n    assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond()));\n    DateTimeFieldType bad = new DateTimeFieldType(\"bad\") {\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public DurationFieldType getDurationType() {\n            return DurationFieldType.weeks();\n        }\n\n        @Override\n        public DurationFieldType getRangeDurationType() {\n            return null;\n        }\n\n        @Override\n        public DateTimeField getField(Chronology chronology) {\n            return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType()));\n        }\n    };\n    try {\n        test.property(bad);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2447, "method_signature": "void testProperty()"}, "TestMutableDateTime_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestMutableDateTime_Basics.testSerialization", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    MutableDateTime result = (MutableDateTime) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2444, "method_signature": "void testSerialization()"}, "TestMutableDateTime_Basics.testTest": {"callee_method_names": [], "method_name": "TestMutableDateTime_Basics.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2442, "method_signature": "void testTest()"}, "TestMutableDateTime_Basics.testToInstant": {"callee_method_names": ["MutableDateTime.toInstant", "Instant.getMillis"], "method_name": "TestMutableDateTime_Basics.testToInstant", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    Instant result = test.toInstant();\n    assertEquals(TEST_TIME1, result.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2446, "method_signature": "void testToInstant()"}, "TestMutableDateTime_Basics.testToString": {"callee_method_names": ["MutableDateTime.toString", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Basics.testToString", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME_NOW);\n    assertEquals(\"2002-06-09T01:00:00.000+01:00\", test.toString());\n    test = new MutableDateTime(TEST_TIME_NOW, PARIS);\n    assertEquals(\"2002-06-09T02:00:00.000+02:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2445, "method_signature": "void testToString()"}, "TestMutableDateTime_Constructors.testConstructor": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime();\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1259, "method_signature": "void testConstructor()"}, "TestMutableDateTime_Constructors.testConstructor_Chronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_Chronology", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1262, "method_signature": "void testConstructor_Chronology()"}, "TestMutableDateTime_Constructors.testConstructor_DateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_DateTimeZone", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1260, "method_signature": "void testConstructor_DateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_Object": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_Object", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    MutableDateTime test = new MutableDateTime(date);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1272, "method_signature": "void testConstructor_Object()"}, "TestMutableDateTime_Constructors.testConstructor_Object_Chronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_Object_Chronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    MutableDateTime test = new MutableDateTime(date, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1282, "method_signature": "void testConstructor_Object_Chronology()"}, "TestMutableDateTime_Constructors.testConstructor_Object_DateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_Object_DateTimeZone", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    MutableDateTime test = new MutableDateTime(date, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1276, "method_signature": "void testConstructor_Object_DateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_Object_nullChronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_Object_nullChronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    MutableDateTime test = new MutableDateTime(date, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1285, "method_signature": "void testConstructor_Object_nullChronology()"}, "TestMutableDateTime_Constructors.testConstructor_Object_nullDateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_Object_nullDateTimeZone", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    MutableDateTime test = new MutableDateTime(date, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1279, "method_signature": "void testConstructor_Object_nullDateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_badconverterObject": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_badconverterObject", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        MutableDateTime test = new MutableDateTime(new Integer(0));\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(0L, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null)\n */\n", "repo_name": "joda-time-main/", "id": 1275, "method_signature": "void testConstructor_badconverterObject()"}, "TestMutableDateTime_Constructors.testConstructor_badconverterObject_Chronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_badconverterObject_Chronology", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(0L, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1287, "method_signature": "void testConstructor_badconverterObject_Chronology()"}, "TestMutableDateTime_Constructors.testConstructor_badconverterObject_DateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_badconverterObject_DateTimeZone", "method_implementation": "{\n    try {\n        ConverterManager.getInstance().addInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n        MutableDateTime test = new MutableDateTime(new Integer(0), GregorianChronology.getInstance());\n        assertEquals(ISOChronology.getInstance(), test.getChronology());\n        assertEquals(0L, test.getMillis());\n    } finally {\n        ConverterManager.getInstance().removeInstantConverter(MockZeroNullIntegerConverter.INSTANCE);\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1281, "method_signature": "void testConstructor_badconverterObject_DateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getZone", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int", "method_implementation": "{\n    // +01:00\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(LONDON, test.getZone());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n    try {\n        new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 0, 9, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 13, 9, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 6, 0, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 6, 31, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new MutableDateTime(2002, 7, 31, 0, 0, 0, 0);\n    try {\n        new MutableDateTime(2002, 7, 32, 0, 0, 0, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1288, "method_signature": "void testConstructor_int_int_int_int_int_int_int()"}, "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_Chronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_Chronology", "method_implementation": "{\n    // +01:00\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n    try {\n        new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, GregorianChronology.getInstance());\n    try {\n        new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1291, "method_signature": "void testConstructor_int_int_int_int_int_int_int_Chronology()"}, "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_DateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_DateTimeZone", "method_implementation": "{\n    // +02:00\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 2, 0, 0, 0, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n    try {\n        new MutableDateTime(Integer.MIN_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(Integer.MAX_VALUE, 6, 9, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 0, 9, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 13, 9, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 6, 0, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new MutableDateTime(2002, 6, 31, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new MutableDateTime(2002, 7, 31, 0, 0, 0, 0, PARIS);\n    try {\n        new MutableDateTime(2002, 7, 32, 0, 0, 0, 0, PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1289, "method_signature": "void testConstructor_int_int_int_int_int_int_int_DateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullChronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullChronology", "method_implementation": "{\n    // +01:00\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1292, "method_signature": "void testConstructor_int_int_int_int_int_int_int_nullChronology()"}, "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullDateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_int_int_int_int_int_int_int_nullDateTimeZone", "method_implementation": "{\n    // +01:00\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 1, 0, 0, 0, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1290, "method_signature": "void testConstructor_int_int_int_int_int_int_int_nullDateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_invalidObject": {"callee_method_names": [], "method_name": "TestMutableDateTime_Constructors.testConstructor_invalidObject", "method_implementation": "{\n    try {\n        new MutableDateTime(new Object());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1273, "method_signature": "void testConstructor_invalidObject()"}, "TestMutableDateTime_Constructors.testConstructor_invalidObject_Chronology": {"callee_method_names": [], "method_name": "TestMutableDateTime_Constructors.testConstructor_invalidObject_Chronology", "method_implementation": "{\n    try {\n        new MutableDateTime(new Object(), GregorianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1283, "method_signature": "void testConstructor_invalidObject_Chronology()"}, "TestMutableDateTime_Constructors.testConstructor_invalidObject_DateTimeZone": {"callee_method_names": [], "method_name": "TestMutableDateTime_Constructors.testConstructor_invalidObject_DateTimeZone", "method_implementation": "{\n    try {\n        new MutableDateTime(new Object(), PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1277, "method_signature": "void testConstructor_invalidObject_DateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_long1": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_long1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1264, "method_signature": "void testConstructor_long1()"}, "TestMutableDateTime_Constructors.testConstructor_long1_Chronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_long1_Chronology", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1269, "method_signature": "void testConstructor_long1_Chronology()"}, "TestMutableDateTime_Constructors.testConstructor_long1_DateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_long1_DateTimeZone", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1266, "method_signature": "void testConstructor_long1_DateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_long2": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_long2", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME2);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME2, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1265, "method_signature": "void testConstructor_long2()"}, "TestMutableDateTime_Constructors.testConstructor_long2_Chronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_long2_Chronology", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME2, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME2, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1270, "method_signature": "void testConstructor_long2_Chronology()"}, "TestMutableDateTime_Constructors.testConstructor_long2_DateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_long2_DateTimeZone", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME2, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME2, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1267, "method_signature": "void testConstructor_long2_DateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_long_nullChronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_long_nullChronology", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1271, "method_signature": "void testConstructor_long_nullChronology()"}, "TestMutableDateTime_Constructors.testConstructor_long_nullDateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_long_nullDateTimeZone", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME1, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1268, "method_signature": "void testConstructor_long_nullDateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_nullChronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_nullChronology", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime((Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1263, "method_signature": "void testConstructor_nullChronology()"}, "TestMutableDateTime_Constructors.testConstructor_nullDateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_nullDateTimeZone", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime((DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1261, "method_signature": "void testConstructor_nullDateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_nullObject": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_nullObject", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime((Object) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null)\n */\n", "repo_name": "joda-time-main/", "id": 1274, "method_signature": "void testConstructor_nullObject()"}, "TestMutableDateTime_Constructors.testConstructor_nullObject_Chronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_nullObject_Chronology", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime((Object) null, GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1284, "method_signature": "void testConstructor_nullObject_Chronology()"}, "TestMutableDateTime_Constructors.testConstructor_nullObject_DateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_nullObject_DateTimeZone", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime((Object) null, PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1278, "method_signature": "void testConstructor_nullObject_DateTimeZone()"}, "TestMutableDateTime_Constructors.testConstructor_nullObject_nullChronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_nullObject_nullChronology", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime((Object) null, (Chronology) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1286, "method_signature": "void testConstructor_nullObject_nullChronology()"}, "TestMutableDateTime_Constructors.testConstructor_nullObject_nullDateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.testConstructor_nullObject_nullDateTimeZone", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime((Object) null, (DateTimeZone) null);\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1280, "method_signature": "void testConstructor_nullObject_nullDateTimeZone()"}, "TestMutableDateTime_Constructors.testTest": {"callee_method_names": [], "method_name": "TestMutableDateTime_Constructors.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1253, "method_signature": "void testTest()"}, "TestMutableDateTime_Constructors.test_now": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.test_now", "method_implementation": "{\n    MutableDateTime test = MutableDateTime.now();\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test now ()\n */\n", "repo_name": "joda-time-main/", "id": 1254, "method_signature": "void test_now()"}, "TestMutableDateTime_Constructors.test_now_Chronology": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.test_now_Chronology", "method_implementation": "{\n    MutableDateTime test = MutableDateTime.now(GregorianChronology.getInstance());\n    assertEquals(GregorianChronology.getInstance(), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test now (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1257, "method_signature": "void test_now_Chronology()"}, "TestMutableDateTime_Constructors.test_now_DateTimeZone": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.getMillis"], "method_name": "TestMutableDateTime_Constructors.test_now_DateTimeZone", "method_implementation": "{\n    MutableDateTime test = MutableDateTime.now(PARIS);\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n    assertEquals(TEST_TIME_NOW, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test now (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1255, "method_signature": "void test_now_DateTimeZone()"}, "TestMutableDateTime_Constructors.test_now_nullChronology": {"callee_method_names": [], "method_name": "TestMutableDateTime_Constructors.test_now_nullChronology", "method_implementation": "{\n    try {\n        MutableDateTime.now((Chronology) null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test now (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1258, "method_signature": "void test_now_nullChronology()"}, "TestMutableDateTime_Constructors.test_now_nullDateTimeZone": {"callee_method_names": [], "method_name": "TestMutableDateTime_Constructors.test_now_nullDateTimeZone", "method_implementation": "{\n    try {\n        MutableDateTime.now((DateTimeZone) null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test now (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1256, "method_signature": "void test_now_nullDateTimeZone()"}, "TestMutableDateTime_Properties.testPropertyGetCenturyOfEra": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.centuryOfEra", "MutableDateTime.centuryOfEra", "MutableDateTime.centuryOfEra", "MutableDateTime.centuryOfEra", "MutableDateTime.centuryOfEra", "MutableDateTime.centuryOfEra", "MutableDateTime.centuryOfEra", "MutableDateTime.centuryOfEra", "MutableDateTime.getChronology", "MutableDateTime.centuryOfEra", "MutableDateTime.getChronology", "MutableDateTime.centuryOfEra", "MutableDateTime.centuryOfEra", "MutableDateTime.centuryOfEra"], "method_name": "TestMutableDateTime_Properties.testPropertyGetCenturyOfEra", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().centuryOfEra(), test.centuryOfEra().getField());\n    assertEquals(\"centuryOfEra\", test.centuryOfEra().getName());\n    assertEquals(\"Property[centuryOfEra]\", test.centuryOfEra().toString());\n    assertEquals(20, test.centuryOfEra().get());\n    assertEquals(\"20\", test.centuryOfEra().getAsText());\n    assertEquals(\"20\", test.centuryOfEra().getAsText(Locale.FRENCH));\n    assertEquals(\"20\", test.centuryOfEra().getAsShortText());\n    assertEquals(\"20\", test.centuryOfEra().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().centuries(), test.centuryOfEra().getDurationField());\n    assertEquals(test.getChronology().eras(), test.centuryOfEra().getRangeDurationField());\n    assertEquals(7, test.centuryOfEra().getMaximumTextLength(null));\n    assertEquals(7, test.centuryOfEra().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1878, "method_signature": "void testPropertyGetCenturyOfEra()"}, "TestMutableDateTime_Properties.testPropertyGetDayOfMonth": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.getChronology", "MutableDateTime.dayOfMonth", "MutableDateTime.getChronology", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth", "MutableDateTime.dayOfMonth"], "method_name": "TestMutableDateTime_Properties.testPropertyGetDayOfMonth", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n    assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n    assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n    assertEquals(9, test.dayOfMonth().get());\n    assertEquals(\"9\", test.dayOfMonth().getAsText());\n    assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText());\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n    assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n    assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n    assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n    assertEquals(1, test.dayOfMonth().getMinimumValue());\n    assertEquals(1, test.dayOfMonth().getMinimumValueOverall());\n    assertEquals(30, test.dayOfMonth().getMaximumValue());\n    assertEquals(31, test.dayOfMonth().getMaximumValueOverall());\n    assertEquals(false, test.dayOfMonth().isLeap());\n    assertEquals(0, test.dayOfMonth().getLeapAmount());\n    assertEquals(null, test.dayOfMonth().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1883, "method_signature": "void testPropertyGetDayOfMonth()"}, "TestMutableDateTime_Properties.testPropertyGetDayOfWeek": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.getChronology", "MutableDateTime.dayOfWeek", "MutableDateTime.getChronology", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek", "MutableDateTime.dayOfWeek"], "method_name": "TestMutableDateTime_Properties.testPropertyGetDayOfWeek", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().dayOfWeek(), test.dayOfWeek().getField());\n    assertEquals(\"dayOfWeek\", test.dayOfWeek().getName());\n    assertEquals(\"Property[dayOfWeek]\", test.dayOfWeek().toString());\n    assertEquals(3, test.dayOfWeek().get());\n    assertEquals(\"Wednesday\", test.dayOfWeek().getAsText());\n    assertEquals(\"mercredi\", test.dayOfWeek().getAsText(Locale.FRENCH));\n    assertEquals(\"Wed\", test.dayOfWeek().getAsShortText());\n    assertEquals(\"mer.\", test.dayOfWeek().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfWeek().getDurationField());\n    assertEquals(test.getChronology().weeks(), test.dayOfWeek().getRangeDurationField());\n    assertEquals(9, test.dayOfWeek().getMaximumTextLength(null));\n    assertEquals(8, test.dayOfWeek().getMaximumTextLength(Locale.FRENCH));\n    assertEquals(3, test.dayOfWeek().getMaximumShortTextLength(null));\n    assertEquals(4, test.dayOfWeek().getMaximumShortTextLength(Locale.FRENCH));\n    assertEquals(1, test.dayOfWeek().getMinimumValue());\n    assertEquals(1, test.dayOfWeek().getMinimumValueOverall());\n    assertEquals(7, test.dayOfWeek().getMaximumValue());\n    assertEquals(7, test.dayOfWeek().getMaximumValueOverall());\n    assertEquals(false, test.dayOfWeek().isLeap());\n    assertEquals(0, test.dayOfWeek().getLeapAmount());\n    assertEquals(null, test.dayOfWeek().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1886, "method_signature": "void testPropertyGetDayOfWeek()"}, "TestMutableDateTime_Properties.testPropertyGetDayOfYear": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.getChronology", "MutableDateTime.dayOfYear", "MutableDateTime.getChronology", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear", "MutableDateTime.dayOfYear"], "method_name": "TestMutableDateTime_Properties.testPropertyGetDayOfYear", "method_implementation": "{\n    // 31+29+31+30+31+9 = 161\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().dayOfYear(), test.dayOfYear().getField());\n    assertEquals(\"dayOfYear\", test.dayOfYear().getName());\n    assertEquals(\"Property[dayOfYear]\", test.dayOfYear().toString());\n    assertEquals(161, test.dayOfYear().get());\n    assertEquals(\"161\", test.dayOfYear().getAsText());\n    assertEquals(\"161\", test.dayOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"161\", test.dayOfYear().getAsShortText());\n    assertEquals(\"161\", test.dayOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.dayOfYear().getRangeDurationField());\n    assertEquals(3, test.dayOfYear().getMaximumTextLength(null));\n    assertEquals(3, test.dayOfYear().getMaximumShortTextLength(null));\n    assertEquals(false, test.dayOfYear().isLeap());\n    assertEquals(0, test.dayOfYear().getLeapAmount());\n    assertEquals(null, test.dayOfYear().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1884, "method_signature": "void testPropertyGetDayOfYear()"}, "TestMutableDateTime_Properties.testPropertyGetEra": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.getChronology", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era", "MutableDateTime.era"], "method_name": "TestMutableDateTime_Properties.testPropertyGetEra", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().era(), test.era().getField());\n    assertEquals(\"era\", test.era().getName());\n    assertEquals(\"Property[era]\", test.era().toString());\n    assertSame(test, test.era().getMutableDateTime());\n    assertEquals(1, test.era().get());\n    assertEquals(\"AD\", test.era().getAsText());\n    assertEquals(\"ap. J.-C.\", test.era().getAsText(Locale.FRENCH));\n    assertEquals(\"AD\", test.era().getAsShortText());\n    assertEquals(\"ap. J.-C.\", test.era().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().eras(), test.era().getDurationField());\n    assertEquals(null, test.era().getRangeDurationField());\n    assertEquals(2, test.era().getMaximumTextLength(null));\n    assertEquals(9, test.era().getMaximumTextLength(Locale.FRENCH));\n    assertEquals(2, test.era().getMaximumShortTextLength(null));\n    assertEquals(9, test.era().getMaximumShortTextLength(Locale.FRENCH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1876, "method_signature": "void testPropertyGetEra()"}, "TestMutableDateTime_Properties.testPropertyGetHourOfDay": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.hourOfDay", "MutableDateTime.hourOfDay", "MutableDateTime.hourOfDay", "MutableDateTime.hourOfDay", "MutableDateTime.hourOfDay", "MutableDateTime.hourOfDay", "MutableDateTime.hourOfDay", "MutableDateTime.hourOfDay", "MutableDateTime.getChronology", "MutableDateTime.hourOfDay", "MutableDateTime.getChronology", "MutableDateTime.hourOfDay", "MutableDateTime.hourOfDay", "MutableDateTime.hourOfDay"], "method_name": "TestMutableDateTime_Properties.testPropertyGetHourOfDay", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n    assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n    assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n    assertEquals(13, test.hourOfDay().get());\n    assertEquals(\"13\", test.hourOfDay().getAsText());\n    assertEquals(\"13\", test.hourOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"13\", test.hourOfDay().getAsShortText());\n    assertEquals(\"13\", test.hourOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());\n    assertEquals(2, test.hourOfDay().getMaximumTextLength(null));\n    assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1887, "method_signature": "void testPropertyGetHourOfDay()"}, "TestMutableDateTime_Properties.testPropertyGetMillisOfDay": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.millisOfDay", "MutableDateTime.millisOfDay", "MutableDateTime.millisOfDay", "MutableDateTime.millisOfDay", "MutableDateTime.millisOfDay", "MutableDateTime.millisOfDay", "MutableDateTime.millisOfDay", "MutableDateTime.millisOfDay", "MutableDateTime.getChronology", "MutableDateTime.millisOfDay", "MutableDateTime.getChronology", "MutableDateTime.millisOfDay", "MutableDateTime.millisOfDay", "MutableDateTime.millisOfDay"], "method_name": "TestMutableDateTime_Properties.testPropertyGetMillisOfDay", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().millisOfDay(), test.millisOfDay().getField());\n    assertEquals(\"millisOfDay\", test.millisOfDay().getName());\n    assertEquals(\"Property[millisOfDay]\", test.millisOfDay().toString());\n    assertEquals(48223053, test.millisOfDay().get());\n    assertEquals(\"48223053\", test.millisOfDay().getAsText());\n    assertEquals(\"48223053\", test.millisOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"48223053\", test.millisOfDay().getAsShortText());\n    assertEquals(\"48223053\", test.millisOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().millis(), test.millisOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.millisOfDay().getRangeDurationField());\n    assertEquals(8, test.millisOfDay().getMaximumTextLength(null));\n    assertEquals(8, test.millisOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1893, "method_signature": "void testPropertyGetMillisOfDay()"}, "TestMutableDateTime_Properties.testPropertyGetMillisOfSecond": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.millisOfSecond", "MutableDateTime.millisOfSecond", "MutableDateTime.millisOfSecond", "MutableDateTime.millisOfSecond", "MutableDateTime.millisOfSecond", "MutableDateTime.millisOfSecond", "MutableDateTime.millisOfSecond", "MutableDateTime.millisOfSecond", "MutableDateTime.getChronology", "MutableDateTime.millisOfSecond", "MutableDateTime.getChronology", "MutableDateTime.millisOfSecond", "MutableDateTime.millisOfSecond", "MutableDateTime.millisOfSecond"], "method_name": "TestMutableDateTime_Properties.testPropertyGetMillisOfSecond", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n    assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n    assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n    assertEquals(53, test.millisOfSecond().get());\n    assertEquals(\"53\", test.millisOfSecond().getAsText());\n    assertEquals(\"53\", test.millisOfSecond().getAsText(Locale.FRENCH));\n    assertEquals(\"53\", test.millisOfSecond().getAsShortText());\n    assertEquals(\"53\", test.millisOfSecond().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());\n    assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());\n    assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));\n    assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1892, "method_signature": "void testPropertyGetMillisOfSecond()"}, "TestMutableDateTime_Properties.testPropertyGetMinuteOfDay": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.minuteOfDay", "MutableDateTime.minuteOfDay", "MutableDateTime.minuteOfDay", "MutableDateTime.minuteOfDay", "MutableDateTime.minuteOfDay", "MutableDateTime.minuteOfDay", "MutableDateTime.minuteOfDay", "MutableDateTime.minuteOfDay", "MutableDateTime.getChronology", "MutableDateTime.minuteOfDay", "MutableDateTime.getChronology", "MutableDateTime.minuteOfDay", "MutableDateTime.minuteOfDay", "MutableDateTime.minuteOfDay"], "method_name": "TestMutableDateTime_Properties.testPropertyGetMinuteOfDay", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().minuteOfDay(), test.minuteOfDay().getField());\n    assertEquals(\"minuteOfDay\", test.minuteOfDay().getName());\n    assertEquals(\"Property[minuteOfDay]\", test.minuteOfDay().toString());\n    assertEquals(803, test.minuteOfDay().get());\n    assertEquals(\"803\", test.minuteOfDay().getAsText());\n    assertEquals(\"803\", test.minuteOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"803\", test.minuteOfDay().getAsShortText());\n    assertEquals(\"803\", test.minuteOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().minutes(), test.minuteOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.minuteOfDay().getRangeDurationField());\n    assertEquals(4, test.minuteOfDay().getMaximumTextLength(null));\n    assertEquals(4, test.minuteOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1889, "method_signature": "void testPropertyGetMinuteOfDay()"}, "TestMutableDateTime_Properties.testPropertyGetMinuteOfHour": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.minuteOfHour", "MutableDateTime.minuteOfHour", "MutableDateTime.minuteOfHour", "MutableDateTime.minuteOfHour", "MutableDateTime.minuteOfHour", "MutableDateTime.minuteOfHour", "MutableDateTime.minuteOfHour", "MutableDateTime.minuteOfHour", "MutableDateTime.getChronology", "MutableDateTime.minuteOfHour", "MutableDateTime.getChronology", "MutableDateTime.minuteOfHour", "MutableDateTime.minuteOfHour", "MutableDateTime.minuteOfHour"], "method_name": "TestMutableDateTime_Properties.testPropertyGetMinuteOfHour", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n    assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n    assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n    assertEquals(23, test.minuteOfHour().get());\n    assertEquals(\"23\", test.minuteOfHour().getAsText());\n    assertEquals(\"23\", test.minuteOfHour().getAsText(Locale.FRENCH));\n    assertEquals(\"23\", test.minuteOfHour().getAsShortText());\n    assertEquals(\"23\", test.minuteOfHour().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());\n    assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());\n    assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));\n    assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1888, "method_signature": "void testPropertyGetMinuteOfHour()"}, "TestMutableDateTime_Properties.testPropertyGetMonthOfYear": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.getChronology", "MutableDateTime.monthOfYear", "MutableDateTime.getChronology", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear", "MutableDateTime.monthOfYear"], "method_name": "TestMutableDateTime_Properties.testPropertyGetMonthOfYear", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n    assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n    assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n    assertEquals(6, test.monthOfYear().get());\n    assertEquals(\"June\", test.monthOfYear().getAsText());\n    assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n    assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n    assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n    int max = test.monthOfYear().getMaximumShortTextLength(null);\n    // for JDK17+\n    assertTrue(max == 3 || max == 4);\n    test = new MutableDateTime(2004, 7, 9, 0, 0, 0, 0);\n    assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(1, test.monthOfYear().getMinimumValue());\n    assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n    assertEquals(12, test.monthOfYear().getMaximumValue());\n    assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n    assertEquals(1, test.monthOfYear().getMinimumValue());\n    assertEquals(1, test.monthOfYear().getMinimumValueOverall());\n    assertEquals(12, test.monthOfYear().getMaximumValue());\n    assertEquals(12, test.monthOfYear().getMaximumValueOverall());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1882, "method_signature": "void testPropertyGetMonthOfYear()"}, "TestMutableDateTime_Properties.testPropertyGetSecondOfDay": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.secondOfDay", "MutableDateTime.secondOfDay", "MutableDateTime.secondOfDay", "MutableDateTime.secondOfDay", "MutableDateTime.secondOfDay", "MutableDateTime.secondOfDay", "MutableDateTime.secondOfDay", "MutableDateTime.secondOfDay", "MutableDateTime.getChronology", "MutableDateTime.secondOfDay", "MutableDateTime.getChronology", "MutableDateTime.secondOfDay", "MutableDateTime.secondOfDay", "MutableDateTime.secondOfDay"], "method_name": "TestMutableDateTime_Properties.testPropertyGetSecondOfDay", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().secondOfDay(), test.secondOfDay().getField());\n    assertEquals(\"secondOfDay\", test.secondOfDay().getName());\n    assertEquals(\"Property[secondOfDay]\", test.secondOfDay().toString());\n    assertEquals(48223, test.secondOfDay().get());\n    assertEquals(\"48223\", test.secondOfDay().getAsText());\n    assertEquals(\"48223\", test.secondOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"48223\", test.secondOfDay().getAsShortText());\n    assertEquals(\"48223\", test.secondOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().seconds(), test.secondOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.secondOfDay().getRangeDurationField());\n    assertEquals(5, test.secondOfDay().getMaximumTextLength(null));\n    assertEquals(5, test.secondOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1891, "method_signature": "void testPropertyGetSecondOfDay()"}, "TestMutableDateTime_Properties.testPropertyGetSecondOfMinute": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.secondOfMinute", "MutableDateTime.secondOfMinute", "MutableDateTime.secondOfMinute", "MutableDateTime.secondOfMinute", "MutableDateTime.secondOfMinute", "MutableDateTime.secondOfMinute", "MutableDateTime.secondOfMinute", "MutableDateTime.secondOfMinute", "MutableDateTime.getChronology", "MutableDateTime.secondOfMinute", "MutableDateTime.getChronology", "MutableDateTime.secondOfMinute", "MutableDateTime.secondOfMinute", "MutableDateTime.secondOfMinute"], "method_name": "TestMutableDateTime_Properties.testPropertyGetSecondOfMinute", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);\n    assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n    assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n    assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n    assertEquals(43, test.secondOfMinute().get());\n    assertEquals(\"43\", test.secondOfMinute().getAsText());\n    assertEquals(\"43\", test.secondOfMinute().getAsText(Locale.FRENCH));\n    assertEquals(\"43\", test.secondOfMinute().getAsShortText());\n    assertEquals(\"43\", test.secondOfMinute().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());\n    assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());\n    assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));\n    assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1890, "method_signature": "void testPropertyGetSecondOfMinute()"}, "TestMutableDateTime_Properties.testPropertyGetWeekOfWeekyear": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.getChronology", "MutableDateTime.weekOfWeekyear", "MutableDateTime.getChronology", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear", "MutableDateTime.weekOfWeekyear"], "method_name": "TestMutableDateTime_Properties.testPropertyGetWeekOfWeekyear", "method_implementation": "{\n    // 2002-01-01 = Thu\n    // 2002-12-31 = Thu (+364 days)\n    // 2003-12-30 = Thu (+364 days)\n    // 2004-01-03 = Mon             W1\n    // 2004-01-31 = Mon (+28 days)  W5\n    // 2004-02-28 = Mon (+28 days)  W9\n    // 2004-03-27 = Mon (+28 days)  W13\n    // 2004-04-24 = Mon (+28 days)  W17\n    // 2004-05-23 = Mon (+28 days)  W21\n    // 2004-06-05 = Mon (+14 days)  W23\n    // 2004-06-09 = Fri\n    // 2004-12-25 = Mon             W52\n    // 2005-01-01 = Mon             W1\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().weekOfWeekyear(), test.weekOfWeekyear().getField());\n    assertEquals(\"weekOfWeekyear\", test.weekOfWeekyear().getName());\n    assertEquals(\"Property[weekOfWeekyear]\", test.weekOfWeekyear().toString());\n    assertEquals(24, test.weekOfWeekyear().get());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsText());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsText(Locale.FRENCH));\n    assertEquals(\"24\", test.weekOfWeekyear().getAsShortText());\n    assertEquals(\"24\", test.weekOfWeekyear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().weeks(), test.weekOfWeekyear().getDurationField());\n    assertEquals(test.getChronology().weekyears(), test.weekOfWeekyear().getRangeDurationField());\n    assertEquals(2, test.weekOfWeekyear().getMaximumTextLength(null));\n    assertEquals(2, test.weekOfWeekyear().getMaximumShortTextLength(null));\n    assertEquals(false, test.weekOfWeekyear().isLeap());\n    assertEquals(0, test.weekOfWeekyear().getLeapAmount());\n    assertEquals(null, test.weekOfWeekyear().getLeapDurationField());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1885, "method_signature": "void testPropertyGetWeekOfWeekyear()"}, "TestMutableDateTime_Properties.testPropertyGetWeekyear": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.weekyear", "MutableDateTime.weekyear", "MutableDateTime.weekyear", "MutableDateTime.weekyear", "MutableDateTime.weekyear", "MutableDateTime.weekyear", "MutableDateTime.weekyear", "MutableDateTime.weekyear", "MutableDateTime.getChronology", "MutableDateTime.weekyear", "MutableDateTime.weekyear", "MutableDateTime.weekyear", "MutableDateTime.weekyear"], "method_name": "TestMutableDateTime_Properties.testPropertyGetWeekyear", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().weekyear(), test.weekyear().getField());\n    assertEquals(\"weekyear\", test.weekyear().getName());\n    assertEquals(\"Property[weekyear]\", test.weekyear().toString());\n    assertEquals(2004, test.weekyear().get());\n    assertEquals(\"2004\", test.weekyear().getAsText());\n    assertEquals(\"2004\", test.weekyear().getAsText(Locale.FRENCH));\n    assertEquals(\"2004\", test.weekyear().getAsShortText());\n    assertEquals(\"2004\", test.weekyear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().weekyears(), test.weekyear().getDurationField());\n    assertEquals(null, test.weekyear().getRangeDurationField());\n    assertEquals(9, test.weekyear().getMaximumTextLength(null));\n    assertEquals(9, test.weekyear().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1880, "method_signature": "void testPropertyGetWeekyear()"}, "TestMutableDateTime_Properties.testPropertyGetYear": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.getChronology", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year", "MutableDateTime.year"], "method_name": "TestMutableDateTime_Properties.testPropertyGetYear", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().year(), test.year().getField());\n    assertEquals(\"year\", test.year().getName());\n    assertEquals(\"Property[year]\", test.year().toString());\n    assertEquals(2004, test.year().get());\n    assertEquals(\"2004\", test.year().getAsText());\n    assertEquals(\"2004\", test.year().getAsText(Locale.FRENCH));\n    assertEquals(\"2004\", test.year().getAsShortText());\n    assertEquals(\"2004\", test.year().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.year().getDurationField());\n    assertEquals(null, test.year().getRangeDurationField());\n    assertEquals(9, test.year().getMaximumTextLength(null));\n    assertEquals(9, test.year().getMaximumShortTextLength(null));\n    assertEquals(-292275054, test.year().getMinimumValue());\n    assertEquals(-292275054, test.year().getMinimumValueOverall());\n    assertEquals(292278993, test.year().getMaximumValue());\n    assertEquals(292278993, test.year().getMaximumValueOverall());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1881, "method_signature": "void testPropertyGetYear()"}, "TestMutableDateTime_Properties.testPropertyGetYearOfCentury": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.yearOfCentury", "MutableDateTime.yearOfCentury", "MutableDateTime.yearOfCentury", "MutableDateTime.yearOfCentury", "MutableDateTime.yearOfCentury", "MutableDateTime.yearOfCentury", "MutableDateTime.yearOfCentury", "MutableDateTime.yearOfCentury", "MutableDateTime.getChronology", "MutableDateTime.yearOfCentury", "MutableDateTime.getChronology", "MutableDateTime.yearOfCentury", "MutableDateTime.yearOfCentury", "MutableDateTime.yearOfCentury"], "method_name": "TestMutableDateTime_Properties.testPropertyGetYearOfCentury", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().yearOfCentury(), test.yearOfCentury().getField());\n    assertEquals(\"yearOfCentury\", test.yearOfCentury().getName());\n    assertEquals(\"Property[yearOfCentury]\", test.yearOfCentury().toString());\n    assertEquals(4, test.yearOfCentury().get());\n    assertEquals(\"4\", test.yearOfCentury().getAsText());\n    assertEquals(\"4\", test.yearOfCentury().getAsText(Locale.FRENCH));\n    assertEquals(\"4\", test.yearOfCentury().getAsShortText());\n    assertEquals(\"4\", test.yearOfCentury().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.yearOfCentury().getDurationField());\n    assertEquals(test.getChronology().centuries(), test.yearOfCentury().getRangeDurationField());\n    assertEquals(2, test.yearOfCentury().getMaximumTextLength(null));\n    assertEquals(2, test.yearOfCentury().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1879, "method_signature": "void testPropertyGetYearOfCentury()"}, "TestMutableDateTime_Properties.testPropertyGetYearOfEra": {"callee_method_names": ["MutableDateTime.getChronology", "MutableDateTime.yearOfEra", "MutableDateTime.yearOfEra", "MutableDateTime.yearOfEra", "MutableDateTime.yearOfEra", "MutableDateTime.yearOfEra", "MutableDateTime.yearOfEra", "MutableDateTime.yearOfEra", "MutableDateTime.yearOfEra", "MutableDateTime.getChronology", "MutableDateTime.yearOfEra", "MutableDateTime.getChronology", "MutableDateTime.yearOfEra", "MutableDateTime.yearOfEra", "MutableDateTime.yearOfEra"], "method_name": "TestMutableDateTime_Properties.testPropertyGetYearOfEra", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 0, 0, 0, 0);\n    assertSame(test.getChronology().yearOfEra(), test.yearOfEra().getField());\n    assertEquals(\"yearOfEra\", test.yearOfEra().getName());\n    assertEquals(\"Property[yearOfEra]\", test.yearOfEra().toString());\n    assertEquals(2004, test.yearOfEra().get());\n    assertEquals(\"2004\", test.yearOfEra().getAsText());\n    assertEquals(\"2004\", test.yearOfEra().getAsText(Locale.FRENCH));\n    assertEquals(\"2004\", test.yearOfEra().getAsShortText());\n    assertEquals(\"2004\", test.yearOfEra().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.yearOfEra().getDurationField());\n    assertEquals(test.getChronology().eras(), test.yearOfEra().getRangeDurationField());\n    assertEquals(9, test.yearOfEra().getMaximumTextLength(null));\n    assertEquals(9, test.yearOfEra().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1877, "method_signature": "void testPropertyGetYearOfEra()"}, "TestMutableDateTime_Properties.testPropertyToIntervalYearOfEra": {"callee_method_names": ["MutableDateTime.yearOfEra", "Interval.getStart", "Interval.getEnd"], "method_name": "TestMutableDateTime_Properties.testPropertyToIntervalYearOfEra", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2004, 6, 9, 13, 23, 43, 53);\n    Interval testInterval = test.yearOfEra().toInterval();\n    assertEquals(new MutableDateTime(2004, 1, 1, 0, 0, 0, 0), testInterval.getStart());\n    assertEquals(new MutableDateTime(2005, 1, 1, 0, 0, 0, 0), testInterval.getEnd());\n    assertEquals(new MutableDateTime(2004, 6, 9, 13, 23, 43, 53), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1894, "method_signature": "void testPropertyToIntervalYearOfEra()"}, "TestMutableDateTime_Properties.testTest": {"callee_method_names": [], "method_name": "TestMutableDateTime_Properties.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1875, "method_signature": "void testTest()"}, "TestMutableDateTime_Sets.testSetChronology_Chronology1": {"callee_method_names": ["MutableDateTime.setChronology", "MutableDateTime.getMillis", "MutableDateTime.getChronology"], "method_name": "TestMutableDateTime_Sets.testSetChronology_Chronology1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.setChronology(GregorianChronology.getInstance(PARIS));\n    assertEquals(TEST_TIME1, test.getMillis());\n    assertEquals(GregorianChronology.getInstance(PARIS), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1600, "method_signature": "void testSetChronology_Chronology1()"}, "TestMutableDateTime_Sets.testSetDateTime_int_int_int_int_int_int_int1": {"callee_method_ids": [679], "callee_method_names": ["MutableDateTime.setDateTime", "MutableDateTime.getYear", "MutableDateTime.getMonthOfYear", "MutableDateTime.getDayOfMonth", "MutableDateTime.getHourOfDay", "MutableDateTime.getMinuteOfHour", "MutableDateTime.getSecondOfMinute", "MutableDateTime.getMillisOfSecond"], "method_name": "TestMutableDateTime_Sets.testSetDateTime_int_int_int_int_int_int_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);\n    test.setDateTime(2010, 12, 3, 5, 6, 7, 8);\n    assertEquals(2010, test.getYear());\n    assertEquals(12, test.getMonthOfYear());\n    assertEquals(3, test.getDayOfMonth());\n    assertEquals(5, test.getHourOfDay());\n    assertEquals(6, test.getMinuteOfHour());\n    assertEquals(7, test.getSecondOfMinute());\n    assertEquals(8, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1611, "method_signature": "void testSetDateTime_int_int_int_int_int_int_int1()"}, "TestMutableDateTime_Sets.testSetDate_RI1": {"callee_method_ids": [676], "callee_method_names": ["MutableDateTime.setDate", "MutableDateTime.getYear", "MutableDateTime.getMonthOfYear", "MutableDateTime.getDayOfMonth", "MutableDateTime.getHourOfDay", "MutableDateTime.getMinuteOfHour", "MutableDateTime.getSecondOfMinute", "MutableDateTime.getMillisOfSecond"], "method_name": "TestMutableDateTime_Sets.testSetDate_RI1", "method_implementation": "{\n    DateTime setter = new DateTime(2010, 12, 3, 5, 7, 9, 501);\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);\n    test.setDate(setter);\n    assertEquals(2010, test.getYear());\n    assertEquals(12, test.getMonthOfYear());\n    assertEquals(3, test.getDayOfMonth());\n    assertEquals(12, test.getHourOfDay());\n    assertEquals(24, test.getMinuteOfHour());\n    assertEquals(48, test.getSecondOfMinute());\n    assertEquals(501, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1607, "method_signature": "void testSetDate_RI1()"}, "TestMutableDateTime_Sets.testSetDate_int_int_int1": {"callee_method_ids": [676], "callee_method_names": ["MutableDateTime.setDate", "MutableDateTime.getYear", "MutableDateTime.getMonthOfYear", "MutableDateTime.getDayOfMonth", "MutableDateTime.getHourOfDay", "MutableDateTime.getMinuteOfHour", "MutableDateTime.getSecondOfMinute", "MutableDateTime.getMillisOfSecond"], "method_name": "TestMutableDateTime_Sets.testSetDate_int_int_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);\n    test.setDate(2010, 12, 3);\n    assertEquals(2010, test.getYear());\n    assertEquals(12, test.getMonthOfYear());\n    assertEquals(3, test.getDayOfMonth());\n    assertEquals(12, test.getHourOfDay());\n    assertEquals(24, test.getMinuteOfHour());\n    assertEquals(48, test.getSecondOfMinute());\n    assertEquals(501, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1605, "method_signature": "void testSetDate_int_int_int1()"}, "TestMutableDateTime_Sets.testSetDate_long1": {"callee_method_ids": [676], "callee_method_names": ["MutableDateTime.setDate", "MutableDateTime.getYear", "MutableDateTime.getMonthOfYear", "MutableDateTime.getDayOfMonth", "MutableDateTime.getHourOfDay", "MutableDateTime.getMinuteOfHour", "MutableDateTime.getSecondOfMinute", "MutableDateTime.getMillisOfSecond"], "method_name": "TestMutableDateTime_Sets.testSetDate_long1", "method_implementation": "{\n    long setter = new DateTime(2010, 12, 3, 5, 7, 9, 501).getMillis();\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);\n    test.setDate(setter);\n    assertEquals(2010, test.getYear());\n    assertEquals(12, test.getMonthOfYear());\n    assertEquals(3, test.getDayOfMonth());\n    assertEquals(12, test.getHourOfDay());\n    assertEquals(24, test.getMinuteOfHour());\n    assertEquals(48, test.getSecondOfMinute());\n    assertEquals(501, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1606, "method_signature": "void testSetDate_long1()"}, "TestMutableDateTime_Sets.testSetDayOfMonth_int1": {"callee_method_names": ["MutableDateTime.setDayOfMonth", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetDayOfMonth_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setDayOfMonth(17);\n    assertEquals(\"2002-06-17T05:06:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1614, "method_signature": "void testSetDayOfMonth_int1()"}, "TestMutableDateTime_Sets.testSetDayOfWeek_int1": {"callee_method_names": ["MutableDateTime.setDayOfWeek", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetDayOfWeek_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setDayOfWeek(5);\n    assertEquals(\"2002-06-07T05:06:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1618, "method_signature": "void testSetDayOfWeek_int1()"}, "TestMutableDateTime_Sets.testSetDayOfYear_int1": {"callee_method_names": ["MutableDateTime.setDayOfYear", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetDayOfYear_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setDayOfYear(3);\n    assertEquals(\"2002-01-03T05:06:07.008Z\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1615, "method_signature": "void testSetDayOfYear_int1()"}, "TestMutableDateTime_Sets.testSetHourOfDay_int1": {"callee_method_names": ["MutableDateTime.setHourOfDay", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetHourOfDay_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setHourOfDay(13);\n    assertEquals(\"2002-06-09T13:06:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1619, "method_signature": "void testSetHourOfDay_int1()"}, "TestMutableDateTime_Sets.testSetMilliOfDay_int1": {"callee_method_names": ["MutableDateTime.setMillisOfDay", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetMilliOfDay_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setMillisOfDay(13);\n    assertEquals(\"2002-06-09T00:00:00.013+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1625, "method_signature": "void testSetMilliOfDay_int1()"}, "TestMutableDateTime_Sets.testSetMilliOfSecond_int1": {"callee_method_names": ["MutableDateTime.setMillisOfSecond", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetMilliOfSecond_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setMillisOfSecond(13);\n    assertEquals(\"2002-06-09T05:06:07.013+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1624, "method_signature": "void testSetMilliOfSecond_int1()"}, "TestMutableDateTime_Sets.testSetMillis_RI1": {"callee_method_ids": [659], "callee_method_names": ["MutableDateTime.setMillis", "MutableDateTime.getMillis", "MutableDateTime.getChronology"], "method_name": "TestMutableDateTime_Sets.testSetMillis_RI1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1, BuddhistChronology.getInstance());\n    test.setMillis(new Instant(TEST_TIME2));\n    assertEquals(TEST_TIME2, test.getMillis());\n    assertEquals(BuddhistChronology.getInstance(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1603, "method_signature": "void testSetMillis_RI1()"}, "TestMutableDateTime_Sets.testSetMillis_long1": {"callee_method_ids": [659], "callee_method_names": ["MutableDateTime.setMillis", "MutableDateTime.getMillis", "MutableDateTime.getChronology"], "method_name": "TestMutableDateTime_Sets.testSetMillis_long1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.setMillis(TEST_TIME2);\n    assertEquals(TEST_TIME2, test.getMillis());\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1599, "method_signature": "void testSetMillis_long1()"}, "TestMutableDateTime_Sets.testSetMinuteOfDay_int1": {"callee_method_names": ["MutableDateTime.setMinuteOfDay", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetMinuteOfDay_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setMinuteOfDay(13);\n    assertEquals(\"2002-06-09T00:13:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1621, "method_signature": "void testSetMinuteOfDay_int1()"}, "TestMutableDateTime_Sets.testSetMinuteOfHour_int1": {"callee_method_names": ["MutableDateTime.setMinuteOfHour", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetMinuteOfHour_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setMinuteOfHour(13);\n    assertEquals(\"2002-06-09T05:13:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1620, "method_signature": "void testSetMinuteOfHour_int1()"}, "TestMutableDateTime_Sets.testSetMonthOfYear_int1": {"callee_method_names": ["MutableDateTime.setMonthOfYear", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetMonthOfYear_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setMonthOfYear(12);\n    assertEquals(\"2002-12-09T05:06:07.008Z\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1613, "method_signature": "void testSetMonthOfYear_int1()"}, "TestMutableDateTime_Sets.testSetSecondOfDay_int1": {"callee_method_names": ["MutableDateTime.setSecondOfDay", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetSecondOfDay_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setSecondOfDay(13);\n    assertEquals(\"2002-06-09T00:00:13.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1623, "method_signature": "void testSetSecondOfDay_int1()"}, "TestMutableDateTime_Sets.testSetSecondOfMinute_int1": {"callee_method_names": ["MutableDateTime.setSecondOfMinute", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetSecondOfMinute_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setSecondOfMinute(13);\n    assertEquals(\"2002-06-09T05:06:13.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1622, "method_signature": "void testSetSecondOfMinute_int1()"}, "TestMutableDateTime_Sets.testSetTime_RI1": {"callee_method_ids": [678], "callee_method_names": ["MutableDateTime.setTime", "MutableDateTime.getYear", "MutableDateTime.getMonthOfYear", "MutableDateTime.getDayOfMonth", "MutableDateTime.getHourOfDay", "MutableDateTime.getMinuteOfHour", "MutableDateTime.getSecondOfMinute", "MutableDateTime.getMillisOfSecond"], "method_name": "TestMutableDateTime_Sets.testSetTime_RI1", "method_implementation": "{\n    DateTime setter = new DateTime(2010, 12, 3, 5, 7, 9, 11);\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);\n    test.setTime(setter);\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(5, test.getHourOfDay());\n    assertEquals(7, test.getMinuteOfHour());\n    assertEquals(9, test.getSecondOfMinute());\n    assertEquals(11, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1610, "method_signature": "void testSetTime_RI1()"}, "TestMutableDateTime_Sets.testSetTime_int_int_int_int1": {"callee_method_ids": [678], "callee_method_names": ["MutableDateTime.setTime", "MutableDateTime.getYear", "MutableDateTime.getMonthOfYear", "MutableDateTime.getDayOfMonth", "MutableDateTime.getHourOfDay", "MutableDateTime.getMinuteOfHour", "MutableDateTime.getSecondOfMinute", "MutableDateTime.getMillisOfSecond"], "method_name": "TestMutableDateTime_Sets.testSetTime_int_int_int_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);\n    test.setTime(5, 6, 7, 8);\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(5, test.getHourOfDay());\n    assertEquals(6, test.getMinuteOfHour());\n    assertEquals(7, test.getSecondOfMinute());\n    assertEquals(8, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1608, "method_signature": "void testSetTime_int_int_int_int1()"}, "TestMutableDateTime_Sets.testSetTime_long1": {"callee_method_ids": [678], "callee_method_names": ["MutableDateTime.setTime", "MutableDateTime.getYear", "MutableDateTime.getMonthOfYear", "MutableDateTime.getDayOfMonth", "MutableDateTime.getHourOfDay", "MutableDateTime.getMinuteOfHour", "MutableDateTime.getSecondOfMinute", "MutableDateTime.getMillisOfSecond"], "method_name": "TestMutableDateTime_Sets.testSetTime_long1", "method_implementation": "{\n    long setter = new DateTime(2010, 12, 3, 5, 7, 9, 11).getMillis();\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 12, 24, 48, 501);\n    test.setTime(setter);\n    assertEquals(2002, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    assertEquals(5, test.getHourOfDay());\n    assertEquals(7, test.getMinuteOfHour());\n    assertEquals(9, test.getSecondOfMinute());\n    assertEquals(11, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1609, "method_signature": "void testSetTime_long1()"}, "TestMutableDateTime_Sets.testSetWeekOfWeekyear_int1": {"callee_method_names": ["MutableDateTime.setWeekOfWeekyear", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetWeekOfWeekyear_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setWeekOfWeekyear(2);\n    assertEquals(\"2002-01-13T05:06:07.008Z\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1617, "method_signature": "void testSetWeekOfWeekyear_int1()"}, "TestMutableDateTime_Sets.testSetWeekyear_int1": {"callee_method_names": ["MutableDateTime.setWeekyear", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetWeekyear_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setWeekyear(2001);\n    assertEquals(\"2001-06-10T05:06:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1616, "method_signature": "void testSetWeekyear_int1()"}, "TestMutableDateTime_Sets.testSetYear_int1": {"callee_method_names": ["MutableDateTime.setYear", "MutableDateTime.toString"], "method_name": "TestMutableDateTime_Sets.testSetYear_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(2002, 6, 9, 5, 6, 7, 8);\n    test.setYear(2010);\n    assertEquals(\"2010-06-09T05:06:07.008+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1612, "method_signature": "void testSetYear_int1()"}, "TestMutableDateTime_Sets.testSetZoneRetainFields_DateTimeZone1": {"callee_method_ids": [663], "callee_method_names": ["MutableDateTime.setZoneRetainFields", "MutableDateTime.getMillis", "MutableDateTime.getChronology"], "method_name": "TestMutableDateTime_Sets.testSetZoneRetainFields_DateTimeZone1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.setZoneRetainFields(PARIS);\n    assertEquals(TEST_TIME1 - DateTimeConstants.MILLIS_PER_HOUR, test.getMillis());\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1602, "method_signature": "void testSetZoneRetainFields_DateTimeZone1()"}, "TestMutableDateTime_Sets.testSetZone_DateTimeZone1": {"callee_method_ids": [662], "callee_method_names": ["MutableDateTime.setZone", "MutableDateTime.getMillis", "MutableDateTime.getChronology"], "method_name": "TestMutableDateTime_Sets.testSetZone_DateTimeZone1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.setZone(PARIS);\n    assertEquals(TEST_TIME1, test.getMillis());\n    assertEquals(ISOChronology.getInstance(PARIS), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1601, "method_signature": "void testSetZone_DateTimeZone1()"}, "TestMutableDateTime_Sets.testSet_DateTimeFieldType_int1": {"callee_method_ids": [664], "callee_method_names": ["MutableDateTime.set", "MutableDateTime.getYear"], "method_name": "TestMutableDateTime_Sets.testSet_DateTimeFieldType_int1", "method_implementation": "{\n    MutableDateTime test = new MutableDateTime(TEST_TIME1);\n    test.set(DateTimeFieldType.year(), 2010);\n    assertEquals(2010, test.getYear());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1604, "method_signature": "void testSet_DateTimeFieldType_int1()"}, "TestMutableDateTime_Sets.testTest": {"callee_method_names": [], "method_name": "TestMutableDateTime_Sets.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1598, "method_signature": "void testTest()"}, "TestMutableInterval_Basics.testContains_RInterval": {"callee_method_names": ["MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains"], "method_name": "TestMutableInterval_Basics.testContains_RInterval", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME1)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME1)));\n    assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME1 + 1)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME1 + 1)));\n    assertEquals(true, test.contains(new Interval(TEST_TIME1 + 1, TEST_TIME1 + 1)));\n    assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2)));\n    assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2)));\n    assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2)));\n    assertEquals(true, test.contains(new Interval(TEST_TIME1, TEST_TIME2 - 1)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 - 1)));\n    assertEquals(true, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 - 1)));\n    assertEquals(true, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 - 1)));\n    assertEquals(true, test.contains(new Interval(TEST_TIME2 - 2, TEST_TIME2 - 1)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME1, TEST_TIME2 + 1)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2, TEST_TIME2 + 1)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME2, TEST_TIME2 + 1)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME2 - 1, TEST_TIME2 + 1)));\n    assertEquals(false, test.contains(new Interval(TEST_TIME1 - 2, TEST_TIME1 - 1)));\n    assertEquals(true, test.contains((ReadableInterval) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1898, "method_signature": "void testContains_RInterval()"}, "TestMutableInterval_Basics.testContains_long": {"callee_method_names": ["MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains", "MutableInterval.contains"], "method_name": "TestMutableInterval_Basics.testContains_long", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    assertEquals(true, test.contains(TEST_TIME1));\n    assertEquals(false, test.contains(TEST_TIME1 - 1));\n    assertEquals(true, test.contains(TEST_TIME1 + (TEST_TIME2 - TEST_TIME1) / 2));\n    assertEquals(false, test.contains(TEST_TIME2));\n    assertEquals(true, test.contains(TEST_TIME2 - 1));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1897, "method_signature": "void testContains_long()"}, "TestMutableInterval_Basics.testCopy": {"callee_method_names": ["MutableInterval.copy"], "method_name": "TestMutableInterval_Basics.testCopy", "method_implementation": "{\n    MutableInterval test = new MutableInterval(123L, 456L, COPTIC_PARIS);\n    MutableInterval cloned = test.copy();\n    assertEquals(test, cloned);\n    assertNotSame(test, cloned);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1907, "method_signature": "void testCopy()"}, "TestMutableInterval_Basics.testGetMillis": {"callee_method_names": ["MutableInterval.getStartMillis", "MutableInterval.getStart", "MutableInterval.getEndMillis", "MutableInterval.getEnd", "MutableInterval.toDurationMillis", "MutableInterval.toDuration"], "method_name": "TestMutableInterval_Basics.testGetMillis", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    assertEquals(TEST_TIME1, test.getStartMillis());\n    assertEquals(TEST_TIME1, test.getStart().getMillis());\n    assertEquals(TEST_TIME2, test.getEndMillis());\n    assertEquals(TEST_TIME2, test.getEnd().getMillis());\n    assertEquals(TEST_TIME2 - TEST_TIME1, test.toDurationMillis());\n    assertEquals(TEST_TIME2 - TEST_TIME1, test.toDuration().getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1896, "method_signature": "void testGetMillis()"}, "TestMutableInterval_Basics.testIsAfter_long": {"callee_method_names": ["MutableInterval.isAfter", "MutableInterval.isAfter", "MutableInterval.isAfter", "MutableInterval.isAfter", "MutableInterval.isAfter", "MutableInterval.isAfter"], "method_name": "TestMutableInterval_Basics.testIsAfter_long", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    assertEquals(true, test.isAfter(TEST_TIME1 - 1));\n    assertEquals(false, test.isAfter(TEST_TIME1));\n    assertEquals(false, test.isAfter(TEST_TIME1 + 1));\n    assertEquals(false, test.isAfter(TEST_TIME2 - 1));\n    assertEquals(false, test.isAfter(TEST_TIME2));\n    assertEquals(false, test.isAfter(TEST_TIME2 + 1));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1900, "method_signature": "void testIsAfter_long()"}, "TestMutableInterval_Basics.testIsBefore_long": {"callee_method_names": ["MutableInterval.isBefore", "MutableInterval.isBefore", "MutableInterval.isBefore", "MutableInterval.isBefore", "MutableInterval.isBefore", "MutableInterval.isBefore"], "method_name": "TestMutableInterval_Basics.testIsBefore_long", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    assertEquals(false, test.isBefore(TEST_TIME1 - 1));\n    assertEquals(false, test.isBefore(TEST_TIME1));\n    assertEquals(false, test.isBefore(TEST_TIME1 + 1));\n    assertEquals(false, test.isBefore(TEST_TIME2 - 1));\n    assertEquals(true, test.isBefore(TEST_TIME2));\n    assertEquals(true, test.isBefore(TEST_TIME2 + 1));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1899, "method_signature": "void testIsBefore_long()"}, "TestMutableInterval_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestMutableInterval_Basics.testSerialization", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    MutableInterval result = (MutableInterval) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1905, "method_signature": "void testSerialization()"}, "TestMutableInterval_Basics.testTest": {"callee_method_names": [], "method_name": "TestMutableInterval_Basics.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1895, "method_signature": "void testTest()"}, "TestMutableInterval_Basics.testToInterval1": {"callee_method_names": ["MutableInterval.toInterval"], "method_name": "TestMutableInterval_Basics.testToInterval1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    Interval result = test.toInterval();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1901, "method_signature": "void testToInterval1()"}, "TestMutableInterval_Basics.testToMutableInterval1": {"callee_method_names": ["MutableInterval.toMutableInterval"], "method_name": "TestMutableInterval_Basics.testToMutableInterval1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2, COPTIC_PARIS);\n    MutableInterval result = test.toMutableInterval();\n    assertEquals(test, result);\n    assertNotSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1902, "method_signature": "void testToMutableInterval1()"}, "TestMutableInterval_Basics.testToPeriod": {"callee_method_names": ["MutableInterval.toPeriod"], "method_name": "TestMutableInterval_Basics.testToPeriod", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS);\n    DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS);\n    MutableInterval base = new MutableInterval(dt1, dt2);\n    Period test = base.toPeriod();\n    Period expected = new Period(dt1, dt2, PeriodType.standard());\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1903, "method_signature": "void testToPeriod()"}, "TestMutableInterval_Basics.testToPeriod_PeriodType1": {"callee_method_names": ["MutableInterval.toPeriod"], "method_name": "TestMutableInterval_Basics.testToPeriod_PeriodType1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, COPTIC_PARIS);\n    DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, COPTIC_PARIS);\n    MutableInterval base = new MutableInterval(dt1, dt2);\n    Period test = base.toPeriod(null);\n    Period expected = new Period(dt1, dt2, PeriodType.standard());\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1904, "method_signature": "void testToPeriod_PeriodType1()"}, "TestMutableInterval_Basics.testToString": {"callee_method_names": ["MutableInterval.toString"], "method_name": "TestMutableInterval_Basics.testToString", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 7, 8, 9, 10, DateTimeZone.UTC);\n    DateTime dt2 = new DateTime(2005, 8, 13, 12, 14, 16, 18, DateTimeZone.UTC);\n    MutableInterval test = new MutableInterval(dt1, dt2);\n    assertEquals(\"2004-06-09T07:08:09.010Z/2005-08-13T12:14:16.018Z\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1906, "method_signature": "void testToString()"}, "TestMutableInterval_Constructors.testConstructor": {"callee_method_names": ["MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Constructors.testConstructor", "method_implementation": "{\n    MutableInterval test = new MutableInterval();\n    assertEquals(0L, test.getStartMillis());\n    assertEquals(0L, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1833, "method_signature": "void testConstructor()"}, "TestMutableInterval_Constructors.testConstructor_Object1": {"callee_method_names": ["DateTime.toString", "DateTime.toString", "DateTime.getMillis", "MutableInterval.getStartMillis", "DateTime.getMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Constructors.testConstructor_Object1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    MutableInterval test = new MutableInterval(dt1.toString() + '/' + dt2.toString());\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1841, "method_signature": "void testConstructor_Object1()"}, "TestMutableInterval_Constructors.testConstructor_Object_Chronology1": {"callee_method_names": ["DateTime.getMillis", "MutableInterval.getStartMillis", "DateTime.getMillis", "MutableInterval.getEndMillis", "MutableInterval.getChronology"], "method_name": "TestMutableInterval_Constructors.testConstructor_Object_Chronology1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Interval base = new Interval(dt1, dt2);\n    MutableInterval test = new MutableInterval(base, BuddhistChronology.getInstance());\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n    assertEquals(BuddhistChronology.getInstance(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1842, "method_signature": "void testConstructor_Object_Chronology1()"}, "TestMutableInterval_Constructors.testConstructor_RD_RI1": {"callee_method_names": ["MutableInterval.getStartMillis", "DateTime.getMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Constructors.testConstructor_RD_RI1", "method_implementation": "{\n    long result = TEST_TIME_NOW;\n    result = ISOChronology.getInstance().months().add(result, -6);\n    result = ISOChronology.getInstance().hours().add(result, -1);\n    DateTime dt = new DateTime(TEST_TIME_NOW);\n    Duration dur = new Duration(TEST_TIME_NOW - result);\n    MutableInterval test = new MutableInterval(dur, dt);\n    assertEquals(result, test.getStartMillis());\n    assertEquals(dt.getMillis(), test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1840, "method_signature": "void testConstructor_RD_RI1()"}, "TestMutableInterval_Constructors.testConstructor_RI_RD1": {"callee_method_names": ["DateTime.getMillis", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Constructors.testConstructor_RI_RD1", "method_implementation": "{\n    long result = TEST_TIME_NOW;\n    result = ISOChronology.getInstance().months().add(result, 6);\n    result = ISOChronology.getInstance().hours().add(result, 1);\n    DateTime dt = new DateTime(TEST_TIME_NOW);\n    Duration dur = new Duration(result - TEST_TIME_NOW);\n    MutableInterval test = new MutableInterval(dt, dur);\n    assertEquals(dt.getMillis(), test.getStartMillis());\n    assertEquals(result, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1839, "method_signature": "void testConstructor_RI_RD1()"}, "TestMutableInterval_Constructors.testConstructor_RI_RI1": {"callee_method_names": ["DateTime.getMillis", "MutableInterval.getStartMillis", "DateTime.getMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Constructors.testConstructor_RI_RI1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    MutableInterval test = new MutableInterval(dt1, dt2);\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1836, "method_signature": "void testConstructor_RI_RI1()"}, "TestMutableInterval_Constructors.testConstructor_RI_RP1": {"callee_method_names": ["DateTime.getMillis", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Constructors.testConstructor_RI_RP1", "method_implementation": "{\n    DateTime dt = new DateTime(TEST_TIME_NOW);\n    Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n    long result = TEST_TIME_NOW;\n    result = ISOChronology.getInstance().months().add(result, 6);\n    result = ISOChronology.getInstance().hours().add(result, 1);\n    MutableInterval test = new MutableInterval(dt, dur);\n    assertEquals(dt.getMillis(), test.getStartMillis());\n    assertEquals(result, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1837, "method_signature": "void testConstructor_RI_RP1()"}, "TestMutableInterval_Constructors.testConstructor_RP_RI1": {"callee_method_names": ["MutableInterval.getStartMillis", "DateTime.getMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Constructors.testConstructor_RP_RI1", "method_implementation": "{\n    DateTime dt = new DateTime(TEST_TIME_NOW);\n    Period dur = new Period(0, 6, 0, 0, 1, 0, 0, 0);\n    long result = TEST_TIME_NOW;\n    result = ISOChronology.getInstance().months().add(result, -6);\n    result = ISOChronology.getInstance().hours().add(result, -1);\n    MutableInterval test = new MutableInterval(dur, dt);\n    assertEquals(result, test.getStartMillis());\n    assertEquals(dt.getMillis(), test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1838, "method_signature": "void testConstructor_RP_RI1()"}, "TestMutableInterval_Constructors.testConstructor_long_long1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "MutableInterval.getStartMillis", "DateTime.getMillis", "MutableInterval.getEndMillis", "MutableInterval.getChronology"], "method_name": "TestMutableInterval_Constructors.testConstructor_long_long1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis());\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n    assertEquals(ISOChronology.getInstance(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1834, "method_signature": "void testConstructor_long_long1()"}, "TestMutableInterval_Constructors.testConstructor_long_long_Chronology1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "MutableInterval.getStartMillis", "DateTime.getMillis", "MutableInterval.getEndMillis", "MutableInterval.getChronology"], "method_name": "TestMutableInterval_Constructors.testConstructor_long_long_Chronology1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    MutableInterval test = new MutableInterval(dt1.getMillis(), dt2.getMillis(), GJChronology.getInstance());\n    assertEquals(dt1.getMillis(), test.getStartMillis());\n    assertEquals(dt2.getMillis(), test.getEndMillis());\n    assertEquals(GJChronology.getInstance(), test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1835, "method_signature": "void testConstructor_long_long_Chronology1()"}, "TestMutableInterval_Constructors.testParse_noFormatter": {"callee_method_names": [], "method_name": "TestMutableInterval_Constructors.testParse_noFormatter", "method_implementation": "{\n    DateTime start = new DateTime(2010, 6, 30, 12, 30, ISOChronology.getInstance(PARIS));\n    DateTime end = new DateTime(2010, 7, 1, 14, 30, ISOChronology.getInstance(PARIS));\n    assertEquals(new MutableInterval(start, end), MutableInterval.parse(\"2010-06-30T12:30/2010-07-01T14:30\"));\n    assertEquals(new MutableInterval(start, end), MutableInterval.parse(\"2010-06-30T12:30/P1DT2H\"));\n    assertEquals(new MutableInterval(start, end), MutableInterval.parse(\"P1DT2H/2010-07-01T14:30\"));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1832, "method_signature": "void testParse_noFormatter()"}, "TestMutableInterval_Constructors.testTest": {"callee_method_names": [], "method_name": "TestMutableInterval_Constructors.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1831, "method_signature": "void testTest()"}, "TestMutableInterval_Updates.testSetDurationAfterStart_RI1": {"callee_method_names": ["MutableInterval.setDurationAfterStart", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetDurationAfterStart_RI1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setDurationAfterStart(new Duration(123L));\n    assertEquals(TEST_TIME1, test.getStartMillis());\n    assertEquals(TEST_TIME1 + 123L, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2580, "method_signature": "void testSetDurationAfterStart_RI1()"}, "TestMutableInterval_Updates.testSetDurationAfterStart_long1": {"callee_method_names": ["MutableInterval.setDurationAfterStart", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetDurationAfterStart_long1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setDurationAfterStart(123L);\n    assertEquals(TEST_TIME1, test.getStartMillis());\n    assertEquals(TEST_TIME1 + 123L, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2579, "method_signature": "void testSetDurationAfterStart_long1()"}, "TestMutableInterval_Updates.testSetDurationBeforeEnd_RI1": {"callee_method_names": ["MutableInterval.setDurationBeforeEnd", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetDurationBeforeEnd_RI1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setDurationBeforeEnd(new Duration(123L));\n    assertEquals(TEST_TIME2 - 123L, test.getStartMillis());\n    assertEquals(TEST_TIME2, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2582, "method_signature": "void testSetDurationBeforeEnd_RI1()"}, "TestMutableInterval_Updates.testSetDurationBeforeEnd_long1": {"callee_method_names": ["MutableInterval.setDurationBeforeEnd", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetDurationBeforeEnd_long1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setDurationBeforeEnd(123L);\n    assertEquals(TEST_TIME2 - 123L, test.getStartMillis());\n    assertEquals(TEST_TIME2, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2581, "method_signature": "void testSetDurationBeforeEnd_long1()"}, "TestMutableInterval_Updates.testSetEndMillis_long1": {"callee_method_names": ["MutableInterval.setEndMillis", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetEndMillis_long1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setEndMillis(TEST_TIME2 + 1);\n    assertEquals(TEST_TIME1, test.getStartMillis());\n    assertEquals(TEST_TIME2 + 1, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2577, "method_signature": "void testSetEndMillis_long1()"}, "TestMutableInterval_Updates.testSetEnd_RI1": {"callee_method_names": ["MutableInterval.setEnd", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetEnd_RI1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setEnd(new Instant(TEST_TIME2 + 1));\n    assertEquals(TEST_TIME1, test.getStartMillis());\n    assertEquals(TEST_TIME2 + 1, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2578, "method_signature": "void testSetEnd_RI1()"}, "TestMutableInterval_Updates.testSetInterval_RI_RI1": {"callee_method_ids": [185], "callee_method_names": ["MutableInterval.setInterval", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetInterval_RI_RI1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setInterval(new Instant(TEST_TIME1 - 1), new Instant(TEST_TIME2 + 1));\n    assertEquals(TEST_TIME1 - 1, test.getStartMillis());\n    assertEquals(TEST_TIME2 + 1, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2573, "method_signature": "void testSetInterval_RI_RI1()"}, "TestMutableInterval_Updates.testSetInterval_RInterval1": {"callee_method_ids": [185], "callee_method_names": ["MutableInterval.setInterval", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetInterval_RInterval1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setInterval(new Interval(TEST_TIME1 - 1, TEST_TIME2 + 1));\n    assertEquals(TEST_TIME1 - 1, test.getStartMillis());\n    assertEquals(TEST_TIME2 + 1, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2574, "method_signature": "void testSetInterval_RInterval1()"}, "TestMutableInterval_Updates.testSetInterval_long_long1": {"callee_method_ids": [185], "callee_method_names": ["MutableInterval.setInterval", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetInterval_long_long1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setInterval(TEST_TIME1 - 1, TEST_TIME2 + 1);\n    assertEquals(TEST_TIME1 - 1, test.getStartMillis());\n    assertEquals(TEST_TIME2 + 1, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2572, "method_signature": "void testSetInterval_long_long1()"}, "TestMutableInterval_Updates.testSetPeriodAfterStart_RI1": {"callee_method_ids": [186], "callee_method_names": ["MutableInterval.setPeriodAfterStart", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetPeriodAfterStart_RI1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setPeriodAfterStart(new Period(123L));\n    assertEquals(TEST_TIME1, test.getStartMillis());\n    assertEquals(TEST_TIME1 + 123L, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2583, "method_signature": "void testSetPeriodAfterStart_RI1()"}, "TestMutableInterval_Updates.testSetPeriodBeforeEnd_RI1": {"callee_method_ids": [187], "callee_method_names": ["MutableInterval.setPeriodBeforeEnd", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetPeriodBeforeEnd_RI1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setPeriodBeforeEnd(new Period(123L));\n    assertEquals(TEST_TIME2 - 123L, test.getStartMillis());\n    assertEquals(TEST_TIME2, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2584, "method_signature": "void testSetPeriodBeforeEnd_RI1()"}, "TestMutableInterval_Updates.testSetStartMillis_long1": {"callee_method_names": ["MutableInterval.setStartMillis", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetStartMillis_long1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setStartMillis(TEST_TIME1 - 1);\n    assertEquals(TEST_TIME1 - 1, test.getStartMillis());\n    assertEquals(TEST_TIME2, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2575, "method_signature": "void testSetStartMillis_long1()"}, "TestMutableInterval_Updates.testSetStart_RI1": {"callee_method_names": ["MutableInterval.setStart", "MutableInterval.getStartMillis", "MutableInterval.getEndMillis"], "method_name": "TestMutableInterval_Updates.testSetStart_RI1", "method_implementation": "{\n    MutableInterval test = new MutableInterval(TEST_TIME1, TEST_TIME2);\n    test.setStart(new Instant(TEST_TIME1 - 1));\n    assertEquals(TEST_TIME1 - 1, test.getStartMillis());\n    assertEquals(TEST_TIME2, test.getEndMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2576, "method_signature": "void testSetStart_RI1()"}, "TestMutableInterval_Updates.testTest": {"callee_method_names": [], "method_name": "TestMutableInterval_Updates.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2571, "method_signature": "void testTest()"}, "TestMutablePeriod_Basics.testClone": {"callee_method_ids": [795], "callee_method_names": ["MutablePeriod.clone", "MutablePeriod.getPeriodType", "MutablePeriod.getPeriodType"], "method_name": "TestMutablePeriod_Basics.testClone", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(123L);\n    MutablePeriod copy = (MutablePeriod) test.clone();\n    assertEquals(test.getPeriodType(), copy.getPeriodType());\n    assertEquals(test, copy);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1757, "method_signature": "void testClone()"}, "TestMutablePeriod_Basics.testCopy": {"callee_method_names": ["MutablePeriod.copy", "MutablePeriod.getPeriodType", "MutablePeriod.getPeriodType"], "method_name": "TestMutablePeriod_Basics.testCopy", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(123L);\n    MutablePeriod copy = test.copy();\n    assertEquals(test.getPeriodType(), copy.getPeriodType());\n    assertEquals(test, copy);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1756, "method_signature": "void testCopy()"}, "TestMutablePeriod_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestMutablePeriod_Basics.testSerialization", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(123L);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    MutablePeriod result = (MutablePeriod) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1753, "method_signature": "void testSerialization()"}, "TestMutablePeriod_Basics.testTest": {"callee_method_names": [], "method_name": "TestMutablePeriod_Basics.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1752, "method_signature": "void testTest()"}, "TestMutablePeriod_Basics.testToPeriod": {"callee_method_names": ["MutablePeriod.toPeriod"], "method_name": "TestMutablePeriod_Basics.testToPeriod", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(123L);\n    Period result = test.toPeriod();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1755, "method_signature": "void testToPeriod()"}, "TestMutablePeriod_Basics.testToString": {"callee_method_names": ["MutablePeriod.toString", "MutablePeriod.toString", "MutablePeriod.toString"], "method_name": "TestMutablePeriod_Basics.testToString", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(\"P1Y2M3W4DT5H6M7.008S\", test.toString());\n    test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 0);\n    assertEquals(\"PT0S\", test.toString());\n    test = new MutablePeriod(12345L);\n    assertEquals(\"PT12.345S\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1754, "method_signature": "void testToString()"}, "TestMutablePeriod_Constructors.testConstructor1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod();\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1432, "method_signature": "void testConstructor1()"}, "TestMutablePeriod_Constructors.testConstructor_4int1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_4int1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(5, 6, 7, 8);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (4ints)\n */\n", "repo_name": "joda-time-main/", "id": 1438, "method_signature": "void testConstructor_4int1()"}, "TestMutablePeriod_Constructors.testConstructor_8int1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_8int1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(4, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (8ints)\n */\n", "repo_name": "joda-time-main/", "id": 1439, "method_signature": "void testConstructor_8int1()"}, "TestMutablePeriod_Constructors.testConstructor_8int__PeriodType1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_8int__PeriodType1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8, null);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(4, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (8ints)\n */\n", "repo_name": "joda-time-main/", "id": 1440, "method_signature": "void testConstructor_8int__PeriodType1()"}, "TestMutablePeriod_Constructors.testConstructor_Object1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_Object1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(\"P1Y2M3D\");\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(3, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1449, "method_signature": "void testConstructor_Object1()"}, "TestMutablePeriod_Constructors.testConstructor_Object_Chronology1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_Object_Chronology1", "method_implementation": "{\n    long length = (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY + 5L * DateTimeConstants.MILLIS_PER_HOUR + 6L * DateTimeConstants.MILLIS_PER_MINUTE + 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n    MutablePeriod test = new MutablePeriod(new Duration(length), ISOChronology.getInstance());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    // (4 + (3 * 7) + (2 * 30) + 365) == 450\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals((450 * 24) + 5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1451, "method_signature": "void testConstructor_Object_Chronology1()"}, "TestMutablePeriod_Constructors.testConstructor_Object_PeriodType1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_Object_PeriodType1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(\"P1Y2M3D\", PeriodType.yearMonthDayTime());\n    assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(3, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object,PeriodType)\n */\n", "repo_name": "joda-time-main/", "id": 1450, "method_signature": "void testConstructor_Object_PeriodType1()"}, "TestMutablePeriod_Constructors.testConstructor_PeriodType1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_PeriodType1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(PeriodType.yearMonthDayTime());\n    assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (PeriodType)\n */\n", "repo_name": "joda-time-main/", "id": 1433, "method_signature": "void testConstructor_PeriodType1()"}, "TestMutablePeriod_Constructors.testConstructor_RI_RD1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_RI_RD1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Duration dur = new Interval(dt1, dt2).toDuration();\n    MutablePeriod test = new MutablePeriod(dt1, dur);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1447, "method_signature": "void testConstructor_RI_RD1()"}, "TestMutablePeriod_Constructors.testConstructor_RI_RD_PeriodType1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_RI_RD_PeriodType1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Duration dur = new Interval(dt1, dt2).toDuration();\n    MutablePeriod test = new MutablePeriod(dt1, dur, PeriodType.yearDayTime());\n    assertEquals(PeriodType.yearDayTime(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(31, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1448, "method_signature": "void testConstructor_RI_RD_PeriodType1()"}, "TestMutablePeriod_Constructors.testConstructor_RI_RI1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_RI_RI1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    MutablePeriod test = new MutablePeriod(dt1, dt2);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1445, "method_signature": "void testConstructor_RI_RI1()"}, "TestMutablePeriod_Constructors.testConstructor_RI_RI_PeriodType1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_RI_RI_PeriodType1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    MutablePeriod test = new MutablePeriod(dt1, dt2, null);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1446, "method_signature": "void testConstructor_RI_RI_PeriodType1()"}, "TestMutablePeriod_Constructors.testConstructor_long1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_long1", "method_implementation": "{\n    long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n    MutablePeriod test = new MutablePeriod(length);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals((4 * 24) + 5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1434, "method_signature": "void testConstructor_long1()"}, "TestMutablePeriod_Constructors.testConstructor_long_Chronology1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_long_Chronology1", "method_implementation": "{\n    long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n    MutablePeriod test = new MutablePeriod(length, ISOChronology.getInstance());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals((4 * 24) + 5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1436, "method_signature": "void testConstructor_long_Chronology1()"}, "TestMutablePeriod_Constructors.testConstructor_long_PeriodType1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_long_PeriodType1", "method_implementation": "{\n    long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n    MutablePeriod test = new MutablePeriod(length, (PeriodType) null);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals((4 * 24) + 5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1435, "method_signature": "void testConstructor_long_PeriodType1()"}, "TestMutablePeriod_Constructors.testConstructor_long_PeriodType_Chronology1": {"callee_method_names": ["MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_long_PeriodType_Chronology1", "method_implementation": "{\n    long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n    MutablePeriod test = new MutablePeriod(length, PeriodType.time().withMillisRemoved(), ISOChronology.getInstance());\n    assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals((4 * 24) + 5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1437, "method_signature": "void testConstructor_long_PeriodType_Chronology1()"}, "TestMutablePeriod_Constructors.testConstructor_long_long1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_long_long1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1441, "method_signature": "void testConstructor_long_long1()"}, "TestMutablePeriod_Constructors.testConstructor_long_long_Chronology1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_long_long_Chronology1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance());\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance());\n    MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), CopticChronology.getInstance());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1443, "method_signature": "void testConstructor_long_long_Chronology1()"}, "TestMutablePeriod_Constructors.testConstructor_long_long_PeriodType1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_long_long_PeriodType1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1442, "method_signature": "void testConstructor_long_long_PeriodType1()"}, "TestMutablePeriod_Constructors.testConstructor_long_long_PeriodType_Chronology1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "MutablePeriod.getPeriodType", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Constructors.testConstructor_long_long_PeriodType_Chronology1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance());\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance());\n    MutablePeriod test = new MutablePeriod(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, CopticChronology.getInstance());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1444, "method_signature": "void testConstructor_long_long_PeriodType_Chronology1()"}, "TestMutablePeriod_Updates.testAddDays": {"callee_method_names": ["MutablePeriod.addDays", "MutablePeriod.getDays", "MutablePeriod.addDays", "MutablePeriod.getDays", "MutablePeriod.addDays", "MutablePeriod.getDays"], "method_name": "TestMutablePeriod_Updates.testAddDays", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addDays(10);\n    assertEquals(14, test.getDays());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addDays(-10);\n    assertEquals(-6, test.getDays());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addDays(0);\n    assertEquals(4, test.getDays());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1783, "method_signature": "void testAddDays()"}, "TestMutablePeriod_Updates.testAddHours": {"callee_method_names": ["MutablePeriod.addHours", "MutablePeriod.getHours", "MutablePeriod.addHours", "MutablePeriod.getHours", "MutablePeriod.addHours", "MutablePeriod.getHours"], "method_name": "TestMutablePeriod_Updates.testAddHours", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addHours(10);\n    assertEquals(15, test.getHours());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addHours(-10);\n    assertEquals(-5, test.getHours());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addHours(0);\n    assertEquals(5, test.getHours());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1784, "method_signature": "void testAddHours()"}, "TestMutablePeriod_Updates.testAddMillis": {"callee_method_names": ["MutablePeriod.addMillis", "MutablePeriod.getMillis", "MutablePeriod.addMillis", "MutablePeriod.getMillis", "MutablePeriod.addMillis", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testAddMillis", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addMillis(10);\n    assertEquals(18, test.getMillis());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addMillis(-10);\n    assertEquals(-2, test.getMillis());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addMillis(0);\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1787, "method_signature": "void testAddMillis()"}, "TestMutablePeriod_Updates.testAddMinutes": {"callee_method_names": ["MutablePeriod.addMinutes", "MutablePeriod.getMinutes", "MutablePeriod.addMinutes", "MutablePeriod.getMinutes", "MutablePeriod.addMinutes", "MutablePeriod.getMinutes"], "method_name": "TestMutablePeriod_Updates.testAddMinutes", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addMinutes(10);\n    assertEquals(16, test.getMinutes());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addMinutes(-10);\n    assertEquals(-4, test.getMinutes());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addMinutes(0);\n    assertEquals(6, test.getMinutes());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1785, "method_signature": "void testAddMinutes()"}, "TestMutablePeriod_Updates.testAddMonths": {"callee_method_names": ["MutablePeriod.addMonths", "MutablePeriod.getMonths", "MutablePeriod.addMonths", "MutablePeriod.getMonths", "MutablePeriod.addMonths", "MutablePeriod.getMonths"], "method_name": "TestMutablePeriod_Updates.testAddMonths", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addMonths(10);\n    assertEquals(12, test.getMonths());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addMonths(-10);\n    assertEquals(-8, test.getMonths());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addMonths(0);\n    assertEquals(2, test.getMonths());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1781, "method_signature": "void testAddMonths()"}, "TestMutablePeriod_Updates.testAddSeconds": {"callee_method_names": ["MutablePeriod.addSeconds", "MutablePeriod.getSeconds", "MutablePeriod.addSeconds", "MutablePeriod.getSeconds", "MutablePeriod.addSeconds", "MutablePeriod.getSeconds"], "method_name": "TestMutablePeriod_Updates.testAddSeconds", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addSeconds(10);\n    assertEquals(17, test.getSeconds());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addSeconds(-10);\n    assertEquals(-3, test.getSeconds());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addSeconds(0);\n    assertEquals(7, test.getSeconds());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1786, "method_signature": "void testAddSeconds()"}, "TestMutablePeriod_Updates.testAddWeeks": {"callee_method_names": ["MutablePeriod.addWeeks", "MutablePeriod.getWeeks", "MutablePeriod.addWeeks", "MutablePeriod.getWeeks", "MutablePeriod.addWeeks", "MutablePeriod.getWeeks"], "method_name": "TestMutablePeriod_Updates.testAddWeeks", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addWeeks(10);\n    assertEquals(13, test.getWeeks());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addWeeks(-10);\n    assertEquals(-7, test.getWeeks());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addWeeks(0);\n    assertEquals(3, test.getWeeks());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1782, "method_signature": "void testAddWeeks()"}, "TestMutablePeriod_Updates.testAddYears": {"callee_method_names": ["MutablePeriod.addYears", "MutablePeriod.getYears", "MutablePeriod.addYears", "MutablePeriod.getYears", "MutablePeriod.addYears", "MutablePeriod.getYears"], "method_name": "TestMutablePeriod_Updates.testAddYears", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addYears(10);\n    assertEquals(11, test.getYears());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addYears(-10);\n    assertEquals(-9, test.getYears());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.addYears(0);\n    assertEquals(1, test.getYears());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1780, "method_signature": "void testAddYears()"}, "TestMutablePeriod_Updates.testAdd_8ints1": {"callee_method_ids": [794], "callee_method_names": ["MutablePeriod.add", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testAdd_8ints1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(100L);\n    test.add(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(4, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(108, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1805, "method_signature": "void testAdd_8ints1()"}, "TestMutablePeriod_Updates.testAdd_Field": {"callee_method_ids": [794, 794, 794, 794], "callee_method_names": ["MutablePeriod.add", "MutablePeriod.getYears", "MutablePeriod.add", "MutablePeriod.getYears", "MutablePeriod.getMillis", "MutablePeriod.add", "MutablePeriod.add"], "method_name": "TestMutablePeriod_Updates.testAdd_Field", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.add(DurationFieldType.years(), 10);\n    assertEquals(11, test.getYears());\n    test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.millis());\n    test.add(DurationFieldType.years(), 0);\n    assertEquals(0, test.getYears());\n    assertEquals(1, test.getMillis());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    try {\n        test.add(null, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    try {\n        test.add(null, 10);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1797, "method_signature": "void testAdd_Field()"}, "TestMutablePeriod_Updates.testAdd_RD1": {"callee_method_ids": [794], "callee_method_names": ["MutablePeriod.add", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testAdd_RD1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(100L);\n    test.add(new Duration(100L));\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(200, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1808, "method_signature": "void testAdd_RD1()"}, "TestMutablePeriod_Updates.testAdd_RInterval1": {"callee_method_ids": [794], "callee_method_names": ["MutablePeriod.add", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testAdd_RInterval1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(100L);\n    test.add(new Interval(100L, 200L));\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(200, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1810, "method_signature": "void testAdd_RInterval1()"}, "TestMutablePeriod_Updates.testAdd_RP1": {"callee_method_ids": [794], "callee_method_names": ["MutablePeriod.add", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testAdd_RP1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(100L);\n    test.add(new Period(100L));\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(200, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1809, "method_signature": "void testAdd_RP1()"}, "TestMutablePeriod_Updates.testAdd_long1": {"callee_method_ids": [794], "callee_method_names": ["MutablePeriod.add", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testAdd_long1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(100L);\n    test.add(100L);\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(200, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1806, "method_signature": "void testAdd_long1()"}, "TestMutablePeriod_Updates.testAdd_long_Chronology1": {"callee_method_ids": [794], "callee_method_names": ["MutablePeriod.add", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testAdd_long_Chronology1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(100L);\n    test.add(100L, ISOChronology.getInstance());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(200, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1807, "method_signature": "void testAdd_long_Chronology1()"}, "TestMutablePeriod_Updates.testClear": {"callee_method_names": ["MutablePeriod.clear", "MutablePeriod.clear"], "method_name": "TestMutablePeriod_Updates.testClear", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.clear();\n    assertEquals(new MutablePeriod(), test);\n    test = new MutablePeriod(1, 2, 0, 4, 5, 6, 7, 8, PeriodType.yearMonthDayTime());\n    test.clear();\n    assertEquals(new MutablePeriod(PeriodType.yearMonthDayTime()), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1779, "method_signature": "void testClear()"}, "TestMutablePeriod_Updates.testMergePeriod_RP1": {"callee_method_names": ["MutablePeriod.mergePeriod", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testMergePeriod_RP1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.mergePeriod(new MutablePeriod(0, 0, 0, 14, 15, 16, 17, 18, PeriodType.dayTime()));\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(14, test.getDays());\n    assertEquals(15, test.getHours());\n    assertEquals(16, test.getMinutes());\n    assertEquals(17, test.getSeconds());\n    assertEquals(18, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1811, "method_signature": "void testMergePeriod_RP1()"}, "TestMutablePeriod_Updates.testSetDays": {"callee_method_names": ["MutablePeriod.setDays", "MutablePeriod.getDays", "MutablePeriod.setDays", "MutablePeriod.getDays", "MutablePeriod.setDays", "MutablePeriod.getDays", "MutablePeriod.setDays", "MutablePeriod.getDays"], "method_name": "TestMutablePeriod_Updates.testSetDays", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setDays(10);\n    assertEquals(10, test.getDays());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setDays(-10);\n    assertEquals(-10, test.getDays());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setDays(0);\n    assertEquals(0, test.getDays());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setDays(4);\n    assertEquals(4, test.getDays());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1791, "method_signature": "void testSetDays()"}, "TestMutablePeriod_Updates.testSetHours": {"callee_method_names": ["MutablePeriod.setHours", "MutablePeriod.getHours", "MutablePeriod.setHours", "MutablePeriod.getHours", "MutablePeriod.setHours", "MutablePeriod.getHours", "MutablePeriod.setHours", "MutablePeriod.getHours"], "method_name": "TestMutablePeriod_Updates.testSetHours", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setHours(10);\n    assertEquals(10, test.getHours());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setHours(-10);\n    assertEquals(-10, test.getHours());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setHours(0);\n    assertEquals(0, test.getHours());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setHours(5);\n    assertEquals(5, test.getHours());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1792, "method_signature": "void testSetHours()"}, "TestMutablePeriod_Updates.testSetMillis": {"callee_method_names": ["MutablePeriod.setMillis", "MutablePeriod.getMillis", "MutablePeriod.setMillis", "MutablePeriod.getMillis", "MutablePeriod.setMillis", "MutablePeriod.getMillis", "MutablePeriod.setMillis", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testSetMillis", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMillis(10);\n    assertEquals(10, test.getMillis());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMillis(-10);\n    assertEquals(-10, test.getMillis());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMillis(0);\n    assertEquals(0, test.getMillis());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMillis(8);\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1795, "method_signature": "void testSetMillis()"}, "TestMutablePeriod_Updates.testSetMinutes": {"callee_method_names": ["MutablePeriod.setMinutes", "MutablePeriod.getMinutes", "MutablePeriod.setMinutes", "MutablePeriod.getMinutes", "MutablePeriod.setMinutes", "MutablePeriod.getMinutes", "MutablePeriod.setMinutes", "MutablePeriod.getMinutes"], "method_name": "TestMutablePeriod_Updates.testSetMinutes", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMinutes(10);\n    assertEquals(10, test.getMinutes());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMinutes(-10);\n    assertEquals(-10, test.getMinutes());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMinutes(0);\n    assertEquals(0, test.getMinutes());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMinutes(6);\n    assertEquals(6, test.getMinutes());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1793, "method_signature": "void testSetMinutes()"}, "TestMutablePeriod_Updates.testSetMonths": {"callee_method_names": ["MutablePeriod.setMonths", "MutablePeriod.getMonths", "MutablePeriod.setMonths", "MutablePeriod.getMonths", "MutablePeriod.setMonths", "MutablePeriod.getMonths", "MutablePeriod.setMonths", "MutablePeriod.getMonths"], "method_name": "TestMutablePeriod_Updates.testSetMonths", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMonths(10);\n    assertEquals(10, test.getMonths());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMonths(-10);\n    assertEquals(-10, test.getMonths());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMonths(0);\n    assertEquals(0, test.getMonths());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setMonths(2);\n    assertEquals(2, test.getMonths());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1789, "method_signature": "void testSetMonths()"}, "TestMutablePeriod_Updates.testSetPeriod_8ints1": {"callee_method_ids": [791], "callee_method_names": ["MutablePeriod.setPeriod", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testSetPeriod_8ints1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setPeriod(11, 12, 13, 14, 15, 16, 17, 18);\n    assertEquals(11, test.getYears());\n    assertEquals(12, test.getMonths());\n    assertEquals(13, test.getWeeks());\n    assertEquals(14, test.getDays());\n    assertEquals(15, test.getHours());\n    assertEquals(16, test.getMinutes());\n    assertEquals(17, test.getSeconds());\n    assertEquals(18, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1798, "method_signature": "void testSetPeriod_8ints1()"}, "TestMutablePeriod_Updates.testSetPeriod_RD1": {"callee_method_ids": [791], "callee_method_names": ["MutablePeriod.setPeriod", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testSetPeriod_RD1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setPeriod(new Duration(100L));\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(100, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1804, "method_signature": "void testSetPeriod_RD1()"}, "TestMutablePeriod_Updates.testSetPeriod_RI_RI1": {"callee_method_ids": [791], "callee_method_names": ["MutablePeriod.setPeriod", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testSetPeriod_RI_RI1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n    DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n    test.setPeriod(dt1, dt2);\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(1, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1801, "method_signature": "void testSetPeriod_RI_RI1()"}, "TestMutablePeriod_Updates.testSetPeriod_RInterval1": {"callee_method_ids": [791], "callee_method_names": ["MutablePeriod.setPeriod", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testSetPeriod_RInterval1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n    DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n    test.setPeriod(new Interval(dt1, dt2));\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(1, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1802, "method_signature": "void testSetPeriod_RInterval1()"}, "TestMutablePeriod_Updates.testSetPeriod_RP1": {"callee_method_ids": [791], "callee_method_names": ["MutablePeriod.setPeriod", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testSetPeriod_RP1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setPeriod(new MutablePeriod(11, 12, 13, 14, 15, 16, 17, 18));\n    assertEquals(11, test.getYears());\n    assertEquals(12, test.getMonths());\n    assertEquals(13, test.getWeeks());\n    assertEquals(14, test.getDays());\n    assertEquals(15, test.getHours());\n    assertEquals(16, test.getMinutes());\n    assertEquals(17, test.getSeconds());\n    assertEquals(18, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1799, "method_signature": "void testSetPeriod_RP1()"}, "TestMutablePeriod_Updates.testSetPeriod_long1": {"callee_method_ids": [791], "callee_method_names": ["MutablePeriod.setPeriod", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testSetPeriod_long1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setPeriod(100L);\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(100, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1803, "method_signature": "void testSetPeriod_long1()"}, "TestMutablePeriod_Updates.testSetPeriod_long_long1": {"callee_method_ids": [791], "callee_method_names": ["MutablePeriod.setPeriod", "DateTime.getMillis", "DateTime.getMillis", "MutablePeriod.getYears", "MutablePeriod.getMonths", "MutablePeriod.getWeeks", "MutablePeriod.getDays", "MutablePeriod.getHours", "MutablePeriod.getMinutes", "MutablePeriod.getSeconds", "MutablePeriod.getMillis"], "method_name": "TestMutablePeriod_Updates.testSetPeriod_long_long1", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    DateTime dt1 = new DateTime(2002, 6, 9, 13, 15, 17, 19);\n    DateTime dt2 = new DateTime(2003, 7, 17, 14, 16, 18, 20);\n    test.setPeriod(dt1.getMillis(), dt2.getMillis());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(1, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1800, "method_signature": "void testSetPeriod_long_long1()"}, "TestMutablePeriod_Updates.testSetSeconds": {"callee_method_names": ["MutablePeriod.setSeconds", "MutablePeriod.getSeconds", "MutablePeriod.setSeconds", "MutablePeriod.getSeconds", "MutablePeriod.setSeconds", "MutablePeriod.getSeconds", "MutablePeriod.setSeconds", "MutablePeriod.getSeconds"], "method_name": "TestMutablePeriod_Updates.testSetSeconds", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setSeconds(10);\n    assertEquals(10, test.getSeconds());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setSeconds(-10);\n    assertEquals(-10, test.getSeconds());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setSeconds(0);\n    assertEquals(0, test.getSeconds());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setSeconds(7);\n    assertEquals(7, test.getSeconds());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1794, "method_signature": "void testSetSeconds()"}, "TestMutablePeriod_Updates.testSetWeeks": {"callee_method_names": ["MutablePeriod.setWeeks", "MutablePeriod.getWeeks", "MutablePeriod.setWeeks", "MutablePeriod.getWeeks", "MutablePeriod.setWeeks", "MutablePeriod.getWeeks", "MutablePeriod.setWeeks", "MutablePeriod.getWeeks"], "method_name": "TestMutablePeriod_Updates.testSetWeeks", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setWeeks(10);\n    assertEquals(10, test.getWeeks());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setWeeks(-10);\n    assertEquals(-10, test.getWeeks());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setWeeks(0);\n    assertEquals(0, test.getWeeks());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setWeeks(3);\n    assertEquals(3, test.getWeeks());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1790, "method_signature": "void testSetWeeks()"}, "TestMutablePeriod_Updates.testSetYears": {"callee_method_names": ["MutablePeriod.setYears", "MutablePeriod.getYears", "MutablePeriod.setYears", "MutablePeriod.getYears", "MutablePeriod.setYears", "MutablePeriod.getYears", "MutablePeriod.setYears", "MutablePeriod.getYears", "MutablePeriod.setYears"], "method_name": "TestMutablePeriod_Updates.testSetYears", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setYears(10);\n    assertEquals(10, test.getYears());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setYears(-10);\n    assertEquals(-10, test.getYears());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setYears(0);\n    assertEquals(0, test.getYears());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.setYears(1);\n    assertEquals(1, test.getYears());\n    test = new MutablePeriod(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.millis());\n    try {\n        test.setYears(1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1788, "method_signature": "void testSetYears()"}, "TestMutablePeriod_Updates.testSet_Field": {"callee_method_names": ["MutablePeriod.set", "MutablePeriod.getYears", "MutablePeriod.set"], "method_name": "TestMutablePeriod_Updates.testSet_Field", "method_implementation": "{\n    MutablePeriod test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    test.set(DurationFieldType.years(), 10);\n    assertEquals(10, test.getYears());\n    test = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    try {\n        test.set(null, 10);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1796, "method_signature": "void testSet_Field()"}, "TestMutablePeriod_Updates.testTest": {"callee_method_names": [], "method_name": "TestMutablePeriod_Updates.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1778, "method_signature": "void testTest()"}, "TestNullConverter.testGetPartialValues": {"callee_method_names": [], "method_name": "TestNullConverter.testGetPartialValues", "method_implementation": "{\n    TimeOfDay tod = new TimeOfDay();\n    // now\n    int[] expected = new int[] { 10 + 1, 20, 30, 40 };\n    int[] actual = NullConverter.INSTANCE.getPartialValues(tod, null, ISOChronology.getInstance());\n    assertEquals(true, Arrays.equals(expected, actual));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2075, "method_signature": "void testGetPartialValues()"}, "TestNullConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestNullConverter.testSingleton", "method_implementation": "{\n    Class cls = NullConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2074, "method_signature": "void testSingleton()"}, "TestOffsetDateTimeField.test_addWrapField_long_int": {"callee_method_names": ["OffsetDateTimeField.addWrapField", "OffsetDateTimeField.addWrapField", "OffsetDateTimeField.addWrapField"], "method_name": "TestOffsetDateTimeField.test_addWrapField_long_int", "method_implementation": "{\n    OffsetDateTimeField field = new MockOffsetDateTimeField();\n    assertEquals(29 * 1000L, field.addWrapField(1000L * 29, 0));\n    assertEquals(59 * 1000L, field.addWrapField(1000L * 29, 30));\n    assertEquals(0L, field.addWrapField(1000L * 29, 31));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1127, "method_signature": "void test_addWrapField_long_int()"}, "TestOffsetDateTimeField.test_constructor1": {"callee_method_names": ["OffsetDateTimeField.getType", "OffsetDateTimeField.getOffset"], "method_name": "TestOffsetDateTimeField.test_constructor1", "method_implementation": "{\n    OffsetDateTimeField field = new OffsetDateTimeField(ISOChronology.getInstance().secondOfMinute(), 3);\n    assertEquals(DateTimeFieldType.secondOfMinute(), field.getType());\n    assertEquals(3, field.getOffset());\n    try {\n        field = new OffsetDateTimeField(null, 3);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        field = new OffsetDateTimeField(ISOChronology.getInstance().secondOfMinute(), 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        field = new OffsetDateTimeField(UnsupportedDateTimeField.getInstance(DateTimeFieldType.secondOfMinute(), UnsupportedDurationField.getInstance(DurationFieldType.seconds())), 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1124, "method_signature": "void test_constructor1()"}, "TestOffsetDateTimeField.test_getAsShortText_long_Locale": {"callee_method_names": ["OffsetDateTimeField.getAsShortText", "OffsetDateTimeField.getAsShortText"], "method_name": "TestOffsetDateTimeField.test_getAsShortText_long_Locale", "method_implementation": "{\n    OffsetDateTimeField field = new MockOffsetDateTimeField();\n    assertEquals(\"32\", field.getAsShortText(1000L * 29, Locale.ENGLISH));\n    assertEquals(\"32\", field.getAsShortText(1000L * 29, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1126, "method_signature": "void test_getAsShortText_long_Locale()"}, "TestOffsetDateTimeField.test_getAsText_long_Locale": {"callee_method_names": ["OffsetDateTimeField.getAsText", "OffsetDateTimeField.getAsText"], "method_name": "TestOffsetDateTimeField.test_getAsText_long_Locale", "method_implementation": "{\n    OffsetDateTimeField field = new MockOffsetDateTimeField();\n    assertEquals(\"32\", field.getAsText(1000L * 29, Locale.ENGLISH));\n    assertEquals(\"32\", field.getAsText(1000L * 29, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1125, "method_signature": "void test_getAsText_long_Locale()"}, "TestOffsetDateTimeField.test_roundFloor_long": {"callee_method_names": ["OffsetDateTimeField.roundFloor", "OffsetDateTimeField.roundFloor", "OffsetDateTimeField.roundFloor", "OffsetDateTimeField.roundFloor", "OffsetDateTimeField.roundFloor", "OffsetDateTimeField.roundFloor", "OffsetDateTimeField.roundFloor", "OffsetDateTimeField.roundFloor", "OffsetDateTimeField.roundFloor", "OffsetDateTimeField.roundFloor"], "method_name": "TestOffsetDateTimeField.test_roundFloor_long", "method_implementation": "{\n    OffsetDateTimeField field = new MockOffsetDateTimeField();\n    assertEquals(-2000L, field.roundFloor(-1001L));\n    assertEquals(-1000L, field.roundFloor(-1000L));\n    assertEquals(-1000L, field.roundFloor(-999L));\n    assertEquals(-1000L, field.roundFloor(-1L));\n    assertEquals(0L, field.roundFloor(0L));\n    assertEquals(0L, field.roundFloor(1L));\n    assertEquals(0L, field.roundFloor(499L));\n    assertEquals(0L, field.roundFloor(500L));\n    assertEquals(0L, field.roundFloor(501L));\n    assertEquals(1000L, field.roundFloor(1000L));\n}", "repo_id": "7", "comment": "//------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1129, "method_signature": "void test_roundFloor_long()"}, "TestOffsetDateTimeField.test_set_long_int": {"callee_method_ids": [61, 61, 61], "callee_method_names": ["OffsetDateTimeField.set", "OffsetDateTimeField.set", "OffsetDateTimeField.set"], "method_name": "TestOffsetDateTimeField.test_set_long_int", "method_implementation": "{\n    OffsetDateTimeField field = new MockOffsetDateTimeField();\n    assertEquals(3120L, field.set(2120L, 6));\n    assertEquals(26120L, field.set(120L, 29));\n    assertEquals(57120L, field.set(2120L, 60));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1128, "method_signature": "void test_set_long_int()"}, "TestPartial_Basics.testCompareTo": {"callee_method_names": ["Partial.compareTo", "Partial.compareTo", "Partial.compareTo", "Partial.compareTo", "Partial.compareTo", "Partial.compareTo", "Partial.compareTo", "Partial.compareTo", "Partial.compareTo", "Partial.compareTo", "Partial.compareTo"], "method_name": "TestPartial_Basics.testCompareTo", "method_implementation": "{\n    Partial test1 = createHourMinPartial();\n    Partial test1a = createHourMinPartial();\n    assertEquals(0, test1.compareTo(test1a));\n    assertEquals(0, test1a.compareTo(test1));\n    assertEquals(0, test1.compareTo(test1));\n    assertEquals(0, test1a.compareTo(test1a));\n    Partial test2 = createHourMinPartial2(ISO_UTC);\n    assertEquals(-1, test1.compareTo(test2));\n    assertEquals(+1, test2.compareTo(test1));\n    Partial test3 = createHourMinPartial2(COPTIC_UTC);\n    assertEquals(-1, test1.compareTo(test3));\n    assertEquals(+1, test3.compareTo(test1));\n    assertEquals(0, test3.compareTo(test2));\n    assertEquals(0, new TimeOfDay(10, 20, 30, 40).compareTo(createTODPartial(ISO_UTC)));\n    try {\n        test1.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n    //        try {\n    //            test1.compareTo(new Date());\n    //            fail();\n    //        } catch (ClassCastException ex) {}\n    try {\n        test1.compareTo(new YearMonthDay());\n        fail();\n    } catch (ClassCastException ex) {\n    }\n    try {\n        createTODPartial(ISO_UTC).without(DateTimeFieldType.hourOfDay()).compareTo(new YearMonthDay());\n        fail();\n    } catch (ClassCastException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2449, "method_signature": "void testCompareTo()"}, "TestPartial_Basics.testGet": {"callee_method_names": ["Partial.get", "Partial.get", "Partial.get", "Partial.get"], "method_name": "TestPartial_Basics.testGet", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    assertEquals(10, test.get(DateTimeFieldType.hourOfDay()));\n    assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));\n    try {\n        test.get(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.get(DateTimeFieldType.secondOfMinute());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2448, "method_signature": "void testGet()"}, "TestPartial_Basics.testGetFormatter1": {"callee_method_ids": [137, 129, 137, 129, 137, 130, 137], "callee_method_names": ["Partial.getFormatter", "Partial.with", "Partial.getFormatter", "Partial.with", "Partial.getFormatter", "Partial.without", "Partial.getFormatter"], "method_name": "TestPartial_Basics.testGetFormatter1", "method_implementation": "{\n    Partial test = new Partial(DateTimeFieldType.year(), 2005);\n    assertEquals(\"2005\", test.getFormatter().print(test));\n    test = test.with(DateTimeFieldType.monthOfYear(), 6);\n    assertEquals(\"2005-06\", test.getFormatter().print(test));\n    test = test.with(DateTimeFieldType.dayOfMonth(), 25);\n    assertEquals(\"2005-06-25\", test.getFormatter().print(test));\n    test = test.without(DateTimeFieldType.monthOfYear());\n    assertEquals(\"2005--25\", test.getFormatter().print(test));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2464, "method_signature": "void testGetFormatter1()"}, "TestPartial_Basics.testIsAfter_TOD": {"callee_method_names": ["Partial.isAfter", "Partial.isAfter", "Partial.isAfter", "Partial.isAfter", "Partial.isAfter", "Partial.isAfter", "Partial.isAfter", "Partial.isAfter", "Partial.isAfter"], "method_name": "TestPartial_Basics.testIsAfter_TOD", "method_implementation": "{\n    Partial test1 = createHourMinPartial();\n    Partial test1a = createHourMinPartial();\n    assertEquals(false, test1.isAfter(test1a));\n    assertEquals(false, test1a.isAfter(test1));\n    assertEquals(false, test1.isAfter(test1));\n    assertEquals(false, test1a.isAfter(test1a));\n    Partial test2 = createHourMinPartial2(ISO_UTC);\n    assertEquals(false, test1.isAfter(test2));\n    assertEquals(true, test2.isAfter(test1));\n    Partial test3 = createHourMinPartial2(COPTIC_UTC);\n    assertEquals(false, test1.isAfter(test3));\n    assertEquals(true, test3.isAfter(test1));\n    assertEquals(false, test3.isAfter(test2));\n    try {\n        createHourMinPartial().isAfter(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2452, "method_signature": "void testIsAfter_TOD()"}, "TestPartial_Basics.testIsBefore_TOD": {"callee_method_names": ["Partial.isBefore", "Partial.isBefore", "Partial.isBefore", "Partial.isBefore", "Partial.isBefore", "Partial.isBefore", "Partial.isBefore", "Partial.isBefore", "Partial.isBefore"], "method_name": "TestPartial_Basics.testIsBefore_TOD", "method_implementation": "{\n    Partial test1 = createHourMinPartial();\n    Partial test1a = createHourMinPartial();\n    assertEquals(false, test1.isBefore(test1a));\n    assertEquals(false, test1a.isBefore(test1));\n    assertEquals(false, test1.isBefore(test1));\n    assertEquals(false, test1a.isBefore(test1a));\n    Partial test2 = createHourMinPartial2(ISO_UTC);\n    assertEquals(true, test1.isBefore(test2));\n    assertEquals(false, test2.isBefore(test1));\n    Partial test3 = createHourMinPartial2(COPTIC_UTC);\n    assertEquals(true, test1.isBefore(test3));\n    assertEquals(false, test3.isBefore(test1));\n    assertEquals(false, test3.isBefore(test2));\n    try {\n        createHourMinPartial().isBefore(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2451, "method_signature": "void testIsBefore_TOD()"}, "TestPartial_Basics.testIsEqual_TOD": {"callee_method_names": ["Partial.isEqual", "Partial.isEqual", "Partial.isEqual", "Partial.isEqual", "Partial.isEqual", "Partial.isEqual", "Partial.isEqual", "Partial.isEqual", "Partial.isEqual"], "method_name": "TestPartial_Basics.testIsEqual_TOD", "method_implementation": "{\n    Partial test1 = createHourMinPartial();\n    Partial test1a = createHourMinPartial();\n    assertEquals(true, test1.isEqual(test1a));\n    assertEquals(true, test1a.isEqual(test1));\n    assertEquals(true, test1.isEqual(test1));\n    assertEquals(true, test1a.isEqual(test1a));\n    Partial test2 = createHourMinPartial2(ISO_UTC);\n    assertEquals(false, test1.isEqual(test2));\n    assertEquals(false, test2.isEqual(test1));\n    Partial test3 = createHourMinPartial2(COPTIC_UTC);\n    assertEquals(false, test1.isEqual(test3));\n    assertEquals(false, test3.isEqual(test1));\n    assertEquals(true, test3.isEqual(test2));\n    try {\n        createHourMinPartial().isEqual(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2450, "method_signature": "void testIsEqual_TOD()"}, "TestPartial_Basics.testMinus_RP": {"callee_method_names": ["Partial.minus", "Partial.minus"], "method_name": "TestPartial_Basics.testMinus_RP", "method_implementation": "{\n    Partial test = createHourMinPartial(BUDDHIST_LONDON);\n    Partial result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n    check(test, 10, 20);\n    check(result, 9, 19);\n    result = test.minus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2460, "method_signature": "void testMinus_RP()"}, "TestPartial_Basics.testPlus_RP": {"callee_method_names": ["Partial.plus", "Partial.plus"], "method_name": "TestPartial_Basics.testPlus_RP", "method_implementation": "{\n    Partial test = createHourMinPartial(BUDDHIST_LONDON);\n    Partial result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n    check(test, 10, 20);\n    check(result, 15, 26);\n    result = test.plus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2459, "method_signature": "void testPlus_RP()"}, "TestPartial_Basics.testProperty": {"callee_method_names": ["Partial.property", "Partial.property", "Partial.property", "Partial.property"], "method_name": "TestPartial_Basics.testProperty", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    assertNotNull(test.property(DateTimeFieldType.hourOfDay()));\n    assertNotNull(test.property(DateTimeFieldType.minuteOfHour()));\n    try {\n        test.property(DateTimeFieldType.secondOfDay());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2462, "method_signature": "void testProperty()"}, "TestPartial_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close", "Partial.getValues", "Partial.getValues", "Partial.getFields", "Partial.getFields", "Partial.getChronology", "Partial.getChronology"], "method_name": "TestPartial_Basics.testSerialization", "method_implementation": "{\n    Partial test = createHourMinPartial(COPTIC_PARIS);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Partial result = (Partial) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n    assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n    assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n    assertEquals(test.getChronology(), result.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2463, "method_signature": "void testSerialization()"}, "TestPartial_Basics.testToDateTime_RI": {"callee_method_names": ["DateTime.toString", "Partial.toDateTime", "DateTime.toString", "DateTime.toString"], "method_name": "TestPartial_Basics.testToDateTime_RI", "method_implementation": "{\n    Partial base = createHourMinPartial(COPTIC_PARIS);\n    // LONDON zone\n    DateTime dt = new DateTime(0L);\n    assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n    DateTime test = base.toDateTime(dt);\n    check(base, 10, 20);\n    assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n    assertEquals(\"1970-01-01T10:20:00.000+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2461, "method_signature": "void testToDateTime_RI()"}, "TestPartial_Basics.testToString_DTFormatter": {"callee_method_ids": [141, 141], "callee_method_names": ["Partial.toString", "Partial.toString"], "method_name": "TestPartial_Basics.testToString_DTFormatter", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    assertEquals(\"\\ufffd\\ufffd\\ufffd\\ufffd 10\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n    assertEquals(\"10:20\", test.toString((DateTimeFormatter) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2467, "method_signature": "void testToString_DTFormatter()"}, "TestPartial_Basics.testToString_String": {"callee_method_ids": [141, 141], "callee_method_names": ["Partial.toString", "Partial.toString"], "method_name": "TestPartial_Basics.testToString_String", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    assertEquals(\"\\ufffd\\ufffd\\ufffd\\ufffd 10\", test.toString(\"yyyy HH\"));\n    assertEquals(\"10:20\", test.toString((String) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2465, "method_signature": "void testToString_String()"}, "TestPartial_Basics.testToString_String_Locale": {"callee_method_ids": [141, 141, 141, 141], "callee_method_names": ["Partial.toString", "Partial.toString", "Partial.toString", "Partial.toString"], "method_name": "TestPartial_Basics.testToString_String_Locale", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    assertEquals(\"10 20\", test.toString(\"H m\", Locale.ENGLISH));\n    assertEquals(\"10:20\", test.toString(null, Locale.ENGLISH));\n    assertEquals(\"10 20\", test.toString(\"H m\", null));\n    assertEquals(\"10:20\", test.toString(null, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2466, "method_signature": "void testToString_String_Locale()"}, "TestPartial_Basics.testWith1": {"callee_method_ids": [129], "callee_method_names": ["Partial.with"], "method_name": "TestPartial_Basics.testWith1", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    Partial result = test.with(DateTimeFieldType.hourOfDay(), 15);\n    check(test, 10, 20);\n    check(result, 15, 20);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2454, "method_signature": "void testWith1()"}, "TestPartial_Basics.testWithChronologyRetainFields_Chrono": {"callee_method_ids": [128], "callee_method_names": ["Partial.withChronologyRetainFields", "Partial.getChronology", "Partial.getChronology"], "method_name": "TestPartial_Basics.testWithChronologyRetainFields_Chrono", "method_implementation": "{\n    Partial base = createHourMinPartial(COPTIC_PARIS);\n    Partial test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n    check(base, 10, 20);\n    assertEquals(COPTIC_UTC, base.getChronology());\n    check(test, 10, 20);\n    assertEquals(BUDDHIST_UTC, test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2453, "method_signature": "void testWithChronologyRetainFields_Chrono()"}, "TestPartial_Basics.testWithField1": {"callee_method_ids": [131], "callee_method_names": ["Partial.withField"], "method_name": "TestPartial_Basics.testWithField1", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    Partial result = test.withField(DateTimeFieldType.hourOfDay(), 15);\n    check(test, 10, 20);\n    check(result, 15, 20);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2456, "method_signature": "void testWithField1()"}, "TestPartial_Basics.testWithFieldAddWrapped1": {"callee_method_ids": [133], "callee_method_names": ["Partial.withFieldAddWrapped"], "method_name": "TestPartial_Basics.testWithFieldAddWrapped1", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    Partial result = test.withFieldAddWrapped(DurationFieldType.hours(), 6);\n    assertEquals(createHourMinPartial(), test);\n    check(test, 10, 20);\n    check(result, 16, 20);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2458, "method_signature": "void testWithFieldAddWrapped1()"}, "TestPartial_Basics.testWithFieldAdded1": {"callee_method_ids": [132], "callee_method_names": ["Partial.withFieldAdded"], "method_name": "TestPartial_Basics.testWithFieldAdded1", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    Partial result = test.withFieldAdded(DurationFieldType.hours(), 6);\n    assertEquals(createHourMinPartial(), test);\n    check(test, 10, 20);\n    check(result, 16, 20);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2457, "method_signature": "void testWithFieldAdded1()"}, "TestPartial_Basics.testWithout1": {"callee_method_ids": [130], "callee_method_names": ["Partial.without"], "method_name": "TestPartial_Basics.testWithout1", "method_implementation": "{\n    Partial test = createHourMinPartial();\n    Partial result = test.without(DateTimeFieldType.year());\n    check(test, 10, 20);\n    check(result, 10, 20);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2455, "method_signature": "void testWithout1()"}, "TestPartial_Constructors.assertMessageContains": {"callee_method_names": ["Exception.getMessage", "Exception.getMessage", "Exception.getMessage", "Exception.getMessage", "Exception.getMessage"], "method_name": "TestPartial_Constructors.assertMessageContains", "method_implementation": "{\n    assertEquals(ex.getMessage() + \": \" + str1 + \"/\" + str2, true, ex.getMessage().indexOf(str1) >= 0 && ex.getMessage().indexOf(str2) >= 0 && ex.getMessage().indexOf(str1) < ex.getMessage().indexOf(str2));\n}", "repo_id": "7", "comment": "/**\n * Checks if the exception message is valid.\n *\n * @param ex  the exception to check\n * @param str1  the string to check\n * @param str2  the string to check\n */\n", "repo_name": "joda-time-main/", "id": 1869, "method_signature": "void assertMessageContains(Exception, String, String)"}, "TestPartial_Constructors.testConstructor": {"callee_method_names": ["Partial.getChronology", "Partial.size"], "method_name": "TestPartial_Constructors.testConstructor", "method_implementation": "{\n    Partial test = new Partial();\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(0, test.size());\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1848, "method_signature": "void testConstructor()"}, "TestPartial_Constructors.testConstructor2_TypeArray_intArray": {"callee_method_names": ["Partial.getChronology", "Partial.size"], "method_name": "TestPartial_Constructors.testConstructor2_TypeArray_intArray", "method_implementation": "{\n    DateTimeFieldType[] types = new DateTimeFieldType[0];\n    int[] values = new int[0];\n    Partial test = new Partial(types, values);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(0, test.size());\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1858, "method_signature": "void testConstructor2_TypeArray_intArray()"}, "TestPartial_Constructors.testConstructorEx1_TypeArray_intArray": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx1_TypeArray_intArray", "method_implementation": "{\n    try {\n        new Partial((DateTimeFieldType[]) null, new int[] { 1 });\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must not be null\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1859, "method_signature": "void testConstructorEx1_TypeArray_intArray()"}, "TestPartial_Constructors.testConstructorEx1_Type_int": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx1_Type_int", "method_implementation": "{\n    try {\n        new Partial(null, 4);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must not be null\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1851, "method_signature": "void testConstructorEx1_Type_int()"}, "TestPartial_Constructors.testConstructorEx2_Type_int": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx2_Type_int", "method_implementation": "{\n    try {\n        new Partial(DateTimeFieldType.dayOfYear(), 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1852, "method_signature": "void testConstructorEx2_Type_int()"}, "TestPartial_Constructors.testConstructorEx2_Type_int_Chrono": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx2_Type_int_Chrono", "method_implementation": "{\n    try {\n        new Partial(DateTimeFieldType.dayOfYear(), 0, ISO_UTC);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1855, "method_signature": "void testConstructorEx2_Type_int_Chrono()"}, "TestPartial_Constructors.testConstructorEx3_TypeArray_intArray": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx3_TypeArray_intArray", "method_implementation": "{\n    try {\n        new Partial(new DateTimeFieldType[] { DateTimeFieldType.dayOfYear() }, null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must not be null\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1860, "method_signature": "void testConstructorEx3_TypeArray_intArray()"}, "TestPartial_Constructors.testConstructorEx5_TypeArray_intArray": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx5_TypeArray_intArray", "method_implementation": "{\n    try {\n        new Partial(new DateTimeFieldType[] { DateTimeFieldType.dayOfYear() }, new int[2]);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"same length\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1861, "method_signature": "void testConstructorEx5_TypeArray_intArray()"}, "TestPartial_Constructors.testConstructorEx6_TypeArray_intArray": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx6_TypeArray_intArray", "method_implementation": "{\n    try {\n        new Partial(new DateTimeFieldType[] { null, DateTimeFieldType.dayOfYear() }, new int[2]);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"contain null\");\n    }\n    try {\n        new Partial(new DateTimeFieldType[] { DateTimeFieldType.dayOfYear(), null }, new int[2]);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"contain null\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1862, "method_signature": "void testConstructorEx6_TypeArray_intArray()"}, "TestPartial_Constructors.testConstructorEx7_TypeArray_intArray_inOrder": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx7_TypeArray_intArray_inOrder", "method_implementation": "{\n    int[] values = new int[] { 1, 1, 1 };\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.weekyear(), DateTimeFieldType.yearOfCentury(), DateTimeFieldType.dayOfMonth() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.weekyear(), DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1863, "method_signature": "void testConstructorEx7_TypeArray_intArray_inOrder()"}, "TestPartial_Constructors.testConstructorEx8_TypeArray_intArray_duplicate": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx8_TypeArray_intArray_duplicate", "method_implementation": "{\n    int[] values = new int[] { 1, 1, 1 };\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.era(), DateTimeFieldType.year(), DateTimeFieldType.year() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must not\", \"duplicate\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.era(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must not\", \"duplicate\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.dayOfYear(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfMonth() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must not\", \"duplicate\");\n    }\n    types = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.clockhourOfDay(), DateTimeFieldType.hourOfDay() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must not\", \"duplicate\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1864, "method_signature": "void testConstructorEx8_TypeArray_intArray_duplicate()"}, "TestPartial_Constructors.testConstructorEx9_TypeArray_intArray": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx9_TypeArray_intArray", "method_implementation": "{\n    int[] values = new int[] { 3, 0 };\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfWeek() };\n    try {\n        new Partial(types, values);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"Value 0\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1865, "method_signature": "void testConstructorEx9_TypeArray_intArray()"}, "TestPartial_Constructors.testConstructorEx_Partial": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx_Partial", "method_implementation": "{\n    try {\n        new Partial((ReadablePartial) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must not be null\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1868, "method_signature": "void testConstructorEx_Partial()"}, "TestPartial_Constructors.testConstructorEx_Type_int_Chrono": {"callee_method_names": [], "method_name": "TestPartial_Constructors.testConstructorEx_Type_int_Chrono", "method_implementation": "{\n    try {\n        new Partial(null, 4, ISO_UTC);\n        fail();\n    } catch (IllegalArgumentException ex) {\n        assertMessageContains(ex, \"must not be null\");\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1854, "method_signature": "void testConstructorEx_Type_int_Chrono()"}, "TestPartial_Constructors.testConstructor_Chrono": {"callee_method_names": ["Partial.getChronology", "Partial.size", "Partial.getChronology", "Partial.size"], "method_name": "TestPartial_Constructors.testConstructor_Chrono", "method_implementation": "{\n    Partial test = new Partial((Chronology) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(0, test.size());\n    test = new Partial(GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(0, test.size());\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1849, "method_signature": "void testConstructor_Chrono()"}, "TestPartial_Constructors.testConstructor_Partial": {"callee_method_names": ["Partial.getChronology", "Partial.size", "Partial.getValue", "Partial.get", "Partial.isSupported", "Partial.getValue", "Partial.get", "Partial.isSupported", "Partial.getValue", "Partial.get", "Partial.isSupported"], "method_name": "TestPartial_Constructors.testConstructor_Partial", "method_implementation": "{\n    YearMonthDay ymd = new YearMonthDay(2005, 6, 25, GREGORIAN_PARIS);\n    Partial test = new Partial(ymd);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(3, test.size());\n    assertEquals(2005, test.getValue(0));\n    assertEquals(2005, test.get(DateTimeFieldType.year()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n    assertEquals(6, test.getValue(1));\n    assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.monthOfYear()));\n    assertEquals(25, test.getValue(2));\n    assertEquals(25, test.get(DateTimeFieldType.dayOfMonth()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.dayOfMonth()));\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1867, "method_signature": "void testConstructor_Partial()"}, "TestPartial_Constructors.testConstructor_TypeArray_intArray": {"callee_method_names": ["Partial.getChronology", "Partial.size", "Partial.getValue", "Partial.get", "Partial.isSupported", "Partial.getValue", "Partial.get", "Partial.isSupported", "Partial.getFieldTypes", "Partial.getValues"], "method_name": "TestPartial_Constructors.testConstructor_TypeArray_intArray", "method_implementation": "{\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n    int[] values = new int[] { 2005, 33 };\n    Partial test = new Partial(types, values);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2, test.size());\n    assertEquals(2005, test.getValue(0));\n    assertEquals(2005, test.get(DateTimeFieldType.year()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n    assertEquals(33, test.getValue(1));\n    assertEquals(33, test.get(DateTimeFieldType.dayOfYear()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n    assertEquals(true, Arrays.equals(test.getFieldTypes(), types));\n    assertEquals(true, Arrays.equals(test.getValues(), values));\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1856, "method_signature": "void testConstructor_TypeArray_intArray()"}, "TestPartial_Constructors.testConstructor_TypeArray_intArray_Chrono": {"callee_method_names": ["Partial.getChronology", "Partial.size", "Partial.getValue", "Partial.get", "Partial.isSupported", "Partial.getValue", "Partial.get", "Partial.isSupported", "Partial.getFieldTypes", "Partial.getValues"], "method_name": "TestPartial_Constructors.testConstructor_TypeArray_intArray_Chrono", "method_implementation": "{\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n    int[] values = new int[] { 2005, 33 };\n    Partial test = new Partial(types, values, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(2, test.size());\n    assertEquals(2005, test.getValue(0));\n    assertEquals(2005, test.get(DateTimeFieldType.year()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n    assertEquals(33, test.getValue(1));\n    assertEquals(33, test.get(DateTimeFieldType.dayOfYear()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n    assertEquals(true, Arrays.equals(test.getFieldTypes(), types));\n    assertEquals(true, Arrays.equals(test.getValues(), values));\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1866, "method_signature": "void testConstructor_TypeArray_intArray_Chrono()"}, "TestPartial_Constructors.testConstructor_TypeArray_intArray_year_weekyear": {"callee_method_names": ["Partial.getChronology", "Partial.size", "Partial.getValue", "Partial.get", "Partial.isSupported", "Partial.getValue", "Partial.get", "Partial.isSupported", "Partial.getFieldTypes", "Partial.getValues"], "method_name": "TestPartial_Constructors.testConstructor_TypeArray_intArray_year_weekyear", "method_implementation": "{\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.weekyear() };\n    int[] values = new int[] { 2005, 2006 };\n    Partial test = new Partial(types, values);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2, test.size());\n    assertEquals(2005, test.getValue(0));\n    assertEquals(2005, test.get(DateTimeFieldType.year()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.year()));\n    assertEquals(2006, test.getValue(1));\n    assertEquals(2006, test.get(DateTimeFieldType.weekyear()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.weekyear()));\n    assertEquals(true, Arrays.equals(test.getFieldTypes(), types));\n    assertEquals(true, Arrays.equals(test.getValues(), values));\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1857, "method_signature": "void testConstructor_TypeArray_intArray_year_weekyear()"}, "TestPartial_Constructors.testConstructor_Type_int": {"callee_method_names": ["Partial.getChronology", "Partial.size", "Partial.getValue", "Partial.get", "Partial.isSupported"], "method_name": "TestPartial_Constructors.testConstructor_Type_int", "method_implementation": "{\n    Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1, test.size());\n    assertEquals(4, test.getValue(0));\n    assertEquals(4, test.get(DateTimeFieldType.dayOfYear()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1850, "method_signature": "void testConstructor_Type_int()"}, "TestPartial_Constructors.testConstructor_Type_int_Chrono": {"callee_method_names": ["Partial.getChronology", "Partial.size", "Partial.getValue", "Partial.get", "Partial.isSupported"], "method_name": "TestPartial_Constructors.testConstructor_Type_int_Chrono", "method_implementation": "{\n    Partial test = new Partial(DateTimeFieldType.dayOfYear(), 4, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1, test.size());\n    assertEquals(4, test.getValue(0));\n    assertEquals(4, test.get(DateTimeFieldType.dayOfYear()));\n    assertEquals(true, test.isSupported(DateTimeFieldType.dayOfYear()));\n}", "repo_id": "7", "comment": "/**\n * Test constructor\n */\n", "repo_name": "joda-time-main/", "id": 1853, "method_signature": "void testConstructor_Type_int_Chrono()"}, "TestPartial_Match.createYMDwPartial": {"callee_method_names": [], "method_name": "TestPartial_Match.createYMDwPartial", "method_implementation": "{\n    return new Partial(new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfWeek() }, new int[] { year, month, dow }, chrono);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2151, "method_signature": "Partial createYMDwPartial(Chronology, int, int, int)"}, "TestPartial_Match.testIsMatch_Instant": {"callee_method_ids": [136, 136, 136, 136, 136, 136, 136, 136, 136], "callee_method_names": ["Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch"], "method_name": "TestPartial_Match.testIsMatch_Instant", "method_implementation": "{\n    // Year=2005, Month=7 (July), DayOfWeek=2 (Tuesday)\n    Partial test = createYMDwPartial(ISO_UTC, 2005, 7, 2);\n    DateTime instant = new DateTime(2005, 7, 5, 0, 0, 0, 0);\n    assertEquals(true, test.isMatch(instant));\n    instant = new DateTime(2005, 7, 4, 0, 0, 0, 0);\n    assertEquals(false, test.isMatch(instant));\n    instant = new DateTime(2005, 7, 6, 0, 0, 0, 0);\n    assertEquals(false, test.isMatch(instant));\n    instant = new DateTime(2005, 7, 12, 0, 0, 0, 0);\n    assertEquals(true, test.isMatch(instant));\n    instant = new DateTime(2005, 7, 19, 0, 0, 0, 0);\n    assertEquals(true, test.isMatch(instant));\n    instant = new DateTime(2005, 7, 26, 0, 0, 0, 0);\n    assertEquals(true, test.isMatch(instant));\n    instant = new DateTime(2005, 8, 2, 0, 0, 0, 0);\n    assertEquals(false, test.isMatch(instant));\n    instant = new DateTime(2006, 7, 5, 0, 0, 0, 0);\n    assertEquals(false, test.isMatch(instant));\n    instant = new DateTime(2005, 6, 5, 0, 0, 0, 0);\n    assertEquals(false, test.isMatch(instant));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2149, "method_signature": "void testIsMatch_Instant()"}, "TestPartial_Match.testIsMatch_Partial": {"callee_method_ids": [136, 136, 136, 136, 136, 136, 136, 136, 136, 136], "callee_method_names": ["Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch", "Partial.isMatch"], "method_name": "TestPartial_Match.testIsMatch_Partial", "method_implementation": "{\n    // Year=2005, Month=7 (July), DayOfWeek=2 (Tuesday)\n    Partial test = createYMDwPartial(ISO_UTC, 2005, 7, 2);\n    LocalDate partial = new LocalDate(2005, 7, 5);\n    assertEquals(true, test.isMatch(partial));\n    partial = new LocalDate(2005, 7, 4);\n    assertEquals(false, test.isMatch(partial));\n    partial = new LocalDate(2005, 7, 6);\n    assertEquals(false, test.isMatch(partial));\n    partial = new LocalDate(2005, 7, 12);\n    assertEquals(true, test.isMatch(partial));\n    partial = new LocalDate(2005, 7, 19);\n    assertEquals(true, test.isMatch(partial));\n    partial = new LocalDate(2005, 7, 26);\n    assertEquals(true, test.isMatch(partial));\n    partial = new LocalDate(2005, 8, 2);\n    assertEquals(false, test.isMatch(partial));\n    partial = new LocalDate(2006, 7, 5);\n    assertEquals(false, test.isMatch(partial));\n    partial = new LocalDate(2005, 6, 5);\n    assertEquals(false, test.isMatch(partial));\n    try {\n        test.isMatch((ReadablePartial) null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2150, "method_signature": "void testIsMatch_Partial()"}, "TestPartial_Properties.check": {"callee_method_names": ["Partial.get", "Partial.get", "Partial.get", "Partial.get"], "method_name": "TestPartial_Properties.check", "method_implementation": "{\n    assertEquals(hour, test.get(DateTimeFieldType.hourOfDay()));\n    assertEquals(min, test.get(DateTimeFieldType.minuteOfHour()));\n    assertEquals(sec, test.get(DateTimeFieldType.secondOfMinute()));\n    assertEquals(milli, test.get(DateTimeFieldType.millisOfSecond()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1815, "method_signature": "void check(Partial, int, int, int, int)"}, "TestPartial_Properties.testPropertyAddHour": {"callee_method_names": ["Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property"], "method_name": "TestPartial_Properties.testPropertyAddHour", "method_implementation": "{\n    Partial test = new Partial(TYPES, VALUES);\n    Partial copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(9);\n    check(test, 10, 20, 30, 40);\n    check(copy, 19, 20, 30, 40);\n    copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(0);\n    check(copy, 10, 20, 30, 40);\n    copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(13);\n    check(copy, 23, 20, 30, 40);\n    try {\n        test.property(DateTimeFieldType.hourOfDay()).addToCopy(14);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    check(test, 10, 20, 30, 40);\n    copy = test.property(DateTimeFieldType.hourOfDay()).addToCopy(-10);\n    check(copy, 0, 20, 30, 40);\n    try {\n        test.property(DateTimeFieldType.hourOfDay()).addToCopy(-11);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    check(test, 10, 20, 30, 40);\n}", "repo_id": "7", "comment": "//\n", "repo_name": "joda-time-main/", "id": 1813, "method_signature": "void testPropertyAddHour()"}, "TestPartial_Properties.testPropertyGetHour": {"callee_method_names": ["Partial.getChronology", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.getChronology", "Partial.property", "Partial.getChronology", "Partial.property", "Partial.property", "Partial.property"], "method_name": "TestPartial_Properties.testPropertyGetHour", "method_implementation": "{\n    Partial test = new Partial(TYPES, VALUES);\n    assertSame(test.getChronology().hourOfDay(), test.property(DateTimeFieldType.hourOfDay()).getField());\n    assertEquals(\"hourOfDay\", test.property(DateTimeFieldType.hourOfDay()).getName());\n    assertEquals(\"Property[hourOfDay]\", test.property(DateTimeFieldType.hourOfDay()).toString());\n    assertSame(test, test.property(DateTimeFieldType.hourOfDay()).getReadablePartial());\n    assertSame(test, test.property(DateTimeFieldType.hourOfDay()).getPartial());\n    assertEquals(10, test.property(DateTimeFieldType.hourOfDay()).get());\n    assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsString());\n    assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsText());\n    assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsText(Locale.FRENCH));\n    assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsShortText());\n    assertEquals(\"10\", test.property(DateTimeFieldType.hourOfDay()).getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().hours(), test.property(DateTimeFieldType.hourOfDay()).getDurationField());\n    assertEquals(test.getChronology().days(), test.property(DateTimeFieldType.hourOfDay()).getRangeDurationField());\n    assertEquals(2, test.property(DateTimeFieldType.hourOfDay()).getMaximumTextLength(null));\n    assertEquals(2, test.property(DateTimeFieldType.hourOfDay()).getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1812, "method_signature": "void testPropertyGetHour()"}, "TestPartial_Properties.testPropertyGetMinute": {"callee_method_names": ["Partial.getChronology", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.property", "Partial.getChronology", "Partial.property", "Partial.getChronology", "Partial.property", "Partial.property", "Partial.property"], "method_name": "TestPartial_Properties.testPropertyGetMinute", "method_implementation": "{\n    Partial test = new Partial(TYPES, VALUES);\n    assertSame(test.getChronology().minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour()).getField());\n    assertEquals(\"minuteOfHour\", test.property(DateTimeFieldType.minuteOfHour()).getName());\n    assertEquals(\"Property[minuteOfHour]\", test.property(DateTimeFieldType.minuteOfHour()).toString());\n    assertSame(test, test.property(DateTimeFieldType.minuteOfHour()).getReadablePartial());\n    assertSame(test, test.property(DateTimeFieldType.minuteOfHour()).getPartial());\n    assertEquals(20, test.property(DateTimeFieldType.minuteOfHour()).get());\n    assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsString());\n    assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsText());\n    assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsText(Locale.FRENCH));\n    assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsShortText());\n    assertEquals(\"20\", test.property(DateTimeFieldType.minuteOfHour()).getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().minutes(), test.property(DateTimeFieldType.minuteOfHour()).getDurationField());\n    assertEquals(test.getChronology().hours(), test.property(DateTimeFieldType.minuteOfHour()).getRangeDurationField());\n    assertEquals(2, test.property(DateTimeFieldType.minuteOfHour()).getMaximumTextLength(null));\n    assertEquals(2, test.property(DateTimeFieldType.minuteOfHour()).getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1814, "method_signature": "void testPropertyGetMinute()"}, "TestPeriodFormat.data_formatStandard": {"callee_method_names": [], "method_name": "TestPeriodFormat.data_formatStandard", "method_implementation": "{\n    return new Object[][] { { BG, \"2 \u0433\u043e\u0434\u0438\u043d\u0438, 1 \u043c\u0435\u0441\u0435\u0446, 1 \u0434\u0435\u043d, 5 \u0447\u0430\u0441\u0430, 6 \u043c\u0438\u043d\u0443\u0442\u0438, 7 \u0441\u0435\u043a\u0443\u043d\u0434\u0438 \u0438 8 \u043c\u0438\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u0438\" }, { CA, \"2 anys, 1 mes, 1 dia, 5 hores, 6 minuts, 7 segons i 8 milisegons\" }, { ZH, \"2\u5e741\u4e2a\u67081\u59295\u5c0f\u65f66\u52067\u79d28\u6beb\u79d2\" }, { CS, \"2 roky, 1 m\u011bs\u00edc, 1 den, 5 hodin, 6 minut, 7 sekund a 8 milisekund\" }, { DA, \"2 \u00e5r, 1 m\u00e5ned, 1 dag, 5 timer, 6 minutter, 7 sekunder og 8 millisekunder\" }, { DE, \"2 Jahre, 1 Monat, 1 Tag, 5 Stunden, 6 Minuten, 7 Sekunden und 8 Millisekunden\" }, { EN, \"2 years, 1 month, 1 day, 5 hours, 6 minutes, 7 seconds and 8 milliseconds\" }, { EL, \"2 \u03c7\u03c1\u03cc\u03bd\u03b9\u03b1, 1 \u03bc\u03ae\u03bd\u03b1\u03c2, 1 \u03bc\u03ad\u03c1\u03b1, 5 \u03ce\u03c1\u03b5\u03c2, 6 \u03bb\u03b5\u03c0\u03c4\u03ac, 7 \u03b4\u03b5\u03c5\u03c4\u03b5\u03c1\u03cc\u03bb\u03b5\u03c0\u03c4\u03b1 \u03ba\u03b1\u03b9 8 \u03c7\u03b9\u03bb\u03b9\u03bf\u03c3\u03c4\u03ac \u03c4\u03bf\u03c5 \u03b4\u03b5\u03c5\u03c4\u03b5\u03c1\u03bf\u03bb\u03ad\u03c0\u03c4\u03bf\u03c5\" }, { ES, \"2 a\u00f1os, 1 mes, 1 d\u00eda, 5 horas, 6 minutos, 7 segundos y 8 milisegundos\" }, { EU, \"2 urte, 1 hilabete, 1 egun, 5 ordu, 6 minuto, 7 segundo eta 8 milisegundo\" }, { FR, \"2 ann\u00e9es, 1 mois, 1 jour, 5 heures, 6 minutes, 7 secondes et 8 millisecondes\" }, { FI, \"2 vuotta, 1 kuukausi, 1 p\u00e4iv\u00e4, 5 tuntia, 6 minuuttia, 7 sekuntia ja 8 millisekuntia\" }, { GA, \"2 blianta, 1 m\u00ed, 1 l\u00e1, 5 uair, 6 miontuairisc\u00ed, 7 soicind agus 8 milleasoicind\" }, { HI, \"2 \u0938\u093e\u0932, 1 \u092e\u0939\u0940\u0928\u093e, 1 \u0926\u093f\u0928, 5 \u0918\u0902\u091f\u0947, 6 \u092e\u093f\u0928\u091f, 7 \u0938\u0947\u0915\u0902\u0921 \u0914\u0930 8 \u092e\u093f\u0932\u0940\u0938\u0947\u0915\u0902\u0921\" }, { HU, \"2 \u00e9v, 1 h\u00f3nap, 1 nap, 5 \u00f3ra, 6 perc, 7 m\u00e1sodperc \u00e9s 8 miliszekundum\" }, { IN, \"2 tahun, 1 bulan, 1 hari, 5 jam, 6 menit, 7 detik dan8 millidetik\" }, { IW, \"2 \u05e9\u05e0\u05d9\u05dd, 1 \u05d7\u05d5\u05d3\u05e9, 1 \u05d9\u05d5\u05dd, 5 \u05e9\u05e2\u05d5\u05ea, 6 \u05d3\u05e7\u05d5\u05ea, 7 \u05e9\u05e0\u05d9\u05d5\u05ea \u05d5-8 \u05d0\u05dc\u05e4\u05d9\u05d5\u05ea \u05e9\u05e0\u05d9\u05d9\u05d4\" }, { JA, \"2\u5e741\u304b\u67081\u65e55\u6642\u95936\u52067\u79d28\u30df\u30ea\u79d2\" }, { MS, \"2 tahun, 1 bulan, 1 hari, 5 jam, 6 minit, 7 saat dan 8 milisaat\" }, { NL, \"2 jaar, 1 maand, 1 dag, 5 uur, 6 minuten, 7 seconden en 8 milliseconden\" }, { NN, \"2 \u00e5r, 1 m\u00e5nad, 1 dag, 5 timar, 6 minutt, 7 sekund og 8 millisekund\" }, { NO, \"2 \u00e5r, 1 m\u00e5ned, 1 dag, 5 timer, 6 minutter, 7 sekunder og 8 millisekunder\" }, { PL, \"2 lata, 1 miesi\u0105c, 1 dzie\\u0144, 5 godzin, 6 minut, 7 sekund i 8 milisekund\" }, { PT, \"2 anos, 1 m\u00eas, 1 dia, 5 horas, 6 minutos, 7 segundos e 8 milissegundos\" }, { RO, \"2 ani, 1 lun\u0103, 1 zi, 5 ore, 6 minute, 7 secunde \u0219i 8 milisecunde\" }, { RU, \"2 \u0433\u043e\u0434\u0430, 1 \u043c\u0435\u0441\u044f\u0446, 1 \u0434\u0435\u043d\u044c, 5 \u0447\u0430\u0441\u043e\u0432, 6 \u043c\u0438\u043d\u0443\u0442, 7 \u0441\u0435\u043a\u0443\u043d\u0434 \u0438 8 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\" }, { SK, \"2 roky, 1 mesiac, 1 de\u0148, 5 hod\u00edn, 6 min\u00fat, 7 sek\u00fand a 8 milisek\u00fand\" }, { SQ, \"2 vjet, 1 muaj, 1 dit\u00eb, 5 or\u00eb, 6 minuta, 7 sekonda dhe 8 milisekonda\" }, { SV, \"2 \u00e5r, 1 m\u00e5nad, 1 dag, 5 timmar, 6 minuter, 7 sekunder och 8 millisekunder\" }, { TR, \"2 y\u0131l, 1 ay, 1 g\u00fcn, 5 saat, 6 dakika, 7 saniye ve 8 milisaniye\" }, { UK, \"2 \u0440\u043e\u043a\u0443, 1 \u043c\u0456\u0441\u044f\u0446\u044c, 1 \u0434\u0435\u043d\u044c, 5 \u0433\u043e\u0434\u0438\u043d, 6 \u0445\u0432\u0438\u043b\u0438\u043d, 7 \u0441\u0435\u043a\u0443\u043d\u0434 \u0438 8 \u043c\u0456\u043b\u0456\u0441\u0435\u043a\u0443\u043d\u0434\" } };\n}", "repo_id": "7", "comment": "// -----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2335, "method_signature": "Object[][] data_formatStandard()"}, "TestPeriodFormat.testSubclassableConstructor": {"callee_method_names": [], "method_name": "TestPeriodFormat.testSubclassableConstructor", "method_implementation": "{\n    PeriodFormat f = new PeriodFormat() {\n    };\n    assertNotNull(f);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2333, "method_signature": "void testSubclassableConstructor()"}, "TestPeriodFormat.test_getDefault_checkRedundantSeparator": {"callee_method_names": ["IllegalFieldValueException.getClass"], "method_name": "TestPeriodFormat.test_getDefault_checkRedundantSeparator", "method_implementation": "{\n    try {\n        PeriodFormat.getDefault().parsePeriod(\"2 days and 5 hours \");\n        fail(\"No exception was caught\");\n    } catch (Exception e) {\n        assertEquals(IllegalArgumentException.class, e.getClass());\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2334, "method_signature": "void test_getDefault_checkRedundantSeparator()"}, "TestPeriodFormat.test_wordBased_en_withLocale_pt": {"callee_method_ids": [904, 908, 900, 904, 908, 900, 904, 908, 900, 904, 908], "callee_method_names": ["PeriodFormatter.print", "PeriodFormatter.parsePeriod", "PeriodFormatter.getLocale", "PeriodFormatter.withLocale", "PeriodFormatter.print", "PeriodFormatter.parsePeriod", "PeriodFormatter.getLocale", "PeriodFormatter.withLocale", "PeriodFormatter.print", "PeriodFormatter.parsePeriod", "PeriodFormatter.getLocale", "PeriodFormatter.withLocale", "PeriodFormatter.print", "PeriodFormatter.parsePeriod", "PeriodFormatter.getLocale"], "method_name": "TestPeriodFormat.test_wordBased_en_withLocale_pt", "method_implementation": "{\n    Period p = Period.days(2).withHours(5);\n    PeriodFormatter format1 = PeriodFormat.wordBased(EN);\n    assertEquals(\"2 days and 5 hours\", format1.print(p));\n    assertEquals(p, format1.parsePeriod(\"2 days and 5 hours\"));\n    assertEquals(EN, format1.getLocale());\n    PeriodFormatter format2 = format1.withLocale(PT);\n    assertEquals(\"2 dias e 5 horas\", format2.print(p));\n    assertEquals(p, format2.parsePeriod(\"2 dias e 5 horas\"));\n    assertEquals(PT, format2.getLocale());\n    PeriodFormatter format3 = format1.withLocale(DE);\n    assertEquals(\"2 Tage und 5 Stunden\", format3.print(p));\n    assertEquals(p, format3.parsePeriod(\"2 Tage und 5 Stunden\"));\n    assertEquals(DE, format3.getLocale());\n    PeriodFormatter format4 = format1.withLocale(null);\n    assertEquals(\"2 days and 5 hours\", format4.print(p));\n    assertEquals(p, format4.parsePeriod(\"2 days and 5 hours\"));\n    assertEquals(null, format4.getLocale());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2342, "method_signature": "void test_wordBased_en_withLocale_pt()"}, "TestPeriodFormat.test_wordBased_fr_from_de": {"callee_method_names": [], "method_name": "TestPeriodFormat.test_wordBased_fr_from_de", "method_implementation": "{\n    Locale.setDefault(DE);\n    Period p = new Period(0, 0, 0, 1, 5, 6, 7, 8);\n    assertEquals(\"1 jour, 5 heures, 6 minutes, 7 secondes et 8 millisecondes\", PeriodFormat.wordBased(FR).print(p));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2341, "method_signature": "void test_wordBased_fr_from_de()"}, "TestPeriodFormat.test_wordBased_ja_checkRedundantSeparator": {"callee_method_names": ["IllegalFieldValueException.getClass"], "method_name": "TestPeriodFormat.test_wordBased_ja_checkRedundantSeparator", "method_implementation": "{\n    try {\n        // Spaces are not valid separators in Japanese\n        PeriodFormat.wordBased(JA).parsePeriod(\"2\\u65E5 \");\n        fail(\"No exception was caught\");\n    } catch (Exception e) {\n        assertEquals(IllegalArgumentException.class, e.getClass());\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2336, "method_signature": "void test_wordBased_ja_checkRedundantSeparator()"}, "TestPeriodFormat.test_wordBased_pl_checkRedundantSeparator": {"callee_method_names": ["IllegalFieldValueException.getClass"], "method_name": "TestPeriodFormat.test_wordBased_pl_checkRedundantSeparator", "method_implementation": "{\n    try {\n        PeriodFormat.wordBased(PL).parsePeriod(\"2 dni and 5 godzin \");\n        fail(\"No exception was caught\");\n    } catch (Exception e) {\n        assertEquals(IllegalArgumentException.class, e.getClass());\n    }\n}", "repo_id": "7", "comment": "// -----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2337, "method_signature": "void test_wordBased_pl_checkRedundantSeparator()"}, "TestPeriodFormat.test_wordBased_pl_regEx": {"callee_method_ids": [904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904], "callee_method_names": ["PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print"], "method_name": "TestPeriodFormat.test_wordBased_pl_regEx", "method_implementation": "{\n    PeriodFormatter pf = PeriodFormat.wordBased(PL);\n    assertEquals(\"1 rok\", pf.print(Period.years(1)));\n    assertEquals(\"2 lata\", pf.print(Period.years(2)));\n    assertEquals(\"5 lat\", pf.print(Period.years(5)));\n    assertEquals(\"12 lat\", pf.print(Period.years(12)));\n    assertEquals(\"15 lat\", pf.print(Period.years(15)));\n    assertEquals(\"1112 lat\", pf.print(Period.years(1112)));\n    assertEquals(\"1115 lat\", pf.print(Period.years(1115)));\n    assertEquals(\"2112 lat\", pf.print(Period.years(2112)));\n    assertEquals(\"2115 lat\", pf.print(Period.years(2115)));\n    assertEquals(\"2212 lat\", pf.print(Period.years(2212)));\n    assertEquals(\"2215 lat\", pf.print(Period.years(2215)));\n    assertEquals(\"22 lata\", pf.print(Period.years(22)));\n    assertEquals(\"25 lat\", pf.print(Period.years(25)));\n    assertEquals(\"1122 lata\", pf.print(Period.years(1122)));\n    assertEquals(\"1125 lat\", pf.print(Period.years(1125)));\n    assertEquals(\"2122 lata\", pf.print(Period.years(2122)));\n    assertEquals(\"2125 lat\", pf.print(Period.years(2125)));\n    assertEquals(\"2222 lata\", pf.print(Period.years(2222)));\n    assertEquals(\"2225 lat\", pf.print(Period.years(2225)));\n    assertEquals(\"1 miesi\\u0105c\", pf.print(Period.months(1)));\n    assertEquals(\"2 miesi\\u0105ce\", pf.print(Period.months(2)));\n    assertEquals(\"5 miesi\\u0119cy\", pf.print(Period.months(5)));\n    assertEquals(\"12 miesi\\u0119cy\", pf.print(Period.months(12)));\n    assertEquals(\"15 miesi\\u0119cy\", pf.print(Period.months(15)));\n    assertEquals(\"1112 miesi\\u0119cy\", pf.print(Period.months(1112)));\n    assertEquals(\"1115 miesi\\u0119cy\", pf.print(Period.months(1115)));\n    assertEquals(\"2112 miesi\\u0119cy\", pf.print(Period.months(2112)));\n    assertEquals(\"2115 miesi\\u0119cy\", pf.print(Period.months(2115)));\n    assertEquals(\"2212 miesi\\u0119cy\", pf.print(Period.months(2212)));\n    assertEquals(\"2215 miesi\\u0119cy\", pf.print(Period.months(2215)));\n    assertEquals(\"22 miesi\\u0105ce\", pf.print(Period.months(22)));\n    assertEquals(\"25 miesi\\u0119cy\", pf.print(Period.months(25)));\n    assertEquals(\"1122 miesi\\u0105ce\", pf.print(Period.months(1122)));\n    assertEquals(\"1125 miesi\\u0119cy\", pf.print(Period.months(1125)));\n    assertEquals(\"2122 miesi\\u0105ce\", pf.print(Period.months(2122)));\n    assertEquals(\"2125 miesi\\u0119cy\", pf.print(Period.months(2125)));\n    assertEquals(\"2222 miesi\\u0105ce\", pf.print(Period.months(2222)));\n    assertEquals(\"2225 miesi\\u0119cy\", pf.print(Period.months(2225)));\n    assertEquals(\"1 tydzie\\u0144\", pf.print(Period.weeks(1)));\n    assertEquals(\"2 tygodnie\", pf.print(Period.weeks(2)));\n    assertEquals(\"5 tygodni\", pf.print(Period.weeks(5)));\n    assertEquals(\"12 tygodni\", pf.print(Period.weeks(12)));\n    assertEquals(\"15 tygodni\", pf.print(Period.weeks(15)));\n    assertEquals(\"1112 tygodni\", pf.print(Period.weeks(1112)));\n    assertEquals(\"1115 tygodni\", pf.print(Period.weeks(1115)));\n    assertEquals(\"2112 tygodni\", pf.print(Period.weeks(2112)));\n    assertEquals(\"2115 tygodni\", pf.print(Period.weeks(2115)));\n    assertEquals(\"2212 tygodni\", pf.print(Period.weeks(2212)));\n    assertEquals(\"2215 tygodni\", pf.print(Period.weeks(2215)));\n    assertEquals(\"22 tygodnie\", pf.print(Period.weeks(22)));\n    assertEquals(\"25 tygodni\", pf.print(Period.weeks(25)));\n    assertEquals(\"1122 tygodnie\", pf.print(Period.weeks(1122)));\n    assertEquals(\"1125 tygodni\", pf.print(Period.weeks(1125)));\n    assertEquals(\"2122 tygodnie\", pf.print(Period.weeks(2122)));\n    assertEquals(\"2125 tygodni\", pf.print(Period.weeks(2125)));\n    assertEquals(\"2222 tygodnie\", pf.print(Period.weeks(2222)));\n    assertEquals(\"2225 tygodni\", pf.print(Period.weeks(2225)));\n    assertEquals(\"1 dzie\\u0144\", pf.print(Period.days(1)));\n    assertEquals(\"2 dni\", pf.print(Period.days(2)));\n    assertEquals(\"5 dni\", pf.print(Period.days(5)));\n    assertEquals(\"12 dni\", pf.print(Period.days(12)));\n    assertEquals(\"15 dni\", pf.print(Period.days(15)));\n    assertEquals(\"22 dni\", pf.print(Period.days(22)));\n    assertEquals(\"25 dni\", pf.print(Period.days(25)));\n    assertEquals(\"1 godzina\", pf.print(Period.hours(1)));\n    assertEquals(\"2 godziny\", pf.print(Period.hours(2)));\n    assertEquals(\"5 godzin\", pf.print(Period.hours(5)));\n    assertEquals(\"12 godzin\", pf.print(Period.hours(12)));\n    assertEquals(\"15 godzin\", pf.print(Period.hours(15)));\n    assertEquals(\"1112 godzin\", pf.print(Period.hours(1112)));\n    assertEquals(\"1115 godzin\", pf.print(Period.hours(1115)));\n    assertEquals(\"2112 godzin\", pf.print(Period.hours(2112)));\n    assertEquals(\"2115 godzin\", pf.print(Period.hours(2115)));\n    assertEquals(\"2212 godzin\", pf.print(Period.hours(2212)));\n    assertEquals(\"2215 godzin\", pf.print(Period.hours(2215)));\n    assertEquals(\"22 godziny\", pf.print(Period.hours(22)));\n    assertEquals(\"25 godzin\", pf.print(Period.hours(25)));\n    assertEquals(\"1122 godziny\", pf.print(Period.hours(1122)));\n    assertEquals(\"1125 godzin\", pf.print(Period.hours(1125)));\n    assertEquals(\"2122 godziny\", pf.print(Period.hours(2122)));\n    assertEquals(\"2125 godzin\", pf.print(Period.hours(2125)));\n    assertEquals(\"2222 godziny\", pf.print(Period.hours(2222)));\n    assertEquals(\"2225 godzin\", pf.print(Period.hours(2225)));\n    assertEquals(\"1 minuta\", pf.print(Period.minutes(1)));\n    assertEquals(\"2 minuty\", pf.print(Period.minutes(2)));\n    assertEquals(\"5 minut\", pf.print(Period.minutes(5)));\n    assertEquals(\"12 minut\", pf.print(Period.minutes(12)));\n    assertEquals(\"15 minut\", pf.print(Period.minutes(15)));\n    assertEquals(\"1112 minut\", pf.print(Period.minutes(1112)));\n    assertEquals(\"1115 minut\", pf.print(Period.minutes(1115)));\n    assertEquals(\"2112 minut\", pf.print(Period.minutes(2112)));\n    assertEquals(\"2115 minut\", pf.print(Period.minutes(2115)));\n    assertEquals(\"2212 minut\", pf.print(Period.minutes(2212)));\n    assertEquals(\"2215 minut\", pf.print(Period.minutes(2215)));\n    assertEquals(\"22 minuty\", pf.print(Period.minutes(22)));\n    assertEquals(\"25 minut\", pf.print(Period.minutes(25)));\n    assertEquals(\"1122 minuty\", pf.print(Period.minutes(1122)));\n    assertEquals(\"1125 minut\", pf.print(Period.minutes(1125)));\n    assertEquals(\"2122 minuty\", pf.print(Period.minutes(2122)));\n    assertEquals(\"2125 minut\", pf.print(Period.minutes(2125)));\n    assertEquals(\"2222 minuty\", pf.print(Period.minutes(2222)));\n    assertEquals(\"2225 minut\", pf.print(Period.minutes(2225)));\n    assertEquals(\"1 sekunda\", pf.print(Period.seconds(1)));\n    assertEquals(\"2 sekundy\", pf.print(Period.seconds(2)));\n    assertEquals(\"5 sekund\", pf.print(Period.seconds(5)));\n    assertEquals(\"12 sekund\", pf.print(Period.seconds(12)));\n    assertEquals(\"15 sekund\", pf.print(Period.seconds(15)));\n    assertEquals(\"1112 sekund\", pf.print(Period.seconds(1112)));\n    assertEquals(\"1115 sekund\", pf.print(Period.seconds(1115)));\n    assertEquals(\"2112 sekund\", pf.print(Period.seconds(2112)));\n    assertEquals(\"2115 sekund\", pf.print(Period.seconds(2115)));\n    assertEquals(\"2212 sekund\", pf.print(Period.seconds(2212)));\n    assertEquals(\"2215 sekund\", pf.print(Period.seconds(2215)));\n    assertEquals(\"22 sekundy\", pf.print(Period.seconds(22)));\n    assertEquals(\"25 sekund\", pf.print(Period.seconds(25)));\n    assertEquals(\"1122 sekundy\", pf.print(Period.seconds(1122)));\n    assertEquals(\"1125 sekund\", pf.print(Period.seconds(1125)));\n    assertEquals(\"2122 sekundy\", pf.print(Period.seconds(2122)));\n    assertEquals(\"2125 sekund\", pf.print(Period.seconds(2125)));\n    assertEquals(\"2222 sekundy\", pf.print(Period.seconds(2222)));\n    assertEquals(\"2225 sekund\", pf.print(Period.seconds(2225)));\n    assertEquals(\"1 milisekunda\", pf.print(Period.millis(1)));\n    assertEquals(\"2 milisekundy\", pf.print(Period.millis(2)));\n    assertEquals(\"5 milisekund\", pf.print(Period.millis(5)));\n    assertEquals(\"12 milisekund\", pf.print(Period.millis(12)));\n    assertEquals(\"15 milisekund\", pf.print(Period.millis(15)));\n    assertEquals(\"1112 milisekund\", pf.print(Period.millis(1112)));\n    assertEquals(\"1115 milisekund\", pf.print(Period.millis(1115)));\n    assertEquals(\"2112 milisekund\", pf.print(Period.millis(2112)));\n    assertEquals(\"2115 milisekund\", pf.print(Period.millis(2115)));\n    assertEquals(\"2212 milisekund\", pf.print(Period.millis(2212)));\n    assertEquals(\"2215 milisekund\", pf.print(Period.millis(2215)));\n    assertEquals(\"22 milisekundy\", pf.print(Period.millis(22)));\n    assertEquals(\"25 milisekund\", pf.print(Period.millis(25)));\n    assertEquals(\"1122 milisekundy\", pf.print(Period.millis(1122)));\n    assertEquals(\"1125 milisekund\", pf.print(Period.millis(1125)));\n    assertEquals(\"2122 milisekundy\", pf.print(Period.millis(2122)));\n    assertEquals(\"2125 milisekund\", pf.print(Period.millis(2125)));\n    assertEquals(\"2222 milisekundy\", pf.print(Period.millis(2222)));\n    assertEquals(\"2225 milisekund\", pf.print(Period.millis(2225)));\n}", "repo_id": "7", "comment": "// -----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2338, "method_signature": "void test_wordBased_pl_regEx()"}, "TestPeriodFormat.test_wordBased_ru_checkRedundantSeparator": {"callee_method_names": ["IllegalFieldValueException.getClass"], "method_name": "TestPeriodFormat.test_wordBased_ru_checkRedundantSeparator", "method_implementation": "{\n    try {\n        PeriodFormat.wordBased(RU).parsePeriod(\"2 \u0434\u043d\u044f and 5 \u043c\u0438\u043d\u0443\u0442\");\n        fail(\"No exception was caught\");\n    } catch (Exception e) {\n        assertEquals(IllegalArgumentException.class, e.getClass());\n    }\n}", "repo_id": "7", "comment": "// -----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2339, "method_signature": "void test_wordBased_ru_checkRedundantSeparator()"}, "TestPeriodFormat.test_wordBased_ru_regEx": {"callee_method_ids": [904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904, 904], "callee_method_names": ["PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print", "PeriodFormatter.print"], "method_name": "TestPeriodFormat.test_wordBased_ru_regEx", "method_implementation": "{\n    PeriodFormatter pf = PeriodFormat.wordBased(RU);\n    assertEquals(\"1 \u0433\u043e\u0434\", pf.print(Period.years(1)));\n    assertEquals(\"11 \u043b\u0435\u0442\", pf.print(Period.years(11)));\n    assertEquals(\"21 \u0433\u043e\u0434\", pf.print(Period.years(21)));\n    assertEquals(\"101 \u0433\u043e\u0434\", pf.print(Period.years(101)));\n    assertEquals(\"111 \u043b\u0435\u0442\", pf.print(Period.years(111)));\n    assertEquals(\"121 \u0433\u043e\u0434\", pf.print(Period.years(121)));\n    assertEquals(\"2001 \u0433\u043e\u0434\", pf.print(Period.years(2001)));\n    assertEquals(\"2 \u0433\u043e\u0434\u0430\", pf.print(Period.years(2)));\n    assertEquals(\"3 \u0433\u043e\u0434\u0430\", pf.print(Period.years(3)));\n    assertEquals(\"4 \u0433\u043e\u0434\u0430\", pf.print(Period.years(4)));\n    assertEquals(\"12 \u043b\u0435\u0442\", pf.print(Period.years(12)));\n    assertEquals(\"13 \u043b\u0435\u0442\", pf.print(Period.years(13)));\n    assertEquals(\"14 \u043b\u0435\u0442\", pf.print(Period.years(14)));\n    assertEquals(\"22 \u0433\u043e\u0434\u0430\", pf.print(Period.years(22)));\n    assertEquals(\"23 \u0433\u043e\u0434\u0430\", pf.print(Period.years(23)));\n    assertEquals(\"24 \u0433\u043e\u0434\u0430\", pf.print(Period.years(24)));\n    assertEquals(\"102 \u0433\u043e\u0434\u0430\", pf.print(Period.years(102)));\n    assertEquals(\"112 \u043b\u0435\u0442\", pf.print(Period.years(112)));\n    assertEquals(\"124 \u0433\u043e\u0434\u0430\", pf.print(Period.years(124)));\n    assertEquals(\"5 \u043b\u0435\u0442\", pf.print(Period.years(5)));\n    assertEquals(\"15 \u043b\u0435\u0442\", pf.print(Period.years(15)));\n    assertEquals(\"25 \u043b\u0435\u0442\", pf.print(Period.years(25)));\n    assertEquals(\"105 \u043b\u0435\u0442\", pf.print(Period.years(105)));\n    assertEquals(\"1005 \u043b\u0435\u0442\", pf.print(Period.years(1005)));\n    assertEquals(\"1 \u043c\u0435\u0441\u044f\u0446\", pf.print(Period.months(1)));\n    assertEquals(\"11 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(11)));\n    assertEquals(\"21 \u043c\u0435\u0441\u044f\u0446\", pf.print(Period.months(21)));\n    assertEquals(\"101 \u043c\u0435\u0441\u044f\u0446\", pf.print(Period.months(101)));\n    assertEquals(\"111 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(111)));\n    assertEquals(\"121 \u043c\u0435\u0441\u044f\u0446\", pf.print(Period.months(121)));\n    assertEquals(\"2001 \u043c\u0435\u0441\u044f\u0446\", pf.print(Period.months(2001)));\n    assertEquals(\"2 \u043c\u0435\u0441\u044f\u0446\u0430\", pf.print(Period.months(2)));\n    assertEquals(\"3 \u043c\u0435\u0441\u044f\u0446\u0430\", pf.print(Period.months(3)));\n    assertEquals(\"4 \u043c\u0435\u0441\u044f\u0446\u0430\", pf.print(Period.months(4)));\n    assertEquals(\"12 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(12)));\n    assertEquals(\"13 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(13)));\n    assertEquals(\"14 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(14)));\n    assertEquals(\"22 \u043c\u0435\u0441\u044f\u0446\u0430\", pf.print(Period.months(22)));\n    assertEquals(\"23 \u043c\u0435\u0441\u044f\u0446\u0430\", pf.print(Period.months(23)));\n    assertEquals(\"24 \u043c\u0435\u0441\u044f\u0446\u0430\", pf.print(Period.months(24)));\n    assertEquals(\"102 \u043c\u0435\u0441\u044f\u0446\u0430\", pf.print(Period.months(102)));\n    assertEquals(\"112 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(112)));\n    assertEquals(\"124 \u043c\u0435\u0441\u044f\u0446\u0430\", pf.print(Period.months(124)));\n    assertEquals(\"5 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(5)));\n    assertEquals(\"15 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(15)));\n    assertEquals(\"25 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(25)));\n    assertEquals(\"105 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(105)));\n    assertEquals(\"1005 \u043c\u0435\u0441\u044f\u0446\u0435\u0432\", pf.print(Period.months(1005)));\n    assertEquals(\"1 \u043d\u0435\u0434\u0435\u043b\u044f\", pf.print(Period.weeks(1)));\n    assertEquals(\"11 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(11)));\n    assertEquals(\"21 \u043d\u0435\u0434\u0435\u043b\u044f\", pf.print(Period.weeks(21)));\n    assertEquals(\"101 \u043d\u0435\u0434\u0435\u043b\u044f\", pf.print(Period.weeks(101)));\n    assertEquals(\"111 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(111)));\n    assertEquals(\"121 \u043d\u0435\u0434\u0435\u043b\u044f\", pf.print(Period.weeks(121)));\n    assertEquals(\"2001 \u043d\u0435\u0434\u0435\u043b\u044f\", pf.print(Period.weeks(2001)));\n    assertEquals(\"2 \u043d\u0435\u0434\u0435\u043b\u0438\", pf.print(Period.weeks(2)));\n    assertEquals(\"3 \u043d\u0435\u0434\u0435\u043b\u0438\", pf.print(Period.weeks(3)));\n    assertEquals(\"4 \u043d\u0435\u0434\u0435\u043b\u0438\", pf.print(Period.weeks(4)));\n    assertEquals(\"12 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(12)));\n    assertEquals(\"13 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(13)));\n    assertEquals(\"14 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(14)));\n    assertEquals(\"22 \u043d\u0435\u0434\u0435\u043b\u0438\", pf.print(Period.weeks(22)));\n    assertEquals(\"23 \u043d\u0435\u0434\u0435\u043b\u0438\", pf.print(Period.weeks(23)));\n    assertEquals(\"24 \u043d\u0435\u0434\u0435\u043b\u0438\", pf.print(Period.weeks(24)));\n    assertEquals(\"102 \u043d\u0435\u0434\u0435\u043b\u0438\", pf.print(Period.weeks(102)));\n    assertEquals(\"112 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(112)));\n    assertEquals(\"124 \u043d\u0435\u0434\u0435\u043b\u0438\", pf.print(Period.weeks(124)));\n    assertEquals(\"5 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(5)));\n    assertEquals(\"15 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(15)));\n    assertEquals(\"25 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(25)));\n    assertEquals(\"105 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(105)));\n    assertEquals(\"1005 \u043d\u0435\u0434\u0435\u043b\u044c\", pf.print(Period.weeks(1005)));\n    assertEquals(\"1 \u0434\u0435\u043d\u044c\", pf.print(Period.days(1)));\n    assertEquals(\"11 \u0434\u043d\u0435\u0439\", pf.print(Period.days(11)));\n    assertEquals(\"21 \u0434\u0435\u043d\u044c\", pf.print(Period.days(21)));\n    assertEquals(\"101 \u0434\u0435\u043d\u044c\", pf.print(Period.days(101)));\n    assertEquals(\"111 \u0434\u043d\u0435\u0439\", pf.print(Period.days(111)));\n    assertEquals(\"121 \u0434\u0435\u043d\u044c\", pf.print(Period.days(121)));\n    assertEquals(\"2001 \u0434\u0435\u043d\u044c\", pf.print(Period.days(2001)));\n    assertEquals(\"2 \u0434\u043d\u044f\", pf.print(Period.days(2)));\n    assertEquals(\"3 \u0434\u043d\u044f\", pf.print(Period.days(3)));\n    assertEquals(\"4 \u0434\u043d\u044f\", pf.print(Period.days(4)));\n    assertEquals(\"12 \u0434\u043d\u0435\u0439\", pf.print(Period.days(12)));\n    assertEquals(\"13 \u0434\u043d\u0435\u0439\", pf.print(Period.days(13)));\n    assertEquals(\"14 \u0434\u043d\u0435\u0439\", pf.print(Period.days(14)));\n    assertEquals(\"22 \u0434\u043d\u044f\", pf.print(Period.days(22)));\n    assertEquals(\"23 \u0434\u043d\u044f\", pf.print(Period.days(23)));\n    assertEquals(\"24 \u0434\u043d\u044f\", pf.print(Period.days(24)));\n    assertEquals(\"102 \u0434\u043d\u044f\", pf.print(Period.days(102)));\n    assertEquals(\"112 \u0434\u043d\u0435\u0439\", pf.print(Period.days(112)));\n    assertEquals(\"124 \u0434\u043d\u044f\", pf.print(Period.days(124)));\n    assertEquals(\"5 \u0434\u043d\u0435\u0439\", pf.print(Period.days(5)));\n    assertEquals(\"15 \u0434\u043d\u0435\u0439\", pf.print(Period.days(15)));\n    assertEquals(\"25 \u0434\u043d\u0435\u0439\", pf.print(Period.days(25)));\n    assertEquals(\"105 \u0434\u043d\u0435\u0439\", pf.print(Period.days(105)));\n    assertEquals(\"1005 \u0434\u043d\u0435\u0439\", pf.print(Period.days(1005)));\n    assertEquals(\"1 \u0447\u0430\u0441\", pf.print(Period.hours(1)));\n    assertEquals(\"11 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(11)));\n    assertEquals(\"21 \u0447\u0430\u0441\", pf.print(Period.hours(21)));\n    assertEquals(\"101 \u0447\u0430\u0441\", pf.print(Period.hours(101)));\n    assertEquals(\"111 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(111)));\n    assertEquals(\"121 \u0447\u0430\u0441\", pf.print(Period.hours(121)));\n    assertEquals(\"2001 \u0447\u0430\u0441\", pf.print(Period.hours(2001)));\n    assertEquals(\"2 \u0447\u0430\u0441\u0430\", pf.print(Period.hours(2)));\n    assertEquals(\"3 \u0447\u0430\u0441\u0430\", pf.print(Period.hours(3)));\n    assertEquals(\"4 \u0447\u0430\u0441\u0430\", pf.print(Period.hours(4)));\n    assertEquals(\"12 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(12)));\n    assertEquals(\"13 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(13)));\n    assertEquals(\"14 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(14)));\n    assertEquals(\"22 \u0447\u0430\u0441\u0430\", pf.print(Period.hours(22)));\n    assertEquals(\"23 \u0447\u0430\u0441\u0430\", pf.print(Period.hours(23)));\n    assertEquals(\"24 \u0447\u0430\u0441\u0430\", pf.print(Period.hours(24)));\n    assertEquals(\"102 \u0447\u0430\u0441\u0430\", pf.print(Period.hours(102)));\n    assertEquals(\"112 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(112)));\n    assertEquals(\"124 \u0447\u0430\u0441\u0430\", pf.print(Period.hours(124)));\n    assertEquals(\"5 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(5)));\n    assertEquals(\"15 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(15)));\n    assertEquals(\"25 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(25)));\n    assertEquals(\"105 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(105)));\n    assertEquals(\"1005 \u0447\u0430\u0441\u043e\u0432\", pf.print(Period.hours(1005)));\n    assertEquals(\"1 \u043c\u0438\u043d\u0443\u0442\u0430\", pf.print(Period.minutes(1)));\n    assertEquals(\"11 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(11)));\n    assertEquals(\"21 \u043c\u0438\u043d\u0443\u0442\u0430\", pf.print(Period.minutes(21)));\n    assertEquals(\"101 \u043c\u0438\u043d\u0443\u0442\u0430\", pf.print(Period.minutes(101)));\n    assertEquals(\"111 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(111)));\n    assertEquals(\"121 \u043c\u0438\u043d\u0443\u0442\u0430\", pf.print(Period.minutes(121)));\n    assertEquals(\"2001 \u043c\u0438\u043d\u0443\u0442\u0430\", pf.print(Period.minutes(2001)));\n    assertEquals(\"2 \u043c\u0438\u043d\u0443\u0442\u044b\", pf.print(Period.minutes(2)));\n    assertEquals(\"3 \u043c\u0438\u043d\u0443\u0442\u044b\", pf.print(Period.minutes(3)));\n    assertEquals(\"4 \u043c\u0438\u043d\u0443\u0442\u044b\", pf.print(Period.minutes(4)));\n    assertEquals(\"12 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(12)));\n    assertEquals(\"13 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(13)));\n    assertEquals(\"14 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(14)));\n    assertEquals(\"22 \u043c\u0438\u043d\u0443\u0442\u044b\", pf.print(Period.minutes(22)));\n    assertEquals(\"23 \u043c\u0438\u043d\u0443\u0442\u044b\", pf.print(Period.minutes(23)));\n    assertEquals(\"24 \u043c\u0438\u043d\u0443\u0442\u044b\", pf.print(Period.minutes(24)));\n    assertEquals(\"102 \u043c\u0438\u043d\u0443\u0442\u044b\", pf.print(Period.minutes(102)));\n    assertEquals(\"112 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(112)));\n    assertEquals(\"124 \u043c\u0438\u043d\u0443\u0442\u044b\", pf.print(Period.minutes(124)));\n    assertEquals(\"5 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(5)));\n    assertEquals(\"15 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(15)));\n    assertEquals(\"25 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(25)));\n    assertEquals(\"105 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(105)));\n    assertEquals(\"1005 \u043c\u0438\u043d\u0443\u0442\", pf.print(Period.minutes(1005)));\n    assertEquals(\"1 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.seconds(1)));\n    assertEquals(\"11 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(11)));\n    assertEquals(\"21 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.seconds(21)));\n    assertEquals(\"101 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.seconds(101)));\n    assertEquals(\"111 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(111)));\n    assertEquals(\"121 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.seconds(121)));\n    assertEquals(\"2001 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.seconds(2001)));\n    assertEquals(\"2 \u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.seconds(2)));\n    assertEquals(\"3 \u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.seconds(3)));\n    assertEquals(\"4 \u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.seconds(4)));\n    assertEquals(\"12 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(12)));\n    assertEquals(\"13 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(13)));\n    assertEquals(\"14 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(14)));\n    assertEquals(\"22 \u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.seconds(22)));\n    assertEquals(\"23 \u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.seconds(23)));\n    assertEquals(\"24 \u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.seconds(24)));\n    assertEquals(\"102 \u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.seconds(102)));\n    assertEquals(\"112 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(112)));\n    assertEquals(\"124 \u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.seconds(124)));\n    assertEquals(\"5 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(5)));\n    assertEquals(\"15 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(15)));\n    assertEquals(\"25 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(25)));\n    assertEquals(\"105 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(105)));\n    assertEquals(\"1005 \u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.seconds(1005)));\n    assertEquals(\"1 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.millis(1)));\n    assertEquals(\"11 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(11)));\n    assertEquals(\"21 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.millis(21)));\n    assertEquals(\"101 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.millis(101)));\n    assertEquals(\"111 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(111)));\n    assertEquals(\"121 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.millis(121)));\n    assertEquals(\"2001 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u0430\", pf.print(Period.millis(2001)));\n    assertEquals(\"2 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.millis(2)));\n    assertEquals(\"3 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.millis(3)));\n    assertEquals(\"4 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.millis(4)));\n    assertEquals(\"12 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(12)));\n    assertEquals(\"13 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(13)));\n    assertEquals(\"14 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(14)));\n    assertEquals(\"22 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.millis(22)));\n    assertEquals(\"23 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.millis(23)));\n    assertEquals(\"24 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.millis(24)));\n    assertEquals(\"102 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.millis(102)));\n    assertEquals(\"112 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(112)));\n    assertEquals(\"124 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u044b\", pf.print(Period.millis(124)));\n    assertEquals(\"5 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(5)));\n    assertEquals(\"15 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(15)));\n    assertEquals(\"25 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(25)));\n    assertEquals(\"105 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(105)));\n    assertEquals(\"1005 \u043c\u0438\u043b\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\", pf.print(Period.millis(1005)));\n}", "repo_id": "7", "comment": "// -----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2340, "method_signature": "void test_wordBased_ru_regEx()"}, "TestPeriodFormatParsing.testParseStandard1": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod"], "method_name": "TestPeriodFormatParsing.testParseStandard1", "method_implementation": "{\n    PeriodFormatter parser = PeriodFormat.getDefault();\n    Period p = parser.parsePeriod(\"6 years, 3 months and 2 days\");\n    assertEquals(new Period(6, 3, 0, 2, 0, 0, 0, 0), p);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2406, "method_signature": "void testParseStandard1()"}, "TestPeriodFormatter.testParseInto_simple": {"callee_method_ids": [907, 907, 907], "callee_method_names": ["PeriodFormatter.parseInto", "PeriodFormatter.parseInto", "PeriodFormatter.parseInto"], "method_name": "TestPeriodFormatter.testParseInto_simple", "method_implementation": "{\n    MutablePeriod expect = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    MutablePeriod result = new MutablePeriod();\n    assertEquals(20, f.parseInto(result, \"P1Y2M3W4DT5H6M7.008S\", 0));\n    assertEquals(expect, result);\n    try {\n        f.parseInto(null, \"P1Y2M3W4DT5H6M7.008S\", 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    assertEquals(~0, f.parseInto(result, \"ABC\", 0));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2405, "method_signature": "void testParseInto_simple()"}, "TestPeriodFormatter.testParseMutablePeriod_simple": {"callee_method_ids": [909, 909], "callee_method_names": ["PeriodFormatter.parseMutablePeriod", "PeriodFormatter.parseMutablePeriod"], "method_name": "TestPeriodFormatter.testParseMutablePeriod_simple", "method_implementation": "{\n    MutablePeriod expect = new MutablePeriod(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(expect, f.parseMutablePeriod(\"P1Y2M3W4DT5H6M7.008S\"));\n    try {\n        f.parseMutablePeriod(\"ABC\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2404, "method_signature": "void testParseMutablePeriod_simple()"}, "TestPeriodFormatter.testParsePeriod_simple": {"callee_method_ids": [908, 908], "callee_method_names": ["PeriodFormatter.parsePeriod", "PeriodFormatter.parsePeriod"], "method_name": "TestPeriodFormatter.testParsePeriod_simple", "method_implementation": "{\n    Period expect = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(expect, f.parsePeriod(\"P1Y2M3W4DT5H6M7.008S\"));\n    try {\n        f.parsePeriod(\"ABC\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2403, "method_signature": "void testParsePeriod_simple()"}, "TestPeriodFormatter.testPrint_bufferMethods": {"callee_method_ids": [903, 903], "callee_method_names": ["PeriodFormatter.printTo", "StringBuffer.toString", "PeriodFormatter.printTo"], "method_name": "TestPeriodFormatter.testPrint_bufferMethods", "method_implementation": "{\n    Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    StringBuffer buf = new StringBuffer();\n    f.printTo(buf, p);\n    assertEquals(\"P1Y2M3W4DT5H6M7.008S\", buf.toString());\n    buf = new StringBuffer();\n    try {\n        f.printTo(buf, null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2400, "method_signature": "void testPrint_bufferMethods()"}, "TestPeriodFormatter.testPrint_writerMethods": {"callee_method_ids": [903, 903], "callee_method_names": ["PeriodFormatter.printTo", "CharArrayWriter.toString", "PeriodFormatter.printTo"], "method_name": "TestPeriodFormatter.testPrint_writerMethods", "method_implementation": "{\n    Period p = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    CharArrayWriter out = new CharArrayWriter();\n    f.printTo(out, p);\n    assertEquals(\"P1Y2M3W4DT5H6M7.008S\", out.toString());\n    out = new CharArrayWriter();\n    try {\n        f.printTo(out, null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2401, "method_signature": "void testPrint_writerMethods()"}, "TestPeriodFormatter.testWithGetLocaleMethods": {"callee_method_ids": [900, 900, 900, 900], "callee_method_names": ["PeriodFormatter.withLocale", "PeriodFormatter.getLocale", "PeriodFormatter.withLocale", "PeriodFormatter.withLocale", "PeriodFormatter.getLocale", "PeriodFormatter.withLocale"], "method_name": "TestPeriodFormatter.testWithGetLocaleMethods", "method_implementation": "{\n    PeriodFormatter f2 = f.withLocale(Locale.FRENCH);\n    assertEquals(Locale.FRENCH, f2.getLocale());\n    assertSame(f2, f2.withLocale(Locale.FRENCH));\n    f2 = f.withLocale(null);\n    assertEquals(null, f2.getLocale());\n    assertSame(f2, f2.withLocale(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2402, "method_signature": "void testWithGetLocaleMethods()"}, "TestPeriodFormatterBuilder.testFormatAppend_PrinterParser_null_null": {"callee_method_names": [], "method_name": "TestPeriodFormatterBuilder.testFormatAppend_PrinterParser_null_null", "method_implementation": "{\n    try {\n        new PeriodFormatterBuilder().append(null, null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2399, "method_signature": "void testFormatAppend_PrinterParser_null_null()"}, "TestPeriodFormatterBuilder.testFormatLiteral": {"callee_method_ids": [870, 904], "callee_method_names": ["PeriodFormatterBuilder.appendLiteral", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter"], "method_name": "TestPeriodFormatterBuilder.testFormatLiteral", "method_implementation": "{\n    PeriodFormatter f = builder.appendLiteral(\"HELLO\").toFormatter();\n    assertEquals(\"HELLO\", f.print(PERIOD));\n    assertEquals(5, f.getPrinter().calculatePrintedLength(PERIOD, null));\n    assertEquals(0, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2397, "method_signature": "void testFormatLiteral()"}, "TestPeriodFormatterBuilder.testFormatPrefixComposite1": {"callee_method_ids": [874, 908, 908], "callee_method_names": ["PeriodFormatterBuilder.appendPrefix", "PeriodFormatter.parsePeriod", "PeriodFormatter.parsePeriod", "String.toUpperCase"], "method_name": "TestPeriodFormatterBuilder.testFormatPrefixComposite1", "method_implementation": "{\n    PeriodFormatter f = builder.appendPrefix(\"d\").appendPrefix(\"a\", \"ay\").appendPrefix(new String[] { \"^1$\", \"^.*$\" }, new String[] { \"y:\", \"s:\" }).appendDays().toFormatter();\n    String oneMS = Period.days(2).toString(f);\n    assertEquals(\"days:2\", oneMS);\n    Period period = f.parsePeriod(oneMS);\n    assertEquals(Period.days(2), period);\n    period = f.parsePeriod(oneMS.toUpperCase(Locale.ENGLISH));\n    assertEquals(Period.days(2), period);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2392, "method_signature": "void testFormatPrefixComposite1()"}, "TestPeriodFormatterBuilder.testFormatPrefixSimple1": {"callee_method_ids": [874, 904, 904], "callee_method_names": ["PeriodFormatterBuilder.appendPrefix", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter"], "method_name": "TestPeriodFormatterBuilder.testFormatPrefixSimple1", "method_implementation": "{\n    PeriodFormatter f = builder.appendPrefix(\"Years:\").appendYears().toFormatter();\n    assertEquals(\"Years:1\", f.print(PERIOD));\n    assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));\n    Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0);\n    assertEquals(\"Years:0\", f.print(p));\n    assertEquals(7, f.getPrinter().calculatePrintedLength(p, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2391, "method_signature": "void testFormatPrefixSimple1()"}, "TestPeriodFormatterBuilder.testFormatPrefixSuffix": {"callee_method_ids": [874, 904, 904], "callee_method_names": ["PeriodFormatterBuilder.appendPrefix", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter"], "method_name": "TestPeriodFormatterBuilder.testFormatPrefixSuffix", "method_implementation": "{\n    PeriodFormatter f = builder.appendPrefix(\"P\").appendYears().appendSuffix(\"Y\").toFormatter();\n    assertEquals(\"P1Y\", f.print(PERIOD));\n    assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));\n    Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0);\n    assertEquals(\"P0Y\", f.print(p));\n    assertEquals(3, f.getPrinter().calculatePrintedLength(p, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2395, "method_signature": "void testFormatPrefixSuffix()"}, "TestPeriodFormatterBuilder.testFormatPrintZeroDefault": {"callee_method_ids": [904, 904, 904, 904, 904], "callee_method_names": ["PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter"], "method_name": "TestPeriodFormatterBuilder.testFormatPrintZeroDefault", "method_implementation": "{\n    PeriodFormatter f = new PeriodFormatterBuilder().appendYears().appendLiteral(\"-\").appendMonths().appendLiteral(\"-\").appendWeeks().appendLiteral(\"-\").appendDays().toFormatter();\n    assertEquals(\"1-2-3-4\", f.print(PERIOD));\n    assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));\n    assertEquals(4, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));\n    assertEquals(\"---0\", f.print(EMPTY_YEAR_DAY_PERIOD));\n    assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_YEAR_DAY_PERIOD, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));\n    assertEquals(\"1---4\", f.print(YEAR_DAY_PERIOD));\n    assertEquals(5, f.getPrinter().calculatePrintedLength(YEAR_DAY_PERIOD, null));\n    assertEquals(2, f.getPrinter().countFieldsToPrint(YEAR_DAY_PERIOD, Integer.MAX_VALUE, null));\n    assertEquals(\"---0\", f.print(EMPTY_PERIOD));\n    assertEquals(4, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null));\n    // test only last instance of same field is output\n    f = new PeriodFormatterBuilder().appendYears().appendLiteral(\"-\").appendYears().toFormatter();\n    assertEquals(\"-0\", f.print(EMPTY_PERIOD));\n    assertEquals(2, f.getPrinter().calculatePrintedLength(EMPTY_PERIOD, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(EMPTY_PERIOD, Integer.MAX_VALUE, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2398, "method_signature": "void testFormatPrintZeroDefault()"}, "TestPeriodFormatterBuilder.testFormatSeparatorSimple": {"callee_method_ids": [904, 904, 904], "callee_method_names": ["PeriodFormatterBuilder.appendYears", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter"], "method_name": "TestPeriodFormatterBuilder.testFormatSeparatorSimple", "method_implementation": "{\n    PeriodFormatter f = builder.appendYears().appendSeparator(\"T\").appendHours().toFormatter();\n    assertEquals(\"1T5\", f.print(PERIOD));\n    assertEquals(3, f.getPrinter().calculatePrintedLength(PERIOD, null));\n    assertEquals(2, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));\n    assertEquals(\"5\", f.print(TIME_PERIOD));\n    assertEquals(1, f.getPrinter().calculatePrintedLength(TIME_PERIOD, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(TIME_PERIOD, Integer.MAX_VALUE, null));\n    assertEquals(\"1\", f.print(DATE_PERIOD));\n    assertEquals(1, f.getPrinter().calculatePrintedLength(DATE_PERIOD, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(DATE_PERIOD, Integer.MAX_VALUE, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2396, "method_signature": "void testFormatSeparatorSimple()"}, "TestPeriodFormatterBuilder.testFormatSuffixComposite1": {"callee_method_ids": [908, 908], "callee_method_names": ["PeriodFormatterBuilder.appendDays", "PeriodFormatter.parsePeriod", "PeriodFormatter.parsePeriod", "String.toUpperCase"], "method_name": "TestPeriodFormatterBuilder.testFormatSuffixComposite1", "method_implementation": "{\n    PeriodFormatter f = builder.appendDays().appendSuffix(\"d\").appendSuffix(\"a\", \"ay\").appendSuffix(new String[] { \"^1$\", \"^.*$\" }, new String[] { \"y\", \"s\" }).toFormatter();\n    String oneMS = Period.days(2).toString(f);\n    assertEquals(\"2days\", oneMS);\n    Period period = f.parsePeriod(oneMS);\n    assertEquals(Period.days(2), period);\n    period = f.parsePeriod(oneMS.toUpperCase(Locale.ENGLISH));\n    assertEquals(Period.days(2), period);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2394, "method_signature": "void testFormatSuffixComposite1()"}, "TestPeriodFormatterBuilder.testFormatSuffixSimple1": {"callee_method_ids": [904, 904], "callee_method_names": ["PeriodFormatterBuilder.appendYears", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter"], "method_name": "TestPeriodFormatterBuilder.testFormatSuffixSimple1", "method_implementation": "{\n    PeriodFormatter f = builder.appendYears().appendSuffix(\" years\").toFormatter();\n    assertEquals(\"1 years\", f.print(PERIOD));\n    assertEquals(7, f.getPrinter().calculatePrintedLength(PERIOD, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));\n    Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0);\n    assertEquals(\"0 years\", f.print(p));\n    assertEquals(7, f.getPrinter().calculatePrintedLength(p, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2393, "method_signature": "void testFormatSuffixSimple1()"}, "TestPeriodFormatterBuilder.testFormatYears": {"callee_method_ids": [904, 904], "callee_method_names": ["PeriodFormatterBuilder.appendYears", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter", "PeriodFormatter.print", "PeriodFormatter.getPrinter", "PeriodFormatter.getPrinter"], "method_name": "TestPeriodFormatterBuilder.testFormatYears", "method_implementation": "{\n    PeriodFormatter f = builder.appendYears().toFormatter();\n    assertEquals(\"1\", f.print(PERIOD));\n    assertEquals(1, f.getPrinter().calculatePrintedLength(PERIOD, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(PERIOD, Integer.MAX_VALUE, null));\n    Period p = new Period(0, 0, 0, 0, 0, 0, 0, 0);\n    assertEquals(\"0\", f.print(p));\n    assertEquals(1, f.getPrinter().calculatePrintedLength(p, null));\n    assertEquals(1, f.getPrinter().countFieldsToPrint(p, Integer.MAX_VALUE, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2390, "method_signature": "void testFormatYears()"}, "TestPeriodFormatterBuilder.testToFormatterPrinterParser": {"callee_method_ids": [880, 865, 866], "callee_method_names": ["PeriodFormatterBuilder.appendYears", "PeriodFormatterBuilder.toFormatter", "PeriodFormatterBuilder.toPrinter", "PeriodFormatterBuilder.toParser"], "method_name": "TestPeriodFormatterBuilder.testToFormatterPrinterParser", "method_implementation": "{\n    builder.appendYears();\n    assertNotNull(builder.toFormatter());\n    assertNotNull(builder.toPrinter());\n    assertNotNull(builder.toParser());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2389, "method_signature": "void testToFormatterPrinterParser()"}, "TestPeriodType.assertEqualsAfterSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestPeriodType.assertEqualsAfterSerialization", "method_implementation": "{\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(type);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    PeriodType result = (PeriodType) ois.readObject();\n    ois.close();\n    assertEquals(type, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2471, "method_signature": "void assertEqualsAfterSerialization(PeriodType)"}, "TestPeriodType.testDayTime": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testDayTime", "method_implementation": "{\n    PeriodType type = PeriodType.dayTime();\n    assertEquals(5, type.size());\n    assertEquals(DurationFieldType.days(), type.getFieldType(0));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(1));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(2));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(3));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(4));\n    assertEquals(\"DayTime\", type.getName());\n    assertEquals(\"PeriodType[DayTime]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.dayTime());\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.dayTime().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2479, "method_signature": "void testDayTime()"}, "TestPeriodType.testDays": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testDays", "method_implementation": "{\n    PeriodType type = PeriodType.days();\n    assertEquals(1, type.size());\n    assertEquals(DurationFieldType.days(), type.getFieldType(0));\n    assertEquals(\"Days\", type.getName());\n    assertEquals(\"PeriodType[Days]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.days());\n    assertEquals(false, type.equals(PeriodType.standard()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.days().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2484, "method_signature": "void testDays()"}, "TestPeriodType.testEquals": {"callee_method_ids": [231, 231, 231, 231], "callee_method_names": ["PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals"], "method_name": "TestPeriodType.testEquals", "method_implementation": "{\n    PeriodType type = PeriodType.dayTime().withMillisRemoved();\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.dayTime().withMillisRemoved()));\n    assertEquals(false, type.equals(null));\n    assertEquals(false, type.equals(\"\"));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2502, "method_signature": "void testEquals()"}, "TestPeriodType.testForFields1": {"callee_method_names": [], "method_name": "TestPeriodType.testForFields1", "method_implementation": "{\n    PeriodType type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.years() });\n    assertSame(PeriodType.years(), type);\n    type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.months() });\n    assertSame(PeriodType.months(), type);\n    type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.weeks() });\n    assertSame(PeriodType.weeks(), type);\n    type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.days() });\n    assertSame(PeriodType.days(), type);\n    type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.hours() });\n    assertSame(PeriodType.hours(), type);\n    type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.minutes() });\n    assertSame(PeriodType.minutes(), type);\n    type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.seconds() });\n    assertSame(PeriodType.seconds(), type);\n    type = PeriodType.forFields(new DurationFieldType[] { DurationFieldType.millis() });\n    assertSame(PeriodType.millis(), type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2489, "method_signature": "void testForFields1()"}, "TestPeriodType.testForFields7": {"callee_method_ids": [231, 232, 232], "callee_method_names": ["PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testForFields7", "method_implementation": "{\n    DurationFieldType[] types = new DurationFieldType[] { DurationFieldType.weeks(), DurationFieldType.months() };\n    DurationFieldType[] types2 = new DurationFieldType[] { DurationFieldType.seconds() };\n    PeriodType type = PeriodType.forFields(types);\n    PeriodType type2 = PeriodType.forFields(types2);\n    assertEquals(false, type == type2);\n    assertEquals(false, type.equals(type2));\n    assertEquals(false, type.hashCode() == type2.hashCode());\n}", "repo_id": "7", "comment": "// ensure hash key distribution\n", "repo_name": "joda-time-main/", "id": 2490, "method_signature": "void testForFields7()"}, "TestPeriodType.testHours": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testHours", "method_implementation": "{\n    PeriodType type = PeriodType.hours();\n    assertEquals(1, type.size());\n    assertEquals(DurationFieldType.hours(), type.getFieldType(0));\n    assertEquals(\"Hours\", type.getName());\n    assertEquals(\"PeriodType[Hours]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.hours());\n    assertEquals(false, type.equals(PeriodType.standard()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.hours().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2485, "method_signature": "void testHours()"}, "TestPeriodType.testIndexOf": {"callee_method_ids": [227, 227, 227, 227, 227, 227, 227, 227], "callee_method_names": ["PeriodType.indexOf", "PeriodType.indexOf", "PeriodType.indexOf", "PeriodType.indexOf", "PeriodType.indexOf", "PeriodType.indexOf", "PeriodType.indexOf", "PeriodType.indexOf"], "method_name": "TestPeriodType.testIndexOf", "method_implementation": "{\n    PeriodType type = PeriodType.dayTime().withMillisRemoved();\n    assertEquals(-1, type.indexOf(DurationFieldType.years()));\n    assertEquals(-1, type.indexOf(DurationFieldType.months()));\n    assertEquals(-1, type.indexOf(DurationFieldType.weeks()));\n    assertEquals(0, type.indexOf(DurationFieldType.days()));\n    assertEquals(1, type.indexOf(DurationFieldType.hours()));\n    assertEquals(2, type.indexOf(DurationFieldType.minutes()));\n    assertEquals(3, type.indexOf(DurationFieldType.seconds()));\n    assertEquals(-1, type.indexOf(DurationFieldType.millis()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2504, "method_signature": "void testIndexOf()"}, "TestPeriodType.testIsSupported": {"callee_method_names": ["PeriodType.isSupported", "PeriodType.isSupported", "PeriodType.isSupported", "PeriodType.isSupported", "PeriodType.isSupported", "PeriodType.isSupported", "PeriodType.isSupported", "PeriodType.isSupported"], "method_name": "TestPeriodType.testIsSupported", "method_implementation": "{\n    PeriodType type = PeriodType.dayTime().withMillisRemoved();\n    assertEquals(false, type.isSupported(DurationFieldType.years()));\n    assertEquals(false, type.isSupported(DurationFieldType.months()));\n    assertEquals(false, type.isSupported(DurationFieldType.weeks()));\n    assertEquals(true, type.isSupported(DurationFieldType.days()));\n    assertEquals(true, type.isSupported(DurationFieldType.hours()));\n    assertEquals(true, type.isSupported(DurationFieldType.minutes()));\n    assertEquals(true, type.isSupported(DurationFieldType.seconds()));\n    assertEquals(false, type.isSupported(DurationFieldType.millis()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2503, "method_signature": "void testIsSupported()"}, "TestPeriodType.testMaskDays": {"callee_method_ids": [231, 231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.getName", "PeriodType.toString"], "method_name": "TestPeriodType.testMaskDays", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withDaysRemoved();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.standard().withDaysRemoved()));\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().withDaysRemoved().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(\"StandardNoDays\", type.getName());\n    assertEquals(\"PeriodType[StandardNoDays]\", type.toString());\n    assertEqualsAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2494, "method_signature": "void testMaskDays()"}, "TestPeriodType.testMaskHours": {"callee_method_ids": [231, 231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.getName", "PeriodType.toString"], "method_name": "TestPeriodType.testMaskHours", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withHoursRemoved();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n    assertEquals(DurationFieldType.days(), type.getFieldType(3));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved()));\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(\"StandardNoHours\", type.getName());\n    assertEquals(\"PeriodType[StandardNoHours]\", type.toString());\n    assertEqualsAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2495, "method_signature": "void testMaskHours()"}, "TestPeriodType.testMaskHoursMinutesSeconds": {"callee_method_ids": [231, 231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.getName", "PeriodType.toString"], "method_name": "TestPeriodType.testMaskHoursMinutesSeconds", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved();\n    assertEquals(5, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n    assertEquals(DurationFieldType.days(), type.getFieldType(3));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(4));\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved()));\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().withHoursRemoved().withMinutesRemoved().withSecondsRemoved().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(\"StandardNoHoursNoMinutesNoSeconds\", type.getName());\n    assertEquals(\"PeriodType[StandardNoHoursNoMinutesNoSeconds]\", type.toString());\n    assertEqualsAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2499, "method_signature": "void testMaskHoursMinutesSeconds()"}, "TestPeriodType.testMaskMillis": {"callee_method_ids": [231, 231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.getName", "PeriodType.toString"], "method_name": "TestPeriodType.testMaskMillis", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withMillisRemoved();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n    assertEquals(DurationFieldType.days(), type.getFieldType(3));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(4));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(5));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(6));\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.standard().withMillisRemoved()));\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().withMillisRemoved().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(\"StandardNoMillis\", type.getName());\n    assertEquals(\"PeriodType[StandardNoMillis]\", type.toString());\n    assertEqualsAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2498, "method_signature": "void testMaskMillis()"}, "TestPeriodType.testMaskMinutes": {"callee_method_ids": [231, 231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.getName", "PeriodType.toString"], "method_name": "TestPeriodType.testMaskMinutes", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withMinutesRemoved();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n    assertEquals(DurationFieldType.days(), type.getFieldType(3));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(4));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.standard().withMinutesRemoved()));\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().withMinutesRemoved().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(\"StandardNoMinutes\", type.getName());\n    assertEquals(\"PeriodType[StandardNoMinutes]\", type.toString());\n    assertEqualsAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2496, "method_signature": "void testMaskMinutes()"}, "TestPeriodType.testMaskMonths": {"callee_method_ids": [231, 231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.getName", "PeriodType.toString"], "method_name": "TestPeriodType.testMaskMonths", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withMonthsRemoved();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(1));\n    assertEquals(DurationFieldType.days(), type.getFieldType(2));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.standard().withMonthsRemoved()));\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().withMonthsRemoved().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(\"StandardNoMonths\", type.getName());\n    assertEquals(\"PeriodType[StandardNoMonths]\", type.toString());\n    assertEqualsAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2492, "method_signature": "void testMaskMonths()"}, "TestPeriodType.testMaskSeconds": {"callee_method_ids": [231, 231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.getName", "PeriodType.toString"], "method_name": "TestPeriodType.testMaskSeconds", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withSecondsRemoved();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n    assertEquals(DurationFieldType.days(), type.getFieldType(3));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(4));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(5));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.standard().withSecondsRemoved()));\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().withSecondsRemoved().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(\"StandardNoSeconds\", type.getName());\n    assertEquals(\"PeriodType[StandardNoSeconds]\", type.toString());\n    assertEqualsAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2497, "method_signature": "void testMaskSeconds()"}, "TestPeriodType.testMaskTwice1": {"callee_method_names": ["PeriodType.withYearsRemoved", "PeriodType.withMonthsRemoved", "PeriodType.withWeeksRemoved", "PeriodType.withDaysRemoved", "PeriodType.withHoursRemoved", "PeriodType.withMinutesRemoved", "PeriodType.withSecondsRemoved", "PeriodType.withMillisRemoved"], "method_name": "TestPeriodType.testMaskTwice1", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withYearsRemoved();\n    PeriodType type2 = type.withYearsRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.standard().withMonthsRemoved();\n    type2 = type.withMonthsRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.standard().withWeeksRemoved();\n    type2 = type.withWeeksRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.standard().withDaysRemoved();\n    type2 = type.withDaysRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.standard().withHoursRemoved();\n    type2 = type.withHoursRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.standard().withMinutesRemoved();\n    type2 = type.withMinutesRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.standard().withSecondsRemoved();\n    type2 = type.withSecondsRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.standard().withMillisRemoved();\n    type2 = type.withMillisRemoved();\n    assertEquals(true, type == type2);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2500, "method_signature": "void testMaskTwice1()"}, "TestPeriodType.testMaskTwice2": {"callee_method_names": ["PeriodType.withYearsRemoved", "PeriodType.withMonthsRemoved", "PeriodType.withWeeksRemoved", "PeriodType.withDaysRemoved", "PeriodType.withHoursRemoved", "PeriodType.withMinutesRemoved", "PeriodType.withSecondsRemoved"], "method_name": "TestPeriodType.testMaskTwice2", "method_implementation": "{\n    PeriodType type = PeriodType.dayTime();\n    PeriodType type2 = type.withYearsRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.dayTime();\n    type2 = type.withMonthsRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.dayTime();\n    type2 = type.withWeeksRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.millis();\n    type2 = type.withDaysRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.millis();\n    type2 = type.withHoursRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.millis();\n    type2 = type.withMinutesRemoved();\n    assertEquals(true, type == type2);\n    type = PeriodType.millis();\n    type2 = type.withSecondsRemoved();\n    assertEquals(true, type == type2);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2501, "method_signature": "void testMaskTwice2()"}, "TestPeriodType.testMaskWeeks": {"callee_method_ids": [231, 231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.getName", "PeriodType.toString"], "method_name": "TestPeriodType.testMaskWeeks", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withWeeksRemoved();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.days(), type.getFieldType(2));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.standard().withWeeksRemoved()));\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().withWeeksRemoved().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(\"StandardNoWeeks\", type.getName());\n    assertEquals(\"PeriodType[StandardNoWeeks]\", type.toString());\n    assertEqualsAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2493, "method_signature": "void testMaskWeeks()"}, "TestPeriodType.testMaskYears": {"callee_method_ids": [231, 231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.equals", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.getName", "PeriodType.toString"], "method_name": "TestPeriodType.testMaskYears", "method_implementation": "{\n    PeriodType type = PeriodType.standard().withYearsRemoved();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.months(), type.getFieldType(0));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(1));\n    assertEquals(DurationFieldType.days(), type.getFieldType(2));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type.equals(PeriodType.standard().withYearsRemoved()));\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().withYearsRemoved().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(\"StandardNoYears\", type.getName());\n    assertEquals(\"PeriodType[StandardNoYears]\", type.toString());\n    assertEqualsAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2491, "method_signature": "void testMaskYears()"}, "TestPeriodType.testMillis": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testMillis", "method_implementation": "{\n    PeriodType type = PeriodType.millis();\n    assertEquals(1, type.size());\n    assertEquals(DurationFieldType.millis(), type.getFieldType(0));\n    assertEquals(\"Millis\", type.getName());\n    assertEquals(\"PeriodType[Millis]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.millis());\n    assertEquals(false, type.equals(PeriodType.standard()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.millis().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2488, "method_signature": "void testMillis()"}, "TestPeriodType.testMinutes": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testMinutes", "method_implementation": "{\n    PeriodType type = PeriodType.minutes();\n    assertEquals(1, type.size());\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(0));\n    assertEquals(\"Minutes\", type.getName());\n    assertEquals(\"PeriodType[Minutes]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.minutes());\n    assertEquals(false, type.equals(PeriodType.standard()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.minutes().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2486, "method_signature": "void testMinutes()"}, "TestPeriodType.testMonths": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testMonths", "method_implementation": "{\n    PeriodType type = PeriodType.months();\n    assertEquals(1, type.size());\n    assertEquals(DurationFieldType.months(), type.getFieldType(0));\n    assertEquals(\"Months\", type.getName());\n    assertEquals(\"PeriodType[Months]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.months());\n    assertEquals(false, type.equals(PeriodType.standard()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.months().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2482, "method_signature": "void testMonths()"}, "TestPeriodType.testSeconds": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testSeconds", "method_implementation": "{\n    PeriodType type = PeriodType.seconds();\n    assertEquals(1, type.size());\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(0));\n    assertEquals(\"Seconds\", type.getName());\n    assertEquals(\"PeriodType[Seconds]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.seconds());\n    assertEquals(false, type.equals(PeriodType.standard()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.seconds().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2487, "method_signature": "void testSeconds()"}, "TestPeriodType.testStandard": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testStandard", "method_implementation": "{\n    PeriodType type = PeriodType.standard();\n    assertEquals(8, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(2));\n    assertEquals(DurationFieldType.days(), type.getFieldType(3));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(4));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(5));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(6));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(7));\n    assertEquals(\"Standard\", type.getName());\n    assertEquals(\"PeriodType[Standard]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.standard());\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.standard().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2472, "method_signature": "void testStandard()"}, "TestPeriodType.testTest": {"callee_method_names": [], "method_name": "TestPeriodType.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2470, "method_signature": "void testTest()"}, "TestPeriodType.testTime": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testTime", "method_implementation": "{\n    PeriodType type = PeriodType.time();\n    assertEquals(4, type.size());\n    assertEquals(DurationFieldType.hours(), type.getFieldType(0));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(1));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(2));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(3));\n    assertEquals(\"Time\", type.getName());\n    assertEquals(\"PeriodType[Time]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.time());\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.time().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2480, "method_signature": "void testTime()"}, "TestPeriodType.testWeeks": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testWeeks", "method_implementation": "{\n    PeriodType type = PeriodType.weeks();\n    assertEquals(1, type.size());\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(0));\n    assertEquals(\"Weeks\", type.getName());\n    assertEquals(\"PeriodType[Weeks]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.weeks());\n    assertEquals(false, type.equals(PeriodType.standard()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.weeks().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2483, "method_signature": "void testWeeks()"}, "TestPeriodType.testYearDay": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testYearDay", "method_implementation": "{\n    PeriodType type = PeriodType.yearDay();\n    assertEquals(2, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.days(), type.getFieldType(1));\n    assertEquals(\"YearDay\", type.getName());\n    assertEquals(\"PeriodType[YearDay]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.yearDay());\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.yearDay().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2478, "method_signature": "void testYearDay()"}, "TestPeriodType.testYearDayTime": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testYearDayTime", "method_implementation": "{\n    PeriodType type = PeriodType.yearDayTime();\n    assertEquals(6, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.days(), type.getFieldType(1));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(2));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(3));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(4));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(5));\n    assertEquals(\"YearDayTime\", type.getName());\n    assertEquals(\"PeriodType[YearDayTime]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.yearDayTime());\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.yearDayTime().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2477, "method_signature": "void testYearDayTime()"}, "TestPeriodType.testYearMonthDay": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testYearMonthDay", "method_implementation": "{\n    PeriodType type = PeriodType.yearMonthDay();\n    assertEquals(3, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.days(), type.getFieldType(2));\n    assertEquals(\"YearMonthDay\", type.getName());\n    assertEquals(\"PeriodType[YearMonthDay]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.yearMonthDay());\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.yearMonthDay().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2474, "method_signature": "void testYearMonthDay()"}, "TestPeriodType.testYearMonthDayTime": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testYearMonthDayTime", "method_implementation": "{\n    PeriodType type = PeriodType.yearMonthDayTime();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.months(), type.getFieldType(1));\n    assertEquals(DurationFieldType.days(), type.getFieldType(2));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n    assertEquals(\"YearMonthDayTime\", type.getName());\n    assertEquals(\"PeriodType[YearMonthDayTime]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.yearMonthDayTime());\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.yearMonthDayTime().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2473, "method_signature": "void testYearMonthDayTime()"}, "TestPeriodType.testYearWeekDay": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testYearWeekDay", "method_implementation": "{\n    PeriodType type = PeriodType.yearWeekDay();\n    assertEquals(3, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(1));\n    assertEquals(DurationFieldType.days(), type.getFieldType(2));\n    assertEquals(\"YearWeekDay\", type.getName());\n    assertEquals(\"PeriodType[YearWeekDay]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.yearWeekDay());\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.yearWeekDay().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2476, "method_signature": "void testYearWeekDay()"}, "TestPeriodType.testYearWeekDayTime": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testYearWeekDayTime", "method_implementation": "{\n    PeriodType type = PeriodType.yearWeekDayTime();\n    assertEquals(7, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(DurationFieldType.weeks(), type.getFieldType(1));\n    assertEquals(DurationFieldType.days(), type.getFieldType(2));\n    assertEquals(DurationFieldType.hours(), type.getFieldType(3));\n    assertEquals(DurationFieldType.minutes(), type.getFieldType(4));\n    assertEquals(DurationFieldType.seconds(), type.getFieldType(5));\n    assertEquals(DurationFieldType.millis(), type.getFieldType(6));\n    assertEquals(\"YearWeekDayTime\", type.getName());\n    assertEquals(\"PeriodType[YearWeekDayTime]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.yearWeekDayTime());\n    assertEquals(false, type.equals(PeriodType.millis()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.yearWeekDayTime().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.millis().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2475, "method_signature": "void testYearWeekDayTime()"}, "TestPeriodType.testYears": {"callee_method_ids": [231, 231, 232, 232, 232, 232], "callee_method_names": ["PeriodType.size", "PeriodType.getFieldType", "PeriodType.getName", "PeriodType.toString", "PeriodType.equals", "PeriodType.equals", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode", "PeriodType.hashCode"], "method_name": "TestPeriodType.testYears", "method_implementation": "{\n    PeriodType type = PeriodType.years();\n    assertEquals(1, type.size());\n    assertEquals(DurationFieldType.years(), type.getFieldType(0));\n    assertEquals(\"Years\", type.getName());\n    assertEquals(\"PeriodType[Years]\", type.toString());\n    assertEquals(true, type.equals(type));\n    assertEquals(true, type == PeriodType.years());\n    assertEquals(false, type.equals(PeriodType.standard()));\n    assertEquals(true, type.hashCode() == type.hashCode());\n    assertEquals(true, type.hashCode() == PeriodType.years().hashCode());\n    assertEquals(false, type.hashCode() == PeriodType.standard().hashCode());\n    assertSameAfterSerialization(type);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2481, "method_signature": "void testYears()"}, "TestPeriod_Basics.testMinus": {"callee_method_ids": [1013, 1013, 1013, 1013, 1013, 1013, 1013], "callee_method_names": ["Period.minus", "Period.minus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.minus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.minus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.minus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.minus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.minus"], "method_name": "TestPeriod_Basics.testMinus", "method_implementation": "{\n    Period base = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    Period baseDaysOnly = new Period(0, 0, 0, 10, 0, 0, 0, 0, PeriodType.days());\n    Period test = base.minus((ReadablePeriod) null);\n    assertSame(base, test);\n    test = base.minus(Period.years(10));\n    assertEquals(-9, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(4, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n    test = base.minus(Years.years(10));\n    assertEquals(-9, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(4, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n    test = base.minus(Period.days(10));\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(-6, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n    test = baseDaysOnly.minus(Period.years(0));\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(10, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n    test = baseDaysOnly.minus(baseDaysOnly);\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n    try {\n        baseDaysOnly.minus(Period.years(1));\n        fail();\n    } catch (UnsupportedOperationException ex) {\n    }\n    try {\n        Period.days(Integer.MAX_VALUE).minus(Period.days(-1));\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n    try {\n        Period.days(Integer.MIN_VALUE).minus(Period.days(1));\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1324, "method_signature": "void testMinus()"}, "TestPeriod_Basics.testMultipliedBy": {"callee_method_ids": [1014, 1014, 1014, 1014, 1014], "callee_method_names": ["Period.multipliedBy", "Period.multipliedBy", "Period.multipliedBy", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.multipliedBy", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.multipliedBy", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Basics.testMultipliedBy", "method_implementation": "{\n    Period base = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    Period test = base.multipliedBy(1);\n    assertSame(base, test);\n    test = base.multipliedBy(0);\n    assertEquals(Period.ZERO, test);\n    test = base.multipliedBy(2);\n    assertEquals(2, test.getYears());\n    assertEquals(4, test.getMonths());\n    assertEquals(6, test.getWeeks());\n    assertEquals(8, test.getDays());\n    assertEquals(10, test.getHours());\n    assertEquals(12, test.getMinutes());\n    assertEquals(14, test.getSeconds());\n    assertEquals(16, test.getMillis());\n    test = base.multipliedBy(3);\n    assertEquals(3, test.getYears());\n    assertEquals(6, test.getMonths());\n    assertEquals(9, test.getWeeks());\n    assertEquals(12, test.getDays());\n    assertEquals(15, test.getHours());\n    assertEquals(18, test.getMinutes());\n    assertEquals(21, test.getSeconds());\n    assertEquals(24, test.getMillis());\n    test = base.multipliedBy(-4);\n    assertEquals(-4, test.getYears());\n    assertEquals(-8, test.getMonths());\n    assertEquals(-12, test.getWeeks());\n    assertEquals(-16, test.getDays());\n    assertEquals(-20, test.getHours());\n    assertEquals(-24, test.getMinutes());\n    assertEquals(-28, test.getSeconds());\n    assertEquals(-32, test.getMillis());\n    try {\n        Period.days(Integer.MAX_VALUE).multipliedBy(2);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n    try {\n        Period.days(Integer.MIN_VALUE).multipliedBy(2);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1326, "method_signature": "void testMultipliedBy()"}, "TestPeriod_Basics.testNegated": {"callee_method_names": ["Period.negated", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.getDays"], "method_name": "TestPeriod_Basics.testNegated", "method_implementation": "{\n    Period base = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    Period test = Period.ZERO.negated();\n    assertEquals(Period.ZERO, test);\n    test = base.negated();\n    assertEquals(-1, test.getYears());\n    assertEquals(-2, test.getMonths());\n    assertEquals(-3, test.getWeeks());\n    assertEquals(-4, test.getDays());\n    assertEquals(-5, test.getHours());\n    assertEquals(-6, test.getMinutes());\n    assertEquals(-7, test.getSeconds());\n    assertEquals(-8, test.getMillis());\n    test = Period.days(Integer.MAX_VALUE).negated();\n    assertEquals(-Integer.MAX_VALUE, test.getDays());\n    try {\n        Period.days(Integer.MIN_VALUE).negated();\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1327, "method_signature": "void testNegated()"}, "TestPeriod_Basics.testNormalizedStandard_periodType_yearMonth1": {"callee_method_ids": [1022], "callee_method_names": ["Period.normalizedStandard"], "method_name": "TestPeriod_Basics.testNormalizedStandard_periodType_yearMonth1", "method_implementation": "{\n    Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);\n    Period result = test.normalizedStandard((PeriodType) null);\n    assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test);\n    assertEquals(new Period(2, 3, 0, 0, 0, 0, 0, 0), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1335, "method_signature": "void testNormalizedStandard_periodType_yearMonth1()"}, "TestPeriod_Basics.testNormalizedStandard_yearMonth1": {"callee_method_ids": [1022], "callee_method_names": ["Period.normalizedStandard"], "method_name": "TestPeriod_Basics.testNormalizedStandard_yearMonth1", "method_implementation": "{\n    Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);\n    Period result = test.normalizedStandard();\n    assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test);\n    assertEquals(new Period(2, 3, 0, 0, 0, 0, 0, 0), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1334, "method_signature": "void testNormalizedStandard_yearMonth1()"}, "TestPeriod_Basics.testPeriodStatics": {"callee_method_names": [], "method_name": "TestPeriod_Basics.testPeriodStatics", "method_implementation": "{\n    Period test;\n    test = Period.years(1);\n    assertEquals(test, new Period(1, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()));\n    test = Period.months(1);\n    assertEquals(test, new Period(0, 1, 0, 0, 0, 0, 0, 0, PeriodType.standard()));\n    test = Period.weeks(1);\n    assertEquals(test, new Period(0, 0, 1, 0, 0, 0, 0, 0, PeriodType.standard()));\n    test = Period.days(1);\n    assertEquals(test, new Period(0, 0, 0, 1, 0, 0, 0, 0, PeriodType.standard()));\n    test = Period.hours(1);\n    assertEquals(test, new Period(0, 0, 0, 0, 1, 0, 0, 0, PeriodType.standard()));\n    test = Period.minutes(1);\n    assertEquals(test, new Period(0, 0, 0, 0, 0, 1, 0, 0, PeriodType.standard()));\n    test = Period.seconds(1);\n    assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 1, 0, PeriodType.standard()));\n    test = Period.millis(1);\n    assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.standard()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1321, "method_signature": "void testPeriodStatics()"}, "TestPeriod_Basics.testPlus": {"callee_method_ids": [1004, 1004, 1004, 1004, 1004, 1004, 1004], "callee_method_names": ["Period.plus", "Period.plus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.plus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.plus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.plus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.plus", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis", "Period.plus"], "method_name": "TestPeriod_Basics.testPlus", "method_implementation": "{\n    Period base = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    Period baseDaysOnly = new Period(0, 0, 0, 10, 0, 0, 0, 0, PeriodType.days());\n    Period test = base.plus((ReadablePeriod) null);\n    assertSame(base, test);\n    test = base.plus(Period.years(10));\n    assertEquals(11, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(4, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n    test = base.plus(Years.years(10));\n    assertEquals(11, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(4, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n    test = base.plus(Period.days(10));\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(14, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n    test = baseDaysOnly.plus(Period.years(0));\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(10, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n    test = baseDaysOnly.plus(baseDaysOnly);\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(20, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n    try {\n        baseDaysOnly.plus(Period.years(1));\n        fail();\n    } catch (UnsupportedOperationException ex) {\n    }\n    try {\n        Period.days(Integer.MAX_VALUE).plus(Period.days(1));\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n    try {\n        Period.days(Integer.MIN_VALUE).plus(Period.days(-1));\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1323, "method_signature": "void testPlus()"}, "TestPeriod_Basics.testPlusFields": {"callee_method_ids": [1005], "callee_method_names": ["Period.plusYears"], "method_name": "TestPeriod_Basics.testPlusFields", "method_implementation": "{\n    Period test;\n    test = Period.years(1).plusYears(1);\n    assertEquals(new Period(2, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);\n    test = Period.months(1).plusMonths(1);\n    assertEquals(new Period(0, 2, 0, 0, 0, 0, 0, 0, PeriodType.standard()), test);\n    test = Period.weeks(1).plusWeeks(1);\n    assertEquals(new Period(0, 0, 2, 0, 0, 0, 0, 0, PeriodType.standard()), test);\n    test = Period.days(1).plusDays(1);\n    assertEquals(new Period(0, 0, 0, 2, 0, 0, 0, 0, PeriodType.standard()), test);\n    test = Period.hours(1).plusHours(1);\n    assertEquals(new Period(0, 0, 0, 0, 2, 0, 0, 0, PeriodType.standard()), test);\n    test = Period.minutes(1).plusMinutes(1);\n    assertEquals(new Period(0, 0, 0, 0, 0, 2, 0, 0, PeriodType.standard()), test);\n    test = Period.seconds(1).plusSeconds(1);\n    assertEquals(new Period(0, 0, 0, 0, 0, 0, 2, 0, PeriodType.standard()), test);\n    test = Period.millis(1).plusMillis(1);\n    assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 2, PeriodType.standard()), test);\n    test = new Period(0L, PeriodType.millis());\n    try {\n        test.plusYears(1);\n        fail();\n    } catch (UnsupportedOperationException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1325, "method_signature": "void testPlusFields()"}, "TestPeriod_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestPeriod_Basics.testSerialization", "method_implementation": "{\n    Period test = new Period(123L);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Period result = (Period) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1313, "method_signature": "void testSerialization()"}, "TestPeriod_Basics.testTest": {"callee_method_names": [], "method_name": "TestPeriod_Basics.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1312, "method_signature": "void testTest()"}, "TestPeriod_Basics.testToPeriod": {"callee_method_names": ["Period.toPeriod"], "method_name": "TestPeriod_Basics.testToPeriod", "method_implementation": "{\n    Period test = new Period(123L);\n    Period result = test.toPeriod();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1316, "method_signature": "void testToPeriod()"}, "TestPeriod_Basics.testToStandardDays": {"callee_method_ids": [1016, 1016, 1016, 1016, 1016, 1016], "callee_method_names": ["Period.toStandardDays", "Period.toStandardDays", "Period.toStandardDays", "Period.toStandardDays", "BigInteger.add", "BigInteger.add", "BigInteger.add", "BigInteger.divide", "BigInteger.compareTo", "BigInteger.longValue", "Period.toStandardDays", "Period.toStandardDays"], "method_name": "TestPeriod_Basics.testToStandardDays", "method_implementation": "{\n    Period test = new Period(0, 0, 0, 4, 5, 6, 7, 8);\n    assertEquals(4, test.toStandardDays().getDays());\n    test = new Period(0, 0, 1, 4, 0, 0, 0, 0);\n    assertEquals(11, test.toStandardDays().getDays());\n    test = new Period(0, 0, 0, 0, 23, 59, 59, 1000);\n    assertEquals(1, test.toStandardDays().getDays());\n    test = new Period(0, 0, 0, Integer.MAX_VALUE, 0, 0, 0, 0);\n    assertEquals(Integer.MAX_VALUE, test.toStandardDays().getDays());\n    test = new Period(0, 0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n    long intMax = Integer.MAX_VALUE;\n    BigInteger expected = BigInteger.valueOf(intMax);\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND));\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_MINUTE));\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_HOUR));\n    expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_DAY));\n    assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n    assertEquals(expected.longValue(), test.toStandardDays().getDays());\n    test = new Period(0, 0, 0, Integer.MAX_VALUE, 24, 0, 0, 0);\n    try {\n        test.toStandardDays();\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1329, "method_signature": "void testToStandardDays()"}, "TestPeriod_Basics.testToStandardDuration": {"callee_method_ids": [1020, 1020, 1020, 1020], "callee_method_names": ["Period.toStandardDuration", "Period.toStandardDuration", "Period.toStandardDuration", "Period.toStandardDuration", "BigInteger.add", "BigInteger.multiply", "BigInteger.add", "BigInteger.multiply", "BigInteger.add", "BigInteger.multiply", "BigInteger.add", "BigInteger.multiply", "BigInteger.add", "BigInteger.multiply", "BigInteger.compareTo"], "method_name": "TestPeriod_Basics.testToStandardDuration", "method_implementation": "{\n    Period test = new Period(0, 0, 0, 0, 0, 0, 0, 8);\n    assertEquals(8, test.toStandardDuration().getMillis());\n    test = new Period(0, 0, 0, 0, 0, 0, 1, 20);\n    assertEquals(1020, test.toStandardDuration().getMillis());\n    test = new Period(0, 0, 0, 0, 0, 0, 0, Integer.MAX_VALUE);\n    assertEquals(Integer.MAX_VALUE, test.toStandardDuration().getMillis());\n    test = new Period(0, 0, 0, 0, 0, 10, 20, Integer.MAX_VALUE);\n    long expected = Integer.MAX_VALUE;\n    expected += 10L * ((long) DateTimeConstants.MILLIS_PER_MINUTE);\n    expected += 20L * ((long) DateTimeConstants.MILLIS_PER_SECOND);\n    assertEquals(expected, test.toStandardDuration().getMillis());\n    // proof that overflow does not occur\n    BigInteger intMax = BigInteger.valueOf(Integer.MAX_VALUE);\n    BigInteger exp = intMax;\n    exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_SECOND)));\n    exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_MINUTE)));\n    exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_HOUR)));\n    exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_DAY)));\n    exp = exp.add(intMax.multiply(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_WEEK)));\n    assertTrue(exp.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n    //        test = new Period(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n    //        try {\n    //            test.toStandardDuration();\n    //            fail();\n    //        } catch (ArithmeticException ex) {}\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1333, "method_signature": "void testToStandardDuration()"}, "TestPeriod_Basics.testToStandardHours": {"callee_method_ids": [1017, 1017, 1017, 1017, 1017, 1017], "callee_method_names": ["Period.toStandardHours", "Period.toStandardHours", "Period.toStandardHours", "Period.toStandardHours", "BigInteger.add", "BigInteger.add", "BigInteger.divide", "BigInteger.compareTo", "BigInteger.longValue", "Period.toStandardHours", "Period.toStandardHours"], "method_name": "TestPeriod_Basics.testToStandardHours", "method_implementation": "{\n    Period test = new Period(0, 0, 0, 0, 5, 6, 7, 8);\n    assertEquals(5, test.toStandardHours().getHours());\n    test = new Period(0, 0, 0, 1, 5, 0, 0, 0);\n    assertEquals(29, test.toStandardHours().getHours());\n    test = new Period(0, 0, 0, 0, 0, 59, 59, 1000);\n    assertEquals(1, test.toStandardHours().getHours());\n    test = new Period(0, 0, 0, 0, Integer.MAX_VALUE, 0, 0, 0);\n    assertEquals(Integer.MAX_VALUE, test.toStandardHours().getHours());\n    test = new Period(0, 0, 0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n    long intMax = Integer.MAX_VALUE;\n    BigInteger expected = BigInteger.valueOf(intMax);\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND));\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_MINUTE));\n    expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_HOUR));\n    assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n    assertEquals(expected.longValue(), test.toStandardHours().getHours());\n    test = new Period(0, 0, 0, 0, Integer.MAX_VALUE, 60, 0, 0);\n    try {\n        test.toStandardHours();\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1330, "method_signature": "void testToStandardHours()"}, "TestPeriod_Basics.testToStandardMinutes": {"callee_method_ids": [1018, 1018, 1018, 1018, 1018, 1018], "callee_method_names": ["Period.toStandardMinutes", "Period.toStandardMinutes", "Period.toStandardMinutes", "Period.toStandardMinutes", "BigInteger.add", "BigInteger.divide", "BigInteger.compareTo", "BigInteger.longValue", "Period.toStandardMinutes", "Period.toStandardMinutes"], "method_name": "TestPeriod_Basics.testToStandardMinutes", "method_implementation": "{\n    Period test = new Period(0, 0, 0, 0, 0, 6, 7, 8);\n    assertEquals(6, test.toStandardMinutes().getMinutes());\n    test = new Period(0, 0, 0, 0, 1, 6, 0, 0);\n    assertEquals(66, test.toStandardMinutes().getMinutes());\n    test = new Period(0, 0, 0, 0, 0, 0, 59, 1000);\n    assertEquals(1, test.toStandardMinutes().getMinutes());\n    test = new Period(0, 0, 0, 0, 0, Integer.MAX_VALUE, 0, 0);\n    assertEquals(Integer.MAX_VALUE, test.toStandardMinutes().getMinutes());\n    test = new Period(0, 0, 0, 0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE);\n    long intMax = Integer.MAX_VALUE;\n    BigInteger expected = BigInteger.valueOf(intMax);\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND));\n    expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_MINUTE));\n    assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n    assertEquals(expected.longValue(), test.toStandardMinutes().getMinutes());\n    test = new Period(0, 0, 0, 0, 0, Integer.MAX_VALUE, 60, 0);\n    try {\n        test.toStandardMinutes();\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1331, "method_signature": "void testToStandardMinutes()"}, "TestPeriod_Basics.testToStandardSeconds": {"callee_method_ids": [1019, 1019, 1019, 1019, 1019, 1019], "callee_method_names": ["Period.toStandardSeconds", "Period.toStandardSeconds", "Period.toStandardSeconds", "Period.toStandardSeconds", "Period.toStandardSeconds", "Period.toStandardSeconds"], "method_name": "TestPeriod_Basics.testToStandardSeconds", "method_implementation": "{\n    Period test = new Period(0, 0, 0, 0, 0, 0, 7, 8);\n    assertEquals(7, test.toStandardSeconds().getSeconds());\n    test = new Period(0, 0, 0, 0, 0, 1, 3, 0);\n    assertEquals(63, test.toStandardSeconds().getSeconds());\n    test = new Period(0, 0, 0, 0, 0, 0, 0, 1000);\n    assertEquals(1, test.toStandardSeconds().getSeconds());\n    test = new Period(0, 0, 0, 0, 0, 0, Integer.MAX_VALUE, 0);\n    assertEquals(Integer.MAX_VALUE, test.toStandardSeconds().getSeconds());\n    test = new Period(0, 0, 0, 0, 0, 0, 20, Integer.MAX_VALUE);\n    long expected = 20;\n    expected += ((long) Integer.MAX_VALUE) / DateTimeConstants.MILLIS_PER_SECOND;\n    assertEquals(expected, test.toStandardSeconds().getSeconds());\n    test = new Period(0, 0, 0, 0, 0, 0, Integer.MAX_VALUE, 1000);\n    try {\n        test.toStandardSeconds();\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1332, "method_signature": "void testToStandardSeconds()"}, "TestPeriod_Basics.testToStandardWeeks": {"callee_method_ids": [1015, 1015, 1015, 1015, 1015, 1015], "callee_method_names": ["Period.toStandardWeeks", "Period.toStandardWeeks", "Period.toStandardWeeks", "Period.toStandardWeeks", "BigInteger.add", "BigInteger.add", "BigInteger.add", "BigInteger.add", "BigInteger.divide", "BigInteger.compareTo", "BigInteger.longValue", "Period.toStandardWeeks", "Period.toStandardWeeks"], "method_name": "TestPeriod_Basics.testToStandardWeeks", "method_implementation": "{\n    Period test = new Period(0, 0, 3, 4, 5, 6, 7, 8);\n    assertEquals(3, test.toStandardWeeks().getWeeks());\n    test = new Period(0, 0, 3, 7, 0, 0, 0, 0);\n    assertEquals(4, test.toStandardWeeks().getWeeks());\n    test = new Period(0, 0, 0, 6, 23, 59, 59, 1000);\n    assertEquals(1, test.toStandardWeeks().getWeeks());\n    test = new Period(0, 0, Integer.MAX_VALUE, 0, 0, 0, 0, 0);\n    assertEquals(Integer.MAX_VALUE, test.toStandardWeeks().getWeeks());\n    test = new Period(0, 0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n    long intMax = Integer.MAX_VALUE;\n    BigInteger expected = BigInteger.valueOf(intMax);\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_SECOND));\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_MINUTE));\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_HOUR));\n    expected = expected.add(BigInteger.valueOf(intMax * DateTimeConstants.MILLIS_PER_DAY));\n    expected = expected.divide(BigInteger.valueOf(DateTimeConstants.MILLIS_PER_WEEK));\n    assertTrue(expected.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) < 0);\n    assertEquals(expected.longValue(), test.toStandardWeeks().getWeeks());\n    test = new Period(0, 0, Integer.MAX_VALUE, 7, 0, 0, 0, 0);\n    try {\n        test.toStandardWeeks();\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1328, "method_signature": "void testToStandardWeeks()"}, "TestPeriod_Basics.testToString": {"callee_method_names": ["Period.toString", "Period.toString", "Period.toString"], "method_name": "TestPeriod_Basics.testToString", "method_implementation": "{\n    Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(\"P1Y2M3W4DT5H6M7.008S\", test.toString());\n    test = new Period(0, 0, 0, 0, 0, 0, 0, 0);\n    assertEquals(\"PT0S\", test.toString());\n    test = new Period(12345L);\n    assertEquals(\"PT12.345S\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1314, "method_signature": "void testToString()"}, "TestPeriod_Basics.testToString_PeriodFormatter": {"callee_method_names": ["Period.toString", "Period.toString"], "method_name": "TestPeriod_Basics.testToString_PeriodFormatter", "method_implementation": "{\n    Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(\"1 year, 2 months, 3 weeks, 4 days, 5 hours, 6 minutes, 7 seconds and 8 milliseconds\", test.toString(PeriodFormat.getDefault()));\n    test = new Period(0, 0, 0, 0, 0, 0, 0, 0);\n    assertEquals(\"0 milliseconds\", test.toString(PeriodFormat.getDefault()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1315, "method_signature": "void testToString_PeriodFormatter()"}, "TestPeriod_Basics.testWith": {"callee_method_ids": [996], "callee_method_names": ["Period.withYears"], "method_name": "TestPeriod_Basics.testWith", "method_implementation": "{\n    Period test;\n    test = Period.years(5).withYears(1);\n    assertEquals(test, new Period(1, 0, 0, 0, 0, 0, 0, 0, PeriodType.standard()));\n    test = Period.months(5).withMonths(1);\n    assertEquals(test, new Period(0, 1, 0, 0, 0, 0, 0, 0, PeriodType.standard()));\n    test = Period.weeks(5).withWeeks(1);\n    assertEquals(test, new Period(0, 0, 1, 0, 0, 0, 0, 0, PeriodType.standard()));\n    test = Period.days(5).withDays(1);\n    assertEquals(test, new Period(0, 0, 0, 1, 0, 0, 0, 0, PeriodType.standard()));\n    test = Period.hours(5).withHours(1);\n    assertEquals(test, new Period(0, 0, 0, 0, 1, 0, 0, 0, PeriodType.standard()));\n    test = Period.minutes(5).withMinutes(1);\n    assertEquals(test, new Period(0, 0, 0, 0, 0, 1, 0, 0, PeriodType.standard()));\n    test = Period.seconds(5).withSeconds(1);\n    assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 1, 0, PeriodType.standard()));\n    test = Period.millis(5).withMillis(1);\n    assertEquals(test, new Period(0, 0, 0, 0, 0, 0, 0, 1, PeriodType.standard()));\n    test = new Period(0L, PeriodType.millis());\n    try {\n        test.withYears(1);\n        fail();\n    } catch (UnsupportedOperationException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1322, "method_signature": "void testWith()"}, "TestPeriod_Basics.testWithField1": {"callee_method_ids": [994], "callee_method_names": ["Period.withField"], "method_name": "TestPeriod_Basics.testWithField1", "method_implementation": "{\n    Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    Period result = test.withField(DurationFieldType.years(), 6);\n    assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test);\n    assertEquals(new Period(6, 2, 3, 4, 5, 6, 7, 8), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1319, "method_signature": "void testWithField1()"}, "TestPeriod_Basics.testWithFieldAdded1": {"callee_method_ids": [995], "callee_method_names": ["Period.withFieldAdded"], "method_name": "TestPeriod_Basics.testWithFieldAdded1", "method_implementation": "{\n    Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    Period result = test.withFieldAdded(DurationFieldType.years(), 6);\n    assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test);\n    assertEquals(new Period(7, 2, 3, 4, 5, 6, 7, 8), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1320, "method_signature": "void testWithFieldAdded1()"}, "TestPeriod_Basics.testWithFields1": {"callee_method_ids": [993], "callee_method_names": ["Period.withFields"], "method_name": "TestPeriod_Basics.testWithFields1", "method_implementation": "{\n    Period test1 = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    Period test2 = new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis());\n    Period result = test1.withFields(test2);\n    assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 8), test1);\n    assertEquals(new Period(0, 0, 0, 0, 0, 0, 0, 9, PeriodType.millis()), test2);\n    assertEquals(new Period(1, 2, 3, 4, 5, 6, 7, 9), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1318, "method_signature": "void testWithFields1()"}, "TestPeriod_Basics.testWithPeriodType1": {"callee_method_ids": [992], "callee_method_names": ["Period.withPeriodType"], "method_name": "TestPeriod_Basics.testWithPeriodType1", "method_implementation": "{\n    Period test = new Period(123L);\n    Period result = test.withPeriodType(PeriodType.standard());\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1317, "method_signature": "void testWithPeriodType1()"}, "TestPeriod_Constructors.testConstants": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstants", "method_implementation": "{\n    Period test = Period.ZERO;\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1920, "method_signature": "void testConstants()"}, "TestPeriod_Constructors.testConstructor1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor1", "method_implementation": "{\n    Period test = new Period();\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1921, "method_signature": "void testConstructor1()"}, "TestPeriod_Constructors.testConstructor_4int1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_4int1", "method_implementation": "{\n    Period test = new Period(5, 6, 7, 8);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (4ints)\n */\n", "repo_name": "joda-time-main/", "id": 1926, "method_signature": "void testConstructor_4int1()"}, "TestPeriod_Constructors.testConstructor_8int1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_8int1", "method_implementation": "{\n    Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(4, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (8ints)\n */\n", "repo_name": "joda-time-main/", "id": 1927, "method_signature": "void testConstructor_8int1()"}, "TestPeriod_Constructors.testConstructor_8int__PeriodType1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_8int__PeriodType1", "method_implementation": "{\n    Period test = new Period(1, 2, 3, 4, 5, 6, 7, 8, null);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(3, test.getWeeks());\n    assertEquals(4, test.getDays());\n    assertEquals(5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (8ints)\n */\n", "repo_name": "joda-time-main/", "id": 1928, "method_signature": "void testConstructor_8int__PeriodType1()"}, "TestPeriod_Constructors.testConstructor_Object1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_Object1", "method_implementation": "{\n    Period test = new Period(\"P1Y2M3D\");\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(3, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1941, "method_signature": "void testConstructor_Object1()"}, "TestPeriod_Constructors.testConstructor_Object_PeriodType1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_Object_PeriodType1", "method_implementation": "{\n    Period test = new Period(\"P1Y2M3D\", PeriodType.yearMonthDayTime());\n    assertEquals(PeriodType.yearMonthDayTime(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(3, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1942, "method_signature": "void testConstructor_Object_PeriodType1()"}, "TestPeriod_Constructors.testConstructor_RD_RI1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_RD_RI1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Duration dur = new Interval(dt1, dt2).toDuration();\n    Period test = new Period(dur, dt2);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1939, "method_signature": "void testConstructor_RD_RI1()"}, "TestPeriod_Constructors.testConstructor_RD_RI_PeriodType1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_RD_RI_PeriodType1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Duration dur = new Interval(dt1, dt2).toDuration();\n    Period test = new Period(dur, dt2, PeriodType.yearDayTime());\n    assertEquals(PeriodType.yearDayTime(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(31, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1940, "method_signature": "void testConstructor_RD_RI_PeriodType1()"}, "TestPeriod_Constructors.testConstructor_RI_RD1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_RI_RD1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Duration dur = new Interval(dt1, dt2).toDuration();\n    Period test = new Period(dt1, dur);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1937, "method_signature": "void testConstructor_RI_RD1()"}, "TestPeriod_Constructors.testConstructor_RI_RD_PeriodType1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_RI_RD_PeriodType1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Duration dur = new Interval(dt1, dt2).toDuration();\n    Period test = new Period(dt1, dur, PeriodType.yearDayTime());\n    assertEquals(PeriodType.yearDayTime(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(31, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1938, "method_signature": "void testConstructor_RI_RD_PeriodType1()"}, "TestPeriod_Constructors.testConstructor_RI_RI1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_RI_RI1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Period test = new Period(dt1, dt2);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1933, "method_signature": "void testConstructor_RI_RI1()"}, "TestPeriod_Constructors.testConstructor_RI_RI_PeriodType1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_RI_RI_PeriodType1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Period test = new Period(dt1, dt2, null);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1934, "method_signature": "void testConstructor_RI_RI_PeriodType1()"}, "TestPeriod_Constructors.testConstructor_RP_RP1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_RP_RP1", "method_implementation": "{\n    YearMonthDay dt1 = new YearMonthDay(2004, 6, 9);\n    YearMonthDay dt2 = new YearMonthDay(2005, 7, 10);\n    Period test = new Period(dt1, dt2);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1935, "method_signature": "void testConstructor_RP_RP1()"}, "TestPeriod_Constructors.testConstructor_RP_RP_PeriodType1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_RP_RP_PeriodType1", "method_implementation": "{\n    YearMonthDay dt1 = new YearMonthDay(2004, 6, 9);\n    YearMonthDay dt2 = new YearMonthDay(2005, 7, 10);\n    Period test = new Period(dt1, dt2, PeriodType.standard());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1936, "method_signature": "void testConstructor_RP_RP_PeriodType1()"}, "TestPeriod_Constructors.testConstructor_long1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_long1", "method_implementation": "{\n    long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n    Period test = new Period(length);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals((4 * 24) + 5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1922, "method_signature": "void testConstructor_long1()"}, "TestPeriod_Constructors.testConstructor_long_Chronology1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_long_Chronology1", "method_implementation": "{\n    long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n    Period test = new Period(length, ISOChronology.getInstance());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals((4 * 24) + 5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1924, "method_signature": "void testConstructor_long_Chronology1()"}, "TestPeriod_Constructors.testConstructor_long_PeriodType1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_long_PeriodType1", "method_implementation": "{\n    long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n    Period test = new Period(length, (PeriodType) null);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals((4 * 24) + 5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(8, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1923, "method_signature": "void testConstructor_long_PeriodType1()"}, "TestPeriod_Constructors.testConstructor_long_PeriodType_Chronology1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_long_PeriodType_Chronology1", "method_implementation": "{\n    long length = 4 * DateTimeConstants.MILLIS_PER_DAY + 5 * DateTimeConstants.MILLIS_PER_HOUR + 6 * DateTimeConstants.MILLIS_PER_MINUTE + 7 * DateTimeConstants.MILLIS_PER_SECOND + 8;\n    Period test = new Period(length, PeriodType.time().withMillisRemoved(), ISOChronology.getInstance());\n    assertEquals(PeriodType.time().withMillisRemoved(), test.getPeriodType());\n    assertEquals(0, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals((4 * 24) + 5, test.getHours());\n    assertEquals(6, test.getMinutes());\n    assertEquals(7, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1925, "method_signature": "void testConstructor_long_PeriodType_Chronology1()"}, "TestPeriod_Constructors.testConstructor_long_long1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_long_long1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Period test = new Period(dt1.getMillis(), dt2.getMillis());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1929, "method_signature": "void testConstructor_long_long1()"}, "TestPeriod_Constructors.testConstructor_long_long_Chronology1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_long_long_Chronology1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance());\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance());\n    Period test = new Period(dt1.getMillis(), dt2.getMillis(), CopticChronology.getInstance());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1931, "method_signature": "void testConstructor_long_long_Chronology1()"}, "TestPeriod_Constructors.testConstructor_long_long_PeriodType1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_long_long_PeriodType1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0);\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1);\n    Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1930, "method_signature": "void testConstructor_long_long_PeriodType1()"}, "TestPeriod_Constructors.testConstructor_long_long_PeriodType_Chronology1": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testConstructor_long_long_PeriodType_Chronology1", "method_implementation": "{\n    DateTime dt1 = new DateTime(2004, 6, 9, 0, 0, 0, 0, CopticChronology.getInstance());\n    DateTime dt2 = new DateTime(2005, 7, 10, 1, 1, 1, 1, CopticChronology.getInstance());\n    Period test = new Period(dt1.getMillis(), dt2.getMillis(), (PeriodType) null, CopticChronology.getInstance());\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(1, test.getYears());\n    assertEquals(1, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(1, test.getDays());\n    assertEquals(1, test.getHours());\n    assertEquals(1, test.getMinutes());\n    assertEquals(1, test.getSeconds());\n    assertEquals(1, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1932, "method_signature": "void testConstructor_long_long_PeriodType_Chronology1()"}, "TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toFeb_standardYear": {"callee_method_names": ["Period.getPeriodType"], "method_name": "TestPeriod_Constructors.testConstructor_trickyDifferences_LD_LD_toFeb_standardYear", "method_implementation": "{\n    LocalDate dt1 = new LocalDate(2011, 1, 1);\n    LocalDate dt2 = new LocalDate(2011, 2, 28);\n    Period test = new Period(dt1, dt2);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(new Period(0, 1, 3, 6, 0, 0, 0, 0), test);\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1945, "method_signature": "void testConstructor_trickyDifferences_LD_LD_toFeb_standardYear()"}, "TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toFeb_standardYear": {"callee_method_names": ["Period.getPeriodType"], "method_name": "TestPeriod_Constructors.testConstructor_trickyDifferences_RI_RI_toFeb_standardYear", "method_implementation": "{\n    DateTime dt1 = new DateTime(2011, 1, 1, 0, 0);\n    DateTime dt2 = new DateTime(2011, 2, 28, 0, 0);\n    Period test = new Period(dt1, dt2);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(new Period(0, 1, 3, 6, 0, 0, 0, 0), test);\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1944, "method_signature": "void testConstructor_trickyDifferences_RI_RI_toFeb_standardYear()"}, "TestPeriod_Constructors.testFactoryFieldDifference1": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testFactoryFieldDifference1", "method_implementation": "{\n    YearMonthDay start = new YearMonthDay(2005, 4, 9);\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };\n    Partial end = new Partial(types, new int[] { 2004, 6, 7 });\n    Period test = Period.fieldDifference(start, end);\n    assertEquals(PeriodType.yearMonthDay(), test.getPeriodType());\n    assertEquals(-1, test.getYears());\n    assertEquals(2, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(-2, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1946, "method_signature": "void testFactoryFieldDifference1()"}, "TestPeriod_Constructors.testFactoryYears": {"callee_method_names": ["Period.getPeriodType", "Period.getYears", "Period.getMonths", "Period.getWeeks", "Period.getDays", "Period.getHours", "Period.getMinutes", "Period.getSeconds", "Period.getMillis"], "method_name": "TestPeriod_Constructors.testFactoryYears", "method_implementation": "{\n    Period test = Period.years(6);\n    assertEquals(PeriodType.standard(), test.getPeriodType());\n    assertEquals(6, test.getYears());\n    assertEquals(0, test.getMonths());\n    assertEquals(0, test.getWeeks());\n    assertEquals(0, test.getDays());\n    assertEquals(0, test.getHours());\n    assertEquals(0, test.getMinutes());\n    assertEquals(0, test.getSeconds());\n    assertEquals(0, test.getMillis());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1943, "method_signature": "void testFactoryYears()"}, "TestPreciseDateTimeField.test_addWrapField_long_int": {"callee_method_ids": [3, 3, 3], "callee_method_names": ["BaseDateTimeField.addWrapField", "BaseDateTimeField.addWrapField", "BaseDateTimeField.addWrapField"], "method_name": "TestPreciseDateTimeField.test_addWrapField_long_int", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDateTimeField();\n    assertEquals(29 * 60L, field.addWrapField(60L * 29, 0));\n    assertEquals(59 * 60L, field.addWrapField(60L * 29, 30));\n    assertEquals(0 * 60L, field.addWrapField(60L * 29, 31));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1134, "method_signature": "void test_addWrapField_long_int()"}, "TestPreciseDateTimeField.test_add_long_int": {"callee_method_ids": [0], "callee_method_names": ["BaseDateTimeField.add"], "method_name": "TestPreciseDateTimeField.test_add_long_int", "method_implementation": "{\n    MockCountingDurationField.add_int = 0;\n    BaseDateTimeField field = new MockPreciseDateTimeField();\n    assertEquals(61, field.add(1L, 1));\n    assertEquals(1, MockCountingDurationField.add_int);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1133, "method_signature": "void test_add_long_int()"}, "TestPreciseDateTimeField.test_constructor": {"callee_method_names": ["BaseDateTimeField.getType"], "method_name": "TestPreciseDateTimeField.test_constructor", "method_implementation": "{\n    BaseDateTimeField field = new PreciseDateTimeField(DateTimeFieldType.secondOfMinute(), ISOChronology.getInstanceUTC().millis(), ISOChronology.getInstanceUTC().hours());\n    assertEquals(DateTimeFieldType.secondOfMinute(), field.getType());\n    try {\n        field = new PreciseDateTimeField(null, null, null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        field = new PreciseDateTimeField(DateTimeFieldType.minuteOfHour(), new MockImpreciseDurationField(DurationFieldType.minutes()), ISOChronology.getInstanceUTC().hours());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        field = new PreciseDateTimeField(DateTimeFieldType.minuteOfHour(), ISOChronology.getInstanceUTC().hours(), new MockImpreciseDurationField(DurationFieldType.minutes()));\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        field = new PreciseDateTimeField(DateTimeFieldType.minuteOfHour(), ISOChronology.getInstanceUTC().hours(), ISOChronology.getInstanceUTC().hours());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        field = new PreciseDateTimeField(DateTimeFieldType.minuteOfHour(), new MockZeroDurationField(DurationFieldType.minutes()), ISOChronology.getInstanceUTC().hours());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1130, "method_signature": "void test_constructor()"}, "TestPreciseDateTimeField.test_getAsShortText_long_Locale": {"callee_method_names": ["BaseDateTimeField.getAsShortText", "BaseDateTimeField.getAsShortText"], "method_name": "TestPreciseDateTimeField.test_getAsShortText_long_Locale", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDateTimeField();\n    assertEquals(\"29\", field.getAsShortText(60L * 29, Locale.ENGLISH));\n    assertEquals(\"29\", field.getAsShortText(60L * 29, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1132, "method_signature": "void test_getAsShortText_long_Locale()"}, "TestPreciseDateTimeField.test_getAsText_long_Locale": {"callee_method_names": ["BaseDateTimeField.getAsText", "BaseDateTimeField.getAsText"], "method_name": "TestPreciseDateTimeField.test_getAsText_long_Locale", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDateTimeField();\n    assertEquals(\"29\", field.getAsText(60L * 29, Locale.ENGLISH));\n    assertEquals(\"29\", field.getAsText(60L * 29, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1131, "method_signature": "void test_getAsText_long_Locale()"}, "TestPreciseDateTimeField.test_getDifference_long_long": {"callee_method_names": ["BaseDateTimeField.getDifference"], "method_name": "TestPreciseDateTimeField.test_getDifference_long_long", "method_implementation": "{\n    MockCountingDurationField.difference_long = 0;\n    BaseDateTimeField field = new MockPreciseDateTimeField();\n    assertEquals(30, field.getDifference(0L, 0L));\n    assertEquals(1, MockCountingDurationField.difference_long);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1135, "method_signature": "void test_getDifference_long_long()"}, "TestPreciseDateTimeField.test_roundFloor_long": {"callee_method_names": ["BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor"], "method_name": "TestPreciseDateTimeField.test_roundFloor_long", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDateTimeField();\n    assertEquals(-120L, field.roundFloor(-61L));\n    assertEquals(-60L, field.roundFloor(-60L));\n    assertEquals(-60L, field.roundFloor(-59L));\n    assertEquals(-60L, field.roundFloor(-1L));\n    assertEquals(0L, field.roundFloor(0L));\n    assertEquals(0L, field.roundFloor(1L));\n    assertEquals(0L, field.roundFloor(29L));\n    assertEquals(0L, field.roundFloor(30L));\n    assertEquals(0L, field.roundFloor(31L));\n    assertEquals(60L, field.roundFloor(60L));\n}", "repo_id": "7", "comment": "//------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1137, "method_signature": "void test_roundFloor_long()"}, "TestPreciseDateTimeField.test_set_long_int": {"callee_method_ids": [6, 6], "callee_method_names": ["BaseDateTimeField.set", "BaseDateTimeField.set"], "method_name": "TestPreciseDateTimeField.test_set_long_int", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDateTimeField();\n    assertEquals(0, field.set(120L, 0));\n    assertEquals(29 * 60, field.set(120L, 29));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1136, "method_signature": "void test_set_long_int()"}, "TestPreciseDurationDateTimeField.test_addWrapField_long_int": {"callee_method_ids": [3, 3, 3], "callee_method_names": ["BaseDateTimeField.addWrapField", "BaseDateTimeField.addWrapField", "BaseDateTimeField.addWrapField"], "method_name": "TestPreciseDurationDateTimeField.test_addWrapField_long_int", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDurationDateTimeField();\n    assertEquals(29 * 60L, field.addWrapField(60L * 29, 0));\n    assertEquals(59 * 60L, field.addWrapField(60L * 29, 30));\n    assertEquals(0 * 60L, field.addWrapField(60L * 29, 31));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1161, "method_signature": "void test_addWrapField_long_int()"}, "TestPreciseDurationDateTimeField.test_add_long_int": {"callee_method_ids": [0], "callee_method_names": ["BaseDateTimeField.add"], "method_name": "TestPreciseDurationDateTimeField.test_add_long_int", "method_implementation": "{\n    MockCountingDurationField.add_int = 0;\n    BaseDateTimeField field = new MockPreciseDurationDateTimeField();\n    assertEquals(61, field.add(1L, 1));\n    assertEquals(1, MockCountingDurationField.add_int);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1160, "method_signature": "void test_add_long_int()"}, "TestPreciseDurationDateTimeField.test_constructor": {"callee_method_names": ["BaseDateTimeField.getType"], "method_name": "TestPreciseDurationDateTimeField.test_constructor", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDurationDateTimeField();\n    assertEquals(DateTimeFieldType.secondOfMinute(), field.getType());\n    try {\n        field = new MockPreciseDurationDateTimeField(null, null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        field = new MockPreciseDurationDateTimeField(DateTimeFieldType.minuteOfHour(), new MockImpreciseDurationField(DurationFieldType.minutes()));\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        field = new MockPreciseDurationDateTimeField(DateTimeFieldType.minuteOfHour(), new MockZeroDurationField(DurationFieldType.minutes()));\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1157, "method_signature": "void test_constructor()"}, "TestPreciseDurationDateTimeField.test_getAsShortText_long_Locale": {"callee_method_names": ["BaseDateTimeField.getAsShortText", "BaseDateTimeField.getAsShortText"], "method_name": "TestPreciseDurationDateTimeField.test_getAsShortText_long_Locale", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDurationDateTimeField();\n    assertEquals(\"29\", field.getAsShortText(60L * 29, Locale.ENGLISH));\n    assertEquals(\"29\", field.getAsShortText(60L * 29, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1159, "method_signature": "void test_getAsShortText_long_Locale()"}, "TestPreciseDurationDateTimeField.test_getAsText_long_Locale": {"callee_method_names": ["BaseDateTimeField.getAsText", "BaseDateTimeField.getAsText"], "method_name": "TestPreciseDurationDateTimeField.test_getAsText_long_Locale", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDurationDateTimeField();\n    assertEquals(\"29\", field.getAsText(60L * 29, Locale.ENGLISH));\n    assertEquals(\"29\", field.getAsText(60L * 29, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1158, "method_signature": "void test_getAsText_long_Locale()"}, "TestPreciseDurationDateTimeField.test_getDifference_long_long": {"callee_method_names": ["BaseDateTimeField.getDifference"], "method_name": "TestPreciseDurationDateTimeField.test_getDifference_long_long", "method_implementation": "{\n    MockCountingDurationField.difference_long = 0;\n    BaseDateTimeField field = new MockPreciseDurationDateTimeField();\n    assertEquals(30, field.getDifference(0L, 0L));\n    assertEquals(1, MockCountingDurationField.difference_long);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1162, "method_signature": "void test_getDifference_long_long()"}, "TestPreciseDurationDateTimeField.test_getMaximumTextLength_Locale": {"callee_method_ids": [8, 8, 8, 8, 8], "callee_method_names": ["BaseDateTimeField.getMaximumTextLength", "BaseDateTimeField.getMaximumTextLength", "BaseDateTimeField.getMaximumTextLength", "BaseDateTimeField.getMaximumTextLength", "BaseDateTimeField.getMaximumTextLength"], "method_name": "TestPreciseDurationDateTimeField.test_getMaximumTextLength_Locale", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDurationDateTimeField();\n    assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));\n    field = new MockPreciseDurationDateTimeField() {\n\n        @Override\n        public int getMaximumValue() {\n            return 5;\n        }\n    };\n    assertEquals(1, field.getMaximumTextLength(Locale.ENGLISH));\n    field = new MockPreciseDurationDateTimeField() {\n\n        @Override\n        public int getMaximumValue() {\n            return 555;\n        }\n    };\n    assertEquals(3, field.getMaximumTextLength(Locale.ENGLISH));\n    field = new MockPreciseDurationDateTimeField() {\n\n        @Override\n        public int getMaximumValue() {\n            return 5555;\n        }\n    };\n    assertEquals(4, field.getMaximumTextLength(Locale.ENGLISH));\n    field = new MockPreciseDurationDateTimeField() {\n\n        @Override\n        public int getMaximumValue() {\n            return -1;\n        }\n    };\n    assertEquals(2, field.getMaximumTextLength(Locale.ENGLISH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1164, "method_signature": "void test_getMaximumTextLength_Locale()"}, "TestPreciseDurationDateTimeField.test_roundFloor_long": {"callee_method_names": ["BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor", "BaseDateTimeField.roundFloor"], "method_name": "TestPreciseDurationDateTimeField.test_roundFloor_long", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDurationDateTimeField();\n    assertEquals(-120L, field.roundFloor(-61L));\n    assertEquals(-60L, field.roundFloor(-60L));\n    assertEquals(-60L, field.roundFloor(-59L));\n    assertEquals(-60L, field.roundFloor(-1L));\n    assertEquals(0L, field.roundFloor(0L));\n    assertEquals(0L, field.roundFloor(1L));\n    assertEquals(0L, field.roundFloor(29L));\n    assertEquals(0L, field.roundFloor(30L));\n    assertEquals(0L, field.roundFloor(31L));\n    assertEquals(60L, field.roundFloor(60L));\n}", "repo_id": "7", "comment": "//------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1165, "method_signature": "void test_roundFloor_long()"}, "TestPreciseDurationDateTimeField.test_set_long_int": {"callee_method_ids": [6, 6], "callee_method_names": ["BaseDateTimeField.set", "BaseDateTimeField.set"], "method_name": "TestPreciseDurationDateTimeField.test_set_long_int", "method_implementation": "{\n    BaseDateTimeField field = new MockPreciseDurationDateTimeField();\n    assertEquals(0, field.set(120L, 0));\n    assertEquals(29 * 60, field.set(120L, 29));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1163, "method_signature": "void test_set_long_int()"}, "TestPreciseDurationField.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestPreciseDurationField.testSerialization", "method_implementation": "{\n    DurationField test = iField;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    DurationField result = (DurationField) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1180, "method_signature": "void testSerialization()"}, "TestPreciseDurationField.test_add_long_int": {"callee_method_names": ["PreciseDurationField.add", "PreciseDurationField.add", "PreciseDurationField.add", "PreciseDurationField.add"], "method_name": "TestPreciseDurationField.test_add_long_int", "method_implementation": "{\n    assertEquals(567L, iField.add(567L, 0));\n    assertEquals(567L + 1234000L, iField.add(567L, 1234));\n    assertEquals(567L - 1234000L, iField.add(567L, -1234));\n    try {\n        iField.add(LONG_MAX, 1);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1176, "method_signature": "void test_add_long_int()"}, "TestPreciseDurationField.test_compareTo": {"callee_method_names": ["PreciseDurationField.compareTo", "PreciseDurationField.compareTo", "PreciseDurationField.compareTo", "PreciseDurationField.compareTo"], "method_name": "TestPreciseDurationField.test_compareTo", "method_implementation": "{\n    assertEquals(0, iField.compareTo(iField));\n    assertEquals(-1, iField.compareTo(ISOChronology.getInstance().minutes()));\n    DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0);\n    assertEquals(1, iField.compareTo(dummy));\n    //        try {\n    //            iField.compareTo(\"\");\n    //            fail();\n    //        } catch (ClassCastException ex) {}\n    try {\n        iField.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1179, "method_signature": "void test_compareTo()"}, "TestPreciseDurationField.test_constructor": {"callee_method_names": [], "method_name": "TestPreciseDurationField.test_constructor", "method_implementation": "{\n    try {\n        new PreciseDurationField(null, 10);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1173, "method_signature": "void test_constructor()"}, "TestPreciseDurationField.test_equals": {"callee_method_ids": [22, 22, 22, 22, 22, 22, 22], "callee_method_names": ["PreciseDurationField.equals", "PreciseDurationField.equals", "PreciseDurationField.equals", "PreciseDurationField.equals", "PreciseDurationField.equals", "PreciseDurationField.equals", "PreciseDurationField.equals"], "method_name": "TestPreciseDurationField.test_equals", "method_implementation": "{\n    assertEquals(true, iField.equals(iField));\n    assertEquals(false, iField.equals(ISOChronology.getInstance().minutes()));\n    DurationField dummy = new PreciseDurationField(DurationFieldType.seconds(), 0);\n    assertEquals(false, iField.equals(dummy));\n    dummy = new PreciseDurationField(DurationFieldType.seconds(), 1000);\n    assertEquals(true, iField.equals(dummy));\n    dummy = new PreciseDurationField(DurationFieldType.millis(), 1000);\n    assertEquals(false, iField.equals(dummy));\n    assertEquals(false, iField.equals(\"\"));\n    assertEquals(false, iField.equals(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1178, "method_signature": "void test_equals()"}, "TestPreciseDurationField.test_getDifference_long_int": {"callee_method_names": ["PreciseDurationField.getDifference", "PreciseDurationField.getDifference", "PreciseDurationField.getDifference", "PreciseDurationField.getDifference", "PreciseDurationField.getDifference"], "method_name": "TestPreciseDurationField.test_getDifference_long_int", "method_implementation": "{\n    assertEquals(0, iField.getDifference(1L, 0L));\n    assertEquals(567, iField.getDifference(567000L, 0L));\n    assertEquals(567 - 1234, iField.getDifference(567000L, 1234000L));\n    assertEquals(567 + 1234, iField.getDifference(567000L, -1234000L));\n    try {\n        iField.getDifference(LONG_MAX, -1L);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1177, "method_signature": "void test_getDifference_long_int()"}, "TestPreciseDurationField.test_getMillis_int": {"callee_method_names": ["PreciseDurationField.getMillis", "PreciseDurationField.getMillis", "PreciseDurationField.getMillis", "PreciseDurationField.getMillis"], "method_name": "TestPreciseDurationField.test_getMillis_int", "method_implementation": "{\n    assertEquals(0, iField.getMillis(0));\n    assertEquals(1234000L, iField.getMillis(1234));\n    assertEquals(-1234000L, iField.getMillis(-1234));\n    assertEquals(LONG_INTEGER_MAX * 1000L, iField.getMillis(INTEGER_MAX));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1175, "method_signature": "void test_getMillis_int()"}, "TestPreciseDurationField.test_getValue_long": {"callee_method_names": ["PreciseDurationField.getValue", "PreciseDurationField.getValue", "PreciseDurationField.getValue", "PreciseDurationField.getValue", "PreciseDurationField.getValue"], "method_name": "TestPreciseDurationField.test_getValue_long", "method_implementation": "{\n    assertEquals(0, iField.getValue(0L));\n    assertEquals(12345, iField.getValue(12345678L));\n    assertEquals(-1, iField.getValue(-1234L));\n    assertEquals(INTEGER_MAX, iField.getValue(LONG_INTEGER_MAX * 1000L + 999L));\n    try {\n        iField.getValue(LONG_INTEGER_MAX * 1000L + 1000L);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1174, "method_signature": "void test_getValue_long()"}, "TestReadableDurationConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestReadableDurationConverter.testSingleton", "method_implementation": "{\n    Class cls = ReadableDurationConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2086, "method_signature": "void testSingleton()"}, "TestReadableInstantConverter.testGetChronology_Object_Zone": {"callee_method_names": [], "method_name": "TestReadableInstantConverter.testGetChronology_Object_Zone", "method_implementation": "{\n    assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), PARIS));\n    assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), PARIS));\n    assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), DateTimeZone.getDefault()));\n    assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), DateTimeZone.getDefault()));\n    assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new Instant(123L), (DateTimeZone) null));\n    assertEquals(ISO, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L), (DateTimeZone) null));\n    assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(new DateTime(123L, new MockBadChronology()), PARIS));\n    MutableDateTime mdt = new MutableDateTime() {\n\n        @Override\n        public Chronology getChronology() {\n            // bad\n            return null;\n        }\n    };\n    assertEquals(ISO_PARIS, ReadableInstantConverter.INSTANCE.getChronology(mdt, PARIS));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2078, "method_signature": "void testGetChronology_Object_Zone()"}, "TestReadableInstantConverter.testGetInstantMillis_Object_Chronology": {"callee_method_names": [], "method_name": "TestReadableInstantConverter.testGetInstantMillis_Object_Chronology", "method_implementation": "{\n    assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), JULIAN));\n    assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), JULIAN));\n    assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new Instant(123L), (Chronology) null));\n    assertEquals(123L, ReadableInstantConverter.INSTANCE.getInstantMillis(new DateTime(123L), (Chronology) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2077, "method_signature": "void testGetInstantMillis_Object_Chronology()"}, "TestReadableInstantConverter.testGetPartialValues": {"callee_method_names": [], "method_name": "TestReadableInstantConverter.testGetPartialValues", "method_implementation": "{\n    TimeOfDay tod = new TimeOfDay();\n    int[] expected = ISOChronology.getInstance().get(tod, 12345678L);\n    int[] actual = ReadableInstantConverter.INSTANCE.getPartialValues(tod, new Instant(12345678L), ISOChronology.getInstance());\n    assertEquals(true, Arrays.equals(expected, actual));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2079, "method_signature": "void testGetPartialValues()"}, "TestReadableInstantConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestReadableInstantConverter.testSingleton", "method_implementation": "{\n    Class cls = ReadableInstantConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2076, "method_signature": "void testSingleton()"}, "TestReadableIntervalConverter.testGetPeriodType_Object": {"callee_method_names": [], "method_name": "TestReadableIntervalConverter.testGetPeriodType_Object", "method_implementation": "{\n    Interval i = new Interval(100L, 223L);\n    assertEquals(PeriodType.standard(), ReadableIntervalConverter.INSTANCE.getPeriodType(i));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2088, "method_signature": "void testGetPeriodType_Object()"}, "TestReadableIntervalConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestReadableIntervalConverter.testSingleton", "method_implementation": "{\n    Class cls = ReadableIntervalConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2087, "method_signature": "void testSingleton()"}, "TestReadablePartialConverter.testGetChronology_Object_Zone": {"callee_method_names": [], "method_name": "TestReadablePartialConverter.testGetChronology_Object_Zone", "method_implementation": "{\n    assertEquals(ISO_PARIS, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), PARIS));\n    assertEquals(ISO, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), DateTimeZone.getDefault()));\n    assertEquals(ISO, ReadablePartialConverter.INSTANCE.getChronology(new TimeOfDay(123L), (DateTimeZone) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2072, "method_signature": "void testGetChronology_Object_Zone()"}, "TestReadablePartialConverter.testGetPartialValues": {"callee_method_names": [], "method_name": "TestReadablePartialConverter.testGetPartialValues", "method_implementation": "{\n    TimeOfDay tod = new TimeOfDay();\n    int[] expected = new int[] { 1, 2, 3, 4 };\n    int[] actual = ReadablePartialConverter.INSTANCE.getPartialValues(tod, new TimeOfDay(1, 2, 3, 4), ISOChronology.getInstance(PARIS));\n    assertEquals(true, Arrays.equals(expected, actual));\n    try {\n        ReadablePartialConverter.INSTANCE.getPartialValues(tod, new YearMonthDay(2005, 6, 9), JULIAN);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        ReadablePartialConverter.INSTANCE.getPartialValues(tod, new MockTOD(), JULIAN);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2073, "method_signature": "void testGetPartialValues()"}, "TestReadablePartialConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestReadablePartialConverter.testSingleton", "method_implementation": "{\n    Class cls = ReadablePartialConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2071, "method_signature": "void testSingleton()"}, "TestReadablePeriodConverter.testGetPeriodType_Object": {"callee_method_names": [], "method_name": "TestReadablePeriodConverter.testGetPeriodType_Object", "method_implementation": "{\n    assertEquals(PeriodType.standard(), ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.standard())));\n    assertEquals(PeriodType.yearMonthDayTime(), ReadablePeriodConverter.INSTANCE.getPeriodType(new Period(123L, PeriodType.yearMonthDayTime())));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2081, "method_signature": "void testGetPeriodType_Object()"}, "TestReadablePeriodConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestReadablePeriodConverter.testSingleton", "method_implementation": "{\n    Class cls = ReadablePeriodConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2080, "method_signature": "void testSingleton()"}, "TestScaledDurationField.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestScaledDurationField.testSerialization", "method_implementation": "{\n    DurationField test = iField;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    DurationField result = (DurationField) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1123, "method_signature": "void testSerialization()"}, "TestScaledDurationField.test_add_long_int": {"callee_method_names": ["ScaledDurationField.add", "ScaledDurationField.add", "ScaledDurationField.add", "ScaledDurationField.add"], "method_name": "TestScaledDurationField.test_add_long_int", "method_implementation": "{\n    assertEquals(567L, iField.add(567L, 0));\n    assertEquals(567L + 1234L * 90L, iField.add(567L, 1234));\n    assertEquals(567L - 1234L * 90L, iField.add(567L, -1234));\n    try {\n        iField.add(LONG_MAX, 1);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1119, "method_signature": "void test_add_long_int()"}, "TestScaledDurationField.test_compareTo": {"callee_method_names": ["ScaledDurationField.compareTo", "ScaledDurationField.compareTo", "ScaledDurationField.compareTo", "ScaledDurationField.compareTo"], "method_name": "TestScaledDurationField.test_compareTo", "method_implementation": "{\n    assertEquals(0, iField.compareTo(iField));\n    assertEquals(-1, iField.compareTo(ISOChronology.getInstance().minutes()));\n    DurationField dummy = new PreciseDurationField(DurationFieldType.minutes(), 0);\n    assertEquals(1, iField.compareTo(dummy));\n    //        try {\n    //            iField.compareTo(\"\");\n    //            fail();\n    //        } catch (ClassCastException ex) {}\n    try {\n        iField.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1122, "method_signature": "void test_compareTo()"}, "TestScaledDurationField.test_constructor": {"callee_method_names": [], "method_name": "TestScaledDurationField.test_constructor", "method_implementation": "{\n    try {\n        new ScaledDurationField(null, DurationFieldType.minutes(), 10);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new ScaledDurationField(MillisDurationField.INSTANCE, null, 10);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1116, "method_signature": "void test_constructor()"}, "TestScaledDurationField.test_equals": {"callee_method_ids": [20, 20, 20, 20, 20, 20, 20], "callee_method_names": ["ScaledDurationField.equals", "ScaledDurationField.equals", "ScaledDurationField.equals", "ScaledDurationField.equals", "ScaledDurationField.equals", "ScaledDurationField.equals", "ScaledDurationField.equals"], "method_name": "TestScaledDurationField.test_equals", "method_implementation": "{\n    assertEquals(true, iField.equals(iField));\n    assertEquals(false, iField.equals(ISOChronology.getInstance().minutes()));\n    DurationField dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 2);\n    assertEquals(false, iField.equals(dummy));\n    dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.minutes(), 90);\n    assertEquals(true, iField.equals(dummy));\n    dummy = new ScaledDurationField(MillisDurationField.INSTANCE, DurationFieldType.millis(), 90);\n    assertEquals(false, iField.equals(dummy));\n    assertEquals(false, iField.equals(\"\"));\n    assertEquals(false, iField.equals(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1121, "method_signature": "void test_equals()"}, "TestScaledDurationField.test_getDifference_long_int": {"callee_method_names": ["ScaledDurationField.getDifference", "ScaledDurationField.getDifference", "ScaledDurationField.getDifference", "ScaledDurationField.getDifference", "ScaledDurationField.getDifference"], "method_name": "TestScaledDurationField.test_getDifference_long_int", "method_implementation": "{\n    assertEquals(0, iField.getDifference(1L, 0L));\n    assertEquals(567, iField.getDifference(567L * 90L, 0L));\n    assertEquals(567 - 1234, iField.getDifference(567L * 90L, 1234L * 90L));\n    assertEquals(567 + 1234, iField.getDifference(567L * 90L, -1234L * 90L));\n    try {\n        iField.getDifference(LONG_MAX, -1L);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1120, "method_signature": "void test_getDifference_long_int()"}, "TestScaledDurationField.test_getMillis_int": {"callee_method_names": ["ScaledDurationField.getMillis", "ScaledDurationField.getMillis", "ScaledDurationField.getMillis", "ScaledDurationField.getMillis"], "method_name": "TestScaledDurationField.test_getMillis_int", "method_implementation": "{\n    assertEquals(0, iField.getMillis(0));\n    assertEquals(1234L * 90L, iField.getMillis(1234));\n    assertEquals(-1234L * 90L, iField.getMillis(-1234));\n    assertEquals(LONG_INTEGER_MAX * 90L, iField.getMillis(INTEGER_MAX));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1118, "method_signature": "void test_getMillis_int()"}, "TestScaledDurationField.test_getValue_long": {"callee_method_names": ["ScaledDurationField.getValue", "ScaledDurationField.getValue", "ScaledDurationField.getValue", "ScaledDurationField.getValue", "ScaledDurationField.getValue"], "method_name": "TestScaledDurationField.test_getValue_long", "method_implementation": "{\n    assertEquals(0, iField.getValue(0L));\n    assertEquals(12345678 / 90, iField.getValue(12345678L));\n    assertEquals(-1234 / 90, iField.getValue(-1234L));\n    assertEquals(INTEGER_MAX / 90, iField.getValue(LONG_INTEGER_MAX));\n    try {\n        iField.getValue(LONG_INTEGER_MAX + 1L);\n        fail();\n    } catch (ArithmeticException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1117, "method_signature": "void test_getValue_long()"}, "TestSeconds.testAddToLocalDate": {"callee_method_names": ["LocalDateTime.plus"], "method_name": "TestSeconds.testAddToLocalDate", "method_implementation": "{\n    Seconds test = Seconds.seconds(26);\n    LocalDateTime date = new LocalDateTime(2006, 6, 1, 0, 0, 0, 0);\n    LocalDateTime expected = new LocalDateTime(2006, 6, 1, 0, 0, 26, 0);\n    assertEquals(expected, date.plus(test));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2160, "method_signature": "void testAddToLocalDate()"}, "TestSeconds.testConstants": {"callee_method_names": [], "method_name": "TestSeconds.testConstants", "method_implementation": "{\n    assertEquals(0, Seconds.ZERO.getSeconds());\n    assertEquals(1, Seconds.ONE.getSeconds());\n    assertEquals(2, Seconds.TWO.getSeconds());\n    assertEquals(3, Seconds.THREE.getSeconds());\n    assertEquals(Integer.MAX_VALUE, Seconds.MAX_VALUE.getSeconds());\n    assertEquals(Integer.MIN_VALUE, Seconds.MIN_VALUE.getSeconds());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2152, "method_signature": "void testConstants()"}, "TestSeconds.testFactory_secondsBetween_RInstant": {"callee_method_names": [], "method_name": "TestSeconds.testFactory_secondsBetween_RInstant", "method_implementation": "{\n    DateTime start = new DateTime(2006, 6, 9, 12, 0, 3, 0, PARIS);\n    DateTime end1 = new DateTime(2006, 6, 9, 12, 0, 6, 0, PARIS);\n    DateTime end2 = new DateTime(2006, 6, 9, 12, 0, 9, 0, PARIS);\n    assertEquals(3, Seconds.secondsBetween(start, end1).getSeconds());\n    assertEquals(0, Seconds.secondsBetween(start, start).getSeconds());\n    assertEquals(0, Seconds.secondsBetween(end1, end1).getSeconds());\n    assertEquals(-3, Seconds.secondsBetween(end1, start).getSeconds());\n    assertEquals(6, Seconds.secondsBetween(start, end2).getSeconds());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2154, "method_signature": "void testFactory_secondsBetween_RInstant()"}, "TestSeconds.testFactory_seconds_int": {"callee_method_names": [], "method_name": "TestSeconds.testFactory_seconds_int", "method_implementation": "{\n    assertSame(Seconds.ZERO, Seconds.seconds(0));\n    assertSame(Seconds.ONE, Seconds.seconds(1));\n    assertSame(Seconds.TWO, Seconds.seconds(2));\n    assertSame(Seconds.THREE, Seconds.seconds(3));\n    assertSame(Seconds.MAX_VALUE, Seconds.seconds(Integer.MAX_VALUE));\n    assertSame(Seconds.MIN_VALUE, Seconds.seconds(Integer.MIN_VALUE));\n    assertEquals(-1, Seconds.seconds(-1).getSeconds());\n    assertEquals(4, Seconds.seconds(4).getSeconds());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2153, "method_signature": "void testFactory_seconds_int()"}, "TestSeconds.testIsGreaterThan": {"callee_method_names": [], "method_name": "TestSeconds.testIsGreaterThan", "method_implementation": "{\n    assertEquals(true, Seconds.THREE.isGreaterThan(Seconds.TWO));\n    assertEquals(false, Seconds.THREE.isGreaterThan(Seconds.THREE));\n    assertEquals(false, Seconds.TWO.isGreaterThan(Seconds.THREE));\n    assertEquals(true, Seconds.ONE.isGreaterThan(null));\n    assertEquals(false, Seconds.seconds(-1).isGreaterThan(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2155, "method_signature": "void testIsGreaterThan()"}, "TestSeconds.testPlus_int": {"callee_method_ids": [779], "callee_method_names": ["Seconds.plus", "Seconds.getSeconds", "Seconds.getSeconds"], "method_name": "TestSeconds.testPlus_int", "method_implementation": "{\n    Seconds test2 = Seconds.seconds(2);\n    Seconds result = test2.plus(3);\n    assertEquals(2, test2.getSeconds());\n    assertEquals(5, result.getSeconds());\n    assertEquals(1, Seconds.ONE.plus(0).getSeconds());\n    try {\n        Seconds.MAX_VALUE.plus(1);\n        fail();\n    } catch (ArithmeticException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2159, "method_signature": "void testPlus_int()"}, "TestSeconds.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestSeconds.testSerialization", "method_implementation": "{\n    Seconds test = Seconds.THREE;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Seconds result = (Seconds) ois.readObject();\n    ois.close();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2157, "method_signature": "void testSerialization()"}, "TestSeconds.testToStandardWeeks": {"callee_method_names": ["Seconds.toStandardWeeks"], "method_name": "TestSeconds.testToStandardWeeks", "method_implementation": "{\n    Seconds test = Seconds.seconds(60 * 60 * 24 * 7 * 2);\n    Weeks expected = Weeks.weeks(2);\n    assertEquals(expected, test.toStandardWeeks());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2158, "method_signature": "void testToStandardWeeks()"}, "TestSeconds.testToString": {"callee_method_ids": [784, 784], "callee_method_names": ["Seconds.toString", "Seconds.toString"], "method_name": "TestSeconds.testToString", "method_implementation": "{\n    Seconds test = Seconds.seconds(20);\n    assertEquals(\"PT20S\", test.toString());\n    test = Seconds.seconds(-20);\n    assertEquals(\"PT-20S\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2156, "method_signature": "void testToString()"}, "TestSerialization.testSerializedInstant": {"callee_method_names": [], "method_name": "TestSerialization.testSerializedInstant", "method_implementation": "{\n    Instant test = new Instant();\n    loadAndCompare(test, \"Instant\", false);\n    inlineCompare(test, false);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2469, "method_signature": "void testSerializedInstant()"}, "TestSerialization.testTest": {"callee_method_names": [], "method_name": "TestSerialization.testTest", "method_implementation": "{\n    assertEquals(\"2002-06-09T00:00:00.000Z\", new Instant(TEST_TIME_NOW).toString());\n    assertEquals(\"2002-04-05T12:24:00.000Z\", new Instant(TEST_TIME1).toString());\n    assertEquals(\"2003-05-06T14:28:00.000Z\", new Instant(TEST_TIME2).toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2468, "method_signature": "void testTest()"}, "TestStringConvert.testDateMidnight": {"callee_method_names": [], "method_name": "TestStringConvert.testDateMidnight", "method_implementation": "{\n    DateMidnight test = new DateMidnight(2010, 6, 30, ISOChronology.getInstance(ZONE));\n    String str = StringConvert.INSTANCE.convertToString(test);\n    assertEquals(\"2010-06-30T00:00:00.000+02:00\", str);\n    assertEquals(test, StringConvert.INSTANCE.convertFromString(DateMidnight.class, str));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2536, "method_signature": "void testDateMidnight()"}, "TestStringConvert.testTimeZone": {"callee_method_names": [], "method_name": "TestStringConvert.testTimeZone", "method_implementation": "{\n    DateTimeZone test = DateTimeZone.forID(\"Europe/Paris\");\n    String str = StringConvert.INSTANCE.convertToString(test);\n    assertEquals(\"Europe/Paris\", str);\n    assertEquals(test, StringConvert.INSTANCE.convertFromString(DateTimeZone.class, str));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2537, "method_signature": "void testTimeZone()"}, "TestStringConverter.testGetChronology_Object_Zone": {"callee_method_names": [], "method_name": "TestStringConverter.testGetChronology_Object_Zone", "method_implementation": "{\n    assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology(\"2004-06-09T12:24:48.501+01:00\", PARIS));\n    assertEquals(ISOChronology.getInstance(PARIS), StringConverter.INSTANCE.getChronology(\"2004-06-09T12:24:48.501\", PARIS));\n    assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology(\"2004-06-09T12:24:48.501+01:00\", (DateTimeZone) null));\n    assertEquals(ISOChronology.getInstance(LONDON), StringConverter.INSTANCE.getChronology(\"2004-06-09T12:24:48.501\", (DateTimeZone) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2091, "method_signature": "void testGetChronology_Object_Zone()"}, "TestStringConverter.testGetDateTime": {"callee_method_names": ["DateTime.toString"], "method_name": "TestStringConverter.testGetDateTime", "method_implementation": "{\n    DateTime base = new DateTime(2004, 6, 9, 12, 24, 48, 501, PARIS);\n    DateTime test = new DateTime(base.toString(), PARIS);\n    assertEquals(base, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2093, "method_signature": "void testGetDateTime()"}, "TestStringConverter.testGetDurationMillis_Object1": {"callee_method_names": [], "method_name": "TestStringConverter.testGetDurationMillis_Object1", "method_implementation": "{\n    long millis = StringConverter.INSTANCE.getDurationMillis(\"PT12.345S\");\n    assertEquals(12345, millis);\n    millis = StringConverter.INSTANCE.getDurationMillis(\"pt12.345s\");\n    assertEquals(12345, millis);\n    millis = StringConverter.INSTANCE.getDurationMillis(\"pt12s\");\n    assertEquals(12000, millis);\n    millis = StringConverter.INSTANCE.getDurationMillis(\"pt12.s\");\n    assertEquals(12000, millis);\n    millis = StringConverter.INSTANCE.getDurationMillis(\"pt-12.32s\");\n    assertEquals(-12320, millis);\n    millis = StringConverter.INSTANCE.getDurationMillis(\"pt-0.32s\");\n    assertEquals(-320, millis);\n    millis = StringConverter.INSTANCE.getDurationMillis(\"pt-0.0s\");\n    assertEquals(0, millis);\n    millis = StringConverter.INSTANCE.getDurationMillis(\"pt0.0s\");\n    assertEquals(0, millis);\n    millis = StringConverter.INSTANCE.getDurationMillis(\"pt12.3456s\");\n    assertEquals(12345, millis);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2094, "method_signature": "void testGetDurationMillis_Object1()"}, "TestStringConverter.testGetInstantMillis_Object": {"callee_method_names": ["DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis", "DateTime.getMillis"], "method_name": "TestStringConverter.testGetInstantMillis_Object", "method_implementation": "{\n    DateTime dt = new DateTime(2004, 6, 9, 12, 24, 48, 501, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 1, 1, 0, 0, 0, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004T+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 1, 0, 0, 0, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06T+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-161T+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 0, 0, 0, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-W24-3T+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 7, 0, 0, 0, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-W24T+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 12, 0, 0, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 12, 24, 0, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 12, 24, 48, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 12, 30, 0, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12.5+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 12, 24, 30, 0, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24.5+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 12, 24, 48, 500, EIGHT);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.5+08:00\", ISO_EIGHT));\n    dt = new DateTime(2004, 6, 9, 12, 24, 48, 501);\n    assertEquals(dt.getMillis(), StringConverter.INSTANCE.getInstantMillis(\"2004-06-09T12:24:48.501\", ISO));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2090, "method_signature": "void testGetInstantMillis_Object()"}, "TestStringConverter.testGetPartialValues": {"callee_method_names": [], "method_name": "TestStringConverter.testGetPartialValues", "method_implementation": "{\n    TimeOfDay tod = new TimeOfDay();\n    int[] expected = new int[] { 3, 4, 5, 6 };\n    int[] actual = StringConverter.INSTANCE.getPartialValues(tod, \"T03:04:05.006\", ISOChronology.getInstance());\n    assertEquals(true, Arrays.equals(expected, actual));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2092, "method_signature": "void testGetPartialValues()"}, "TestStringConverter.testSingleton": {"callee_method_names": ["Class.getModifiers", "Class.getModifiers", "Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers", "Class.getDeclaredField", "Field.getModifiers", "Field.getModifiers", "Field.getModifiers"], "method_name": "TestStringConverter.testSingleton", "method_implementation": "{\n    Class cls = StringConverter.class;\n    assertEquals(false, Modifier.isPublic(cls.getModifiers()));\n    assertEquals(false, Modifier.isProtected(cls.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isProtected(con.getModifiers()));\n    Field fld = cls.getDeclaredField(\"INSTANCE\");\n    assertEquals(false, Modifier.isPublic(fld.getModifiers()));\n    assertEquals(false, Modifier.isProtected(fld.getModifiers()));\n    assertEquals(false, Modifier.isPrivate(fld.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2089, "method_signature": "void testSingleton()"}, "TestTextFields.testMonthNames_monthStart": {"callee_method_ids": [855], "callee_method_names": ["DateTimeFormatter.print"], "method_name": "TestTextFields.testMonthNames_monthStart", "method_implementation": "{\n    DateTimeFormatter printer = DateTimeFormat.forPattern(\"MMMM\");\n    for (int i = 0; i < ZONES.length; i++) {\n        for (int month = 1; month <= 12; month++) {\n            DateTime dt = new DateTime(2004, month, 1, 1, 20, 30, 40, ZONES[i]);\n            String monthText = printer.print(dt);\n            assertEquals(MONTHS[month], monthText);\n        }\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2213, "method_signature": "void testMonthNames_monthStart()"}, "TestTimeOfDay_Basics.check": {"callee_method_names": ["TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Basics.check", "method_implementation": "{\n    assertEquals(hour, test.getHourOfDay());\n    assertEquals(min, test.getMinuteOfHour());\n    assertEquals(sec, test.getSecondOfMinute());\n    assertEquals(milli, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2535, "method_signature": "void check(TimeOfDay, int, int, int, int)"}, "TestTimeOfDay_Basics.testCompareTo": {"callee_method_names": ["TimeOfDay.compareTo", "TimeOfDay.compareTo", "TimeOfDay.compareTo", "TimeOfDay.compareTo", "TimeOfDay.compareTo", "TimeOfDay.compareTo", "TimeOfDay.compareTo", "TimeOfDay.compareTo", "TimeOfDay.compareTo", "TimeOfDay.compareTo", "TimeOfDay.compareTo"], "method_name": "TestTimeOfDay_Basics.testCompareTo", "method_implementation": "{\n    TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n    TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);\n    assertEquals(0, test1.compareTo(test1a));\n    assertEquals(0, test1a.compareTo(test1));\n    assertEquals(0, test1.compareTo(test1));\n    assertEquals(0, test1a.compareTo(test1a));\n    TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);\n    assertEquals(-1, test1.compareTo(test2));\n    assertEquals(+1, test2.compareTo(test1));\n    TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n    assertEquals(-1, test1.compareTo(test3));\n    assertEquals(+1, test3.compareTo(test1));\n    assertEquals(0, test3.compareTo(test2));\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };\n    int[] values = new int[] { 10, 20, 30, 40 };\n    Partial p = new Partial(types, values);\n    assertEquals(0, test1.compareTo(p));\n    try {\n        test1.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n    //        try {\n    //            test1.compareTo(new Date());\n    //            fail();\n    //        } catch (ClassCastException ex) {}\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2516, "method_signature": "void testCompareTo()"}, "TestTimeOfDay_Basics.testGet": {"callee_method_names": ["TimeOfDay.get", "TimeOfDay.get", "TimeOfDay.get", "TimeOfDay.get", "TimeOfDay.get", "TimeOfDay.get"], "method_name": "TestTimeOfDay_Basics.testGet", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay();\n    assertEquals(10 + OFFSET, test.get(DateTimeFieldType.hourOfDay()));\n    assertEquals(20, test.get(DateTimeFieldType.minuteOfHour()));\n    assertEquals(30, test.get(DateTimeFieldType.secondOfMinute()));\n    assertEquals(40, test.get(DateTimeFieldType.millisOfSecond()));\n    try {\n        test.get(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.get(DateTimeFieldType.dayOfMonth());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2515, "method_signature": "void testGet()"}, "TestTimeOfDay_Basics.testIsAfter_TOD": {"callee_method_names": ["TimeOfDay.isAfter", "TimeOfDay.isAfter", "TimeOfDay.isAfter", "TimeOfDay.isAfter", "TimeOfDay.isAfter", "TimeOfDay.isAfter", "TimeOfDay.isAfter", "TimeOfDay.isAfter", "TimeOfDay.isAfter"], "method_name": "TestTimeOfDay_Basics.testIsAfter_TOD", "method_implementation": "{\n    TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n    TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);\n    assertEquals(false, test1.isAfter(test1a));\n    assertEquals(false, test1a.isAfter(test1));\n    assertEquals(false, test1.isAfter(test1));\n    assertEquals(false, test1a.isAfter(test1a));\n    TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);\n    assertEquals(false, test1.isAfter(test2));\n    assertEquals(true, test2.isAfter(test1));\n    TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isAfter(test3));\n    assertEquals(true, test3.isAfter(test1));\n    assertEquals(false, test3.isAfter(test2));\n    try {\n        new TimeOfDay(10, 20, 35, 40).isAfter(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2519, "method_signature": "void testIsAfter_TOD()"}, "TestTimeOfDay_Basics.testIsBefore_TOD": {"callee_method_names": ["TimeOfDay.isBefore", "TimeOfDay.isBefore", "TimeOfDay.isBefore", "TimeOfDay.isBefore", "TimeOfDay.isBefore", "TimeOfDay.isBefore", "TimeOfDay.isBefore", "TimeOfDay.isBefore", "TimeOfDay.isBefore"], "method_name": "TestTimeOfDay_Basics.testIsBefore_TOD", "method_implementation": "{\n    TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n    TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);\n    assertEquals(false, test1.isBefore(test1a));\n    assertEquals(false, test1a.isBefore(test1));\n    assertEquals(false, test1.isBefore(test1));\n    assertEquals(false, test1a.isBefore(test1a));\n    TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);\n    assertEquals(true, test1.isBefore(test2));\n    assertEquals(false, test2.isBefore(test1));\n    TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n    assertEquals(true, test1.isBefore(test3));\n    assertEquals(false, test3.isBefore(test1));\n    assertEquals(false, test3.isBefore(test2));\n    try {\n        new TimeOfDay(10, 20, 35, 40).isBefore(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2518, "method_signature": "void testIsBefore_TOD()"}, "TestTimeOfDay_Basics.testIsEqual_TOD": {"callee_method_names": ["TimeOfDay.isEqual", "TimeOfDay.isEqual", "TimeOfDay.isEqual", "TimeOfDay.isEqual", "TimeOfDay.isEqual", "TimeOfDay.isEqual", "TimeOfDay.isEqual", "TimeOfDay.isEqual", "TimeOfDay.isEqual"], "method_name": "TestTimeOfDay_Basics.testIsEqual_TOD", "method_implementation": "{\n    TimeOfDay test1 = new TimeOfDay(10, 20, 30, 40);\n    TimeOfDay test1a = new TimeOfDay(10, 20, 30, 40);\n    assertEquals(true, test1.isEqual(test1a));\n    assertEquals(true, test1a.isEqual(test1));\n    assertEquals(true, test1.isEqual(test1));\n    assertEquals(true, test1a.isEqual(test1a));\n    TimeOfDay test2 = new TimeOfDay(10, 20, 35, 40);\n    assertEquals(false, test1.isEqual(test2));\n    assertEquals(false, test2.isEqual(test1));\n    TimeOfDay test3 = new TimeOfDay(10, 20, 35, 40, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isEqual(test3));\n    assertEquals(false, test3.isEqual(test1));\n    assertEquals(true, test3.isEqual(test2));\n    try {\n        new TimeOfDay(10, 20, 35, 40).isEqual(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2517, "method_signature": "void testIsEqual_TOD()"}, "TestTimeOfDay_Basics.testMinus_RP": {"callee_method_names": ["TimeOfDay.minus", "TimeOfDay.minus"], "method_name": "TestTimeOfDay_Basics.testMinus_RP", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40, BuddhistChronology.getInstance());\n    TimeOfDay result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n    TimeOfDay expected = new TimeOfDay(9, 19, 29, 39, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n    result = test.minus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2524, "method_signature": "void testMinus_RP()"}, "TestTimeOfDay_Basics.testPlus_RP": {"callee_method_names": ["TimeOfDay.plus", "TimeOfDay.plus"], "method_name": "TestTimeOfDay_Basics.testPlus_RP", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40, BuddhistChronology.getInstance());\n    TimeOfDay result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n    TimeOfDay expected = new TimeOfDay(15, 26, 37, 48, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n    result = test.plus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2523, "method_signature": "void testPlus_RP()"}, "TestTimeOfDay_Basics.testProperty": {"callee_method_names": ["TimeOfDay.hourOfDay", "TimeOfDay.property", "TimeOfDay.minuteOfHour", "TimeOfDay.property", "TimeOfDay.secondOfMinute", "TimeOfDay.property", "TimeOfDay.millisOfSecond", "TimeOfDay.property", "TimeOfDay.property", "TimeOfDay.property"], "method_name": "TestTimeOfDay_Basics.testProperty", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    assertEquals(test.hourOfDay(), test.property(DateTimeFieldType.hourOfDay()));\n    assertEquals(test.minuteOfHour(), test.property(DateTimeFieldType.minuteOfHour()));\n    assertEquals(test.secondOfMinute(), test.property(DateTimeFieldType.secondOfMinute()));\n    assertEquals(test.millisOfSecond(), test.property(DateTimeFieldType.millisOfSecond()));\n    try {\n        test.property(DateTimeFieldType.millisOfDay());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2530, "method_signature": "void testProperty()"}, "TestTimeOfDay_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close", "TimeOfDay.getValues", "TimeOfDay.getValues", "TimeOfDay.getFields", "TimeOfDay.getFields", "TimeOfDay.getChronology", "TimeOfDay.getChronology"], "method_name": "TestTimeOfDay_Basics.testSerialization", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    TimeOfDay result = (TimeOfDay) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n    assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n    assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n    assertEquals(test.getChronology(), result.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2531, "method_signature": "void testSerialization()"}, "TestTimeOfDay_Basics.testToDateTimeToday": {"callee_method_ids": [641], "callee_method_names": ["DateTime.getMillis", "TimeOfDay.toDateTimeToday", "DateTime.getMillis", "DateTime.hourOfDay", "DateTime.minuteOfHour", "DateTime.secondOfMinute", "DateTime.millisOfSecond"], "method_name": "TestTimeOfDay_Basics.testToDateTimeToday", "method_implementation": "{\n    // PARIS irrelevant\n    TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n    DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    DateTime test = base.toDateTimeToday();\n    check(base, 10, 20, 30, 40);\n    DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n    expected = expected.hourOfDay().setCopy(10);\n    expected = expected.minuteOfHour().setCopy(20);\n    expected = expected.secondOfMinute().setCopy(30);\n    expected = expected.millisOfSecond().setCopy(40);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2526, "method_signature": "void testToDateTimeToday()"}, "TestTimeOfDay_Basics.testToDateTimeToday_Zone": {"callee_method_ids": [641], "callee_method_names": ["DateTime.getMillis", "TimeOfDay.toDateTimeToday", "DateTime.getMillis", "DateTime.hourOfDay", "DateTime.minuteOfHour", "DateTime.secondOfMinute", "DateTime.millisOfSecond"], "method_name": "TestTimeOfDay_Basics.testToDateTimeToday_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n    DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    DateTime test = base.toDateTimeToday(TOKYO);\n    check(base, 10, 20, 30, 40);\n    DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);\n    expected = expected.hourOfDay().setCopy(10);\n    expected = expected.minuteOfHour().setCopy(20);\n    expected = expected.secondOfMinute().setCopy(30);\n    expected = expected.millisOfSecond().setCopy(40);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2527, "method_signature": "void testToDateTimeToday_Zone()"}, "TestTimeOfDay_Basics.testToDateTime_RI": {"callee_method_names": ["DateTime.toString", "TimeOfDay.toDateTime", "DateTime.toString", "DateTime.toString"], "method_name": "TestTimeOfDay_Basics.testToDateTime_RI", "method_implementation": "{\n    TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n    // LONDON zone\n    DateTime dt = new DateTime(0L);\n    assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n    DateTime test = base.toDateTime(dt);\n    check(base, 10, 20, 30, 40);\n    assertEquals(\"1970-01-01T01:00:00.000+01:00\", dt.toString());\n    assertEquals(\"1970-01-01T10:20:30.040+01:00\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2528, "method_signature": "void testToDateTime_RI()"}, "TestTimeOfDay_Basics.testToLocalTime": {"callee_method_names": ["TimeOfDay.toLocalTime"], "method_name": "TestTimeOfDay_Basics.testToLocalTime", "method_implementation": "{\n    TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_UTC);\n    LocalTime test = base.toLocalTime();\n    assertEquals(new LocalTime(10, 20, 30, 40, COPTIC_UTC), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2525, "method_signature": "void testToLocalTime()"}, "TestTimeOfDay_Basics.testToString_DTFormatter": {"callee_method_names": ["TimeOfDay.toString", "TimeOfDay.toString"], "method_name": "TestTimeOfDay_Basics.testToString_DTFormatter", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    assertEquals(\"\\ufffd\\ufffd\\ufffd\\ufffd 10\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n    assertEquals(\"T10:20:30.040\", test.toString((DateTimeFormatter) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2534, "method_signature": "void testToString_DTFormatter()"}, "TestTimeOfDay_Basics.testToString_String": {"callee_method_names": ["TimeOfDay.toString", "TimeOfDay.toString"], "method_name": "TestTimeOfDay_Basics.testToString_String", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    assertEquals(\"\\ufffd\\ufffd\\ufffd\\ufffd 10\", test.toString(\"yyyy HH\"));\n    assertEquals(\"T10:20:30.040\", test.toString((String) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2532, "method_signature": "void testToString_String()"}, "TestTimeOfDay_Basics.testToString_String_Locale": {"callee_method_names": ["TimeOfDay.toString", "TimeOfDay.toString", "TimeOfDay.toString", "TimeOfDay.toString"], "method_name": "TestTimeOfDay_Basics.testToString_String_Locale", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    assertEquals(\"10 20\", test.toString(\"H m\", Locale.ENGLISH));\n    assertEquals(\"T10:20:30.040\", test.toString(null, Locale.ENGLISH));\n    assertEquals(\"10 20\", test.toString(\"H m\", null));\n    assertEquals(\"T10:20:30.040\", test.toString(null, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2533, "method_signature": "void testToString_String_Locale()"}, "TestTimeOfDay_Basics.testWithChronologyRetainFields_Chrono": {"callee_method_ids": [637], "callee_method_names": ["TimeOfDay.withChronologyRetainFields", "TimeOfDay.getChronology", "TimeOfDay.getChronology"], "method_name": "TestTimeOfDay_Basics.testWithChronologyRetainFields_Chrono", "method_implementation": "{\n    TimeOfDay base = new TimeOfDay(10, 20, 30, 40, COPTIC_PARIS);\n    TimeOfDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n    check(base, 10, 20, 30, 40);\n    assertEquals(COPTIC_UTC, base.getChronology());\n    check(test, 10, 20, 30, 40);\n    assertEquals(BUDDHIST_UTC, test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2520, "method_signature": "void testWithChronologyRetainFields_Chrono()"}, "TestTimeOfDay_Basics.testWithField1": {"callee_method_ids": [638], "callee_method_names": ["TimeOfDay.withField"], "method_name": "TestTimeOfDay_Basics.testWithField1", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    TimeOfDay result = test.withField(DateTimeFieldType.hourOfDay(), 15);\n    assertEquals(new TimeOfDay(10, 20, 30, 40), test);\n    assertEquals(new TimeOfDay(15, 20, 30, 40), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2521, "method_signature": "void testWithField1()"}, "TestTimeOfDay_Basics.testWithFieldAdded1": {"callee_method_ids": [639], "callee_method_names": ["TimeOfDay.withFieldAdded"], "method_name": "TestTimeOfDay_Basics.testWithFieldAdded1", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    TimeOfDay result = test.withFieldAdded(DurationFieldType.hours(), 6);\n    assertEquals(new TimeOfDay(10, 20, 30, 40), test);\n    assertEquals(new TimeOfDay(16, 20, 30, 40), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2522, "method_signature": "void testWithFieldAdded1()"}, "TestTimeOfDay_Basics.testWithers": {"callee_method_ids": [642, 643, 644, 645, 642, 642], "callee_method_names": ["TimeOfDay.withHourOfDay", "TimeOfDay.withMinuteOfHour", "TimeOfDay.withSecondOfMinute", "TimeOfDay.withMillisOfSecond", "TimeOfDay.withHourOfDay", "TimeOfDay.withHourOfDay"], "method_name": "TestTimeOfDay_Basics.testWithers", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    check(test.withHourOfDay(6), 6, 20, 30, 40);\n    check(test.withMinuteOfHour(6), 10, 6, 30, 40);\n    check(test.withSecondOfMinute(6), 10, 20, 6, 40);\n    check(test.withMillisOfSecond(6), 10, 20, 30, 6);\n    try {\n        test.withHourOfDay(-1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.withHourOfDay(24);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2529, "method_signature": "void testWithers()"}, "TestTimeOfDay_Constructors.testConstantMidnight": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstantMidnight", "method_implementation": "{\n    TimeOfDay test = TimeOfDay.MIDNIGHT;\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(0, test.getHourOfDay());\n    assertEquals(0, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1639, "method_signature": "void testConstantMidnight()"}, "TestTimeOfDay_Constructors.testConstructor": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay();\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10 + OFFSET, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1645, "method_signature": "void testConstructor()"}, "TestTimeOfDay_Constructors.testConstructor2_Object_Chronology": {"callee_method_names": ["TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor2_Object_Chronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(\"T10:20\");\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n    try {\n        new TimeOfDay(\"T1020\");\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1660, "method_signature": "void testConstructor2_Object_Chronology()"}, "TestTimeOfDay_Constructors.testConstructor_Chronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_Chronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(JulianChronology.getInstance());\n    assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(10 + OFFSET, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1648, "method_signature": "void testConstructor_Chronology()"}, "TestTimeOfDay_Constructors.testConstructor_DateTimeZone": {"callee_method_names": ["DateTime.getMillis", "TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond", "TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_DateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    TimeOfDay test = new TimeOfDay(LONDON);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(23, test.getHourOfDay());\n    assertEquals(59, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    test = new TimeOfDay(PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(0, test.getHourOfDay());\n    assertEquals(59, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1646, "method_signature": "void testConstructor_DateTimeZone()"}, "TestTimeOfDay_Constructors.testConstructor_Object1": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_Object1", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    TimeOfDay test = new TimeOfDay(date);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1 + OFFSET, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1655, "method_signature": "void testConstructor_Object1()"}, "TestTimeOfDay_Constructors.testConstructor_Object2": {"callee_method_names": ["Calendar.setTime", "TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_Object2", "method_implementation": "{\n    Calendar cal = new GregorianCalendar();\n    cal.setTime(new Date(TEST_TIME1));\n    TimeOfDay test = new TimeOfDay(cal);\n    assertEquals(GJChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(1 + OFFSET, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1656, "method_signature": "void testConstructor_Object2()"}, "TestTimeOfDay_Constructors.testConstructor_Object_Chronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_Object_Chronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    TimeOfDay test = new TimeOfDay(date, JulianChronology.getInstance());\n    assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(1 + OFFSET, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1659, "method_signature": "void testConstructor_Object_Chronology()"}, "TestTimeOfDay_Constructors.testConstructor_Object_nullChronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_Object_nullChronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    TimeOfDay test = new TimeOfDay(date, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1 + OFFSET, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1662, "method_signature": "void testConstructor_Object_nullChronology()"}, "TestTimeOfDay_Constructors.testConstructor_int_int": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_int_int", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n    try {\n        new TimeOfDay(-1, 20);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(24, 20);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, -1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 60);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1664, "method_signature": "void testConstructor_int_int()"}, "TestTimeOfDay_Constructors.testConstructor_int_int_Chronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_int_int_Chronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, JulianChronology.getInstance());\n    assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n    try {\n        new TimeOfDay(-1, 20, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(24, 20, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, -1, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 60, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1665, "method_signature": "void testConstructor_int_int_Chronology()"}, "TestTimeOfDay_Constructors.testConstructor_int_int_int": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_int_int_int", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n    try {\n        new TimeOfDay(-1, 20, 30);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(24, 20, 30);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, -1, 30);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 60, 30);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, -1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, 60);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1667, "method_signature": "void testConstructor_int_int_int()"}, "TestTimeOfDay_Constructors.testConstructor_int_int_int_Chronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_int_int_int_Chronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, JulianChronology.getInstance());\n    assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n    try {\n        new TimeOfDay(-1, 20, 30, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(24, 20, 30, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, -1, 30, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 60, 30, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, -1, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, 60, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1668, "method_signature": "void testConstructor_int_int_int_Chronology()"}, "TestTimeOfDay_Constructors.testConstructor_int_int_int_int": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_int_int_int_int", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    try {\n        new TimeOfDay(-1, 20, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(24, 20, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, -1, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 60, 30, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, -1, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, 60, 40);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, 30, -1);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, 30, 1000);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1670, "method_signature": "void testConstructor_int_int_int_int()"}, "TestTimeOfDay_Constructors.testConstructor_int_int_int_int_Chronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_int_int_int_int_Chronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40, JulianChronology.getInstance());\n    assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n    try {\n        new TimeOfDay(-1, 20, 30, 40, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(24, 20, 30, 40, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, -1, 30, 40, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 60, 30, 40, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, -1, 40, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, 60, 40, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, 30, -1, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new TimeOfDay(10, 20, 30, 1000, JulianChronology.getInstance());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1671, "method_signature": "void testConstructor_int_int_int_int_Chronology()"}, "TestTimeOfDay_Constructors.testConstructor_int_int_int_int_nullChronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_int_int_int_int_nullChronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1672, "method_signature": "void testConstructor_int_int_int_int_nullChronology()"}, "TestTimeOfDay_Constructors.testConstructor_int_int_int_nullChronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_int_int_int_nullChronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1669, "method_signature": "void testConstructor_int_int_int_nullChronology()"}, "TestTimeOfDay_Constructors.testConstructor_int_int_nullChronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_int_int_nullChronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(0, test.getSecondOfMinute());\n    assertEquals(0, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1666, "method_signature": "void testConstructor_int_int_nullChronology()"}, "TestTimeOfDay_Constructors.testConstructor_long1": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_long1", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(TEST_TIME1);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1 + OFFSET, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1650, "method_signature": "void testConstructor_long1()"}, "TestTimeOfDay_Constructors.testConstructor_long1_Chronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_long1_Chronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(TEST_TIME1, JulianChronology.getInstance());\n    assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(1 + OFFSET, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1652, "method_signature": "void testConstructor_long1_Chronology()"}, "TestTimeOfDay_Constructors.testConstructor_long2": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_long2", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(TEST_TIME2);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(5 + OFFSET, test.getHourOfDay());\n    assertEquals(6, test.getMinuteOfHour());\n    assertEquals(7, test.getSecondOfMinute());\n    assertEquals(8, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1651, "method_signature": "void testConstructor_long2()"}, "TestTimeOfDay_Constructors.testConstructor_long2_Chronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_long2_Chronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(TEST_TIME2, JulianChronology.getInstance());\n    assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(5 + OFFSET, test.getHourOfDay());\n    assertEquals(6, test.getMinuteOfHour());\n    assertEquals(7, test.getSecondOfMinute());\n    assertEquals(8, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1653, "method_signature": "void testConstructor_long2_Chronology()"}, "TestTimeOfDay_Constructors.testConstructor_long_nullChronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_long_nullChronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(TEST_TIME1, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1 + OFFSET, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1654, "method_signature": "void testConstructor_long_nullChronology()"}, "TestTimeOfDay_Constructors.testConstructor_nullChronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_nullChronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay((Chronology) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10 + OFFSET, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1649, "method_signature": "void testConstructor_nullChronology()"}, "TestTimeOfDay_Constructors.testConstructor_nullDateTimeZone": {"callee_method_names": ["DateTime.getMillis", "TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_nullDateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 8, 23, 59, 30, 40, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    TimeOfDay test = new TimeOfDay((DateTimeZone) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(23, test.getHourOfDay());\n    assertEquals(59, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1647, "method_signature": "void testConstructor_nullDateTimeZone()"}, "TestTimeOfDay_Constructors.testConstructor_nullObject": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_nullObject", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay((Object) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10 + OFFSET, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null)\n */\n", "repo_name": "joda-time-main/", "id": 1657, "method_signature": "void testConstructor_nullObject()"}, "TestTimeOfDay_Constructors.testConstructor_nullObject_Chronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_nullObject_Chronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay((Object) null, JulianChronology.getInstance());\n    assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(10 + OFFSET, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1661, "method_signature": "void testConstructor_nullObject_Chronology()"}, "TestTimeOfDay_Constructors.testConstructor_nullObject_nullChronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_nullObject_nullChronology", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay((Object) null, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(10 + OFFSET, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1663, "method_signature": "void testConstructor_nullObject_nullChronology()"}, "TestTimeOfDay_Constructors.testConstructor_todObject": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testConstructor_todObject", "method_implementation": "{\n    TimeOfDay base = new TimeOfDay(10, 20, 30, 40, CopticChronology.getInstance(PARIS));\n    TimeOfDay test = new TimeOfDay(base);\n    assertEquals(CopticChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(10, test.getHourOfDay());\n    assertEquals(20, test.getMinuteOfHour());\n    assertEquals(30, test.getSecondOfMinute());\n    assertEquals(40, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object)\n */\n", "repo_name": "joda-time-main/", "id": 1658, "method_signature": "void testConstructor_todObject()"}, "TestTimeOfDay_Constructors.testFactoryMillisOfDay_long1": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testFactoryMillisOfDay_long1", "method_implementation": "{\n    TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test factory (long)\n */\n", "repo_name": "joda-time-main/", "id": 1642, "method_signature": "void testFactoryMillisOfDay_long1()"}, "TestTimeOfDay_Constructors.testFactoryMillisOfDay_long1_Chronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testFactoryMillisOfDay_long1_Chronology", "method_implementation": "{\n    TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1, JulianChronology.getInstance());\n    assertEquals(JulianChronology.getInstanceUTC(), test.getChronology());\n    assertEquals(1, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test factory (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1643, "method_signature": "void testFactoryMillisOfDay_long1_Chronology()"}, "TestTimeOfDay_Constructors.testFactoryMillisOfDay_long_nullChronology": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Constructors.testFactoryMillisOfDay_long_nullChronology", "method_implementation": "{\n    TimeOfDay test = TimeOfDay.fromMillisOfDay(TEST_TIME1, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1, test.getHourOfDay());\n    assertEquals(2, test.getMinuteOfHour());\n    assertEquals(3, test.getSecondOfMinute());\n    assertEquals(4, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "/**\n * Test factory (long, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1644, "method_signature": "void testFactoryMillisOfDay_long_nullChronology()"}, "TestTimeOfDay_Constructors.testFactory_FromCalendarFields": {"callee_method_names": ["GregorianCalendar.set"], "method_name": "TestTimeOfDay_Constructors.testFactory_FromCalendarFields", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    TimeOfDay expected = new TimeOfDay(4, 5, 6, 7);\n    assertEquals(expected, TimeOfDay.fromCalendarFields(cal));\n    try {\n        TimeOfDay.fromCalendarFields(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1640, "method_signature": "void testFactory_FromCalendarFields()"}, "TestTimeOfDay_Constructors.testFactory_FromDateFields_after1970": {"callee_method_names": ["GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestTimeOfDay_Constructors.testFactory_FromDateFields_after1970", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    TimeOfDay expected = new TimeOfDay(4, 5, 6, 7);\n    assertEquals(expected, TimeOfDay.fromDateFields(cal.getTime()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1641, "method_signature": "void testFactory_FromDateFields_after1970()"}, "TestTimeOfDay_Properties.check": {"callee_method_names": ["TimeOfDay.getHourOfDay", "TimeOfDay.getMinuteOfHour", "TimeOfDay.getSecondOfMinute", "TimeOfDay.getMillisOfSecond"], "method_name": "TestTimeOfDay_Properties.check", "method_implementation": "{\n    assertEquals(hour, test.getHourOfDay());\n    assertEquals(min, test.getMinuteOfHour());\n    assertEquals(sec, test.getSecondOfMinute());\n    assertEquals(milli, test.getMillisOfSecond());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1232, "method_signature": "void check(TimeOfDay, int, int, int, int)"}, "TestTimeOfDay_Properties.testPropertyGetHour": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.getChronology", "TimeOfDay.hourOfDay", "TimeOfDay.getChronology", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay", "TimeOfDay.hourOfDay"], "method_name": "TestTimeOfDay_Properties.testPropertyGetHour", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    assertSame(test.getChronology().hourOfDay(), test.hourOfDay().getField());\n    assertEquals(\"hourOfDay\", test.hourOfDay().getName());\n    assertEquals(\"Property[hourOfDay]\", test.hourOfDay().toString());\n    assertSame(test, test.hourOfDay().getReadablePartial());\n    assertSame(test, test.hourOfDay().getTimeOfDay());\n    assertEquals(10, test.hourOfDay().get());\n    assertEquals(\"10\", test.hourOfDay().getAsString());\n    assertEquals(\"10\", test.hourOfDay().getAsText());\n    assertEquals(\"10\", test.hourOfDay().getAsText(Locale.FRENCH));\n    assertEquals(\"10\", test.hourOfDay().getAsShortText());\n    assertEquals(\"10\", test.hourOfDay().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().hours(), test.hourOfDay().getDurationField());\n    assertEquals(test.getChronology().days(), test.hourOfDay().getRangeDurationField());\n    assertEquals(2, test.hourOfDay().getMaximumTextLength(null));\n    assertEquals(2, test.hourOfDay().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1228, "method_signature": "void testPropertyGetHour()"}, "TestTimeOfDay_Properties.testPropertyGetMilli": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.getChronology", "TimeOfDay.millisOfSecond", "TimeOfDay.getChronology", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond", "TimeOfDay.millisOfSecond"], "method_name": "TestTimeOfDay_Properties.testPropertyGetMilli", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    assertSame(test.getChronology().millisOfSecond(), test.millisOfSecond().getField());\n    assertEquals(\"millisOfSecond\", test.millisOfSecond().getName());\n    assertEquals(\"Property[millisOfSecond]\", test.millisOfSecond().toString());\n    assertSame(test, test.millisOfSecond().getReadablePartial());\n    assertSame(test, test.millisOfSecond().getTimeOfDay());\n    assertEquals(40, test.millisOfSecond().get());\n    assertEquals(\"40\", test.millisOfSecond().getAsString());\n    assertEquals(\"40\", test.millisOfSecond().getAsText());\n    assertEquals(\"40\", test.millisOfSecond().getAsText(Locale.FRENCH));\n    assertEquals(\"40\", test.millisOfSecond().getAsShortText());\n    assertEquals(\"40\", test.millisOfSecond().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().millis(), test.millisOfSecond().getDurationField());\n    assertEquals(test.getChronology().seconds(), test.millisOfSecond().getRangeDurationField());\n    assertEquals(3, test.millisOfSecond().getMaximumTextLength(null));\n    assertEquals(3, test.millisOfSecond().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1231, "method_signature": "void testPropertyGetMilli()"}, "TestTimeOfDay_Properties.testPropertyGetMinute": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.getChronology", "TimeOfDay.minuteOfHour", "TimeOfDay.getChronology", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour", "TimeOfDay.minuteOfHour"], "method_name": "TestTimeOfDay_Properties.testPropertyGetMinute", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    assertSame(test.getChronology().minuteOfHour(), test.minuteOfHour().getField());\n    assertEquals(\"minuteOfHour\", test.minuteOfHour().getName());\n    assertEquals(\"Property[minuteOfHour]\", test.minuteOfHour().toString());\n    assertSame(test, test.minuteOfHour().getReadablePartial());\n    assertSame(test, test.minuteOfHour().getTimeOfDay());\n    assertEquals(20, test.minuteOfHour().get());\n    assertEquals(\"20\", test.minuteOfHour().getAsString());\n    assertEquals(\"20\", test.minuteOfHour().getAsText());\n    assertEquals(\"20\", test.minuteOfHour().getAsText(Locale.FRENCH));\n    assertEquals(\"20\", test.minuteOfHour().getAsShortText());\n    assertEquals(\"20\", test.minuteOfHour().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().minutes(), test.minuteOfHour().getDurationField());\n    assertEquals(test.getChronology().hours(), test.minuteOfHour().getRangeDurationField());\n    assertEquals(2, test.minuteOfHour().getMaximumTextLength(null));\n    assertEquals(2, test.minuteOfHour().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1229, "method_signature": "void testPropertyGetMinute()"}, "TestTimeOfDay_Properties.testPropertyGetSecond": {"callee_method_names": ["TimeOfDay.getChronology", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.getChronology", "TimeOfDay.secondOfMinute", "TimeOfDay.getChronology", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute", "TimeOfDay.secondOfMinute"], "method_name": "TestTimeOfDay_Properties.testPropertyGetSecond", "method_implementation": "{\n    TimeOfDay test = new TimeOfDay(10, 20, 30, 40);\n    assertSame(test.getChronology().secondOfMinute(), test.secondOfMinute().getField());\n    assertEquals(\"secondOfMinute\", test.secondOfMinute().getName());\n    assertEquals(\"Property[secondOfMinute]\", test.secondOfMinute().toString());\n    assertSame(test, test.secondOfMinute().getReadablePartial());\n    assertSame(test, test.secondOfMinute().getTimeOfDay());\n    assertEquals(30, test.secondOfMinute().get());\n    assertEquals(\"30\", test.secondOfMinute().getAsString());\n    assertEquals(\"30\", test.secondOfMinute().getAsText());\n    assertEquals(\"30\", test.secondOfMinute().getAsText(Locale.FRENCH));\n    assertEquals(\"30\", test.secondOfMinute().getAsShortText());\n    assertEquals(\"30\", test.secondOfMinute().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().seconds(), test.secondOfMinute().getDurationField());\n    assertEquals(test.getChronology().minutes(), test.secondOfMinute().getRangeDurationField());\n    assertEquals(2, test.secondOfMinute().getMaximumTextLength(null));\n    assertEquals(2, test.secondOfMinute().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1230, "method_signature": "void testPropertyGetSecond()"}, "TestUTCProvider.testClass": {"callee_method_names": ["Class.getModifiers", "Class.getDeclaredConstructor", "Class.getDeclaredConstructors", "Constructor.getModifiers"], "method_name": "TestUTCProvider.testClass", "method_implementation": "{\n    Class cls = UTCProvider.class;\n    assertEquals(true, Modifier.isPublic(cls.getModifiers()));\n    Constructor con = cls.getDeclaredConstructor((Class[]) null);\n    assertEquals(1, cls.getDeclaredConstructors().length);\n    assertEquals(true, Modifier.isPublic(con.getModifiers()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2121, "method_signature": "void testClass()"}, "TestUTCProvider.testGetAvailableIDs": {"callee_method_names": ["Provider.getAvailableIDs", "Set.size", "Set.iterator"], "method_name": "TestUTCProvider.testGetAvailableIDs", "method_implementation": "{\n    Provider p = new UTCProvider();\n    Set set = p.getAvailableIDs();\n    assertEquals(1, set.size());\n    assertEquals(\"UTC\", set.iterator().next());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2122, "method_signature": "void testGetAvailableIDs()"}, "TestUTCProvider.testGetZone_String": {"callee_method_names": ["Provider.getZone", "Provider.getZone", "Provider.getZone", "Provider.getZone"], "method_name": "TestUTCProvider.testGetZone_String", "method_implementation": "{\n    Provider p = new UTCProvider();\n    assertSame(DateTimeZone.UTC, p.getZone(\"UTC\"));\n    assertEquals(null, p.getZone(null));\n    assertEquals(null, p.getZone(\"Europe/London\"));\n    assertEquals(null, p.getZone(\"Blah\"));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2123, "method_signature": "void testGetZone_String()"}, "TestUnsupportedDateTimeField.testAlwaysFalseReturnTypes": {"callee_method_names": ["DateTimeField.isLenient", "DateTimeField.isSupported"], "method_name": "TestUnsupportedDateTimeField.testAlwaysFalseReturnTypes", "method_implementation": "{\n    DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(dateTimeFieldTypeOne, UnsupportedDurationField.getInstance(weeks));\n    assertFalse(fieldOne.isLenient());\n    assertFalse(fieldOne.isSupported());\n}", "repo_id": "7", "comment": "/**\n * As this is an unsupported date/time field, some normal methods will\n * always return false, as they are not supported. Verify that each method\n * correctly returns null.\n */\n", "repo_name": "joda-time-main/", "id": 1169, "method_signature": "void testAlwaysFalseReturnTypes()"}, "TestUnsupportedDateTimeField.testDelegatedMethods": {"callee_method_names": ["DateTimeField.add", "PreciseDurationField.add", "DateTimeField.add", "DateTimeField.add", "PreciseDurationField.add", "DateTimeField.add", "DateTimeField.getDifference", "PreciseDurationField.getDifference", "DateTimeField.getDifference", "DateTimeField.getDifferenceAsLong", "PreciseDurationField.getDifference", "DateTimeField.getDifference"], "method_name": "TestUnsupportedDateTimeField.testDelegatedMethods", "method_implementation": "{\n    DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(dateTimeFieldTypeOne, UnsupportedDurationField.getInstance(weeks));\n    PreciseDurationField hoursDuration = new PreciseDurationField(DurationFieldType.hours(), 10L);\n    DateTimeField fieldTwo = UnsupportedDateTimeField.getInstance(dateTimeFieldTypeOne, hoursDuration);\n    // UnsupportedDateTimeField.add(long instant, int value) should\n    // throw an UnsupportedOperationException when the duration does\n    // not support the operation, otherwise it delegates to the duration.\n    // First\n    // try it with an UnsupportedDurationField, then a PreciseDurationField.\n    try {\n        fieldOne.add(System.currentTimeMillis(), 100);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    try {\n        long currentTime = System.currentTimeMillis();\n        long firstComputation = hoursDuration.add(currentTime, 100);\n        long secondComputation = fieldTwo.add(currentTime, 100);\n        assertEquals(firstComputation, secondComputation);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(false);\n    }\n    // UnsupportedDateTimeField.add(long instant, long value) should\n    // throw an UnsupportedOperationException when the duration does\n    // not support the operation, otherwise it delegates to the duration.\n    // First\n    // try it with an UnsupportedDurationField, then a PreciseDurationField.\n    try {\n        fieldOne.add(System.currentTimeMillis(), 1000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    try {\n        long currentTime = System.currentTimeMillis();\n        long firstComputation = hoursDuration.add(currentTime, 1000L);\n        long secondComputation = fieldTwo.add(currentTime, 1000L);\n        assertTrue(firstComputation == secondComputation);\n        assertEquals(firstComputation, secondComputation);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(false);\n    }\n    // UnsupportedDateTimeField.getDifference(long minuendInstant,\n    // long subtrahendInstant)\n    // should throw an UnsupportedOperationException when the duration does\n    // not support the operation, otherwise return the result from the\n    // delegated call.\n    try {\n        fieldOne.getDifference(100000L, 1000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    try {\n        int firstDifference = hoursDuration.getDifference(100000L, 1000L);\n        int secondDifference = fieldTwo.getDifference(100000L, 1000L);\n        assertEquals(firstDifference, secondDifference);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(false);\n    }\n    // UnsupportedDateTimeField.getDifferenceAsLong(long minuendInstant,\n    // long subtrahendInstant)\n    // should throw an UnsupportedOperationException when the duration does\n    // not support the operation, otherwise return the result from the\n    // delegated call.\n    try {\n        fieldOne.getDifferenceAsLong(100000L, 1000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    try {\n        long firstDifference = hoursDuration.getDifference(100000L, 1000L);\n        long secondDifference = fieldTwo.getDifference(100000L, 1000L);\n        assertEquals(firstDifference, secondDifference);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(false);\n    }\n}", "repo_id": "7", "comment": "/**\n * As this is an unsupported date/time field, many normal methods are\n * unsupported. Some delegate and can possibly throw an\n * UnsupportedOperationException or have a valid return. Verify that each\n * method correctly throws this exception when appropriate and delegates\n * correctly based on the Duration used to get the instance.\n */\n", "repo_name": "joda-time-main/", "id": 1171, "method_signature": "void testDelegatedMethods()"}, "TestUnsupportedDateTimeField.testDifferentDurationReturnDifferentObjects": {"callee_method_names": [], "method_name": "TestUnsupportedDateTimeField.testDifferentDurationReturnDifferentObjects", "method_implementation": "{\n    /**\n     * The fields returned by getInstance should be the same when the\n     * duration is the same for both method calls.\n     */\n    DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(dateTimeFieldTypeOne, UnsupportedDurationField.getInstance(weeks));\n    DateTimeField fieldTwo = UnsupportedDateTimeField.getInstance(dateTimeFieldTypeOne, UnsupportedDurationField.getInstance(weeks));\n    assertSame(fieldOne, fieldTwo);\n    /**\n     * The fields returned by getInstance should NOT be the same when the\n     * duration is the same for both method calls.\n     */\n    DateTimeField fieldThree = UnsupportedDateTimeField.getInstance(dateTimeFieldTypeOne, UnsupportedDurationField.getInstance(months));\n    assertNotSame(fieldOne, fieldThree);\n}", "repo_id": "7", "comment": "/**\n * This test exercises the logic in UnsupportedDateTimeField.getInstance. If\n * getInstance() is invoked twice with: - the same DateTimeFieldType -\n * different duration fields\n *\n * Then the field returned in the first invocation should not be equal to\n * the field returned by the second invocation. In other words, the generated\n * instance should be the same for a unique pairing of\n * DateTimeFieldType/DurationField\n */\n", "repo_name": "joda-time-main/", "id": 1167, "method_signature": "void testDifferentDurationReturnDifferentObjects()"}, "TestUnsupportedDateTimeField.testNullValuesToGetInstanceThrowsException": {"callee_method_names": [], "method_name": "TestUnsupportedDateTimeField.testNullValuesToGetInstanceThrowsException", "method_implementation": "{\n    try {\n        UnsupportedDateTimeField.getInstance(null, null);\n        assertTrue(false);\n    } catch (IllegalArgumentException e) {\n        assertTrue(true);\n    }\n}", "repo_id": "7", "comment": "/**\n * Passing null values into UnsupportedDateTimeField.getInstance() should\n * throw an IllegalArguementsException\n */\n", "repo_name": "joda-time-main/", "id": 1166, "method_signature": "void testNullValuesToGetInstanceThrowsException()"}, "TestUnsupportedDateTimeField.testPublicGetNameMethod": {"callee_method_names": ["DateTimeField.getName", "DateTimeFieldType.getName"], "method_name": "TestUnsupportedDateTimeField.testPublicGetNameMethod", "method_implementation": "{\n    DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(dateTimeFieldTypeOne, UnsupportedDurationField.getInstance(weeks));\n    assertSame(fieldOne.getName(), dateTimeFieldTypeOne.getName());\n}", "repo_id": "7", "comment": "/**\n * The getName() method should return the same value as the getName() method\n * of the DateTimeFieldType that was used to create the instance.\n */\n", "repo_name": "joda-time-main/", "id": 1168, "method_signature": "void testPublicGetNameMethod()"}, "TestUnsupportedDateTimeField.testToString": {"callee_method_names": ["DateTimeField.toString", "String.length"], "method_name": "TestUnsupportedDateTimeField.testToString", "method_implementation": "{\n    DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(dateTimeFieldTypeOne, UnsupportedDurationField.getInstance(weeks));\n    String debugMessage = fieldOne.toString();\n    assertNotNull(debugMessage);\n    assertTrue(debugMessage.length() > 0);\n}", "repo_id": "7", "comment": "/**\n * The toString method should return a suitable debug message (not null).\n * Ensure that the toString method returns a string with length greater than\n * 0 (and not null)\n */\n", "repo_name": "joda-time-main/", "id": 1172, "method_signature": "void testToString()"}, "TestUnsupportedDateTimeField.testUnsupportedMethods": {"callee_method_names": ["DateTimeField.add", "DateTimeField.addWrapField", "DateTimeField.addWrapField", "DateTimeField.addWrapPartial", "DateTimeField.get", "DateTimeField.getAsShortText", "DateTimeField.getAsShortText", "DateTimeField.getAsShortText", "DateTimeField.getAsShortText", "DateTimeField.getAsShortText", "DateTimeField.getAsText", "DateTimeField.getAsText", "DateTimeField.getAsText", "DateTimeField.getAsText", "DateTimeField.getAsText", "DateTimeField.getLeapAmount", "DateTimeField.getMaximumShortTextLength", "DateTimeField.getMaximumTextLength", "DateTimeField.getMaximumValue", "DateTimeField.getMaximumValue", "DateTimeField.getMaximumValue", "DateTimeField.getMaximumValue", "DateTimeField.getMinimumValue", "DateTimeField.getMinimumValue", "DateTimeField.getMinimumValue", "DateTimeField.getMinimumValue", "DateTimeField.isLeap", "DateTimeField.remainder", "DateTimeField.roundCeiling", "DateTimeField.roundFloor", "DateTimeField.roundHalfCeiling", "DateTimeField.roundHalfEven", "DateTimeField.roundHalfFloor", "DateTimeField.set", "DateTimeField.set", "DateTimeField.set", "DateTimeField.set", "DateTimeField.set"], "method_name": "TestUnsupportedDateTimeField.testUnsupportedMethods", "method_implementation": "{\n    DateTimeField fieldOne = UnsupportedDateTimeField.getInstance(dateTimeFieldTypeOne, UnsupportedDurationField.getInstance(weeks));\n    // add(ReadablePartial instant, int fieldIndex, int[] values, int\n    // valueToAdd)\n    try {\n        fieldOne.add(localTime, 0, new int[] { 0, 100 }, 100);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // addWrapField(long instant, int value)\n    try {\n        fieldOne.addWrapField(100000L, 250);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // addWrapField(ReadablePartial instant, int fieldIndex, int[] values,\n    // int valueToAdd)\n    try {\n        fieldOne.addWrapField(localTime, 0, new int[] { 0, 100 }, 100);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values,\n    // int valueToAdd)\n    try {\n        fieldOne.addWrapPartial(localTime, 0, new int[] { 0, 100 }, 100);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.get(long instant)\n    try {\n        fieldOne.get(1000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsShortText(int fieldValue,\n    // Locale locale)\n    try {\n        fieldOne.getAsShortText(0, Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsShortText(long instant)\n    try {\n        fieldOne.getAsShortText(100000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsShortText(long instant, Locale locale)\n    try {\n        fieldOne.getAsShortText(100000L, Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsShortText(ReadablePartial partial,\n    // int fieldValue,\n    // Locale locale)\n    try {\n        fieldOne.getAsShortText(localTime, 0, Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsShortText(ReadablePartial partial,\n    // Locale locale)\n    try {\n        fieldOne.getAsShortText(localTime, Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsText(int fieldValue,\n    // Locale locale)\n    try {\n        fieldOne.getAsText(0, Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsText(long instant)\n    try {\n        fieldOne.getAsText(1000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsText(long instant, Locale locale)\n    try {\n        fieldOne.getAsText(1000L, Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsText(ReadablePartial partial,\n    // int fieldValue,\n    // Locale locale)\n    try {\n        fieldOne.getAsText(localTime, 0, Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getAsText(ReadablePartial partial,\n    // Locale locale)\n    try {\n        fieldOne.getAsText(localTime, Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getLeapAmount(long instant) is unsupported\n    // and should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.getLeapAmount(System.currentTimeMillis());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMaximumShortTextLength(Locale locale)\n    // is unsupported and should always thrown an\n    // UnsupportedOperationException\n    try {\n        fieldOne.getMaximumShortTextLength(Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMaximumTextLength(Locale locale)\n    // is unsupported and should always thrown an\n    // UnsupportedOperationException\n    try {\n        fieldOne.getMaximumTextLength(Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMaximumValue() is unsupported\n    // and should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.getMaximumValue();\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMaximumValue(long instant)\n    // is unsupported and should always thrown an\n    // UnsupportedOperationException\n    try {\n        fieldOne.getMaximumValue(1000000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMaximumValue(ReadablePartial instant)\n    // is unsupported and should always thrown an\n    // UnsupportedOperationException\n    try {\n        fieldOne.getMaximumValue(localTime);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMaximumValue(ReadablePartial instant,\n    // int[] values)\n    // is unsupported and should always thrown an\n    // UnsupportedOperationException\n    try {\n        fieldOne.getMaximumValue(localTime, new int[] { 0 });\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMinumumValue() is unsupported\n    // and should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.getMinimumValue();\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMinumumValue(long instant) is unsupported\n    // and should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.getMinimumValue(10000000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMinumumValue(ReadablePartial instant)\n    // is unsupported and should always thrown an\n    // UnsupportedOperationException\n    try {\n        fieldOne.getMinimumValue(localTime);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.getMinumumValue(ReadablePartial instant,\n    // int[] values) is unsupported\n    // and should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.getMinimumValue(localTime, new int[] { 0 });\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.isLeap(long instant) is unsupported and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.isLeap(System.currentTimeMillis());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.remainder(long instant) is unsupported and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.remainder(1000000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.roundCeiling(long instant) is unsupported\n    // and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.roundCeiling(1000000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.roundFloor(long instant) is unsupported and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.roundFloor(1000000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.roundHalfCeiling(long instant) is\n    // unsupported and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.roundHalfCeiling(1000000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.roundHalfEven(long instant) is unsupported\n    // and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.roundHalfEven(1000000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.roundHalfFloor(long instant) is unsupported\n    // and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.roundHalfFloor(1000000L);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.set(long instant, int value) is unsupported\n    // and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.set(1000000L, 1000);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.set(long instant, String test) is\n    // unsupported and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.set(1000000L, \"Unsupported Operation\");\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.set(long instant, String text, Locale\n    // locale)\n    // is unsupported and should always thrown an\n    // UnsupportedOperationException\n    try {\n        fieldOne.set(1000000L, \"Unsupported Operation\", Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.set(ReadablePartial instant,\n    // int fieldIndex,\n    // int[] values,\n    // int newValue) is unsupported and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.set(localTime, 0, new int[] { 0 }, 10000);\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n    // UnsupportedDateTimeField.set(ReadablePartial instant,\n    // int fieldIndex,\n    // int[] values,\n    // String text,\n    // Locale locale) is unsupported and\n    // should always thrown an UnsupportedOperationException\n    try {\n        fieldOne.set(localTime, 0, new int[] { 0 }, \"Unsupported Operation\", Locale.getDefault());\n        assertTrue(false);\n    } catch (UnsupportedOperationException e) {\n        assertTrue(true);\n    }\n}", "repo_id": "7", "comment": "/**\n * As this is an unsupported date/time field, many normal methods are\n * unsupported and throw an UnsupportedOperationException. Verify that each\n * method correctly throws this exception. * add(ReadablePartial instant,\n * int fieldIndex, int[] values, int valueToAdd) * addWrapField(long\n * instant, int value) * addWrapField(ReadablePartial instant, int\n * fieldIndex, int[] values, int valueToAdd) *\n * addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int\n * valueToAdd) * get(long instant) * getAsShortText(int fieldValue, Locale\n * locale) * getAsShortText(long instant) * getAsShortText(long instant,\n * Locale locale) * getAsShortText(ReadablePartial partial, int fieldValue,\n * Locale locale) * getAsShortText(ReadablePartial partial, Locale locale) *\n * getAsText(int fieldValue, Locale locale) * getAsText(long instant) *\n * getAsText(long instant, Locale locale) * getAsText(ReadablePartial\n * partial, int fieldValue, Locale locale) * getAsText(ReadablePartial\n * partial, Locale locale) * getLeapAmount(long instant) *\n * getMaximumShortTextLength(Locale locale) * getMaximumTextLength(Locale\n * locale) * getMaximumValue() * getMaximumValue(long instant) *\n * getMaximumValue(ReadablePartial instant) *\n * getMaximumValue(ReadablePartial instant, int[] values) *\n * getMinimumValue() * getMinimumValue(long instant) *\n * getMinimumValue(ReadablePartial instant) *\n * getMinimumValue(ReadablePartial instant, int[] values) * isLeap(long\n * instant) * remainder(long instant) * roundCeiling(long instant) *\n * roundFloor(long instant) * roundHalfCeiling(long instant) *\n * roundHalfEven(long instant) * roundHalfFloor(long instant) * set(long\n * instant, int value) * set(long instant, String text) * set(long instant,\n * String text, Locale locale) * set(ReadablePartial instant, int\n * fieldIndex, int[] values, int newValue) * set(ReadablePartial instant,\n * int fieldIndex, int[] values, String text, Locale locale)\n */\n", "repo_name": "joda-time-main/", "id": 1170, "method_signature": "void testUnsupportedMethods()"}, "TestWeeks.testAddToLocalDate": {"callee_method_names": ["LocalDate.plus"], "method_name": "TestWeeks.testAddToLocalDate", "method_implementation": "{\n    Weeks test = Weeks.weeks(3);\n    LocalDate date = new LocalDate(2006, 6, 1);\n    LocalDate expected = new LocalDate(2006, 6, 22);\n    assertEquals(expected, date.plus(test));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2039, "method_signature": "void testAddToLocalDate()"}, "TestWeeks.testConstants": {"callee_method_names": [], "method_name": "TestWeeks.testConstants", "method_implementation": "{\n    assertEquals(0, Weeks.ZERO.getWeeks());\n    assertEquals(1, Weeks.ONE.getWeeks());\n    assertEquals(2, Weeks.TWO.getWeeks());\n    assertEquals(3, Weeks.THREE.getWeeks());\n    assertEquals(Integer.MAX_VALUE, Weeks.MAX_VALUE.getWeeks());\n    assertEquals(Integer.MIN_VALUE, Weeks.MIN_VALUE.getWeeks());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2031, "method_signature": "void testConstants()"}, "TestWeeks.testFactory_weeksBetween_RInstant": {"callee_method_names": [], "method_name": "TestWeeks.testFactory_weeksBetween_RInstant", "method_implementation": "{\n    DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n    DateTime end1 = new DateTime(2006, 6, 30, 12, 0, 0, 0, PARIS);\n    DateTime end2 = new DateTime(2006, 7, 21, 12, 0, 0, 0, PARIS);\n    assertEquals(3, Weeks.weeksBetween(start, end1).getWeeks());\n    assertEquals(0, Weeks.weeksBetween(start, start).getWeeks());\n    assertEquals(0, Weeks.weeksBetween(end1, end1).getWeeks());\n    assertEquals(-3, Weeks.weeksBetween(end1, start).getWeeks());\n    assertEquals(6, Weeks.weeksBetween(start, end2).getWeeks());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2033, "method_signature": "void testFactory_weeksBetween_RInstant()"}, "TestWeeks.testFactory_weeks_int": {"callee_method_names": [], "method_name": "TestWeeks.testFactory_weeks_int", "method_implementation": "{\n    assertSame(Weeks.ZERO, Weeks.weeks(0));\n    assertSame(Weeks.ONE, Weeks.weeks(1));\n    assertSame(Weeks.TWO, Weeks.weeks(2));\n    assertSame(Weeks.THREE, Weeks.weeks(3));\n    assertSame(Weeks.MAX_VALUE, Weeks.weeks(Integer.MAX_VALUE));\n    assertSame(Weeks.MIN_VALUE, Weeks.weeks(Integer.MIN_VALUE));\n    assertEquals(-1, Weeks.weeks(-1).getWeeks());\n    assertEquals(4, Weeks.weeks(4).getWeeks());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2032, "method_signature": "void testFactory_weeks_int()"}, "TestWeeks.testIsGreaterThan": {"callee_method_names": [], "method_name": "TestWeeks.testIsGreaterThan", "method_implementation": "{\n    assertEquals(true, Weeks.THREE.isGreaterThan(Weeks.TWO));\n    assertEquals(false, Weeks.THREE.isGreaterThan(Weeks.THREE));\n    assertEquals(false, Weeks.TWO.isGreaterThan(Weeks.THREE));\n    assertEquals(true, Weeks.ONE.isGreaterThan(null));\n    assertEquals(false, Weeks.weeks(-1).isGreaterThan(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2034, "method_signature": "void testIsGreaterThan()"}, "TestWeeks.testPlus_int": {"callee_method_ids": [80], "callee_method_names": ["Weeks.plus", "Weeks.getWeeks", "Weeks.getWeeks"], "method_name": "TestWeeks.testPlus_int", "method_implementation": "{\n    Weeks test2 = Weeks.weeks(2);\n    Weeks result = test2.plus(3);\n    assertEquals(2, test2.getWeeks());\n    assertEquals(5, result.getWeeks());\n    assertEquals(1, Weeks.ONE.plus(0).getWeeks());\n    try {\n        Weeks.MAX_VALUE.plus(1);\n        fail();\n    } catch (ArithmeticException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2038, "method_signature": "void testPlus_int()"}, "TestWeeks.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestWeeks.testSerialization", "method_implementation": "{\n    Weeks test = Weeks.THREE;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Weeks result = (Weeks) ois.readObject();\n    ois.close();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2036, "method_signature": "void testSerialization()"}, "TestWeeks.testToStandardDays": {"callee_method_names": ["Weeks.toStandardDays"], "method_name": "TestWeeks.testToStandardDays", "method_implementation": "{\n    Weeks test = Weeks.weeks(2);\n    Days expected = Days.days(14);\n    assertEquals(expected, test.toStandardDays());\n    try {\n        Weeks.MAX_VALUE.toStandardDays();\n        fail();\n    } catch (ArithmeticException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2037, "method_signature": "void testToStandardDays()"}, "TestWeeks.testToString": {"callee_method_ids": [85, 85], "callee_method_names": ["Weeks.toString", "Weeks.toString"], "method_name": "TestWeeks.testToString", "method_implementation": "{\n    Weeks test = Weeks.weeks(20);\n    assertEquals(\"P20W\", test.toString());\n    test = Weeks.weeks(-20);\n    assertEquals(\"P-20W\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2035, "method_signature": "void testToString()"}, "TestYearMonthDay_Basics.check": {"callee_method_names": ["YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Basics.check", "method_implementation": "{\n    assertEquals(hour, test.getYear());\n    assertEquals(min, test.getMonthOfYear());\n    assertEquals(sec, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1701, "method_signature": "void check(YearMonthDay, int, int, int)"}, "TestYearMonthDay_Basics.testCompareTo": {"callee_method_names": ["YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo", "YearMonthDay.compareTo"], "method_name": "TestYearMonthDay_Basics.testCompareTo", "method_implementation": "{\n    YearMonthDay test1 = new YearMonthDay(2005, 6, 2);\n    YearMonthDay test1a = new YearMonthDay(2005, 6, 2);\n    assertEquals(0, test1.compareTo(test1a));\n    assertEquals(0, test1a.compareTo(test1));\n    assertEquals(0, test1.compareTo(test1));\n    assertEquals(0, test1a.compareTo(test1a));\n    YearMonthDay test2 = new YearMonthDay(2005, 7, 2);\n    assertEquals(-1, test1.compareTo(test2));\n    assertEquals(+1, test2.compareTo(test1));\n    YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());\n    assertEquals(-1, test1.compareTo(test3));\n    assertEquals(+1, test3.compareTo(test1));\n    assertEquals(0, test3.compareTo(test2));\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };\n    int[] values = new int[] { 2005, 6, 2 };\n    Partial p = new Partial(types, values);\n    assertEquals(0, test1.compareTo(p));\n    try {\n        test1.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n    //        try {\n    //            test1.compareTo(new Date());\n    //            fail();\n    //        } catch (ClassCastException ex) {}\n    try {\n        test1.compareTo(new TimeOfDay());\n        fail();\n    } catch (ClassCastException ex) {\n    }\n    Partial partial = new Partial().with(DateTimeFieldType.centuryOfEra(), 1).with(DateTimeFieldType.halfdayOfDay(), 0).with(DateTimeFieldType.dayOfMonth(), 9);\n    try {\n        new YearMonthDay(1970, 6, 9).compareTo(partial);\n        fail();\n    } catch (ClassCastException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1674, "method_signature": "void testCompareTo()"}, "TestYearMonthDay_Basics.testGet": {"callee_method_names": ["YearMonthDay.get", "YearMonthDay.get", "YearMonthDay.get", "YearMonthDay.get", "YearMonthDay.get"], "method_name": "TestYearMonthDay_Basics.testGet", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay();\n    assertEquals(1970, test.get(DateTimeFieldType.year()));\n    assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n    assertEquals(9, test.get(DateTimeFieldType.dayOfMonth()));\n    try {\n        test.get(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.get(DateTimeFieldType.hourOfDay());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1673, "method_signature": "void testGet()"}, "TestYearMonthDay_Basics.testIsAfter_YMD": {"callee_method_names": ["YearMonthDay.isAfter", "YearMonthDay.isAfter", "YearMonthDay.isAfter", "YearMonthDay.isAfter", "YearMonthDay.isAfter", "YearMonthDay.isAfter", "YearMonthDay.isAfter", "YearMonthDay.isAfter", "YearMonthDay.isAfter"], "method_name": "TestYearMonthDay_Basics.testIsAfter_YMD", "method_implementation": "{\n    YearMonthDay test1 = new YearMonthDay(2005, 6, 2);\n    YearMonthDay test1a = new YearMonthDay(2005, 6, 2);\n    assertEquals(false, test1.isAfter(test1a));\n    assertEquals(false, test1a.isAfter(test1));\n    assertEquals(false, test1.isAfter(test1));\n    assertEquals(false, test1a.isAfter(test1a));\n    YearMonthDay test2 = new YearMonthDay(2005, 7, 2);\n    assertEquals(false, test1.isAfter(test2));\n    assertEquals(true, test2.isAfter(test1));\n    YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isAfter(test3));\n    assertEquals(true, test3.isAfter(test1));\n    assertEquals(false, test3.isAfter(test2));\n    try {\n        new YearMonthDay(2005, 7, 2).isAfter(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1677, "method_signature": "void testIsAfter_YMD()"}, "TestYearMonthDay_Basics.testIsBefore_YMD": {"callee_method_names": ["YearMonthDay.isBefore", "YearMonthDay.isBefore", "YearMonthDay.isBefore", "YearMonthDay.isBefore", "YearMonthDay.isBefore", "YearMonthDay.isBefore", "YearMonthDay.isBefore", "YearMonthDay.isBefore", "YearMonthDay.isBefore"], "method_name": "TestYearMonthDay_Basics.testIsBefore_YMD", "method_implementation": "{\n    YearMonthDay test1 = new YearMonthDay(2005, 6, 2);\n    YearMonthDay test1a = new YearMonthDay(2005, 6, 2);\n    assertEquals(false, test1.isBefore(test1a));\n    assertEquals(false, test1a.isBefore(test1));\n    assertEquals(false, test1.isBefore(test1));\n    assertEquals(false, test1a.isBefore(test1a));\n    YearMonthDay test2 = new YearMonthDay(2005, 7, 2);\n    assertEquals(true, test1.isBefore(test2));\n    assertEquals(false, test2.isBefore(test1));\n    YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());\n    assertEquals(true, test1.isBefore(test3));\n    assertEquals(false, test3.isBefore(test1));\n    assertEquals(false, test3.isBefore(test2));\n    try {\n        new YearMonthDay(2005, 7, 2).isBefore(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1676, "method_signature": "void testIsBefore_YMD()"}, "TestYearMonthDay_Basics.testIsEqual_YMD": {"callee_method_names": ["YearMonthDay.isEqual", "YearMonthDay.isEqual", "YearMonthDay.isEqual", "YearMonthDay.isEqual", "YearMonthDay.isEqual", "YearMonthDay.isEqual", "YearMonthDay.isEqual", "YearMonthDay.isEqual", "YearMonthDay.isEqual"], "method_name": "TestYearMonthDay_Basics.testIsEqual_YMD", "method_implementation": "{\n    YearMonthDay test1 = new YearMonthDay(2005, 6, 2);\n    YearMonthDay test1a = new YearMonthDay(2005, 6, 2);\n    assertEquals(true, test1.isEqual(test1a));\n    assertEquals(true, test1a.isEqual(test1));\n    assertEquals(true, test1.isEqual(test1));\n    assertEquals(true, test1a.isEqual(test1a));\n    YearMonthDay test2 = new YearMonthDay(2005, 7, 2);\n    assertEquals(false, test1.isEqual(test2));\n    assertEquals(false, test2.isEqual(test1));\n    YearMonthDay test3 = new YearMonthDay(2005, 7, 2, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isEqual(test3));\n    assertEquals(false, test3.isEqual(test1));\n    assertEquals(true, test3.isEqual(test2));\n    try {\n        new YearMonthDay(2005, 7, 2).isEqual(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1675, "method_signature": "void testIsEqual_YMD()"}, "TestYearMonthDay_Basics.testMinus_RP": {"callee_method_names": ["YearMonthDay.minus", "YearMonthDay.minus"], "method_name": "TestYearMonthDay_Basics.testMinus_RP", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());\n    YearMonthDay result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n    YearMonthDay expected = new YearMonthDay(2001, 4, 2, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n    result = test.minus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1682, "method_signature": "void testMinus_RP()"}, "TestYearMonthDay_Basics.testPlus_RP": {"callee_method_names": ["YearMonthDay.plus", "YearMonthDay.plus"], "method_name": "TestYearMonthDay_Basics.testPlus_RP", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(2002, 5, 3, BuddhistChronology.getInstance());\n    YearMonthDay result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n    YearMonthDay expected = new YearMonthDay(2003, 7, 7, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n    result = test.plus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1681, "method_signature": "void testPlus_RP()"}, "TestYearMonthDay_Basics.testProperty": {"callee_method_names": ["YearMonthDay.year", "YearMonthDay.property", "YearMonthDay.monthOfYear", "YearMonthDay.property", "YearMonthDay.dayOfMonth", "YearMonthDay.property", "YearMonthDay.property", "YearMonthDay.property"], "method_name": "TestYearMonthDay_Basics.testProperty", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(2005, 6, 9);\n    assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n    assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));\n    assertEquals(test.dayOfMonth(), test.property(DateTimeFieldType.dayOfMonth()));\n    try {\n        test.property(DateTimeFieldType.millisOfDay());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1696, "method_signature": "void testProperty()"}, "TestYearMonthDay_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close", "YearMonthDay.getValues", "YearMonthDay.getValues", "YearMonthDay.getFields", "YearMonthDay.getFields", "YearMonthDay.getChronology", "YearMonthDay.getChronology"], "method_name": "TestYearMonthDay_Basics.testSerialization", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(1972, 6, 9, COPTIC_PARIS);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    YearMonthDay result = (YearMonthDay) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n    assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n    assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n    assertEquals(test.getChronology(), result.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1697, "method_signature": "void testSerialization()"}, "TestYearMonthDay_Basics.testToDateMidnight": {"callee_method_names": ["YearMonthDay.toDateMidnight"], "method_name": "TestYearMonthDay_Basics.testToDateMidnight", "method_implementation": "{\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    DateMidnight test = base.toDateMidnight();\n    check(base, 2005, 6, 9);\n    assertEquals(new DateMidnight(2005, 6, 9, COPTIC_LONDON), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1690, "method_signature": "void testToDateMidnight()"}, "TestYearMonthDay_Basics.testToDateMidnight_Zone": {"callee_method_names": ["YearMonthDay.toDateMidnight"], "method_name": "TestYearMonthDay_Basics.testToDateMidnight_Zone", "method_implementation": "{\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    DateMidnight test = base.toDateMidnight(TOKYO);\n    check(base, 2005, 6, 9);\n    assertEquals(new DateMidnight(2005, 6, 9, COPTIC_TOKYO), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1691, "method_signature": "void testToDateMidnight_Zone()"}, "TestYearMonthDay_Basics.testToDateTimeAtCurrentTime": {"callee_method_ids": [196], "callee_method_names": ["DateTime.getMillis", "YearMonthDay.toDateTimeAtCurrentTime", "DateTime.getMillis", "DateTime.year", "DateTime.monthOfYear", "DateTime.dayOfMonth"], "method_name": "TestYearMonthDay_Basics.testToDateTimeAtCurrentTime", "method_implementation": "{\n    // PARIS irrelevant\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    DateTime test = base.toDateTimeAtCurrentTime();\n    check(base, 2005, 6, 9);\n    DateTime expected = new DateTime(dt.getMillis(), COPTIC_LONDON);\n    expected = expected.year().setCopy(2005);\n    expected = expected.monthOfYear().setCopy(6);\n    expected = expected.dayOfMonth().setCopy(9);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1686, "method_signature": "void testToDateTimeAtCurrentTime()"}, "TestYearMonthDay_Basics.testToDateTimeAtCurrentTime_Zone": {"callee_method_ids": [196], "callee_method_names": ["DateTime.getMillis", "YearMonthDay.toDateTimeAtCurrentTime", "DateTime.getMillis", "DateTime.year", "DateTime.monthOfYear", "DateTime.dayOfMonth"], "method_name": "TestYearMonthDay_Basics.testToDateTimeAtCurrentTime_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    DateTime dt = new DateTime(2004, 6, 9, 6, 7, 8, 9);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    DateTime test = base.toDateTimeAtCurrentTime(TOKYO);\n    check(base, 2005, 6, 9);\n    DateTime expected = new DateTime(dt.getMillis(), COPTIC_TOKYO);\n    expected = expected.year().setCopy(2005);\n    expected = expected.monthOfYear().setCopy(6);\n    expected = expected.dayOfMonth().setCopy(9);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1687, "method_signature": "void testToDateTimeAtCurrentTime_Zone()"}, "TestYearMonthDay_Basics.testToDateTimeAtMidnight": {"callee_method_names": ["YearMonthDay.toDateTimeAtMidnight"], "method_name": "TestYearMonthDay_Basics.testToDateTimeAtMidnight", "method_implementation": "{\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    DateTime test = base.toDateTimeAtMidnight();\n    check(base, 2005, 6, 9);\n    assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_LONDON), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1684, "method_signature": "void testToDateTimeAtMidnight()"}, "TestYearMonthDay_Basics.testToDateTimeAtMidnight_Zone": {"callee_method_names": ["YearMonthDay.toDateTimeAtMidnight"], "method_name": "TestYearMonthDay_Basics.testToDateTimeAtMidnight_Zone", "method_implementation": "{\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    DateTime test = base.toDateTimeAtMidnight(TOKYO);\n    check(base, 2005, 6, 9);\n    assertEquals(new DateTime(2005, 6, 9, 0, 0, 0, 0, COPTIC_TOKYO), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1685, "method_signature": "void testToDateTimeAtMidnight_Zone()"}, "TestYearMonthDay_Basics.testToDateTime_RI": {"callee_method_ids": [197], "callee_method_names": ["YearMonthDay.toDateTime", "DateTime.year", "DateTime.monthOfYear", "DateTime.dayOfMonth"], "method_name": "TestYearMonthDay_Basics.testToDateTime_RI", "method_implementation": "{\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n    DateTime test = base.toDateTime(dt);\n    check(base, 2005, 6, 9);\n    DateTime expected = dt;\n    expected = expected.year().setCopy(2005);\n    expected = expected.monthOfYear().setCopy(6);\n    expected = expected.dayOfMonth().setCopy(9);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1692, "method_signature": "void testToDateTime_RI()"}, "TestYearMonthDay_Basics.testToDateTime_TOD": {"callee_method_ids": [197], "callee_method_names": ["YearMonthDay.toDateTime"], "method_name": "TestYearMonthDay_Basics.testToDateTime_TOD", "method_implementation": "{\n    // PARIS irrelevant\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO);\n    DateTime test = base.toDateTime(tod);\n    check(base, 2005, 6, 9);\n    DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_LONDON);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1688, "method_signature": "void testToDateTime_TOD()"}, "TestYearMonthDay_Basics.testToDateTime_TOD_Zone": {"callee_method_ids": [197], "callee_method_names": ["YearMonthDay.toDateTime"], "method_name": "TestYearMonthDay_Basics.testToDateTime_TOD_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    TimeOfDay tod = new TimeOfDay(12, 13, 14, 15, BUDDHIST_TOKYO);\n    DateTime test = base.toDateTime(tod, TOKYO);\n    check(base, 2005, 6, 9);\n    DateTime expected = new DateTime(2005, 6, 9, 12, 13, 14, 15, COPTIC_TOKYO);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1689, "method_signature": "void testToDateTime_TOD_Zone()"}, "TestYearMonthDay_Basics.testToInterval": {"callee_method_ids": [197], "callee_method_names": ["YearMonthDay.toInterval", "YearMonthDay.toDateTime", "DateTime.plus"], "method_name": "TestYearMonthDay_Basics.testToInterval", "method_implementation": "{\n    // PARIS irrelevant\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    Interval test = base.toInterval();\n    check(base, 2005, 6, 9);\n    DateTime start = base.toDateTime(TimeOfDay.MIDNIGHT);\n    DateTime end = start.plus(Period.days(1));\n    Interval expected = new Interval(start, end);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1693, "method_signature": "void testToInterval()"}, "TestYearMonthDay_Basics.testToInterval_Zone": {"callee_method_ids": [197], "callee_method_names": ["YearMonthDay.toInterval", "YearMonthDay.toDateTime", "DateTime.plus"], "method_name": "TestYearMonthDay_Basics.testToInterval_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    Interval test = base.toInterval(TOKYO);\n    check(base, 2005, 6, 9);\n    DateTime start = base.toDateTime(TimeOfDay.MIDNIGHT, TOKYO);\n    DateTime end = start.plus(Period.days(1));\n    Interval expected = new Interval(start, end);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1694, "method_signature": "void testToInterval_Zone()"}, "TestYearMonthDay_Basics.testToLocalDate": {"callee_method_names": ["YearMonthDay.toLocalDate"], "method_name": "TestYearMonthDay_Basics.testToLocalDate", "method_implementation": "{\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_UTC);\n    LocalDate test = base.toLocalDate();\n    assertEquals(new LocalDate(2005, 6, 9, COPTIC_UTC), test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1683, "method_signature": "void testToLocalDate()"}, "TestYearMonthDay_Basics.testToString_DTFormatter": {"callee_method_names": ["YearMonthDay.toString", "YearMonthDay.toString"], "method_name": "TestYearMonthDay_Basics.testToString_DTFormatter", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(2002, 6, 9);\n    assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n    assertEquals(\"2002-06-09\", test.toString((DateTimeFormatter) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1700, "method_signature": "void testToString_DTFormatter()"}, "TestYearMonthDay_Basics.testToString_String": {"callee_method_names": ["YearMonthDay.toString", "YearMonthDay.toString"], "method_name": "TestYearMonthDay_Basics.testToString_String", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(2002, 6, 9);\n    assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(\"yyyy HH\"));\n    assertEquals(\"2002-06-09\", test.toString((String) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1698, "method_signature": "void testToString_String()"}, "TestYearMonthDay_Basics.testToString_String_Locale": {"callee_method_names": ["YearMonthDay.toString", "YearMonthDay.toString", "YearMonthDay.toString", "YearMonthDay.toString", "YearMonthDay.toString"], "method_name": "TestYearMonthDay_Basics.testToString_String_Locale", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(2002, 6, 9);\n    assertEquals(\"\\ufffd 9/6\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n    assertEquals(\"\\ufffd 9/6\", test.toString(\"EEE d/M\", Locale.FRENCH));\n    assertEquals(\"2002-06-09\", test.toString(null, Locale.ENGLISH));\n    assertEquals(\"\\ufffd 9/6\", test.toString(\"EEE d/M\", null));\n    assertEquals(\"2002-06-09\", test.toString(null, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1699, "method_signature": "void testToString_String_Locale()"}, "TestYearMonthDay_Basics.testWithChronologyRetainFields_Chrono": {"callee_method_ids": [192], "callee_method_names": ["YearMonthDay.withChronologyRetainFields", "YearMonthDay.getChronology", "YearMonthDay.getChronology"], "method_name": "TestYearMonthDay_Basics.testWithChronologyRetainFields_Chrono", "method_implementation": "{\n    YearMonthDay base = new YearMonthDay(2005, 6, 9, COPTIC_PARIS);\n    YearMonthDay test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n    check(base, 2005, 6, 9);\n    assertEquals(COPTIC_UTC, base.getChronology());\n    check(test, 2005, 6, 9);\n    assertEquals(BUDDHIST_UTC, test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1678, "method_signature": "void testWithChronologyRetainFields_Chrono()"}, "TestYearMonthDay_Basics.testWithField1": {"callee_method_ids": [193], "callee_method_names": ["YearMonthDay.withField"], "method_name": "TestYearMonthDay_Basics.testWithField1", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(2004, 6, 9);\n    YearMonthDay result = test.withField(DateTimeFieldType.year(), 2006);\n    assertEquals(new YearMonthDay(2004, 6, 9), test);\n    assertEquals(new YearMonthDay(2006, 6, 9), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1679, "method_signature": "void testWithField1()"}, "TestYearMonthDay_Basics.testWithFieldAdded1": {"callee_method_ids": [194], "callee_method_names": ["YearMonthDay.withFieldAdded"], "method_name": "TestYearMonthDay_Basics.testWithFieldAdded1", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(2004, 6, 9);\n    YearMonthDay result = test.withFieldAdded(DurationFieldType.years(), 6);\n    assertEquals(new YearMonthDay(2004, 6, 9), test);\n    assertEquals(new YearMonthDay(2010, 6, 9), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1680, "method_signature": "void testWithFieldAdded1()"}, "TestYearMonthDay_Basics.testWithers": {"callee_method_ids": [198, 199, 200, 199, 199], "callee_method_names": ["YearMonthDay.withYear", "YearMonthDay.withMonthOfYear", "YearMonthDay.withDayOfMonth", "YearMonthDay.withMonthOfYear", "YearMonthDay.withMonthOfYear"], "method_name": "TestYearMonthDay_Basics.testWithers", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(1970, 6, 9);\n    check(test.withYear(2000), 2000, 6, 9);\n    check(test.withMonthOfYear(2), 1970, 2, 9);\n    check(test.withDayOfMonth(2), 1970, 6, 2);\n    try {\n        test.withMonthOfYear(0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.withMonthOfYear(13);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1695, "method_signature": "void testWithers()"}, "TestYearMonthDay_Constructors.testConstructor": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay();\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1235, "method_signature": "void testConstructor()"}, "TestYearMonthDay_Constructors.testConstructor_Chronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_Chronology", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1238, "method_signature": "void testConstructor_Chronology()"}, "TestYearMonthDay_Constructors.testConstructor_DateTimeZone": {"callee_method_names": ["DateTime.getMillis", "YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth", "YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_DateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    YearMonthDay test = new YearMonthDay(LONDON);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(8, test.getDayOfMonth());\n    test = new YearMonthDay(PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1236, "method_signature": "void testConstructor_DateTimeZone()"}, "TestYearMonthDay_Constructors.testConstructor_Object": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_Object", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    YearMonthDay test = new YearMonthDay(date);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1245, "method_signature": "void testConstructor_Object()"}, "TestYearMonthDay_Constructors.testConstructor_Object_Chronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_Object_Chronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    YearMonthDay test = new YearMonthDay(date, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1246, "method_signature": "void testConstructor_Object_Chronology()"}, "TestYearMonthDay_Constructors.testConstructor_Object_nullChronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_Object_nullChronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    YearMonthDay test = new YearMonthDay(date, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1248, "method_signature": "void testConstructor_Object_nullChronology()"}, "TestYearMonthDay_Constructors.testConstructor_int_int_int": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_int_int_int", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(1970, 6, 9);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    try {\n        new YearMonthDay(Integer.MIN_VALUE, 6, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(Integer.MAX_VALUE, 6, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(1970, 0, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(1970, 13, 9);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(1970, 6, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(1970, 6, 31);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new YearMonthDay(1970, 7, 31);\n    try {\n        new YearMonthDay(1970, 7, 32);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int)\n */\n", "repo_name": "joda-time-main/", "id": 1250, "method_signature": "void testConstructor_int_int_int()"}, "TestYearMonthDay_Constructors.testConstructor_int_int_int_Chronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_int_int_int_Chronology", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(1970, 6, 9, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n    try {\n        new YearMonthDay(Integer.MIN_VALUE, 6, 9, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(Integer.MAX_VALUE, 6, 9, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(1970, 0, 9, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(1970, 13, 9, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(1970, 6, 0, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonthDay(1970, 6, 31, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    new YearMonthDay(1970, 7, 31, GREGORIAN_PARIS);\n    try {\n        new YearMonthDay(1970, 7, 32, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1251, "method_signature": "void testConstructor_int_int_int_Chronology()"}, "TestYearMonthDay_Constructors.testConstructor_int_int_int_nullChronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_int_int_int_nullChronology", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(1970, 6, 9, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1252, "method_signature": "void testConstructor_int_int_int_nullChronology()"}, "TestYearMonthDay_Constructors.testConstructor_long1": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_long1", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(TEST_TIME1);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1240, "method_signature": "void testConstructor_long1()"}, "TestYearMonthDay_Constructors.testConstructor_long1_Chronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_long1_Chronology", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(TEST_TIME1, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1242, "method_signature": "void testConstructor_long1_Chronology()"}, "TestYearMonthDay_Constructors.testConstructor_long2": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_long2", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(TEST_TIME2);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1971, test.getYear());\n    assertEquals(5, test.getMonthOfYear());\n    assertEquals(7, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 1241, "method_signature": "void testConstructor_long2()"}, "TestYearMonthDay_Constructors.testConstructor_long2_Chronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_long2_Chronology", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(TEST_TIME2, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1971, test.getYear());\n    assertEquals(5, test.getMonthOfYear());\n    assertEquals(7, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1243, "method_signature": "void testConstructor_long2_Chronology()"}, "TestYearMonthDay_Constructors.testConstructor_long_nullChronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_long_nullChronology", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(TEST_TIME1, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n    assertEquals(6, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1244, "method_signature": "void testConstructor_long_nullChronology()"}, "TestYearMonthDay_Constructors.testConstructor_nullChronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_nullChronology", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay((Chronology) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1239, "method_signature": "void testConstructor_nullChronology()"}, "TestYearMonthDay_Constructors.testConstructor_nullDateTimeZone": {"callee_method_names": ["DateTime.getMillis", "YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_nullDateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 8, 23, 59, 0, 0, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    YearMonthDay test = new YearMonthDay((DateTimeZone) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(8, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1237, "method_signature": "void testConstructor_nullDateTimeZone()"}, "TestYearMonthDay_Constructors.testConstructor_nullObject_Chronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_nullObject_Chronology", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay((Object) null, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1247, "method_signature": "void testConstructor_nullObject_Chronology()"}, "TestYearMonthDay_Constructors.testConstructor_nullObject_nullChronology": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Constructors.testConstructor_nullObject_nullChronology", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay((Object) null, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(9, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 1249, "method_signature": "void testConstructor_nullObject_nullChronology()"}, "TestYearMonthDay_Constructors.testFactory_FromCalendarFields": {"callee_method_names": ["GregorianCalendar.set"], "method_name": "TestYearMonthDay_Constructors.testFactory_FromCalendarFields", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    YearMonthDay expected = new YearMonthDay(1970, 2, 3);\n    assertEquals(expected, YearMonthDay.fromCalendarFields(cal));\n    try {\n        YearMonthDay.fromCalendarFields(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1233, "method_signature": "void testFactory_FromCalendarFields()"}, "TestYearMonthDay_Constructors.testFactory_FromDateFields": {"callee_method_names": ["GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestYearMonthDay_Constructors.testFactory_FromDateFields", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    YearMonthDay expected = new YearMonthDay(1970, 2, 3);\n    assertEquals(expected, YearMonthDay.fromDateFields(cal.getTime()));\n    try {\n        YearMonthDay.fromDateFields(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1234, "method_signature": "void testFactory_FromDateFields()"}, "TestYearMonthDay_Properties.check": {"callee_method_names": ["YearMonthDay.getYear", "YearMonthDay.getMonthOfYear", "YearMonthDay.getDayOfMonth"], "method_name": "TestYearMonthDay_Properties.check", "method_implementation": "{\n    assertEquals(year, test.getYear());\n    assertEquals(month, test.getMonthOfYear());\n    assertEquals(day, test.getDayOfMonth());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2615, "method_signature": "void check(YearMonthDay, int, int, int)"}, "TestYearMonthDay_Properties.testPropertyGetDay": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.getChronology", "YearMonthDay.dayOfMonth", "YearMonthDay.getChronology", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth", "YearMonthDay.dayOfMonth"], "method_name": "TestYearMonthDay_Properties.testPropertyGetDay", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(1972, 6, 9);\n    assertSame(test.getChronology().dayOfMonth(), test.dayOfMonth().getField());\n    assertEquals(\"dayOfMonth\", test.dayOfMonth().getName());\n    assertEquals(\"Property[dayOfMonth]\", test.dayOfMonth().toString());\n    assertSame(test, test.dayOfMonth().getReadablePartial());\n    assertSame(test, test.dayOfMonth().getYearMonthDay());\n    assertEquals(9, test.dayOfMonth().get());\n    assertEquals(\"9\", test.dayOfMonth().getAsString());\n    assertEquals(\"9\", test.dayOfMonth().getAsText());\n    assertEquals(\"9\", test.dayOfMonth().getAsText(Locale.FRENCH));\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText());\n    assertEquals(\"9\", test.dayOfMonth().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().days(), test.dayOfMonth().getDurationField());\n    assertEquals(test.getChronology().months(), test.dayOfMonth().getRangeDurationField());\n    assertEquals(2, test.dayOfMonth().getMaximumTextLength(null));\n    assertEquals(2, test.dayOfMonth().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2614, "method_signature": "void testPropertyGetDay()"}, "TestYearMonthDay_Properties.testPropertyGetMonth": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.getChronology", "YearMonthDay.monthOfYear", "YearMonthDay.getChronology", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear", "YearMonthDay.monthOfYear"], "method_name": "TestYearMonthDay_Properties.testPropertyGetMonth", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(1972, 6, 9);\n    assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n    assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n    assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n    assertSame(test, test.monthOfYear().getReadablePartial());\n    assertSame(test, test.monthOfYear().getYearMonthDay());\n    assertEquals(6, test.monthOfYear().get());\n    assertEquals(\"6\", test.monthOfYear().getAsString());\n    assertEquals(\"June\", test.monthOfYear().getAsText());\n    assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n    assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n    assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n    assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));\n    test = new YearMonthDay(1972, 7, 9);\n    assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2613, "method_signature": "void testPropertyGetMonth()"}, "TestYearMonthDay_Properties.testPropertyGetYear": {"callee_method_names": ["YearMonthDay.getChronology", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.getChronology", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year", "YearMonthDay.year"], "method_name": "TestYearMonthDay_Properties.testPropertyGetYear", "method_implementation": "{\n    YearMonthDay test = new YearMonthDay(1972, 6, 9);\n    assertSame(test.getChronology().year(), test.year().getField());\n    assertEquals(\"year\", test.year().getName());\n    assertEquals(\"Property[year]\", test.year().toString());\n    assertSame(test, test.year().getReadablePartial());\n    assertSame(test, test.year().getYearMonthDay());\n    assertEquals(1972, test.year().get());\n    assertEquals(\"1972\", test.year().getAsString());\n    assertEquals(\"1972\", test.year().getAsText());\n    assertEquals(\"1972\", test.year().getAsText(Locale.FRENCH));\n    assertEquals(\"1972\", test.year().getAsShortText());\n    assertEquals(\"1972\", test.year().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.year().getDurationField());\n    assertEquals(null, test.year().getRangeDurationField());\n    assertEquals(9, test.year().getMaximumTextLength(null));\n    assertEquals(9, test.year().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2612, "method_signature": "void testPropertyGetYear()"}, "TestYearMonth_Basics.testCompareTo": {"callee_method_names": ["YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo", "YearMonth.compareTo"], "method_name": "TestYearMonth_Basics.testCompareTo", "method_implementation": "{\n    YearMonth test1 = new YearMonth(2005, 6);\n    YearMonth test1a = new YearMonth(2005, 6);\n    assertEquals(0, test1.compareTo(test1a));\n    assertEquals(0, test1a.compareTo(test1));\n    assertEquals(0, test1.compareTo(test1));\n    assertEquals(0, test1a.compareTo(test1a));\n    YearMonth test2 = new YearMonth(2005, 7);\n    assertEquals(-1, test1.compareTo(test2));\n    assertEquals(+1, test2.compareTo(test1));\n    YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC());\n    assertEquals(-1, test1.compareTo(test3));\n    assertEquals(+1, test3.compareTo(test1));\n    assertEquals(0, test3.compareTo(test2));\n    DateTimeFieldType[] types = new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n    int[] values = new int[] { 2005, 6 };\n    Partial p = new Partial(types, values);\n    assertEquals(0, test1.compareTo(p));\n    try {\n        test1.compareTo(null);\n        fail();\n    } catch (NullPointerException ex) {\n    }\n    try {\n        test1.compareTo(new LocalTime());\n        fail();\n    } catch (ClassCastException ex) {\n    }\n    Partial partial = new Partial().with(DateTimeFieldType.centuryOfEra(), 1).with(DateTimeFieldType.halfdayOfDay(), 0).with(DateTimeFieldType.dayOfMonth(), 9);\n    try {\n        new YearMonth(1970, 6).compareTo(partial);\n        fail();\n    } catch (ClassCastException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2593, "method_signature": "void testCompareTo()"}, "TestYearMonth_Basics.testGet": {"callee_method_names": ["YearMonth.get", "YearMonth.get", "YearMonth.get", "YearMonth.get"], "method_name": "TestYearMonth_Basics.testGet", "method_implementation": "{\n    YearMonth test = new YearMonth();\n    assertEquals(1970, test.get(DateTimeFieldType.year()));\n    assertEquals(6, test.get(DateTimeFieldType.monthOfYear()));\n    try {\n        test.get(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.get(DateTimeFieldType.dayOfMonth());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2592, "method_signature": "void testGet()"}, "TestYearMonth_Basics.testIsAfter_YM": {"callee_method_names": ["YearMonth.isAfter", "YearMonth.isAfter", "YearMonth.isAfter", "YearMonth.isAfter", "YearMonth.isAfter", "YearMonth.isAfter", "YearMonth.isAfter", "YearMonth.isAfter", "YearMonth.isAfter"], "method_name": "TestYearMonth_Basics.testIsAfter_YM", "method_implementation": "{\n    YearMonth test1 = new YearMonth(2005, 6);\n    YearMonth test1a = new YearMonth(2005, 6);\n    assertEquals(false, test1.isAfter(test1a));\n    assertEquals(false, test1a.isAfter(test1));\n    assertEquals(false, test1.isAfter(test1));\n    assertEquals(false, test1a.isAfter(test1a));\n    YearMonth test2 = new YearMonth(2005, 7);\n    assertEquals(false, test1.isAfter(test2));\n    assertEquals(true, test2.isAfter(test1));\n    YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isAfter(test3));\n    assertEquals(true, test3.isAfter(test1));\n    assertEquals(false, test3.isAfter(test2));\n    try {\n        new YearMonth(2005, 7).isAfter(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2596, "method_signature": "void testIsAfter_YM()"}, "TestYearMonth_Basics.testIsBefore_YM": {"callee_method_names": ["YearMonth.isBefore", "YearMonth.isBefore", "YearMonth.isBefore", "YearMonth.isBefore", "YearMonth.isBefore", "YearMonth.isBefore", "YearMonth.isBefore", "YearMonth.isBefore", "YearMonth.isBefore"], "method_name": "TestYearMonth_Basics.testIsBefore_YM", "method_implementation": "{\n    YearMonth test1 = new YearMonth(2005, 6);\n    YearMonth test1a = new YearMonth(2005, 6);\n    assertEquals(false, test1.isBefore(test1a));\n    assertEquals(false, test1a.isBefore(test1));\n    assertEquals(false, test1.isBefore(test1));\n    assertEquals(false, test1a.isBefore(test1a));\n    YearMonth test2 = new YearMonth(2005, 7);\n    assertEquals(true, test1.isBefore(test2));\n    assertEquals(false, test2.isBefore(test1));\n    YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC());\n    assertEquals(true, test1.isBefore(test3));\n    assertEquals(false, test3.isBefore(test1));\n    assertEquals(false, test3.isBefore(test2));\n    try {\n        new YearMonth(2005, 7).isBefore(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2595, "method_signature": "void testIsBefore_YM()"}, "TestYearMonth_Basics.testIsEqual_YM": {"callee_method_names": ["YearMonth.isEqual", "YearMonth.isEqual", "YearMonth.isEqual", "YearMonth.isEqual", "YearMonth.isEqual", "YearMonth.isEqual", "YearMonth.isEqual", "YearMonth.isEqual", "YearMonth.isEqual"], "method_name": "TestYearMonth_Basics.testIsEqual_YM", "method_implementation": "{\n    YearMonth test1 = new YearMonth(2005, 6);\n    YearMonth test1a = new YearMonth(2005, 6);\n    assertEquals(true, test1.isEqual(test1a));\n    assertEquals(true, test1a.isEqual(test1));\n    assertEquals(true, test1.isEqual(test1));\n    assertEquals(true, test1a.isEqual(test1a));\n    YearMonth test2 = new YearMonth(2005, 7);\n    assertEquals(false, test1.isEqual(test2));\n    assertEquals(false, test2.isEqual(test1));\n    YearMonth test3 = new YearMonth(2005, 7, GregorianChronology.getInstanceUTC());\n    assertEquals(false, test1.isEqual(test3));\n    assertEquals(false, test3.isEqual(test1));\n    assertEquals(true, test3.isEqual(test2));\n    try {\n        new YearMonth(2005, 7).isEqual(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2594, "method_signature": "void testIsEqual_YM()"}, "TestYearMonth_Basics.testMinus_RP": {"callee_method_names": ["YearMonth.minus", "YearMonth.minus"], "method_name": "TestYearMonth_Basics.testMinus_RP", "method_implementation": "{\n    YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance());\n    YearMonth result = test.minus(new Period(1, 1, 1, 1, 1, 1, 1, 1));\n    YearMonth expected = new YearMonth(2001, 4, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n    result = test.minus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2601, "method_signature": "void testMinus_RP()"}, "TestYearMonth_Basics.testPlus_RP": {"callee_method_names": ["YearMonth.plus", "YearMonth.plus"], "method_name": "TestYearMonth_Basics.testPlus_RP", "method_implementation": "{\n    YearMonth test = new YearMonth(2002, 5, BuddhistChronology.getInstance());\n    YearMonth result = test.plus(new Period(1, 2, 3, 4, 5, 6, 7, 8));\n    YearMonth expected = new YearMonth(2003, 7, BuddhistChronology.getInstance());\n    assertEquals(expected, result);\n    result = test.plus((ReadablePeriod) null);\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2600, "method_signature": "void testPlus_RP()"}, "TestYearMonth_Basics.testProperty": {"callee_method_names": ["YearMonth.year", "YearMonth.property", "YearMonth.monthOfYear", "YearMonth.property", "YearMonth.property", "YearMonth.property"], "method_name": "TestYearMonth_Basics.testProperty", "method_implementation": "{\n    YearMonth test = new YearMonth(2005, 6);\n    assertEquals(test.year(), test.property(DateTimeFieldType.year()));\n    assertEquals(test.monthOfYear(), test.property(DateTimeFieldType.monthOfYear()));\n    try {\n        test.property(DateTimeFieldType.millisOfDay());\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.property(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2607, "method_signature": "void testProperty()"}, "TestYearMonth_Basics.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close", "YearMonth.getValues", "YearMonth.getValues", "YearMonth.getFields", "YearMonth.getFields", "YearMonth.getChronology", "YearMonth.getChronology"], "method_name": "TestYearMonth_Basics.testSerialization", "method_implementation": "{\n    YearMonth test = new YearMonth(1972, 6, COPTIC_PARIS);\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    YearMonth result = (YearMonth) ois.readObject();\n    ois.close();\n    assertEquals(test, result);\n    assertTrue(Arrays.equals(test.getValues(), result.getValues()));\n    assertTrue(Arrays.equals(test.getFields(), result.getFields()));\n    assertEquals(test.getChronology(), result.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2608, "method_signature": "void testSerialization()"}, "TestYearMonth_Basics.testToDateTime_RI": {"callee_method_names": ["YearMonth.toDateTime", "DateTime.year", "DateTime.monthOfYear"], "method_name": "TestYearMonth_Basics.testToDateTime_RI", "method_implementation": "{\n    YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS);\n    DateTime dt = new DateTime(2002, 1, 3, 4, 5, 6, 7);\n    DateTime test = base.toDateTime(dt);\n    check(base, 2005, 6);\n    DateTime expected = dt;\n    expected = expected.year().setCopy(2005);\n    expected = expected.monthOfYear().setCopy(6);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2603, "method_signature": "void testToDateTime_RI()"}, "TestYearMonth_Basics.testToInterval": {"callee_method_ids": [411], "callee_method_names": ["YearMonth.toInterval"], "method_name": "TestYearMonth_Basics.testToInterval", "method_implementation": "{\n    // PARIS irrelevant\n    YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS);\n    Interval test = base.toInterval();\n    check(base, 2005, 6);\n    DateTime start = new DateTime(2005, 6, 1, 0, 0, COPTIC_LONDON);\n    DateTime end = new DateTime(2005, 7, 1, 0, 0, COPTIC_LONDON);\n    Interval expected = new Interval(start, end);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2604, "method_signature": "void testToInterval()"}, "TestYearMonth_Basics.testToInterval_Zone": {"callee_method_ids": [411], "callee_method_names": ["YearMonth.toInterval"], "method_name": "TestYearMonth_Basics.testToInterval_Zone", "method_implementation": "{\n    // PARIS irrelevant\n    YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS);\n    Interval test = base.toInterval(TOKYO);\n    check(base, 2005, 6);\n    DateTime start = new DateTime(2005, 6, 1, 0, 0, COPTIC_TOKYO);\n    DateTime end = new DateTime(2005, 7, 1, 0, 0, COPTIC_TOKYO);\n    Interval expected = new Interval(start, end);\n    assertEquals(expected, test);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2605, "method_signature": "void testToInterval_Zone()"}, "TestYearMonth_Basics.testToLocalDate": {"callee_method_names": ["YearMonth.toLocalDate", "YearMonth.toLocalDate"], "method_name": "TestYearMonth_Basics.testToLocalDate", "method_implementation": "{\n    YearMonth base = new YearMonth(2005, 6, COPTIC_UTC);\n    LocalDate test = base.toLocalDate(9);\n    assertEquals(new LocalDate(2005, 6, 9, COPTIC_UTC), test);\n    try {\n        base.toLocalDate(0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2602, "method_signature": "void testToLocalDate()"}, "TestYearMonth_Basics.testToString_DTFormatter": {"callee_method_ids": [416, 416], "callee_method_names": ["YearMonth.toString", "YearMonth.toString"], "method_name": "TestYearMonth_Basics.testToString_DTFormatter", "method_implementation": "{\n    YearMonth test = new YearMonth(2002, 6);\n    assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(DateTimeFormat.forPattern(\"yyyy HH\")));\n    assertEquals(\"2002-06\", test.toString((DateTimeFormatter) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2611, "method_signature": "void testToString_DTFormatter()"}, "TestYearMonth_Basics.testToString_String": {"callee_method_ids": [416, 416], "callee_method_names": ["YearMonth.toString", "YearMonth.toString"], "method_name": "TestYearMonth_Basics.testToString_String", "method_implementation": "{\n    YearMonth test = new YearMonth(2002, 6);\n    assertEquals(\"2002 \\ufffd\\ufffd\", test.toString(\"yyyy HH\"));\n    assertEquals(\"2002-06\", test.toString((String) null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2609, "method_signature": "void testToString_String()"}, "TestYearMonth_Basics.testToString_String_Locale": {"callee_method_ids": [416, 416, 416, 416, 416], "callee_method_names": ["YearMonth.toString", "YearMonth.toString", "YearMonth.toString", "YearMonth.toString", "YearMonth.toString"], "method_name": "TestYearMonth_Basics.testToString_String_Locale", "method_implementation": "{\n    YearMonth test = new YearMonth(2002, 6);\n    assertEquals(\"\\ufffd \\ufffd/6\", test.toString(\"EEE d/M\", Locale.ENGLISH));\n    assertEquals(\"\\ufffd \\ufffd/6\", test.toString(\"EEE d/M\", Locale.FRENCH));\n    assertEquals(\"2002-06\", test.toString(null, Locale.ENGLISH));\n    assertEquals(\"\\ufffd \\ufffd/6\", test.toString(\"EEE d/M\", null));\n    assertEquals(\"2002-06\", test.toString(null, null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2610, "method_signature": "void testToString_String_Locale()"}, "TestYearMonth_Basics.testWithChronologyRetainFields_Chrono": {"callee_method_ids": [407], "callee_method_names": ["YearMonth.withChronologyRetainFields", "YearMonth.getChronology", "YearMonth.getChronology"], "method_name": "TestYearMonth_Basics.testWithChronologyRetainFields_Chrono", "method_implementation": "{\n    YearMonth base = new YearMonth(2005, 6, COPTIC_PARIS);\n    YearMonth test = base.withChronologyRetainFields(BUDDHIST_TOKYO);\n    check(base, 2005, 6);\n    assertEquals(COPTIC_UTC, base.getChronology());\n    check(test, 2005, 6);\n    assertEquals(BUDDHIST_UTC, test.getChronology());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2597, "method_signature": "void testWithChronologyRetainFields_Chrono()"}, "TestYearMonth_Basics.testWithField": {"callee_method_ids": [408], "callee_method_names": ["YearMonth.withField"], "method_name": "TestYearMonth_Basics.testWithField", "method_implementation": "{\n    YearMonth test = new YearMonth(2004, 6);\n    YearMonth result = test.withField(DateTimeFieldType.year(), 2006);\n    assertEquals(new YearMonth(2004, 6), test);\n    assertEquals(new YearMonth(2006, 6), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2598, "method_signature": "void testWithField()"}, "TestYearMonth_Basics.testWithFieldAdded": {"callee_method_ids": [409], "callee_method_names": ["YearMonth.withFieldAdded"], "method_name": "TestYearMonth_Basics.testWithFieldAdded", "method_implementation": "{\n    YearMonth test = new YearMonth(2004, 6);\n    YearMonth result = test.withFieldAdded(DurationFieldType.years(), 6);\n    assertEquals(new YearMonth(2004, 6), test);\n    assertEquals(new YearMonth(2010, 6), result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2599, "method_signature": "void testWithFieldAdded()"}, "TestYearMonth_Basics.testWithers": {"callee_method_ids": [412, 413, 413, 413], "callee_method_names": ["YearMonth.withYear", "YearMonth.withMonthOfYear", "YearMonth.withMonthOfYear", "YearMonth.withMonthOfYear"], "method_name": "TestYearMonth_Basics.testWithers", "method_implementation": "{\n    YearMonth test = new YearMonth(1970, 6);\n    check(test.withYear(2000), 2000, 6);\n    check(test.withMonthOfYear(2), 1970, 2);\n    try {\n        test.withMonthOfYear(0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        test.withMonthOfYear(13);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2606, "method_signature": "void testWithers()"}, "TestYearMonth_Constructors.testConstructor": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor", "method_implementation": "{\n    YearMonth test = new YearMonth();\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(test, YearMonth.now());\n}", "repo_id": "7", "comment": "/**\n * Test constructor ()\n */\n", "repo_name": "joda-time-main/", "id": 1996, "method_signature": "void testConstructor()"}, "TestYearMonth_Constructors.testConstructor_Chronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_Chronology", "method_implementation": "{\n    YearMonth test = new YearMonth(GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(test, YearMonth.now(GREGORIAN_PARIS));\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 1999, "method_signature": "void testConstructor_Chronology()"}, "TestYearMonth_Constructors.testConstructor_DateTimeZone": {"callee_method_names": ["DateTime.getMillis", "YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear", "YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_DateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    YearMonth test = new YearMonth(LONDON);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    assertEquals(test, YearMonth.now(LONDON));\n    test = new YearMonth(PARIS);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(7, test.getMonthOfYear());\n    assertEquals(test, YearMonth.now(PARIS));\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone)\n */\n", "repo_name": "joda-time-main/", "id": 1997, "method_signature": "void testConstructor_DateTimeZone()"}, "TestYearMonth_Constructors.testConstructor_Object": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_Object", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    YearMonth test = new YearMonth(date);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2006, "method_signature": "void testConstructor_Object()"}, "TestYearMonth_Constructors.testConstructor_Object_Chronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_Object_Chronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    YearMonth test = new YearMonth(date, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 2007, "method_signature": "void testConstructor_Object_Chronology()"}, "TestYearMonth_Constructors.testConstructor_Object_nullChronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_Object_nullChronology", "method_implementation": "{\n    Date date = new Date(TEST_TIME1);\n    YearMonth test = new YearMonth(date, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 2009, "method_signature": "void testConstructor_Object_nullChronology()"}, "TestYearMonth_Constructors.testConstructor_int_int": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_int_int", "method_implementation": "{\n    YearMonth test = new YearMonth(1970, 6);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    try {\n        new YearMonth(Integer.MIN_VALUE, 6);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonth(Integer.MAX_VALUE, 6);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonth(1970, 0);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonth(1970, 13);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int)\n */\n", "repo_name": "joda-time-main/", "id": 2011, "method_signature": "void testConstructor_int_int()"}, "TestYearMonth_Constructors.testConstructor_int_int_Chronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_int_int_Chronology", "method_implementation": "{\n    YearMonth test = new YearMonth(1970, 6, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n    try {\n        new YearMonth(Integer.MIN_VALUE, 6, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonth(Integer.MAX_VALUE, 6, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonth(1970, 0, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n    try {\n        new YearMonth(1970, 13, GREGORIAN_PARIS);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 2012, "method_signature": "void testConstructor_int_int_Chronology()"}, "TestYearMonth_Constructors.testConstructor_int_int_nullChronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_int_int_nullChronology", "method_implementation": "{\n    YearMonth test = new YearMonth(1970, 6, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (int, int, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 2013, "method_signature": "void testConstructor_int_int_nullChronology()"}, "TestYearMonth_Constructors.testConstructor_long1": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_long1", "method_implementation": "{\n    YearMonth test = new YearMonth(TEST_TIME1);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 2001, "method_signature": "void testConstructor_long1()"}, "TestYearMonth_Constructors.testConstructor_long1_Chronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_long1_Chronology", "method_implementation": "{\n    YearMonth test = new YearMonth(TEST_TIME1, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 2003, "method_signature": "void testConstructor_long1_Chronology()"}, "TestYearMonth_Constructors.testConstructor_long2": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_long2", "method_implementation": "{\n    YearMonth test = new YearMonth(TEST_TIME2);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1971, test.getYear());\n    assertEquals(5, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long)\n */\n", "repo_name": "joda-time-main/", "id": 2002, "method_signature": "void testConstructor_long2()"}, "TestYearMonth_Constructors.testConstructor_long2_Chronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_long2_Chronology", "method_implementation": "{\n    YearMonth test = new YearMonth(TEST_TIME2, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1971, test.getYear());\n    assertEquals(5, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 2004, "method_signature": "void testConstructor_long2_Chronology()"}, "TestYearMonth_Constructors.testConstructor_long_nullChronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_long_nullChronology", "method_implementation": "{\n    YearMonth test = new YearMonth(TEST_TIME1, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(4, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (long, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 2005, "method_signature": "void testConstructor_long_nullChronology()"}, "TestYearMonth_Constructors.testConstructor_nullChronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_nullChronology", "method_implementation": "{\n    YearMonth test = new YearMonth((Chronology) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 2000, "method_signature": "void testConstructor_nullChronology()"}, "TestYearMonth_Constructors.testConstructor_nullDateTimeZone": {"callee_method_names": ["DateTime.getMillis", "YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_nullDateTimeZone", "method_implementation": "{\n    DateTime dt = new DateTime(2005, 6, 30, 23, 59, 0, 0, LONDON);\n    DateTimeUtils.setCurrentMillisFixed(dt.getMillis());\n    // 23:59 in London is 00:59 the following day in Paris\n    YearMonth test = new YearMonth((DateTimeZone) null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(2005, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (DateTimeZone=null)\n */\n", "repo_name": "joda-time-main/", "id": 1998, "method_signature": "void testConstructor_nullDateTimeZone()"}, "TestYearMonth_Constructors.testConstructor_nullObject_Chronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_nullObject_Chronology", "method_implementation": "{\n    YearMonth test = new YearMonth((Object) null, GREGORIAN_PARIS);\n    assertEquals(GREGORIAN_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology)\n */\n", "repo_name": "joda-time-main/", "id": 2008, "method_signature": "void testConstructor_nullObject_Chronology()"}, "TestYearMonth_Constructors.testConstructor_nullObject_nullChronology": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.getYear", "YearMonth.getMonthOfYear"], "method_name": "TestYearMonth_Constructors.testConstructor_nullObject_nullChronology", "method_implementation": "{\n    YearMonth test = new YearMonth((Object) null, null);\n    assertEquals(ISO_UTC, test.getChronology());\n    assertEquals(1970, test.getYear());\n    assertEquals(6, test.getMonthOfYear());\n}", "repo_id": "7", "comment": "/**\n * Test constructor (Object=null, Chronology=null)\n */\n", "repo_name": "joda-time-main/", "id": 2010, "method_signature": "void testConstructor_nullObject_nullChronology()"}, "TestYearMonth_Constructors.testFactory_FromCalendarFields": {"callee_method_names": ["GregorianCalendar.set"], "method_name": "TestYearMonth_Constructors.testFactory_FromCalendarFields", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    YearMonth expected = new YearMonth(1970, 2);\n    assertEquals(expected, YearMonth.fromCalendarFields(cal));\n    try {\n        YearMonth.fromCalendarFields(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1994, "method_signature": "void testFactory_FromCalendarFields()"}, "TestYearMonth_Constructors.testFactory_FromDateFields": {"callee_method_names": ["GregorianCalendar.set", "GregorianCalendar.getTime"], "method_name": "TestYearMonth_Constructors.testFactory_FromDateFields", "method_implementation": "{\n    GregorianCalendar cal = new GregorianCalendar(1970, 1, 3, 4, 5, 6);\n    cal.set(Calendar.MILLISECOND, 7);\n    YearMonth expected = new YearMonth(1970, 2);\n    assertEquals(expected, YearMonth.fromDateFields(cal.getTime()));\n    try {\n        YearMonth.fromDateFields(null);\n        fail();\n    } catch (IllegalArgumentException ex) {\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1995, "method_signature": "void testFactory_FromDateFields()"}, "TestYearMonth_Properties.testPropertyEquals": {"callee_method_names": ["YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.year", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.year", "YearMonth.year", "YearMonth.monthOfYear", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.monthOfYear", "YearMonth.year", "YearMonth.year", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear"], "method_name": "TestYearMonth_Properties.testPropertyEquals", "method_implementation": "{\n    YearMonth test1 = new YearMonth(11, 11);\n    YearMonth test2 = new YearMonth(11, 12);\n    YearMonth test3 = new YearMonth(11, 11, CopticChronology.getInstanceUTC());\n    assertEquals(true, test1.monthOfYear().equals(test1.monthOfYear()));\n    assertEquals(false, test1.monthOfYear().equals(test1.year()));\n    assertEquals(false, test1.monthOfYear().equals(test2.monthOfYear()));\n    assertEquals(false, test1.monthOfYear().equals(test2.year()));\n    assertEquals(false, test1.year().equals(test1.monthOfYear()));\n    assertEquals(true, test1.year().equals(test1.year()));\n    assertEquals(false, test1.year().equals(test2.monthOfYear()));\n    assertEquals(true, test1.year().equals(test2.year()));\n    assertEquals(false, test1.monthOfYear().equals(null));\n    assertEquals(false, test1.monthOfYear().equals(\"any\"));\n    // chrono\n    assertEquals(false, test1.monthOfYear().equals(test3.monthOfYear()));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2210, "method_signature": "void testPropertyEquals()"}, "TestYearMonth_Properties.testPropertyGetMonth": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.getChronology", "YearMonth.monthOfYear", "YearMonth.getChronology", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear", "YearMonth.monthOfYear"], "method_name": "TestYearMonth_Properties.testPropertyGetMonth", "method_implementation": "{\n    YearMonth test = new YearMonth(1972, 6);\n    assertSame(test.getChronology().monthOfYear(), test.monthOfYear().getField());\n    assertEquals(\"monthOfYear\", test.monthOfYear().getName());\n    assertEquals(\"Property[monthOfYear]\", test.monthOfYear().toString());\n    assertSame(test, test.monthOfYear().getReadablePartial());\n    assertSame(test, test.monthOfYear().getYearMonth());\n    assertEquals(6, test.monthOfYear().get());\n    assertEquals(\"6\", test.monthOfYear().getAsString());\n    assertEquals(\"June\", test.monthOfYear().getAsText());\n    assertEquals(\"juin\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"Jun\", test.monthOfYear().getAsShortText());\n    assertEquals(\"juin\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().months(), test.monthOfYear().getDurationField());\n    assertEquals(test.getChronology().years(), test.monthOfYear().getRangeDurationField());\n    assertEquals(9, test.monthOfYear().getMaximumTextLength(null));\n    assertEquals(3, test.monthOfYear().getMaximumShortTextLength(null));\n    test = new YearMonth(1972, 7);\n    assertEquals(\"juillet\", test.monthOfYear().getAsText(Locale.FRENCH));\n    assertEquals(\"juil.\", test.monthOfYear().getAsShortText(Locale.FRENCH));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2209, "method_signature": "void testPropertyGetMonth()"}, "TestYearMonth_Properties.testPropertyGetYear": {"callee_method_names": ["YearMonth.getChronology", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.getChronology", "YearMonth.year", "YearMonth.year", "YearMonth.year", "YearMonth.year"], "method_name": "TestYearMonth_Properties.testPropertyGetYear", "method_implementation": "{\n    YearMonth test = new YearMonth(1972, 6);\n    assertSame(test.getChronology().year(), test.year().getField());\n    assertEquals(\"year\", test.year().getName());\n    assertEquals(\"Property[year]\", test.year().toString());\n    assertSame(test, test.year().getReadablePartial());\n    assertSame(test, test.year().getYearMonth());\n    assertEquals(1972, test.year().get());\n    assertEquals(\"1972\", test.year().getAsString());\n    assertEquals(\"1972\", test.year().getAsText());\n    assertEquals(\"1972\", test.year().getAsText(Locale.FRENCH));\n    assertEquals(\"1972\", test.year().getAsShortText());\n    assertEquals(\"1972\", test.year().getAsShortText(Locale.FRENCH));\n    assertEquals(test.getChronology().years(), test.year().getDurationField());\n    assertEquals(null, test.year().getRangeDurationField());\n    assertEquals(9, test.year().getMaximumTextLength(null));\n    assertEquals(9, test.year().getMaximumShortTextLength(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2208, "method_signature": "void testPropertyGetYear()"}, "TestYears.testAddToLocalDate": {"callee_method_names": ["LocalDate.plus"], "method_name": "TestYears.testAddToLocalDate", "method_implementation": "{\n    Years test = Years.years(3);\n    LocalDate date = new LocalDate(2006, 6, 1);\n    LocalDate expected = new LocalDate(2009, 6, 1);\n    assertEquals(expected, date.plus(test));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2206, "method_signature": "void testAddToLocalDate()"}, "TestYears.testConstants": {"callee_method_names": [], "method_name": "TestYears.testConstants", "method_implementation": "{\n    assertEquals(0, Years.ZERO.getYears());\n    assertEquals(1, Years.ONE.getYears());\n    assertEquals(2, Years.TWO.getYears());\n    assertEquals(3, Years.THREE.getYears());\n    assertEquals(Integer.MAX_VALUE, Years.MAX_VALUE.getYears());\n    assertEquals(Integer.MIN_VALUE, Years.MIN_VALUE.getYears());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2199, "method_signature": "void testConstants()"}, "TestYears.testFactory_yearsBetween_RInstant": {"callee_method_names": [], "method_name": "TestYears.testFactory_yearsBetween_RInstant", "method_implementation": "{\n    DateTime start = new DateTime(2006, 6, 9, 12, 0, 0, 0, PARIS);\n    DateTime end1 = new DateTime(2009, 6, 9, 12, 0, 0, 0, PARIS);\n    DateTime end2 = new DateTime(2012, 6, 9, 12, 0, 0, 0, PARIS);\n    assertEquals(3, Years.yearsBetween(start, end1).getYears());\n    assertEquals(0, Years.yearsBetween(start, start).getYears());\n    assertEquals(0, Years.yearsBetween(end1, end1).getYears());\n    assertEquals(-3, Years.yearsBetween(end1, start).getYears());\n    assertEquals(6, Years.yearsBetween(start, end2).getYears());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2201, "method_signature": "void testFactory_yearsBetween_RInstant()"}, "TestYears.testFactory_years_int": {"callee_method_names": [], "method_name": "TestYears.testFactory_years_int", "method_implementation": "{\n    assertSame(Years.ZERO, Years.years(0));\n    assertSame(Years.ONE, Years.years(1));\n    assertSame(Years.TWO, Years.years(2));\n    assertSame(Years.THREE, Years.years(3));\n    assertSame(Years.MAX_VALUE, Years.years(Integer.MAX_VALUE));\n    assertSame(Years.MIN_VALUE, Years.years(Integer.MIN_VALUE));\n    assertEquals(-1, Years.years(-1).getYears());\n    assertEquals(4, Years.years(4).getYears());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2200, "method_signature": "void testFactory_years_int()"}, "TestYears.testIsGreaterThan": {"callee_method_names": [], "method_name": "TestYears.testIsGreaterThan", "method_implementation": "{\n    assertEquals(true, Years.THREE.isGreaterThan(Years.TWO));\n    assertEquals(false, Years.THREE.isGreaterThan(Years.THREE));\n    assertEquals(false, Years.TWO.isGreaterThan(Years.THREE));\n    assertEquals(true, Years.ONE.isGreaterThan(null));\n    assertEquals(false, Years.years(-1).isGreaterThan(null));\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2202, "method_signature": "void testIsGreaterThan()"}, "TestYears.testPlus_int": {"callee_method_ids": [243], "callee_method_names": ["Years.plus", "Years.getYears", "Years.getYears"], "method_name": "TestYears.testPlus_int", "method_implementation": "{\n    Years test2 = Years.years(2);\n    Years result = test2.plus(3);\n    assertEquals(2, test2.getYears());\n    assertEquals(5, result.getYears());\n    assertEquals(1, Years.ONE.plus(0).getYears());\n    try {\n        Years.MAX_VALUE.plus(1);\n        fail();\n    } catch (ArithmeticException ex) {\n        // expected\n    }\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2205, "method_signature": "void testPlus_int()"}, "TestYears.testSerialization": {"callee_method_names": ["ObjectOutputStream.writeObject", "ObjectOutputStream.close", "ByteArrayOutputStream.toByteArray", "ObjectInputStream.readObject", "ObjectInputStream.close"], "method_name": "TestYears.testSerialization", "method_implementation": "{\n    Years test = Years.THREE;\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    ObjectOutputStream oos = new ObjectOutputStream(baos);\n    oos.writeObject(test);\n    oos.close();\n    byte[] bytes = baos.toByteArray();\n    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n    ObjectInputStream ois = new ObjectInputStream(bais);\n    Years result = (Years) ois.readObject();\n    ois.close();\n    assertSame(test, result);\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2204, "method_signature": "void testSerialization()"}, "TestYears.testToString": {"callee_method_ids": [248, 248], "callee_method_names": ["Years.toString", "Years.toString"], "method_name": "TestYears.testToString", "method_implementation": "{\n    Years test = Years.years(20);\n    assertEquals(\"P20Y\", test.toString());\n    test = Years.years(-20);\n    assertEquals(\"P-20Y\", test.toString());\n}", "repo_id": "7", "comment": "//-----------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 2203, "method_signature": "void testToString()"}, "ThreadContention.multiThreadGJLocale": {"callee_method_names": ["CountDownLatch.await", "GJLocaleSymbols.getClass", "Exception.printStackTrace", "List<Runnable>.add", "CountDownLatch.countDown"], "method_name": "ThreadContention.multiThreadGJLocale", "method_implementation": "{\n    final CountDownLatch latch = new CountDownLatch(1);\n    final List<Locale> locales = createLocales();\n    List<Runnable> runnables = new ArrayList<Runnable>();\n    for (int i = 0; i < 100; i++) {\n        Runnable r = new Runnable() {\n\n            public void run() {\n                try {\n                    latch.await();\n                    List<Locale> shuffled = new ArrayList<Locale>(locales);\n                    Collections.shuffle(shuffled);\n                    String name = Thread.currentThread().getName();\n                    for (int j = 0; j < 100; j++) {\n                        for (Locale locale : shuffled) {\n                            GJLocaleSymbols symbols = GJLocaleSymbols.forLocale(locale);\n                            Assert.assertEquals(GJLocaleSymbols.class, symbols.getClass());\n                        }\n                    }\n                    System.out.println(\"Finished: \" + name);\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        };\n        new Thread(r).start();\n        runnables.add(r);\n    }\n    latch.countDown();\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1949, "method_signature": "void multiThreadGJLocale()"}, "ThreadContention.multiThreadZones": {"callee_method_names": ["CountDownLatch.await", "ISOChronology.getZone", "Exception.printStackTrace", "List<Runnable>.add", "CountDownLatch.countDown"], "method_name": "ThreadContention.multiThreadZones", "method_implementation": "{\n    final CountDownLatch latch = new CountDownLatch(1);\n    final List<DateTimeZone> zones = createZones();\n    List<Runnable> runnables = new ArrayList<Runnable>();\n    for (int i = 0; i < 100; i++) {\n        Runnable r = new Runnable() {\n\n            public void run() {\n                try {\n                    latch.await();\n                    List<DateTimeZone> shuffled = new ArrayList<DateTimeZone>(zones);\n                    Collections.shuffle(shuffled);\n                    String name = Thread.currentThread().getName();\n                    for (int j = 0; j < 100; j++) {\n                        for (DateTimeZone zn : shuffled) {\n                            ISOChronology chrono = ISOChronology.getInstance(zn);\n                            Assert.assertEquals(zn, chrono.getZone());\n                        }\n                    }\n                    System.out.println(\"Finished: \" + name);\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        };\n        new Thread(r).start();\n        runnables.add(r);\n    }\n    latch.countDown();\n}", "repo_id": "7", "comment": "//-------------------------------------------------------------------------\n", "repo_name": "joda-time-main/", "id": 1950, "method_signature": "void multiThreadZones()"}, "TimeOfDay.addNoWrapToCopy": {"callee_method_names": ["TimeOfDay.getValues"], "method_name": "TimeOfDay.addNoWrapToCopy", "method_implementation": "{\n    int[] newValues = iTimeOfDay.getValues();\n    newValues = getField().add(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n    return new TimeOfDay(iTimeOfDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this TimeOfDay,\n * throwing an Exception if the bounds are exceeded.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it will affect larger fields.\n * Smaller fields are unaffected.\n * <p>\n * If the result would be too large (beyond 23:59:59:999) or too\n * small (less than 00:00:00.000) then an Exception is thrown.\n * For the alternate behaviour which wraps to the next 'day',\n * see {@link #addToCopy(int)}.\n * <p>\n * The TimeOfDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the TimeOfDay with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 647, "method_signature": "TimeOfDay addNoWrapToCopy(int)"}, "TimeOfDay.addToCopy": {"callee_method_names": ["TimeOfDay.getValues"], "method_name": "TimeOfDay.addToCopy", "method_implementation": "{\n    int[] newValues = iTimeOfDay.getValues();\n    newValues = getField().addWrapPartial(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n    return new TimeOfDay(iTimeOfDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this TimeOfDay,\n * wrapping to what would be the next day if necessary.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it will affect larger fields.\n * Smaller fields are unaffected.\n * <p>\n * If the result would be too large, beyond 23:59:59:999, then the\n * calculation wraps to 00:00:00.000. For the alternate strict behaviour\n * with no wrapping see {@link #addNoWrapToCopy(int)}.\n * <p>\n * The TimeOfDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the TimeOfDay with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 646, "method_signature": "TimeOfDay addToCopy(int)"}, "TimeOfDay.addWrapFieldToCopy": {"callee_method_names": ["TimeOfDay.getValues"], "method_name": "TimeOfDay.addWrapFieldToCopy", "method_implementation": "{\n    int[] newValues = iTimeOfDay.getValues();\n    newValues = getField().addWrapField(iTimeOfDay, iFieldIndex, newValues, valueToAdd);\n    return new TimeOfDay(iTimeOfDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this TimeOfDay wrapping\n * within this field if the maximum value is reached.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it wraps within this field.\n * Other fields are unaffected.\n * <p>\n * For example,\n * <code>12:59:37</code> addWrapField one minute returns <code>12:00:37</code>.\n * <p>\n * The TimeOfDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the TimeOfDay with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 648, "method_signature": "TimeOfDay addWrapFieldToCopy(int)"}, "TimeOfDay.fromCalendarFields": {"callee_method_names": ["Calendar.get", "Calendar.get", "Calendar.get", "Calendar.get"], "method_name": "TimeOfDay.fromCalendarFields", "method_implementation": "{\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    return new TimeOfDay(calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND));\n}", "repo_id": "7", "comment": "/**\n * Constructs a TimeOfDay from a <code>java.util.Calendar</code>\n * using exactly the same field values avoiding any time zone effects.\n * <p>\n * Each field is queried from the Calendar and assigned to the TimeOfDay.\n * This is useful to ensure that the field values are the same in the\n * created TimeOfDay no matter what the time zone is. For example, if\n * the Calendar states that the time is 04:29, then the created TimeOfDay\n * will always have the time 04:29 irrespective of time zone issues.\n * <p>\n * This factory method ignores the type of the calendar and always\n * creates a TimeOfDay with ISO chronology.\n *\n * @param calendar  the Calendar to extract fields from\n * @return the created TimeOfDay\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the time is invalid for the ISO chronology\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 633, "method_signature": "TimeOfDay fromCalendarFields(Calendar)"}, "TimeOfDay.fromDateFields": {"callee_method_names": ["Date.getHours", "Date.getMinutes", "Date.getSeconds", "Date.getTime"], "method_name": "TimeOfDay.fromDateFields", "method_implementation": "{\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return new TimeOfDay(date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000);\n}", "repo_id": "7", "comment": "/**\n * Constructs a TimeOfDay from a <code>java.util.Date</code>\n * using exactly the same field values avoiding any time zone effects.\n * <p>\n * Each field is queried from the Date and assigned to the TimeOfDay.\n * This is useful to ensure that the field values are the same in the\n * created TimeOfDay no matter what the time zone is. For example, if\n * the Calendar states that the time is 04:29, then the created TimeOfDay\n * will always have the time 04:29 irrespective of time zone issues.\n * <p>\n * This factory method always creates a TimeOfDay with ISO chronology.\n *\n * @param date  the Date to extract fields from\n * @return the created TimeOfDay\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 634, "method_signature": "TimeOfDay fromDateFields(Date)"}, "TimeOfDay.fromMillisOfDay": {"callee_method_names": ["Chronology.withUTC"], "method_name": "TimeOfDay.fromMillisOfDay", "method_implementation": "{\n    chrono = DateTimeUtils.getChronology(chrono);\n    chrono = chrono.withUTC();\n    return new TimeOfDay(millisOfDay, chrono);\n}", "repo_id": "7", "comment": "/**\n * Constructs a TimeOfDay from the specified millis of day using the\n * specified chronology.\n * <p>\n * The millisOfDay value may exceed the number of millis in one day,\n * but additional days will be ignored.\n * This method uses the UTC time zone internally.\n *\n * @param millisOfDay  the number of milliseconds into a day to convert\n * @param chrono  the chronology, null means ISO chronology\n * @return the time, not null\n */\n", "repo_name": "joda-time-main/", "id": 635, "method_signature": "TimeOfDay fromMillisOfDay(long, Chronology)"}, "TimeOfDay.getField": {"callee_method_names": ["Chronology.hourOfDay", "Chronology.minuteOfHour", "Chronology.secondOfMinute", "Chronology.millisOfSecond"], "method_name": "TimeOfDay.getField", "method_implementation": "{\n    switch(index) {\n        case HOUR_OF_DAY:\n            return chrono.hourOfDay();\n        case MINUTE_OF_HOUR:\n            return chrono.minuteOfHour();\n        case SECOND_OF_MINUTE:\n            return chrono.secondOfMinute();\n        case MILLIS_OF_SECOND:\n            return chrono.millisOfSecond();\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the field for a specific index in the chronology specified.\n * <p>\n * This method must not use any instance variables.\n *\n * @param index  the index to retrieve\n * @param chrono  the chronology to use\n * @return the field\n */\n", "repo_name": "joda-time-main/", "id": 636, "method_signature": "DateTimeField getField(int, Chronology)"}, "TimeOfDay.setCopy": {"callee_method_names": ["TimeOfDay.getValues"], "method_name": "TimeOfDay.setCopy", "method_implementation": "{\n    int[] newValues = iTimeOfDay.getValues();\n    newValues = getField().set(iTimeOfDay, iFieldIndex, newValues, text, locale);\n    return new TimeOfDay(iTimeOfDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Sets this field in a copy of the TimeOfDay to a parsed text value.\n * <p>\n * The TimeOfDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param text  the text value to set\n * @param locale  optional locale to use for selecting a text symbol\n * @return a copy of the TimeOfDay with the field value changed\n * @throws IllegalArgumentException if the text value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 650, "method_signature": "TimeOfDay setCopy(String, Locale)"}, "TimeOfDay.toDateTimeToday": {"callee_method_names": ["Chronology.set"], "method_name": "TimeOfDay.toDateTimeToday", "method_implementation": "{\n    Chronology chrono = getChronology().withZone(zone);\n    long instantMillis = DateTimeUtils.currentTimeMillis();\n    long resolved = chrono.set(this, instantMillis);\n    return new DateTime(resolved, chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this partial to a full datetime using the specified time zone\n * setting the time fields from this instance and the date fields from\n * the current time.\n * <p>\n * This method uses the chronology from this instance plus the time zone\n * specified.\n *\n * @param zone  the zone to use, null means default\n * @return this date as a datetime with the time as the current time\n */\n", "repo_name": "joda-time-main/", "id": 641, "method_signature": "DateTime toDateTimeToday(DateTimeZone)"}, "TimeOfDay.withChronologyRetainFields": {"callee_method_names": ["Chronology.withUTC", "Chronology.validate"], "method_name": "TimeOfDay.withChronologyRetainFields", "method_implementation": "{\n    newChronology = DateTimeUtils.getChronology(newChronology);\n    newChronology = newChronology.withUTC();\n    if (newChronology == getChronology()) {\n        return this;\n    } else {\n        TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology);\n        newChronology.validate(newTimeOfDay, getValues());\n        return newTimeOfDay;\n    }\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the specified chronology.\n * This instance is immutable and unaffected by this method call.\n * <p>\n * This method retains the values of the fields, thus the result will\n * typically refer to a different instant.\n * <p>\n * The time zone of the specified chronology is ignored, as TimeOfDay\n * operates without a time zone.\n *\n * @param newChronology  the new chronology, null means ISO\n * @return a copy of this datetime with a different chronology\n * @throws IllegalArgumentException if the values are invalid for the new chronology\n */\n", "repo_name": "joda-time-main/", "id": 637, "method_signature": "TimeOfDay withChronologyRetainFields(Chronology)"}, "TimeOfDay.withField": {"callee_method_names": [], "method_name": "TimeOfDay.withField", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new TimeOfDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the specified field set to a new value.\n * <p>\n * For example, if the field type is <code>minuteOfHour</code> then the day\n * would be changed in the returned instance.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * TimeOfDay updated = tod.withField(DateTimeFieldType.minuteOfHour(), 6);\n * TimeOfDay updated = tod.minuteOfHour().setCopy(6);\n * TimeOfDay updated = tod.property(DateTimeFieldType.minuteOfHour()).setCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this instance with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 638, "method_signature": "TimeOfDay withField(DateTimeFieldType, int)"}, "TimeOfDay.withFieldAdded": {"callee_method_names": [], "method_name": "TimeOfDay.withFieldAdded", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (amount == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).addWrapPartial(this, index, newValues, amount);\n    return new TimeOfDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the value of the specified field increased,\n * wrapping to what would be a new day if required.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * TimeOfDay added = tod.withFieldAdded(DurationFieldType.minutes(), 6);\n * TimeOfDay added = tod.plusMinutes(6);\n * TimeOfDay added = tod.minuteOfHour().addToCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this instance with the field updated\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the new datetime exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 639, "method_signature": "TimeOfDay withFieldAdded(DurationFieldType, int)"}, "TimeOfDay.withHourOfDay": {"callee_method_names": [], "method_name": "TimeOfDay.withHourOfDay", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().hourOfDay().set(this, HOUR_OF_DAY, newValues, hour);\n    return new TimeOfDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the hour of day field updated.\n * <p>\n * TimeOfDay is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * hour of day changed.\n *\n * @param hour  the hour of day to set\n * @return a copy of this object with the field set\n * @throws IllegalArgumentException if the value is invalid\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 642, "method_signature": "TimeOfDay withHourOfDay(int)"}, "TimeOfDay.withMillisOfSecond": {"callee_method_names": [], "method_name": "TimeOfDay.withMillisOfSecond", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().millisOfSecond().set(this, MILLIS_OF_SECOND, newValues, millis);\n    return new TimeOfDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the millis of second field updated.\n * <p>\n * TimeOfDay is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * millis of second changed.\n *\n * @param millis  the millis of second to set\n * @return a copy of this object with the field set\n * @throws IllegalArgumentException if the value is invalid\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 645, "method_signature": "TimeOfDay withMillisOfSecond(int)"}, "TimeOfDay.withMinuteOfHour": {"callee_method_names": [], "method_name": "TimeOfDay.withMinuteOfHour", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().minuteOfHour().set(this, MINUTE_OF_HOUR, newValues, minute);\n    return new TimeOfDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the minute of hour field updated.\n * <p>\n * TimeOfDay is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * minute of hour changed.\n *\n * @param minute  the minute of hour to set\n * @return a copy of this object with the field set\n * @throws IllegalArgumentException if the value is invalid\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 643, "method_signature": "TimeOfDay withMinuteOfHour(int)"}, "TimeOfDay.withPeriodAdded": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getFieldType", "ReadablePeriod.getValue"], "method_name": "TimeOfDay.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    for (int i = 0; i < period.size(); i++) {\n        DurationFieldType fieldType = period.getFieldType(i);\n        int index = indexOf(fieldType);\n        if (index >= 0) {\n            newValues = getField(index).addWrapPartial(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\n        }\n    }\n    return new TimeOfDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the specified period added,\n * wrapping to what would be a new day if required.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * Fields in the period that aren't present in the partial are ignored.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using methods\n * like {@link #withFieldAdded(DurationFieldType, int)}\n * or {@link #plusHours(int)}.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this instance with the period added\n * @throws ArithmeticException if the new datetime exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 640, "method_signature": "TimeOfDay withPeriodAdded(ReadablePeriod, int)"}, "TimeOfDay.withSecondOfMinute": {"callee_method_names": [], "method_name": "TimeOfDay.withSecondOfMinute", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().secondOfMinute().set(this, SECOND_OF_MINUTE, newValues, second);\n    return new TimeOfDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this time with the second of minute field updated.\n * <p>\n * TimeOfDay is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * second of minute changed.\n *\n * @param second  the second of minute to set\n * @return a copy of this object with the field set\n * @throws IllegalArgumentException if the value is invalid\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 644, "method_signature": "TimeOfDay withSecondOfMinute(int)"}, "TimeZoneOffset.digitCount": {"callee_method_names": ["CharSequence.length", "CharSequence.charAt"], "method_name": "TimeZoneOffset.digitCount", "method_implementation": "{\n    int limit = Math.min(text.length() - position, amount);\n    amount = 0;\n    for (; limit > 0; limit--) {\n        char c = text.charAt(position + amount);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        amount++;\n    }\n    return amount;\n}", "repo_id": "7", "comment": "/**\n * Returns actual amount of digits to parse, but no more than original\n * 'amount' parameter.\n */\n", "repo_name": "joda-time-main/", "id": 933, "method_signature": "int digitCount(CharSequence, int, int)"}, "Transition.isTransitionFrom": {"callee_method_names": ["String.equals"], "method_name": "Transition.isTransitionFrom", "method_implementation": "{\n    if (other == null) {\n        return true;\n    }\n    return iMillis > other.iMillis && (iWallOffset != other.iWallOffset || iStandardOffset != other.iStandardOffset || !(iNameKey.equals(other.iNameKey)));\n}", "repo_id": "7", "comment": "/**\n * There must be a change in the millis, wall offsets or name keys.\n */\n", "repo_name": "joda-time-main/", "id": 766, "method_signature": "boolean isTransitionFrom(Transition)"}, "UTCProvider.getZone": {"callee_method_names": [], "method_name": "UTCProvider.getZone", "method_implementation": "{\n    if (\"UTC\".equalsIgnoreCase(id)) {\n        return DateTimeZone.UTC;\n    }\n    return null;\n}", "repo_id": "7", "comment": "/**\n * Returns {@link DateTimeZone#UTC UTC} for <code>\"UTC\"</code>, null\n * otherwise.\n */\n", "repo_name": "joda-time-main/", "id": 772, "method_signature": "DateTimeZone getZone(String)"}, "UnsupportedDateTimeField.getInstance": {"callee_method_names": ["HashMap<DateTimeFieldType, UnsupportedDateTimeField>.get", "UnsupportedDateTimeField.getDurationField", "HashMap<DateTimeFieldType, UnsupportedDateTimeField>.put"], "method_name": "UnsupportedDateTimeField.getInstance", "method_implementation": "{\n    UnsupportedDateTimeField field;\n    if (cCache == null) {\n        cCache = new HashMap<DateTimeFieldType, UnsupportedDateTimeField>(7);\n        field = null;\n    } else {\n        field = cCache.get(type);\n        if (field != null && field.getDurationField() != durationField) {\n            field = null;\n        }\n    }\n    if (field == null) {\n        field = new UnsupportedDateTimeField(type, durationField);\n        cCache.put(type, field);\n    }\n    return field;\n}", "repo_id": "7", "comment": "/**\n * Gets an instance of UnsupportedDateTimeField for a specific named field.\n * Names should be of standard format, such as 'monthOfYear' or 'hourOfDay'.\n * The returned instance is cached.\n *\n * @param type  the type to obtain\n * @param durationField  the duration field\n * @return the instance\n * @throws IllegalArgumentException if durationField is null\n */\n", "repo_name": "joda-time-main/", "id": 24, "method_signature": "UnsupportedDateTimeField getInstance(DateTimeFieldType, DurationField)"}, "UnsupportedDurationField.equals": {"callee_method_names": ["UnsupportedDurationField.getName", "UnsupportedDurationField.getName"], "method_name": "UnsupportedDurationField.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    } else if (obj instanceof UnsupportedDurationField) {\n        UnsupportedDurationField other = (UnsupportedDurationField) obj;\n        if (other.getName() == null) {\n            return (getName() == null);\n        }\n        return (other.getName().equals(getName()));\n    }\n    return false;\n}", "repo_id": "7", "comment": "/**\n * Compares this duration field to another.\n *\n * @param obj  the object to compare to\n * @return true if equal\n */\n", "repo_name": "joda-time-main/", "id": 58, "method_signature": "boolean equals(Object)"}, "UnsupportedDurationField.getInstance": {"callee_method_names": ["HashMap<DurationFieldType, UnsupportedDurationField>.get", "HashMap<DurationFieldType, UnsupportedDurationField>.put"], "method_name": "UnsupportedDurationField.getInstance", "method_implementation": "{\n    UnsupportedDurationField field;\n    if (cCache == null) {\n        cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n        field = null;\n    } else {\n        field = cCache.get(type);\n    }\n    if (field == null) {\n        field = new UnsupportedDurationField(type);\n        cCache.put(type, field);\n    }\n    return field;\n}", "repo_id": "7", "comment": "/**\n * Gets an instance of UnsupportedDurationField for a specific named field.\n * The returned instance is cached.\n *\n * @param type  the type to obtain\n * @return the instance\n */\n", "repo_name": "joda-time-main/", "id": 57, "method_signature": "UnsupportedDurationField getInstance(DurationFieldType)"}, "Weeks.dividedBy": {"callee_method_names": [], "method_name": "Weeks.dividedBy", "method_implementation": "{\n    if (divisor == 1) {\n        return this;\n    }\n    return Weeks.weeks(getValue() / divisor);\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the weeks divided by the specified divisor.\n * The calculation uses integer division, thus 3 divided by 2 is 1.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param divisor  the amount to divide by, may be negative\n * @return the new period divided by the specified divisor\n * @throws ArithmeticException if the divisor is zero\n */\n", "repo_name": "joda-time-main/", "id": 82, "method_signature": "Weeks dividedBy(int)"}, "Weeks.isGreaterThan": {"callee_method_names": ["Weeks.getValue"], "method_name": "Weeks.isGreaterThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() > 0;\n    }\n    return getValue() > other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this weeks instance greater than the specified number of weeks.\n *\n * @param other  the other period, null means zero\n * @return true if this weeks instance is greater than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 83, "method_signature": "boolean isGreaterThan(Weeks)"}, "Weeks.isLessThan": {"callee_method_names": ["Weeks.getValue"], "method_name": "Weeks.isLessThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() < 0;\n    }\n    return getValue() < other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this weeks instance less than the specified number of weeks.\n *\n * @param other  the other period, null means zero\n * @return true if this weeks instance is less than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 84, "method_signature": "boolean isLessThan(Weeks)"}, "Weeks.minus": {"callee_method_names": ["Weeks.getValue"], "method_name": "Weeks.minus", "method_implementation": "{\n    if (weeks == null) {\n        return this;\n    }\n    return minus(weeks.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of weeks taken away.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param weeks  the amount of weeks to take away, may be negative, null means zero\n * @return the new period minus the specified number of weeks\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 81, "method_signature": "Weeks minus(Weeks)"}, "Weeks.parseWeeks": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod", "Period.getWeeks"], "method_name": "Weeks.parseWeeks", "method_implementation": "{\n    if (periodStr == null) {\n        return Weeks.ZERO;\n    }\n    Period p = PARSER.parsePeriod(periodStr);\n    return Weeks.weeks(p.getWeeks());\n}", "repo_id": "7", "comment": "/**\n * Creates a new <code>Weeks</code> by parsing a string in the ISO8601 format 'PnW'.\n * <p>\n * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n * weeks component may be non-zero. If any other component is non-zero, an exception\n * will be thrown.\n *\n * @param periodStr  the period string, null returns zero\n * @return the period in weeks\n * @throws IllegalArgumentException if the string format is invalid\n */\n", "repo_name": "joda-time-main/", "id": 78, "method_signature": "Weeks parseWeeks(String)"}, "Weeks.plus": {"callee_method_names": ["Weeks.getValue"], "method_name": "Weeks.plus", "method_implementation": "{\n    if (weeks == null) {\n        return this;\n    }\n    return plus(weeks.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of weeks added.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param weeks  the amount of weeks to add, may be negative, null means zero\n * @return the new period plus the specified number of weeks\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 80, "method_signature": "Weeks plus(Weeks)"}, "Weeks.toString": {"callee_method_names": [], "method_name": "Weeks.toString", "method_implementation": "{\n    return \"P\" + String.valueOf(getValue()) + \"W\";\n}", "repo_id": "7", "comment": "/**\n * Gets this instance as a String in the ISO8601 duration format.\n * <p>\n * For example, \"P4W\" represents 4 weeks.\n *\n * @return the value as an ISO8601 string\n */\n", "repo_name": "joda-time-main/", "id": 85, "method_signature": "String toString()"}, "Weeks.weeks": {"callee_method_names": [], "method_name": "Weeks.weeks", "method_implementation": "{\n    switch(weeks) {\n        case 0:\n            return ZERO;\n        case 1:\n            return ONE;\n        case 2:\n            return TWO;\n        case 3:\n            return THREE;\n        case Integer.MAX_VALUE:\n            return MAX_VALUE;\n        case Integer.MIN_VALUE:\n            return MIN_VALUE;\n        default:\n            return new Weeks(weeks);\n    }\n}", "repo_id": "7", "comment": "/**\n * Obtains an instance of <code>Weeks</code> that may be cached.\n * <code>Weeks</code> is immutable, so instances can be cached and shared.\n * This factory method provides access to shared instances.\n *\n * @param weeks  the number of weeks to obtain an instance for\n * @return the instance of Weeks\n */\n", "repo_name": "joda-time-main/", "id": 75, "method_signature": "Weeks weeks(int)"}, "Weeks.weeksBetween": {"callee_method_names": ["ReadablePartial.getChronology", "Chronology.weeks"], "method_name": "Weeks.weeksBetween", "method_implementation": "{\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int weeks = chrono.weeks().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return Weeks.weeks(weeks);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return Weeks.weeks(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Weeks</code> representing the number of whole weeks\n * between the two specified partial datetimes.\n * <p>\n * The two partials must contain the same fields, for example you can specify\n * two <code>LocalDate</code> objects.\n *\n * @param start  the start partial date, must not be null\n * @param end  the end partial date, must not be null\n * @return the period in weeks\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 76, "method_signature": "Weeks weeksBetween(ReadablePartial, ReadablePartial)"}, "Weeks.weeksIn": {"callee_method_names": ["ReadableInterval.getStart", "ReadableInterval.getEnd"], "method_name": "Weeks.weeksIn", "method_implementation": "{\n    if (interval == null) {\n        return Weeks.ZERO;\n    }\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.weeks());\n    return Weeks.weeks(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Weeks</code> representing the number of whole weeks\n * in the specified interval.\n *\n * @param interval  the interval to extract weeks from, null returns zero\n * @return the period in weeks\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 77, "method_signature": "Weeks weeksIn(ReadableInterval)"}, "YearMonth.addToCopy": {"callee_method_names": ["YearMonth.getValues"], "method_name": "YearMonth.addToCopy", "method_implementation": "{\n    int[] newValues = iBase.getValues();\n    newValues = getField().add(iBase, iFieldIndex, newValues, valueToAdd);\n    return new YearMonth(iBase, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this YearMonth.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it will affect larger fields.\n * Smaller fields are unaffected.\n * <p>\n * If the result would be too large, beyond the maximum year, then an\n * IllegalArgumentException is thrown.\n * <p>\n * The YearMonth attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the YearMonth with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 417, "method_signature": "YearMonth addToCopy(int)"}, "YearMonth.addWrapFieldToCopy": {"callee_method_names": ["YearMonth.getValues"], "method_name": "YearMonth.addWrapFieldToCopy", "method_implementation": "{\n    int[] newValues = iBase.getValues();\n    newValues = getField().addWrapField(iBase, iFieldIndex, newValues, valueToAdd);\n    return new YearMonth(iBase, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this YearMonth wrapping\n * within this field if the maximum value is reached.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it wraps within this field.\n * Other fields are unaffected.\n * <p>\n * For example,\n * <code>2004-12</code> addWrapField one month returns <code>2004-01</code>.\n * <p>\n * The YearMonth attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the YearMonth with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 418, "method_signature": "YearMonth addWrapFieldToCopy(int)"}, "YearMonth.fromCalendarFields": {"callee_method_names": ["Calendar.get", "Calendar.get"], "method_name": "YearMonth.fromCalendarFields", "method_implementation": "{\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    return new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1);\n}", "repo_id": "7", "comment": "/**\n * Constructs a YearMonth from a <code>java.util.Calendar</code>\n * using exactly the same field values avoiding any time zone effects.\n * <p>\n * Each field is queried from the Calendar and assigned to the YearMonth.\n * <p>\n * This factory method ignores the type of the calendar and always\n * creates a YearMonth with ISO chronology. It is expected that you\n * will only pass in instances of <code>GregorianCalendar</code> however\n * this is not validated.\n *\n * @param calendar  the Calendar to extract fields from\n * @return the created YearMonth, never null\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 403, "method_signature": "YearMonth fromCalendarFields(Calendar)"}, "YearMonth.fromDateFields": {"callee_method_names": ["Date.getYear", "Date.getMonth"], "method_name": "YearMonth.fromDateFields", "method_implementation": "{\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return new YearMonth(date.getYear() + 1900, date.getMonth() + 1);\n}", "repo_id": "7", "comment": "/**\n * Constructs a YearMonth from a <code>java.util.Date</code>\n * using exactly the same field values avoiding any time zone effects.\n * <p>\n * Each field is queried from the Date and assigned to the YearMonth.\n * <p>\n * This factory method always creates a YearMonth with ISO chronology.\n *\n * @param date  the Date to extract fields from\n * @return the created YearMonth, never null\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the year or month is invalid for the ISO chronology\n */\n", "repo_name": "joda-time-main/", "id": 404, "method_signature": "YearMonth fromDateFields(Date)"}, "YearMonth.getField": {"callee_method_names": ["Chronology.year", "Chronology.monthOfYear"], "method_name": "YearMonth.getField", "method_implementation": "{\n    switch(index) {\n        case YEAR:\n            return chrono.year();\n        case MONTH_OF_YEAR:\n            return chrono.monthOfYear();\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the field for a specific index in the chronology specified.\n * <p>\n * This method must not use any instance variables.\n *\n * @param index  the index to retrieve\n * @param chrono  the chronology to use\n * @return the field, never null\n */\n", "repo_name": "joda-time-main/", "id": 406, "method_signature": "DateTimeField getField(int, Chronology)"}, "YearMonth.now": {"callee_method_names": [], "method_name": "YearMonth.now", "method_implementation": "{\n    if (chronology == null) {\n        throw new NullPointerException(\"Chronology must not be null\");\n    }\n    return new YearMonth(chronology);\n}", "repo_id": "7", "comment": "/**\n * Obtains a {@code YearMonth} set to the current system millisecond time\n * using the specified chronology.\n * The resulting object does not use the zone.\n *\n * @param chronology  the chronology, not null\n * @return the current year-month, not null\n * @since 2.0\n */\n", "repo_name": "joda-time-main/", "id": 402, "method_signature": "YearMonth now(Chronology)"}, "YearMonth.readResolve": {"callee_method_names": [], "method_name": "YearMonth.readResolve", "method_implementation": "{\n    if (DateTimeZone.UTC.equals(getChronology().getZone()) == false) {\n        return new YearMonth(this, getChronology().withUTC());\n    }\n    return this;\n}", "repo_id": "7", "comment": "/**\n * Handle broken serialization from other tools.\n * @return the resolved object, not null\n */\n", "repo_name": "joda-time-main/", "id": 405, "method_signature": "Object readResolve()"}, "YearMonth.setCopy": {"callee_method_names": ["YearMonth.getValues"], "method_name": "YearMonth.setCopy", "method_implementation": "{\n    int[] newValues = iBase.getValues();\n    newValues = getField().set(iBase, iFieldIndex, newValues, text, locale);\n    return new YearMonth(iBase, newValues);\n}", "repo_id": "7", "comment": "/**\n * Sets this field in a copy of the YearMonth to a parsed text value.\n * <p>\n * The YearMonth attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param text  the text value to set\n * @param locale  optional locale to use for selecting a text symbol\n * @return a copy of the YearMonth with the field value changed\n * @throws IllegalArgumentException if the text value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 420, "method_signature": "YearMonth setCopy(String, Locale)"}, "YearMonth.toInterval": {"callee_method_names": [], "method_name": "YearMonth.toInterval", "method_implementation": "{\n    zone = DateTimeUtils.getZone(zone);\n    DateTime start = toLocalDate(1).toDateTimeAtStartOfDay(zone);\n    DateTime end = plusMonths(1).toLocalDate(1).toDateTimeAtStartOfDay(zone);\n    return new Interval(start, end);\n}", "repo_id": "7", "comment": "/**\n * Converts this object to an Interval representing the whole month.\n * <p>\n * The interval will use the chronology of the year-month in the specified zone.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param zone  the zone to get the Interval in, null means default\n * @return an interval over the month, never null\n */\n", "repo_name": "joda-time-main/", "id": 411, "method_signature": "Interval toInterval(DateTimeZone)"}, "YearMonth.toString": {"callee_method_names": [], "method_name": "YearMonth.toString", "method_implementation": "{\n    if (pattern == null) {\n        return toString();\n    }\n    return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this);\n}", "repo_id": "7", "comment": "/**\n * Output the year-month using the specified format pattern.\n *\n * @param pattern  the pattern specification, null means use <code>toString</code>\n * @param locale  Locale to use, null means default\n * @see org.joda.time.format.DateTimeFormat\n */\n", "repo_name": "joda-time-main/", "id": 416, "method_signature": "String toString(String, Locale)"}, "YearMonth.withChronologyRetainFields": {"callee_method_names": ["Chronology.withUTC", "Chronology.validate"], "method_name": "YearMonth.withChronologyRetainFields", "method_implementation": "{\n    newChronology = DateTimeUtils.getChronology(newChronology);\n    newChronology = newChronology.withUTC();\n    if (newChronology == getChronology()) {\n        return this;\n    } else {\n        YearMonth newYearMonth = new YearMonth(this, newChronology);\n        newChronology.validate(newYearMonth, getValues());\n        return newYearMonth;\n    }\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this year-month with the specified chronology.\n * This instance is immutable and unaffected by this method call.\n * <p>\n * This method retains the values of the fields, thus the result will\n * typically refer to a different instant.\n * <p>\n * The time zone of the specified chronology is ignored, as YearMonth\n * operates without a time zone.\n *\n * @param newChronology  the new chronology, null means ISO\n * @return a copy of this year-month with a different chronology, never null\n * @throws IllegalArgumentException if the values are invalid for the new chronology\n */\n", "repo_name": "joda-time-main/", "id": 407, "method_signature": "YearMonth withChronologyRetainFields(Chronology)"}, "YearMonth.withField": {"callee_method_names": [], "method_name": "YearMonth.withField", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new YearMonth(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this year-month with the specified field set to a new value.\n * <p>\n * For example, if the field type is <code>monthOfYear</code> then the month\n * would be changed in the returned instance.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * YearMonth updated = ym.withField(DateTimeFieldType.monthOfYear(), 6);\n * YearMonth updated = ym.monthOfYear().setCopy(6);\n * YearMonth updated = ym.property(DateTimeFieldType.monthOfYear()).setCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this instance with the field set, never null\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 408, "method_signature": "YearMonth withField(DateTimeFieldType, int)"}, "YearMonth.withFieldAdded": {"callee_method_names": [], "method_name": "YearMonth.withFieldAdded", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (amount == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).add(this, index, newValues, amount);\n    return new YearMonth(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this year-month with the value of the specified field increased.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * YearMonth added = ym.withFieldAdded(DurationFieldType.months(), 6);\n * YearMonth added = ym.plusMonths(6);\n * YearMonth added = ym.monthOfYear().addToCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this instance with the field updated, never null\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the new date-time exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 409, "method_signature": "YearMonth withFieldAdded(DurationFieldType, int)"}, "YearMonth.withMonthOfYear": {"callee_method_names": [], "method_name": "YearMonth.withMonthOfYear", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n    return new YearMonth(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this year-month with the month of year field updated.\n * <p>\n * YearMonth is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * month of year changed.\n *\n * @param monthOfYear  the month of year to set\n * @return a copy of this object with the field set, never null\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 413, "method_signature": "YearMonth withMonthOfYear(int)"}, "YearMonth.withPeriodAdded": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getFieldType", "ReadablePeriod.getValue"], "method_name": "YearMonth.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    for (int i = 0; i < period.size(); i++) {\n        DurationFieldType fieldType = period.getFieldType(i);\n        int index = indexOf(fieldType);\n        if (index >= 0) {\n            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\n        }\n    }\n    return new YearMonth(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this year-month with the specified period added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * Fields in the period that aren't present in the partial are ignored.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using methods\n * like {@link #withFieldAdded(DurationFieldType, int)}\n * or {@link #plusYears(int)}.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this instance with the period added, never null\n * @throws ArithmeticException if the new date-time exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 410, "method_signature": "YearMonth withPeriodAdded(ReadablePeriod, int)"}, "YearMonth.withYear": {"callee_method_names": [], "method_name": "YearMonth.withYear", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().year().set(this, YEAR, newValues, year);\n    return new YearMonth(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this year-month with the year field updated.\n * <p>\n * YearMonth is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * year changed.\n *\n * @param year  the year to set\n * @return a copy of this object with the field set, never null\n * @throws IllegalArgumentException if the value is invalid\n */\n", "repo_name": "joda-time-main/", "id": 412, "method_signature": "YearMonth withYear(int)"}, "YearMonthDay.addToCopy": {"callee_method_names": ["YearMonthDay.getValues"], "method_name": "YearMonthDay.addToCopy", "method_implementation": "{\n    int[] newValues = iYearMonthDay.getValues();\n    newValues = getField().add(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n    return new YearMonthDay(iYearMonthDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this YearMonthDay.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it will affect larger fields.\n * Smaller fields are unaffected.\n * <p>\n * If the result would be too large, beyond the maximum year, then an\n * IllegalArgumentException is thrown.\n * <p>\n * The YearMonthDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the YearMonthDay with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 201, "method_signature": "YearMonthDay addToCopy(int)"}, "YearMonthDay.addWrapFieldToCopy": {"callee_method_names": ["YearMonthDay.getValues"], "method_name": "YearMonthDay.addWrapFieldToCopy", "method_implementation": "{\n    int[] newValues = iYearMonthDay.getValues();\n    newValues = getField().addWrapField(iYearMonthDay, iFieldIndex, newValues, valueToAdd);\n    return new YearMonthDay(iYearMonthDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Adds to the value of this field in a copy of this YearMonthDay wrapping\n * within this field if the maximum value is reached.\n * <p>\n * The value will be added to this field. If the value is too large to be\n * added solely to this field then it wraps within this field.\n * Other fields are unaffected.\n * <p>\n * For example,\n * <code>2004-12-20</code> addWrapField one month returns <code>2004-01-20</code>.\n * <p>\n * The YearMonthDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param valueToAdd  the value to add to the field in the copy\n * @return a copy of the YearMonthDay with the field value changed\n * @throws IllegalArgumentException if the value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 202, "method_signature": "YearMonthDay addWrapFieldToCopy(int)"}, "YearMonthDay.fromCalendarFields": {"callee_method_names": ["Calendar.get", "Calendar.get", "Calendar.get"], "method_name": "YearMonthDay.fromCalendarFields", "method_implementation": "{\n    if (calendar == null) {\n        throw new IllegalArgumentException(\"The calendar must not be null\");\n    }\n    return new YearMonthDay(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.DAY_OF_MONTH));\n}", "repo_id": "7", "comment": "/**\n * Constructs a YearMonthDay from a <code>java.util.Calendar</code>\n * using exactly the same field values avoiding any time zone effects.\n * <p>\n * Each field is queried from the Calendar and assigned to the YearMonthDay.\n * This is useful if you have been using the Calendar as a local date,\n * ignoring the zone.\n * <p>\n * This factory method ignores the type of the calendar and always\n * creates a YearMonthDay with ISO chronology. It is expected that you\n * will only pass in instances of <code>GregorianCalendar</code> however\n * this is not validated.\n *\n * @param calendar  the Calendar to extract fields from\n * @return the created YearMonthDay\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 189, "method_signature": "YearMonthDay fromCalendarFields(Calendar)"}, "YearMonthDay.fromDateFields": {"callee_method_names": ["Date.getYear", "Date.getMonth", "Date.getDate"], "method_name": "YearMonthDay.fromDateFields", "method_implementation": "{\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return new YearMonthDay(date.getYear() + 1900, date.getMonth() + 1, date.getDate());\n}", "repo_id": "7", "comment": "/**\n * Constructs a YearMonthDay from a <code>java.util.Date</code>\n * using exactly the same field values avoiding any time zone effects.\n * <p>\n * Each field is queried from the Date and assigned to the YearMonthDay.\n * This is useful if you have been using the Date as a local date,\n * ignoring the zone.\n * <p>\n * This factory method always creates a YearMonthDay with ISO chronology.\n *\n * @param date  the Date to extract fields from\n * @return the created YearMonthDay\n * @throws IllegalArgumentException if the calendar is null\n * @throws IllegalArgumentException if the date is invalid for the ISO chronology\n * @since 1.2\n */\n", "repo_name": "joda-time-main/", "id": 190, "method_signature": "YearMonthDay fromDateFields(Date)"}, "YearMonthDay.getField": {"callee_method_names": ["Chronology.year", "Chronology.monthOfYear", "Chronology.dayOfMonth"], "method_name": "YearMonthDay.getField", "method_implementation": "{\n    switch(index) {\n        case YEAR:\n            return chrono.year();\n        case MONTH_OF_YEAR:\n            return chrono.monthOfYear();\n        case DAY_OF_MONTH:\n            return chrono.dayOfMonth();\n        default:\n            throw new IndexOutOfBoundsException(\"Invalid index: \" + index);\n    }\n}", "repo_id": "7", "comment": "/**\n * Gets the field for a specific index in the chronology specified.\n * <p>\n * This method must not use any instance variables.\n *\n * @param index  the index to retrieve\n * @param chrono  the chronology to use\n * @return the field\n */\n", "repo_name": "joda-time-main/", "id": 191, "method_signature": "DateTimeField getField(int, Chronology)"}, "YearMonthDay.setCopy": {"callee_method_names": ["YearMonthDay.getValues"], "method_name": "YearMonthDay.setCopy", "method_implementation": "{\n    int[] newValues = iYearMonthDay.getValues();\n    newValues = getField().set(iYearMonthDay, iFieldIndex, newValues, text, locale);\n    return new YearMonthDay(iYearMonthDay, newValues);\n}", "repo_id": "7", "comment": "/**\n * Sets this field in a copy of the YearMonthDay to a parsed text value.\n * <p>\n * The YearMonthDay attached to this property is unchanged by this call.\n * Instead, a new instance is returned.\n *\n * @param text  the text value to set\n * @param locale  optional locale to use for selecting a text symbol\n * @return a copy of the YearMonthDay with the field value changed\n * @throws IllegalArgumentException if the text value isn't valid\n */\n", "repo_name": "joda-time-main/", "id": 204, "method_signature": "YearMonthDay setCopy(String, Locale)"}, "YearMonthDay.toDateTime": {"callee_method_names": ["Chronology.set", "Chronology.set"], "method_name": "YearMonthDay.toDateTime", "method_implementation": "{\n    Chronology chrono = getChronology().withZone(zone);\n    long instant = DateTimeUtils.currentTimeMillis();\n    instant = chrono.set(this, instant);\n    if (time != null) {\n        instant = chrono.set(time, instant);\n    }\n    return new DateTime(instant, chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this object to a DateTime using a TimeOfDay to fill in the\n * missing fields.\n * This instance is immutable and unaffected by this method call.\n * <p>\n * The resulting chronology is determined by the chronology of this\n * YearMonthDay plus the time zone.\n * The chronology of the time is ignored - only the field values are used.\n *\n * @param time  the time of day to use, null means current time\n * @param zone  the zone to get the DateTime in, null means default\n * @return the DateTime instance\n */\n", "repo_name": "joda-time-main/", "id": 197, "method_signature": "DateTime toDateTime(TimeOfDay, DateTimeZone)"}, "YearMonthDay.toDateTimeAtCurrentTime": {"callee_method_names": ["Chronology.set"], "method_name": "YearMonthDay.toDateTimeAtCurrentTime", "method_implementation": "{\n    Chronology chrono = getChronology().withZone(zone);\n    long instantMillis = DateTimeUtils.currentTimeMillis();\n    long resolved = chrono.set(this, instantMillis);\n    return new DateTime(resolved, chrono);\n}", "repo_id": "7", "comment": "/**\n * Converts this partial to a full datetime using the specified time zone\n * setting the date fields from this instance and the time fields from\n * the current time.\n * <p>\n * This method uses the chronology from this instance plus the time zone\n * specified.\n *\n * @param zone  the zone to use, null means default\n * @return this date as a datetime with the time as the current time\n */\n", "repo_name": "joda-time-main/", "id": 196, "method_signature": "DateTime toDateTimeAtCurrentTime(DateTimeZone)"}, "YearMonthDay.withChronologyRetainFields": {"callee_method_names": ["Chronology.withUTC", "Chronology.validate"], "method_name": "YearMonthDay.withChronologyRetainFields", "method_implementation": "{\n    newChronology = DateTimeUtils.getChronology(newChronology);\n    newChronology = newChronology.withUTC();\n    if (newChronology == getChronology()) {\n        return this;\n    } else {\n        YearMonthDay newYearMonthDay = new YearMonthDay(this, newChronology);\n        newChronology.validate(newYearMonthDay, getValues());\n        return newYearMonthDay;\n    }\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the specified chronology.\n * This instance is immutable and unaffected by this method call.\n * <p>\n * This method retains the values of the fields, thus the result will\n * typically refer to a different instant.\n * <p>\n * The time zone of the specified chronology is ignored, as YearMonthDay\n * operates without a time zone.\n *\n * @param newChronology  the new chronology, null means ISO\n * @return a copy of this datetime with a different chronology\n * @throws IllegalArgumentException if the values are invalid for the new chronology\n */\n", "repo_name": "joda-time-main/", "id": 192, "method_signature": "YearMonthDay withChronologyRetainFields(Chronology)"}, "YearMonthDay.withDayOfMonth": {"callee_method_names": [], "method_name": "YearMonthDay.withDayOfMonth", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth);\n    return new YearMonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the day of month field updated.\n * <p>\n * YearMonthDay is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * day of month changed.\n *\n * @param dayOfMonth  the day of month to set\n * @return a copy of this object with the field set\n * @throws IllegalArgumentException if the value is invalid\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 200, "method_signature": "YearMonthDay withDayOfMonth(int)"}, "YearMonthDay.withField": {"callee_method_names": [], "method_name": "YearMonthDay.withField", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (value == getValue(index)) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).set(this, index, newValues, value);\n    return new YearMonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the specified field set to a new value.\n * <p>\n * For example, if the field type is <code>dayOfMonth</code> then the day\n * would be changed in the returned instance.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * YearMonthDay updated = ymd.withField(DateTimeFieldType.dayOfMonth(), 6);\n * YearMonthDay updated = ymd.dayOfMonth().setCopy(6);\n * YearMonthDay updated = ymd.property(DateTimeFieldType.dayOfMonth()).setCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to set, not null\n * @param value  the value to set\n * @return a copy of this instance with the field set\n * @throws IllegalArgumentException if the value is null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 193, "method_signature": "YearMonthDay withField(DateTimeFieldType, int)"}, "YearMonthDay.withFieldAdded": {"callee_method_names": [], "method_name": "YearMonthDay.withFieldAdded", "method_implementation": "{\n    int index = indexOfSupported(fieldType);\n    if (amount == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    newValues = getField(index).add(this, index, newValues, amount);\n    return new YearMonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the value of the specified field increased.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * <p>\n * These three lines are equivalent:\n * <pre>\n * YearMonthDay added = ymd.withFieldAdded(DurationFieldType.days(), 6);\n * YearMonthDay added = ymd.plusDays(6);\n * YearMonthDay added = ymd.dayOfMonth().addToCopy(6);\n * </pre>\n *\n * @param fieldType  the field type to add to, not null\n * @param amount  the amount to add\n * @return a copy of this instance with the field updated\n * @throws IllegalArgumentException if the value is null or invalid\n * @throws ArithmeticException if the new datetime exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 194, "method_signature": "YearMonthDay withFieldAdded(DurationFieldType, int)"}, "YearMonthDay.withMonthOfYear": {"callee_method_names": [], "method_name": "YearMonthDay.withMonthOfYear", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear);\n    return new YearMonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the month of year field updated.\n * <p>\n * YearMonthDay is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * month of year changed.\n *\n * @param monthOfYear  the month of year to set\n * @return a copy of this object with the field set\n * @throws IllegalArgumentException if the value is invalid\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 199, "method_signature": "YearMonthDay withMonthOfYear(int)"}, "YearMonthDay.withPeriodAdded": {"callee_method_names": ["ReadablePeriod.size", "ReadablePeriod.getFieldType", "ReadablePeriod.getValue"], "method_name": "YearMonthDay.withPeriodAdded", "method_implementation": "{\n    if (period == null || scalar == 0) {\n        return this;\n    }\n    int[] newValues = getValues();\n    for (int i = 0; i < period.size(); i++) {\n        DurationFieldType fieldType = period.getFieldType(i);\n        int index = indexOf(fieldType);\n        if (index >= 0) {\n            newValues = getField(index).add(this, index, newValues, FieldUtils.safeMultiply(period.getValue(i), scalar));\n        }\n    }\n    return new YearMonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the specified period added.\n * <p>\n * If the addition is zero, then <code>this</code> is returned.\n * Fields in the period that aren't present in the partial are ignored.\n * <p>\n * This method is typically used to add multiple copies of complex\n * period instances. Adding one field is best achieved using methods\n * like {@link #withFieldAdded(DurationFieldType, int)}\n * or {@link #plusYears(int)}.\n *\n * @param period  the period to add to this one, null means zero\n * @param scalar  the amount of times to add, such as -1 to subtract once\n * @return a copy of this instance with the period added\n * @throws ArithmeticException if the new datetime exceeds the capacity\n */\n", "repo_name": "joda-time-main/", "id": 195, "method_signature": "YearMonthDay withPeriodAdded(ReadablePeriod, int)"}, "YearMonthDay.withYear": {"callee_method_names": [], "method_name": "YearMonthDay.withYear", "method_implementation": "{\n    int[] newValues = getValues();\n    newValues = getChronology().year().set(this, YEAR, newValues, year);\n    return new YearMonthDay(this, newValues);\n}", "repo_id": "7", "comment": "/**\n * Returns a copy of this date with the year field updated.\n * <p>\n * YearMonthDay is immutable, so there are no set methods.\n * Instead, this method returns a new instance with the value of\n * year changed.\n *\n * @param year  the year to set\n * @return a copy of this object with the field set\n * @throws IllegalArgumentException if the value is invalid\n * @since 1.3\n */\n", "repo_name": "joda-time-main/", "id": 198, "method_signature": "YearMonthDay withYear(int)"}, "Years.dividedBy": {"callee_method_names": [], "method_name": "Years.dividedBy", "method_implementation": "{\n    if (divisor == 1) {\n        return this;\n    }\n    return Years.years(getValue() / divisor);\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the years divided by the specified divisor.\n * The calculation uses integer division, thus 3 divided by 2 is 1.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param divisor  the amount to divide by, may be negative\n * @return the new period divided by the specified divisor\n * @throws ArithmeticException if the divisor is zero\n */\n", "repo_name": "joda-time-main/", "id": 245, "method_signature": "Years dividedBy(int)"}, "Years.isGreaterThan": {"callee_method_names": ["Years.getValue"], "method_name": "Years.isGreaterThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() > 0;\n    }\n    return getValue() > other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this years instance greater than the specified number of years.\n *\n * @param other  the other period, null means zero\n * @return true if this years instance is greater than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 246, "method_signature": "boolean isGreaterThan(Years)"}, "Years.isLessThan": {"callee_method_names": ["Years.getValue"], "method_name": "Years.isLessThan", "method_implementation": "{\n    if (other == null) {\n        return getValue() < 0;\n    }\n    return getValue() < other.getValue();\n}", "repo_id": "7", "comment": "/**\n * Is this years instance less than the specified number of years.\n *\n * @param other  the other period, null means zero\n * @return true if this years instance is less than the specified one\n */\n", "repo_name": "joda-time-main/", "id": 247, "method_signature": "boolean isLessThan(Years)"}, "Years.minus": {"callee_method_names": ["Years.getValue"], "method_name": "Years.minus", "method_implementation": "{\n    if (years == null) {\n        return this;\n    }\n    return minus(years.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of years taken away.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param years  the amount of years to take away, may be negative, null means zero\n * @return the new period minus the specified number of years\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 244, "method_signature": "Years minus(Years)"}, "Years.parseYears": {"callee_method_ids": [908], "callee_method_names": ["PeriodFormatter.parsePeriod", "Period.getYears"], "method_name": "Years.parseYears", "method_implementation": "{\n    if (periodStr == null) {\n        return Years.ZERO;\n    }\n    Period p = PARSER.parsePeriod(periodStr);\n    return Years.years(p.getYears());\n}", "repo_id": "7", "comment": "/**\n * Creates a new <code>Years</code> by parsing a string in the ISO8601 format 'PnY'.\n * <p>\n * The parse will accept the full ISO syntax of PnYnMnWnDTnHnMnS however only the\n * years component may be non-zero. If any other component is non-zero, an exception\n * will be thrown.\n *\n * @param periodStr  the period string, null returns zero\n * @return the period in years\n * @throws IllegalArgumentException if the string format is invalid\n */\n", "repo_name": "joda-time-main/", "id": 241, "method_signature": "Years parseYears(String)"}, "Years.plus": {"callee_method_names": ["Years.getValue"], "method_name": "Years.plus", "method_implementation": "{\n    if (years == null) {\n        return this;\n    }\n    return plus(years.getValue());\n}", "repo_id": "7", "comment": "/**\n * Returns a new instance with the specified number of years added.\n * <p>\n * This instance is immutable and unaffected by this method call.\n *\n * @param years  the amount of years to add, may be negative, null means zero\n * @return the new period plus the specified number of years\n * @throws ArithmeticException if the result overflows an int\n */\n", "repo_name": "joda-time-main/", "id": 243, "method_signature": "Years plus(Years)"}, "Years.toString": {"callee_method_names": [], "method_name": "Years.toString", "method_implementation": "{\n    return \"P\" + String.valueOf(getValue()) + \"Y\";\n}", "repo_id": "7", "comment": "/**\n * Gets this instance as a String in the ISO8601 duration format.\n * <p>\n * For example, \"P4Y\" represents 4 years.\n *\n * @return the value as an ISO8601 string\n */\n", "repo_name": "joda-time-main/", "id": 248, "method_signature": "String toString()"}, "Years.years": {"callee_method_names": [], "method_name": "Years.years", "method_implementation": "{\n    switch(years) {\n        case 0:\n            return ZERO;\n        case 1:\n            return ONE;\n        case 2:\n            return TWO;\n        case 3:\n            return THREE;\n        case Integer.MAX_VALUE:\n            return MAX_VALUE;\n        case Integer.MIN_VALUE:\n            return MIN_VALUE;\n        default:\n            return new Years(years);\n    }\n}", "repo_id": "7", "comment": "/**\n * Obtains an instance of <code>Years</code> that may be cached.\n * <code>Years</code> is immutable, so instances can be cached and shared.\n * This factory method provides access to shared instances.\n *\n * @param years  the number of years to obtain an instance for\n * @return the instance of Years\n */\n", "repo_name": "joda-time-main/", "id": 238, "method_signature": "Years years(int)"}, "Years.yearsBetween": {"callee_method_names": ["ReadablePartial.getChronology", "Chronology.years"], "method_name": "Years.yearsBetween", "method_implementation": "{\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int years = chrono.years().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return Years.years(years);\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return Years.years(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Years</code> representing the number of whole years\n * between the two specified partial datetimes.\n * <p>\n * The two partials must contain the same fields, for example you can specify\n * two <code>LocalDate</code> objects.\n *\n * @param start  the start partial date, must not be null\n * @param end  the end partial date, must not be null\n * @return the period in years\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 239, "method_signature": "Years yearsBetween(ReadablePartial, ReadablePartial)"}, "Years.yearsIn": {"callee_method_names": ["ReadableInterval.getStart", "ReadableInterval.getEnd"], "method_name": "Years.yearsIn", "method_implementation": "{\n    if (interval == null) {\n        return Years.ZERO;\n    }\n    int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.years());\n    return Years.years(amount);\n}", "repo_id": "7", "comment": "/**\n * Creates a <code>Years</code> representing the number of whole years\n * in the specified interval. This method correctly handles any daylight\n * savings time changes that may occur during the interval.\n *\n * @param interval  the interval to extract years from, null returns zero\n * @return the period in years\n * @throws IllegalArgumentException if the partials are null or invalid\n */\n", "repo_name": "joda-time-main/", "id": 240, "method_signature": "Years yearsIn(ReadableInterval)"}, "ZoneInfoCompiler.addCutover": {"callee_method_ids": [745], "callee_method_names": ["DateTimeZoneBuilder.addCutover"], "method_name": "ZoneInfoCompiler.addCutover", "method_implementation": "{\n    builder.addCutover(year, iZoneChar, iMonthOfYear, iDayOfMonth, iDayOfWeek, iAdvanceDayOfWeek, iMillisOfDay);\n}", "repo_id": "7", "comment": "/**\n * Adds a cutover to the builder.\n *\n * @param builder  the builder\n * @param year  the year\n */\n", "repo_name": "joda-time-main/", "id": 733, "method_signature": "void addCutover(DateTimeZoneBuilder, int)"}, "ZoneInfoCompiler.addRecurring": {"callee_method_ids": [738, 738], "callee_method_names": ["String.size", "String.get", "String.get", "String.indexOf", "String.substring", "String.substring", "DateTimeZoneBuilder.setStandardOffset", "String.get", "Rule.addRecurring", "String.size", "String.get", "Rule.addRecurring"], "method_name": "ZoneInfoCompiler.addRecurring", "method_implementation": "{\n    // a hack is necessary to remove negative SAVE values from the input tzdb file\n    // negative save values cause the standard offset to be set in the summer instead of the winter\n    // this causes the wrong name to be chosen from the CLDR data\n    // check if the ruleset has negative SAVE values\n    int negativeSave = 0;\n    for (int i = 0; i < iRules.size(); i++) {\n        Rule rule = iRules.get(i);\n        if (rule.iSaveMillis < 0) {\n            negativeSave = Math.min(negativeSave, rule.iSaveMillis);\n        }\n    }\n    // if negative SAVE values, then patch standard millis and name format\n    if (negativeSave < 0) {\n        System.out.println(\"Fixed negative save values for rule '\" + iRules.get(0).iName + \"'\");\n        standardMillis += negativeSave;\n        int slashPos = nameFormat.indexOf(\"/\");\n        if (slashPos > 0) {\n            nameFormat = nameFormat.substring(slashPos + 1) + \"/\" + nameFormat.substring(0, slashPos);\n        }\n    }\n    builder.setStandardOffset(standardMillis);\n    // add a fake rule that predates all other rules to ensure standard=summer (see Namibia)\n    if (negativeSave < 0) {\n        Rule rule = new Rule(iRules.get(0));\n        rule.addRecurring(builder, negativeSave, nameFormat);\n    }\n    // add each rule, passing through the negative save to alter the actual iSaveMillis value that is used\n    for (int i = 0; i < iRules.size(); i++) {\n        Rule rule = iRules.get(i);\n        rule.addRecurring(builder, negativeSave, nameFormat);\n    }\n}", "repo_id": "7", "comment": "/**\n * Adds recurring savings rules to the builder.\n *\n * @param builder  the builder\n * @param standardMillis  the standard millis\n * @param nameFormat  the name format\n */\n", "repo_name": "joda-time-main/", "id": 735, "method_signature": "void addRecurring(DateTimeZoneBuilder, int, String)"}, "ZoneInfoCompiler.compile": {"callee_method_ids": [747, 747], "callee_method_names": ["File[].getName", "BufferedReader.close", "File.exists", "File.mkdirs", "File.isDirectory", "List<Zone>.size", "List<Zone>.get", "Zone.addToBuilder", "DateTimeZoneBuilder.toDateTimeZone", "DateTimeZone.getID", "Map<String, DateTimeZone>.put", "DateTimeZone.getID", "Map<String, Zone>.put", "DateTimeZone.getID", "List<String>.size", "List<String>.get", "List<String>.get", "Map<String, Zone>.get", "Zone.addToBuilder", "DateTimeZoneBuilder.toDateTimeZone", "DateTimeZone.getID", "Map<String, DateTimeZone>.put", "DateTimeZone.getID", "Map<String, DateTimeZone>.put", "DateTimeZone.getID", "List<String>.size", "List<String>.get", "List<String>.get", "Map<String, DateTimeZone>.get", "Map<String, DateTimeZone>.put", "DateTimeZone.getID", "File.getParentFile", "File.getParentFile", "Map<String, DateTimeZone>.putAll", "DataOutputStream.close"], "method_name": "ZoneInfoCompiler.compile", "method_implementation": "{\n    if (sources != null) {\n        for (int i = 0; i < sources.length; i++) {\n            BufferedReader in = null;\n            try {\n                in = new BufferedReader(new FileReader(sources[i]));\n                parseDataFile(in, \"backward\".equals(sources[i].getName()));\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        }\n    }\n    if (outputDir != null) {\n        if (!outputDir.exists() && !outputDir.mkdirs()) {\n            throw new IOException(\"Destination directory doesn't exist and cannot be created: \" + outputDir);\n        }\n        if (!outputDir.isDirectory()) {\n            throw new IOException(\"Destination is not a directory: \" + outputDir);\n        }\n    }\n    Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();\n    Map<String, Zone> sourceMap = new TreeMap<String, Zone>();\n    System.out.println(\"Writing zoneinfo files\");\n    // write out the standard entries\n    for (int i = 0; i < iZones.size(); i++) {\n        Zone zone = iZones.get(i);\n        DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n        zone.addToBuilder(builder, iRuleSets);\n        DateTimeZone tz = builder.toDateTimeZone(zone.iName, true);\n        if (test(tz.getID(), tz)) {\n            map.put(tz.getID(), tz);\n            sourceMap.put(tz.getID(), zone);\n            if (outputDir != null) {\n                writeZone(outputDir, builder, tz);\n            }\n        }\n    }\n    // revive zones from \"good\" links\n    for (int i = 0; i < iGoodLinks.size(); i += 2) {\n        String baseId = iGoodLinks.get(i);\n        String alias = iGoodLinks.get(i + 1);\n        Zone sourceZone = sourceMap.get(baseId);\n        if (sourceZone == null) {\n            System.out.println(\"Cannot find source zone '\" + baseId + \"' to link alias '\" + alias + \"' to\");\n        } else {\n            DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n            sourceZone.addToBuilder(builder, iRuleSets);\n            DateTimeZone revived = builder.toDateTimeZone(alias, true);\n            if (test(revived.getID(), revived)) {\n                map.put(revived.getID(), revived);\n                if (outputDir != null) {\n                    writeZone(outputDir, builder, revived);\n                }\n            }\n            map.put(revived.getID(), revived);\n            if (ZoneInfoLogger.verbose()) {\n                System.out.println(\"Good link: \" + alias + \" -> \" + baseId + \" revived\");\n            }\n        }\n    }\n    // store \"back\" links as aliases (where name is permanently mapped\n    for (int pass = 0; pass < 2; pass++) {\n        for (int i = 0; i < iBackLinks.size(); i += 2) {\n            String id = iBackLinks.get(i);\n            String alias = iBackLinks.get(i + 1);\n            DateTimeZone tz = map.get(id);\n            if (tz == null) {\n                if (pass > 0) {\n                    System.out.println(\"Cannot find time zone '\" + id + \"' to link alias '\" + alias + \"' to\");\n                }\n            } else {\n                map.put(alias, tz);\n                if (ZoneInfoLogger.verbose()) {\n                    System.out.println(\"Back link: \" + alias + \" -> \" + tz.getID());\n                }\n            }\n        }\n    }\n    // write map that unites the time-zone data, pointing aliases and real zones at files\n    if (outputDir != null) {\n        System.out.println(\"Writing ZoneInfoMap\");\n        File file = new File(outputDir, \"ZoneInfoMap\");\n        if (!file.getParentFile().exists()) {\n            file.getParentFile().mkdirs();\n        }\n        OutputStream out = new FileOutputStream(file);\n        DataOutputStream dout = new DataOutputStream(out);\n        try {\n            // Sort and filter out any duplicates that match case.\n            Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n            zimap.putAll(map);\n            writeZoneInfoMap(dout, zimap);\n        } finally {\n            dout.close();\n        }\n    }\n    return map;\n}", "repo_id": "7", "comment": "/**\n * Returns a map of ids to DateTimeZones.\n *\n * @param outputDir optional directory to write compiled data files to\n * @param sources optional list of source files to parse\n */\n", "repo_name": "joda-time-main/", "id": 731, "method_signature": "Map<String,DateTimeZone> compile(File, File[])"}, "ZoneInfoCompiler.main": {"callee_method_ids": [731], "callee_method_names": ["ZoneInfoCompiler.compile"], "method_name": "ZoneInfoCompiler.main", "method_implementation": "{\n    if (args.length == 0) {\n        printUsage();\n        return;\n    }\n    File inputDir = null;\n    File outputDir = null;\n    boolean verbose = false;\n    int i;\n    for (i = 0; i < args.length; i++) {\n        if (\"-src\".equals(args[i])) {\n            if (++i >= args.length) {\n                printUsage();\n                return;\n            }\n            inputDir = new File(args[i]);\n        } else if (\"-dst\".equals(args[i])) {\n            if (++i >= args.length) {\n                printUsage();\n                return;\n            }\n            outputDir = new File(args[i]);\n        } else if (\"-verbose\".equals(args[i])) {\n            verbose = true;\n        } else if (\"-?\".equals(args[i])) {\n            printUsage();\n            return;\n        } else {\n            break;\n        }\n    }\n    if (i >= args.length) {\n        printUsage();\n        return;\n    }\n    File[] sources = new File[args.length - i];\n    for (int j = 0; i < args.length; i++, j++) {\n        sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);\n    }\n    ZoneInfoLogger.set(verbose);\n    ZoneInfoCompiler zic = new ZoneInfoCompiler();\n    zic.compile(outputDir, sources);\n}", "repo_id": "7", "comment": "/**\n * Launches the ZoneInfoCompiler tool.\n *\n * <pre>\n * Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;\n * where possible options include:\n *   -src &lt;directory&gt;    Specify where to read source files\n *   -dst &lt;directory&gt;    Specify where to write generated files\n *   -verbose            Output verbosely (default false)\n * </pre>\n */\n", "repo_name": "joda-time-main/", "id": 728, "method_signature": "void main(String[])"}, "ZoneInfoCompiler.test": {"callee_method_ids": [114, 114], "callee_method_names": ["String.equals", "DateTimeZone.getID", "DateTimeZone.getOffset", "DateTimeZone.getStandardOffset", "DateTimeZone.getNameKey", "DateTimeZone.nextTransition", "DateTimeZone.getOffset", "DateTimeZone.getStandardOffset", "DateTimeZone.getNameKey", "String.equals", "DateTimeZone.getID", "String.length", "DateTimeZone.getID", "List<Long>.add", "List<Long>.size", "DateTimeZone.previousTransition", "List<Long>.get", "DateTimeZone.getID"], "method_name": "ZoneInfoCompiler.test", "method_implementation": "{\n    if (!id.equals(tz.getID())) {\n        return true;\n    }\n    // Test to ensure that reported transitions are not duplicated.\n    long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);\n    long end = ISOChronology.getInstanceUTC().year().set(0, 2050);\n    int offset = tz.getOffset(millis);\n    int stdOffset = tz.getStandardOffset(millis);\n    String key = tz.getNameKey(millis);\n    List<Long> transitions = new ArrayList<Long>();\n    while (true) {\n        long next = tz.nextTransition(millis);\n        if (next == millis || next > end) {\n            break;\n        }\n        millis = next;\n        int nextOffset = tz.getOffset(millis);\n        int nextStdOffset = tz.getStandardOffset(millis);\n        String nextKey = tz.getNameKey(millis);\n        if (offset == nextOffset && stdOffset == nextStdOffset && key.equals(nextKey)) {\n            System.out.println(\"*d* Error in \" + tz.getID() + \" \" + new DateTime(millis, ISOChronology.getInstanceUTC()));\n            return false;\n        }\n        if (nextKey == null || (nextKey.length() < 3 && !\"??\".equals(nextKey))) {\n            System.out.println(\"*s* Error in \" + tz.getID() + \" \" + new DateTime(millis, ISOChronology.getInstanceUTC()) + \", nameKey=\" + nextKey);\n            return false;\n        }\n        transitions.add(Long.valueOf(millis));\n        offset = nextOffset;\n        key = nextKey;\n    }\n    // Now verify that reverse transitions match up.\n    millis = ISOChronology.getInstanceUTC().year().set(0, 2050);\n    end = ISOChronology.getInstanceUTC().year().set(0, 1850);\n    for (int i = transitions.size(); --i >= 0; ) {\n        long prev = tz.previousTransition(millis);\n        if (prev == millis || prev < end) {\n            break;\n        }\n        millis = prev;\n        long trans = transitions.get(i).longValue();\n        if (trans - 1 != millis) {\n            System.out.println(\"*r* Error in \" + tz.getID() + \" \" + new DateTime(millis, ISOChronology.getInstanceUTC()) + \" != \" + new DateTime(trans - 1, ISOChronology.getInstanceUTC()));\n            return false;\n        }\n    }\n    return true;\n}", "repo_id": "7", "comment": "/**\n * @return false if error.\n */\n", "repo_name": "joda-time-main/", "id": 730, "method_signature": "boolean test(String, DateTimeZone)"}, "ZoneInfoCompiler.writeZoneInfoMap": {"callee_method_names": ["Map<String,DateTimeZone>.size", "Map<String,DateTimeZone>.entrySet", "Map<String, Short>.containsKey", "Map<String, Short>.put", "TreeMap<Short, String>.put", "Map<String, Short>.containsKey", "Map<String, Short>.put", "TreeMap<Short, String>.put", "DataOutputStream.writeShort", "TreeMap<Short, String>.size", "TreeMap<Short, String>.values", "DataOutputStream.writeUTF", "DataOutputStream.writeShort", "Map<String,DateTimeZone>.size", "Map<String,DateTimeZone>.entrySet", "DataOutputStream.writeShort", "Map<String, Short>.get", "DataOutputStream.writeShort", "Map<String, Short>.get"], "method_name": "ZoneInfoCompiler.writeZoneInfoMap", "method_implementation": "{\n    if (dout == null) {\n        throw new IllegalArgumentException(\"DataOutputStream must not be null.\");\n    }\n    // Build the string pool.\n    Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());\n    TreeMap<Short, String> indexToId = new TreeMap<Short, String>();\n    short count = 0;\n    for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n        String id = (String) entry.getKey();\n        if (!idToIndex.containsKey(id)) {\n            Short index = Short.valueOf(count);\n            idToIndex.put(id, index);\n            indexToId.put(index, id);\n            if (++count == Short.MAX_VALUE) {\n                throw new InternalError(\"Too many time zone ids\");\n            }\n        }\n        id = ((DateTimeZone) entry.getValue()).getID();\n        if (!idToIndex.containsKey(id)) {\n            Short index = Short.valueOf(count);\n            idToIndex.put(id, index);\n            indexToId.put(index, id);\n            if (++count == Short.MAX_VALUE) {\n                throw new InternalError(\"Too many time zone ids\");\n            }\n        }\n    }\n    // Write the string pool, ordered by index.\n    dout.writeShort(indexToId.size());\n    for (String id : indexToId.values()) {\n        dout.writeUTF(id);\n    }\n    // Write the mappings.\n    dout.writeShort(zimap.size());\n    for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n        String id = entry.getKey();\n        dout.writeShort(idToIndex.get(id).shortValue());\n        id = entry.getValue().getID();\n        dout.writeShort(idToIndex.get(id).shortValue());\n    }\n}", "repo_id": "7", "comment": "/**\n * @param zimap maps string ids to DateTimeZone objects.\n */\n", "repo_name": "joda-time-main/", "id": 729, "method_signature": "void writeZoneInfoMap(DataOutputStream, Map)"}, "ZoneInfoProvider.getZone": {"callee_method_names": ["Map<String, Object>.get", "SoftReference<DateTimeZone>.get", "String.equals"], "method_name": "ZoneInfoProvider.getZone", "method_implementation": "{\n    if (id == null) {\n        return null;\n    }\n    Object obj = iZoneInfoMap.get(id);\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof SoftReference<?>) {\n        @SuppressWarnings(\"unchecked\")\n        SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n        DateTimeZone tz = ref.get();\n        if (tz != null) {\n            return tz;\n        }\n        // Reference cleared; load data again.\n        return loadZoneData(id);\n    } else if (id.equals(obj)) {\n        // Load zone data for the first time.\n        return loadZoneData(id);\n    }\n    // If this point is reached, mapping must link to another.\n    return getZone((String) obj);\n}", "repo_id": "7", "comment": "/**\n * If an error is thrown while loading zone data, the exception is logged\n * to system error and null is returned for this and all future requests.\n *\n * @param id  the id to load\n * @return the loaded zone\n */\n", "repo_name": "joda-time-main/", "id": 723, "method_signature": "DateTimeZone getZone(String)"}, "ZoneInfoProvider.loadZoneData": {"callee_method_names": ["Map<String, Object>.put", "Map<String, Object>.remove", "InputStream.close"], "method_name": "ZoneInfoProvider.loadZoneData", "method_implementation": "{\n    InputStream in = null;\n    try {\n        in = openResource(id);\n        DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n        iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n        return tz;\n    } catch (IOException ex) {\n        uncaughtException(ex);\n        iZoneInfoMap.remove(id);\n        return null;\n    } finally {\n        try {\n            if (in != null) {\n                in.close();\n            }\n        } catch (IOException ex) {\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Loads the time zone data for one id.\n *\n * @param id  the id to load\n * @return the zone\n */\n", "repo_name": "joda-time-main/", "id": 725, "method_signature": "DateTimeZone loadZoneData(String)"}, "ZoneInfoProvider.loadZoneInfoMap": {"callee_method_names": ["DataInputStream.close", "Map<String, Object>.put"], "method_name": "ZoneInfoProvider.loadZoneInfoMap", "method_implementation": "{\n    Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n    DataInputStream din = new DataInputStream(in);\n    try {\n        readZoneInfoMap(din, map);\n    } finally {\n        try {\n            din.close();\n        } catch (IOException ex) {\n        }\n    }\n    map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n    return map;\n}", "repo_id": "7", "comment": "/**\n * Loads the zone info map.\n *\n * @param in  the input stream\n * @return the map\n */\n", "repo_name": "joda-time-main/", "id": 726, "method_signature": "Map<String,Object> loadZoneInfoMap(InputStream)"}, "ZoneInfoProvider.openResource": {"callee_method_names": ["String.concat", "ClassLoader.getResourceAsStream", "ClassLoader.toString", "StringBuilder.toString"], "method_name": "ZoneInfoProvider.openResource", "method_implementation": "{\n    InputStream in;\n    if (iFileDir != null) {\n        in = new FileInputStream(new File(iFileDir, name));\n    } else {\n        final String path = iResourcePath.concat(name);\n        in = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {\n\n            public InputStream run() {\n                if (iLoader != null) {\n                    return iLoader.getResourceAsStream(path);\n                } else {\n                    return ClassLoader.getSystemResourceAsStream(path);\n                }\n            }\n        });\n        if (in == null) {\n            StringBuilder buf = new StringBuilder(40).append(\"Resource not found: \\\"\").append(path).append(\"\\\" ClassLoader: \").append(iLoader != null ? iLoader.toString() : \"system\");\n            throw new IOException(buf.toString());\n        }\n    }\n    return in;\n}", "repo_id": "7", "comment": "/**\n * Opens a resource from file or classpath.\n *\n * @param name  the name to open\n * @return the input stream\n * @throws IOException if an error occurs\n */\n", "repo_name": "joda-time-main/", "id": 724, "method_signature": "InputStream openResource(String)"}, "ZoneInfoProvider.readZoneInfoMap": {"callee_method_names": ["DataInputStream.readUnsignedShort", "DataInputStream.readUTF", "DataInputStream.readUnsignedShort", "Map<String,Object>.put", "DataInputStream.readUnsignedShort", "DataInputStream.readUnsignedShort"], "method_name": "ZoneInfoProvider.readZoneInfoMap", "method_implementation": "{\n    // Read the string pool.\n    int size = din.readUnsignedShort();\n    String[] pool = new String[size];\n    for (int i = 0; i < size; i++) {\n        pool[i] = din.readUTF().intern();\n    }\n    // Read the mappings.\n    size = din.readUnsignedShort();\n    for (int i = 0; i < size; i++) {\n        try {\n            zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n        } catch (ArrayIndexOutOfBoundsException ex) {\n            throw new IOException(\"Corrupt zone info map\");\n        }\n    }\n}", "repo_id": "7", "comment": "/**\n * Reads the zone info map from file.\n *\n * @param din  the input stream\n * @param zimap  gets filled with string id to string id mappings\n */\n", "repo_name": "joda-time-main/", "id": 727, "method_signature": "void readZoneInfoMap(DataInputStream, Map)"}, "ZonedChronology.equals": {"callee_method_names": ["ZonedChronology.getBase", "ZonedChronology.getZone"], "method_name": "ZonedChronology.equals", "method_implementation": "{\n    if (this == obj) {\n        return true;\n    }\n    if (obj instanceof ZonedChronology == false) {\n        return false;\n    }\n    ZonedChronology chrono = (ZonedChronology) obj;\n    return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone());\n}", "repo_id": "7", "comment": "/**\n * A zoned chronology is only equal to a zoned chronology with the\n * same base chronology and zone.\n *\n * @param obj  the object to compare to\n * @return true if equal\n * @since 1.4\n */\n", "repo_name": "joda-time-main/", "id": 297, "method_signature": "boolean equals(Object)"}, "ZonedChronology.getInstance": {"callee_method_names": ["Chronology.withUTC"], "method_name": "ZonedChronology.getInstance", "method_implementation": "{\n    if (base == null) {\n        throw new IllegalArgumentException(\"Must supply a chronology\");\n    }\n    base = base.withUTC();\n    if (base == null) {\n        throw new IllegalArgumentException(\"UTC chronology must not be null\");\n    }\n    if (zone == null) {\n        throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n    }\n    return new ZonedChronology(base, zone);\n}", "repo_id": "7", "comment": "/**\n * Create a ZonedChronology for any chronology, overriding any time zone it\n * may already have.\n *\n * @param base base chronology to wrap\n * @param zone the time zone\n * @return the chronology, not null\n * @throws IllegalArgumentException if chronology or time zone is null\n */\n", "repo_name": "joda-time-main/", "id": 295, "method_signature": "ZonedChronology getInstance(Chronology, DateTimeZone)"}, "ZonedChronology.localToUTC": {"callee_method_ids": [115, 114], "callee_method_names": ["DateTimeZone.getOffsetFromLocal", "DateTimeZone.getOffset", "DateTimeZone.getID"], "method_name": "ZonedChronology.localToUTC", "method_implementation": "{\n    if (localInstant == Long.MAX_VALUE) {\n        return Long.MAX_VALUE;\n    } else if (localInstant == Long.MIN_VALUE) {\n        return Long.MIN_VALUE;\n    }\n    DateTimeZone zone = getZone();\n    int offset = zone.getOffsetFromLocal(localInstant);\n    long utcInstant = localInstant - offset;\n    if (localInstant > NEAR_ZERO && utcInstant < 0) {\n        return Long.MAX_VALUE;\n    } else if (localInstant < -NEAR_ZERO && utcInstant > 0) {\n        return Long.MIN_VALUE;\n    }\n    int offsetBasedOnUtc = zone.getOffset(utcInstant);\n    if (offset != offsetBasedOnUtc) {\n        throw new IllegalInstantException(localInstant, zone.getID());\n    }\n    return utcInstant;\n}", "repo_id": "7", "comment": "/**\n * @param localInstant  the instant from 1970-01-01T00:00:00 local time\n * @return the instant from 1970-01-01T00:00:00Z\n */\n", "repo_name": "joda-time-main/", "id": 296, "method_signature": "long localToUTC(long)"}}