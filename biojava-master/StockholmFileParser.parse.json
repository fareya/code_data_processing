{"callee_method_names":["Scanner.hasNextLine","Scanner.nextLine","String.trim","String.startsWith","String.startsWith","String.indexOf","String.substring","String.substring","String.startsWith","String.indexOf","String.substring","String.substring","String.startsWith","String.indexOf","String.substring","String.charAt","String.indexOf","String.substring","String.substring","String.startsWith","String.indexOf","String.substring","String.charAt","String.indexOf","String.substring","String.substring","String.startsWith","String.split","String.trim","Logger.error","StockholmStructure.getSequences","Map<String, StringBuffer>.keySet","Map<String, StringBuffer>.get","StringBuffer.length","StringBuffer.length"],"method_name":"StockholmFileParser.parse","method_implementation":"{\n    if (scanner == null) {\n        if (internalScanner != null) {\n            scanner = internalScanner;\n        } else {\n            throw new IllegalArgumentException(\"No Scanner defined\");\n        }\n    }\n    String line = null;\n    int linesCount = 0;\n    try {\n        while (scanner.hasNextLine()) {\n            line = scanner.nextLine();\n            // if the file is empty\n            // this condition will not happen, just left in case we decided to go for buffereedReader again for\n            // performance purpose.\n            if (linesCount == 0 && line == null) {\n                throw new IOException(\"Could not parse Stockholm file, BufferedReader returns null!\");\n            }\n            // ignore empty lines\n            if ((/* status==STATUS_INSIDE_FILE && */\n            line == null) || line.trim().length() == 0) {\n                continue;\n            }\n            if (line.startsWith(\"#=G\")) {\n                // // comment line or metadata\n                // line = line.substring(1).trim();\n                // line = line.substring(1).trim();\n                if (line.startsWith(GENERIC_PER_FILE_ANNOTATION, 2)) {\n                    // #=GF <featurename> <generic per-file annotation, free text>\n                    int firstSpaceIndex = line.indexOf(' ', 5);\n                    String featureName = line.substring(5, firstSpaceIndex);\n                    String value = line.substring(firstSpaceIndex).trim();\n                    handleFileAnnotation(featureName, value);\n                } else if (line.startsWith(GENERIC_PER_CONSENSUS_ANNOTATION, 2)) {\n                    // Being in a consensus means we are no longer in a sequence.\n                    // this.status = STATUS_INSIDE_FILE;\n                    // #=GC <featurename> <generic per-column annotation, exactly 1 char per column>\n                    int firstSpaceIndex = line.indexOf(' ', 5);\n                    String featureName = line.substring(5, firstSpaceIndex);\n                    String value = line.substring(firstSpaceIndex).trim();\n                    handleConsensusAnnotation(featureName, value);\n                } else if (line.startsWith(GENERIC_PER_SEQUENCE_ANNOTATION, 2)) {\n                    // #=GS <seqname> <featurename> <generic per-sequence annotation, free text>\n                    int index1 = line.indexOf(' ', 5);\n                    String seqName = line.substring(5, index1);\n                    while (line.charAt(++index1) <= ' ') // i.e. white space\n                    ;\n                    // keep advancing\n                    int index2 = line.indexOf(' ', index1);\n                    String featureName = line.substring(index1, index2);\n                    String value = line.substring(index2).trim();\n                    handleSequenceAnnotation(seqName, featureName, value);\n                } else if (line.startsWith(GENERIC_PER_RESIDUE_ANNOTATION, 2)) {\n                    // #=GR <seqname> <featurename> <generic per-sequence AND per-column mark-up, exactly 1\n                    // character per column>\n                    int index1 = line.indexOf(' ', 5);\n                    String seqName = line.substring(5, index1);\n                    while (line.charAt(++index1) == ' ') // keep advancing\n                    ;\n                    int index2 = line.indexOf(' ', index1);\n                    String featureName = line.substring(index1, index2);\n                    String value = line.substring(index2).trim();\n                    handleResidueAnnotation(seqName, featureName, value);\n                }\n            } else if (line.startsWith(\"# STOCKHOLM\")) {\n                // it is the header line\n                // if (status == STATUS_OUTSIDE_FILE) {\n                // status = STATUS_INSIDE_FILE;\n                // String[] header = line.split(\"\\\\s+\");\n                // this.stockholmStructure = new StockholmStructure();\n                // this.stockholmStructure.getFileAnnotation().setFormat(header[1]);\n                // this.stockholmStructure.getFileAnnotation().setVersion(header[2]);\n                // } else {\n                // throw new ParserException(\"Uexpected Format line: [\" + line + \"]\");\n                // }\n                String[] header = line.split(\"\\\\s+\");\n                this.stockholmStructure = new StockholmStructure();\n                this.stockholmStructure.getFileAnnotation().setFormat(header[1]);\n                this.stockholmStructure.getFileAnnotation().setVersion(header[2]);\n            } else if (\"//\".equals(line.trim())) {\n                // status = STATUS_OUTSIDE_FILE;\n                // should we just break immediately or jump next empty lines?\n                break;\n            } else /* if (!line.startsWith(\"#\")) */\n            {\n                // most probably This line corresponds to a sequence. Something like:\n                // O83071/192-246 MTCRAQLIAVPRASSLAEAIACAQKMRVSRVPVYERS\n                // N.B. as long as we don't check the status now, it is somehow error prone\n                handleSequenceLine(line);\n                // //============removed status==========================\n                // if (status == STATUS_IN_SEQUENCE) {\n                // // This line corresponds to a sequence. Something like:\n                // // O83071/192-246 MTCRAQLIAVPRASSLAEAIACAQKMRVSRVPVYERS\n                // handleSequenceLine(line);\n                // // }else if (status==STATUS_OUTSIDE_FILE) {\n                // // throw new\n                // //\n                // ParserException(\"The end of file character was allready reached but there are still sequence lines\");\n                // } else {\n                // System.err.println(\"Error: Unknown or unexpected line [\" + line\n                // + \"].\\nPlease contact the Biojava team.\");\n                // throw new ParserException(\"Error: Unknown or unexpected line [\" + line + \"].\");\n                // }\n                // //============removed status==========================\n            }\n            linesCount++;\n        }\n    } catch (IOException e) {\n        // TODO: Best practice is to catch or throw Exception, never both\n        logger.error(\"IOException: \", e);\n        throw new IOException(\"Error parsing Stockholm file\");\n    }\n    StockholmStructure structure = this.stockholmStructure;\n    this.stockholmStructure = null;\n    if (structure != null) {\n        int length = -1;\n        Map<String, StringBuffer> sequences = structure.getSequences();\n        for (String sequencename : sequences.keySet()) {\n            StringBuffer sequence = sequences.get(sequencename);\n            if (length == -1) {\n                length = sequence.length();\n            } else if (length != sequence.length()) {\n                throw new RuntimeException(\"Sequences have different lengths\");\n            }\n        }\n    }\n    return structure;\n}","repo_id":"9","comment":"/**\n * Parses a Stockholm file and returns a {@link StockholmStructure} object with its content. This method returns\n * just after reaching the end of structure delimiter line (\"//\"), leaving any remaining empty lines unconsumed.\n *\n * @param scanner\n *            from where to read the file content\n * @return Stockholm file content, <code>null<\/code> if couldn't or no more structures.\n * @throws IOException\n * @throws Exception\n */\n","repo_name":"biojava-master/","id":18,"method_signature":"StockholmStructure parse(Scanner)"}