{"callee_method_names":["Atom.clone","Atom.clone"],"method_name":"RotationAxis.getAxisEnds","method_implementation":"{\n    // Project each Atom onto the rotation axis to determine limits\n    double min, max;\n    min = max = Calc.scalarProduct(rotationAxis, atoms[0]);\n    for (int i = 1; i < atoms.length; i++) {\n        double prod = Calc.scalarProduct(rotationAxis, atoms[i]);\n        if (prod < min)\n            min = prod;\n        if (prod > max)\n            max = prod;\n    }\n    // Should be 1, but double check\n    double uLen = Calc.scalarProduct(rotationAxis, rotationAxis);\n    min /= uLen;\n    max /= uLen;\n    // Project the origin onto the axis. If the axis is undefined, use the center of mass\n    Atom axialPt;\n    if (rotationPos == null) {\n        Atom center = Calc.centerOfMass(atoms);\n        // Project center onto the axis\n        Atom centerOnAxis = Calc.scale(rotationAxis, Calc.scalarProduct(center, rotationAxis));\n        // Remainder is projection of origin onto axis\n        axialPt = Calc.subtract(center, centerOnAxis);\n    } else {\n        axialPt = rotationPos;\n    }\n    // Find end points of the rotation axis to display\n    Atom axisMin = (Atom) axialPt.clone();\n    Calc.scaleAdd(min, rotationAxis, axisMin);\n    Atom axisMax = (Atom) axialPt.clone();\n    Calc.scaleAdd(max, rotationAxis, axisMax);\n    return new Pair<>(axisMin, axisMax);\n}","repo_id":"9","comment":"/**\n * Find a segment of the axis that covers the specified set of atoms.\n * <p>\n * Projects the input atoms onto the rotation axis and returns the bounding\n * points.\n * <p>\n * In the case of a pure translational axis, the axis location is undefined\n * so the center of mass will be used instead.\n * @param atoms\n * @return two points defining the axis segment\n */\n","repo_name":"biojava-master/","id":569,"method_signature":"Pair<Atom> getAxisEnds(Atom[])"}