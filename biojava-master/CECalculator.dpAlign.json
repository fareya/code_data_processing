{"callee_method_names":[],"method_name":"CECalculator.dpAlign","method_implementation":"{\n    // isGlobal1,isGlobal2 are always false...\n    int i, j, is, js, iMax, jMax, k;\n    boolean ge = (gapE != 0.0 ? true : false);\n    double sum, sum_ret, sum_brk;\n    boolean[][] brk_flg = new boolean[nSeq1][nSeq2];\n    for (i = 0; i < nSeq1; i++) brk_flg[i] = new boolean[nSeq2];\n    brk_flg = notifyBreakFlagListener(brk_flg);\n    // ge = true here...\n    /*\n\t\t  for(i=0; i<nSeq1; i++)\n\t\t   {\n\t\t     printf(\"\\n\");\n\t\t     for(j=0; j<nSeq2; j++)\n\t\t       {\n\t\t\t printf(\"%4d\", (int)(*(mat[i]+j)*10));\n\t\t       }\n\t\t   }\n\t\t printf(\"\\n\\n\\n\");\n\t\t */\n    if (!ge) {\n        for (i = nSeq1 - 1; i >= 0; i--) for (j = nSeq2 - 1; j >= 0; j--) {\n            brk_flg[i][j] = false;\n            if (j < nSeq2 - 1 && i < nSeq1 - 1) {\n                sum = mat[i + 1][j + 1];\n            } else {\n                sum = 0.0;\n                if ((isGlobal1 && i != nSeq1 - 1) || (isGlobal2 && j != nSeq2 - 1))\n                    sum = -gapI;\n            }\n            if (j + 1 < nSeq2)\n                for (k = i + 2; k < nSeq1; k++) {\n                    if (mat[k][j + 1] - gapI > sum)\n                        sum = mat[k][j + 1] - gapI;\n                }\n            if (i + 1 < nSeq1)\n                for (k = j + 2; k < nSeq2; k++) {\n                    if (mat[i + 1][k] - gapI > sum)\n                        sum = mat[i + 1][k] - gapI;\n                }\n            sum += mat[i][j];\n            sum_brk = (isGlobal1 ? -gapI : 0.0) + (isGlobal2 ? -gapI : 0.0);\n            if (sum < sum_brk) {\n                sum = sum_brk;\n                brk_flg[i][j] = true;\n                //System.out.println(\"break at: \" + i + \" \" + j);\n            }\n            mat[i][j] = sum;\n        }\n    } else {\n        for (i = nSeq1 - 1; i >= 0; i--) for (j = nSeq2 - 1; j >= 0; j--) {\n            brk_flg[i][j] = false;\n            if (j < nSeq2 - 1 && i < nSeq1 - 1) {\n                sum = mat[i + 1][j + 1];\n            } else {\n                sum = 0.0;\n                if (isGlobal1 && i != nSeq1 - 1)\n                    sum = -gapI - gapE * (nSeq1 - i - 1);\n                if (isGlobal2 && j != nSeq2 - 1)\n                    sum = -gapI - gapE * (nSeq2 - j - 1);\n            }\n            if (j + 1 < nSeq2)\n                for (k = i + 2; k < nSeq1; k++) if (mat[k][j + 1] - gapI - gapE * (k - i - 1) > sum)\n                    sum = mat[k][j + 1] - gapI - gapE * (k - i - 1);\n            if (i + 1 < nSeq1)\n                for (k = j + 2; k < nSeq2; k++) if (mat[i + 1][k] - gapI - gapE * (k - j - 1) > sum)\n                    sum = mat[i + 1][k] - gapI - gapE * (k - j - 1);\n            sum += mat[i][j];\n            sum_brk = (isGlobal1 ? (-gapI - gapE * (nSeq1 - 1 - i)) : 0.0) + (isGlobal2 ? (-gapI - gapE * (nSeq2 - 1 - j)) : 0.0);\n            if (sum < sum_brk) {\n                sum = sum_brk;\n                brk_flg[i][j] = true;\n            }\n            mat[i][j] = sum;\n        }\n    }\n    //\t\tif (debug ){\n    //\t\t\tScaleableMatrixPanel smp = new ScaleableMatrixPanel();\n    //\t\t\tJFrame frame = new JFrame(\"CE alignment matrix in dpAlign \" );\n    //\t\t\tframe.addWindowListener(new WindowAdapter(){\n    //\t\t\t\tpublic void windowClosing(WindowEvent e){\n    //\t\t\t\t\tJFrame f = (JFrame) e.getSource();\n    //\t\t\t\t\tf.setVisible(false);\n    //\t\t\t\t\tf.dispose();\n    //\t\t\t\t}\n    //\n    //\t\t\t});\n    //\n    //\t\t\tsmp.getMatrixPanel().setScalevalue(100);\n    //\t\t\tMatrix mx = (Matrix) new Matrix(mat).clone();\n    //\t\t\tsmp.setMatrix(mx);\n    //\n    //\t\t\tframe.getContentPane().add(smp);\n    //\n    //\t\t\tframe.pack();\n    //\t\t\tframe.setVisible(true);\n    //\t\t}\n    /*\n\t\t for(i=0; i<nSeq1; i++)\n\t\t   {\n\t\t     printf(\"\\n\");\n\t\t     for(j=0; j<nSeq2; j++)\n\t\t       {\n\t\t\t printf(\"%4d\", (int)(*(mat[i]+j)*10));\n\t\t       }\n\t\t   }\n\t\t printf(\"\\n\\n\\n\");\n\t\t for(i=0; i<nSeq1; i++)\n\t\t   {\n\t\t     printf(\"\\n\");\n\t\t     for(j=0; j<nSeq2; j++)\n\t\t       {\n\t\t\t printf(\"%4d\", (int)(*(brk_flg[i]+j)));\n\t\t       }\n\t\t   }\n\t\t // exit(0);\n\t\t */\n    is = 0;\n    js = 0;\n    lcmp = 0;\n    // no nc-end penalty - begin\n    sum_ret = mat[0][0];\n    // look for the highest score in mat[i][j]\n    for (i = 0; i < nSeq1; i++) for (j = 0; j < nSeq2; j++) {\n        if (i == 0 && j == 0)\n            continue;\n        sum = mat[i][j];\n        if (isGlobal1)\n            sum += -gapI - gapE * i;\n        if (isGlobal2)\n            sum += -gapI - gapE * j;\n        if (sum > sum_ret) {\n            sum_ret = sum;\n            is = i;\n            js = j;\n        }\n    }\n    //System.out.println(\"start at \" + is + \"  \" + js);\n    //for(k=0; k<is; k++) align1[k]=-1;\n    //for(k=0; k<js; k++) align2[k]=-1;\n    // no nc-end penalty - end\n    for (i = is, j = js; i < nSeq1 && j < nSeq2; i++, j++) {\n        iMax = i;\n        jMax = j;\n        sum = mat[i][j];\n        if (!ge) {\n            for (k = i + 1; k < nSeq1; k++) if (mat[k][j] - gapI > sum) {\n                iMax = k;\n                jMax = j;\n                sum = mat[k][j] - gapI;\n            }\n            for (k = j + 1; k < nSeq2; k++) if (mat[i][k] - gapI > sum) {\n                iMax = i;\n                jMax = k;\n                sum = mat[i][k] - gapI;\n            }\n        } else {\n            for (k = i + 1; k < nSeq1; k++) if (mat[k][j] - gapI - gapE * (k - i) > sum) {\n                //System.out.println(\"gap1 \" + k + \" \" + j + \" \" + sum + \"<\" +(mat[k][j]-gapI-gapE*(k-i)));\n                iMax = k;\n                jMax = j;\n                sum = mat[k][j] - gapI - gapE * (k - i);\n            }\n            for (k = j + 1; k < nSeq2; k++) if (mat[i][k] - gapI - gapE * (k - j) > sum) {\n                //System.out.println(\"gap2 \" + i + \" \" + k + \" \" + sum + \"<\"+ (mat[i][k]-gapI-gapE*(k-j)));\n                iMax = i;\n                jMax = k;\n                sum = mat[i][k] - gapI - gapE * (k - j);\n            }\n        }\n        //if ( i != iMax || j != jMax )\n        //\tSystem.out.println(\"FOUND GAP AT: \" + i+ \" \" + iMax + \" \" + j + \" \" + jMax);\n        //System.out.println(\" iMax \" + iMax + \" jMax \" +  jMax);\n        // set the gap positions:\n        //printf(\"%d %d\\n\", iMax, jMax);\n        for (k = i; k < iMax; k++, i++) {\n            align_se1[lcmp] = k;\n            align_se2[lcmp] = -1;\n            lcmp++;\n        }\n        for (k = j; k < jMax; k++, j++) {\n            align_se1[lcmp] = -1;\n            align_se2[lcmp] = k;\n            lcmp++;\n        }\n        align_se1[lcmp] = iMax;\n        align_se2[lcmp] = jMax;\n        lcmp++;\n        if (brk_flg[i][j]) {\n            //System.out.println(\"hit break flag at: \" + i + \"  \" + j + \" sum \" + sum_ret + \" lcmp \" + lcmp);\n            break;\n        }\n    }\n    return sum_ret;\n}","repo_id":"9","comment":"/**\n * On input, mat[i][j] should give the score for aligning positions i and j.\n * On output, mat[i][j] gives the maximum score possible for aligning 1..i\n * of protein 1 with 1..j of protein 2.\n *\n * @param nSeq1 The length of protein 1 (mat.length)\n * @param nSeq2 The length of protein 2 (mat[0].length)\n * @param gapI gap initiation penalty\n * @param gapE gap extension penalty\n * @param isGlobal1 The alignment is global for protein 1\n * @param isGlobal2 The alignment is global for protein 2\n * @return The maximum score\n */\n","repo_name":"biojava-master/","id":719,"method_signature":"double dpAlign(int, int, double, double, boolean, boolean)"}