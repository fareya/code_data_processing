{"callee_method_ids":[874,874,875,1410],"callee_method_names":["StructureInterface.getMoleculeIds","Map<String, String>.get","StructureInterface.getMoleculeIds","Map<String, String>.get","StructureInterface.getTransforms","PDBCrystallographicInfo.getCrystalCell","Map<String, Matrix4d>.get","Matrix4d.invert","Map<String, Matrix4d>.get","Matrix4d.mul","Matrix4d.mul","Matrix4d.invert","Map<String, Map<Matrix4d, StructureInterface>>.computeIfAbsent","double.getKey","double.epsilonEquals","Optional<Matrix4d>.orElse","Map<String, Map<Matrix4d, StructureInterface>>.computeIfAbsent","double.getKey","double.epsilonEquals","Optional<Matrix4d>.orElse","Map<String, Map<Matrix4d, StructureInterface>>.get","Map<String, Map<Matrix4d, StructureInterface>>.get"],"method_name":"CrystalBuilder.findNcsRef","method_implementation":"{\n    if (!this.hasNcsOps()) {\n        return null;\n    }\n    String chainIName = interf.getMoleculeIds().getFirst();\n    String iOrigName = chainOrigNames.get(chainIName);\n    String chainJName = interf.getMoleculeIds().getSecond();\n    String jOrigName = chainOrigNames.get(chainJName);\n    Matrix4d mJCryst;\n    if (this.searchBeyondAU) {\n        mJCryst = interf.getTransforms().getSecond().getMatTransform();\n        mJCryst = crystallographicInfo.getCrystalCell().transfToOrthonormal(mJCryst);\n    } else {\n        mJCryst = IDENTITY;\n    }\n    // Let X1,...Xn be the original coords, before NCS transforms (M1...Mk)\n    // current chain i: M_i * X_i\n    // current chain j: Cn * M_j * X_j\n    // transformation to bring chain j near X_i: M_i^(-1) * Cn * M_j\n    // transformation to bring chain i near X_j: (Cn * M_j)^(-1) * M_i = (M_i^(-1) * Cn * M_j)^(-1)\n    Matrix4d mChainIInv = new Matrix4d(chainNcsOps.get(chainIName));\n    mChainIInv.invert();\n    Matrix4d mJNcs = new Matrix4d(chainNcsOps.get(chainJName));\n    Matrix4d j2iNcsOrigin = new Matrix4d(mChainIInv);\n    j2iNcsOrigin.mul(mJCryst);\n    //overall transformation to bring current chainj from its NCS origin to i's\n    j2iNcsOrigin.mul(mJNcs);\n    //overall transformation to bring current chaini from its NCS origin to j's\n    Matrix4d i2jNcsOrigin = new Matrix4d(j2iNcsOrigin);\n    i2jNcsOrigin.invert();\n    String matchChainIdsIJ = iOrigName + jOrigName;\n    String matchChainIdsJI = jOrigName + iOrigName;\n    // same original chain names\n    Optional<Matrix4d> matchDirect = visitedNcsChainPairs.computeIfAbsent(matchChainIdsIJ, k -> new HashMap<>()).entrySet().stream().map(r -> r.getKey()).filter(r -> r.epsilonEquals(j2iNcsOrigin, 0.01)).findFirst();\n    Matrix4d matchMatrix = matchDirect.orElse(null);\n    String matchChainIds = matchChainIdsIJ;\n    if (matchMatrix == null) {\n        // reversed original chain names with inverted transform\n        Optional<Matrix4d> matchInverse = visitedNcsChainPairs.computeIfAbsent(matchChainIdsJI, k -> new HashMap<>()).entrySet().stream().map(r -> r.getKey()).filter(r -> r.epsilonEquals(i2jNcsOrigin, 0.01)).findFirst();\n        matchMatrix = matchInverse.orElse(null);\n        matchChainIds = matchChainIdsJI;\n    }\n    StructureInterface matchInterface = null;\n    if (matchMatrix == null) {\n        visitedNcsChainPairs.get(matchChainIdsIJ).put(j2iNcsOrigin, interf);\n    } else {\n        matchInterface = visitedNcsChainPairs.get(matchChainIds).get(matchMatrix);\n    }\n    return matchInterface;\n}","repo_id":"9","comment":"/**\n * Checks whether given interface is NCS-redundant, i.e., an identical interface between NCS copies of\n * these molecules has already been seen, and returns this (reference) interface.\n *\n * @param interf\n *          StructureInterface\n * @return  already seen interface that is NCS-equivalent to interf,\n *          null if such interface is not found.\n */\n","repo_name":"biojava-master/","id":1440,"method_signature":"StructureInterface findNcsRef(StructureInterface)"}