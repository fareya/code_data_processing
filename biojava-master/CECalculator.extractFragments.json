{"callee_method_ids":[759,746],"callee_method_names":["AFPChain.setCa1Length","AFPChain.setCa2Length","CeParameters.getScoringStrategy","CeParameters.getSeqWeight","CeParameters.setSeqWeight","CeParameters.getWinSize"],"method_name":"CECalculator.extractFragments","method_implementation":"{\n    int nse1 = ca1.length;\n    int nse2 = ca2.length;\n    afpChain.setCa1Length(nse1);\n    afpChain.setCa2Length(nse2);\n    int traceMaxSize = nse1 < nse2 ? nse1 : nse2;\n    f1 = new int[nse1];\n    f2 = new int[nse2];\n    dist1 = initIntraDistmatrix(ca1, nse1);\n    dist2 = initIntraDistmatrix(ca2, nse2);\n    if (debug)\n        System.out.println(\"parameters: \" + params);\n    if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SEQUENCE_CONSERVATION) {\n        if (params.getSeqWeight() < 1)\n            params.setSeqWeight(2);\n    }\n    int winSize = params.getWinSize();\n    int winSizeComb1 = (winSize - 1) * (winSize - 2) / 2;\n    traceIndexContainer = new int[traceMaxSize];\n    // CE: unused code. distAll is always false and both loops do the same???\n    // CE v2.3 calls this Weight factors for trace extension\n    if (distAll) {\n        for (int i = 0; i < traceMaxSize; i++) traceIndexContainer[i] = (i + 1) * i * winSize * winSize / 2 + (i + 1) * winSizeComb1;\n    } else {\n        for (int i = 0; i < traceMaxSize; i++) {\n            traceIndexContainer[i] = (i + 1) * i * winSize / 2 + (i + 1) * winSizeComb1;\n        }\n    }\n    // verified: a[] is set correctly.\n    mat = initSumOfDistances(nse1, nse2, winSize, winSizeComb1, ca1, ca2);\n    //\t\ttry {\n    //\t\t\tMatrix m2 = new Matrix(mat).copy();\n    //\t\t\tJPanel panel = GuiWrapper.getScaleableMatrixPanel(m2);\n    //\t\t\tJFrame frame = new JFrame();\n    //\t\t\tframe.addWindowListener(new WindowAdapter(){\n    //\t\t\t\tpublic void windowClosing(WindowEvent e){\n    //\t\t\t\t\tJFrame f = (JFrame) e.getSource();\n    //\t\t\t\t\tf.setVisible(false);\n    //\t\t\t\t\tf.dispose();\n    //\t\t\t\t}\n    //\t\t\t});\n    //\n    //\n    //\t\t\tframe.getContentPane().add(panel);\n    //\n    //\t\t\tframe.pack();\n    //\t\t\tframe.setVisible(true);\n    //\t\t} catch (Exception e) {\n    //\t\t\te.printStackTrace();\n    //\t\t}\n    // Set the distance matrix\n    //afpChain.setDistanceMatrix(new Matrix(mat.clone()));\n    //\n    //\t\t\t   double rmsdThr = params.getRmsdThr();\n    //\t\t\t   StringBuffer buf = new StringBuffer(\"  \");\n    //\t\t\t   for(int i=0; i<nse2; i++)\n    //\t\t\t      buf.append(String.format(\"%c\", i%10==0?(i%100)/10+48:32));\n    //\t\t\t   buf.append(\"\\n\");\n    //\t\t\t   for(int i=0; i<nse1; i++) {\n    //\t\t\t      buf.append(String.format(\"%c \", i%10==0?(i%100)/10+48:32));\n    //\t\t\t      for(int j=0; j<nse2; j++)\n    //\t\t\t         buf.append(String.format(\"%c\", (mat[i][j])<rmsdThr?'+':'X'));\n    //\t\t\t      //printf(\"%c\", ((int)*(mat[i]+j)/40)>9?'*':((int)*(mat[i]+j)/40)+48);\n    //\t\t\t      buf.append(\"\\n\");\n    //\t\t\t   }\n    //\t\t\t   buf.append(\"\\n\");\n    //\n    //\t\t\t   System.out.println(buf.toString());\n    //\n    return afpChain;\n}","repo_id":"9","comment":"/**\n * @param afpChain A new AFPChain, which will be filled in by this function\n * @param ca1\n * @param ca2\n * @return afpChain\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":711,"method_signature":"AFPChain extractFragments(AFPChain, Atom[], Atom[])"}