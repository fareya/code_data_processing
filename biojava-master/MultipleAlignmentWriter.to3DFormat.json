{"callee_method_ids":[1610],"callee_method_names":["MultipleAlignment.getEnsemble","List<Atom[]>.get","List<Atom[]>.get","MultipleAlignment.getBlocks","MultipleAlignment.getEnsemble","StructureIdentifier.toCanonical","SubstructureIdentifier.getPdbId","SubstructureIdentifier.getResidueRanges","List<Block>.get","Atom[].getGroup","StringBuilder.append","Block.getAlignRes","Block.getAlignRes","Block.length","List<Integer>.get","List<Integer>.get","Atom[].toPDB","Atom[].toPDB","StringBuilder.append","String.substring","StringBuilder.append","String.substring","StringBuilder.append","String.substring","StringBuilder.append","StringBuilder.append","String.substring","StringBuilder.append","StringBuilder.toString"],"method_name":"MultipleAlignmentWriter.to3DFormat","method_implementation":"{\n    List<Atom[]> atomArrays = alignment.getEnsemble().getAtomArrays();\n    Atom[] queryAtoms = atomArrays.get(queryIndex);\n    Atom[] templateAtoms = atomArrays.get(templateIndex);\n    List<Block> blocks = alignment.getBlocks();\n    MultipleAlignmentTools.sortBlocks(blocks, queryIndex);\n    StringBuilder str = new StringBuilder();\n    // Gather info about the template structure\n    StructureIdentifier tName = alignment.getEnsemble().getStructureIdentifiers().get(templateIndex);\n    SubstructureIdentifier canon = tName.toCanonical();\n    PdbId tPdbId = canon.getPdbId();\n    String tChain = null;\n    for (ResidueRange range : canon.getResidueRanges()) {\n        tChain = range.getChainName();\n        break;\n    }\n    if (tChain == null) {\n        // Use the chain of the first template block\n        for (Integer i : blocks.get(0).getAlignRes().get(templateIndex)) {\n            if (i != null) {\n                tChain = templateAtoms[i].getGroup().getChainId();\n                break;\n            }\n        }\n    }\n    str.append(String.format(\"REMARK Template name:%s:%s\\n\", tPdbId, tChain));\n    for (Block block : blocks) {\n        List<Integer> qAlign = block.getAlignRes().get(queryIndex);\n        List<Integer> tAlign = block.getAlignRes().get(templateIndex);\n        for (int i = 0; i < block.length(); i++) {\n            Integer qRes = qAlign.get(i);\n            Integer tRes = tAlign.get(i);\n            // skip gaps\n            if (qRes == null || tRes == null)\n                continue;\n            // Get PDB-format ATOM records\n            String qPDB = queryAtoms[qRes].toPDB();\n            String tPDB = templateAtoms[tRes].toPDB();\n            // merge the two records into 3D format\n            // up through coordinates\n            str.append(qPDB.substring(0, 30));\n            // coordinates\n            str.append(tPDB.substring(30, 54));\n            // residue number\n            str.append(tPDB.substring(22, 27));\n            str.append(' ');\n            str.append(tPDB.substring(17, 20));\n            str.append('\\n');\n        }\n    }\n    return str.toString();\n}","repo_id":"9","comment":"/**\n * Outputs a pairwise alignment in I-TASSER's 3D Format for target-template\n * alignment. http://zhanglab.ccmb.med.umich.edu/I-TASSER/option4.html\n *\n * <p>\n * The format is closely related to a standard PDB file, but contains only\n * CA atoms and adds two columns for specifying the alignment:\n *\n * <pre>\n * ATOM   2001  CA  MET     1      41.116 -30.727   6.866  129 THR\n * ATOM   2002  CA  ALA     2      39.261 -27.408   6.496  130 ARG\n * ATOM   2003  CA  ALA     3      35.665 -27.370   7.726  131 THR\n * ATOM   2004  CA  ARG     4      32.662 -25.111   7.172  132 ARG\n * ATOM   2005  CA  GLY     5      29.121 -25.194   8.602  133 ARG\n *\n * Column 1 -30: Atom & Residue records of query sequence.\n * Column 31-54: Coordinates of atoms in query copied from corresponding atoms in template.\n * Column 55-59: Corresponding residue number in template based on alignment\n * Column 60-64: Corresponding residue name in template\n * <\/pre>\n *\n * <p>\n * Note that the output is a pairwise alignment. Only the first and second\n * rows in the MultipleAlignment will be used, others ignored.\n *\n * <p>\n * This method supports topology-independent alignments. The output will\n * have sequence order matching the query, but include atoms from the\n * template.\n *\n * @param alignment\n *            A <em>full<\/em> multiple alignment between proteins\n * @param queryIndex\n *            index of the query within the multiple alignment\n * @param templateIndex\n *            index of the template within the multiple alignment\n * @return The file contents as a string\n * @throws StructureException If an error occurs parsing the alignment's structure names\n */\n","repo_name":"biojava-master/","id":675,"method_signature":"String to3DFormat(MultipleAlignment, int, int)"}