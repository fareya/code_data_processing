{"callee_method_names":["Matrix3d.mul","Matrix3d.add","Matrix3d.transform","Vector3d.scale","Matrix3d.add","Matrix3d.transform","Vector3d.scale"],"method_name":"CrystalTransform.getTranslScrewComponent","method_implementation":"{\n    int foldType = SpaceGroup.getRotAxisType(m);\n    // For reference see:\n    // http://www.crystallography.fr/mathcryst/pdf/Gargnano/Aroyo_Gargnano_1.pdf\n    Vector3d transl = null;\n    Matrix3d W = new Matrix3d(m.m00, m.m01, m.m02, m.m10, m.m11, m.m12, m.m20, m.m21, m.m22);\n    if (foldType >= 0) {\n        // the Y matrix: Y = W^k-1 + W^k-2 ... + W + I  ; with k the fold type\n        Matrix3d Y = new Matrix3d(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        Matrix3d Wk = new Matrix3d(1, 0, 0, 0, 1, 0, 0, 0, 1);\n        for (int k = 0; k < foldType; k++) {\n            // k=0 Wk=W, k=1 Wk=W^2, k=2 Wk=W^3, ... k=foldType-1, Wk=W^foldType\n            Wk.mul(W);\n            if (k != foldType - 1)\n                Y.add(Wk);\n        }\n        transl = new Vector3d(m.m03, m.m13, m.m23);\n        Y.transform(transl);\n        transl.scale(1.0 / foldType);\n    } else {\n        if (foldType == -2) {\n            // there are glide planes only in -2\n            Matrix3d Y = new Matrix3d(1, 0, 0, 0, 1, 0, 0, 0, 1);\n            Y.add(W);\n            transl = new Vector3d(m.m03, m.m13, m.m23);\n            Y.transform(transl);\n            transl.scale(1.0 / 2.0);\n        } else {\n            // for -1, -3, -4 and -6 there's nothing to do: fill with 0s\n            transl = new Vector3d(0, 0, 0);\n        }\n    }\n    return transl;\n}","repo_id":"9","comment":"/**\n * Given a transformation matrix containing a rotation and translation returns the\n * screw component of the rotation.\n * See http://www.crystallography.fr/mathcryst/pdf/Gargnano/Aroyo_Gargnano_1.pdf\n * @param m\n * @return\n */\n","repo_name":"biojava-master/","id":1434,"method_signature":"Vector3d getTranslScrewComponent(Matrix4d)"}