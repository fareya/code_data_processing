{"callee_method_ids":[487],"callee_method_names":["AFPChain.getBlockRotationMatrix","AFPChain.setBlockRotationMatrix","AFPChain.setBlockShiftVector","AFPChain.getAlgorithmName","AFPChain.getAlgorithmName","AFPChain.getGroup","AFPChain.getBlockRotationMatrix","AFPChain.getBlockShiftVector","AFPChain.getBlockNum","List<Group>.size","AFPChain.getBlockRotationMatrix","AFPChain.getBlockRotationMatrix","AFPChain.getBlockShiftVector"],"method_name":"AlignmentTools.prepareGroupsForDisplay","method_implementation":"{\n    if (afpChain.getBlockRotationMatrix().length == 0) {\n        // probably the alignment is too short!\n        System.err.println(\"No rotation matrix found to rotate 2nd structure!\");\n        afpChain.setBlockRotationMatrix(new Matrix[] { Matrix.identity(3, 3) });\n        afpChain.setBlockShiftVector(new Atom[] { new AtomImpl() });\n    }\n    // List of groups to be rotated according to the alignment\n    Group[] twistedGroups = new Group[ca2.length];\n    //int blockNum = afpChain.getBlockNum();\n    int i = -1;\n    // List of groups from the structure not included in ca2 (e.g. ligands)\n    // Will be rotated according to first block\n    List<Group> hetatms2 = StructureTools.getUnalignedGroups(ca2);\n    if ((afpChain.getAlgorithmName().equals(FatCatRigid.algorithmName)) || (afpChain.getAlgorithmName().equals(FatCatFlexible.algorithmName))) {\n        for (Atom a : ca2) {\n            i++;\n            twistedGroups[i] = a.getGroup();\n        }\n        twistedGroups = AFPTwister.twistOptimized(afpChain, ca1, ca2);\n        //} else  if  (( blockNum == 1 ) || (afpChain.getAlgorithmName().equals(CeCPMain.algorithmName))) {\n    } else {\n        Matrix m = afpChain.getBlockRotationMatrix()[0];\n        Atom shift = afpChain.getBlockShiftVector()[0];\n        shiftCA2(afpChain, ca2, m, shift, twistedGroups);\n    }\n    if (afpChain.getBlockNum() > 0) {\n        // Superimpose ligands relative to the first block\n        if (hetatms2.size() > 0) {\n            if (afpChain.getBlockRotationMatrix().length > 0) {\n                Matrix m1 = afpChain.getBlockRotationMatrix()[0];\n                //m1.print(3,3);\n                Atom vector1 = afpChain.getBlockShiftVector()[0];\n                //System.out.println(\"shift vector:\" + vector1);\n                for (Group g : hetatms2) {\n                    Calc.rotate(g, m1);\n                    Calc.shift(g, vector1);\n                }\n            }\n        }\n    }\n    return twistedGroups;\n}","repo_id":"9","comment":"/**\n * Rotate the Atoms/Groups so they are aligned for the 3D visualisation\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @return an array of Groups that are transformed for 3D display\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":603,"method_signature":"Group[] prepareGroupsForDisplay(AFPChain, Atom[], Atom[])"}