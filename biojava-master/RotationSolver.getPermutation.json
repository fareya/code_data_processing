{"callee_method_names":["DistanceBox<Integer>.getNeighborsWithCache","Integer.distanceSquared","List<Integer>.add","List<Integer>.size","List<Integer>.clear","Set<Integer>.size","List<Integer>.clear"],"method_name":"RotationSolver.getPermutation","method_implementation":"{\n    List<Integer> permutation = new ArrayList<Integer>(transformedCoords.length);\n    double sum = 0.0f;\n    for (Point3d t : transformedCoords) {\n        List<Integer> neighbors = box.getNeighborsWithCache(t);\n        int closest = -1;\n        double minDist = Double.MAX_VALUE;\n        for (int j : neighbors) {\n            double dist = t.distanceSquared(originalCoords[j]);\n            if (dist < minDist) {\n                closest = j;\n                minDist = dist;\n            }\n        }\n        sum += minDist;\n        if (closest == -1) {\n            break;\n        }\n        permutation.add(closest);\n    }\n    double rmsd = Math.sqrt(sum / transformedCoords.length);\n    if (rmsd > distanceThreshold || permutation.size() != transformedCoords.length) {\n        permutation.clear();\n        return permutation;\n    }\n    // check uniqueness of indices\n    Set<Integer> set = new HashSet<Integer>(permutation);\n    // if size mismatch, clear permutation (its invalid)\n    if (set.size() != originalCoords.length) {\n        permutation.clear();\n    }\n    return permutation;\n}","repo_id":"9","comment":"/**\n * Compare this.transformedCoords with the original coords. For each\n * subunit, return the transformed subunit with the closest position.\n * @return A list mapping each subunit to the closest transformed subunit\n */\n","repo_name":"biojava-master/","id":1906,"method_signature":"List<Integer> getPermutation()"}