{"callee_method_names":["int.getProfile","List<GuideTreeNode<S, C>>.add","List<GuideTreeNode<S, C>>.size","int.getChild1","int.getChild2","int.getChild1","int.getChild2","int.setProfileFuture","int.setProfile","int.getProfileFuture","Logger.error","Logger.error","GuideTree<S,C>.getRoot"],"method_name":"Alignments.getProgressiveAlignment","method_implementation":"{\n    // find inner nodes in post-order traversal of tree (each leaf node has a single sequence profile)\n    List<GuideTreeNode<S, C>> innerNodes = new ArrayList<GuideTreeNode<S, C>>();\n    for (GuideTreeNode<S, C> n : tree) {\n        if (n.getProfile() == null) {\n            innerNodes.add(n);\n        }\n    }\n    // submit alignment tasks to the shared thread pool\n    int i = 1, all = innerNodes.size();\n    for (GuideTreeNode<S, C> n : innerNodes) {\n        Profile<S, C> p1 = n.getChild1().getProfile(), p2 = n.getChild2().getProfile();\n        Future<ProfilePair<S, C>> pf1 = n.getChild1().getProfileFuture(), pf2 = n.getChild2().getProfileFuture();\n        ProfileProfileAligner<S, C> aligner = (p1 != null) ? ((p2 != null) ? getProfileProfileAligner(p1, p2, type, gapPenalty, subMatrix) : getProfileProfileAligner(p1, pf2, type, gapPenalty, subMatrix)) : ((p2 != null) ? getProfileProfileAligner(pf1, p2, type, gapPenalty, subMatrix) : getProfileProfileAligner(pf1, pf2, type, gapPenalty, subMatrix));\n        n.setProfileFuture(ConcurrencyTools.submit(new CallableProfileProfileAligner<S, C>(aligner), String.format(\"Aligning pair %d of %d\", i++, all)));\n    }\n    // retrieve the alignment results\n    for (GuideTreeNode<S, C> n : innerNodes) {\n        // TODO when added to ConcurrencyTools, log completions and exceptions instead of printing stack traces\n        try {\n            n.setProfile(n.getProfileFuture().get());\n        } catch (InterruptedException e) {\n            logger.error(\"Interrupted Exception: \", e);\n        } catch (ExecutionException e) {\n            logger.error(\"Execution Exception: \", e);\n        }\n    }\n    // the alignment profile at the root of the tree is the full multiple sequence alignment\n    return tree.getRoot().getProfile();\n}","repo_id":"9","comment":"/**\n * Factory method to run the profile-profile alignments of a progressive multiple sequence alignment concurrently.\n * This method runs the alignments in parallel by submitting all of the alignment tasks to the shared thread pool\n * of the {@link ConcurrencyTools} utility.\n *\n * @param <S> each {@link Sequence} of the {@link Profile} pair is of type S\n * @param <C> each element of an {@link AlignedSequence} is a {@link Compound} of type C\n * @param tree guide tree to follow aligning profiles from leaves to root\n * @param type chosen type from list of profile-profile alignment routines\n * @param gapPenalty the gap penalties used during alignment\n * @param subMatrix the set of substitution scores used during alignment\n * @return multiple sequence alignment\n */\n","repo_name":"biojava-master/","id":51,"method_signature":"Profile<S,C> getProgressiveAlignment(GuideTree, ProfileProfileAlignerType, GapPenalty, SubstitutionMatrix)"}