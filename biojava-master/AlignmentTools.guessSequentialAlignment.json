{"callee_method_names":["Map<Integer,Integer>.entrySet","SortedSet<Integer>.add","SequencePair<ProteinSequence,AminoAcidCompound>.getKey","SortedSet<Integer>.add","SequencePair<ProteinSequence,AminoAcidCompound>.getValue","SequencePair<ProteinSequence,AminoAcidCompound>.getValue","SortedSet<Integer>.iterator","SortedSet<Integer>.iterator","Iterator<Integer>.hasNext","Map<Integer, Integer>.put","Iterator<Integer>.next","Iterator<Integer>.next","Map<Integer, Integer>.put","Iterator<Integer>.next","Iterator<Integer>.next"],"method_name":"AlignmentTools.guessSequentialAlignment","method_implementation":"{\n    Map<Integer, Integer> identity = new HashMap<Integer, Integer>();\n    SortedSet<Integer> aligned1 = new TreeSet<Integer>();\n    SortedSet<Integer> aligned2 = new TreeSet<Integer>();\n    for (Entry<Integer, Integer> pair : alignment.entrySet()) {\n        aligned1.add(pair.getKey());\n        if (!aligned2.add(pair.getValue()))\n            throw new IllegalArgumentException(\"Alignment is not one-to-one for residue \" + pair.getValue() + \" of the second structure.\");\n    }\n    Iterator<Integer> it1 = aligned1.iterator();\n    Iterator<Integer> it2 = aligned2.iterator();\n    while (it1.hasNext()) {\n        if (inverseAlignment) {\n            // 2->1\n            identity.put(it2.next(), it1.next());\n        } else {\n            // 1->2\n            identity.put(it1.next(), it2.next());\n        }\n    }\n    return identity;\n}","repo_id":"9","comment":"/**\n * Takes a potentially non-sequential alignment and guesses a sequential\n * version of it. Residues from each structure are sorted sequentially and\n * then compared directly.\n *\n * <p>The results of this method are consistent with what one might expect\n * from an identity function, and are therefore useful with\n * {@link #getSymmetryOrder(Map, Map identity, int, float)}.\n * <ul>\n *  <li>Perfect self-alignments will have the same pre-image and image,\n *      so will map X->X<\/li>\n *  <li>Gaps and alignment errors will cause errors in the resulting map,\n *      but only locally. Errors do not propagate through the whole\n *      alignment.<\/li>\n * <\/ul>\n *\n * <h4>Example:<\/h4>\n * A non sequential alignment, represented schematically as\n * <pre>\n * 12456789\n * 78912345<\/pre>\n * would result in a map\n * <pre>\n * 12456789\n * 12345789<\/pre>\n * @param alignment The non-sequential input alignment\n * @param inverseAlignment If false, map from structure1 to structure2. If\n *  true, generate the inverse of that map.\n * @return A mapping from sequential residues of one protein to those of the other\n * @throws IllegalArgumentException if the input alignment is not one-to-one.\n */\n","repo_name":"biojava-master/","id":585,"method_signature":"Map<Integer,Integer> guessSequentialAlignment(Map, boolean)"}