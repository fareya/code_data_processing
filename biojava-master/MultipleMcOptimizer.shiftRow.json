{"callee_method_names":["Random.nextInt","Random.nextInt","Random.nextInt","Random.nextInt","MultipleAlignment.getBlock","MultipleAlignment.getBlock","Block.getCoreLength","Block.getAlignRes","Block.getAlignRes","Block.length","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes","Block.getAlignRes","Random.nextInt","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.length","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get","List<SortedSet<Integer>>.get","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.length","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.length","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get"],"method_name":"MultipleMcOptimizer.shiftRow","method_implementation":"{\n    // Select randomly the subunit\n    int str = rnd.nextInt(size);\n    // Select between moving right (0) or left (1)\n    int rl = rnd.nextInt(2);\n    // Select randomly the Block\n    int bk = rnd.nextInt(blockNr);\n    int res = rnd.nextInt(msa.getBlock(bk).length());\n    Block block = msa.getBlock(bk);\n    if (block.getCoreLength() <= Lmin)\n        return false;\n    // When the pivot residue is null try to add a residue from the freePool\n    if (block.getAlignRes().get(str).get(res) == null) {\n        // Residues not null at the right and left of the pivot null residue\n        int rightRes = res;\n        int leftRes = res;\n        // Find the boundary to the right abd left\n        while (block.getAlignRes().get(str).get(rightRes) == null && rightRes < block.length() - 1) {\n            rightRes++;\n        }\n        while (block.getAlignRes().get(str).get(leftRes) == null && leftRes > 0) {\n            leftRes--;\n        }\n        // If both are null return because the block is empty\n        if (block.getAlignRes().get(str).get(leftRes) == null && block.getAlignRes().get(str).get(rightRes) == null) {\n            return false;\n        } else if (block.getAlignRes().get(str).get(leftRes) == null) {\n            // Choose the sequentially previous residue of the known one\n            Integer residue = block.getAlignRes().get(str).get(rightRes) - 1;\n            if (freePool.get(str).contains(residue)) {\n                block.getAlignRes().get(str).set(res, residue);\n                freePool.get(str).remove(residue);\n            } else\n                return false;\n        } else if (block.getAlignRes().get(str).get(rightRes) == null) {\n            // Choose the sequentially next residue of the known one\n            Integer residue = block.getAlignRes().get(str).get(leftRes) + 1;\n            if (freePool.get(str).contains(residue)) {\n                block.getAlignRes().get(str).set(res, residue);\n                freePool.get(str).remove(residue);\n            } else\n                return false;\n        } else {\n            // If boundaries are consecutive no residue can be added\n            if (block.getAlignRes().get(str).get(rightRes) == block.getAlignRes().get(str).get(leftRes) + 1) {\n                return false;\n            } else {\n                // Choose randomly a residue in between left and right\n                Integer residue = rnd.nextInt(block.getAlignRes().get(str).get(rightRes) - block.getAlignRes().get(str).get(leftRes) - 1) + block.getAlignRes().get(str).get(leftRes) + 1;\n                if (freePool.get(str).contains(residue)) {\n                    block.getAlignRes().get(str).set(res, residue);\n                    freePool.get(str).remove(residue);\n                }\n            }\n        }\n        return true;\n    }\n    // When residue different than null shift the whole block\n    switch(rl) {\n        case // Move to the right\n        0:\n            // Find the nearest boundary to the left of the pivot\n            int leftBoundary = res - 1;\n            int leftPrevRes = res;\n            while (true) {\n                if (leftBoundary < 0)\n                    break;\n                else {\n                    if (block.getAlignRes().get(str).get(leftBoundary) == null)\n                        // Break if there is a gap (this is the boundary)\n                        break;\n                    else if (block.getAlignRes().get(str).get(leftPrevRes) > block.getAlignRes().get(str).get(leftBoundary) + 1)\n                        // Break if there is a discontinuity\n                        break;\n                }\n                leftPrevRes = leftBoundary;\n                leftBoundary--;\n            }\n            leftBoundary++;\n            // Find the nearest boundary to the right of the pivot\n            int rightBoundary = res + 1;\n            int rightPrevRes = res;\n            while (true) {\n                if (rightBoundary == block.length())\n                    break;\n                else {\n                    if (block.getAlignRes().get(str).get(rightBoundary) == null)\n                        // Break if there is a gap\n                        break;\n                    else if (block.getAlignRes().get(str).get(rightPrevRes) + 1 < block.getAlignRes().get(str).get(rightBoundary))\n                        // Discontinuity\n                        break;\n                }\n                rightPrevRes = rightBoundary;\n                rightBoundary++;\n            }\n            rightBoundary--;\n            // Residues at the boundary\n            Integer resR0 = block.getAlignRes().get(str).get(rightBoundary);\n            Integer resL0 = block.getAlignRes().get(str).get(leftBoundary);\n            // Remove the residue at the right of the block\n            block.getAlignRes().get(str).remove(rightBoundary);\n            if (resR0 != null)\n                freePool.get(str).add(resR0);\n            // Add the residue at the left of the block\n            if (resL0 != null)\n                resL0 -= 1;\n            if (freePool.get(str).contains(resL0)) {\n                block.getAlignRes().get(str).add(leftBoundary, resL0);\n                freePool.get(str).remove(resL0);\n            } else\n                block.getAlignRes().get(str).add(leftBoundary, null);\n            break;\n        case // Move to the left\n        1:\n            // Find the nearest boundary to the left of the pivot\n            int leftBoundary1 = res - 1;\n            int leftPrevRes1 = res;\n            while (true) {\n                if (leftBoundary1 < 0)\n                    break;\n                else {\n                    if (block.getAlignRes().get(str).get(leftBoundary1) == null)\n                        // Break if there is a gap (this is the boundary)\n                        break;\n                    else if (block.getAlignRes().get(str).get(leftPrevRes1) > block.getAlignRes().get(str).get(leftBoundary1) + 1)\n                        // Break if there is a discontinuity\n                        break;\n                }\n                leftPrevRes1 = leftBoundary1;\n                leftBoundary1--;\n            }\n            leftBoundary1++;\n            // Find the nearest boundary to the right of the pivot\n            int rightBoundary1 = res + 1;\n            int rightPrevRes1 = res;\n            while (true) {\n                if (rightBoundary1 == block.length())\n                    break;\n                else {\n                    if (block.getAlignRes().get(str).get(rightBoundary1) == null)\n                        // Break if there is a gap\n                        break;\n                    else if (block.getAlignRes().get(str).get(rightPrevRes1) + 1 < block.getAlignRes().get(str).get(rightBoundary1))\n                        // Discontinuity\n                        break;\n                }\n                rightPrevRes1 = rightBoundary1;\n                rightBoundary1++;\n            }\n            rightBoundary1--;\n            // Residues at the boundary\n            Integer resR1 = block.getAlignRes().get(str).get(rightBoundary1);\n            Integer resL1 = block.getAlignRes().get(str).get(leftBoundary1);\n            // Add the residue at the right of the block\n            if (resR1 != null)\n                resR1 += 1;\n            if (freePool.get(str).contains(resR1)) {\n                if (rightBoundary1 == block.length() - 1) {\n                    block.getAlignRes().get(str).add(resR1);\n                } else\n                    block.getAlignRes().get(str).add(rightBoundary1 + 1, resR1);\n                freePool.get(str).remove(resR1);\n            } else\n                block.getAlignRes().get(str).add(rightBoundary1 + 1, null);\n            // Remove the residue at the left of the block\n            block.getAlignRes().get(str).remove(leftBoundary1);\n            if (resL1 != null)\n                freePool.get(str).add(resL1);\n            break;\n    }\n    checkGaps();\n    return true;\n}","repo_id":"9","comment":"/**\n * Move all the block residues of one subunit one position to the left or to\n * the right and move the corresponding boundary residues from the freePool\n * to the block.\n * <p>\n * The boundaries are determined by any irregularity (either a null or a\n * discontinuity in the alignment).\n *\n * @return true if the alignment has been changed, false otherwise.\n */\n","repo_name":"biojava-master/","id":697,"method_signature":"boolean shiftRow()"}