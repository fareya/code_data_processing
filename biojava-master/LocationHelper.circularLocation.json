{"callee_method_names":["List<Location>.add","List<Location>.add","List<Location>.add"],"method_name":"LocationHelper.circularLocation","method_implementation":"{\n    int min = Math.min(start, end);\n    int max = Math.max(start, end);\n    //Tells us we're dealing with something that's not _right_\n    boolean isReverse = (min != start);\n    if (min > length) {\n        throw new IllegalArgumentException(\"Cannot process a \" + \"location whose lowest coordinate is less than \" + \"the given length \" + length);\n    }\n    //If max positon was less than length the return a normal location\n    if (max <= length) {\n        return location(start, end, strand, length);\n    }\n    //Fine for forward coords (i..e start < end)\n    int modStart = modulateCircularIndex(start, length);\n    int modEnd = modulateCircularIndex(end, length);\n    int numberOfPasses = completeCircularPasses(Math.max(start, end), length);\n    if (isReverse) {\n        int reversedModStart = new SimplePoint(modStart).reverse(length).getPosition();\n        int reversedModEnd = new SimplePoint(modEnd).reverse(length).getPosition();\n        modStart = reversedModStart;\n        modEnd = reversedModEnd;\n        start = reversedModStart;\n        //+1 to number of passes to skip the run encoded by the start\n        end = (length * (numberOfPasses + 1)) + modEnd;\n    }\n    List<Location> locations = new ArrayList<Location>();\n    locations.add(new SimpleLocation(modStart, length, strand));\n    for (int i = 0; i < numberOfPasses; i++) {\n        locations.add(new SimpleLocation(1, length, strand));\n    }\n    locations.add(new SimpleLocation(1, modEnd, strand));\n    return new SimpleLocation(new SimplePoint(start), new SimplePoint(end), strand, true, false, locations);\n}","repo_id":"9","comment":"/**\n * Converts a location which defines the outer bounds of a circular\n * location and splits it into the required portions. Unlike any\n * other location builder this allows you to express your input\n * location on the reverse strand\n *\n * @param location The location which currently expresses the outer\n * bounds of a circular location.\n * @param length The length of the circular genomic unit\n * @return The circular location; can optionally return a normal non\n * circular location if the one you give is within the bounds of\n * the length\n */\n","repo_name":"biojava-master/","id":3045,"method_signature":"Location circularLocation(int, int, Strand, int)"}