{"callee_method_ids":[489,490,487,487],"callee_method_names":["AFPChain.getCa2Length","AFPChain.getName2","AFPChain.getOptAln","AFPChain.getOptLen","AFPChain.getBlockNum","AFPChain.getBlockNum","List<List<Integer>>.add","List<List<Integer>>.add","List<List<List<Integer>>>.add","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.add","List<List<Integer>>.add","List<List<List<Integer>>>.add","List<List<Integer>>.get","List<List<Integer>>.get"],"method_name":"OptimalCECPMain.permuteOptAln","method_implementation":"{\n    int ca2len = afpChain.getCa2Length();\n    if (ca2len <= 0) {\n        throw new IllegalArgumentException(\"No Ca2Length specified in \" + afpChain);\n    }\n    // Allow negative cp points for convenience.\n    if (cp == 0) {\n        return;\n    }\n    if (cp <= -ca2len || cp >= ca2len) {\n        // could just take cp%ca2len, but probably its a bug if abs(cp)>=ca2len\n        throw new ArrayIndexOutOfBoundsException(String.format(\"Permutation point %d must be between %d and %d for %s\", cp, 1 - ca2len, ca2len - 1, afpChain.getName2()));\n    }\n    if (cp < 0) {\n        cp = cp + ca2len;\n    }\n    // the unprocessed alignment\n    int[][][] optAln = afpChain.getOptAln();\n    int[] optLen = afpChain.getOptLen();\n    // the processed alignment\n    List<List<List<Integer>>> blocks = new ArrayList<List<List<Integer>>>(afpChain.getBlockNum() * 2);\n    //Update residue indices\n    // newi = (oldi-cp) % N\n    for (int block = 0; block < afpChain.getBlockNum(); block++) {\n        if (optLen[block] < 1)\n            continue;\n        // set up storage for the current block\n        List<List<Integer>> currBlock = new ArrayList<List<Integer>>(2);\n        currBlock.add(new ArrayList<Integer>());\n        currBlock.add(new ArrayList<Integer>());\n        blocks.add(currBlock);\n        // pos = 0 case\n        currBlock.get(0).add(optAln[block][0][0]);\n        currBlock.get(1).add((optAln[block][1][0] + cp) % ca2len);\n        for (int pos = 1; pos < optLen[block]; pos++) {\n            //check if we need to start a new block\n            //this happens when the new alignment crosses the protein terminus\n            if (optAln[block][1][pos - 1] + cp < ca2len && optAln[block][1][pos] + cp >= ca2len) {\n                currBlock = new ArrayList<List<Integer>>(2);\n                currBlock.add(new ArrayList<Integer>());\n                currBlock.add(new ArrayList<Integer>());\n                blocks.add(currBlock);\n            }\n            currBlock.get(0).add(optAln[block][0][pos]);\n            currBlock.get(1).add((optAln[block][1][pos] + cp) % ca2len);\n        }\n    }\n    // save permuted blocks to afpChain\n    assignOptAln(afpChain, blocks);\n}","repo_id":"9","comment":"/**\n * Modifies the {@link AFPChain#setOptAln(int[][][]) optAln} of an AFPChain\n * by permuting the second protein.\n *\n * Sets residue numbers in the second protein to <i>(i-cp)%len<\/i>\n *\n * @param afpChain\n * @param cp Amount leftwards (or rightward, if negative) to shift the\n */\n","repo_name":"biojava-master/","id":787,"method_signature":"void permuteOptAln(AFPChain, int)"}