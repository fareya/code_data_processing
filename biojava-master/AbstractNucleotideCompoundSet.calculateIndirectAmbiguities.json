{"callee_method_names":["C.isAmbiguous","Set<NucleotideCompound>.containsAll","Map<NucleotideCompound, List<NucleotideCompound>>.keySet","Map<NucleotideCompound, List<NucleotideCompound>>.get"],"method_name":"AbstractNucleotideCompoundSet.calculateIndirectAmbiguities","method_implementation":"{\n    Map<NucleotideCompound, List<NucleotideCompound>> equivalentsMap = new HashMap<NucleotideCompound, List<NucleotideCompound>>();\n    List<NucleotideCompound> ambiguousCompounds = getAllCompounds().stream().filter(compound -> compound.isAmbiguous()).collect(Collectors.toCollection(ArrayList::new));\n    for (NucleotideCompound sourceCompound : ambiguousCompounds) {\n        Set<NucleotideCompound> compoundConstituents = sourceCompound.getConstituents();\n        for (NucleotideCompound targetCompound : ambiguousCompounds) {\n            Set<NucleotideCompound> targetConstituents = targetCompound.getConstituents();\n            if (targetConstituents.containsAll(compoundConstituents)) {\n                NucleotideCompound lcSourceCompound = toLowerCase(sourceCompound);\n                NucleotideCompound lcTargetCompound = toLowerCase(targetCompound);\n                //equivalentsMap.put(sourceCompound, targetCompound);\n                //      equivalentsMap.put(sourceCompound, lcTargetCompound);\n                checkAdd(equivalentsMap, sourceCompound, targetCompound);\n                checkAdd(equivalentsMap, sourceCompound, lcTargetCompound);\n                checkAdd(equivalentsMap, targetCompound, sourceCompound);\n                checkAdd(equivalentsMap, lcTargetCompound, sourceCompound);\n                checkAdd(equivalentsMap, lcSourceCompound, targetCompound);\n                checkAdd(equivalentsMap, lcSourceCompound, lcTargetCompound);\n            }\n        }\n    }\n    //And once it's all done start adding them to the equivalents map\n    for (NucleotideCompound key : equivalentsMap.keySet()) {\n        List<NucleotideCompound> vals = equivalentsMap.get(key);\n        for (NucleotideCompound value : vals) {\n            addEquivalent((C) key, (C) value);\n            addEquivalent((C) value, (C) key);\n        }\n    }\n}","repo_id":"9","comment":"/**\n * Loops through all known nucleotides and attempts to find which are\n * equivalent to each other. Also takes into account lower casing\n * nucleotides as well as upper-cased ones.\n */\n","repo_name":"biojava-master/","id":2955,"method_signature":"void calculateIndirectAmbiguities()"}