{"callee_method_ids":[529,808,820,830,826],"callee_method_names":["Logger.debug","Logger.debug","Logger.debug","StrucAligParameters.getDiagonalDistance","StrucAligParameters.getDiagonalDistance2","StrucAligParameters.getFragmentLength","Atom.setCoords","Matrix.set","StrucAligParameters.getFragmentMiniDistance","JointFragments.setCenter1","JointFragments.setCenter2","JointFragments.setRot","Atom.clone","JointFragments.setUnitv","StrucAligParameters.reduceInitialFragments","List<FragmentPair>.add","List<FragmentPair>.toArray","Logger.debug","Logger.debug","StrucAligParameters.isJoinFast","FragmentJoiner.approach_ap3","FragmentJoiner.extendFragments","StrucAligParameters.isJoinPlo","FragmentJoiner.frag_pairwise_compat","StrucAligParameters.getAngleDiff","StrucAligParameters.getFragCompat","StrucAligParameters.getMaxrefine","FragmentJoiner.approach_ap3","Logger.debug","Logger.debug","AlternativeAlignment.apairs_from_idxlst","AlternativeAlignment.setAltAligNumber","AlternativeAlignment.setDistanceMatrix","StrucAligParameters.getMaxIter","AlternativeAlignment.refine","AlternativeAlignment.finish","Logger.error","AlternativeAlignment.calcScores","List<AlternativeAlignment>.add","List<AlternativeAlignment>.sort","List<AlternativeAlignment>.toArray","AlternativeAlignment.setAltAligNumber","Logger.debug"],"method_name":"StructurePairAligner.align","method_implementation":"{\n    reset();\n    this.params = params;\n    long timeStart = System.currentTimeMillis();\n    // step 1 get all Diagonals of length X that are similar between both\n    // structures\n    logger.debug(\" length atoms1:{}\", ca1.length);\n    logger.debug(\" length atoms2:{}\", ca2.length);\n    logger.debug(\"step 1 - get fragments with similar intramolecular distances \");\n    int k = params.getDiagonalDistance();\n    int k2 = params.getDiagonalDistance2();\n    int fragmentLength = params.getFragmentLength();\n    if (ca1.length < (fragmentLength + 1)) {\n        throw new StructureException(\"structure 1 too short (\" + ca1.length + \"), can not align\");\n    }\n    if (ca2.length < (fragmentLength + 1)) {\n        throw new StructureException(\"structure 2 too short (\" + ca2.length + \"), can not align\");\n    }\n    int rows = ca1.length - fragmentLength + 1;\n    int cols = ca2.length - fragmentLength + 1;\n    distanceMatrix = new Matrix(rows, cols, 0.0);\n    double[] dist1 = AlignUtils.getDiagonalAtK(ca1, k);\n    double[] dist2 = AlignUtils.getDiagonalAtK(ca2, k);\n    double[] dist3 = new double[0];\n    double[] dist4 = new double[0];\n    if (k2 > 0) {\n        dist3 = AlignUtils.getDiagonalAtK(ca1, k2);\n        dist4 = AlignUtils.getDiagonalAtK(ca2, k2);\n    }\n    double[][] utmp = new double[][] { { 0, 0, 1 } };\n    Atom unitvector = new AtomImpl();\n    unitvector.setCoords(utmp[0]);\n    List<FragmentPair> fragments = new ArrayList<>();\n    for (int i = 0; i < rows; i++) {\n        Atom[] catmp1 = AlignUtils.getFragment(ca1, i, fragmentLength);\n        Atom center1 = AlignUtils.getCenter(ca1, i, fragmentLength);\n        for (int j = 0; j < cols; j++) {\n            double rdd1 = AlignUtils.rms_dk_diag(dist1, dist2, i, j, fragmentLength, k);\n            double rdd2 = 0;\n            if (k2 > 0)\n                rdd2 = AlignUtils.rms_dk_diag(dist3, dist4, i, j, fragmentLength, k2);\n            double rdd = rdd1 + rdd2;\n            distanceMatrix.set(i, j, rdd);\n            if (rdd < params.getFragmentMiniDistance()) {\n                FragmentPair f = new FragmentPair(fragmentLength, i, j);\n                Atom[] catmp2 = AlignUtils.getFragment(ca2, j, fragmentLength);\n                Atom center2 = AlignUtils.getCenter(ca2, j, fragmentLength);\n                f.setCenter1(center1);\n                f.setCenter2(center2);\n                Matrix4d t = SuperPositions.superpose(Calc.atomsToPoints(catmp1), Calc.atomsToPoints(catmp2));\n                Matrix rotmat = Matrices.getRotationJAMA(t);\n                f.setRot(rotmat);\n                Atom aunitv = (Atom) unitvector.clone();\n                Calc.rotate(aunitv, rotmat);\n                f.setUnitv(aunitv);\n                boolean doNotAdd = false;\n                if (params.reduceInitialFragments()) {\n                    doNotAdd = FragmentJoiner.reduceFragments(fragments, f, distanceMatrix);\n                }\n                if (doNotAdd)\n                    continue;\n                fragments.add(f);\n            }\n        }\n    }\n    notifyFragmentListeners(fragments);\n    FragmentPair[] fp = fragments.toArray(new FragmentPair[0]);\n    setFragmentPairs(fp);\n    logger.debug(\" got # fragment pairs: {}\", fp.length);\n    logger.debug(\"step 2 - join fragments\");\n    // step 2 combine them to possible models\n    FragmentJoiner joiner = new FragmentJoiner();\n    JointFragments[] frags;\n    if (params.isJoinFast()) {\n        // apply the quick alignment procedure.\n        // less quality in alignments, better for DB searches...\n        frags = joiner.approach_ap3(ca1, ca2, fp, params);\n        joiner.extendFragments(ca1, ca2, frags, params);\n    } else if (params.isJoinPlo()) {\n        // this approach by StrComPy (peter lackner):\n        frags = joiner.frag_pairwise_compat(fp, params.getAngleDiff(), params.getFragCompat(), params.getMaxrefine());\n    } else {\n        // my first implementation\n        frags = joiner.approach_ap3(ca1, ca2, fp, params);\n    }\n    notifyJointFragments(frags);\n    logger.debug(\" number joint fragments: {}\", frags.length);\n    logger.debug(\"step 3 - refine alignments\");\n    List<AlternativeAlignment> aas = new ArrayList<>();\n    for (int i = 0; i < frags.length; i++) {\n        JointFragments f = frags[i];\n        AlternativeAlignment a = new AlternativeAlignment();\n        a.apairs_from_idxlst(f);\n        a.setAltAligNumber(i + 1);\n        a.setDistanceMatrix(distanceMatrix);\n        try {\n            if (params.getMaxIter() > 0) {\n                a.refine(params, ca1, ca2);\n            } else {\n                a.finish(params, ca1, ca2);\n            }\n        } catch (StructureException e) {\n            logger.error(\"Refinement of fragment {} failed\", i, e);\n        }\n        a.calcScores(ca1, ca2);\n        aas.add(a);\n    }\n    // sort the alternative alignments\n    Comparator<AlternativeAlignment> comp = new AltAligComparator();\n    aas.sort(comp);\n    Collections.reverse(aas);\n    alts = aas.toArray(new AlternativeAlignment[0]);\n    // do final numbering of alternative solutions\n    int aanbr = 0;\n    for (AlternativeAlignment a : alts) {\n        aanbr++;\n        a.setAltAligNumber(aanbr);\n    }\n    logger.debug(\"total calculation time: {} ms.\", (System.currentTimeMillis() - timeStart));\n}","repo_id":"9","comment":"/**\n * Calculate the protein structure superimposition, between two sets of\n * atoms.\n *\n * @param ca1\n *            set of Atoms of structure 1\n * @param ca2\n *            set of Atoms of structure 2\n * @param params\n *            the parameters to use for the alignment\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":554,"method_signature":"void align(Atom[], Atom[], StrucAligParameters)"}