{"callee_method_names":["Map<Integer,Integer>.keySet","List<Integer>.iterator","Iterator<Integer>.hasNext","Iterator<Integer>.next","Map<Integer, Integer>.containsKey","Iterator<Integer>.remove","Map<Integer, Integer>.get","Iterator<Integer>.remove","Map<Integer,Double>.get","Iterator<Integer>.remove","Map<Integer,Integer>.get","NavigableSet<Integer>.add","NavigableSet<Integer>.add","Map<Integer,Double>.get","Iterator<Integer>.remove","List<Integer>.iterator","Iterator<Integer>.hasNext","Iterator<Integer>.next","Map<Integer, Integer>.get","NavigableSet<Integer>.floor","NavigableSet<Integer>.higher","Map<Integer,Integer>.get","Iterator<Integer>.remove","Map<Integer,Integer>.get","Iterator<Integer>.remove"],"method_name":"SequenceFunctionRefiner.initializeEligible","method_implementation":"{\n    // Eligible if:\n    // 1. score(x)>0\n    // 2. f^K-1(x) is defined\n    // 3. score(f^K-1(x))>0\n    // 4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n    // 5. Not in a loop of length less than k\n    // Assume all residues are eligible to start\n    if (eligible == null) {\n        eligible = new LinkedList<Integer>(alignment.keySet());\n    }\n    // Precalculate f^K-1(x)\n    // Map<Integer, Integer> alignK1 = AlignmentTools.applyAlignment(alignment, k-1);\n    Map<Integer, Integer> alignK1 = applyAlignmentAndCheckCycles(alignment, k - 1, eligible);\n    // Remove ineligible residues\n    Iterator<Integer> eligibleIt = eligible.iterator();\n    while (eligibleIt.hasNext()) {\n        Integer res = eligibleIt.next();\n        //  2. f^K-1(x) is defined\n        if (!alignK1.containsKey(res)) {\n            eligibleIt.remove();\n            continue;\n        }\n        Integer k1 = alignK1.get(res);\n        if (k1 == null) {\n            eligibleIt.remove();\n            continue;\n        }\n        //  1. score(x)>0\n        Double score = scores.get(res);\n        if (score == null || score <= 0.0) {\n            eligibleIt.remove();\n            // res is in a loop. Add it to the proper set\n            if (res <= alignment.get(res)) {\n                //forward\n                forwardLoops.add(res);\n            } else {\n                //backward\n                backwardLoops.add(res);\n            }\n            continue;\n        }\n        //\t3. score(f^K-1(x))>0\n        Double scoreK1 = scores.get(k1);\n        if (scoreK1 == null || scoreK1 <= 0.0) {\n            eligibleIt.remove();\n            continue;\n        }\n    }\n    // Now that loops are up-to-date, check for loop crossings\n    eligibleIt = eligible.iterator();\n    while (eligibleIt.hasNext()) {\n        Integer res = eligibleIt.next();\n        //4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n        //Test equivalent: All loop edges should be properly ordered wrt edge f^k-1(x) -> x\n        Integer src = alignK1.get(res);\n        if (src < res) {\n            //forward\n            // get interval [a,b) containing res\n            Integer a = forwardLoops.floor(src);\n            Integer b = forwardLoops.higher(src);\n            // Ineligible unless f(a) < res < f(b)\n            if (a != null && alignment.get(a) > res) {\n                eligibleIt.remove();\n                continue;\n            }\n            if (b != null && alignment.get(b) < res) {\n                eligibleIt.remove();\n                continue;\n            }\n        }\n    }\n    return eligible;\n}","repo_id":"9","comment":"/**\n * Helper method to initialize eligible residues.\n *\n * Eligible if:\n *  1. score(x)>0\n *  2. f^K-1(x) is defined\n *  3. score(f^K-1(x))>0\n *  4. For all y, score(y)==0 implies sign(f^K-1(x)-y) == sign(x-f(y) )\n * @param alignment The alignment with respect to which to calculate eligibility\n * @param scores An up-to-date map from residues to their scores\n * @param eligible Starting list of eligible residues. If null will be generated.\n * @param k\n * @param backwardLoops\n * @param forwardLoops\n * @return eligible after modification\n */\n","repo_name":"biojava-master/","id":2064,"method_signature":"List<Integer> initializeEligible(Map, Map, List, int, NavigableSet, NavigableSet)"}