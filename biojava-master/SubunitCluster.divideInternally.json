{"callee_method_ids":[1616,2053,1626,2055,1630,2055],"callee_method_names":["CESymmParameters.setMinCoreLength","SubunitClustererParameters.getMinimumSequenceLength","CESymmParameters.setGaps","ArrayList.get","CeSymmResult.isSignificant","CeSymmResult.getMultipleAlignment","SubunitClustererParameters.getRMSDThreshold","CeSymmResult.getMultipleAlignment","CeSymmResult.getNumRepeats","SubunitClustererParameters.getStructureCoverageThreshold","Logger.info","CeSymmResult.getNumRepeats","CeSymmResult.getMultipleAlignment","List<List<Integer>>.size","List<List<Integer>>.add","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.size","ArrayList.get","List<List<Integer>>.get","List<List<Integer>>.size","List<List<Integer>>.get","ArrayList.get","List<List<Integer>>.get","ArrayList.size","List<List<Integer>>.size","ArrayList.size","List<List<Integer>>.size","ArrayList.size","List<List<Integer>>.size","ArrayList.get","List<List<Integer>>.get","ArrayList.get","List<List<Integer>>.get","List<List<Integer>>.get","ArrayList.get","List<Subunit>.add","ArrayList.get","ArrayList.get","ArrayList.get","List<List<Integer>>.get","List<Integer>.add","ArrayList.get","List<List<Integer>>.get","List<List<Integer>>.add","ArrayList.size","ArrayList.get","ArrayList.get"],"method_name":"SubunitCluster.divideInternally","method_implementation":"{\n    CESymmParameters cesym_params = new CESymmParameters();\n    cesym_params.setMinCoreLength(clusterParams.getMinimumSequenceLength());\n    // We want no gaps between the repeats\n    cesym_params.setGaps(false);\n    // Analyze the internal symmetry of the representative subunit\n    CeSymmResult result = CeSymm.analyze(subunits.get(representative).getRepresentativeAtoms(), cesym_params);\n    if (!result.isSignificant())\n        return false;\n    double rmsd = result.getMultipleAlignment().getScore(MultipleAlignmentScorer.RMSD);\n    if (rmsd > clusterParams.getRMSDThreshold())\n        return false;\n    double coverage = result.getMultipleAlignment().getCoverages().get(0) * result.getNumRepeats();\n    if (coverage < clusterParams.getStructureCoverageThreshold())\n        return false;\n    logger.info(\"SubunitCluster is internally symmetric with {} repeats, \" + \"{} RMSD and {} coverage\", result.getNumRepeats(), rmsd, coverage);\n    // Divide if symmety was significant with RMSD and coverage sufficient\n    List<List<Integer>> alignedRes = result.getMultipleAlignment().getBlock(0).getAlignRes();\n    List<List<Integer>> columns = new ArrayList<>();\n    for (int s = 0; s < alignedRes.size(); s++) columns.add(new ArrayList<>(alignedRes.get(s).size()));\n    // Extract the aligned columns of each repeat in the Subunit\n    for (int col = 0; col < alignedRes.get(0).size(); col++) {\n        // Check that all aligned residues are part of the Cluster\n        boolean missing = false;\n        for (int s = 0; s < alignedRes.size(); s++) {\n            if (!subunitEQR.get(representative).contains(alignedRes.get(s).get(col))) {\n                missing = true;\n                break;\n            }\n        }\n        // Skip the column if any residue was not part of the cluster\n        if (missing)\n            continue;\n        for (int s = 0; s < alignedRes.size(); s++) {\n            columns.get(s).add(subunitEQR.get(representative).indexOf(alignedRes.get(s).get(col)));\n        }\n    }\n    // Divide the Subunits in their repeats\n    List<Subunit> newSubunits = new ArrayList<Subunit>(subunits.size() * columns.size());\n    List<List<Integer>> newSubunitEQR = new ArrayList<List<Integer>>(subunits.size() * columns.size());\n    for (int s = 0; s < subunits.size(); s++) {\n        for (int r = 0; r < columns.size(); r++) {\n            // Calculate start and end residues of the new Subunit\n            int start = subunitEQR.get(s).get(columns.get(r).get(0));\n            int end = subunitEQR.get(s).get(columns.get(r).get(columns.get(r).size() - 1));\n            Atom[] reprAtoms = Arrays.copyOfRange(subunits.get(s).getRepresentativeAtoms(), start, end + 1);\n            newSubunits.add(new Subunit(reprAtoms, subunits.get(s).getName(), subunits.get(s).getIdentifier(), subunits.get(s).getStructure()));\n            // Recalculate equivalent residues\n            List<Integer> eqr = new ArrayList<Integer>();\n            for (int p = 0; p < columns.get(r).size(); p++) {\n                eqr.add(subunitEQR.get(s).get(columns.get(r).get(p)) - start);\n            }\n            newSubunitEQR.add(eqr);\n        }\n    }\n    subunits = newSubunits;\n    subunitEQR = newSubunitEQR;\n    // Update representative\n    for (int s = 0; s < subunits.size(); s++) {\n        if (subunits.get(s).size() > subunits.get(representative).size())\n            representative = s;\n    }\n    method = SubunitClustererMethod.STRUCTURE;\n    pseudoStoichiometric = true;\n    return true;\n}","repo_id":"9","comment":"/**\n * Analyze the internal symmetry of the SubunitCluster and divide its\n * {@link Subunit} into the internal repeats (domains) if they are\n * internally symmetric.\n *\n * @param clusterParams {@link SubunitClustererParameters} with fields used as follows:\n * structureCoverageThreshold\n *            the minimum coverage of all repeats in the Subunit\n * rmsdThreshold\n *            the maximum allowed RMSD between the repeats\n * minimumSequenceLength\n *            the minimum length of the repeating units\n * @return true if the cluster was internally symmetric, false otherwise\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":1661,"method_signature":"boolean divideInternally(SubunitClustererParameters)"}