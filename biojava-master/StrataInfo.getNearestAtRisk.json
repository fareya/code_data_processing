{"callee_method_names":["ArrayList.size","ArrayList.get","DecimalFormat.format","ArrayList.size","ArrayList.get"],"method_name":"StrataInfo.getNearestAtRisk","method_implementation":"{\n    Integer index = 0;\n    /*       String timeValue = t + \"\";\n\t\tString format = \"#\";\n\t\tint numDecimals = 0;\n\t\tint decimalIndex = timeValue.indexOf(\".\");\n\t\tif (decimalIndex > 0) {\n\t\t\tfor (int i = timeValue.length() - 1; i > decimalIndex; i--) {\n\t\t\t\tif (timeValue.charAt(i) == '0' && numDecimals == 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (i == decimalIndex - 1) {\n\t\t\t\t\tformat = format + \".#\";\n\t\t\t\t} else {\n\t\t\t\t\tformat = format + \"#\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n */\n    //used to round on expected precision of time. Not correct but trying to match the other packages\n    DecimalFormat newFormat = new DecimalFormat(\"#.#\");\n    for (int i = 0; i < time.size(); i++) {\n        Double compareTime = time.get(i);\n        //  compareTime = new Double(Math.round(compareTime)); //this is rounding up so that we stop on the first match trying to get this to match another report. Not correct or the other report is wrong\n        compareTime = Double.valueOf(newFormat.format(compareTime));\n        if (compareTime < t) {\n            index = i + 1;\n        } else if (compareTime == t) {\n            index = i;\n            break;\n        } else {\n            break;\n        }\n    }\n    //http://www.inside-r.org/packages/cran/rms/docs/survplot\n    //per validation using survplot from RMS package and ggkm they select the next\n    //time in the future which doesn't seem to be correct as the next time represents\n    //knowledge about the future but maybe nrisk at that point in time is defined\n    //as the nrisk prior to that time. This appears to be the case where at time 0\n    //you would expect that everyone is at risk and you should report that time which\n    //is the case in survplot. Added in index = 0 or if the time you are requesting has\n    //an exact match\n    //survplot(kma,n.risk=TRUE,time.inc=1090)\n    //ggkm(kma,timeby=1090)\n    //     if(index != 0 && time.get(index) != t){\n    //      index++;\n    //     }\n    if (index >= nrisk.size()) {\n        return null;\n    } else {\n        return nrisk.get(index);\n    }\n}","repo_id":"9","comment":"/**\n * Selection of number of risk will depend on the precision and rounding of\n * time in the survival table. If you are asking for 12 and entry exists for\n * 11.9999999 then 12 is greater than 11.99999 unless you round.\n *\n * @param t\n * @return\n */\n","repo_name":"biojava-master/","id":3513,"method_signature":"Double getNearestAtRisk(double)"}