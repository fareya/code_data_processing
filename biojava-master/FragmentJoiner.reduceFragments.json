{"callee_method_names":["FragmentPair.getPos1","FragmentPair.getPos2","List<FragmentPair>.size","List<FragmentPair>.get","FragmentPair.getPos1","FragmentPair.getPos1","FragmentPair.getPos2","FragmentPair.getPos2","Matrix.get","FragmentPair.getPos1","FragmentPair.getPos2","Matrix.get","List<FragmentPair>.remove","List<FragmentPair>.add","List<FragmentPair>.size"],"method_name":"FragmentJoiner.reduceFragments","method_implementation":"{\n    boolean doNotAdd = false;\n    int i = f.getPos1();\n    int j = f.getPos2();\n    for (int p = 0; p < fragments.size(); p++) {\n        FragmentPair tmp = fragments.get(p);\n        int di1 = Math.abs(f.getPos1() - tmp.getPos1());\n        int di2 = Math.abs(f.getPos2() - tmp.getPos2());\n        if ((Math.abs(di1 - di2) == 2)) {\n            double rms1 = rmsmat.get(tmp.getPos1(), tmp.getPos2());\n            double rms2 = rmsmat.get(i, j);\n            doNotAdd = true;\n            if (rms2 < rms1) {\n                fragments.remove(p);\n                fragments.add(f);\n                break;\n            }\n            p = fragments.size();\n        }\n    }\n    return doNotAdd;\n}","repo_id":"9","comment":"/**\n *  In helices often many similar fragments can be found. To reduce these to a few\n *  representative ones this check can be used. It does a distance check between\n *  all known Fragments and a new one. If this one is on a similar diagonal and it\n *  has a lower rms, this one is a better representation. Note: shifts of one are\n *  not allowed.\n *\n * @param fragments\n * @param f\n * @param rmsmat\n * @return true - if this is a better representant for a group of locala fragments.\n */\n","repo_name":"biojava-master/","id":805,"method_signature":"boolean reduceFragments(List, FragmentPair, Matrix)"}