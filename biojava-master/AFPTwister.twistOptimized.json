{"callee_method_ids":[487,490,489,498],"callee_method_names":["AFPChain.getBlockNum","AFPChain.getFocusRes1","AFPChain.getFocusRes2","AFPChain.getCa1Length","AFPChain.setFocusRes1","AFPChain.getCa2Length","AFPChain.setFocusRes2","AFPChain.getOptLen","AFPChain.getOptAln","Logger.debug","Logger.debug","AFPChain.getOptLength","Logger.warn","Logger.debug","AFPChain.setTotalLenOpt","AFPChain.setTotalRmsdOpt"],"method_name":"AFPTwister.twistOptimized","method_implementation":"{\n    Atom[] optTwistPdb = new Atom[ca2.length];\n    int gPos = -1;\n    for (Atom a : ca2) {\n        gPos++;\n        optTwistPdb[gPos] = a;\n    }\n    int blockNum = afpChain.getBlockNum();\n    int b2 = 0;\n    int e2 = 0;\n    int focusResn = 0;\n    int[] focusRes1 = afpChain.getFocusRes1();\n    int[] focusRes2 = afpChain.getFocusRes2();\n    if (focusRes1 == null) {\n        focusRes1 = new int[afpChain.getCa1Length()];\n        afpChain.setFocusRes1(focusRes1);\n    }\n    if (focusRes2 == null) {\n        focusRes2 = new int[afpChain.getCa2Length()];\n        afpChain.setFocusRes2(focusRes2);\n    }\n    int[] optLen = afpChain.getOptLen();\n    int[][][] optAln = afpChain.getOptAln();\n    for (int bk = 0; bk < blockNum; bk++) {\n        // THIS IS TRANSFORMING THE ORIGINAL ca2 COORDINATES, NO CLONING...\n        // copies the atoms over to iniTwistPdb later on in modifyCod\n        transformOrigPDB(optLen[bk], optAln[bk][0], optAln[bk][1], ca1, ca2, afpChain, bk);\n        // transform pro2 according to comparison of pro1 and pro2 at give\n        // residues\n        if (bk > 0) {\n            b2 = e2;\n        }\n        if (bk < blockNum - 1) {\n            // bend at the middle of two consecutive\n            // blocks\n            e2 = optAln[bk][1][optLen[bk] - 1];\n            e2 = (optAln[bk + 1][1][0] - e2) / 2 + e2;\n        } else {\n            e2 = ca2.length;\n        }\n        cloneAtomRange(optTwistPdb, ca2, b2, e2);\n        for (int i = 0; i < optLen[bk]; i++) {\n            focusRes1[focusResn] = optAln[bk][0][i];\n            focusRes2[focusResn] = optAln[bk][1][i];\n            focusResn++;\n        }\n    }\n    int totalLenOpt = focusResn;\n    logger.debug(\"calrmsdopt for {} residues\", focusResn);\n    double totalRmsdOpt = calCaRmsd(ca1, optTwistPdb, focusResn, focusRes1, focusRes2);\n    logger.debug(\"got opt RMSD: {}\", totalRmsdOpt);\n    int optLength = afpChain.getOptLength();\n    if (totalLenOpt != optLength) {\n        logger.warn(\"Final alignment length is different {} {}\", totalLenOpt, optLength);\n    }\n    logger.debug(\"final alignment length {}, rmsd {}\", focusResn, totalRmsdOpt);\n    afpChain.setTotalLenOpt(totalLenOpt);\n    afpChain.setTotalRmsdOpt(totalRmsdOpt);\n    return StructureTools.cloneGroups(optTwistPdb);\n}","repo_id":"9","comment":"/**\n * superimposing according to the optimized alignment\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n * @return Group array twisted.\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":539,"method_signature":"Group[] twistOptimized(AFPChain, Atom[], Atom[])"}