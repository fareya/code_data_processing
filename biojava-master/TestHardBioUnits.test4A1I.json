{"callee_method_names":["Structure.nrModels","Structure.getPolyChains","Structure.getPolyChains","Set<String>.add","PolymerType.getName","Set<String>.size","Set<String>.contains","Set<String>.contains","Set<String>.contains","Set<String>.contains","Structure.getPolyChainByPDB","Structure.getPolyChainByPDB","Structure.getPolyChains","Chain.getName","Chain.getName","SuperPosition.superposeAndTransform","SuperPosition.superposeAndTransform"],"method_name":"TestHardBioUnits.test4A1I","method_implementation":"{\n    String pdbId = \"4A1I\";\n    int biolAssemblyNr = 2;\n    Structure bioAssembly = StructureIO.getBiologicalAssembly(pdbId, biolAssemblyNr);\n    if (bioAssembly == null) {\n        System.err.println(\"Could not generate the biological assembly \" + pdbId + \" nr \" + biolAssemblyNr);\n    }\n    /*\n\t\t * loop_\n\t\t\t\t_pdbx_struct_assembly_gen.assembly_id\n\t\t\t\t_pdbx_struct_assembly_gen.oper_expression\n\t\t\t\t_pdbx_struct_assembly_gen.asym_id_list\n\t\t\t\t1 1 A,I,J,K,L,M,N,UA,H,PA,QA,RA,SA,TA,BB\n\t\t\t\t2 1 G,KA,LA,MA,NA,OA,AB\n\t\t\t\t2 2 B,O,P,Q,R,VA\n\t\t\t\t3 1 B,O,P,Q,R,VA\n\t\t\t\t3 3 G,KA,LA,MA,NA,OA,AB\n\t\t\t\t4 1 C,S,T,U,V,W,WA,F,FA,GA,HA,IA,JA,ZA\n\t\t\t\t5 1 D,X,Y,Z,XA,E,AA,BA,CA,DA,EA,YA\n\t\t */\n    //System.out.println(bioAssembly.toPDB());\n    assertEquals(1, bioAssembly.nrModels());\n    assertEquals(2, bioAssembly.getPolyChains().size());\n    // here we'll store all author chain ids without the operator id part\n    Set<String> chainIdsNoOps = new HashSet<String>();\n    for (Chain poly : bioAssembly.getPolyChains()) {\n        chainIdsNoOps.add(poly.getName().split(\"_\")[0]);\n    }\n    assertEquals(2, chainIdsNoOps.size());\n    // we should have B and G only\n    assertTrue(chainIdsNoOps.contains(\"B\"));\n    assertTrue(chainIdsNoOps.contains(\"G\"));\n    assertFalse(chainIdsNoOps.contains(\"A\"));\n    assertFalse(chainIdsNoOps.contains(\"H\"));\n    // now let's check that the right operators were applied to the right chains\n    // first we need the original structure\n    Structure original = StructureIO.getStructure(pdbId);\n    Point3d[] atomsOrigChainG = Calc.atomsToPoints(StructureTools.getAtomCAArray(original.getPolyChainByPDB(\"G\")));\n    Point3d[] atomsOrigChainB = Calc.atomsToPoints(StructureTools.getAtomCAArray(original.getPolyChainByPDB(\"B\")));\n    List<Chain> bioAssemblyChains = bioAssembly.getPolyChains();\n    Chain transfChainB = null;\n    Chain transfChainG = null;\n    // get the bioassembly's equivalent chains B and G\n    for (Chain c : bioAssemblyChains) {\n        if (c.getName().startsWith(\"B\"))\n            transfChainB = c;\n        if (c.getName().startsWith(\"G\"))\n            transfChainG = c;\n    }\n    assertNotNull(transfChainB);\n    assertNotNull(transfChainG);\n    Point3d[] atomsTransfChainG = Calc.atomsToPoints(StructureTools.getAtomCAArray(transfChainG));\n    Point3d[] atomsTransfChainB = Calc.atomsToPoints(StructureTools.getAtomCAArray(transfChainB));\n    SuperPosition superPosition = new SuperPositionSVD(false);\n    // operator 1 is the identity, trace should be == 3\n    Matrix4d m1 = superPosition.superposeAndTransform(atomsOrigChainG, atomsTransfChainG);\n    assertEquals(3.0, m1.m00 + m1.m11 + m1.m22, 0.00001);\n    assertEquals(0.0, CalcPoint.rmsd(atomsOrigChainG, atomsTransfChainG), 0.00001);\n    // operator 2 is a 2-fold, trace should be == -1\n    Matrix4d m2 = superPosition.superposeAndTransform(atomsOrigChainB, atomsTransfChainB);\n    assertEquals(-1.0, m2.m00 + m2.m11 + m2.m22, 0.00001);\n    assertEquals(0.0, CalcPoint.rmsd(atomsOrigChainB, atomsTransfChainB), 0.00001);\n}","repo_id":"9","comment":"/**\n * This tests that the biounit is correctly represented (should work from all sources mmcif, pdb, mmtf)\n * @throws IOException\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":2221,"method_signature":"void test4A1I()"}