{"callee_method_names":["List<Atom[]>.get","List<Atom[]>.get","List<Atom[]>.size","List<Atom[]>.get"],"method_name":"MultipleAlignmentScorer.getRefRMSD","method_implementation":"{\n    double sumSqDist = 0;\n    int totalLength = 0;\n    for (int c = 0; c < transformed.get(reference).length; c++) {\n        Atom refAtom = transformed.get(reference)[c];\n        if (refAtom == null)\n            continue;\n        double nonNullSqDist = 0;\n        int nonNullLength = 0;\n        for (int r = 0; r < transformed.size(); r++) {\n            if (r == reference)\n                continue;\n            Atom atom = transformed.get(r)[c];\n            if (atom != null) {\n                nonNullSqDist += Calc.getDistanceFast(refAtom, atom);\n                nonNullLength++;\n            }\n        }\n        if (nonNullLength > 0) {\n            totalLength++;\n            sumSqDist += nonNullSqDist / nonNullLength;\n        }\n    }\n    return Math.sqrt(sumSqDist / totalLength);\n}","repo_id":"9","comment":"/**\n * Calculates the average RMSD from all structures to a reference s\n * tructure, given a set of superimposed atoms.\n * <p>\n * Complexity: T(n,l) = O(l*n), if n=number of structures and l=alignment\n * length.\n * <p>\n * For ungapped alignments, this is just the sqroot of the average distance\n * from an atom to the aligned atom from the reference. Thus, for R\n * structures aligned over C columns (with structure 0 as the reference), we\n * have:\n *\n * <pre>\n * RefRMSD = \\sqrt{ 1/(C*(R-1)) * \\sum_{r=1}^{R-1} \\sum_{j=0}^{C-1}\n * (atom[1][c]-atom[r][c])^2 }\n * <\/pre>\n * <p>\n * For gapped alignments, null atoms are omitted from consideration, so that\n * the RMSD is the average over all columns with non-null reference of the\n * average RMSD within the non-null elements of the column.\n *\n * @param transformed\n * @param reference\n * @return\n */\n","repo_name":"biojava-master/","id":681,"method_signature":"double getRefRMSD(List, int)"}