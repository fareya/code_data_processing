{"callee_method_ids":[1907,1942,1942,1907,1951],"callee_method_names":["QuatSymmetrySubunits.getSubunitCount","Point3d[].set","List<Integer>.get","Matrix4d.set","AxisAngle4d.set","Vector3d.lengthSquared","Vector3d.normalize","QuatSymmetryParameters.getRmsdThreshold","QuatSymmetryScores.getRmsd","QuatSymmetryScores.getRmsd","QuatSymmetryParameters.getRmsdThreshold","QuatSymmetryScores.setRmsdCenters"],"method_name":"RotationSolver.superimposePermutation","method_implementation":"{\n    // permutate subunits\n    for (int j = 0, n = subunits.getSubunitCount(); j < n; j++) {\n        transformedCoords[j].set(originalCoords[permutation.get(j)]);\n    }\n    int fold = PermutationGroup.getOrder(permutation);\n    // get optimal transformation and axisangle by subunit superposition\n    // TODO implement this piece of code using at origin superposition\n    Quat4d quat = UnitQuaternions.relativeOrientation(originalCoords, transformedCoords);\n    AxisAngle4d axisAngle = new AxisAngle4d();\n    Matrix4d transformation = new Matrix4d();\n    transformation.set(quat);\n    axisAngle.set(quat);\n    Vector3d axis = new Vector3d(axisAngle.x, axisAngle.y, axisAngle.z);\n    if (axis.lengthSquared() < 1.0E-6) {\n        axisAngle.x = 0;\n        axisAngle.y = 0;\n        axisAngle.z = 1;\n        axisAngle.angle = 0;\n    } else {\n        axis.normalize();\n        axisAngle.x = axis.x;\n        axisAngle.y = axis.y;\n        axisAngle.z = axis.z;\n    }\n    CalcPoint.transform(transformation, transformedCoords);\n    double subunitRmsd = CalcPoint.rmsd(transformedCoords, originalCoords);\n    if (subunitRmsd < parameters.getRmsdThreshold()) {\n        combineWithTranslation(transformation);\n        // evaluate superposition of CA traces\n        QuatSymmetryScores scores = QuatSuperpositionScorer.calcScores(subunits, transformation, permutation);\n        if (scores.getRmsd() < 0.0 || scores.getRmsd() > parameters.getRmsdThreshold()) {\n            return null;\n        }\n        scores.setRmsdCenters(subunitRmsd);\n        Rotation symmetryOperation = createSymmetryOperation(permutation, transformation, axisAngle, fold, scores);\n        return symmetryOperation;\n    }\n    return null;\n}","repo_id":"9","comment":"/**\n * Superimpose subunits based on the given permutation. Then check whether\n * the superposition passes RMSD thresholds and create a Rotation to\n * represent it if so.\n * @param permutation A list specifying which subunits should be aligned by the current transformation\n * @return A Rotation representing the permutation, or null if the superposition did not meet thresholds.\n */\n","repo_name":"biojava-master/","id":1901,"method_signature":"Rotation superimposePermutation(List)"}