{"callee_method_names":["AtomContactSet.iterator","Iterator<AtomContact>.hasNext","Iterator<AtomContact>.next","AtomContact.getPair","AtomContact.getPair","Map<ResidueNumber, Integer>.get","Group.getResidueNumber","Map<ResidueNumber, Integer>.get","Group.getResidueNumber","List<Pair<Integer>>.add","Point3d.getFirst","Point3d.getSecond"],"method_name":"SecStrucCalc.findBridges","method_implementation":"{\n    // Get the interator of contacts\n    Iterator<AtomContact> myIter = contactSet.iterator();\n    List<Pair<Integer>> outList = new ArrayList<Pair<Integer>>();\n    // Now iterate through this\n    while (myIter.hasNext()) {\n        // Get the next atom contact\n        AtomContact ac = myIter.next();\n        Group g1 = ac.getPair().getFirst().getGroup();\n        Group g2 = ac.getPair().getSecond().getGroup();\n        // Get the indices\n        int i = indResMap.get(g1.getResidueNumber());\n        int j = indResMap.get(g2.getResidueNumber());\n        // If i>j switch them over\n        if (i > j) {\n            // Switch them over\n            int old = i;\n            i = j;\n            j = old;\n        }\n        // Only these\n        if (j < i + 3) {\n            continue;\n        }\n        // If it's the first\n        if (i == 0) {\n            continue;\n        }\n        if (j == 0) {\n            continue;\n        }\n        // If it's the last\n        if (i == groups.length - 1) {\n            continue;\n        }\n        if (j == groups.length - 1) {\n            continue;\n        }\n        Pair<Integer> thisPair = new Pair<Integer>(i, j);\n        outList.add(thisPair);\n    }\n    //\n    Collections.sort(outList, new Comparator<Pair<Integer>>() {\n\n        @Override\n        public int compare(Pair<Integer> o1, Pair<Integer> o2) {\n            if (o1.getFirst() < o2.getFirst()) {\n                return -1;\n            } else if (o1.getFirst() > o2.getFirst()) {\n                return +1;\n            } else {\n                if (o1.getSecond() < o2.getSecond()) {\n                    return -1;\n                } else if (o1.getSecond() > o2.getSecond()) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n        }\n    });\n    for (Pair<Integer> p : outList) {\n        int i = p.getFirst();\n        int j = p.getSecond();\n        BridgeType btype = null;\n        // Now do the bonding\n        if ((isBonded(i - 1, j) && isBonded(j, i + 1)) || (isBonded(j - 1, i) && isBonded(i, j + 1))) {\n            btype = BridgeType.parallel;\n        } else if ((isBonded(i, j) && isBonded(j, i)) || (isBonded(i - 1, j + 1) && (isBonded(j - 1, i + 1)))) {\n            btype = BridgeType.antiparallel;\n        }\n        if (btype != null) {\n            registerBridge(i, j, btype);\n        }\n    }\n}","repo_id":"9","comment":"/**\n * Two nonoverlapping stretches of three residues each, i-1,i,i+1 and\n * j-1,j,j+1, form either a parallel or antiparallel bridge, depending on\n * which of two basic patterns is matched. We assign a bridge between\n * residues i and j if there are two H bonds characteristic of beta-\n * structure; in particular:\n * <p>\n * Parallel Bridge(i,j) =: [Hbond(i-1,j) and Hbond(j,i+1)]\n * \t\t\t\t\t\t\tor [Hbond(j-1,i) and Hbond(i,j+1)]\n * <p>\n * Antiparallel Bridge(i,j) =: [Hbond(i,j) and Hbond(j,i)]\n * \t\t\t\t\t\t\t\tor [Hbond(i-1,j+1) and Hbond(j-1,i+1)]\n *\n * Optimised to use the contact set\n */\n","repo_name":"biojava-master/","id":1593,"method_signature":"void findBridges()"}