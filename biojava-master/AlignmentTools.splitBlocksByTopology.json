{"callee_method_ids":[489,487,490],"callee_method_names":["AFPChain.getOptAln","AFPChain.getBlockNum","AFPChain.getOptLen","List<Integer>.add","List<Integer>.add","List<Integer>.add","List<Integer>.size","List<int[][]>.add","List<int[][]>.add","List<int[][]>.toArray","List<Integer>.size","List<Integer>.size","List<Integer>.get","List<int[][]>.size"],"method_name":"AlignmentTools.splitBlocksByTopology","method_implementation":"{\n    int[][][] optAln = a.getOptAln();\n    int blockNum = a.getBlockNum();\n    int[] optLen = a.getOptLen();\n    // Determine block lengths\n    // Split blocks if residue indices don't increase monotonically\n    List<Integer> newBlkLen = new ArrayList<Integer>();\n    boolean blockChanged = false;\n    for (int blk = 0; blk < blockNum; blk++) {\n        int currLen = 1;\n        for (int pos = 1; pos < optLen[blk]; pos++) {\n            if (optAln[blk][0][pos] <= optAln[blk][0][pos - 1] || optAln[blk][1][pos] <= optAln[blk][1][pos - 1]) {\n                //start a new block\n                newBlkLen.add(currLen);\n                currLen = 0;\n                blockChanged = true;\n            }\n            currLen++;\n        }\n        if (optLen[blk] < 2) {\n            newBlkLen.add(optLen[blk]);\n        } else {\n            newBlkLen.add(currLen);\n        }\n    }\n    // Check if anything needs to be split\n    if (!blockChanged) {\n        return a;\n    }\n    // Split blocks\n    List<int[][]> blocks = new ArrayList<int[][]>(newBlkLen.size());\n    int oldBlk = 0;\n    int pos = 0;\n    for (int blkLen : newBlkLen) {\n        if (blkLen == optLen[oldBlk]) {\n            //should be the whole block\n            assert (pos == 0);\n            // Use the old block\n            blocks.add(optAln[oldBlk]);\n        } else {\n            int[][] newBlock = new int[2][blkLen];\n            // don't overrun block\n            assert (pos + blkLen <= optLen[oldBlk]);\n            for (int i = 0; i < blkLen; i++) {\n                newBlock[0][i] = optAln[oldBlk][0][pos + i];\n                newBlock[1][i] = optAln[oldBlk][1][pos + i];\n            }\n            pos += blkLen;\n            blocks.add(newBlock);\n            if (pos == optLen[oldBlk]) {\n                // Finished this oldBlk, start the next\n                oldBlk++;\n                pos = 0;\n            }\n        }\n    }\n    // Store new blocks\n    int[][][] newOptAln = blocks.toArray(new int[0][][]);\n    int[] newBlockLens = new int[newBlkLen.size()];\n    for (int i = 0; i < newBlkLen.size(); i++) {\n        newBlockLens[i] = newBlkLen.get(i);\n    }\n    return replaceOptAln(a, ca1, ca2, blocks.size(), newBlockLens, newOptAln);\n}","repo_id":"9","comment":"/**\n * @param a\n * @param ca1\n * @param ca2\n * @return\n * @throws StructureException if an error occurred during superposition\n */\n","repo_name":"biojava-master/","id":590,"method_signature":"AFPChain splitBlocksByTopology(AFPChain, Atom[], Atom[])"}