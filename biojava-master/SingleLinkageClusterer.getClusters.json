{"callee_method_names":["Map<Integer, Set<Integer>>.keySet","Map<Integer, Set<Integer>>.get","Set<Integer>.contains","LinkedPair[].getFirst","Set<Integer>.contains","LinkedPair[].getSecond","Set<Integer>.add","LinkedPair[].getFirst","Set<Integer>.add","LinkedPair[].getSecond","Map<Integer, Set<Integer>>.put","Map<Integer, Set<Integer>>.get","LinkedPair[].getSecond","Map<Integer, Set<Integer>>.get","LinkedPair[].getFirst","Map<Integer, Set<Integer>>.get","Map<Integer, Set<Integer>>.get","Set<Integer>.size","Set<Integer>.size","Logger.debug","Set<Integer>.add","Map<Integer, Set<Integer>>.remove","Logger.debug","Set<Integer>.add","Map<Integer, Set<Integer>>.remove","Logger.debug","Logger.debug","Map<Integer, Set<Integer>>.keySet","Map<Integer, Set<Integer>>.put","Map<Integer, Set<Integer>>.get","Map<Integer, Set<Integer>>.values","StructureInterfaceCluster.contains","Set<Integer>.add","Map<Integer, Set<Integer>>.put","Logger.debug"],"method_name":"SingleLinkageClusterer.getClusters","method_implementation":"{\n    if (dendrogram == null) {\n        clusterIt();\n    }\n    Map<Integer, Set<Integer>> clusters = new TreeMap<Integer, Set<Integer>>();\n    int clusterId = 1;\n    for (int i = 0; i < numItems - 1; i++) {\n        if (isWithinCutoff(i, cutoff)) {\n            //int containingClusterId = getContainingCluster(clusters, dendrogram[i]);\n            int firstClusterId = -1;\n            int secondClusterId = -1;\n            for (int cId : clusters.keySet()) {\n                Set<Integer> members = clusters.get(cId);\n                if (members.contains(dendrogram[i].getFirst())) {\n                    firstClusterId = cId;\n                }\n                if (members.contains(dendrogram[i].getSecond())) {\n                    secondClusterId = cId;\n                }\n            }\n            if (firstClusterId == -1 && secondClusterId == -1) {\n                // neither member is in a cluster yet, let's assign a new cluster and put them both in\n                Set<Integer> members = new TreeSet<Integer>();\n                members.add(dendrogram[i].getFirst());\n                members.add(dendrogram[i].getSecond());\n                clusters.put(clusterId, members);\n                clusterId++;\n            } else if (firstClusterId != -1 && secondClusterId == -1) {\n                // first member was in firstClusterId already, we add second\n                clusters.get(firstClusterId).add(dendrogram[i].getSecond());\n            } else if (secondClusterId != -1 && firstClusterId == -1) {\n                // second member was in secondClusterId already, we add first\n                clusters.get(secondClusterId).add(dendrogram[i].getFirst());\n            } else {\n                // both were in different clusters already\n                // we need to join them: necessarily one must be of size 1 and the other of size>=1\n                Set<Integer> firstCluster = clusters.get(firstClusterId);\n                Set<Integer> secondCluster = clusters.get(secondClusterId);\n                if (firstCluster.size() < secondCluster.size()) {\n                    logger.debug(\"Joining cluster \" + firstClusterId + \" to cluster \" + secondClusterId);\n                    // we join first onto second\n                    for (int member : firstCluster) {\n                        secondCluster.add(member);\n                    }\n                    clusters.remove(firstClusterId);\n                } else {\n                    logger.debug(\"Joining cluster \" + secondClusterId + \" to cluster \" + firstClusterId);\n                    // we join second onto first\n                    for (int member : secondCluster) {\n                        firstCluster.add(member);\n                    }\n                    clusters.remove(secondClusterId);\n                }\n            }\n            logger.debug(\"Within cutoff:     {}\", dendrogram[i]);\n        } else {\n            logger.debug(\"Not within cutoff: {}\", dendrogram[i]);\n        }\n    }\n    // reassigning cluster numbers by creating a new map (there can be gaps in the numbering if cluster-joining happened)\n    Map<Integer, Set<Integer>> finalClusters = new TreeMap<Integer, Set<Integer>>();\n    int newClusterId = 1;\n    for (int oldClusterId : clusters.keySet()) {\n        finalClusters.put(newClusterId, clusters.get(oldClusterId));\n        newClusterId++;\n    }\n    // anything not clustered is assigned to a singleton cluster (cluster with one member)\n    for (int i = 0; i < numItems; i++) {\n        boolean isAlreadyClustered = false;\n        for (Set<Integer> cluster : finalClusters.values()) {\n            if (cluster.contains(i)) {\n                isAlreadyClustered = true;\n                break;\n            }\n        }\n        if (!isAlreadyClustered) {\n            Set<Integer> members = new TreeSet<Integer>();\n            members.add(i);\n            finalClusters.put(newClusterId, members);\n            newClusterId++;\n        }\n    }\n    logger.debug(\"Clusters: \\n{}\", clustersToString(finalClusters));\n    return finalClusters;\n}","repo_id":"9","comment":"/**\n * Get the clusters by cutting the dendrogram at given cutoff\n * @param cutoff\n * @return Map from cluster numbers to indices of the cluster members\n */\n","repo_name":"biojava-master/","id":2583,"method_signature":"Map<Integer,Set<Integer>> getClusters(double)"}