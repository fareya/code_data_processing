{"callee_method_names":[],"method_name":"AlignmentTools.calculateBlockGap","method_implementation":"{\n    //Initialize the array to be returned\n    int[] blockGap = new int[optAln.length];\n    //Loop for every block and look in both chains for non-contiguous residues.\n    for (int i = 0; i < optAln.length; i++) {\n        //the number of gaps in that block\n        int gaps = 0;\n        //the last residue position in chain 1\n        int last1 = 0;\n        //the last residue position in chain 2\n        int last2 = 0;\n        //Loop for every position in the block\n        for (int j = 0; j < optAln[i][0].length; j++) {\n            //If the first position is evaluated initialize the last positions\n            if (j == 0) {\n                last1 = optAln[i][0][j];\n                last2 = optAln[i][1][j];\n            } else {\n                //If one of the positions or both are not contiguous increment the number of gaps\n                if (optAln[i][0][j] > last1 + 1 || optAln[i][1][j] > last2 + 1) {\n                    gaps++;\n                    last1 = optAln[i][0][j];\n                    last2 = optAln[i][1][j];\n                } else //Otherwise just set the last position to the current one\n                {\n                    last1 = optAln[i][0][j];\n                    last2 = optAln[i][1][j];\n                }\n            }\n        }\n        blockGap[i] = gaps;\n    }\n    return blockGap;\n}","repo_id":"9","comment":"/**\n * Method that calculates the number of gaps in each subunit block of an optimal AFP alignment.\n *\n * INPUT: an optimal alignment in the format int[][][].\n * OUTPUT: an int[] array of <order> length containing the gaps in each block as int[block].\n */\n","repo_name":"biojava-master/","id":599,"method_signature":"int[] calculateBlockGap(int[][][])"}