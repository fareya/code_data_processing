{"callee_method_ids":[1939,1941,1945,1947,1949,1943],"callee_method_names":["QuatSymmetrySubunits.getTraces","List<Point3d[]>.size","List<Integer>.get","List<Point3d[]>.get","List<Point3d[]>.get","List<Integer>.get","Point3d.set","Matrix4d.transform","Point3d[].distanceSquared","QuatSymmetryScores.setMinRmsd","QuatSymmetryScores.setMaxRmsd","QuatSymmetryScores.setMinTm","QuatSymmetryScores.setMaxTm","QuatSymmetryScores.setTm","QuatSymmetryScores.setRmsd"],"method_name":"QuatSuperpositionScorer.calcScores","method_implementation":"{\n    QuatSymmetryScores scores = new QuatSymmetryScores();\n    double minTm = Double.MAX_VALUE;\n    double maxTm = Double.MIN_VALUE;\n    double minRmsd = Double.MAX_VALUE;\n    double maxRmsd = Double.MIN_VALUE;\n    double totalSumTm = 0;\n    double totalSumDsq = 0;\n    double totalLength = 0;\n    Point3d t = new Point3d();\n    List<Point3d[]> traces = subunits.getTraces();\n    // loop over the Calpha atoms of all subunits\n    for (int i = 0; i < traces.size(); i++) {\n        // in helical systems not all permutations involve all subunit. -1 indicates subunits that should not be permuted.\n        if (permutation.get(i) == -1) {\n            continue;\n        }\n        // get original subunit\n        Point3d[] orig = traces.get(i);\n        totalLength += orig.length;\n        // get permuted subunit\n        Point3d[] perm = traces.get(permutation.get(i));\n        // calculate TM specific parameters\n        // don't let d0 get negative with short sequences\n        int tmLen = Math.max(orig.length, 17);\n        double d0 = 1.24 * Math.cbrt(tmLen - 15.0) - 1.8;\n        double d0Sq = d0 * d0;\n        double sumTm = 0;\n        double sumDsq = 0;\n        for (int j = 0; j < orig.length; j++) {\n            // transform coordinates of the permuted subunit\n            t.set(perm[j]);\n            transformation.transform(t);\n            double dSq = orig[j].distanceSquared(t);\n            sumTm += 1.0 / (1.0 + dSq / d0Sq);\n            sumDsq += dSq;\n        }\n        // scores for individual subunits\n        double sTm = sumTm / tmLen;\n        minTm = Math.min(minTm, sTm);\n        maxTm = Math.max(maxTm, sTm);\n        double sRmsd = Math.sqrt(sumDsq / orig.length);\n        minRmsd = Math.min(minRmsd, sRmsd);\n        maxRmsd = Math.max(maxRmsd, sRmsd);\n        totalSumTm += sumTm;\n        totalSumDsq += sumDsq;\n    }\n    // save scores for individual subunits\n    scores.setMinRmsd(minRmsd);\n    scores.setMaxRmsd(maxRmsd);\n    scores.setMinTm(minTm);\n    scores.setMaxTm(maxTm);\n    // save mean scores over all subunits\n    scores.setTm(totalSumTm / totalLength);\n    scores.setRmsd(Math.sqrt(totalSumDsq / totalLength));\n    // add intra subunit scores\n    calcIntrasubunitScores(subunits, transformation, permutation, scores);\n    return scores;\n}","repo_id":"9","comment":"/**\n * Returns minimum, mean, and maximum RMSD and TM-Score for two superimposed sets of subunits\n *\n * TM score: Yang Zhang and Jeffrey Skolnick, PROTEINS: Structure, Function, and Bioinformatics 57:702\u2013710 (2004)\n * @param subunits subunits to be scored\n * @param transformation transformation matrix\n * @param permutations permutation that determines which subunits are superposed\n * @return\n */\n","repo_name":"biojava-master/","id":1934,"method_signature":"QuatSymmetryScores calcScores(QuatSymmetrySubunits, Matrix4d, List)"}