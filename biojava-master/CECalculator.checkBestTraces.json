{"callee_method_ids":[746,496,752,485,762,498,495,491],"callee_method_names":["CeParameters.getWinSize","Atom[].getX","Atom[].getX","AFPChain.setTotalRmsdIni","AFPChain.setTotalLenIni","CeParameters.isShowAFPRanges","AFP.setFragLen","AFP.setP1","AFP.setP2","List<AFP>.add","AFPChain.setAfpSet","CeParameters.isOptimizeAlignment","AFPChain.setTotalRmsdOpt","AFPChain.getTotalRmsdIni","AFPChain.setCalculationTime","AFPChain.setGapLen","AFPChain.setOptLen","AFPChain.setOptLength","AFPChain.setAlnLength","AFPChain.setProbability"],"method_name":"CECalculator.checkBestTraces","method_implementation":"{\n    z = 0.0;\n    int nGaps;\n    int winSize = params.getWinSize();\n    int nse1 = ca1.length;\n    int nse2 = ca2.length;\n    int traceMaxSize = nse1 < nse2 ? nse1 : nse2;\n    int idir;\n    align_se1 = new int[nse1 + nse2];\n    align_se2 = new int[nse1 + nse2];\n    lcmp = 0;\n    // we now support alignment using any particular atoms..\n    Atom[] strBuf1 = new Atom[traceMaxSize];\n    Atom[] strBuf2 = new Atom[traceMaxSize];\n    double rmsdNew;\n    // removing some loops that are run in orig CE\n    // and which did not do anything\n    if (debug) {\n        checkPrintRmsdNew(traceMaxSize, winSize, ca1, ca2);\n    }\n    double rmsd = 100.0;\n    int iBestTrace = 0;\n    for (int ir = 0; ir < nBestTraces; ir++) {\n        if (bestTracesN[ir] != nBestTrace)\n            continue;\n        rmsdNew = getRMSDForBestTrace(ir, strBuf1, strBuf2, bestTracesN, bestTraces1, bestTrace2, winSize, ca1, ca2);\n        if (isPrint)\n            System.out.println(String.format(\"%d %d %d %.2f\", ir, bestTracesN[ir], nBestTrace, rmsdNew));\n        if (rmsd > rmsdNew) {\n            iBestTrace = ir;\n            rmsd = rmsdNew;\n            //System.out.println(\" iBestTrace:\" + iBestTrace + \" new rmsd = \" + rmsd);\n        }\n    }\n    for (int it = 0; it < bestTracesN[iBestTrace]; it++) {\n        bestTrace1[it] = bestTraces1[iBestTrace][it];\n        bestTrace2[it] = bestTraces2[iBestTrace][it];\n    }\n    //System.out.println(\"iBestTrace: \"+iBestTrace+\" = bestTracesScores \" + bestTracesScores[iBestTrace]);\n    nBestTrace = bestTracesN[iBestTrace];\n    bestTraceScore = bestTracesScores[iBestTrace];\n    //printf(\"\\nOptimizing gaps...\\n\");\n    int[] traceLen = new int[traceMaxSize];\n    bestTraceLen = new int[traceMaxSize];\n    int strLen = 0;\n    int jt;\n    strLen = 0;\n    nGaps = 0;\n    nTrace = nBestTrace;\n    for (jt = 0; jt < nBestTrace; jt++) {\n        trace1[jt] = bestTrace1[jt];\n        trace2[jt] = bestTrace2[jt];\n        traceLen[jt] = winSize;\n        if (jt < nBestTrace - 1) {\n            nGaps += bestTrace1[jt + 1] - bestTrace1[jt] - winSize + bestTrace2[jt + 1] - bestTrace2[jt] - winSize;\n        }\n    }\n    nBestTrace = 0;\n    for (int it = 0; it < nTrace; ) {\n        int cSize = traceLen[it];\n        for (jt = it + 1; jt < nTrace; jt++) {\n            if (trace1[jt] - trace1[jt - 1] - traceLen[jt - 1] != 0 || trace2[jt] - trace2[jt - 1] - traceLen[jt - 1] != 0)\n                break;\n            cSize += traceLen[jt];\n        }\n        bestTrace1[nBestTrace] = trace1[it];\n        bestTrace2[nBestTrace] = trace2[it];\n        bestTraceLen[nBestTrace] = cSize;\n        nBestTrace++;\n        strLen += cSize;\n        it = jt;\n    }\n    int is = 0;\n    for (jt = 0; jt < nBestTrace; jt++) {\n        for (int i = 0; i < bestTraceLen[jt]; i++) {\n            setStrBuf(strBuf1, is + i, ca1, bestTrace1[jt] + i);\n            setStrBuf(strBuf2, is + i, ca2, bestTrace2[jt] + i);\n        }\n        is += bestTraceLen[jt];\n    }\n    //sup_str(strBuf1, strBuf2, strLen, d_);\n    rmsd = calc_rmsd(strBuf1, strBuf2, strLen, true);\n    if (isPrint)\n        System.out.println(\"got first rmsd: \" + rmsd);\n    boolean isCopied = false;\n    outer_loop: for (int it = 1; it < nBestTrace; it++) {\n        /* not needed...\n\t\t\tint igap;\n\t\t\tif(bestTrace1[it]-bestTrace1[it-1]-bestTraceLen[it-1]>0) igap=0;\n\t\t\tif(bestTrace2[it]-bestTrace2[it-1]-bestTraceLen[it-1]>0) igap=1;\n\t\t\t\t */\n        boolean wasBest = false;\n        main_loop: for (idir = -1; idir <= 1; idir += 2) {\n            if (wasBest)\n                break;\n            inner_loop: for (int idep = 1; idep <= winSize / 2; idep++) {\n                // isCopied indicates that bestTrace has changed and needs to be re-copied\n                if (!isCopied)\n                    for (jt = 0; jt < nBestTrace; jt++) {\n                        trace1[jt] = bestTrace1[jt];\n                        trace2[jt] = bestTrace2[jt];\n                        traceLen[jt] = bestTraceLen[jt];\n                    }\n                isCopied = false;\n                // Move an atom from the previous trace to the current on, or vice versa\n                traceLen[it - 1] += idir;\n                traceLen[it] -= idir;\n                trace1[it] += idir;\n                trace2[it] += idir;\n                // Copy atoms from the current trace into strBuf\n                is = 0;\n                for (jt = 0; jt < nBestTrace; jt++) {\n                    for (int i = 0; i < traceLen[jt]; i++) {\n                        if (ca1[trace1[jt] + i].getX() > 1e10 || ca2[trace2[jt] + i].getX() > 1e10)\n                            continue main_loop;\n                        strBuf1[is + i] = ca1[trace1[jt] + i];\n                        strBuf2[is + i] = ca2[trace2[jt] + i];\n                    }\n                    is += traceLen[jt];\n                }\n                // Check new RMSD\n                //sup_str(strBuf1, strBuf2, strLen, d_);\n                rmsdNew = calc_rmsd(strBuf1, strBuf2, strLen, true);\n                //System.out.println(String.format(\"step %d %d %d %.2f old: %.2f\", it, idir, idep, rmsdNew, rmsd));\n                // Update best trace if RMSD improved\n                if (rmsdNew < rmsd) {\n                    for (jt = 0; jt < nBestTrace; jt++) {\n                        bestTrace1[jt] = trace1[jt];\n                        bestTrace2[jt] = trace2[jt];\n                        bestTraceLen[jt] = traceLen[jt];\n                    }\n                    isCopied = true;\n                    wasBest = true;\n                    rmsd = rmsdNew;\n                    continue inner_loop;\n                }\n                // AP\n                //bad_ca: break;\n                continue main_loop;\n            }\n        }\n    }\n    rmsdNew = calc_rmsd(strBuf1, strBuf2, strLen, true);\n    if (isPrint)\n        System.out.println(\"rmsdNew: \" + rmsdNew + \" rmsd \" + rmsd);\n    afpChain.setTotalRmsdIni(rmsdNew);\n    afpChain.setTotalLenIni(strBuf1.length);\n    nAtom = strLen;\n    //System.out.println(\"zStrAlign: \" + winSize + \" strLen \" + strLen  + \" s/w \" + (strLen/winSize) + \" \" + bestTraceScore + \" \" + nGaps);\n    z = zStrAlign(winSize, strLen / winSize, bestTraceScore, nGaps);\n    if (params.isShowAFPRanges()) {\n        System.out.println(\"win size: \" + winSize + \" strLen/winSize: \" + strLen / winSize + \" best trace score: \" + String.format(\"%.2f\", bestTraceScore) + \" nr gaps: \" + nGaps + \" nr residues: \" + nAtom);\n        System.out.println(String.format(\"size=%d rmsd=%.2f z=%.1f gaps=%d(%.1f%%) comb=%d\", nAtom, rmsd, z, nGaps, nGaps * 100.0 / nAtom, nTraces));\n        System.out.println(\"Best Trace, before optimization\");\n        for (int k = 0; k < nBestTrace; k++) System.out.println(String.format(\"(%d,%d,%d) \", bestTrace1[k] + 1, bestTrace2[k] + 1, bestTraceLen[k]));\n    }\n    // start to convert CE internal datastructure to generic AFPChain one...\n    List<AFP> afpSet = new ArrayList<AFP>();\n    for (int afp = 0; afp < nBestTrace; afp++) {\n        // fill in data from nBestTrace into AFP\n        AFP afpI = new AFP();\n        afpI.setFragLen(bestTraceLen[afp]);\n        afpI.setP1(bestTrace1[afp] + 1);\n        afpI.setP2(bestTrace2[afp] + 1);\n        afpSet.add(afpI);\n    }\n    afpChain.setAfpSet(afpSet);\n    //System.out.println(\"z:\"+z + \" zThr\" + zThr+ \" bestTraceScore \" + bestTraceScore + \" \" + nGaps );\n    if (params.isOptimizeAlignment() && z >= zThr) {\n        nGaps = optimizeSuperposition(afpChain, nse1, nse2, strLen, rmsd, ca1, ca2, nGaps, strBuf1, strBuf2);\n        //\t      if(isPrint) {\n        //\t\t/*\n        //\t\tFILE *f=fopen(\"homologies\", \"a\");\n        //\t\tfprintf(f, \"%s(%d) %s(%d) %3d %4.1f %4.1f %d(%d) \",\n        //\t\t\tname1, nse1, name2, nse2, nAtom, rmsd, z,\n        //\t\t\tnGaps, nGaps*100/nAtom);\n        //\t\tfor(int k=0; k<nBestTrace; k++)\n        //\t\t  fprintf(f, \"(%d,%d,%d) \", bestTrace1[k]+1, bestTrace2[k]+1,\n        //\t\t\t  bestTraceLen[k]);\n        //\t\tfprintf(f, \"\\n\");\n        //\t\tfclose(f);\n        //\t\t*/\n        //\t      }\n    } else {\n        int lali_x_ = 0;\n        for (int k = 0; k < nBestTrace; k++) {\n            for (int l = 0; l < bestTraceLen[k]; l++) {\n                align_se1[lcmp + l] = bestTrace1[k] + l;\n                align_se2[lcmp + l] = bestTrace2[k] + l;\n            }\n            lali_x_ += bestTraceLen[k];\n            lcmp += bestTraceLen[k];\n            if (k < nBestTrace - 1) {\n                if (bestTrace1[k] + bestTraceLen[k] != bestTrace1[k + 1])\n                    for (int l = bestTrace1[k] + bestTraceLen[k]; l < bestTrace1[k + 1]; l++) {\n                        align_se1[lcmp] = l;\n                        align_se2[lcmp] = -1;\n                        lcmp++;\n                    }\n                if (bestTrace2[k] + bestTraceLen[k] != bestTrace2[k + 1])\n                    for (int l = bestTrace2[k] + bestTraceLen[k]; l < bestTrace2[k + 1]; l++) {\n                        align_se1[lcmp] = -1;\n                        align_se2[lcmp] = l;\n                        lcmp++;\n                    }\n            }\n        }\n        nAtom = lali_x_;\n        afpChain.setTotalRmsdOpt(afpChain.getTotalRmsdIni());\n    }\n    timeEnd = System.currentTimeMillis();\n    long time_q = (timeEnd - timeStart);\n    double gapsP = (nGaps * 100.0 / nAtom);\n    if (isPrint) {\n        String msg = String.format(\"Alignment length = %d Rmsd = %.2fA Z-Score = %.1f Gaps = %d(%.1f%%)\", nAtom, rmsd, z, nGaps, gapsP);\n        System.out.println(msg + \" CPU = \" + time_q);\n    }\n    //      if ( params.isShowAFPRanges()){\n    // this is actually the final alignment...\n    //         System.out.println(\"Best Trace: (index1,index2,len)\");\n    //         for(int k=0; k<nBestTrace; k++)\n    //            System.out.println(\n    //                  String.format(\"(%d,%d,%d) \", bestTrace1[k]+1, bestTrace2[k]+1, bestTraceLen[k]));\n    //\n    //\n    //\n    //      }\n    afpChain.setCalculationTime(time_q);\n    afpChain.setGapLen(nGaps);\n    int[] optLen = new int[] { nAtom };\n    afpChain.setOptLen(optLen);\n    afpChain.setOptLength(nAtom);\n    afpChain.setAlnLength(lcmp);\n    afpChain.setProbability(z);\n}","repo_id":"9","comment":"// this part is modified from the original CeCalculator\n","repo_name":"biojava-master/","id":714,"method_signature":"void checkBestTraces(AFPChain, Atom[], Atom[])"}