{"callee_method_names":["Random.nextInt","Random.nextInt","Random.nextInt","MultipleAlignment.getBlock","MultipleAlignment.getBlock","Block.length","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.length","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.length","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.length","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes","List<SortedSet<Integer>>.get","Block.getAlignRes"],"method_name":"MultipleMcOptimizer.expandBlock","method_implementation":"{\n    // Select expanding right (0) or left (1)\n    int rl = rnd.nextInt(2);\n    // Select randomly the Block\n    int bk = rnd.nextInt(blockNr);\n    int res = rnd.nextInt(msa.getBlock(bk).length());\n    Block block = msa.getBlock(bk);\n    // store the number of gaps in the expansion\n    int gaps = 0;\n    switch(rl) {\n        case 0:\n            int rightBound = res;\n            int[] previousPos = new int[size];\n            for (int str = 0; str < size; str++) previousPos[str] = -1;\n            // Search t the right for >Rmin non consecutive residues\n            while (block.length() - 1 > rightBound) {\n                int noncontinuous = 0;\n                for (int str = 0; str < size; str++) {\n                    if (block.getAlignRes().get(str).get(rightBound) == null) {\n                        continue;\n                    } else if (previousPos[str] == -1) {\n                        previousPos[str] = block.getAlignRes().get(str).get(rightBound);\n                    } else if (block.getAlignRes().get(str).get(rightBound) > previousPos[str] + 1) {\n                        noncontinuous++;\n                    }\n                }\n                if (noncontinuous < Rmin)\n                    rightBound++;\n                else\n                    break;\n            }\n            if (rightBound > 0)\n                rightBound--;\n            // Expand the block with the residues at the subunit boundaries\n            for (int str = 0; str < size; str++) {\n                Integer residueR = block.getAlignRes().get(str).get(rightBound);\n                if (residueR == null) {\n                    if (rightBound == block.length() - 1) {\n                        block.getAlignRes().get(str).add(null);\n                    } else\n                        block.getAlignRes().get(str).add(rightBound + 1, null);\n                    gaps++;\n                } else if (freePool.get(str).contains(residueR + 1)) {\n                    Integer residueAdd = residueR + 1;\n                    if (rightBound == block.length() - 1) {\n                        block.getAlignRes().get(str).add(residueAdd);\n                    } else {\n                        block.getAlignRes().get(str).add(rightBound + 1, residueAdd);\n                    }\n                    freePool.get(str).remove(residueAdd);\n                } else {\n                    if (rightBound == block.length() - 1)\n                        block.getAlignRes().get(str).add(null);\n                    else\n                        block.getAlignRes().get(str).add(rightBound + 1, null);\n                    gaps++;\n                }\n            }\n            break;\n        case 1:\n            int leftBoundary = res;\n            int[] nextPos = new int[size];\n            for (int str = 0; str < size; str++) nextPos[str] = -1;\n            // Search position to the right with >Rmin non consecutive residues\n            while (leftBoundary > 0) {\n                int noncontinuous = 0;\n                for (int str = 0; str < size; str++) {\n                    if (block.getAlignRes().get(str).get(leftBoundary) == null)\n                        continue;\n                    else if (nextPos[str] == -1) {\n                        nextPos[str] = block.getAlignRes().get(str).get(leftBoundary);\n                    } else if (block.getAlignRes().get(str).get(leftBoundary) < nextPos[str] - 1) {\n                        noncontinuous++;\n                    }\n                }\n                if (noncontinuous < Rmin)\n                    leftBoundary--;\n                else\n                    break;\n            }\n            // Expand the block with the residues at the subunit boundaries\n            for (int str = 0; str < size; str++) {\n                Integer residueL = block.getAlignRes().get(str).get(leftBoundary);\n                if (residueL == null) {\n                    block.getAlignRes().get(str).add(leftBoundary, null);\n                    gaps++;\n                } else if (freePool.get(str).contains(residueL - 1)) {\n                    Integer residueAdd = residueL - 1;\n                    block.getAlignRes().get(str).add(leftBoundary, residueAdd);\n                    freePool.get(str).remove(residueAdd);\n                } else {\n                    block.getAlignRes().get(str).add(leftBoundary, null);\n                    gaps++;\n                }\n            }\n            break;\n    }\n    if (size - gaps >= Rmin)\n        return true;\n    else\n        checkGaps();\n    return false;\n}","repo_id":"9","comment":"/**\n * It extends the alignment one position to the right or to the left of a\n * randomly selected position by moving the consecutive residues of each\n * subunit (if enough) from the freePool to the block.\n * <p>\n * If there are not enough residues in the freePool it introduces gaps.\n */\n","repo_name":"biojava-master/","id":698,"method_signature":"boolean expandBlock()"}