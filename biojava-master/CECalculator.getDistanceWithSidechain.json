{"callee_method_names":["CeParameters.getScoringStrategy","Atom.getGroup","Group.hasAtom","Group.getAtom","Atom.getGroup","Group.hasAtom","Group.getAtom","CeParameters.getScoringStrategy","CeParameters.getScoringStrategy","CeParameters.getScoringStrategy","CeParameters.getScoringStrategy"],"method_name":"CECalculator.getDistanceWithSidechain","method_implementation":"{\n    if (params.getScoringStrategy() == CeParameters.ScoringStrategy.CA_SCORING) {\n        return Calc.getDistance(ca1, ca2);\n    }\n    double dist;\n    Group g1 = ca1.getGroup();\n    Atom cb1 = null;\n    if (g1.hasAtom(StructureTools.CB_ATOM_NAME)) {\n        cb1 = g1.getAtom(StructureTools.CB_ATOM_NAME);\n    }\n    //\n    Group g2 = ca2.getGroup();\n    Atom cb2 = null;\n    if (g2.hasAtom(StructureTools.CB_ATOM_NAME)) {\n        cb2 = g2.getAtom(StructureTools.CB_ATOM_NAME);\n    }\n    if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SIDE_CHAIN_SCORING) {\n        // here we are using side chain orientation for scoring...\n        // score type 1    consider side chain distances\n        if (cb1 != null && cb2 != null) {\n            // CB distance\n            dist = Calc.getDistance(cb1, cb2);\n            //dist = dist / 2.;\n        } else {\n            dist = Calc.getDistance(ca1, ca2);\n        }\n        return dist;\n    } else if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SIDE_CHAIN_ANGLE_SCORING) {\n        // score type 2 add angle info\n        if (cb1 != null && cb2 != null) {\n            // If the CA were overlaid, what is the distance between the CB?\n            // Recall c^2 = a^2 + b^2 -2ab*cos(theta), so this is a function of angle\n            Atom c1 = Calc.subtract(cb1, ca1);\n            Atom c2 = Calc.subtract(cb2, ca2);\n            Atom newA = Calc.subtract(c2, c1);\n            dist = Calc.amount(newA);\n        } else {\n            //dist += Calc.getDistance(ca1,ca2);\n            dist = 0;\n        }\n        return dist;\n    } else if (params.getScoringStrategy() == CeParameters.ScoringStrategy.CA_AND_SIDE_CHAIN_ANGLE_SCORING) {\n        // score type 3\n        // CA distance + cos(angle)\n        dist = 0;\n        if (cb1 != null && cb2 != null) {\n            Atom cacb1 = Calc.subtract(cb1, ca1);\n            Atom cacb2 = Calc.subtract(cb2, ca2);\n            Atom newA = Calc.subtract(cacb2, cacb1);\n            //System.out.format(\"CACB 1: %s\\nCACB 2: %s\\ndiff: %s\\nd: %f\\n\",cacb1.toString(),cacb2.toString(),newA.toString(),Calc.amount(newA));\n            dist += Calc.amount(newA);\n        }\n        dist += Calc.getDistance(ca1, ca2);\n        return dist;\n    } else if (params.getScoringStrategy() == CeParameters.ScoringStrategy.SEQUENCE_CONSERVATION) {\n        if (cb1 != null && cb2 != null) {\n            // CB distance\n            dist = Calc.getDistance(cb1, cb2);\n            //dist = dist / 2.;\n        } else {\n            dist = Calc.getDistance(ca1, ca2);\n        }\n        return dist;\n    } else {\n        // unsupported scoring scheme\n        return Calc.getDistance(ca1, ca2);\n    }\n}","repo_id":"9","comment":"/**\n * Evaluates the distance between two atoms\n * Several scoring functions are implemented and can be changed by calling\n * {@link CeParameters#setScoringStrategy(Integer) setScoringStrategy()}\n * on {@link CeParameters parameter} object this CECalculator was created with.\n * <p>\n * Scoring Strategies:<dl>\n * <dt>DEFAULT_SCORING_STRATEGY<\/dt>\n * <dd>Strategy of the original CE publication; CA-CA distance<\/dd>\n *\n * <dt>SIDE_CHAIN_SCORING<\/dt>\n * <dd>CB-CB distance. This performs better for sheets and helices than CA.<\/dd>\n *\n * <dt>SIDE_CHAIN_ANGLE_SCORING<\/dt>\n * <dd>Use the dot product (eg the cosine) of the two CA-CB vectors.<\/dd>\n *\n * <dt>CA_AND_SIDE_CHAIN_ANGLE_SCORING<\/dt>\n * <dd>Equivalent to DEFAULT_SCORING_STRATEGY + SIDE_CHAIN_ANGLE_SCORING<\/dd>\n * <\/dl>\n *\n *  <dt>SEQUENCE_CONSERVATION<\/dt>\n * <dd>A mix between the DEFAULT_SCORING_STRATEGY and a scoring function that favors the alignment of sequence conserved positions in the alignment<\/dd>\n * <\/dl>\n *\n * @param ca1 The CA of the first residue\n * @param ca2 The CA of the second residue\n * @return The distance between the two fragments, according to the selected\n * scoring strategy. Lower distances are better alignments.\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":712,"method_signature":"double getDistanceWithSidechain(Atom, Atom)"}