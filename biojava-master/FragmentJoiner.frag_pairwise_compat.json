{"callee_method_names":["FragmentPair[].clone","Logger.debug","Logger.debug","FragmentPair[].getPos1","FragmentPair[].getPos2","FragmentPair[].getLength","JointFragments.add","FragmentPair[].getLength","FragmentPair[].getPos1","FragmentPair[].getPos2","FragmentPair[].getLength","FragmentPair[].getUnitv","FragmentPair[].getUnitv","FragmentPair[].getCenter1","FragmentPair[].getCenter1","FragmentPair[].getCenter2","FragmentPair[].getCenter2","JointFragments.add","FragmentPair[].getLength","List<JointFragments>.add","List<JointFragments>.size","List<JointFragments>.get","List<JointFragments>.add","List<JointFragments>.toArray","List<JointFragments>.size"],"method_name":"FragmentJoiner.frag_pairwise_compat","method_implementation":"{\n    FragmentPair[] tmpfidx = new FragmentPair[fraglst.length];\n    for (int i = 0; i < fraglst.length; i++) {\n        tmpfidx[i] = (FragmentPair) fraglst[i].clone();\n    }\n    int n = tmpfidx.length;\n    //indicator if a fragment was already used\n    int[] used = new int[n];\n    //the final list of joined fragments stores as apairs\n    List<JointFragments> fll = new ArrayList<JointFragments>();\n    double adiff = angleDiff * Math.PI / 180d;\n    logger.debug(\"addiff{}\", adiff);\n    //distance between two unit vectors with angle adiff\n    double ddiff = Math.sqrt(2.0 - 2.0 * Math.cos(adiff));\n    logger.debug(\"ddiff{}\", ddiff);\n    // the fpairs in the flist have to be sorted with respect to their positions\n    while (tmpfidx.length > 0) {\n        int i = 0;\n        int j = 1;\n        used[i] = 1;\n        JointFragments f = new JointFragments();\n        int p1i = tmpfidx[i].getPos1();\n        int p1j = tmpfidx[i].getPos2();\n        int maxi = p1i + tmpfidx[i].getLength();\n        f.add(p1i, p1j, 0, tmpfidx[i].getLength());\n        n = tmpfidx.length;\n        while (j < n) {\n            int p2i = tmpfidx[j].getPos1();\n            int p2j = tmpfidx[j].getPos2();\n            int l2 = tmpfidx[j].getLength();\n            if (p2i > maxi) {\n                double dist = Calc.getDistance(tmpfidx[i].getUnitv(), tmpfidx[j].getUnitv());\n                if (dist < ddiff) {\n                    // centroids have to be closer than fragCompatDist\n                    double dd = Calc.getDistance(tmpfidx[i].getCenter1(), tmpfidx[j].getCenter1()) - Calc.getDistance(tmpfidx[i].getCenter2(), tmpfidx[j].getCenter2());\n                    if (dd < 0)\n                        dd = -dd;\n                    if (dd < fragCompatDist) {\n                        maxi = p2i + l2;\n                        used[j] = 1;\n                        f.add(p2i, p2j, 0, tmpfidx[j].getLength());\n                    }\n                }\n            }\n            j += 1;\n        }\n        int red = 0;\n        for (int k = 0; k < n; k++) {\n            if (used[k] == 0) {\n                tmpfidx[red] = tmpfidx[k];\n                red += 1;\n            }\n        }\n        used = new int[n];\n        tmpfidx = (FragmentPair[]) resizeArray(tmpfidx, red);\n        fll.add(f);\n    }\n    Comparator<JointFragments> comp = new JointFragmentsComparator();\n    Collections.sort(fll, comp);\n    Collections.reverse(fll);\n    int m = Math.min(maxRefine, fll.size());\n    List<JointFragments> retlst = new ArrayList<JointFragments>();\n    for (int i = 0; i < m; i++) {\n        JointFragments jf = fll.get(i);\n        retlst.add(jf);\n    }\n    return retlst.toArray(new JointFragments[retlst.size()]);\n}","repo_id":"9","comment":"/**\n * Calculate the pairwise compatibility of fpairs.\n * Iterates through a list of fpairs and joins them if\n * they have compatible rotation and translation parameters.\n * @param fraglst FragmentPair[] array\n * @param angleDiff angle cutoff\n * @param fragCompatDist distance cutoff\n * @param maxRefine max number of solutions to keep\n * @return JointFragments[]\n */\n","repo_name":"biojava-master/","id":808,"method_signature":"JointFragments[] frag_pairwise_compat(FragmentPair[], int, float, int)"}