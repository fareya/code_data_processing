{"callee_method_names":["List<Atom[]>.size","List<AFPChain>.get","List<AFPChain>.get","List<List<Integer>>.add","List<List<Integer>>.get","List<List<Integer>>.get","List<AFPChain>.get","List<AFPChain>.get","List<AFPChain>.get","List<AFPChain>.get","List<AFPChain>.get","List<AFPChain>.get","List<List<Integer>>.get","SortedSet<Integer>.add","MultipleAlignment.getEnsemble","SortedSet<Integer>.contains","BlockSet.getBlocks","BlockSet.getBlocks","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","BlockSet.getBlocks","BlockSet.getBlocks","Block.getAlignRes","List<List<Integer>>.add","Block.setAlignRes","Block.getAlignRes","List<List<Integer>>.get","Logger.info","MultipleAlignment.getBlocks"],"method_name":"MultipleMcMain.combineReferenceAlignments","method_implementation":"{\n    int size = atomArrays.size();\n    //the number of residues of the reference structure\n    int length = 0;\n    if (ref == 0)\n        length = afpList.get(1).getCa1Length();\n    else\n        length = afpList.get(0).getCa2Length();\n    SortedSet<Integer> flexibleBoundaries = new TreeSet<Integer>();\n    //Stores the equivalencies of all the structures as a double List\n    List<List<Integer>> equivalencies = new ArrayList<List<Integer>>();\n    for (int str = 0; str < size; str++) {\n        equivalencies.add(new ArrayList<Integer>());\n        for (int res = 0; res < length; res++) {\n            if (//identity\n            str == ref)\n                //identity\n                equivalencies.get(str).add(res);\n            else\n                equivalencies.get(str).add(null);\n        }\n    }\n    //Now we parse the AFPChains adding the residue equivalencies\n    for (int str = 0; str < size; str++) {\n        //avoid self-comparison\n        if (str == ref)\n            continue;\n        for (int bk = 0; bk < afpList.get(str).getBlockNum(); bk++) {\n            for (int i = 0; i < afpList.get(str).getOptLen()[bk]; i++) {\n                //reference index\n                int res1 = 0;\n                int res2 = 0;\n                //The low index is always in the first chain (0)\n                if (str > ref) {\n                    res1 = afpList.get(str).getOptAln()[bk][0][i];\n                    res2 = afpList.get(str).getOptAln()[bk][1][i];\n                } else if (str < ref) {\n                    res1 = afpList.get(str).getOptAln()[bk][1][i];\n                    res2 = afpList.get(str).getOptAln()[bk][0][i];\n                }\n                equivalencies.get(str).set(res1, res2);\n                //Add the flexible boundaries if flexible\n                if (flexible && i == 0)\n                    flexibleBoundaries.add(res1);\n            }\n        }\n    }\n    //We have translated the equivalencies, we create the MultipleAlignment\n    MultipleAlignment seed = new MultipleAlignmentImpl();\n    seed.getEnsemble().setAtomArrays(atomArrays);\n    BlockSet blockSet = new BlockSetImpl(seed);\n    new BlockImpl(blockSet);\n    //Store last positions in the block different than null to detect CP\n    int[] lastResidues = new int[size];\n    Arrays.fill(lastResidues, -1);\n    //We loop through all the equivalencies checking for CP\n    for (int pos = 0; pos < length; pos++) {\n        //Start a new BlockSet if the position means a boundary\n        if (flexibleBoundaries.contains(pos) && blockSet.getBlocks().get(blockSet.getBlocks().size() - 1).getAlignRes() != null) {\n            blockSet = new BlockSetImpl(seed);\n            new BlockImpl(blockSet);\n        }\n        boolean cp = false;\n        for (int str = 0; str < size; str++) {\n            if (equivalencies.get(str).get(pos) == null) {\n                //there is a gap, ignore position\n                continue;\n            } else if (equivalencies.get(str).get(pos) < lastResidues[str]) {\n                //current residue is lower than the last\n                cp = true;\n                break;\n            } else\n                lastResidues[str] = equivalencies.get(str).get(pos);\n        }\n        if (cp) {\n            //if there is a CP create a new Block\n            new BlockImpl(blockSet);\n            Arrays.fill(lastResidues, -1);\n        }\n        //Now add the equivalent residues into the Block AlignRes variable\n        for (int str = 0; str < size; str++) {\n            Block lastB = blockSet.getBlocks().get(blockSet.getBlocks().size() - 1);\n            if (lastB.getAlignRes() == null) {\n                //Initialize the aligned residues list\n                List<List<Integer>> alnRes = new ArrayList<List<Integer>>(size);\n                for (int k = 0; k < size; k++) {\n                    alnRes.add(new ArrayList<Integer>());\n                }\n                lastB.setAlignRes(alnRes);\n            }\n            lastB.getAlignRes().get(str).add(equivalencies.get(str).get(pos));\n        }\n    }\n    logger.info(\"Seed alignment has \" + seed.getBlocks() + \" Blocks.\");\n    return seed;\n}","repo_id":"9","comment":"/**\n * This method takes a list of pairwise alignments to the reference\n * structure and calculates a MultipleAlignment resulting from combining\n * their residue equivalencies.\n * <p>\n * It uses the blocks in AFPChain as {@link Block}s in the\n * MultipleAlignment, so considers non-topological\n * alignments, if the alignment is rigid. If the alignment is flexible,\n * it considers the blocks as {@link BlockSets}.\n *\n * @param afpList the list of pairwise alignments to the reference\n * @param atomArrays List of Atoms of the structures\n * @param ref index of the reference structure\n * @param flexible uses BlockSets if true, uses Blocks otherwise\n * @return MultipleAlignment seed alignment\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":692,"method_signature":"MultipleAlignment combineReferenceAlignments(List, List, int, boolean)"}