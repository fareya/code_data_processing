{"callee_method_ids":[489,490,432,487,484,438,491],"callee_method_names":["AFPChain.getMinLen","FatCatParameters.getFragLen","AFPChain.getOptAln","AFPChain.getOptLen","FatCatParameters.getMaxTra","AFPChain.getOptRmsd","AFPChain.getBlockNum","AFPChain.setOptLen","AFPChain.setOptRmsd","AFPChain.getAfpSet","AFPChain.getOptLength","AFPChain.getAfpChainList","AFPChain.getBlock2Afp","AFPChain.getBlockSize","List<AFP>.get","List<AFP>.get","List<AFP>.get","List<AFP>.get","List<AFP>.get","List<AFP>.get","List<AFP>.get","StructureAlignmentOptimizer.runOptimization","StructureAlignmentOptimizer.optimizeResult","AFPChain.setOptAln","AFPChain.setOptAln","AFPChain.setBlockNum","AFPChain.setOptLength","AFPChain.setAfpChainList","AFPChain.setBlock2Afp","AFPChain.setBlockSize"],"method_name":"AFPOptimizer.optimizeAln","method_implementation":"{\n    int minLen = afpChain.getMinLen();\n    int fragLen = params.getFragLen();\n    long optStart = System.currentTimeMillis();\n    int i, a, k, p1, p2, bk, b1, b2, e1, e2, a1, a2;\n    int iniLen;\n    int[][] iniSet = new int[2][minLen];\n    int maxi = 100;\n    int[][][] optAln = afpChain.getOptAln();\n    int[] optLen = afpChain.getOptLen();\n    int maxTra = params.getMaxTra();\n    double[] optRmsd = afpChain.getOptRmsd();\n    int blockNum = afpChain.getBlockNum();\n    if (optAln == null) {\n        optAln = new int[maxTra + 1][2][minLen];\n        optLen = new int[maxTra + 1];\n        afpChain.setOptLen(optLen);\n        optRmsd = new double[maxTra + 1];\n        afpChain.setOptRmsd(optRmsd);\n    }\n    List<AFP> afpSet = afpChain.getAfpSet();\n    int optLength = afpChain.getOptLength();\n    int[] afpChainList = afpChain.getAfpChainList();\n    int[] block2Afp = afpChain.getBlock2Afp();\n    int[] blockSize = afpChain.getBlockSize();\n    if (debug)\n        System.out.println(\"AFPOptimizer got blockNum: \" + blockNum);\n    //optimize each alignment defined by a block\n    b1 = b2 = e1 = e2 = optLength = 0;\n    for (bk = 0; bk < blockNum; bk++) {\n        //initial aligned position\n        iniLen = 0;\n        if (bk > 0) {\n            b1 = e1;\n            b2 = e2;\n        }\n        if (bk < blockNum - 1) {\n            //the last AFP in current block\n            a1 = afpChainList[block2Afp[bk] + blockSize[bk] - 1];\n            //the first AFP in next block\n            a2 = afpChainList[block2Afp[bk + 1]];\n            e1 = (afpSet.get(a1).getP1() + fragLen + afpSet.get(a2).getP1()) / 2;\n            e2 = (afpSet.get(a1).getP2() + fragLen + afpSet.get(a2).getP2()) / 2;\n        } else //use the middle point of the current and next AFPs. old (starting point of next AFP)\n        {\n            e1 = ca1.length;\n            e2 = ca2.length;\n        }\n        for (i = block2Afp[bk]; i < block2Afp[bk] + blockSize[bk]; i++) {\n            a = afpChainList[i];\n            p1 = afpSet.get(a).getP1();\n            p2 = afpSet.get(a).getP2();\n            for (k = 0; k < afpSet.get(a).getFragLen(); k++) {\n                //note -b1\n                iniSet[0][iniLen] = p1 + k - b1;\n                //note -b2\n                iniSet[1][iniLen] = p2 + k - b2;\n                iniLen++;\n            }\n        }\n        //optimize the align by dynamic programming & constraint the optimization region\n        if (debug) {\n            System.err.println(String.format(\"optimize block %d (%d afp), region %d-%d(len %d), %d-%d(len %d)\\n\", bk, blockSize[bk], b1, e1, e1 - b1, b2, e2, e2 - b2));\n            System.err.println(\" initial alignment Length: \" + iniLen);\n        }\n        StructureAlignmentOptimizer opt = new StructureAlignmentOptimizer(b1, e1, ca1, b2, e2, ca2, iniLen, iniSet);\n        opt.runOptimization(maxi);\n        optRmsd[bk] = opt.optimizeResult(optLen, bk, optAln[bk]);\n        //System.out.println(optRmsd[bk]);\n        // SALNOPT *opt = new SALNOPT(e1-b1, &pro1->caCod[3 * b1], e2-b2, &pro2->caCod[3 * b2], iniLen, iniSet, maxi);\n        // optRmsd[bk] = opt->OptimizeResult(&optLen[bk], optAln[bk]);\n        if (debug)\n            System.out.println(String.format(\" optimized len=%d, rmsd %f\\n\", optLen[bk], optRmsd[bk]));\n        for (i = 0; i < optLen[bk]; i++) {\n            //restore the position\n            optAln[bk][0][i] += b1;\n            //restore the position\n            optAln[bk][1][i] += b2;\n        }\n        optLength += optLen[bk];\n    }\n    long optEnd = System.currentTimeMillis();\n    if (debug)\n        System.out.println(\"complete AlignOpt \" + (optEnd - optStart) + \"\\n\");\n    if (optLength < minLen) {\n        int[][][] optAln_trim = new int[maxTra + 1][2][optLength];\n        for (i = 0; i < maxTra + 1; i++) {\n            System.arraycopy(optAln[i][0], 0, optAln_trim[i][0], 0, optLength);\n            System.arraycopy(optAln[i][1], 0, optAln_trim[i][1], 0, optLength);\n        }\n        afpChain.setOptAln(optAln_trim);\n    } else {\n        afpChain.setOptAln(optAln);\n    }\n    afpChain.setBlockNum(blockNum);\n    afpChain.setOptLength(optLength);\n    afpChain.setAfpChainList(afpChainList);\n    afpChain.setBlock2Afp(block2Afp);\n    afpChain.setBlockSize(blockSize);\n}","repo_id":"9","comment":"/**\n * optimize the alignment by dynamic programming\n */\n","repo_name":"biojava-master/","id":420,"method_signature":"void optimizeAln(FatCatParameters, AFPChain, Atom[], Atom[])"}