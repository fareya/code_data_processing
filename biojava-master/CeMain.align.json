{"callee_method_ids":[711,502,477,746,506,504],"callee_method_names":["int.getGroup","Group.getAtom","int.getName","CECalculator.extractFragments","CECalculator.traceFragmentMatrix","CECalculator.nextStep","AFPChain.setAlgorithmName","AFPChain.setVersion","Atom[].getGroup","Atom[].getGroup","AFPChain.setName1","Atom[].getGroup","Atom[].getGroup","Atom[].getGroup","AFPChain.setName2","Atom[].getGroup","AFPChain.getNrEQR","CeParameters.getWinSize","CECalculator.initSumOfDistances","AFPChain.setDistanceMatrix","AFPChain.setSequentialAlignment"],"method_name":"CeMain.align","method_implementation":"{\n    if (!(param instanceof CeParameters))\n        throw new IllegalArgumentException(\"CE algorithm needs an object of call CeParameters as argument.\");\n    params = (CeParameters) param;\n    // we don't want to rotate input atoms, do we?\n    ca2clone = new Atom[ca2.length];\n    int pos = 0;\n    for (Atom a : ca2) {\n        // works because each group has only a CA atom\n        Group g = (Group) a.getGroup().clone();\n        ca2clone[pos] = g.getAtom(a.getName());\n        pos++;\n    }\n    calculator = new CECalculator(params);\n    //Build alignment ca1 to ca2-ca2\n    AFPChain afpChain = new AFPChain(algorithmName);\n    afpChain = calculator.extractFragments(afpChain, ca1, ca2clone);\n    calculator.traceFragmentMatrix(afpChain, ca1, ca2clone);\n    calculator.nextStep(afpChain, ca1, ca2clone);\n    afpChain.setAlgorithmName(getAlgorithmName());\n    afpChain.setVersion(version);\n    // Try to guess names\n    if (ca1.length != 0 && ca1[0].getGroup().getChain() != null && ca1[0].getGroup().getChain().getStructure() != null)\n        afpChain.setName1(ca1[0].getGroup().getChain().getStructure().getName());\n    if (ca2.length != 0 && ca2[0].getGroup().getChain() != null && ca2[0].getGroup().getChain().getStructure() != null)\n        afpChain.setName2(ca2[0].getGroup().getChain().getStructure().getName());\n    if (afpChain.getNrEQR() == 0)\n        return afpChain;\n    // Set the distance matrix\n    int winSize = params.getWinSize();\n    int winSizeComb1 = (winSize - 1) * (winSize - 2) / 2;\n    double[][] m = calculator.initSumOfDistances(ca1.length, ca2.length, winSize, winSizeComb1, ca1, ca2clone);\n    afpChain.setDistanceMatrix(new Matrix(m));\n    afpChain.setSequentialAlignment(true);\n    return afpChain;\n}","repo_id":"9","comment":"/**\n * Align ca2 onto ca1.\n */\n","repo_name":"biojava-master/","id":802,"method_signature":"AFPChain align(Atom[], Atom[], Object)"}