{"callee_method_ids":[874,875,874,875,832,874,875,874,875,876,874,873,874,883,885,885,883],"callee_method_names":["List<StructureInterface>.add","StructureInterface.getMoleculeIds","StructureInterface.getTransforms","StructureInterface.getMoleculeIds","StructureInterface.getTransforms","Map<String, Atom[]>.put","StructureInterface.getFirstAtomsForAsa","Map<String, Atom[]>.put","StructureInterface.getSecondAtomsForAsa","Logger.debug","Map<String, Atom[]>.size","Map<String, Atom[]>.keySet","Logger.debug","Map<String, Atom[]>.get","Map<String, Atom[]>.get","AsaCalculator.calculateAsas","Map<String, double[]>.put","Logger.debug","Map<String, Atom[]>.size","Logger.debug","List<StructureInterface>.size","StructureInterface.getMoleculeIds","StructureInterface.getTransforms","StructureInterface.getMoleculeIds","StructureInterface.getTransforms","Logger.debug","StructureInterface.getId","StructureInterface.setAsas","Map<String, double[]>.get","Map<String, double[]>.get","Logger.debug","List<StructureInterface>.size","Logger.warn","StructureInterface.getMoleculeIds","StructureInterface.setTotalArea","StructureInterface.getTotalArea","StructureInterface.getMoleculeIds","StructureInterface.setFirstGroupAsas","StructureInterface.getFirstGroupAsas","StructureInterface.setSecondGroupAsas","StructureInterface.getSecondGroupAsas","StructureInterface.setFirstGroupAsas","StructureInterface.getSecondGroupAsas","StructureInterface.setSecondGroupAsas","StructureInterface.getFirstGroupAsas"],"method_name":"StructureInterfaceList.calcAsas","method_implementation":"{\n    // asa/bsa calculation\n    // NOTE in principle it is more efficient to calculate asas only once per unique chain\n    // BUT! the rolling ball algorithm gives slightly different values for same molecule in different\n    // rotations (due to sampling depending on orientation of axes grid).\n    // Both NACCESS and our own implementation behave like that.\n    // That's why we calculate ASAs for each rotation-unique molecule, otherwise\n    // we get discrepancies (not very big but annoying) which lead to things like negative (small) bsa values\n    Map<String, Atom[]> uniqAsaChains = new TreeMap<>();\n    Map<String, double[]> chainAsas = new TreeMap<>();\n    List<StructureInterface> redundancyReducedList;\n    if (clustersNcs != null) {\n        redundancyReducedList = new ArrayList<>();\n        for (StructureInterfaceCluster ncsCluster : clustersNcs) {\n            // we use the first one in list as the only one for which we calculate ASAs\n            redundancyReducedList.add(ncsCluster.getMembers().get(0));\n        }\n    } else {\n        redundancyReducedList = list;\n    }\n    // first we gather rotation-unique chains (in terms of AU id and transform id)\n    for (StructureInterface interf : redundancyReducedList) {\n        String molecId1 = interf.getMoleculeIds().getFirst() + interf.getTransforms().getFirst().getTransformId();\n        String molecId2 = interf.getMoleculeIds().getSecond() + interf.getTransforms().getSecond().getTransformId();\n        uniqAsaChains.put(molecId1, interf.getFirstAtomsForAsa(cofactorSizeToUse));\n        uniqAsaChains.put(molecId2, interf.getSecondAtomsForAsa(cofactorSizeToUse));\n    }\n    logger.debug(\"Will calculate uncomplexed ASA for {} orientation-unique chains.\", uniqAsaChains.size());\n    long start = System.currentTimeMillis();\n    // we only need to calculate ASA for that subset (any translation of those will have same values)\n    for (String molecId : uniqAsaChains.keySet()) {\n        logger.debug(\"Calculating uncomplexed ASA for molecId {}, with {} atoms\", molecId, uniqAsaChains.get(molecId).length);\n        AsaCalculator asaCalc = new AsaCalculator(uniqAsaChains.get(molecId), AsaCalculator.DEFAULT_PROBE_SIZE, nSpherePoints, nThreads);\n        double[] atomAsas = asaCalc.calculateAsas();\n        chainAsas.put(molecId, atomAsas);\n    }\n    long end = System.currentTimeMillis();\n    logger.debug(\"Calculated uncomplexed ASA for {} orientation-unique chains. Time: {} s\", uniqAsaChains.size(), ((end - start) / 1000.0));\n    logger.debug(\"Will calculate complexed ASA for {} pairwise complexes.\", redundancyReducedList.size());\n    start = System.currentTimeMillis();\n    // now we calculate the ASAs for each of the complexes\n    for (StructureInterface interf : redundancyReducedList) {\n        String molecId1 = interf.getMoleculeIds().getFirst() + interf.getTransforms().getFirst().getTransformId();\n        String molecId2 = interf.getMoleculeIds().getSecond() + interf.getTransforms().getSecond().getTransformId();\n        logger.debug(\"Calculating complexed ASAs for interface {} between molecules {} and {}\", interf.getId(), molecId1, molecId2);\n        interf.setAsas(chainAsas.get(molecId1), chainAsas.get(molecId2), nSpherePoints, nThreads, cofactorSizeToUse);\n    }\n    end = System.currentTimeMillis();\n    logger.debug(\"Calculated complexes ASA for {} pairwise complexes. Time: {} s\", redundancyReducedList.size(), ((end - start) / 1000.0));\n    // now let's populate the interface area value for the NCS-redundant ones from the reference interface (first one in list)\n    if (clustersNcs != null) {\n        if (chainOrigNamesMap == null) {\n            logger.warn(\"No chainOrigNamesMap is set. Considering NCS interfaces in same order as reference. This is likely a bug.\");\n        }\n        for (StructureInterfaceCluster ncsCluster : clustersNcs) {\n            StructureInterface refInterf = ncsCluster.getMembers().get(0);\n            String refMolecId1 = refInterf.getMoleculeIds().getFirst();\n            for (int i = 1; i < ncsCluster.getMembers().size(); i++) {\n                StructureInterface member = ncsCluster.getMembers().get(i);\n                member.setTotalArea(refInterf.getTotalArea());\n                String molecId1 = member.getMoleculeIds().getFirst();\n                if (areMolecIdsSameOrder(refMolecId1, molecId1)) {\n                    // we add the reference interface GroupAsas as the GroupAsas for all other members, like that\n                    // ResidueNumbers won't match in their chain ids, but otherwise all info is there without using a lot of memory\n                    member.setFirstGroupAsas(refInterf.getFirstGroupAsas());\n                    member.setSecondGroupAsas(refInterf.getSecondGroupAsas());\n                } else {\n                    member.setFirstGroupAsas(refInterf.getSecondGroupAsas());\n                    member.setSecondGroupAsas(refInterf.getFirstGroupAsas());\n                }\n            }\n        }\n    }\n    // finally we sort based on the ChainInterface.comparable() (based in interfaceArea)\n    sort();\n}","repo_id":"9","comment":"/**\n * Calculates ASAs for all interfaces in list, both for the unbound\n * chains and for the complex of the two chains together.\n * Also sorts the interfaces based on calculated BSA areas (descending)\n * @param nSpherePoints\n * @param nThreads\n * @param cofactorSizeToUse the minimum size of cofactor molecule (non-chain HET atoms) that will be used\n */\n","repo_name":"biojava-master/","id":903,"method_signature":"void calcAsas(int, int, int)"}