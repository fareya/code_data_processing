{"callee_method_ids":[477,487,487,498,490,489,487,487,487,490,490,490,490],"callee_method_names":["AFPChain.setCa1Length","AFPChain.setCa2Length","AFPChain.getFocusRes1","AFPChain.getFocusRes2","AFPChain.getCa1Length","AFPChain.setFocusRes1","AFPChain.getCa2Length","AFPChain.setFocusRes2","AFPChain.getNrEQR","AFPChain.getOptLength","AFPChain.getOptLength","AFPChain.getBlockNum","AFPChain.setBlockRotationMatrix","AFPChain.getBlockNum","AFPChain.setBlockShiftVector","AFPChain.setTotalRmsdOpt","AFPChain.setTMScore","AFPChain.getOptLen","AFPChain.getOptAln","AFPChain.getBlockNum","AFPChain.getBlockNum","AFPChain.getBlockNum","AFPChain.getOptLen","AFPChain.getOptLen","Atom[].clone","AFPChain.getOptLen","Logger.warn","AFPChain.getOptLen","AFPChain.setOptRmsd","AFPChain.setBlockRmsd","AFPChain.setBlockScore"],"method_name":"AlignmentTools.updateSuperposition","method_implementation":"{\n    //Update ca information, because the atom array might also be changed\n    afpChain.setCa1Length(ca1.length);\n    afpChain.setCa2Length(ca2.length);\n    //We need this to get the correct superposition\n    int[] focusRes1 = afpChain.getFocusRes1();\n    int[] focusRes2 = afpChain.getFocusRes2();\n    if (focusRes1 == null) {\n        focusRes1 = new int[afpChain.getCa1Length()];\n        afpChain.setFocusRes1(focusRes1);\n    }\n    if (focusRes2 == null) {\n        focusRes2 = new int[afpChain.getCa2Length()];\n        afpChain.setFocusRes2(focusRes2);\n    }\n    if (afpChain.getNrEQR() == 0)\n        return;\n    // create new arrays for the subset of atoms in the alignment.\n    Atom[] ca1aligned = new Atom[afpChain.getOptLength()];\n    Atom[] ca2aligned = new Atom[afpChain.getOptLength()];\n    fillAlignedAtomArrays(afpChain, ca1, ca2, ca1aligned, ca2aligned);\n    //Superimpose the two structures in correspondance to the new alignment\n    Matrix4d trans = SuperPositions.superpose(Calc.atomsToPoints(ca1aligned), Calc.atomsToPoints(ca2aligned));\n    Matrix matrix = Matrices.getRotationJAMA(trans);\n    Atom shift = Calc.getTranslationVector(trans);\n    Matrix[] blockMxs = new Matrix[afpChain.getBlockNum()];\n    Arrays.fill(blockMxs, matrix);\n    afpChain.setBlockRotationMatrix(blockMxs);\n    Atom[] blockShifts = new Atom[afpChain.getBlockNum()];\n    Arrays.fill(blockShifts, shift);\n    afpChain.setBlockShiftVector(blockShifts);\n    for (Atom a : ca2aligned) {\n        Calc.rotate(a, matrix);\n        Calc.shift(a, shift);\n    }\n    //Calculate the RMSD and TM score for the new alignment\n    double rmsd = Calc.rmsd(ca1aligned, ca2aligned);\n    double tmScore = Calc.getTMScore(ca1aligned, ca2aligned, ca1.length, ca2.length);\n    afpChain.setTotalRmsdOpt(rmsd);\n    afpChain.setTMScore(tmScore);\n    int[] blockLens = afpChain.getOptLen();\n    int[][][] optAln = afpChain.getOptAln();\n    //Calculate the RMSD and TM score for every block of the new alignment\n    double[] blockRMSD = new double[afpChain.getBlockNum()];\n    double[] blockScore = new double[afpChain.getBlockNum()];\n    for (int k = 0; k < afpChain.getBlockNum(); k++) {\n        //Create the atom arrays corresponding to the aligned residues in the block\n        Atom[] ca1block = new Atom[afpChain.getOptLen()[k]];\n        Atom[] ca2block = new Atom[afpChain.getOptLen()[k]];\n        int position = 0;\n        for (int i = 0; i < blockLens[k]; i++) {\n            int pos1 = optAln[k][0][i];\n            int pos2 = optAln[k][1][i];\n            Atom a1 = ca1[pos1];\n            Atom a2 = (Atom) ca2[pos2].clone();\n            ca1block[position] = a1;\n            ca2block[position] = a2;\n            position++;\n        }\n        if (position != afpChain.getOptLen()[k]) {\n            logger.warn(\"AFPChainScorer getTMScore: Problems reconstructing block alignment! nr of loaded atoms is \" + position + \" but should be \" + afpChain.getOptLen()[k]);\n            // we need to resize the array, because we allocated too many atoms earlier on.\n            ca1block = (Atom[]) resizeArray(ca1block, position);\n            ca2block = (Atom[]) resizeArray(ca2block, position);\n        }\n        //Superimpose the two block structures\n        Matrix4d transb = SuperPositions.superpose(Calc.atomsToPoints(ca1block), Calc.atomsToPoints(ca2block));\n        blockMxs[k] = Matrices.getRotationJAMA(trans);\n        blockShifts[k] = Calc.getTranslationVector(trans);\n        Calc.transform(ca2block, transb);\n        //Calculate the RMSD and TM score for the block\n        double rmsdb = Calc.rmsd(ca1block, ca2block);\n        double tmScoreb = Calc.getTMScore(ca1block, ca2block, ca1.length, ca2.length);\n        blockRMSD[k] = rmsdb;\n        blockScore[k] = tmScoreb;\n    }\n    afpChain.setOptRmsd(blockRMSD);\n    afpChain.setBlockRmsd(blockRMSD);\n    afpChain.setBlockScore(blockScore);\n}","repo_id":"9","comment":"/**\n * After the alignment changes (optAln, optLen, blockNum, at a minimum),\n * many other properties which depend on the superposition will be invalid.\n *\n * This method re-runs a rigid superposition over the whole alignment\n * and repopulates the required properties, including RMSD (TotalRMSD) and\n * TM-Score.\n * @param afpChain\n * @param ca1\n * @param ca2 Second set of ca atoms. Will be modified based on the superposition\n * @throws StructureException\n * @see {@link CECalculator#calc_rmsd(Atom[], Atom[], int, boolean)}\n *  contains much of the same code, but stores results in a CECalculator\n *  instance rather than an AFPChain\n */\n","repo_name":"biojava-master/","id":594,"method_signature":"void updateSuperposition(AFPChain, Atom[], Atom[])"}