{"callee_method_ids":[1933],"callee_method_names":["PermutationGroup.addPermutation","String.getPermutation","PermutationGroup.addPermutation","String.getPermutation","HashMap.get","String.getPermutation","PermutationGroup.completeGroup","PermutationGroup.getOrder","RotationGroup.getOrder","PermutationGroup.getOrder","HashMap.containsKey","HashMap.get","HashMap.containsKey","HashMap.get","HashMap.containsKey","List<Rotation>.add"],"method_name":"RotationSolver.completeRotationGroup","method_implementation":"{\n    PermutationGroup g = new PermutationGroup();\n    for (Rotation s : rotations) {\n        g.addPermutation(s.getPermutation());\n    }\n    for (Rotation s : additionalRots) {\n        g.addPermutation(s.getPermutation());\n        // inputs should not have been added already\n        assert evaluatedPermutations.get(s.getPermutation()) == null;\n    }\n    g.completeGroup();\n    // the group is complete, nothing to do\n    if (g.getOrder() == rotations.getOrder() + additionalRots.length) {\n        for (Rotation s : additionalRots) {\n            addRotation(s);\n        }\n        return true;\n    }\n    // try to complete the group\n    List<Rotation> newRots = new ArrayList<>(g.getOrder());\n    // First, quick check for whether they're allowed\n    for (List<Integer> permutation : g) {\n        if (evaluatedPermutations.containsKey(permutation)) {\n            Rotation rot = evaluatedPermutations.get(permutation);\n            if (rot == null) {\n                return false;\n            }\n        } else {\n            if (!isAllowedPermutation(permutation)) {\n                return false;\n            }\n        }\n    }\n    // Slower check including the superpositions\n    for (List<Integer> permutation : g) {\n        Rotation rot;\n        if (evaluatedPermutations.containsKey(permutation)) {\n            rot = evaluatedPermutations.get(permutation);\n        } else {\n            rot = isValidPermutation(permutation);\n        }\n        if (rot == null) {\n            // if any induced rotation is invalid, abort\n            return false;\n        }\n        if (!evaluatedPermutations.containsKey(permutation)) {\n            //novel\n            newRots.add(rot);\n        }\n    }\n    // Add rotations\n    for (Rotation rot : newRots) {\n        addRotation(rot);\n    }\n    return true;\n}","repo_id":"9","comment":"/**\n * Combine current rotations to make all possible permutations.\n * If these are all valid, add them to the rotations\n * @param additionalRots Additional rotations we are considering adding to this.rotations\n * @return whether the rotations were valid and added\n */\n","repo_name":"biojava-master/","id":1900,"method_signature":"boolean completeRotationGroup(Rotation[])"}