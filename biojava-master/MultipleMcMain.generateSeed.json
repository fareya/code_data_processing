{"callee_method_names":["List<Atom[]>.size","List<List<AFPChain>>.add","List<List<AFPChain>>.get","MultipleMcParameters.getNrThreads","List<Atom[]>.get","List<Atom[]>.get","StructureAlignment.getAlgorithmName","StructureAlignment.getParameters","ExecutorService.submit","List<Future<AFPChain>>.add","List<List<AFPChain>>.get","List<Future<AFPChain>>.get","List<List<AFPChain>>.get","List<Future<AFPChain>>.get","ExecutorService.shutdown","StructureAlignment.getAlgorithmName","List<List<AFPChain>>.get"],"method_name":"MultipleMcMain.generateSeed","method_implementation":"{\n    int size = atomArrays.size();\n    //List to store the all-to-all alignments\n    List<List<AFPChain>> afpAlignments = new ArrayList<List<AFPChain>>();\n    for (int i = 0; i < size; i++) {\n        afpAlignments.add(new ArrayList<AFPChain>());\n        for (int j = 0; j < size; j++) afpAlignments.get(i).add(null);\n    }\n    int threads = params.getNrThreads();\n    ExecutorService executor = Executors.newFixedThreadPool(threads);\n    List<Future<AFPChain>> afpFuture = new ArrayList<Future<AFPChain>>();\n    //Create all the possible protein pairwise combinations\n    //(N*(N-1)/2) and call the pairwise alignment algorithm\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            Callable<AFPChain> worker = new CallableStructureAlignment(atomArrays.get(i), atomArrays.get(j), pairwise.getAlgorithmName(), pairwise.getParameters());\n            Future<AFPChain> submit = executor.submit(worker);\n            afpFuture.add(submit);\n        }\n    }\n    //Store the resulting AFPChains in the 2D List\n    //the alignment index\n    int index = 0;\n    for (int i = 0; i < size; i++) {\n        for (int j = i; j < size; j++) {\n            if (i != j) {\n                afpAlignments.get(i).add(j, afpFuture.get(index).get());\n                afpAlignments.get(j).add(i, afpFuture.get(index).get());\n                index++;\n            }\n        }\n    }\n    executor.shutdown();\n    reference = chooseReferenceRMSD(afpAlignments);\n    boolean flexible = false;\n    if (pairwise.getAlgorithmName().contains(\"flexible\"))\n        flexible = true;\n    return combineReferenceAlignments(afpAlignments.get(reference), atomArrays, reference, flexible);\n}","repo_id":"9","comment":"/**\n * Creates a MultipleAlignment seed for MC optimization from the\n * representative Atoms of the structures. If there are N structures:\n * <ul><li>Generate (N*(N-1))/2 all-to-all alignments in parallel using\n * the Java API.\n * <li>Choose the closest structure to all others as the reference.\n * <li>Generate a MultipleAlignment by combining all the alignments to\n * the reference, that will be used as a seed for the MC optimization.\n * <\/ul>\n *\n * @param atomArrays List of Atoms to align of the structures\n * @return MultipleAlignment seed alignment\n * @throws ExecutionException\n * @throws InterruptedException\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":690,"method_signature":"MultipleAlignment generateSeed(List)"}