{"callee_method_names":["DistanceMatrix.getSize","Phylogeny.getExternalNodes","HashMap<String, PhylogenyNode>.put","DistanceMatrix.getIdentifier","HashMap<String, PhylogenyNode>.get","DistanceMatrix.getIdentifier","HashMap<String, PhylogenyNode>.get","DistanceMatrix.getValue","Logger.info","Logger.warn","Set<PhylogenyNode>.clear","Logger.info","Logger.info","Logger.info"],"method_name":"DistanceTreeEvaluator.evaluate","method_implementation":"{\n    int numSequences = matrix.getSize();\n    List<PhylogenyNode> externalNodes = tree.getExternalNodes();\n    HashMap<String, PhylogenyNode> externalNodesHashMap = new HashMap<String, PhylogenyNode>();\n    Set<PhylogenyNode> path = new HashSet<PhylogenyNode>();\n    for (PhylogenyNode node : externalNodes) {\n        externalNodesHashMap.put(node.getName(), node);\n    }\n    int count = 0;\n    double averageMatrixDistance = 0.0;\n    double averageTreeDistance = 0.0;\n    double averageTreeErrorDistance = 0.0;\n    for (int row = 0; row < numSequences - 1; row++) {\n        String nodeName1 = matrix.getIdentifier(row);\n        PhylogenyNode node1 = externalNodesHashMap.get(nodeName1);\n        markPathToRoot(node1, path);\n        for (int col = row + 1; col < numSequences; col++) {\n            count++;\n            String nodeName2 = matrix.getIdentifier(col);\n            PhylogenyNode node2 = externalNodesHashMap.get(nodeName2);\n            double distance = matrix.getValue(col, row);\n            averageMatrixDistance = averageMatrixDistance + distance;\n            PhylogenyNode commonParent = findCommonParent(node2, path);\n            if (commonParent != null) {\n                double treeDistance = getNodeDistance(commonParent, node1) + getNodeDistance(commonParent, node2);\n                averageTreeDistance += treeDistance;\n                averageTreeErrorDistance += (distance - treeDistance) * (distance - treeDistance);\n                logger.info(\"{} {} Distance: {}Tree: {} difference: {}\", nodeName1, nodeName2, distance, treeDistance, Math.abs(distance - treeDistance));\n            } else {\n                logger.warn(\"Unable to find common parent with {} {}\", node1, node2);\n            }\n        }\n        path.clear();\n    }\n    averageMatrixDistance /= count;\n    averageTreeDistance /= count;\n    averageTreeErrorDistance /= count;\n    logger.info(\"Average matrix distance: {}\", averageMatrixDistance);\n    logger.info(\"Average tree distance: {}\", averageTreeDistance);\n    logger.info(\"Average LS error: {}\", averageTreeErrorDistance);\n    return Math.sqrt(averageTreeErrorDistance) / averageMatrixDistance;\n}","repo_id":"9","comment":"/**\n * Evaluate the goodness of fit of a given tree to the original distance\n * matrix. The returned value is the coefficient of variation, i.e. the\n * square root of the LS error normalized by the mean.\n * <p>\n * This measure can also give an estimate of the quality of the distance\n * matrix, because a bad fit may mean that the distance is non-additive.\n *\n * @param tree\n *            Phylogenetic Distance Tree to evaluate\n * @param matrix\n *            Distance Matrix with the original distances\n * @return the square root of the average tree LS error normalized by the\n *         average tree distance (coefficient of variation, CV).\n */\n","repo_name":"biojava-master/","id":114,"method_signature":"double evaluate(Phylogeny, DistanceMatrix)"}