{"callee_method_names":["Vector3d.dot","Vector3d.cross","Vector3d.normalize","AxisAngle4d.set","Vector3d.angle","Matrix4d.set","Matrix4d.setElement","Matrix4d.setIdentity","Matrix4d.set","Matrix4d.transform","Matrix4d.transform","Vector3d.dot","Vector3d.cross","Vector3d.normalize","AxisAngle4d.set","Vector3d.angle","Matrix4d.set","Matrix4d.setElement","Matrix4d.setIdentity","Matrix4d.set","Matrix4d.transform","Matrix4d.transform","Matrix4d.mul","Logger.warn"],"method_name":"HelixAxisAligner.alignAxes","method_implementation":"{\n    Matrix4d m1 = new Matrix4d();\n    AxisAngle4d a = new AxisAngle4d();\n    Vector3d axis = new Vector3d();\n    // calculate rotation matrix to rotate refPoints[0] into coordPoints[0]\n    Vector3d v1 = new Vector3d(axisVectors[0]);\n    Vector3d v2 = new Vector3d(referenceVectors[0]);\n    double dot = v1.dot(v2);\n    if (Math.abs(dot) < 0.999) {\n        axis.cross(v1, v2);\n        axis.normalize();\n        a.set(axis, v1.angle(v2));\n        m1.set(a);\n        // make sure matrix element m33 is 1.0. It's 0 on Linux.\n        m1.setElement(3, 3, 1.0);\n    } else if (dot > 0) {\n        // parallel axis, nothing to do -> identity matrix\n        m1.setIdentity();\n    } else if (dot < 0) {\n        // anti-parallel axis, flip around x-axis\n        m1.set(flipX());\n    }\n    // apply transformation matrix to all refPoints\n    m1.transform(axisVectors[0]);\n    m1.transform(axisVectors[1]);\n    // calculate rotation matrix to rotate refPoints[1] into coordPoints[1]\n    v1 = new Vector3d(axisVectors[1]);\n    v2 = new Vector3d(referenceVectors[1]);\n    Matrix4d m2 = new Matrix4d();\n    dot = v1.dot(v2);\n    if (Math.abs(dot) < 0.999) {\n        axis.cross(v1, v2);\n        axis.normalize();\n        a.set(axis, v1.angle(v2));\n        m2.set(a);\n        // make sure matrix element m33 is 1.0. It's 0 on Linux.\n        m2.setElement(3, 3, 1.0);\n    } else if (dot > 0) {\n        // parallel axis, nothing to do -> identity matrix\n        m2.setIdentity();\n    } else if (dot < 0) {\n        // anti-parallel axis, flip around z-axis\n        m2.set(flipZ());\n    }\n    // apply transformation matrix to all refPoints\n    m2.transform(axisVectors[0]);\n    m2.transform(axisVectors[1]);\n    // combine the two rotation matrices\n    m2.mul(m1);\n    // the RMSD should be close to zero\n    Point3d[] axes = new Point3d[2];\n    axes[0] = new Point3d(axisVectors[0]);\n    axes[1] = new Point3d(axisVectors[1]);\n    Point3d[] ref = new Point3d[2];\n    ref[0] = new Point3d(referenceVectors[0]);\n    ref[1] = new Point3d(referenceVectors[1]);\n    if (CalcPoint.rmsd(axes, ref) > 0.1) {\n        logger.warn(\"AxisTransformation: axes alignment is off. RMSD: \" + CalcPoint.rmsd(axes, ref));\n    }\n    return m2;\n}","repo_id":"9","comment":"/**\n * Returns a transformation matrix that rotates refPoints to match\n * coordPoints\n * @param refPoints the points to be aligned\n * @param referenceVectors\n * @return\n */\n","repo_name":"biojava-master/","id":1975,"method_signature":"Matrix4d alignAxes(Vector3d[], Vector3d[])"}