{"callee_method_names":["Random.nextInt","Random.nextInt","Random.nextInt","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.contains","List<List<Integer>>.get","List<Integer>.remove","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.contains","List<List<Integer>>.get","List<Integer>.remove","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","Random.nextInt","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.contains","List<List<Integer>>.get","List<Integer>.remove","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.add","List<Integer>.contains","List<List<Integer>>.get","List<Integer>.remove","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.contains","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.remove","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.add"],"method_name":"SymmOptimizer.shiftRow","method_implementation":"{\n    // Select the repeat\n    int su = rnd.nextInt(order);\n    // Select between moving right (0) or left (1)\n    int rl = rnd.nextInt(2);\n    // Residue as a pivot\n    int res = rnd.nextInt(length);\n    // When the pivot residue is null try to add a residue from the freePool\n    if (block.get(su).get(res) == null) {\n        int right = res;\n        int left = res;\n        // Find the boundary to the right abd left\n        while (block.get(su).get(right) == null && right < length - 1) {\n            right++;\n        }\n        while (block.get(su).get(left) == null && left > 0) {\n            left--;\n        }\n        // If they both are null the whole block is null\n        if (block.get(su).get(left) == null && block.get(su).get(right) == null) {\n            return false;\n        } else if (block.get(su).get(left) == null) {\n            // Choose the sequentially previous residue of the known one\n            Integer residue = block.get(su).get(right) - 1;\n            if (freePool.contains(residue)) {\n                block.get(su).set(res, residue);\n                freePool.remove(residue);\n            } else\n                return false;\n        } else if (block.get(su).get(right) == null) {\n            // Choose the sequentially next residue of the known one\n            Integer residue = block.get(su).get(left) + 1;\n            if (freePool.contains(residue)) {\n                block.get(su).set(res, residue);\n                freePool.remove(residue);\n            } else\n                return false;\n        } else {\n            // If boundaries are consecutive swap null and position (R or L)\n            if (block.get(su).get(right) == block.get(su).get(left) + 1) {\n                switch(rl) {\n                    case // to the right\n                    0:\n                        block.get(su).set(right - 1, block.get(su).get(right));\n                        block.get(su).set(right, null);\n                        break;\n                    case // to the left\n                    1:\n                        block.get(su).set(left + 1, block.get(su).get(left));\n                        block.get(su).set(left, null);\n                        break;\n                }\n            } else {\n                // Choose randomly a residue in between left and right to\n                // add\n                Integer residue = rnd.nextInt(block.get(su).get(right) - block.get(su).get(left) - 1) + block.get(su).get(left) + 1;\n                if (freePool.contains(residue)) {\n                    block.get(su).set(res, residue);\n                    freePool.remove(residue);\n                }\n            }\n        }\n        return true;\n    }\n    // When the residue is different than null\n    switch(rl) {\n        case // Move to the right\n        0:\n            int leftBoundary = res - 1;\n            int leftPrevRes = res;\n            while (true) {\n                if (leftBoundary < 0)\n                    break;\n                else {\n                    if (block.get(su).get(leftBoundary) == null) {\n                        // gap\n                        break;\n                    } else if (block.get(su).get(leftPrevRes) > block.get(su).get(leftBoundary) + 1) {\n                        // discontinuity\n                        break;\n                    }\n                }\n                leftPrevRes = leftBoundary;\n                leftBoundary--;\n            }\n            leftBoundary++;\n            int rightBoundary = res + 1;\n            int rightPrevRes = res;\n            while (true) {\n                if (rightBoundary == length)\n                    break;\n                else {\n                    if (block.get(su).get(rightBoundary) == null) {\n                        // gap\n                        break;\n                    } else if (block.get(su).get(rightPrevRes) + 1 < block.get(su).get(rightBoundary)) {\n                        // discontinuity\n                        break;\n                    }\n                }\n                rightPrevRes = rightBoundary;\n                rightBoundary++;\n            }\n            rightBoundary--;\n            // Residues at the boundary\n            Integer residueR0 = block.get(su).get(rightBoundary);\n            Integer residueL0 = block.get(su).get(leftBoundary);\n            // Remove residue at the right of the block and add to the freePool\n            block.get(su).remove(rightBoundary);\n            if (residueR0 != null) {\n                freePool.add(residueR0);\n                Collections.sort(freePool);\n            }\n            // Add the residue at the left of the block\n            // cannot be null, throw exception if it is\n            residueL0 -= 1;\n            if (freePool.contains(residueL0)) {\n                block.get(su).add(leftBoundary, residueL0);\n                freePool.remove(residueL0);\n            } else {\n                block.get(su).add(leftBoundary, null);\n            }\n            break;\n        case // Move to the left\n        1:\n            int leftBoundary1 = res - 1;\n            int leftPrevRes1 = res;\n            while (true) {\n                if (leftBoundary1 < 0)\n                    break;\n                else {\n                    if (block.get(su).get(leftBoundary1) == null) {\n                        // gap\n                        break;\n                    } else if (block.get(su).get(leftPrevRes1) > block.get(su).get(leftBoundary1) + 1) {\n                        // discontinuity\n                        break;\n                    }\n                }\n                leftPrevRes1 = leftBoundary1;\n                leftBoundary1--;\n            }\n            leftBoundary1++;\n            int rightBoundary1 = res + 1;\n            int rightPrevRes1 = res;\n            while (true) {\n                if (rightBoundary1 == length)\n                    break;\n                else {\n                    if (block.get(su).get(rightBoundary1) == null) {\n                        // gap\n                        break;\n                    } else if (block.get(su).get(rightPrevRes1) + 1 < block.get(su).get(rightBoundary1)) {\n                        // discontinuity\n                        break;\n                    }\n                }\n                rightPrevRes1 = rightBoundary1;\n                rightBoundary1++;\n            }\n            rightBoundary1--;\n            // Residues at the boundary\n            Integer residueR1 = block.get(su).get(rightBoundary1);\n            Integer residueL1 = block.get(su).get(leftBoundary1);\n            // Add the residue at the right of the block\n            // cannot be null\n            residueR1 += 1;\n            if (freePool.contains(residueR1)) {\n                if (rightBoundary1 == length - 1)\n                    block.get(su).add(residueR1);\n                else\n                    block.get(su).add(rightBoundary1 + 1, residueR1);\n                freePool.remove(residueR1);\n            } else {\n                block.get(su).add(rightBoundary1 + 1, null);\n            }\n            // Remove the residue at the left of the block\n            block.get(su).remove(leftBoundary1);\n            freePool.add(residueL1);\n            Collections.sort(freePool);\n            break;\n    }\n    checkGaps();\n    return true;\n}","repo_id":"9","comment":"/**\n * Move all the block residues of one repeat one position to the left or\n * right and move the corresponding boundary residues from the freePool to\n * the block, and viceversa.\n * <p>\n * The boundaries are determined by any irregularity (either a gap or a\n * discontinuity in the alignment.\n */\n","repo_name":"biojava-master/","id":2079,"method_signature":"boolean shiftRow()"}