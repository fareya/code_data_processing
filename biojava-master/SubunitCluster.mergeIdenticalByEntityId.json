{"callee_method_ids":[1673,1673,1675,1675,1670,1669,1343],"callee_method_names":["SubunitCluster.get","Subunit.getName","Subunit.getName","Logger.info","Subunit.getStructure","Subunit.getStructure","Structure.getChain","Structure.getChain","Chain.getEntityInfo","Subunit.size","Subunit.getRepresentativeAtoms","EntityInfo.getAlignedResIndex","Chain.getSeqResGroups","Chain.getAtomGroups","SubunitCluster.get","List<Integer>.add","List<Integer>.add","List<Integer>.size","List<Integer>.size","Logger.warn"],"method_name":"SubunitCluster.mergeIdenticalByEntityId","method_implementation":"{\n    if (!isIdenticalByEntityIdTo(other))\n        return false;\n    Subunit thisSub = this.subunits.get(this.representative);\n    Subunit otherSub = other.subunits.get(other.representative);\n    String thisName = thisSub.getName();\n    String otherName = otherSub.getName();\n    logger.info(\"SubunitClusters {}-{} belong to same entity. Assuming they are identical\", thisName, otherName);\n    List<Integer> thisAligned = new ArrayList<>();\n    List<Integer> otherAligned = new ArrayList<>();\n    // we've merged by entity id, we can assume structure, chain and entity are available (checked in isIdenticalByEntityIdTo())\n    Structure thisStruct = thisSub.getStructure();\n    Structure otherStruct = otherSub.getStructure();\n    Chain thisChain = thisStruct.getChain(thisName);\n    Chain otherChain = otherStruct.getChain(otherName);\n    EntityInfo entityInfo = thisChain.getEntityInfo();\n    // Extract the aligned residues of both Subunits\n    for (int thisIndex = 0; thisIndex < thisSub.size(); thisIndex++) {\n        Group g = thisSub.getRepresentativeAtoms()[thisIndex].getGroup();\n        int seqresIndex = entityInfo.getAlignedResIndex(g, thisChain);\n        if (seqresIndex == -1) {\n            // this might mean that FileParsingParameters.setAlignSeqRes() wasn't set to true during parsing\n            continue;\n        }\n        // note the seqresindex is 1-based\n        Group otherG = otherChain.getSeqResGroups().get(seqresIndex - 1);\n        int otherIndex = otherChain.getAtomGroups().indexOf(otherG);\n        if (otherIndex == -1) {\n            // skip residues that are unobserved in other sequence (\"gaps\" in the entity SEQRES alignment)\n            continue;\n        }\n        // Only consider residues that are part of the SubunitCluster\n        if (this.subunitEQR.get(this.representative).contains(thisIndex) && other.subunitEQR.get(other.representative).contains(otherIndex)) {\n            thisAligned.add(thisIndex);\n            otherAligned.add(otherIndex);\n        }\n    }\n    if (thisAligned.size() == 0 && otherAligned.size() == 0) {\n        logger.warn(\"No equivalent aligned atoms found between SubunitClusters {}-{} via entity SEQRES alignment. Is FileParsingParameters.setAlignSeqRes() set?\", thisName, otherName);\n    }\n    updateEquivResidues(other, thisAligned, otherAligned);\n    return true;\n}","repo_id":"9","comment":"/**\n * Merges the other SubunitCluster into this one if it contains exactly the\n * same Subunit. This is checked by comparing the entity identifiers of the subunits\n * if one can be found.\n * Thus this only makes sense when the subunits are complete chains of a\n * deposited PDB entry.\n *\n * @param other\n *            SubunitCluster\n * @return true if the SubunitClusters were merged, false otherwise\n */\n","repo_name":"biojava-master/","id":1660,"method_signature":"boolean mergeIdenticalByEntityId(SubunitCluster)"}