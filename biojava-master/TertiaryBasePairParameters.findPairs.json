{"callee_method_names":["List<Chain>.size","List<Chain>.get","Chain.getAtomSequence","String.length","String.length","Chain.getAtomGroup","Chain.getAtomGroup","Map<String, Integer>.get","Group.getPDBName","Map<String, Integer>.get","Group.getPDBName","Group.getAtom","Group.getAtom","Atom.getCoordsAsPoint3d","Atom.getCoordsAsPoint3d","List<Pair<Group>>.add","ArrayList.add","String.length","String.charAt","String.length","Chain.getAtomSequence","List<Pair<Group>>.addAll"],"method_name":"TertiaryBasePairParameters.findPairs","method_implementation":"{\n    List<Pair<Group>> result = new ArrayList<>();\n    boolean lastFoundPair = false;\n    for (int i = 0; i < chains.size(); i++) {\n        Chain c = chains.get(i);\n        String sequence = c.getAtomSequence();\n        Integer type1, type2;\n        for (int j = 0; j < sequence.length(); j++) {\n            boolean foundPair = false;\n            for (int k = sequence.length() - 1; k >= j + 3 && !foundPair; k--) {\n                Group g1 = c.getAtomGroup(j);\n                Group g2 = c.getAtomGroup(k);\n                type1 = BASE_MAP.get(g1.getPDBName());\n                type2 = BASE_MAP.get(g2.getPDBName());\n                if (type1 == null || type2 == null)\n                    continue;\n                Atom a1 = g1.getAtom(\"C1'\");\n                Atom a2 = g2.getAtom(\"C1'\");\n                if (a1 == null || a2 == null)\n                    continue;\n                // C1'-C1' distance is one useful criteria\n                if (Math.abs(a1.getCoordsAsPoint3d().distance(a2.getCoordsAsPoint3d()) - 10.0) > 4.0)\n                    continue;\n                Pair<Group> ga = new Pair<>(g1, g2);\n                // TODO is this call needed?? JD 2018-03-07\n                @SuppressWarnings(\"unused\")\n                Matrix4d data = basePairReferenceFrame(ga);\n                // if the stagger is greater than 2 Ã…, it's not really paired.\n                if (Math.abs(pairParameters[5]) > maxStagger)\n                    continue;\n                // if the propeller is ridiculous it's also not that good of a pair.\n                if (Math.abs(pairParameters[1]) > maxPropeller) {\n                    continue;\n                }\n                result.add(ga);\n                pairingNames.add(useRNA ? BASE_LIST_RNA[type1] + BASE_LIST_RNA[type2] : BASE_LIST_DNA[type1] + BASE_LIST_DNA[type2]);\n                foundPair = true;\n            }\n            if (!foundPair && lastFoundPair) {\n                if (pairSequence.length() > 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                    pairSequence += ' ';\n            }\n            if (foundPair)\n                pairSequence += (c.getAtomSequence().charAt(j));\n            lastFoundPair = foundPair;\n        }\n    }\n    result.addAll(super.findPairs(chains));\n    return result;\n}","repo_id":"9","comment":"/**\n * This is an alternative implementation of findPair() that looks for anything that would fit the\n * criteria for a base-pair, useful for the context of tertiary structure of RNA.  Intra-strand base pairs\n * are found with this algorithm.\n * @param chains The list of chains already found to be nucleic acids\n * @return A list of the Pair of groups that match the base pair criteria, including intra-strand groups.\n */\n","repo_name":"biojava-master/","id":1746,"method_signature":"List<Pair<Group>> findPairs(List)"}