{"callee_method_names":["MultipleAlignment.clone","List<SortedSet<Integer>>.get","double.add","List<SortedSet<Integer>>.add","Random.nextDouble","Logger.debug","Logger.debug","Logger.debug","Logger.debug","MultipleAlignment.clear","MultipleSuperimposer.superimpose","Random.nextDouble","Logger.debug","List<Integer>.add","MultipleAlignment.length","List<Double>.add","List<Double>.add","MultipleSuperimposer.superimpose","MultipleAlignment.putScore","Logger.warn","Object.getMessage"],"method_name":"MultipleMcOptimizer.optimize","method_implementation":"{\n    initialize();\n    // Number of steps without an alignment improvement\n    int conv = 0;\n    int i = 1;\n    int maxIter = convergenceSteps * 100;\n    while (i < maxIter && conv < convergenceSteps) {\n        // Save the state of the system\n        MultipleAlignment lastMSA = msa.clone();\n        List<SortedSet<Integer>> lastFreePool = new ArrayList<SortedSet<Integer>>();\n        for (int k = 0; k < size; k++) {\n            SortedSet<Integer> p = new TreeSet<Integer>();\n            for (Integer l : freePool.get(k)) p.add(l);\n            lastFreePool.add(p);\n        }\n        double lastScore = mcScore;\n        boolean moved = false;\n        while (!moved) {\n            // Randomly select one of the steps to modify the alignment\n            double move = rnd.nextDouble();\n            if (move < 0.4) {\n                moved = shiftRow();\n                logger.debug(\"did shift\");\n            } else if (move < 0.7) {\n                moved = expandBlock();\n                logger.debug(\"did expand\");\n            } else if (move < 0.85) {\n                moved = shrinkBlock();\n                logger.debug(\"did shrink\");\n            } else {\n                moved = insertGap();\n                logger.debug(\"did insert gap\");\n            }\n        }\n        // Get the score of the new alignment\n        msa.clear();\n        imposer.superimpose(msa);\n        mcScore = MultipleAlignmentScorer.getMCScore(msa, Gopen, Gextend, dCutoff);\n        double AS = mcScore - lastScore;\n        double prob = 1.0;\n        if (AS < 0) {\n            // Probability of accepting the move\n            prob = probabilityFunction(AS, i, maxIter);\n            double p = rnd.nextDouble();\n            // Reject the move\n            if (p > prob) {\n                msa = lastMSA;\n                freePool = lastFreePool;\n                mcScore = lastScore;\n                conv++;\n            } else\n                conv = 0;\n        } else\n            conv = 0;\n        logger.debug(\"Step: \" + i + \": --prob: \" + prob + \", --score change: \" + AS + \", --conv: \" + conv);\n        if (history) {\n            if (i % 100 == 1) {\n                lengthHistory.add(msa.length());\n                rmsdHistory.add(MultipleAlignmentScorer.getRMSD(msa));\n                scoreHistory.add(mcScore);\n            }\n        }\n        i++;\n    }\n    // Return Multiple Alignment\n    imposer.superimpose(msa);\n    MultipleAlignmentScorer.calculateScores(msa);\n    msa.putScore(MultipleAlignmentScorer.MC_SCORE, mcScore);\n    if (history) {\n        try {\n            saveHistory(pathToHistory);\n        } catch (Exception e) {\n            logger.warn(\"Could not save history file: \" + e.getMessage());\n        }\n    }\n    return msa;\n}","repo_id":"9","comment":"/**\n * Optimization method based in a Monte-Carlo approach. Starting from the\n * refined alignment uses 4 types of moves:\n * <p>\n * <ul>\n * <li>Shift Row: if there are enough freePool residues available.\n * <li>Expand Block: add another alignment column.\n * <li>Shrink Block: move a block column to the freePool.\n * <li>Insert gap: insert a gap in a random position of the alignment.\n * <\/ul>\n * <\/li>\n */\n","repo_name":"biojava-master/","id":694,"method_signature":"MultipleAlignment optimize()"}