{"callee_method_ids":[487],"callee_method_names":["AFPChain.getBlockNum","FatCatParameters.getBadRmsd","AFPChain.getBlock2Afp","AFPChain.getBlockSize","AFPChain.getBlockRmsd","AFPChain.getAfpChainTwiNum","AFPChain.setBlock2Afp","AFPChain.setBlockSize","AFPChain.setBlockNum","AFPChain.setBlockRmsd","AFPChain.setAfpChainTwiNum"],"method_name":"AFPPostProcessor.mergeBlock","method_implementation":"{\n    int blockNum = afpChain.getBlockNum();\n    double badRmsd = params.getBadRmsd();\n    int[] block2Afp = afpChain.getBlock2Afp();\n    int[] blockSize = afpChain.getBlockSize();\n    double[] blockRmsd = afpChain.getBlockRmsd();\n    int afpChainTwiNum = afpChain.getAfpChainTwiNum();\n    //clustering the neighbor blocks if their transformations are similar\n    int i, j, b1, b2, minb1, minb2;\n    double minrmsd;\n    int merge = 0;\n    int blockNumOld = blockNum;\n    double[][] rmsdlist = null;\n    if (blockNum > 1) {\n        rmsdlist = new double[blockNumOld][blockNumOld];\n        for (b1 = 0; b1 < blockNum - 1; b1++) {\n            for (b2 = b1 + 1; b2 < blockNum; b2++) {\n                rmsdlist[b1][b2] = combineRmsd(b1, b2, afpChain, ca1, ca2);\n            }\n        }\n    }\n    minb1 = 0;\n    while (blockNum > 1) {\n        minrmsd = 1000;\n        for (i = 0; i < blockNum - 1; i++) {\n            //only consider neighbor blocks\n            j = i + 1;\n            if (minrmsd > rmsdlist[i][j]) {\n                minrmsd = rmsdlist[i][j];\n                minb1 = i;\n            }\n        }\n        //merge those most similar blocks\n        minb2 = minb1 + 1;\n        //maxrmsd = (blockRmsd[minb1] > blockRmsd[minb2])?blockRmsd[minb1]:blockRmsd[minb2];\n        if (minrmsd < badRmsd) {\n            if (debug)\n                System.out.println(String.format(\"merge block %d (rmsd %.3f) and %d (rmsd %.3f), total rmsd %.3f\\n\", minb1, blockRmsd[minb1], minb2, blockRmsd[minb2], minrmsd));\n            blockSize[minb1] += blockSize[minb2];\n            blockRmsd[minb1] = minrmsd;\n            for (i = minb2; i < blockNum - 1; i++) {\n                block2Afp[i] = block2Afp[i + 1];\n                blockSize[i] = blockSize[i + 1];\n                blockRmsd[i] = blockRmsd[i + 1];\n            }\n            //update block information\n            afpChainTwiNum--;\n            blockNum--;\n            for (b1 = 0; b1 < blockNum - 1; b1++) {\n                for (b2 = b1 + 1; b2 < blockNum; b2++) {\n                    if (b1 == minb1 || b2 == minb1) {\n                        rmsdlist[b1][b2] = combineRmsd(b1, b2, afpChain, ca1, ca2);\n                    } else if (b2 < minb1)\n                        continue;\n                    else if (b1 < minb1) {\n                        rmsdlist[b1][b2] = rmsdlist[b1][b2 + 1];\n                    } else {\n                        rmsdlist[b1][b2] = rmsdlist[b1 + 1][b2 + 1];\n                    }\n                }\n            }\n            //update the rmsdlist\n            merge++;\n        } else //merge two blocks\n        if (minrmsd >= 100)\n            break;\n        else {\n            rmsdlist[minb1][minb2] += 100;\n        }\n        //not merge, modify the rmsdlist so that this combination is not considered in next iteration\n    }\n    if (merge > 0) {\n        if (debug)\n            System.out.println(String.format(\"Merge %d blocks, remaining %d blocks\\n\", merge, blockNum));\n    }\n    if (debug) {\n        System.err.println(\"AFPPostProcessor: mergeBlock end blocknum:\" + blockNum);\n    }\n    afpChain.setBlock2Afp(block2Afp);\n    afpChain.setBlockSize(blockSize);\n    afpChain.setBlockNum(blockNum);\n    afpChain.setBlockRmsd(blockRmsd);\n    afpChain.setAfpChainTwiNum(afpChainTwiNum);\n}","repo_id":"9","comment":"/**\n * Merge consecutive blocks with similar transformation\n */\n","repo_name":"biojava-master/","id":423,"method_signature":"void mergeBlock(FatCatParameters, AFPChain, Atom[], Atom[])"}