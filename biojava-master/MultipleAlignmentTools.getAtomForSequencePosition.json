{"callee_method_names":["List<Integer>.get","MultipleAlignment.getBlocks","String.length","String.length","String.getAlignRes","MultipleAlignment.getAtomArrays"],"method_name":"MultipleAlignmentTools.getAtomForSequencePosition","method_implementation":"{\n    int seqPos = mapSeqToStruct.get(sequencePos);\n    // Check if the position selected is an aligned position\n    if (seqPos == -1)\n        return null;\n    else {\n        Atom a = null;\n        // Calculate the corresponding structure position\n        int sum = 0;\n        for (Block b : msa.getBlocks()) {\n            if (sum + b.length() <= seqPos) {\n                sum += b.length();\n                continue;\n            } else {\n                for (Integer p : b.getAlignRes().get(str)) {\n                    if (sum == seqPos) {\n                        if (p != null) {\n                            a = msa.getAtomArrays().get(str)[p];\n                        }\n                        break;\n                    }\n                    sum++;\n                }\n                break;\n            }\n        }\n        return a;\n    }\n}","repo_id":"9","comment":"/**\n * Returns the Atom of the specified structure that is aligned in the\n * sequence alignment position specified.\n *\n * @param multAln\n *            the MultipleAlignment object from where the sequence alignment\n *            has been generated\n * @param mapSeqToStruct\n *            the mapping between sequence and structure generated with the\n *            sequence alignment\n * @param str\n *            the structure index of the alignment (row)\n * @param sequencePos\n *            the sequence alignment position (column)\n * @return Atom the atom in that position or null if there is a gap\n */\n","repo_name":"biojava-master/","id":657,"method_signature":"Atom getAtomForSequencePosition(MultipleAlignment, List, int, int)"}