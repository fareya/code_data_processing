{"callee_method_ids":[1885,1884],"callee_method_names":["RotationGroup.getPointGroup","RotationAxisAligner.getSubunits","QuatSymmetrySubunits.getModelNumbers","QuatSymmetrySubunits.getChainIds","RotationAxisAligner.getOrbits","QuatSymmetrySubunits.getSubunitCount","RotationGroup.getRotation","String.startsWith","String.startsWith","List<List<Integer>>.size","List<List<Integer>>.size","List<List<Integer>>.size","List<List<Integer>>.size","List<List<Integer>>.size","List<List<Integer>>.size","Map<Color4f, List<String>>.get","Map<Color4f, List<String>>.put","List<List<Integer>>.get","List<String>.add","List<List<Integer>>.size","List<List<Integer>>.size","Map<Color4f, List<String>>.get","Map<Color4f, List<String>>.put","List<List<Integer>>.get","List<Integer>.size","List<Integer>.get","List<String>.add"],"method_name":"JmolSymmetryScriptGeneratorPointGroup.colorBySymmetry","method_implementation":"{\n    // TODO needs some refactoring\n    String pointGroup = rotationGroup.getPointGroup();\n    QuatSymmetrySubunits subunits = rotationAxisAligner.getSubunits();\n    List<Integer> modelNumbers = subunits.getModelNumbers();\n    List<String> chainIds = subunits.getChainIds();\n    List<List<Integer>> orbits = rotationAxisAligner.getOrbits();\n    int n = subunits.getSubunitCount();\n    int fold = rotationGroup.getRotation(0).getFold();\n    Map<Color4f, List<String>> colorMap = new HashMap<Color4f, List<String>>();\n    // Simple Cn symmetry\n    if (pointGroup.startsWith(\"C\") && n == fold) {\n        colorMap = getCnColorMap();\n        // complex cases\n    } else if ((pointGroup.startsWith(\"D\") && orbits.size() > 2) || \"T\".equals(pointGroup) || \"O\".equals(pointGroup) || \"I\".equals(pointGroup)) {\n        int nColor = 0;\n        if (orbits.size() % 2 == 0) {\n            nColor = orbits.size() / 2;\n        } else {\n            nColor = (orbits.size() + 1) / 2;\n        }\n        Color4f[] colors = getSymmetryColors(nColor);\n        for (int i = 0; i < orbits.size(); i++) {\n            int colorIndex = i;\n            // reverse colors once the center of the structure has been reached\n            if (i >= nColor) {\n                colorIndex = orbits.size() - 1 - i;\n            }\n            Color4f c = colors[colorIndex];\n            List<String> ids = colorMap.get(c);\n            if (ids == null) {\n                ids = new ArrayList<String>();\n                colorMap.put(c, ids);\n            }\n            for (int subunit : orbits.get(i)) {\n                String id = getChainSpecification(modelNumbers, chainIds, subunit);\n                ids.add(id);\n            }\n        }\n        // Simple Dn symmetry\n    } else {\n        Color4f[] colors = getSymmetryColors(orbits.size());\n        for (int i = 0; i < orbits.size(); i++) {\n            Color4f c = new Color4f(colors[i]);\n            List<String> ids = colorMap.get(c);\n            if (ids == null) {\n                ids = new ArrayList<String>();\n                colorMap.put(c, ids);\n            }\n            List<Integer> orbit = orbits.get(i);\n            for (int j = 0; j < orbit.size(); j++) {\n                String id = getChainSpecification(modelNumbers, chainIds, orbit.get(j));\n                ids.add(id);\n            }\n        }\n    }\n    return defaultColoring + getJmolColorScript(colorMap) + getJmolLigandScript();\n}","repo_id":"9","comment":"/* (non-Javadoc)\n\t * @see org.biojava.nbio.structure.quaternary.jmolScript.JMolSymmetryScriptInterface#colorBySymmetry()\n\t */\n","repo_name":"biojava-master/","id":3398,"method_signature":"String colorBySymmetry()"}