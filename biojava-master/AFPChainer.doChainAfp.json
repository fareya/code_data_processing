{"callee_method_ids":[484,432],"callee_method_names":["AFPChain.getAfpSet","AFPChain.setConn","AFPChain.setDVar","List<AFP>.size","AFPChain.getTwi","AFPChain.setTwi","AFPChain.setConn","AFPChain.setDVar","FatCatParameters.getMaxGap","FatCatParameters.getFragLen","FatCatParameters.getMaxTra","AFPChain.setDisTable1","AFPChain.setDisTable2","List<AFP>.get","List<AFP>.get","List<AFP>.get","AFPChain.getConn","List<AFP>.get","AFPChain.setAlignScore","AFPChain.setAlignScoreUpdate","AFPChain.setAfpChainTwiNum"],"method_name":"AFPChainer.doChainAfp","method_implementation":"{\n    List<AFP> afpSet = afpChain.getAfpSet();\n    afpChain.setConn(0d);\n    afpChain.setDVar(0d);\n    int afpNum = afpSet.size();\n    if (afpNum <= 0)\n        return;\n    int[] twi = afpChain.getTwi();\n    if (twi == null) {\n        twi = new int[afpNum];\n        afpChain.setTwi(twi);\n    }\n    //transformation, calculated at DoChainAfp, be used in List extraction\n    //forward: calculate the score matrix\n    boolean isConnected = false;\n    int i, j, j0, n;\n    double stmp;\n    afpChain.setConn(0d);\n    afpChain.setDVar(0d);\n    //the score ending at an AFP\n    double[] sco = new double[afpNum];\n    //the previous AFP\n    int[] pre = new int[afpNum];\n    double maxsco = 0;\n    int maxafp = 0;\n    int[] list = new int[afpNum];\n    int maxGap = params.getMaxGap();\n    int fragLen = params.getFragLen();\n    int maxTra = params.getMaxTra();\n    Matrix disTable1 = getDisTable(maxGap + 2 * fragLen + 1, ca1);\n    Matrix disTable2 = getDisTable(maxGap + 2 * fragLen + 1, ca2);\n    afpChain.setDisTable1(disTable1);\n    afpChain.setDisTable2(disTable2);\n    for (i = 0; i < afpNum; i++) {\n        //start from itself\n        sco[i] = afpSet.get(i).getScore();\n        pre[i] = -1;\n        twi[i] = 0;\n        if (afpSet.get(i).getP1() < fragLen || afpSet.get(i).getP2() < fragLen)\n            n = 0;\n        else\n            //get a compatible list\n            n = getCompatibleAfps(i, list, params, afpChain);\n        //printf(\"afp %d, compatible %d\\n\", i, n);\n        for (j0 = 0; j0 < n; j0++) {\n            j = list[j0];\n            //note: j, i\n            isConnected = afpPairConn(j, i, params, afpChain);\n            Double conn = afpChain.getConn();\n            int t = 0;\n            if (isConnected)\n                t = 1;\n            if (twi[j] + t > maxTra)\n                continue;\n            //two many transformation are disfavored\n            stmp = sco[j] + afpSet.get(i).getScore() + conn;\n            if (stmp > sco[i]) {\n                //considered all previous compatible AFPs\n                sco[i] = stmp;\n                twi[i] = twi[j] + t;\n                pre[i] = j;\n            }\n        }\n        if (maxsco < sco[i]) {\n            maxsco = sco[i];\n            maxafp = i;\n        }\n    }\n    int currafp = maxafp;\n    if (debug)\n        System.out.printf(\"maximum score %f, %d%n%n\", maxsco, twi[currafp]);\n    //trace-back from maxafp (maxsco)\n    afpChain.setAlignScore(maxsco);\n    afpChain.setAlignScoreUpdate(maxsco);\n    afpChain.setAfpChainTwiNum(0);\n    traceBack(pre, currafp, twi[currafp], params, afpChain, ca1, ca2);\n}","repo_id":"9","comment":"/**\n * \t// Key function: chain (assembly) the AFPs\n * \t// a AFP (k) is defined as (i, j, k), with i and j are staring points\n * \t// AFP extension (eg. AFP(k-1) -> AFP(k) ) requiring\n * \t// AFP(k-1) < AFP(k)(refer AFP.h definition),\n * \t// ie i(k-1) < i(k) and j(k-1) < j(k)\n * \t// in the figure, only (2) AFP can extend to AFP(k)\n * \t// Key features: a coordination transformation is allowed in the AFP extension\n * \t//                      gap penalties are also considered\n * \t//\n * \t//                                   protein1\n * \t//                 ---------------------------\n * \t//                 |        \\                |\n * \t//                 |         \\(1)            |\n * \t//                 |     \\    \\              |\n * \t//                 |      \\(2) \\             |\n * \t//              p  |       \\                 |\n * \t//              r  |   \\                     |\n * \t//              o  |    \\(3)  \\(i,j, k)      |\n * \t//              t  |     \\     \\             |\n * \t//              e  |            \\            |\n * \t//              i  |                         |\n * \t//              n  |                         |\n * \t//              2  ---------------------------\n * \t//                  schematic of AFP chaining\n */\n","repo_name":"biojava-master/","id":412,"method_signature":"void doChainAfp(FatCatParameters, AFPChain, Atom[], Atom[])"}