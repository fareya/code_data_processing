{"callee_method_names":["Reader.ready"],"method_name":"BufferedReaderBytesRead.read","method_implementation":"{\n    synchronized (lock) {\n        ensureOpen();\n        if ((off < 0) || (off > cbuf.length) || (len < 0) || ((off + len) > cbuf.length) || ((off + len) < 0)) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n        int n = read1(cbuf, off, len);\n        if (n <= 0) {\n            return n;\n        }\n        while ((n < len) && in.ready()) {\n            int n1 = read1(cbuf, off + n, len - n);\n            if (n1 <= 0) {\n                break;\n            }\n            n += n1;\n        }\n        bytesRead = bytesRead + n;\n        return n;\n    }\n}","repo_id":"9","comment":"/**\n * Reads characters into a portion of an array.\n *\n * <p> This method implements the general contract of the corresponding\n * <code>{@link Reader#read(char[], int, int) read}<\/code> method of the\n * <code>{@link Reader}<\/code> class.  As an additional convenience, it\n * attempts to read as many characters as possible by repeatedly invoking\n * the <code>read<\/code> method of the underlying stream.  This iterated\n * <code>read<\/code> continues until one of the following conditions becomes\n * true: <ul>\n *\n *   <li> The specified number of characters have been read,\n *\n *   <li> The <code>read<\/code> method of the underlying stream returns\n *   <code>-1<\/code>, indicating end-of-file, or\n *\n *   <li> The <code>ready<\/code> method of the underlying stream\n *   returns <code>false<\/code>, indicating that further input requests\n *   would block.\n *\n * <\/ul> If the first <code>read<\/code> on the underlying stream returns\n * <code>-1<\/code> to indicate end-of-file then this method returns\n * <code>-1<\/code>.  Otherwise this method returns the number of characters\n * actually read.\n *\n * <p> Subclasses of this class are encouraged, but not required, to\n * attempt to read as many characters as possible in the same fashion.\n *\n * <p> Ordinarily this method takes characters from this stream's character\n * buffer, filling it from the underlying stream as necessary.  If,\n * however, the buffer is empty, the mark is not valid, and the requested\n * length is at least as large as the buffer, then this method will read\n * characters directly from the underlying stream into the given array.\n * Thus redundant <code>BufferedReaderBytesRead<\/code>s will not copy data\n * unnecessarily.\n *\n * @param      cbuf  Destination buffer\n * @param      off   Offset at which to start storing characters\n * @param      len   Maximum number of characters to read\n *\n * @return     The number of characters read, or -1 if the end of the\n *             stream has been reached\n *\n * @exception  IOException  If an I/O error occurs\n */\n","repo_name":"biojava-master/","id":2714,"method_signature":"int read(char[], int, int)"}