{"callee_method_ids":[2105,2100,2097,2094,2100],"callee_method_names":["MultipleAlignment.getBlocks","List<List<Integer>>.get","SymmetryAxes.getNumLevels","SymmetryAxes.getFirstRepeats","SymmetryAxes.getRepeatTransform","SymmetryAxes.getRepeatRelation","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","MultipleAlignment.getAtomArrays","MultipleAlignment.getAtomArrays","List<Atom>.add","List<Atom>.add","List<Atom>.toArray","List<Atom>.size","List<Atom>.toArray","List<Atom>.size","SymmetryAxes.updateAxis","MultipleAlignment.size","List<Matrix4d>.add","SymmetryAxes.getRepeatTransform","MultipleAlignment.getBlockSet","MultipleSuperimposer.superimpose"],"method_name":"SymmetryTools.updateSymmetryTransformation","method_implementation":"{\n    List<List<Integer>> block = msa.getBlocks().get(0).getAlignRes();\n    int length = block.get(0).size();\n    if (axes != null) {\n        for (int level = 0; level < axes.getNumLevels(); level++) {\n            // Calculate the aligned atom arrays to superimpose\n            List<Atom> list1 = new ArrayList<Atom>();\n            List<Atom> list2 = new ArrayList<Atom>();\n            for (int firstRepeat : axes.getFirstRepeats(level)) {\n                Matrix4d transform = axes.getRepeatTransform(firstRepeat);\n                List<List<Integer>> relation = axes.getRepeatRelation(level, firstRepeat);\n                for (int index = 0; index < relation.get(0).size(); index++) {\n                    int p1 = relation.get(0).get(index);\n                    int p2 = relation.get(1).get(index);\n                    for (int k = 0; k < length; k++) {\n                        Integer pos1 = block.get(p1).get(k);\n                        Integer pos2 = block.get(p2).get(k);\n                        if (pos1 != null && pos2 != null) {\n                            Atom a = (Atom) msa.getAtomArrays().get(p1)[pos1].clone();\n                            Atom b = (Atom) msa.getAtomArrays().get(p2)[pos2].clone();\n                            Calc.transform(a, transform);\n                            Calc.transform(b, transform);\n                            list1.add(a);\n                            list2.add(b);\n                        }\n                    }\n                }\n            }\n            Atom[] arr1 = list1.toArray(new Atom[list1.size()]);\n            Atom[] arr2 = list2.toArray(new Atom[list2.size()]);\n            // Calculate the new transformation information\n            if (arr1.length > 0 && arr2.length > 0) {\n                Matrix4d axis = SuperPositions.superpose(Calc.atomsToPoints(arr1), Calc.atomsToPoints(arr2));\n                axes.updateAxis(level, axis);\n            }\n            // Get the transformations from the SymmetryAxes\n            List<Matrix4d> transformations = new ArrayList<Matrix4d>();\n            for (int su = 0; su < msa.size(); su++) {\n                transformations.add(axes.getRepeatTransform(su));\n            }\n            msa.getBlockSet(0).setTransformations(transformations);\n        }\n    } else {\n        MultipleSuperimposer imposer = new CoreSuperimposer();\n        imposer.superimpose(msa);\n    }\n    updateSymmetryScores(msa);\n}","repo_id":"9","comment":"/**\n * Calculates the set of symmetry operation Matrices (transformations) of\n * the new alignment, based on the symmetry relations in the SymmetryAxes\n * object. It sets the transformations to the input MultipleAlignment and\n * SymmetryAxes objects. If the SymmetryAxes object is null, the\n * superposition of the repeats is done without symmetry constraints.\n * <p>\n * This method also sets the scores (RMSD and TM-score) after the new\n * superposition has been updated.\n *\n * @param axes\n *            SymmetryAxes object. It will be modified.\n * @param msa\n *            MultipleAlignment. It will be modified.\n */\n","repo_name":"biojava-master/","id":2048,"method_signature":"void updateSymmetryTransformation(SymmetryAxes, MultipleAlignment)"}