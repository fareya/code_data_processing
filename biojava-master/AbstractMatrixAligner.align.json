{"callee_method_names":["GapPenalty.getType","List<Subproblem>.size","ArrayList.size","List<Subproblem>.size","List<Subproblem>.get","Subproblem.getQueryStartIndex","Subproblem.getQueryEndIndex","GapPenalty.getExtensionPenalty","GapPenalty.getOpenPenalty","GapPenalty.getExtensionPenalty","GapPenalty.getExtensionPenalty","GapPenalty.getOpenPenalty","GapPenalty.getExtensionPenalty"],"method_name":"AbstractMatrixAligner.align","method_implementation":"{\n    if (!isReady()) {\n        return;\n    }\n    long timeStart = System.nanoTime();\n    int[] dim = getScoreMatrixDimensions();\n    if (storingScoreMatrix) {\n        scores = new int[dim[0]][dim[1]][dim[2]];\n    } else {\n        scores = new int[dim[0]][][];\n        scores[0] = new int[dim[1]][dim[2]];\n        scores[1] = new int[dim[1]][dim[2]];\n    }\n    boolean linear = (gapPenalty.getType() == GapPenalty.Type.LINEAR);\n    Last[][][] traceback = new Last[dim[0]][][];\n    List<Step> sx = new ArrayList<Step>(), sy = new ArrayList<Step>();\n    if (!local) {\n        xyMax = new int[] { dim[0] - 1, dim[1] - 1 };\n        xyStart = new int[] { 0, 0 };\n        score = 0;\n        List<Subproblem> problems = Subproblem.getSubproblems(anchors, xyMax[0], xyMax[1]);\n        assert problems.size() == anchors.size() + 1;\n        for (int i = 0; i < problems.size(); i++) {\n            Subproblem subproblem = problems.get(i);\n            for (int x = subproblem.getQueryStartIndex(); x <= subproblem.getQueryEndIndex(); x++) {\n                traceback[x] = linear ? setScoreVector(x, subproblem, gapPenalty.getExtensionPenalty(), getSubstitutionScoreVector(x, subproblem), storingScoreMatrix, scores) : setScoreVector(x, subproblem, gapPenalty.getOpenPenalty(), gapPenalty.getExtensionPenalty(), getSubstitutionScoreVector(x, subproblem), storingScoreMatrix, scores);\n            }\n        }\n        setSteps(traceback, scores, sx, sy);\n        score = Integer.MIN_VALUE;\n        int[] finalScore = scores[xyMax[0]][xyMax[1]];\n        for (int z = 0; z < finalScore.length; z++) {\n            score = Math.max(score, finalScore[z]);\n        }\n    } else {\n        for (int x = 0; x < dim[0]; x++) {\n            traceback[x] = linear ? setScoreVector(x, gapPenalty.getExtensionPenalty(), getSubstitutionScoreVector(x), storingScoreMatrix, scores, xyMax, score) : setScoreVector(x, gapPenalty.getOpenPenalty(), gapPenalty.getExtensionPenalty(), getSubstitutionScoreVector(x), storingScoreMatrix, scores, xyMax, score);\n            if (xyMax[0] == x) {\n                score = scores[x][xyMax[1]][0];\n            }\n        }\n        xyStart = local ? setSteps(traceback, xyMax, sx, sy) : setSteps(traceback, scores, sx, sy);\n    }\n    setProfile(sx, sy);\n    if (!storingScoreMatrix) {\n        scores = null;\n    }\n    time = System.nanoTime() - timeStart;\n}","repo_id":"9","comment":"/**\n * Performs alignment\n */\n","repo_name":"biojava-master/","id":68,"method_signature":"void align()"}