{"callee_method_ids":[3106,3108],"callee_method_names":["GenbankSequenceParser<S, C>.getSequence","SequenceCreatorInterface<C>.getSequence","GenbankSequenceParser<S, C>.getSequenceHeaderParser","GenericGenbankHeaderParser<S, C>.parseHeader","GenbankSequenceParser<S, C>.getHeader","GenericGenbankHeaderParser<S, C>.getAccession","GenericGenbankHeaderParser<S, C>.getVersion","GenericGenbankHeaderParser<S, C>.getIdentifier","S.setAccession","GenbankSequenceParser<S, C>.getFeatures","GenbankSequenceParser<S, C>.getDatabaseReferences","List<DBReferenceInfo>.get","S.setTaxonomy","DBReferenceInfo.getDatabase","DBReferenceInfo.getId","LinkedHashMap<String, S>.put","S.getAccession"],"method_name":"GenbankReader.process","method_implementation":"{\n    if (closed) {\n        throw new IOException(\"Cannot perform action: resource has been closed.\");\n    }\n    LinkedHashMap<String, S> sequences = new LinkedHashMap<>();\n    int i = 0;\n    while (true) {\n        if (max > 0 && i >= max)\n            break;\n        i++;\n        String seqString = genbankParser.getSequence(bufferedReader, 0);\n        //reached end of file?\n        if (seqString == null)\n            break;\n        @SuppressWarnings(\"unchecked\")\n        S sequence = (S) sequenceCreator.getSequence(seqString, 0);\n        GenericGenbankHeaderParser<S, C> genbankHeaderParser = genbankParser.getSequenceHeaderParser();\n        genbankHeaderParser.parseHeader(genbankParser.getHeader(), sequence);\n        String id = genbankHeaderParser.getAccession();\n        int version = genbankHeaderParser.getVersion();\n        String identifier = genbankHeaderParser.getIdentifier();\n        AccessionID accession = new AccessionID(id, DataSource.GENBANK, version, identifier);\n        sequence.setAccession(accession);\n        // add features to new sequence\n        genbankParser.getFeatures().values().stream().flatMap(List::stream).forEach(sequence::addFeature);\n        // add taxonomy ID to new sequence\n        List<DBReferenceInfo> dbQualifier = genbankParser.getDatabaseReferences().get(\"db_xref\");\n        if (dbQualifier != null) {\n            DBReferenceInfo q = dbQualifier.get(0);\n            sequence.setTaxonomy(new TaxonomyID(q.getDatabase() + \":\" + q.getId(), DataSource.GENBANK));\n        }\n        sequences.put(sequence.getAccession().getID(), sequence);\n    }\n    return sequences;\n}","repo_id":"9","comment":"/**\n * This method tries to parse maximum <code>max<\/code> records from\n * the open File or InputStream, and leaves the underlying resource open.<br>\n *\n * Subsequent calls to the same method continue parsing the rest of the file.<br>\n * This is particularly useful when dealing with very big data files,\n * (e.g. NCBI nr database), which can't fit into memory and will take long\n * time before the first result is available.<br>\n * <b>N.B.<\/b>\n * <ul>\n * <li>This method can't be called after calling its NO-ARGUMENT twin.<\/li>\n * <li>remember to close the underlying resource when you are done.<\/li>\n * <\/ul>\n * @see #process()\n * @author Amr ALHOSSARY\n * @since 3.0.6\n * @param max maximum number of records to return.\n * @return {@link HashMap} containing maximum <code>max<\/code> parsed Genbank records\n * present, starting current fileIndex onwards.\n * @throws IOException\n * @throws CompoundNotFoundException\n */\n","repo_name":"biojava-master/","id":2729,"method_signature":"LinkedHashMap<String,S> process(int)"}