{"callee_method_ids":[491,487,487],"callee_method_names":["AFPChain.setName1","Atom[].getGroup","Atom[].getGroup","AFPChain.setName2","Atom[].getGroup","AFPChain.setBlockNum","AFPChain.setCa1Length","AFPChain.setCa2Length","AFPChain.setOptLength","AFPChain.setOptLen","AFPChain.getBlockNum","AFPChain.setBlockRotationMatrix","AFPChain.getBlockNum","AFPChain.setBlockShiftVector","ResidueNumber[].getChainName","ResidueNumber[].getChainName","AFPChain.setPdbAln"],"method_name":"AlignmentTools.createAFPChain","method_implementation":"{\n    //input validation\n    int alnLen = aligned1.length;\n    if (alnLen != aligned2.length) {\n        throw new IllegalArgumentException(\"Alignment lengths are not equal\");\n    }\n    AFPChain a = new AFPChain(AFPChain.UNKNOWN_ALGORITHM);\n    try {\n        a.setName1(ca1[0].getGroup().getChain().getStructure().getName());\n        if (ca2[0].getGroup().getChain().getStructure() != null) {\n            // common case for cloned ca2\n            a.setName2(ca2[0].getGroup().getChain().getStructure().getName());\n        }\n    } catch (Exception e) {\n        // One of the structures wasn't fully created. Ignore\n    }\n    a.setBlockNum(1);\n    a.setCa1Length(ca1.length);\n    a.setCa2Length(ca2.length);\n    a.setOptLength(alnLen);\n    a.setOptLen(new int[] { alnLen });\n    Matrix[] ms = new Matrix[a.getBlockNum()];\n    a.setBlockRotationMatrix(ms);\n    Atom[] blockShiftVector = new Atom[a.getBlockNum()];\n    a.setBlockShiftVector(blockShiftVector);\n    String[][][] pdbAln = new String[1][2][alnLen];\n    for (int i = 0; i < alnLen; i++) {\n        pdbAln[0][0][i] = aligned1[i].getChainName() + \":\" + aligned1[i];\n        pdbAln[0][1][i] = aligned2[i].getChainName() + \":\" + aligned2[i];\n    }\n    a.setPdbAln(pdbAln);\n    // convert pdbAln to optAln, and fill in some other basic parameters\n    AFPChainXMLParser.rebuildAFPChain(a, ca1, ca2);\n    return a;\n    // Currently a single block. Split into several blocks by sequence if needed\n    //\t\treturn AlignmentTools.splitBlocksByTopology(a,ca1,ca2);\n}","repo_id":"9","comment":"/**\n * Fundamentally, an alignment is just a list of aligned residues in each\n * protein. This method converts two lists of ResidueNumbers into an\n * AFPChain.\n *\n * <p>Parameters are filled with defaults (often null) or sometimes\n * calculated.\n *\n * <p>For a way to modify the alignment of an existing AFPChain, see\n * {@link AlignmentTools#replaceOptAln(AFPChain, Atom[], Atom[], Map)}\n * @param ca1 CA atoms of the first protein\n * @param ca2 CA atoms of the second protein\n * @param aligned1 A list of aligned residues from the first protein\n * @param aligned2 A list of aligned residues from the second protein.\n *  Must be the same length as aligned1.\n * @return An AFPChain representing the alignment. Many properties may be\n *  null or another default.\n * @throws StructureException if an error occured during superposition\n * @throws IllegalArgumentException if aligned1 and aligned2 have different\n *  lengths\n * @see AlignmentTools#replaceOptAln(AFPChain, Atom[], Atom[], Map)\n */\n","repo_name":"biojava-master/","id":589,"method_signature":"AFPChain createAFPChain(Atom[], Atom[], ResidueNumber[], ResidueNumber[])"}