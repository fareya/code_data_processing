{"callee_method_names":["List<Integer>.addAll","List<Integer>.addAll","List<List<Integer>>.get","List<List<Integer>>.add","List<Integer>.addAll","List<Integer>.addAll","List<List<Integer>>.get","List<List<Integer>>.add","Random.nextDouble","Logger.debug","Logger.debug","Logger.debug","Logger.debug","Random.nextDouble","List<List<Integer>>.get","Logger.debug","List<Integer>.addAll","List<Integer>.addAll","List<List<Integer>>.get","List<List<Integer>>.add","List<Long>.add","List<Integer>.add","List<Double>.add","MultipleAlignment.getScore","List<Double>.add","MultipleAlignment.getScore","List<Double>.add","MultipleAlignment.putScore","Logger.warn","MultipleAlignmentEnsemble.getMessage"],"method_name":"SymmOptimizer.optimize","method_implementation":"{\n    initialize();\n    // Save the optimal alignment\n    List<List<Integer>> optBlock = new ArrayList<List<Integer>>();\n    List<Integer> optFreePool = new ArrayList<Integer>();\n    optFreePool.addAll(freePool);\n    for (int k = 0; k < order; k++) {\n        List<Integer> b = new ArrayList<Integer>();\n        b.addAll(block.get(k));\n        optBlock.add(b);\n    }\n    double optScore = mcScore;\n    // Number of steps without an alignment improvement\n    int conv = 0;\n    int i = 1;\n    int stepsToConverge = Math.max(maxIter / 50, 1000);\n    long initialTime = System.nanoTime() / 1000000;\n    while (i < maxIter && conv < stepsToConverge) {\n        // Save the state of the system\n        List<List<Integer>> lastBlock = new ArrayList<List<Integer>>();\n        List<Integer> lastFreePool = new ArrayList<Integer>();\n        lastFreePool.addAll(freePool);\n        for (int k = 0; k < order; k++) {\n            List<Integer> b = new ArrayList<Integer>();\n            b.addAll(block.get(k));\n            lastBlock.add(b);\n        }\n        double lastScore = mcScore;\n        int lastRepeatCore = repeatCore;\n        boolean moved = false;\n        while (!moved) {\n            // Randomly select one of the steps to modify the alignment.\n            // Because of biased moves, the probabilities are not the same\n            double move = rnd.nextDouble();\n            if (move < 0.4) {\n                moved = shiftRow();\n                logger.debug(\"did shift\");\n            } else if (move < 0.7) {\n                moved = expandBlock();\n                logger.debug(\"did expand\");\n            } else if (move < 0.85) {\n                moved = shrinkBlock();\n                logger.debug(\"did shrink\");\n            } else {\n                moved = insertGap();\n                logger.debug(\"did insert gap\");\n            }\n        }\n        // Get the properties of the new alignment\n        updateMultipleAlignment();\n        mcScore = MultipleAlignmentScorer.getMCScore(msa, Gopen, Gextend, dCutoff);\n        // Calculate change in the optimization Score\n        double AS = mcScore - lastScore;\n        double prob = 1.0;\n        if (AS < 0) {\n            // Probability of accepting bad move\n            prob = probabilityFunction(AS, i, maxIter);\n            double p = rnd.nextDouble();\n            // Reject the move\n            if (p > prob) {\n                block = lastBlock;\n                freePool = lastFreePool;\n                length = block.get(0).size();\n                repeatCore = lastRepeatCore;\n                mcScore = lastScore;\n                // no change in score if rejected\n                conv++;\n            } else\n                // if accepted\n                conv = 0;\n        } else\n            // if positive change\n            conv = 0;\n        logger.debug(i + \": --prob: \" + prob + \", --score: \" + AS + \", --conv: \" + conv);\n        // Store as the optimal alignment if better\n        if (mcScore > optScore) {\n            optBlock = new ArrayList<List<Integer>>();\n            optFreePool = new ArrayList<Integer>();\n            optFreePool.addAll(freePool);\n            for (int k = 0; k < order; k++) {\n                List<Integer> b = new ArrayList<Integer>();\n                b.addAll(block.get(k));\n                optBlock.add(b);\n            }\n            optScore = mcScore;\n        }\n        if (history) {\n            if (i % saveStep == 1) {\n                // Get the correct superposition again\n                updateMultipleAlignment();\n                timeHistory.add(System.nanoTime() / 1000000 - initialTime);\n                lengthHistory.add(length);\n                rmsdHistory.add(msa.getScore(MultipleAlignmentScorer.RMSD));\n                tmScoreHistory.add(msa.getScore(MultipleAlignmentScorer.AVGTM_SCORE));\n                mcScoreHistory.add(mcScore);\n            }\n        }\n        i++;\n    }\n    // Use the optimal alignment of the trajectory\n    block = optBlock;\n    freePool = optFreePool;\n    mcScore = optScore;\n    // Superimpose and calculate final scores\n    updateMultipleAlignment();\n    msa.putScore(MultipleAlignmentScorer.MC_SCORE, mcScore);\n    // Save the history to the results folder of the symmetry project\n    if (history) {\n        try {\n            saveHistory(pathToHistory);\n        } catch (Exception e) {\n            logger.warn(\"Could not save history file: \" + e.getMessage());\n        }\n    }\n    return msa;\n}","repo_id":"9","comment":"/**\n * Optimization method based in a Monte-Carlo approach. Starting from the\n * refined alignment uses 4 types of moves:\n * <p>\n * <li>1- Shift Row: if there are enough freePool residues available.\n * <li>2- Expand Block: add another alignment column.\n * <li>3- Shrink Block: move a block column to the freePool.\n * <li>4- Insert gap: insert a gap in a position of the alignment.\n *\n * @throws StructureException\n * @throws RefinerFailedException\n *             if the alignment is not symmetric or too short.\n */\n","repo_name":"biojava-master/","id":2075,"method_signature":"MultipleAlignment optimize()"}