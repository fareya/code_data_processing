{"callee_method_names":["MultipleAlignment.getEnsemble","MultipleAlignment.getAtomArrays","List<Atom[]>.size","List<Atom[]>.size","List<Atom[]>.get","MultipleAlignment.length","MultipleAlignment.getBlockSets","List<Atom[]>.size","List<Atom[]>.size","Atom[].clone","MultipleAlignment.length","List<Atom[]>.add"],"method_name":"MultipleAlignmentTools.transformAtoms","method_implementation":"{\n    if (alignment.getEnsemble() == null) {\n        throw new NullPointerException(\"No ensemble set for this alignment\");\n    }\n    List<Atom[]> atomArrays = alignment.getAtomArrays();\n    List<Atom[]> transformed = new ArrayList<Atom[]>(atomArrays.size());\n    // Loop through structures\n    for (int i = 0; i < atomArrays.size(); i++) {\n        Matrix4d transform = null;\n        // all CA atoms from structure\n        Atom[] curr = atomArrays.get(i);\n        // Concatenated list of all blocks for this structure\n        Atom[] transformedAtoms = new Atom[alignment.length()];\n        int transformedAtomsLength = 0;\n        // Each blockset gets transformed independently\n        for (BlockSet bs : alignment.getBlockSets()) {\n            Atom[] blocksetAtoms = new Atom[bs.length()];\n            int blockPos = 0;\n            for (Block blk : bs.getBlocks()) {\n                if (blk.size() != atomArrays.size()) {\n                    throw new IllegalStateException(String.format(\"Mismatched block size. Expected %d \" + \"structures, found %d.\", atomArrays.size(), blk.size()));\n                }\n                // Extract aligned atoms\n                for (int j = 0; j < blk.length(); j++) {\n                    Integer alignedPos = blk.getAlignRes().get(i).get(j);\n                    if (alignedPos != null) {\n                        blocksetAtoms[blockPos] = (Atom) curr[alignedPos].clone();\n                    }\n                    blockPos++;\n                }\n            }\n            // Transform according to the blockset or alignment matrix\n            Matrix4d blockTrans = null;\n            if (bs.getTransformations() != null)\n                blockTrans = bs.getTransformations().get(i);\n            if (blockTrans == null) {\n                blockTrans = transform;\n            }\n            for (Atom a : blocksetAtoms) {\n                if (a != null)\n                    Calc.transform(a, blockTrans);\n                transformedAtoms[transformedAtomsLength] = a;\n                transformedAtomsLength++;\n            }\n        }\n        assert (transformedAtomsLength == alignment.length());\n        transformed.add(transformedAtoms);\n    }\n    return transformed;\n}","repo_id":"9","comment":"/**\n * Transforms atoms according to the superposition stored in the alignment.\n * <p>\n * For each structure in the alignment, returns an atom for each\n * representative atom in the aligned columns, omitting unaligned residues\n * (i.e. an array of length <tt>alignment.length()<\/tt> ).\n * <p>\n * All blocks are concatenated together, so Atoms may not appear in the same\n * order as in their parent structure. If the alignment blocks contain null\n * residues (gaps), then the returned array will also contain null Atoms in\n * the same positions.\n *\n * @param alignment\n *            MultipleAlignment\n * @return List of Atom arrays of only the aligned atoms of every structure\n *         (null Atom if a gap position)\n */\n","repo_name":"biojava-master/","id":661,"method_signature":"List<Atom[]> transformAtoms(MultipleAlignment)"}