{"callee_method_names":["List<Subunit>.size","List<Subunit>.get","List<Subunit>.get","List<Subunit>.get","List<Integer>.add","List<Subunit>.get","List<Integer>.size","List<Integer>.size","List<Integer>.size","List<Integer>.get","List<Integer>.size","List<Integer>.get","List<Integer>.get"],"method_name":"SubunitExtractor.calcAdjustedMinimumSequenceLength","method_implementation":"{\n    int maxLength = Integer.MIN_VALUE;\n    int minLength = Integer.MAX_VALUE;\n    // Extract the length List, the min and the max\n    List<Integer> lengths = new ArrayList<Integer>();\n    for (int i = 0; i < subunits.size(); i++) {\n        if (subunits.get(i).size() >= absMinLen) {\n            maxLength = Math.max(subunits.get(i).size(), maxLength);\n            minLength = Math.min(subunits.get(i).size(), minLength);\n            lengths.add(subunits.get(i).size());\n        }\n    }\n    int adjustedMinimumSequenceLength = minLen;\n    if (lengths.size() < 2)\n        return adjustedMinimumSequenceLength;\n    // Calculate the median of the lengths\n    double median = 0;\n    Collections.sort(lengths);\n    if (lengths.size() % 2 == 1) {\n        int middle = (lengths.size() - 1) / 2;\n        median = lengths.get(middle);\n    } else {\n        int middle2 = lengths.size() / 2;\n        int middle1 = middle2 - 1;\n        median = 0.5 * (lengths.get(middle1) + lengths.get(middle2));\n    }\n    // If the median * fraction is lower than the minLength\n    if (minLength >= median * fraction) {\n        adjustedMinimumSequenceLength = Math.min(minLength, minLen);\n    }\n    return adjustedMinimumSequenceLength;\n}","repo_id":"9","comment":"/**\n * Returns an adapted minimum sequence length. This method ensure that\n * structure that only have short chains are not excluded by the\n * minimumSequenceLength cutoff value.\n *\n * @return adjustedMinimumSequenceLength\n */\n","repo_name":"biojava-master/","id":1654,"method_signature":"int calcAdjustedMinimumSequenceLength(List, int, double, int)"}