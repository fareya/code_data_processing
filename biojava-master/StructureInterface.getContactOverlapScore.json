{"callee_method_ids":[894,919],"callee_method_names":["StructureInterface.getParentChains","Pair<Chain>.getFirst","Pair<Chain>.getSecond","Pair<Chain>.getFirst","Pair<Chain>.getSecond","Logger.warn","StructureInterface.getId","Pair<Chain>.getFirst","Pair<Chain>.getSecond","Pair<Chain>.getFirst","Pair<Chain>.getSecond","StructureInterface.getGroupContacts","GroupContactSet.hasContact","GroupContactSet.size","GroupContactSet.size","Logger.debug","Pair<Chain>.getFirst","Pair<Chain>.getSecond","Pair<Chain>.getFirst","Pair<Chain>.getSecond"],"method_name":"StructureInterface.getContactOverlapScore","method_implementation":"{\n    Pair<Chain> thisChains = getParentChains();\n    Pair<Chain> otherChains = other.getParentChains();\n    if (thisChains.getFirst().getEntityInfo() == null || thisChains.getSecond().getEntityInfo() == null || otherChains.getFirst().getEntityInfo() == null || otherChains.getSecond().getEntityInfo() == null) {\n        // this happens in cases like 2uub\n        logger.warn(\"Found chains with null compounds while comparing interfaces {} and {}. Contact overlap score for them will be 0.\", this.getId(), other.getId());\n        return 0;\n    }\n    Pair<EntityInfo> thisCompounds = new Pair<EntityInfo>(thisChains.getFirst().getEntityInfo(), thisChains.getSecond().getEntityInfo());\n    Pair<EntityInfo> otherCompounds = new Pair<EntityInfo>(otherChains.getFirst().getEntityInfo(), otherChains.getSecond().getEntityInfo());\n    if (checkMolIdMatch(thisCompounds, otherCompounds)) {\n        int common = 0;\n        GroupContactSet thisContacts = getGroupContacts();\n        GroupContactSet otherContacts = other.getGroupContacts();\n        for (GroupContact thisContact : thisContacts) {\n            ResidueIdentifier first;\n            ResidueIdentifier second;\n            if (!invert) {\n                first = new ResidueIdentifier(thisContact.getPair().getFirst());\n                second = new ResidueIdentifier(thisContact.getPair().getSecond());\n            } else {\n                first = new ResidueIdentifier(thisContact.getPair().getSecond());\n                second = new ResidueIdentifier(thisContact.getPair().getFirst());\n            }\n            if (otherContacts.hasContact(first, second)) {\n                common++;\n            }\n        }\n        return (2.0 * common) / (thisContacts.size() + otherContacts.size());\n    } else {\n        logger.debug(\"Chain pairs {},{} and {},{} belong to different compound pairs, contact overlap score will be 0 \", thisChains.getFirst().getId(), thisChains.getSecond().getId(), otherChains.getFirst().getId(), otherChains.getSecond().getId());\n        return 0.0;\n    }\n}","repo_id":"9","comment":"/**\n * Calculates the Jaccard contact set score (intersection over union) between this StructureInterface and\n * the given one. The calculation assumes that both interfaces come from the same structure. The output\n * will not necessarily make sense if the two interfaces come from different structures.\n * The two sides of the given StructureInterface need to match this StructureInterface\n * in the sense that they must come from the same Entity, i.e.\n * their residue numbers need to align with 100% identity, except for unobserved\n * density residues. The SEQRES indices obtained through {@link EntityInfo#getAlignedResIndex(Group, Chain)} are\n * used to match residues, thus if no SEQRES is present or if {@link FileParsingParameters#setAlignSeqRes(boolean)}\n * is not used, this calculation is not guaranteed to work properly.\n * @param other the interface to be compared to this one\n * @param invert if false the comparison will be done first-to-first and second-to-second,\n * if true the match will be first-to-second and second-to-first\n * @return the contact overlap score, range [0.0,1.0]\n */\n","repo_name":"biojava-master/","id":891,"method_signature":"double getContactOverlapScore(StructureInterface, boolean)"}