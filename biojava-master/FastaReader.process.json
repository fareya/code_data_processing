{"callee_method_ids":[2709,2716],"callee_method_names":["String.trim","String.length","String.startsWith","StringBuilder.length","SequenceCreatorInterface<C>.getSequence","StringBuilder.toString","SequenceHeaderParserInterface<S, C>.parseHeader","LinkedHashMap<String, S>.put","S.getAccession","Logger.warn","Enumeration<JarEntry>.getMessage","StringBuilder.setLength","String.substring","String.startsWith","StringBuilder.length","StringBuilder.append","BufferedReaderBytesRead.getBytesRead","BufferedReaderBytesRead.readLine","StringBuilder.length","String.length","Logger.warn","Logger.warn","StringBuilder.length","SequenceCreatorInterface<C>.getSequence","StringBuilder.toString","SequenceHeaderParserInterface<S, C>.parseHeader","LinkedHashMap<String, S>.put","S.getAccession","Logger.warn","Enumeration<JarEntry>.getMessage","LinkedHashMap<String, S>.isEmpty"],"method_name":"FastaReader.process","method_implementation":"{\n    String line = \"\";\n    if (this.line != null && this.line.length() > 0) {\n        line = this.line;\n    }\n    String header = \"\";\n    if (this.header != null && this.header.length() > 0) {\n        header = this.header;\n    }\n    StringBuilder sb = new StringBuilder();\n    int processedSequences = 0;\n    boolean keepGoing = true;\n    LinkedHashMap<String, S> sequences = new LinkedHashMap<String, S>();\n    do {\n        // nice to have but probably not needed\n        line = line.trim();\n        if (line.length() != 0) {\n            if (line.startsWith(\">\")) {\n                //start of new fasta record\n                if (sb.length() > 0) {\n                    //i.e. if there is already a sequence before\n                    //logger.info(\"Sequence index=\" + sequenceIndex);\n                    try {\n                        @SuppressWarnings(\"unchecked\")\n                        S sequence = (S) sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n                        headerParser.parseHeader(header, sequence);\n                        sequences.put(sequence.getAccession().getID(), sequence);\n                        processedSequences++;\n                    } catch (CompoundNotFoundException e) {\n                        logger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\", header, e.getMessage());\n                    }\n                    //this is faster than allocating new buffers, better memory utilization (same buffer)\n                    sb.setLength(0);\n                }\n                header = line.substring(1);\n            } else if (line.startsWith(\";\")) {\n            } else {\n                //mark the start of the sequence with the fileIndex before the line was read\n                if (sb.length() == 0) {\n                    sequenceIndex = fileIndex;\n                }\n                sb.append(line);\n            }\n        }\n        fileIndex = br.getBytesRead();\n        line = br.readLine();\n        if (line == null) {\n            //i.e. EOF\n            if (sb.length() == 0 && header.length() != 0) {\n                logger.warn(\"Can't parse sequence {}. Got sequence of length 0!\", sequenceIndex);\n                logger.warn(\"header: {}\", header);\n                header = null;\n            } else if (sb.length() > 0) {\n                //logger.info(\"Sequence index=\" + sequenceIndex + \" \" + fileIndex );\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    S sequence = (S) sequenceCreator.getSequence(sb.toString(), sequenceIndex);\n                    headerParser.parseHeader(header, sequence);\n                    sequences.put(sequence.getAccession().getID(), sequence);\n                    processedSequences++;\n                    header = null;\n                } catch (CompoundNotFoundException e) {\n                    logger.warn(\"Sequence with header '{}' has unrecognised compounds ({}), it will be ignored\", header, e.getMessage());\n                }\n            }\n            keepGoing = false;\n        }\n        if (max > -1 && processedSequences >= max) {\n            keepGoing = false;\n        }\n    } while (keepGoing);\n    this.line = line;\n    this.header = header;\n    return max > -1 && sequences.isEmpty() ? null : sequences;\n}","repo_id":"9","comment":"/**\n * This method tries to parse maximum <code>max<\/code> records from\n * the open File or InputStream, and leaves the underlying resource open.<br>\n * Subsequent calls to the same method continue parsing the rest of the file.<br>\n * This is particularly useful when dealing with very big data files,\n * (e.g. NCBI nr database), which can't fit into memory and will take long\n * time before the first result is available.<br>\n * <b>N.B.<\/b>\n * <ul>\n * <li>This method can't be called after calling its NO-ARGUMENT twin.<\/li>\n * <li>remember to close the underlying resource when you are done.<\/li>\n * <\/ul>\n * @see #process()\n * @author Amr ALHOSSARY\n * @since 3.0.6\n * @param max maximum number of records to return, <code>-1<\/code> for infinity.\n * @return {@link HashMap} containing maximum <code>max<\/code> parsed fasta records\n * present, starting current fileIndex onwards.\n * @throws IOException if an error occurs reading the input file\n */\n","repo_name":"biojava-master/","id":2769,"method_signature":"LinkedHashMap<String,S> process(int)"}