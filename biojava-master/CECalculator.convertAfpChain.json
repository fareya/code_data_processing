{"callee_method_names":["AFPChain.setBlockNum","AFPChain.setBlockRotationMatrix","AFPChain.setBlockShiftVector","AFPChain.setDisTable1","AFPChain.setDisTable1","AFPChain.setDisTable2","AFPChain.setDisTable2","AFPChain.setOptAln","Atom[].getGroup","Atom[].getGroup","Atom[].getGroup","Atom[].getGroup","AFPChain.setAlnseq1","AFPChain.setAlnseq2","AFPChain.setAlnsymb","AFPChain.setIdentity","AFPChain.setSimilarity","AFPChain.setIdentity","AFPChain.setSimilarity"],"method_name":"CECalculator.convertAfpChain","method_implementation":"{\n    afpChain.setBlockNum(1);\n    //afpChain.setAlignScore(z);\n    Matrix[] m;\n    if (r != null) {\n        m = new Matrix[1];\n        m[0] = r;\n    } else {\n        m = new Matrix[0];\n    }\n    Atom[] as;\n    if (t != null) {\n        as = new Atom[1];\n        as[0] = t;\n    } else {\n        as = new Atom[0];\n    }\n    afpChain.setBlockRotationMatrix(m);\n    afpChain.setBlockShiftVector(as);\n    int nse1 = ca1.length;\n    int nse2 = ca2.length;\n    //System.out.println(\"dist1 :\" + dist1.length + \" \" + dist2.length);\n    if (nse1 > 0 && dist1.length > 0)\n        afpChain.setDisTable1(new Matrix(dist1));\n    else\n        afpChain.setDisTable1(Matrix.identity(3, 3));\n    if (nse2 > 0 && dist2.length > 0)\n        afpChain.setDisTable2(new Matrix(dist2));\n    else\n        afpChain.setDisTable2(Matrix.identity(3, 3));\n    char[] alnseq1 = new char[nse1 + nse2 + 1];\n    char[] alnseq2 = new char[nse1 + nse2 + 1];\n    char[] alnsymb = new char[nse1 + nse2 + 1];\n    int[][][] optAln = new int[1][2][nAtom];\n    afpChain.setOptAln(optAln);\n    int pos = 0;\n    int nrIdent = 0;\n    int nrSim = 0;\n    for (int ia = 0; ia < lcmp; ia++) {\n        // no gap\n        if (align_se1[ia] != -1 && align_se2[ia] != -1) {\n            //System.out.println(\"ia \" + ia + \" pos \" + pos + \" \"  + align_se1[ia] + \" \" + align_se2[ia]);\n            optAln[0][0][pos] = align_se1[ia];\n            optAln[0][1][pos] = align_se2[ia];\n            char l1 = getOneLetter(ca1[align_se1[ia]].getGroup());\n            char l2 = getOneLetter(ca2[align_se2[ia]].getGroup());\n            alnseq1[ia] = Character.toUpperCase(l1);\n            alnseq2[ia] = Character.toUpperCase(l2);\n            alnsymb[ia] = ' ';\n            if (l1 == l2) {\n                nrIdent++;\n                nrSim++;\n                alnsymb[ia] = '|';\n            } else if (AFPAlignmentDisplay.aaScore(l1, l2) > 0) {\n                nrSim++;\n                alnsymb[ia] = ':';\n            }\n            pos++;\n        } else {\n            // there is a gap at this position\n            alnsymb[ia] = ' ';\n            if (align_se1[ia] == -1) {\n                alnseq1[ia] = '-';\n            } else {\n                char l1 = getOneLetter(ca1[align_se1[ia]].getGroup());\n                alnseq1[ia] = Character.toUpperCase(l1);\n            }\n            if (align_se2[ia] == -1) {\n                alnseq2[ia] = '-';\n            } else {\n                char l2 = getOneLetter(ca2[align_se2[ia]].getGroup());\n                alnseq2[ia] = Character.toUpperCase(l2);\n            }\n        }\n    }\n    afpChain.setAlnseq1(alnseq1);\n    afpChain.setAlnseq2(alnseq2);\n    afpChain.setAlnsymb(alnsymb);\n    // CE uses the aligned pairs as reference not the whole alignment including gaps...\n    if (pos > 0) {\n        afpChain.setIdentity(nrIdent * 1.0 / pos);\n        afpChain.setSimilarity(nrSim * 1.0 / pos);\n    } else {\n        afpChain.setIdentity(0);\n        afpChain.setSimilarity(0);\n    }\n    //AFPAlignmentDisplay.getAlign( afpChain,ca1,ca2);\n}","repo_id":"9","comment":"/**\n * copy data from this class into AFPChain container object.\n *\n * @param afpChain\n * @param ca1\n * @param ca2\n */\n","repo_name":"biojava-master/","id":725,"method_signature":"void convertAfpChain(AFPChain, Atom[], Atom[])"}