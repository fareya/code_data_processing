{"callee_method_names":["Map<S,T>.keySet","List<S>.size","List<S>.get","Map<S,T>.get","Map<T,S>.get","List<S>.set","Map<S,T>.size","List<S>.size","List<S>.get","List<S>.get","Map<S,T>.get","Map<S, T>.put"],"method_name":"AlignmentTools.applyAlignment","method_implementation":"{\n    // This implementation simply applies the map k times.\n    // If k were large, it would be more efficient to do this recursively,\n    // (eg f^4 = (f^2)^2) but k will usually be small.\n    if (k < 0)\n        throw new IllegalArgumentException(\"k must be positive\");\n    if (k == 1) {\n        return new HashMap<S, T>(alignmentMap);\n    }\n    // Convert to lists to establish a fixed order\n    // currently unmodified\n    List<S> preimage = new ArrayList<S>(alignmentMap.keySet());\n    List<S> image = new ArrayList<S>(preimage);\n    for (int n = 1; n < k; n++) {\n        // apply alignment\n        for (int i = 0; i < image.size(); i++) {\n            S pre = image.get(i);\n            T intermediate = (pre == null ? null : alignmentMap.get(pre));\n            S post = (intermediate == null ? null : identity.get(intermediate));\n            image.set(i, post);\n        }\n    }\n    Map<S, T> imageMap = new HashMap<S, T>(alignmentMap.size());\n    //TODO handle nulls consistently.\n    // assure that all the residues in the domain are valid keys\n    /*\n\t\tfor(int i=0;i<preimage.size();i++) {\n\t\t\tS pre = preimage.get(i);\n\t\t\tT intermediate = (pre==null?null: alignmentMap.get(pre));\n\t\t\tS post = (intermediate==null?null: identity.get(intermediate));\n\t\t\timageMap.put(post, null);\n\t\t}\n\t\t */\n    // now populate with actual values\n    for (int i = 0; i < preimage.size(); i++) {\n        S pre = preimage.get(i);\n        // image is currently f^k-1(x), so take the final step\n        S preK1 = image.get(i);\n        T postK = (preK1 == null ? null : alignmentMap.get(preK1));\n        imageMap.put(pre, postK);\n    }\n    return imageMap;\n}","repo_id":"9","comment":"/**\n * Applies an alignment k times. Eg if alignmentMap defines function f(x),\n * this returns a function f^k(x)=f(f(...f(x)...)).\n *\n * To allow for functions with different domains and codomains, the identity\n * function allows converting back in a reasonable way. For instance, if\n * alignmentMap represented an alignment between two proteins with different\n * numbering schemes, the identity function could calculate the offset\n * between residue numbers, eg I(x) = x-offset.\n *\n * When an identity function is provided, the returned function calculates\n * f^k(x) = f(I( f(I( ... f(x) ... )) )).\n *\n * @param <S>\n * @param <T>\n * @param alignmentMap The input function, as a map (see {@link AlignmentTools#alignmentAsMap(AFPChain)})\n * @param identity An identity-like function providing the isomorphism between\n *  the codomain of alignmentMap (of type <T>) and the domain (type <S>).\n * @param k The number of times to apply the alignment\n * @return A new alignment. If the input function is not automorphic\n *  (one-to-one), then some inputs may map to null, indicating that the\n *  function is undefined for that input.\n */\n","repo_name":"biojava-master/","id":581,"method_signature":"Map<S,T> applyAlignment(Map, Map, int)"}