{"callee_method_names":["Matrix.get","Matrix.get","Matrix.get","Matrix.get","Matrix.get","Matrix.get","Matrix.get","Matrix.get","Matrix.get","Matrix.get","Matrix.get","Matrix.get","Matrix.get","Atom.setCoords"],"method_name":"RotationAxis.calculateRotationalAxis","method_implementation":"{\n    // Calculate magnitude of rotationAxis components, but not signs\n    double sum = 0;\n    double[] rotAx = new double[3];\n    for (int i = 0; i < 3; i++) {\n        rotAx[i] = Math.sqrt(rotation.get(i, i) - c);\n        sum += rotAx[i] * rotAx[i];\n    }\n    for (int i = 0; i < 3; i++) {\n        rotAx[i] /= Math.sqrt(sum);\n    }\n    // Now determine signs\n    //=2u[0]*sin(theta)\n    double d0 = rotation.get(2, 1) - rotation.get(1, 2);\n    //=2u[1]*sin(theta)\n    double d1 = rotation.get(0, 2) - rotation.get(2, 0);\n    //=2u[2]*sin(theta)\n    double d2 = rotation.get(1, 0) - rotation.get(0, 1);\n    //=2*u[1]*u[2]*(1-cos(theta))\n    double s12 = rotation.get(2, 1) + rotation.get(1, 2);\n    //=2*u[0]*u[2]*(1-cos(theta))\n    double s02 = rotation.get(0, 2) + rotation.get(2, 0);\n    //=2*u[0]*u[1]*(1-cos(theta))\n    double s01 = rotation.get(1, 0) + rotation.get(0, 1);\n    //Only use biggest d for the sign directly, for numerical stability around 180deg\n    if (Math.abs(d0) < Math.abs(d1)) {\n        // not d0\n        if (Math.abs(d1) < Math.abs(d2)) {\n            //d2\n            if (d2 >= 0) {\n                //u[2] positive\n                if (s02 < 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 < 0)\n                    rotAx[1] = -rotAx[1];\n            } else {\n                //u[2] negative\n                rotAx[2] = -rotAx[2];\n                if (s02 >= 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 >= 0)\n                    rotAx[1] = -rotAx[1];\n            }\n        } else {\n            //d1\n            if (d1 >= 0) {\n                //u[1] positive\n                if (s01 < 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 < 0)\n                    rotAx[2] = -rotAx[2];\n            } else {\n                //u[1] negative\n                rotAx[1] = -rotAx[1];\n                if (s01 >= 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 >= 0)\n                    rotAx[2] = -rotAx[2];\n            }\n        }\n    } else {\n        // not d1\n        if (Math.abs(d0) < Math.abs(d2)) {\n            //d2\n            if (d2 >= 0) {\n                //u[2] positive\n                if (s02 < 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 < 0)\n                    rotAx[1] = -rotAx[1];\n            } else {\n                //u[2] negative\n                rotAx[2] = -rotAx[2];\n                if (s02 >= 0)\n                    rotAx[0] = -rotAx[0];\n                if (s12 >= 0)\n                    rotAx[1] = -rotAx[1];\n            }\n        } else {\n            //d0\n            if (d0 >= 0) {\n                //u[0] positive\n                if (s01 < 0)\n                    rotAx[1] = -rotAx[1];\n                if (s02 < 0)\n                    rotAx[2] = -rotAx[2];\n            } else {\n                //u[0] negative\n                rotAx[0] = -rotAx[0];\n                if (s01 >= 0)\n                    rotAx[1] = -rotAx[1];\n                if (s02 >= 0)\n                    rotAx[2] = -rotAx[2];\n            }\n        }\n    }\n    rotationAxis = new AtomImpl();\n    rotationAxis.setCoords(rotAx);\n    // Calculate screw = (rotationAxis dot translation)*u\n    double dotProduct = Calc.scalarProduct(rotationAxis, translation);\n    screwTranslation = Calc.scale(rotationAxis, dotProduct);\n    otherTranslation = Calc.subtract(translation, screwTranslation);\n    Atom hypot = Calc.vectorProduct(otherTranslation, rotationAxis);\n    Calc.scaleEquals(hypot, .5 / Math.tan(theta / 2.0));\n    // Calculate rotation axis position\n    rotationPos = Calc.scaleAdd(.5, otherTranslation, hypot);\n}","repo_id":"9","comment":"/**\n * Calculate the rotation axis for the normal case, where there is a\n * significant rotation angle\n * @param rotation\n * @param translation\n * @param c\n */\n","repo_name":"biojava-master/","id":566,"method_signature":"void calculateRotationalAxis(Matrix, Atom, double)"}