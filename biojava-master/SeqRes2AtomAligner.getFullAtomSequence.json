{"callee_method_names":["List<Group>.size","List<Group>.get","Atom.getAminoType","Map<Integer,Integer>.put","StringBuffer.append","Group.isWater","Group.size","Group.getAtom","Atom.getElement","Group.getChemComp","Logger.debug","Group.toString","ChemComp.getResidueType","ChemComp.getPolymerType","ChemComp.getPolymerType","ChemComp.getOneLetterCode","ChemComp.getPolymerType","String.length","Logger.info","Group.toString","String.length","Map<Integer,Integer>.put","StringBuffer.append","String.charAt","Logger.debug","Group.toString","StringBuffer.toString"],"method_name":"SeqRes2AtomAligner.getFullAtomSequence","method_implementation":"{\n    StringBuffer sequence = new StringBuffer();\n    // track sequence.length()\n    int seqIndex = 0;\n    for (int i = 0; i < groups.size(); i++) {\n        Group g = groups.get(i);\n        if (g instanceof AminoAcid) {\n            AminoAcid a = (AminoAcid) g;\n            char oneLetter = a.getAminoType();\n            if (oneLetter == '?')\n                oneLetter = 'X';\n            positionIndex.put(seqIndex, i);\n            sequence.append(oneLetter);\n            seqIndex++;\n        } else {\n            // exclude solvents\n            if (g.isWater())\n                continue;\n            // exclude metals\n            if (g.size() == 1) {\n                Atom a = g.getAtom(0);\n                if (a == null)\n                    continue;\n                if (a.getElement().isMetal())\n                    continue;\n            }\n            ChemComp cc = g.getChemComp();\n            if (cc == null) {\n                logger.debug(\"No chem comp available for group {}\", g.toString());\n                // not sure what to do in that case!\n                continue;\n            }\n            if (ResidueType.lPeptideLinking.equals(cc.getResidueType()) || PolymerType.PROTEIN_ONLY.contains(cc.getPolymerType()) || PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {\n                //System.out.println(cc.getOne_letter_code());\n                String c = cc.getOneLetterCode();\n                if (\"?\".equals(c)) {\n                    if (isNucleotideChain && PolymerType.POLYNUCLEOTIDE_ONLY.contains(cc.getPolymerType())) {\n                        // the way to represent unknown nucleotides is with 'N', see https://en.wikipedia.org/wiki/Nucleic_acid_notation\n                        c = \"N\";\n                    } else {\n                        c = \"X\";\n                    }\n                }\n                // For some unusual cases the het residue can map to 2 or more standard aas and thus give an\n                // insertion of length >1.\n                //      e.g. 1: SUI maps to DG  (in 1oew,A)\n                //\t\te.g. 2: NRQ maps to MYG (in 3cfh,A)\n                if (c.length() > 1) {\n                    logger.info(\"Group '{}' maps to more than 1 standard aminoacid: {}.\", g.toString(), c);\n                }\n                // because of the mapping to more than 1 aminoacid, we have\n                // to loop through it (99% of cases c will have length 1 anyway)\n                for (int cIdx = 0; cIdx < c.length(); cIdx++) {\n                    positionIndex.put(seqIndex, i);\n                    sequence.append(c.charAt(cIdx));\n                    seqIndex++;\n                }\n            } else {\n                logger.debug(\"Group {} is not lPeptideLinked, nor PROTEIN_ONLY, nor POLYNUCLEOTIDE_ONLY\", g.toString());\n                continue;\n            }\n            //sequence.append(\"X\");\n        }\n    }\n    return sequence.toString();\n}","repo_id":"9","comment":"/**\n * Returns the full sequence of the Atom records of a parent\n * with X instead of HETATMSs. The advantage of this is\n * that it allows us to also align HETATM groups back to the SEQRES.\n * @param groups the list of groups in a parent\n * @param positionIndex a Map to keep track of which group is at which sequence position\n * @param isNucleotideChain whether the atom groups are predominantly nucleotides (the groups represent a nucleotide chain), if true\n * non-standard nucleotides will be represented with ambiguous letter 'N' instead of 'X', if false all non-standard residues will be 'X'\n * @return string representations\n */\n","repo_name":"biojava-master/","id":1234,"method_signature":"String getFullAtomSequence(List, Map, boolean)"}