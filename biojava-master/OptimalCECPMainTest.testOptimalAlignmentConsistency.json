{"callee_method_ids":[619,619,790,781,619,784,781],"callee_method_names":["AtomCache.getAtoms","AtomCache.getAtoms","OptimalCECPMain.alignOptimal","OptimalCECPMain.getParameters","AtomCache.getAtoms","OptimalCECPMain.alignPermuted","OptimalCECPMain.getParameters"],"method_name":"OptimalCECPMainTest.testOptimalAlignmentConsistency","method_implementation":"{\n    String name1, name2;\n    OptimalCECPMain ce;\n    AFPChain afpChain;\n    //CP points to check for consistency\n    int[] cps;\n    //small case\n    name1 = \"d1qdmA1\";\n    name2 = \"d1nklA_\";\n    cps = new int[] { 0, 1, 2, 41, 5, 38 };\n    Atom[] ca1 = cache.getAtoms(name1);\n    Atom[] ca2 = cache.getAtoms(name2);\n    // Calculate all alignments initially\n    ce = new OptimalCECPMain();\n    AFPChain[] alignments = new AFPChain[ca2.length];\n    ce.alignOptimal(ca1, ca2, ce.getParameters(), alignments);\n    for (int cp : cps) {\n        // fresh instance to avoid contamination\n        ce = new OptimalCECPMain();\n        // new copy of ca2, since alignPermuted has side effects\n        Atom[] ca2clone = cache.getAtoms(name2);\n        afpChain = ce.alignPermuted(ca1, ca2clone, ce.getParameters(), cp);\n        Assert.assertEquals(\"Alignment \" + cp + \" differs.\", afpChain, alignments[cp]);\n    }\n}","repo_id":"9","comment":"/**\n * Checks that individual alignments performed by alignOptimal are consistent\n * with the alignments returned by individual calls to alignPermuted.\n *\n * This addresses a bug involving multiple calls to align() on the same\n * CE instance.\n *\n * @throws IOException\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":150,"method_signature":"void testOptimalAlignmentConsistency()"}