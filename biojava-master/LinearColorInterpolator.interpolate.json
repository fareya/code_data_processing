{"callee_method_names":["Color.getColorSpace","Color.getComponents","Color.getComponents","Color.getColorSpace","Color.getComponents","Color.getComponents"],"method_name":"LinearColorInterpolator.interpolate","method_implementation":"{\n    float[] compA, compB;\n    // Get components\n    // Don't convert colorSpaces unless necessary\n    if (a.getColorSpace().equals(colorSpace)) {\n        compA = a.getComponents(null);\n    } else {\n        compA = a.getComponents(colorSpace, null);\n    }\n    if (b.getColorSpace().equals(colorSpace)) {\n        compB = b.getComponents(null);\n    } else {\n        compB = b.getComponents(colorSpace, null);\n    }\n    float[] compMixed = new float[compA.length];\n    for (int i = 0; i < compA.length; i++) {\n        //Normalizing to [0,1] after the interpolation,\n        // INNER means between a and b\n        // OUTER means between max(a,b) and min(a,b)+1\n        // UPPER means between a and b' s.t. b'>a and b' in {b, b+1}\n        // LOWER means between a and b' s.t. b'<a and b' in {b, b-1}\n        float left, right;\n        left = compA[i];\n        //Alpha uses INNER direction\n        InterpolationDirection dir = i < interpolationDirection.length ? interpolationDirection[i] : InterpolationDirection.INNER;\n        switch(dir) {\n            case INNER:\n                right = compB[i];\n                break;\n            case OUTER:\n                if (compA[i] < compB[i]) {\n                    right = compB[i] - 1;\n                } else {\n                    right = compB[i] + 1;\n                }\n                break;\n            case UPPER:\n                if (compA[i] < compB[i]) {\n                    right = compB[i];\n                } else {\n                    right = compB[i] + 1;\n                }\n                break;\n            case LOWER:\n                if (compA[i] < compB[i]) {\n                    right = compB[i] - 1;\n                } else {\n                    right = compB[i];\n                }\n                break;\n            default:\n                throw new IllegalStateException(\"Unkown interpolation Direction \" + interpolationDirection[i]);\n        }\n        //Perform mixing\n        compMixed[i] = mixing * left + (1 - mixing) * right;\n        if (dir != InterpolationDirection.INNER) {\n            //Normalize to [0,1]\n            if (compMixed[i] < 0)\n                compMixed[i] += 1f;\n            if (compMixed[i] > 1)\n                compMixed[i] -= 1f;\n        }\n    }\n    return new Color(colorSpace, compMixed, compMixed[compMixed.length - 1]);\n}","repo_id":"9","comment":"/**\n * Interpolates to a color between a and b\n * @param a First color\n * @param b Second color\n * @param mixing Mixing coefficient; the fraction of a in the result.\n * @return The color between a and b\n * @throws IllegalArgumentException if mixing is not between 0 and 1\n * @see org.biojava.nbio.structure.gui.util.color.ColorInterpolator#interpolate(java.awt.Color, java.awt.Color, float)\n */\n","repo_name":"biojava-master/","id":3369,"method_signature":"Color interpolate(Color, Color, float)"}