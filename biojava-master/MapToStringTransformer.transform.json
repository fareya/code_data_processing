{"callee_method_names":["Map<?,?>.keySet","StringBuilder.append","BlastOutputParameterEnum.toString","StringBuilder.append","StringBuilder.append","Map<?,?>.get","Map<?,?>.get","StringBuilder.append","StringBuilder.substring"],"method_name":"MapToStringTransformer.transform","method_implementation":"{\n    StringBuilder sb = new StringBuilder();\n    for (Object key : map.keySet()) {\n        sb.append(getSeparatorSequence());\n        String keyString = key != null ? key.toString() : getNullValue();\n        sb.append(keyString);\n        sb.append(getMappingSequence());\n        String valueString = map.get(key) != null ? map.get(key).toString() : getNullValue();\n        sb.append(valueString);\n    }\n    return sb.substring(1);\n}","repo_id":"9","comment":"/**\n * Transforms {@code Map} to {@code String}, representing every entry as\n * {@code key} {@code mappingSequence} {@code value} , joined by\n * {@code separatorSequence}\n * <p>\n * Calls {@code toString()} for keys and values, replacing {@code null} with\n * the value of {@code nullValue} property\n * <p>\n * For example, if we have a map with two entries: {@code (\"key1\", \"1\")} and\n * {@code (\"key2\", \"2\")} this method would return {@code \"key1=1&key2=2\"} if\n * {@code mappingSequence} is \"=\" and separator sequence is \"&\";\n *\n * @param map map of arguments\n * @return String resulting string\n */\n","repo_name":"biojava-master/","id":3476,"method_signature":"String transform(Map)"}