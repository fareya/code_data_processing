{"callee_method_names":["Random.nextInt","Random.nextInt","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.contains","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.remove","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<List<Integer>>.get","List<Integer>.contains","List<List<Integer>>.get","List<Integer>.remove","List<List<Integer>>.get"],"method_name":"SymmOptimizer.expandBlock","method_implementation":"{\n    boolean moved = false;\n    // Select between right (0) or left (1)\n    int rl = rnd.nextInt(2);\n    // Residue as a pivot\n    int res = rnd.nextInt(length);\n    switch(rl) {\n        case 0:\n            int rightBoundary = res;\n            int[] previousPos = new int[order];\n            for (int su = 0; su < order; su++) previousPos[su] = -1;\n            // Search a position to the right that has at minimum Rmin\n            while (length - 1 > rightBoundary) {\n                int noncontinuous = 0;\n                for (int su = 0; su < order; su++) {\n                    if (block.get(su).get(rightBoundary) == null) {\n                        continue;\n                    } else if (previousPos[su] == -1) {\n                        previousPos[su] = block.get(su).get(rightBoundary);\n                    } else if (block.get(su).get(rightBoundary) > previousPos[su] + 1) {\n                        noncontinuous++;\n                    }\n                }\n                if (noncontinuous < Rmin)\n                    rightBoundary++;\n                else\n                    break;\n            }\n            if (rightBoundary > 0)\n                rightBoundary--;\n            // Expand the block with the residues at the repeat boundaries\n            for (int su = 0; su < order; su++) {\n                Integer residueR = block.get(su).get(rightBoundary);\n                if (residueR == null) {\n                    if (rightBoundary == length - 1)\n                        block.get(su).add(null);\n                    else\n                        block.get(su).add(rightBoundary + 1, null);\n                } else if (freePool.contains(residueR + 1)) {\n                    Integer residueAdd = residueR + 1;\n                    if (rightBoundary == length - 1) {\n                        block.get(su).add(residueAdd);\n                    } else\n                        block.get(su).add(rightBoundary + 1, residueAdd);\n                    freePool.remove(residueAdd);\n                } else {\n                    if (rightBoundary == length - 1)\n                        block.get(su).add(null);\n                    else\n                        block.get(su).add(rightBoundary + 1, null);\n                }\n            }\n            length++;\n            moved = true;\n            break;\n        case 1:\n            int leftBoundary = res;\n            int[] nextPos = new int[order];\n            for (int su = 0; su < order; su++) nextPos[su] = -1;\n            // Search a position to the right that has at minimum Rmin\n            while (leftBoundary > 0) {\n                int noncontinuous = 0;\n                for (int su = 0; su < order; su++) {\n                    if (block.get(su).get(leftBoundary) == null) {\n                        continue;\n                    } else if (nextPos[su] == -1) {\n                        nextPos[su] = block.get(su).get(leftBoundary);\n                    } else if (block.get(su).get(leftBoundary) < nextPos[su] - 1) {\n                        noncontinuous++;\n                    }\n                }\n                if (noncontinuous < Rmin)\n                    leftBoundary--;\n                else\n                    break;\n            }\n            // Expand the block with the residues at the repeat boundaries\n            for (int su = 0; su < order; su++) {\n                Integer residueL = block.get(su).get(leftBoundary);\n                if (residueL == null) {\n                    block.get(su).add(leftBoundary, null);\n                } else if (freePool.contains(residueL - 1)) {\n                    Integer residueAdd = residueL - 1;\n                    block.get(su).add(leftBoundary, residueAdd);\n                    freePool.remove(residueAdd);\n                } else {\n                    block.get(su).add(leftBoundary, null);\n                }\n            }\n            length++;\n            moved = true;\n            break;\n    }\n    if (moved)\n        return !checkGaps();\n    return moved;\n}","repo_id":"9","comment":"/**\n * It extends the alignment one position to the right or to the left of a\n * randomly selected position by moving the consecutive residues of each\n * repeat (if present) from the freePool to the block.\n * <p>\n * If there are not enough residues in the freePool it introduces gaps.\n */\n","repo_name":"biojava-master/","id":2080,"method_signature":"boolean expandBlock()"}