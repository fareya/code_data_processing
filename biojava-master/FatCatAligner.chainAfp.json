{"callee_method_ids":[484,497],"callee_method_names":["AFPChain.getAfpSet","List<AFP>.size","AFPChain.getAfpChainLen","AFPChain.setShortAlign","SigEva.calSigAll","AFPChain.setProbability","SigEva.calNS","AFPChain.setNormAlignScore","AFPChain.setTMScore","AFPChain.getAlignScore","AFPChain.getOptLength","AFPChain.getTotalRmsdOpt"],"method_name":"FatCatAligner.chainAfp","method_implementation":"{\n    // we don;t want to rotate input atoms, do we?\n    Atom[] ca2clone = StructureTools.cloneAtomArray(ca2);\n    List<AFP> afpSet = afpChain.getAfpSet();\n    if (debug)\n        System.out.println(\"entering chainAfp\");\n    int afpNum = afpSet.size();\n    if (afpNum < 1)\n        return new Group[0];\n    long bgtime = System.currentTimeMillis();\n    if (debug) {\n        System.out.println(String.format(\"total AFP %d\\n\", afpNum));\n    }\n    //run AFP chaining\n    AFPChainer.doChainAfp(params, afpChain, ca1, ca2);\n    int afpChainLen = afpChain.getAfpChainLen();\n    if (afpChainLen < 1) {\n        afpChain.setShortAlign(true);\n        return new Group[0];\n    }\n    //very short alignment\n    long chaintime = System.currentTimeMillis();\n    if (debug) {\n        System.out.println(\"Afp chaining: time \" + (chaintime - bgtime));\n    }\n    // do post processing\n    AFPPostProcessor.postProcess(params, afpChain, ca1, ca2);\n    // Optimize the final alignment\n    AFPOptimizer.optimizeAln(params, afpChain, ca1, ca2);\n    AFPOptimizer.blockInfo(afpChain);\n    AFPOptimizer.updateScore(params, afpChain);\n    AFPAlignmentDisplay.getAlign(afpChain, ca1, ca2);\n    Group[] twistedPDB = AFPTwister.twistPDB(afpChain, ca1, ca2clone);\n    SigEva sig = new SigEva();\n    double probability = sig.calSigAll(params, afpChain);\n    afpChain.setProbability(probability);\n    double normAlignScore = sig.calNS(params, afpChain);\n    afpChain.setNormAlignScore(normAlignScore);\n    double tmScore = AFPChainScorer.getTMScore(afpChain, ca1, ca2, false);\n    afpChain.setTMScore(tmScore);\n    /*\n\n\t\tSIGEVA  sig;\n\t\tprobability = sig.calSigAll(maxTra, sparse, pro1Len, pro2Len, alignScore, totalRmsdOpt, optLength, blockNum - 1);\n\t\tnormAlignScore = sig.calNS(pro1Len, pro2Len, alignScore, totalRmsdOpt, optLength, blockNum - 1);\n\n\t\t */\n    //if(maxTra == 0)       probability = sig.calSigRigid(pro1Len, pro2Len, alignScore, totalRmsdOpt, optLength);\n    //else  probability = sig.calSigFlexi(pro1Len, pro2Len, alignScore, totalRmsdOpt, optLength, blockNum - 1);\n    if (debug) {\n        long nowtime = System.currentTimeMillis();\n        long diff = nowtime - chaintime;\n        System.out.println(\"Alignment optimization: time \" + diff);\n        System.out.println(\"score:      \" + afpChain.getAlignScore());\n        System.out.println(\"opt length: \" + afpChain.getOptLength());\n        System.out.println(\"opt rmsd:   \" + afpChain.getTotalRmsdOpt());\n    }\n    return twistedPDB;\n}","repo_id":"9","comment":"/**\n * run AFP chaining allowing up to maxTra flexible regions.\n * Input is original coordinates.\n */\n","repo_name":"biojava-master/","id":437,"method_signature":"Group[] chainAfp(FatCatParameters, AFPChain, Atom[], Atom[])"}