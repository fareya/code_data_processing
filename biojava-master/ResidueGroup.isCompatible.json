{"callee_method_ids":[2069,2070],"callee_method_names":["ResidueGroup.order","ResidueGroup.get","ResidueGroup.isCompatible","ResidueGroup.get","List<Integer>.get","List<Integer>.get","ResidueGroup.get"],"method_name":"ResidueGroup.isCompatible","method_implementation":"{\n    // Same order needed is necessary\n    if (this.order() != other.order())\n        return false;\n    // Use the method of the smallest ResidueGroup\n    if (this.residues.get(0) > other.residues.get(0))\n        return other.isCompatible(this);\n    // Check for intercalation of residues\n    for (int i = 0; i < order() - 1; i++) {\n        if (other.residues.get(i) > residues.get(i + 1))\n            return false;\n        if (residues.get(i) > other.residues.get(i + 1))\n            return false;\n    }\n    return true;\n}","repo_id":"9","comment":"/**\n * Determine if two Residuegroups (maximally connected components of the\n * alignment Graph) are compatible, based in the following criterion:\n *\n * <pre>\n * Two maximally connected components of the self-alignment Graph are\n * compatible if they can be combined in a consistent multiple alignment\n * of repeats, i.e.there exists one residue in c1 between each sorted\n * pair of residues in c2.\n * <\/pre>\n *\n * Compatibility is an intransitive relation, which means that for three\n * ResidueGroups {A,B,C}, if A is compatible with B and B is compatible with\n * C, then A is not necessarily compatible with C.\n *\n * @param c2\n *            second maximally connected component\n * @return true if compatible, false otherwise\n */\n","repo_name":"biojava-master/","id":2070,"method_signature":"boolean isCompatible(ResidueGroup)"}