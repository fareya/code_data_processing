{"callee_method_names":["Logger.info","MultipleSequenceAlignment<C,D>.getSize","MultipleSequenceAlignment<C,D>.getAlignedSequence","MultipleSequenceAlignment<C,D>.getAlignedSequences","MultipleSequenceAlignment<C,D>.getLength","Logger.info","String[].charAt","String[].charAt","SubstitutionMatrix<D>.getValue","List<C>.get","List<C>.get","DistanceMatrix.setValue","DistanceMatrix.setIdentifier","MultipleSequenceAlignment<C,D>.getAlignedSequence","DistanceMatrix.setValue","DistanceMatrix.getValue","DistanceMatrix.setValue","DistanceMatrix.setValue","Logger.info"],"method_name":"DistanceMatrixCalculator.dissimilarityScore","method_implementation":"{\n    logger.info(\"{}:{}\", \"Determing Distances\", 0);\n    int n = msa.getSize();\n    String[] sequenceString = new String[n];\n    for (int i = 0; i < n; i++) {\n        sequenceString[i] = msa.getAlignedSequence(i + 1).getSequenceAsString();\n    }\n    List<C> seqs = msa.getAlignedSequences();\n    DistanceMatrix DM = new BasicSymmetricalDistanceMatrix(n);\n    int totalloopcount = (n / 2) * (n + 1);\n    double maxscore = 0;\n    int end = msa.getLength();\n    int loopcount = 0;\n    for (int i = 0; i < (n - 1); i++) {\n        logger.info(\"{}:{}\", \"Determining Distances\", (loopcount * 100) / totalloopcount);\n        // Obtain the similarity scores\n        for (int j = i; j < n; j++) {\n            double score = 0;\n            loopcount++;\n            for (int k = 0; k < end; k++) {\n                if (Comparison.isGap(sequenceString[i].charAt(k)) || Comparison.isGap(sequenceString[j].charAt(k)))\n                    continue;\n                score += M.getValue(seqs.get(i).getCompoundAt(k + 1), seqs.get(j).getCompoundAt(k + 1));\n            }\n            if (i != j) {\n                score = Math.max(score, 0.0);\n                DM.setValue(i, j, score);\n            }\n            if (score > maxscore)\n                maxscore = score;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        DM.setIdentifier(i, msa.getAlignedSequence(i + 1).getAccession().getID());\n        for (int j = i; j < n; j++) {\n            if (i == j)\n                DM.setValue(i, j, 0.0);\n            else {\n                double dS = Math.max(maxscore - DM.getValue(i, j), 0);\n                DM.setValue(i, j, dS);\n                DM.setValue(j, i, dS);\n            }\n        }\n    }\n    logger.info(\"{}:{}\", \"Determining Distances\", 100);\n    return DM;\n}","repo_id":"9","comment":"/**\n * The dissimilarity score is the additive inverse of the similarity score\n * (sum of scores) between two aligned sequences using a substitution model\n * (Substitution Matrix). The maximum dissimilarity score is taken to be the\n * maximum similarity score between self-alignments (each sequence against\n * itself). Calculation of the score is as follows:\n *\n * <pre>\n * Ds = maxScore - sum<sub>i<\/sub>(M<sub>ai,bi<\/sub>)\n * <\/pre>\n *\n * It is recommended to use the method\n * {@link #fractionalDissimilarityScore(MultipleSequenceAlignment, SubstitutionMatrix)}\n * , since the maximum similarity score is not relative to the data set, but\n * relative to the Substitution Matrix, and the score is normalized by the\n * alignment length (fractional).\n * <p>\n * Gaps do not have a contribution to the similarity score calculation (gap\n * penalty = 0).\n *\n * @param msa\n *            MultipleSequenceAlignment\n * @param M\n *            SubstitutionMatrix for similarity scoring\n * @return DistanceMatrix\n */\n","repo_name":"biojava-master/","id":111,"method_signature":"DistanceMatrix dissimilarityScore(MultipleSequenceAlignment, SubstitutionMatrix)"}