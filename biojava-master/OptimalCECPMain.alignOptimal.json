{"callee_method_names":["Atom[].getGroup","Atom[].getGroup","AFPChain.setName2","Atom[].getGroup","AFPChain.getAlignScore","AFPChain.getAlignScore"],"method_name":"OptimalCECPMain.alignOptimal","method_implementation":"{\n    long startTime = System.currentTimeMillis();\n    if (alignments != null && alignments.length != ca2.length) {\n        throw new IllegalArgumentException(\"scores param should have same length as ca2\");\n    }\n    AFPChain unaligned = super.align(ca1, ca2, param);\n    AFPChain bestAlignment = unaligned;\n    if (debug) {\n        // print progress bar header\n        System.out.print(\"|\");\n        for (int cp = 1; cp < ca2.length - 1; cp++) {\n            System.out.print(\"=\");\n        }\n        System.out.println(\"|\");\n        System.out.print(\".\");\n    }\n    if (alignments != null) {\n        alignments[0] = unaligned;\n    }\n    for (int cp = 1; cp < ca2.length; cp++) {\n        // clone ca2 to prevent side effects from propegating\n        Atom[] ca2p = StructureTools.cloneAtomArray(ca2);\n        //permute one each time. Alters ca2p as a side effect\n        AFPChain currentAlignment = alignPermuted(ca1, ca2p, param, cp);\n        // increment progress bar\n        if (debug)\n            System.out.print(\".\");\n        // fix up names, since cloning ca2 wipes it\n        if (ca2.length != 0 && ca2[0].getGroup().getChain() != null && ca2[0].getGroup().getChain().getStructure() != null) {\n            currentAlignment.setName2(ca2[0].getGroup().getChain().getStructure().getName() + \" CP=\" + cp);\n        }\n        double currentScore = currentAlignment.getAlignScore();\n        if (alignments != null) {\n            alignments[cp] = currentAlignment;\n        }\n        if (currentScore > bestAlignment.getAlignScore()) {\n            bestAlignment = currentAlignment;\n        }\n    }\n    if (debug) {\n        long elapsedTime = System.currentTimeMillis() - startTime;\n        System.out.println();\n        System.out.format(\"%d alignments took %.4f s (%.1f ms avg)\\n\", ca2.length, elapsedTime / 1000., (double) elapsedTime / ca2.length);\n    }\n    return bestAlignment;\n}","repo_id":"9","comment":"/**\n * Finds the optimal alignment between two proteins allowing for a circular\n * permutation (CP).\n *\n * This algorithm performs a CE alignment for each possible CP site. This is\n * quite slow. Use {@link #alignHeuristic(Atom[], Atom[], Object)} for a\n * faster algorithm.\n *\n * @param ca1 CA atoms of the first protein\n * @param ca2 CA atoms of the second protein\n * @param param {@link CeParameters} object\n * @param alignments If not null, should be an empty array of the same length as\n *  ca2. This will be filled with the alignments from permuting ca2 by\n *  0 to n-1 residues.\n * @return The best-scoring alignment\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":790,"method_signature":"AFPChain alignOptimal(Atom[], Atom[], Object, AFPChain[])"}