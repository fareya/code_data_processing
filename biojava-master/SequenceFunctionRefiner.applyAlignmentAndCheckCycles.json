{"callee_method_names":["Map<Integer,Integer>.keySet","List<Integer>.size","List<Integer>.get","Map<Integer,Integer>.get","List<Integer>.set","Integer.equals","List<Integer>.get","List<Integer>.remove","List<Integer>.get","Map<Integer,Integer>.size","List<Integer>.size","List<Integer>.get","List<Integer>.get","Map<Integer, Integer>.put"],"method_name":"SequenceFunctionRefiner.applyAlignmentAndCheckCycles","method_implementation":"{\n    // Convert to lists to establish a fixed order (avoid concurrent modification)\n    // currently unmodified\n    List<Integer> preimage = new ArrayList<Integer>(alignmentMap.keySet());\n    List<Integer> image = new ArrayList<Integer>(preimage);\n    for (int n = 1; n <= k; n++) {\n        // apply alignment\n        for (int i = 0; i < image.size(); i++) {\n            final Integer pre = image.get(i);\n            final Integer post = (pre == null ? null : alignmentMap.get(pre));\n            image.set(i, post);\n            // Make cycles ineligible\n            if (post != null && post.equals(preimage.get(i))) {\n                // Could be O(n) with List impl\n                eligible.remove(preimage.get(i));\n            }\n        }\n    }\n    Map<Integer, Integer> imageMap = new HashMap<Integer, Integer>(alignmentMap.size());\n    // now populate with actual values\n    for (int i = 0; i < preimage.size(); i++) {\n        Integer pre = preimage.get(i);\n        Integer postK = image.get(i);\n        imageMap.put(pre, postK);\n    }\n    return imageMap;\n}","repo_id":"9","comment":"/**\n * Like {@link AlignmentTools#applyAlignment(Map, int)}, returns a map of k applications of alignmentMap. However,\n * it also sets loops of size less than k as ineligible.\n *\n * @param alignmentMap\n *            f(x)\n * @param k\n * @param eligible\n *            Eligible residues. Residues from small cycles are removed.\n * @return f^k(x)\n */\n","repo_name":"biojava-master/","id":2065,"method_signature":"Map<Integer,Integer> applyAlignmentAndCheckCycles(Map, int, List)"}