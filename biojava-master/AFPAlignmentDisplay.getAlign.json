{"callee_method_ids":[487,490,489,493,494],"callee_method_names":["AFPChain.getAlnsymb","AFPChain.getAlnseq1","AFPChain.getAlnseq2","AFPChain.setAlnseq1","AFPChain.setAlnseq2","AFPChain.setAlnsymb","AFPChain.getBlockNum","AFPChain.getOptLen","AFPChain.getOptAln","AFPChain.getAlnbeg1","AFPChain.getAlnbeg2","AFPChain.getOptLength","Logger.warn","Atom[].getGroup","Atom[].getGroup","Atom[].getGroup","Atom[].getGroup","String.charAt","AFPChain.setOptAln","AFPChain.setOptLen","AFPChain.setAlnbeg1","AFPChain.setAlnbeg2","AFPChain.setAlnLength","AFPChain.setGapLen"],"method_name":"AFPAlignmentDisplay.getAlign","method_implementation":"{\n    char[] alnsymb = afpChain.getAlnsymb();\n    char[] alnseq1 = afpChain.getAlnseq1();\n    char[] alnseq2 = afpChain.getAlnseq2();\n    int i, j, k, p1, p2, p1b, p2b, lmax;\n    int pro1Len = ca1.length;\n    int pro2Len = ca2.length;\n    p1b = p2b = 0;\n    if (alnsymb == null) {\n        alnseq1 = new char[pro1Len + pro2Len + 1];\n        alnseq2 = new char[pro1Len + pro2Len + 1];\n        alnsymb = new char[pro1Len + pro2Len + 1];\n        afpChain.setAlnseq1(alnseq1);\n        afpChain.setAlnseq2(alnseq2);\n        afpChain.setAlnsymb(alnsymb);\n    }\n    int blockNum = afpChain.getBlockNum();\n    int[] optLen = afpChain.getOptLen();\n    int[][][] optAln = afpChain.getOptAln();\n    // immediately overwritten\n    int alnbeg1 = afpChain.getAlnbeg1();\n    // immediately overwritten\n    int alnbeg2 = afpChain.getAlnbeg2();\n    // immediately overwritten\n    int alnLength;\n    int optLength = afpChain.getOptLength();\n    if (optLen == null) {\n        optLen = new int[blockNum];\n        for (int oi = 0; oi < blockNum; oi++) optLen[oi] = 0;\n    }\n    int len = 0;\n    for (i = 0; i < blockNum; i++) {\n        for (j = 0; j < optLen[i]; j++) {\n            p1 = optAln[i][0][j];\n            p2 = optAln[i][1][j];\n            // weird, could not find a residue in the Atom array. Did something change in the underlying data?\n            if ((p1 == -1) || (p2 == -1)) {\n                logger.warn(\"Could not get atom on position \" + j);\n                continue;\n            }\n            if (len > 0) {\n                lmax = (p1 - p1b - 1) > (p2 - p2b - 1) ? (p1 - p1b - 1) : (p2 - p2b - 1);\n                for (k = 0; k < lmax; k++) {\n                    if (k >= (p1 - p1b - 1))\n                        alnseq1[len] = '-';\n                    else {\n                        char oneletter = getOneLetter(ca1[p1b + 1 + k].getGroup());\n                        alnseq1[len] = oneletter;\n                    }\n                    if (k >= (p2 - p2b - 1))\n                        alnseq2[len] = '-';\n                    else {\n                        char oneletter = getOneLetter(ca2[p2b + 1 + k].getGroup());\n                        alnseq2[len] = oneletter;\n                    }\n                    alnsymb[len++] = ' ';\n                }\n            } else {\n                //the first position of sequence in alignment\n                alnbeg1 = p1;\n                alnbeg2 = p2;\n            }\n            if (p1 < ca1.length && p2 < ca2.length) {\n                alnseq1[len] = getOneLetter(ca1[p1].getGroup());\n                alnseq2[len] = getOneLetter(ca2[p2].getGroup());\n            } else {\n                //TODO handle permutations\n                alnseq1[len] = '?';\n                alnseq2[len] = '?';\n            }\n            if (showSeq) {\n                if (alnseq1[len] == alnseq2[len]) {\n                    alnsymb[len++] = '|';\n                } else {\n                    double score = aaScore(alnseq1[len], alnseq2[len]);\n                    if (score > 1)\n                        alnsymb[len++] = ':';\n                    else\n                        alnsymb[len++] = '.';\n                }\n            } else {\n                String tmpS = String.format(\"%d\", i + 1);\n                alnsymb[len++] = tmpS.charAt(0);\n            }\n            p1b = p1;\n            p2b = p2;\n        }\n    }\n    alnLength = len;\n    afpChain.setOptAln(optAln);\n    afpChain.setOptLen(optLen);\n    afpChain.setAlnbeg1(alnbeg1);\n    afpChain.setAlnbeg2(alnbeg2);\n    afpChain.setAlnLength(alnLength);\n    afpChain.setGapLen(alnLength - optLength);\n}","repo_id":"9","comment":"/**\n * Sets the following properties:\n * <ul>\n * <li>The alignment strings {@link AFPChain#setAlnseq1(char[]) alnseq1},\n *  {@link AFPChain#setAlnseq2(char[]) alnseq2},\n *  and {@link AFPChain#setAlnsymb(char[]) alnsymb}<\/li>\n * <li>{@link AFPChain#setAlnbeg1(int) alnbeg1} and 2<\/li>\n * <li>{@link AFPChain#setAlnLength(int) alnLength} and\n *  {@link AFPChain#setGapLen(int) gapLen}<\/li>\n * <\/ul>\n * <p>\n * Expects the following properties to be previously computed:\n * <ul>\n * <li>{@link AFPChain#getOptAln()} and lengths\n * <\/ul>\n *\n * <section>Known Bugs<\/section>\n * Expects the alignment to have linear topology. May give odd results\n * for circular permutations and other complicated topologies.\n *\n * @param afpChain Alignment between ca1 and ca2\n * @param ca1 CA atoms of the first protein\n * @param ca2 CA atoms of the second protein\n * @param showSeq Use symbols reflecting sequence similarity: '|' for identical,\n *  ':' for similar, '.' for dissimilar. Otherwise, use the block number\n *  to show aligned residues.\n */\n","repo_name":"biojava-master/","id":648,"method_signature":"void getAlign(AFPChain, Atom[], Atom[], boolean)"}