{"callee_method_ids":[432,484],"callee_method_names":["FatCatParameters.getFragLen","FatCatParameters.getMaxGapFrag","FatCatParameters.getMisCut","FatCatParameters.getMaxTra","AFPChain.getAfpSet","List<AFP>.get","List<AFP>.get","AFPChain.getAfpAftIndex","AFPChain.getAfpBefIndex","AFPChain.getTwi"],"method_name":"AFPChainer.getCompatibleAfps","method_implementation":"{\n    int i, j, i1, j1, f, G, c, a1, a2, a3, b1, b2, b3, s1, s2;\n    int fragLen = params.getFragLen();\n    int maxGapFrag = params.getMaxGapFrag();\n    int misCut = params.getMisCut();\n    int maxTra = params.getMaxTra();\n    List<AFP> afpSet = afpChain.getAfpSet();\n    f = fragLen;\n    G = maxGapFrag;\n    c = misCut;\n    i1 = afpSet.get(afp).getP1();\n    j1 = afpSet.get(afp).getP2();\n    a3 = i1 - f;\n    a2 = a3 - c;\n    a1 = i1 - G;\n    a2 = a2 > 0 ? a2 : 0;\n    a1 = a1 > 0 ? a1 : 0;\n    b3 = j1 - f;\n    b2 = b3 - c;\n    b1 = j1 - G;\n    b2 = (b2 > 0) ? b2 : 0;\n    b1 = (b1 > 0) ? b1 : 0;\n    int[][] afpAftIndex = afpChain.getAfpAftIndex();\n    int[][] afpBefIndex = afpChain.getAfpBefIndex();\n    int[] twi = afpChain.getTwi();\n    int n = 0;\n    //compatible region 1-2, [a1,a3][b2,b3]\n    for (i = a1; i <= a3; i++) {\n        //i <= a3 instead of i < a3\n        //note afpAftIndex, not afpIndex\n        s1 = afpAftIndex[i][b2];\n        //no AFP for the given i with j > b2\n        if (s1 < 0)\n            continue;\n        //afps is sorted by j given a i,it's sparse matrix\n        s2 = afpBefIndex[i][b3];\n        //no AFP for the given i with j < b3\n        if (s2 < 0)\n            continue;\n        for (j = s1; j <= s2; j++) {\n            //j <= s2 instead of j < s2\n            if (twi[j] <= maxTra) {\n                list[n++] = j;\n            }\n        }\n    }\n    //compatible region 3  [a2,a3][b1,b2]\n    for (i = a2; i <= a3; i++) {\n        s1 = afpAftIndex[i][b1];\n        if (s1 < 0)\n            continue;\n        //afps is sorted by j given a i\n        s2 = afpBefIndex[i][b2];\n        if (s2 < 0)\n            continue;\n        //note j < s2, as the cases of j == s2 is alread considered in previous region\n        for (j = s1; j < s2; j++) {\n            if (twi[j] <= maxTra) {\n                list[n++] = j;\n            }\n        }\n    }\n    return n;\n}","repo_id":"9","comment":"/*\n\n\tderive the compabitle AFP lists for AFP-chaining\n\tthis is important for speeding up the process\n\tfor a given AFP(i1,j1), there are three regions that could be the starting\n\tpoint for the compabitle AFPs of AFP(i1,j1)\n\t//                 a1        a2   a3\n\t//               i1-G    i1-f-c i1-f+1 i1\n\t//                 |          |   |   |\n\t//              ----------------------------\n\t//              | B               |   |\n\t//b1  j1-G  -|  ---------------|   |\n\t//              |  |          |   |   |\n\t//              |  |     C    | 3 |   |\n\t//              |  |          |   |   |\n\t//b2 j1-f-c -|  |--------------|   |\n\t//              |  |     2    | 1 |   |\n\t//b3 j1-f+1 -|------------------   |\n\t//              |                   A |\n\t//          j1 -|---------------------\\\n\t//              |                      \\ (AFP(i1,j1))\n\t//              -----------------------------\n\t//\n\tf: the length of AFPs (we use segments of same length)\n\tG: g + f, where g is the maximum allowed gaps\n\tc: the maximum allowed cross-over in AFP-connection,\n\t\t here we use c = f, and j1-f-c = j1-2f\n\tincompatible region A: its AFPs overlap with given AFP(i1,j1)\n\tincompatible region B: the gaps between its AFP with given AFP is larger than g\n\tincompatible region C: its AFPs connect with given AFP but cross a given threshold.\n\tcompatible region 1: [i1-f-c,i1-f+1>,[j1-f-c,j1-f+1> or [a2,a3],[b2,b3]\n\tcompatible region 2: [i1-G,i1-f-c],[j1-f-c,j1-f] or [a1,a2],[b2,b3]\n\tcombine 1 and 2    : [i1-G,i1-f],[j1-f-c,j1-f]   or [a1,a3],[b2,b3]\n\tcompatible region 3: [i1-f-c,i1-f],[j1-G,j1-f-c] or [a2,a3],[b1,b2]\n\tc->misCut\n\tf->fragLen\n\tG->fragLen+maxGap->maxGapFrag\n\t *\n\t *\n\t */\n","repo_name":"biojava-master/","id":413,"method_signature":"int getCompatibleAfps(int, int[], FatCatParameters, AFPChain)"}