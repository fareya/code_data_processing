{"callee_method_ids":[3610,3673,3675,3655,3667,3667,3667,3657,3659,3654,3632,3641,3634,3631,3606,3531,3531,3532,3531,3532,3531,3532,3531,3532,3616,3530],"callee_method_names":["String.indexOf","String.split","CoxInfo.setSurvivalInfoList","ArrayList<SurvivalInfo>.size","ArrayList<String>.size","ArrayList<SurvivalInfo>.get","SurvivalInfo.getTime","SurvivalInfo.getStatus","SurvivalInfo.getOffset","SurvivalInfo.getClusterValue","SurvivalInfo.getClusterValue","SurvivalInfo.toString","ArrayList<String>.add","SurvivalInfo.getClusterValue","SurvivalInfo.getWeight","SurvivalInfo.getStrata","ArrayList<String>.size","ArrayList<String>.get","SurvivalInfo.getVariable","CoxInfo.setScoreLogrankTest","CoxInfo.setDegreeFreedom","CoxInfo.setScoreLogrankTestpvalue","CoxInfo.getScoreLogrankTest","CoxInfo.setVariance","ArrayList<String>.get","CoxCoefficient.getCoeff","CoxCoefficient.getCoeff","CoxCoefficient.getStdError","CoxCoefficient.getCoeff","CoxCoefficient.getStdError","CoxCoefficient.getCoeff","CoxCoefficient.getStdError","CoxCoefficient.getCoeff","CoxCoefficient.getStdError","CoxInfo.setCoefficient","CoxCoefficient.getName"],"method_name":"CoxR.process","method_implementation":"{\n    //make sure data is converted to numbers if labels are used\n    SurvivalInfoHelper.categorizeData(data);\n    //create variables if testing for interaction\n    for (String variable : variables) {\n        if (variable.indexOf(\":\") != -1) {\n            String[] d = variable.split(\":\");\n            SurvivalInfoHelper.addInteraction(d[0], d[1], data);\n        }\n    }\n    Collections.sort(data);\n    // Collections.reverse(data);\n    CoxInfo coxInfo = new CoxInfo();\n    coxInfo.setSurvivalInfoList(data);\n    int i, j, k, person;\n    boolean gotofinish = false;\n    double[][] cmat, imat;\n    /*ragged arrays covar[][], */\n    double wtave;\n    double[] a, newbeta;\n    double[] a2;\n    double[][] cmat2;\n    double[] scale;\n    double denom = 0, zbeta, risk;\n    double temp, temp2;\n    int ndead;\n    /* actually, the sum of their weights */\n    double newlk = 0;\n    double dtime, d2;\n    double deadwt;\n    /*sum of case weights for the deaths*/\n    double efronwt;\n    /* sum of weighted risk scores for the deaths*/\n    int halving;\n    /*are we doing step halving at the moment? */\n    @SuppressWarnings(\"unused\")\n    int nrisk = 0;\n    /* number of subjects in the current risk set */\n    /* copies of scalar input arguments */\n    int nused, nvar;\n    /* vector inputs */\n    //  double *time, *weights, *offset;\n    //  int *status, *strata;\n    /* returned objects */\n    // double imat2[][];\n    double[] u, loglik, means;\n    double sctest;\n    int flag = 0;\n    int iter = 0;\n    //SEXP rlist, rlistnames;\n    //  int nprotect;  /* number of protect calls I have issued */\n    /* get local copies of some input args */\n    // LENGTH(offset2);\n    nused = data.size();\n    // ncols(covar2);\n    nvar = variables.size();\n    //       imat2 = new double[nvar][nvar];\n    //        nprotect++;\n    //dmatrix(REAL(imat2),  nvar, nvar);\n    imat = new double[nvar][nvar];\n    //(double *) R_alloc(2*nvar*nvar + 4*nvar, sizeof(double));\n    a = new double[nvar];\n    //a + nvar;\n    newbeta = new double[nvar];\n    //newbeta + nvar;\n    a2 = new double[nvar];\n    //a2 + nvar;\n    scale = new double[nvar];\n    //dmatrix(scale + nvar,   nvar, nvar);\n    cmat = new double[nvar][nvar];\n    //dmatrix(scale + nvar +nvar*nvar, nvar, nvar);\n    cmat2 = new double[nvar][nvar];\n    /*\n\t\t ** create output variables\n\t\t */\n    //    PROTECT(beta2 = duplicate(ibeta));\n    //    beta = REAL(beta2);\n    //  beta = new double[nvar];\n    // beta = beta2;\n    //  PROTECT(means2 = allocVector(REALSXP, nvar));\n    //  means = REAL(means2);\n    means = new double[nvar];\n    double[] sd = new double[nvar];\n    //double[] se = new double[nvar];\n    //   means = means2;\n    //   PROTECT(u2 = allocVector(REALSXP, nvar));\n    //   u = REAL(u2);\n    u = new double[nvar];\n    //   u = u2;\n    //    PROTECT(loglik2 = allocVector(REALSXP, 2));\n    //    loglik = REAL(loglik2);\n    loglik = new double[2];\n    //   loglik = loglik2;\n    //    PROTECT(sctest2 = allocVector(REALSXP, 1));\n    //    sctest = REAL(sctest2);\n    //        sctest = new double[1];\n    //   sctest = sctest2;\n    //    PROTECT(flag2 = allocVector(INTSXP, 1));\n    //    flag = INTEGER(flag2);\n    //        flag = new int[1];\n    //     flag = flag2;\n    //    PROTECT(iter2 = allocVector(INTSXP, 1));\n    //    iterations = INTEGER(iter2);\n    //        iterations = new int[1];\n    //        iterations = iter2;\n    //       nprotect += 7;\n    /*\n\t\t ** Subtract the mean from each covar, as this makes the regression\n\t\t **  much more stable.\n\t\t */\n    double[] time = new double[nused];\n    int[] status = new int[nused];\n    double[] offset = new double[nused];\n    double[] weights = new double[nused];\n    int[] strata = new int[nused];\n    double[][] covar = new double[nvar][nused];\n    ArrayList<String> clusterList = null;\n    if (cluster) {\n        clusterList = new ArrayList<String>();\n    }\n    //copy data over to local arrays to minimuze changing code\n    for (person = 0; person < nused; person++) {\n        SurvivalInfo si = data.get(person);\n        time[person] = si.getTime();\n        status[person] = si.getStatus();\n        offset[person] = si.getOffset();\n        if (cluster) {\n            if (si.getClusterValue() == null && si.getClusterValue().length() == 0) {\n                throw new Exception(\"Cluster value is not valid for \" + si.toString());\n            }\n            clusterList.add(si.getClusterValue());\n        }\n        if (useWeighted) {\n            weights[person] = si.getWeight();\n        } else {\n            weights[person] = 1.0;\n        }\n        if (useStrata) {\n            strata[person] = si.getStrata();\n        } else {\n            strata[person] = 0;\n        }\n        for (i = 0; i < variables.size(); i++) {\n            String variable = variables.get(i);\n            covar[i][person] = si.getVariable(variable);\n        }\n    }\n    double tempsd = 0;\n    i = 0;\n    for (i = 0; i < nvar; i++) {\n        temp = 0;\n        tempsd = 0;\n        //calculate the mean sd\n        for (person = 0; person < nused; person++) {\n            // * weights[person];\n            temp += covar[i][person];\n            //*weights[person] * weights[person]\n            tempsd += (covar[i][person]) * (covar[i][person]);\n        }\n        temp /= nused;\n        //   temp /= weightCount;\n        means[i] = temp;\n        tempsd /= nused;\n        //  tempsd /= weightCount;\n        tempsd = Math.sqrt(tempsd - temp * temp);\n        //standard deviation\n        sd[i] = tempsd;\n        //subtract the mean\n        for (person = 0; person < nused; person++) {\n            covar[i][person] -= temp;\n        }\n        if (doscale == 1) {\n            /* and also scale it */\n            temp = 0;\n            for (person = 0; person < nused; person++) {\n                //fabs\n                temp += Math.abs(covar[i][person]);\n            }\n            if (temp > 0) {\n                temp = nused / temp;\n                /* scaling */\n            } else {\n                temp = 1.0;\n                /* rare case of a constant covariate */\n            }\n            scale[i] = temp;\n            for (person = 0; person < nused; person++) {\n                covar[i][person] *= temp;\n            }\n        }\n    }\n    if (doscale == 1) {\n        for (i = 0; i < nvar; i++) {\n            beta[i] /= scale[i];\n            /*rescale initial betas */\n        }\n    } else {\n        for (i = 0; i < nvar; i++) {\n            scale[i] = 1.0;\n        }\n    }\n    /*\n\t\t ** do the initial iteration step\n\t\t */\n    strata[nused - 1] = 1;\n    loglik[1] = 0;\n    for (i = 0; i < nvar; i++) {\n        //u = s1\n        u[i] = 0;\n        //a2 = a\n        a2[i] = 0;\n        for (j = 0; j < nvar; j++) {\n            //s2\n            imat[i][j] = 0;\n            //a\n            cmat2[i][j] = 0;\n        }\n    }\n    for (person = nused - 1; person >= 0; ) {\n        if (strata[person] == 1) {\n            nrisk = 0;\n            denom = 0;\n            for (i = 0; i < nvar; i++) {\n                a[i] = 0;\n                for (j = 0; j < nvar; j++) {\n                    cmat[i][j] = 0;\n                }\n            }\n        }\n        dtime = time[person];\n        ndead = 0;\n        /*number of deaths at this time point */\n        deadwt = 0;\n        /* sum of weights for the deaths */\n        efronwt = 0;\n        /* sum of weighted risks for the deaths */\n        while (person >= 0 && time[person] == dtime) {\n            /* walk through the this set of tied times */\n            nrisk++;\n            zbeta = offset[person];\n            /* form the term beta*z (vector mult) */\n            for (i = 0; i < nvar; i++) {\n                //x\n                zbeta += beta[i] * covar[i][person];\n            }\n            zbeta = coxsafe(zbeta);\n            //risk = v\n            risk = Math.exp(zbeta) * weights[person];\n            denom += risk;\n            /* a is the vector of weighted sums of x, cmat sums of squares */\n            for (i = 0; i < nvar; i++) {\n                //a = s1\n                a[i] += risk * covar[i][person];\n                for (j = 0; j <= i; j++) {\n                    //cmat = s2;\n                    cmat[i][j] += risk * covar[i][person] * covar[j][person];\n                }\n            }\n            if (status[person] == 1) {\n                ndead++;\n                deadwt += weights[person];\n                efronwt += risk;\n                loglik[1] += weights[person] * zbeta;\n                for (i = 0; i < nvar; i++) {\n                    u[i] += weights[person] * covar[i][person];\n                }\n                if (method == CoxMethod.Efron) {\n                    /* Efron */\n                    for (i = 0; i < nvar; i++) {\n                        a2[i] += risk * covar[i][person];\n                        for (j = 0; j <= i; j++) {\n                            cmat2[i][j] += risk * covar[i][person] * covar[j][person];\n                        }\n                    }\n                }\n            }\n            person--;\n            if (person >= 0 && strata[person] == 1) {\n                //added catch of person = 0 and person-- = -1\n                break;\n                /*ties don't cross strata */\n            }\n        }\n        if (ndead > 0) {\n            /* we need to add to the main terms */\n            if (method == CoxMethod.Breslow) {\n                /* Breslow */\n                loglik[1] -= deadwt * Math.log(denom);\n                for (i = 0; i < nvar; i++) {\n                    temp2 = a[i] / denom;\n                    /* mean */\n                    u[i] -= deadwt * temp2;\n                    for (j = 0; j <= i; j++) {\n                        imat[j][i] += deadwt * (cmat[i][j] - temp2 * a[j]) / denom;\n                    }\n                }\n            } else {\n                /* Efron */\n                /*\n\t\t\t\t\t ** If there are 3 deaths we have 3 terms: in the first the\n\t\t\t\t\t **  three deaths are all in, in the second they are 2/3\n\t\t\t\t\t **  in the sums, and in the last 1/3 in the sum.  Let k go\n\t\t\t\t\t **  from 0 to (ndead -1), then we will sequentially use\n\t\t\t\t\t **     denom - (k/ndead)*efronwt as the denominator\n\t\t\t\t\t **     a - (k/ndead)*a2 as the \"a\" term\n\t\t\t\t\t **     cmat - (k/ndead)*cmat2 as the \"cmat\" term\n\t\t\t\t\t **  and reprise the equations just above.\n\t\t\t\t\t */\n                for (k = 0; k < ndead; k++) {\n                    temp = (double) k / ndead;\n                    wtave = deadwt / ndead;\n                    d2 = denom - temp * efronwt;\n                    loglik[1] -= wtave * Math.log(d2);\n                    for (i = 0; i < nvar; i++) {\n                        temp2 = (a[i] - temp * a2[i]) / d2;\n                        u[i] -= wtave * temp2;\n                        for (j = 0; j <= i; j++) {\n                            imat[j][i] += (wtave / d2) * ((cmat[i][j] - temp * cmat2[i][j]) - temp2 * (a[j] - temp * a2[j]));\n                        }\n                    }\n                }\n                for (i = 0; i < nvar; i++) {\n                    a2[i] = 0;\n                    for (j = 0; j < nvar; j++) {\n                        cmat2[i][j] = 0;\n                    }\n                }\n            }\n        }\n    }\n    /* end  of accumulation loop */\n    loglik[0] = loglik[1];\n    /* save the loglik for iterations 0 */\n    /* am I done?\n\t\t **   update the betas and test for convergence\n\t\t */\n    for (i = 0; i < nvar; i++) /*use 'a' as a temp to save u0, for the score test*/\n    {\n        a[i] = u[i];\n    }\n    flag = Cholesky2.process(imat, nvar, toler);\n    chsolve2(imat, nvar, a);\n    /* a replaced by  a *inverse(i) */\n    temp = 0;\n    for (i = 0; i < nvar; i++) {\n        temp += u[i] * a[i];\n    }\n    sctest = temp;\n    /* score test */\n    /*\n\t\t **  Never, never complain about convergence on the first step.  That way,\n\t\t **  if someone HAS to they can force one iterations at a time.\n\t\t */\n    for (i = 0; i < nvar; i++) {\n        newbeta[i] = beta[i] + a[i];\n    }\n    if (maxiter == 0) {\n        chinv2(imat, nvar);\n        for (i = 0; i < nvar; i++) {\n            beta[i] *= scale[i];\n            /*return to original scale */\n            u[i] /= scale[i];\n            imat[i][i] *= scale[i] * scale[i];\n            for (j = 0; j < i; j++) {\n                imat[j][i] *= scale[i] * scale[j];\n                imat[i][j] = imat[j][i];\n            }\n        }\n        // goto finish;\n        gotofinish = true;\n    }\n    /*\n\t\t ** here is the main loop\n\t\t */\n    if (!gotofinish) {\n        halving = 0;\n        /* =1 when in the midst of \"step halving\" */\n        for (iter = 1; iter <= maxiter; iter++) {\n            newlk = 0;\n            for (i = 0; i < nvar; i++) {\n                u[i] = 0;\n                for (j = 0; j < nvar; j++) {\n                    imat[i][j] = 0;\n                }\n            }\n            /*\n\t\t\t\t ** The data is sorted from smallest time to largest\n\t\t\t\t ** Start at the largest time, accumulating the risk set 1 by 1\n\t\t\t\t */\n            for (person = nused - 1; person >= 0; ) {\n                if (strata[person] == 1) {\n                    /* rezero temps for each strata */\n                    denom = 0;\n                    nrisk = 0;\n                    for (i = 0; i < nvar; i++) {\n                        a[i] = 0;\n                        for (j = 0; j < nvar; j++) {\n                            cmat[i][j] = 0;\n                        }\n                    }\n                }\n                dtime = time[person];\n                deadwt = 0;\n                ndead = 0;\n                efronwt = 0;\n                while (person >= 0 && time[person] == dtime) {\n                    nrisk++;\n                    zbeta = offset[person];\n                    for (i = 0; i < nvar; i++) {\n                        zbeta += newbeta[i] * covar[i][person];\n                    }\n                    zbeta = coxsafe(zbeta);\n                    risk = Math.exp(zbeta) * weights[person];\n                    denom += risk;\n                    for (i = 0; i < nvar; i++) {\n                        a[i] += risk * covar[i][person];\n                        for (j = 0; j <= i; j++) {\n                            cmat[i][j] += risk * covar[i][person] * covar[j][person];\n                        }\n                    }\n                    if (status[person] == 1) {\n                        ndead++;\n                        deadwt += weights[person];\n                        newlk += weights[person] * zbeta;\n                        for (i = 0; i < nvar; i++) {\n                            u[i] += weights[person] * covar[i][person];\n                        }\n                        if (method == CoxMethod.Efron) {\n                            /* Efron */\n                            efronwt += risk;\n                            for (i = 0; i < nvar; i++) {\n                                a2[i] += risk * covar[i][person];\n                                for (j = 0; j <= i; j++) {\n                                    cmat2[i][j] += risk * covar[i][person] * covar[j][person];\n                                }\n                            }\n                        }\n                    }\n                    person--;\n                    if (person >= 0 && strata[person] == 1) {\n                        //added catch of person = 0 and person-- = -1\n                        break;\n                        /*ties don't cross strata */\n                    }\n                }\n                if (ndead > 0) {\n                    /* add up terms*/\n                    if (method == CoxMethod.Breslow) {\n                        /* Breslow */\n                        newlk -= deadwt * Math.log(denom);\n                        for (i = 0; i < nvar; i++) {\n                            temp2 = a[i] / denom;\n                            /* mean */\n                            u[i] -= deadwt * temp2;\n                            for (j = 0; j <= i; j++) {\n                                imat[j][i] += (deadwt / denom) * (cmat[i][j] - temp2 * a[j]);\n                            }\n                        }\n                    } else {\n                        /* Efron */\n                        for (k = 0; k < ndead; k++) {\n                            temp = (double) k / ndead;\n                            wtave = deadwt / ndead;\n                            d2 = denom - temp * efronwt;\n                            newlk -= wtave * Math.log(d2);\n                            for (i = 0; i < nvar; i++) {\n                                temp2 = (a[i] - temp * a2[i]) / d2;\n                                u[i] -= wtave * temp2;\n                                for (j = 0; j <= i; j++) {\n                                    imat[j][i] += (wtave / d2) * ((cmat[i][j] - temp * cmat2[i][j]) - temp2 * (a[j] - temp * a2[j]));\n                                }\n                            }\n                        }\n                        for (i = 0; i < nvar; i++) {\n                            /*in anticipation */\n                            a2[i] = 0;\n                            for (j = 0; j < nvar; j++) {\n                                cmat2[i][j] = 0;\n                            }\n                        }\n                    }\n                }\n            }\n            /* end  of accumulation loop  */\n            /* am I done?\n\t\t\t\t **   update the betas and test for convergence\n\t\t\t\t */\n            flag = Cholesky2.process(imat, nvar, toler);\n            if (Math.abs(1 - (loglik[1] / newlk)) <= eps && halving == 0) {\n                /* all done */\n                loglik[1] = newlk;\n                chinv2(imat, nvar);\n                /* invert the information matrix */\n                for (i = 0; i < nvar; i++) {\n                    beta[i] = newbeta[i] * scale[i];\n                    u[i] /= scale[i];\n                    imat[i][i] *= scale[i] * scale[i];\n                    for (j = 0; j < i; j++) {\n                        imat[j][i] *= scale[i] * scale[j];\n                        imat[i][j] = imat[j][i];\n                    }\n                }\n                //  goto finish;\n                gotofinish = true;\n                break;\n            }\n            if (iter == maxiter) {\n                break;\n                /*skip the step halving calc*/\n            }\n            if (newlk < loglik[1]) {\n                /*it is not converging ! */\n                halving = 1;\n                for (i = 0; i < nvar; i++) {\n                    newbeta[i] = (newbeta[i] + beta[i]) / 2;\n                    /*half of old increment */\n                }\n            } else {\n                halving = 0;\n                loglik[1] = newlk;\n                chsolve2(imat, nvar, u);\n                j = 0;\n                for (i = 0; i < nvar; i++) {\n                    beta[i] = newbeta[i];\n                    newbeta[i] = newbeta[i] + u[i];\n                }\n            }\n        }\n        /* return for another iteration */\n    }\n    if (!gotofinish) {\n        /*\n\t\t\t ** We end up here only if we ran out of iterations\n\t\t\t */\n        loglik[1] = newlk;\n        chinv2(imat, nvar);\n        for (i = 0; i < nvar; i++) {\n            beta[i] = newbeta[i] * scale[i];\n            u[i] /= scale[i];\n            imat[i][i] *= scale[i] * scale[i];\n            for (j = 0; j < i; j++) {\n                imat[j][i] *= scale[i] * scale[j];\n                imat[i][j] = imat[j][i];\n            }\n        }\n        flag = 1000;\n    }\n    //finish:\n    /*\n\t\t for (j = 0; j < numCovariates; j++) {\n\t\t b[j] = b[j] / SD[j];\n\t\t * ix = j * (numCovariates + 1) + j\n\t\t SE[j] = Math.sqrt(a[ix(j, j, numCovariates + 1)]) / SD[j];\n\t\t //            o = o + (\"   \" + variables.get(j) + \"    \" + Fmt(b[j]) + Fmt(SE[j]) + Fmt(Math.exp(b[j])) + Fmt(Norm(Math.abs(b[j] / SE[j]))) + Fmt(Math.exp(b[j] - 1.95 * SE[j])) + Fmt(Math.exp(b[j] + 1.95 * SE[j])) + NL);\n\t\t CoxCoefficient coe = coxInfo.getCoefficient(variables.get(j));\n\t\t coe.coeff = b[j];\n\t\t coe.stdError = SE[j];\n\t\t coe.hazardRatio = Math.exp(b[j]);\n\t\t coe.pvalue = Norm(Math.abs(b[j] / SE[j]));\n\t\t coe.hazardRatioLoCI = Math.exp(b[j] - 1.95 * SE[j]);\n\t\t coe.hazardRatioHiCI = Math.exp(b[j] + 1.95 * SE[j]);\n\t\t }\n\n\t\t */\n    coxInfo.setScoreLogrankTest(sctest);\n    coxInfo.setDegreeFreedom(beta.length);\n    coxInfo.setScoreLogrankTestpvalue(ChiSq.chiSq(coxInfo.getScoreLogrankTest(), beta.length));\n    coxInfo.setVariance(imat);\n    coxInfo.u = u;\n    //     for (int n = 0; n < beta.length; n++) {\n    //         se[n] = Math.sqrt(imat[n][n]); // / sd[n];\n    //     }\n    //       System.out.println(\"coef,se, means,u\");\n    for (int n = 0; n < beta.length; n++) {\n        CoxCoefficient coe = new CoxCoefficient();\n        coe.name = variables.get(n);\n        coe.mean = means[n];\n        coe.standardDeviation = sd[n];\n        coe.coeff = beta[n];\n        coe.stdError = Math.sqrt(imat[n][n]);\n        coe.hazardRatio = Math.exp(coe.getCoeff());\n        coe.z = coe.getCoeff() / coe.getStdError();\n        coe.pvalue = ChiSq.norm(Math.abs(coe.getCoeff() / coe.getStdError()));\n        double z = 1.959964;\n        coe.hazardRatioLoCI = Math.exp(coe.getCoeff() - z * coe.getStdError());\n        coe.hazardRatioHiCI = Math.exp(coe.getCoeff() + z * coe.getStdError());\n        coxInfo.setCoefficient(coe.getName(), coe);\n        // System.out.println(beta[n] + \",\" + se[n] + \",\" + means[n] + \",\" + sd[n] + \",\" + u[n]); //+ \",\" + imat[n] \",\" + loglik[n] + \",\" + sctest[n] + \",\" + iterations[n] + \",\" + flag[n]\n    }\n    coxInfo.maxIterations = maxiter;\n    coxInfo.eps = eps;\n    coxInfo.toler = toler;\n    coxInfo.iterations = iter;\n    coxInfo.flag = flag;\n    coxInfo.loglikInit = loglik[0];\n    coxInfo.loglikFinal = loglik[1];\n    coxInfo.method = method;\n    //    System.out.println(\"loglik[0]=\" + loglik[0]);\n    //    System.out.println(\"loglik[1]=\" + loglik[1]);\n    //    System.out.println(\"chisq? sctest[0]=\" + sctest[0]);\n    //    System.out.println(\"?overall model p-value=\" + chiSq(sctest[0], beta.length));\n    //      System.out.println();\n    //       for (int n = 0; n < covar[0].length; n++) {\n    //           System.out.print(n);\n    //           for (int variable = 0; variable < covar.length; variable++) {\n    //               System.out.print(\"\\t\" + covar[variable][n]);\n    //           }\n    //           System.out.println();\n    //       }\n    //      for (SurvivalInfo si : data) {\n    //          System.out.println(si.order + \" \" + si.getScore());\n    //      }\n    //        coxInfo.dump();\n    coxphfitSCleanup(coxInfo, useWeighted, robust, clusterList);\n    return coxInfo;\n}","repo_id":"9","comment":"/**\n * @param variables\n * @param data\n * @param maxiter\n * @param method\n * @param eps\n * @param toler\n * @param beta\n * @param doscale\n * @param useStrata\n * @param useWeighted\n * @param robust\n * @param cluster\n * @return\n * @throws Exception\n */\n","repo_name":"biojava-master/","id":3563,"method_signature":"CoxInfo process(ArrayList, ArrayList, int, CoxMethod, double, double, double[], int, boolean, boolean, boolean, boolean)"}