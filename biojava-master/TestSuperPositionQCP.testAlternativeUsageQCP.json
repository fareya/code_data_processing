{"callee_method_ids":[1504,1510],"callee_method_names":["Matrix4d.set","Matrix4d.setTranslation","Matrix4d.set","Matrix4d.setTranslation","Random.nextInt","Random.nextInt","Random.nextInt","Random.nextDouble","Random.nextDouble","Random.nextDouble","SuperPositionQCP.getRmsd","SuperPositionQCP.superposeAfterRmsd","SuperPositionQCP.superpose","Logger.info","Matrix4d.epsilonEquals"],"method_name":"TestSuperPositionQCP.testAlternativeUsageQCP","method_implementation":"{\n    // Transformation applied to cloud points 1 that needs to be recovered\n    // by the superposition method\n    AxisAngle4d rotAxis = new AxisAngle4d(0.440, 0.302, 0.845, 1.570);\n    Vector3d translation = new Vector3d(0.345, 2.453, 5.324);\n    Matrix4d transform = new Matrix4d();\n    transform.set(rotAxis);\n    transform.setTranslation(translation);\n    // Generate a random artificial array of points\n    Random rnd = new Random(0);\n    transform = new Matrix4d();\n    transform.set(rotAxis);\n    transform.setTranslation(translation);\n    Point3d[] c1 = new Point3d[500];\n    Point3d[] c2 = new Point3d[500];\n    for (int p = 0; p < 500; p++) {\n        Point3d a = new Point3d(rnd.nextInt(100), rnd.nextInt(50), rnd.nextInt(150));\n        c1[p] = a;\n        // Add some noise to the second point\n        Point3d b = new Point3d(a.x + rnd.nextDouble(), a.y + rnd.nextDouble(), a.z + rnd.nextDouble());\n        c2[p] = b;\n    }\n    CalcPoint.transform(transform, c1);\n    SuperPositionQCP qcp = new SuperPositionQCP(false);\n    // Step 1 calculate RMSD\n    long start = System.nanoTime() / 1000;\n    qcp.getRmsd(c1, c2);\n    long rmsdTime = (System.nanoTime() / 1000 - start);\n    // Step 2 Obtain the matrix after RMSD\n    Matrix4d trans1 = qcp.superposeAfterRmsd();\n    long trans1time = (System.nanoTime() / 1000 - start) - rmsdTime;\n    // Now obtain the matrix from scratch\n    Matrix4d trans2 = qcp.superpose(c1, c2);\n    long trans2time = (System.nanoTime() / 1000 - start) - trans1time;\n    LOGGER.info(String.format(\"Time for RMSD: %d us, superposition after RMSD: %d us, and superposition from scratch: %d us\", rmsdTime, trans1time, trans2time));\n    // Check the results are the same\n    assertTrue(trans1.epsilonEquals(trans2, 0.05));\n}","repo_id":"9","comment":"/**\n * Test case proposed by Peter Rose to check the alternative use of QCP,\n * where first the RMSD is checked before obtaining the transformation\n * matrix, in order to speed up large-scale calculations.\n */\n","repo_name":"biojava-master/","id":2309,"method_signature":"void testAlternativeUsageQCP()"}