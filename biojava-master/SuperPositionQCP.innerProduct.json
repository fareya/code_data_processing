{"callee_method_names":[],"method_name":"SuperPositionQCP.innerProduct","method_implementation":"{\n    double x1, x2, y1, y2, z1, z2;\n    double g1 = 0.0, g2 = 0.0;\n    Sxx = 0;\n    Sxy = 0;\n    Sxz = 0;\n    Syx = 0;\n    Syy = 0;\n    Syz = 0;\n    Szx = 0;\n    Szy = 0;\n    Szz = 0;\n    if (weight != null) {\n        wsum = 0;\n        for (int i = 0; i < coords1.length; i++) {\n            wsum += weight[i];\n            x1 = weight[i] * coords1[i].x;\n            y1 = weight[i] * coords1[i].y;\n            z1 = weight[i] * coords1[i].z;\n            g1 += x1 * coords1[i].x + y1 * coords1[i].y + z1 * coords1[i].z;\n            x2 = coords2[i].x;\n            y2 = coords2[i].y;\n            z2 = coords2[i].z;\n            g2 += weight[i] * (x2 * x2 + y2 * y2 + z2 * z2);\n            Sxx += (x1 * x2);\n            Sxy += (x1 * y2);\n            Sxz += (x1 * z2);\n            Syx += (y1 * x2);\n            Syy += (y1 * y2);\n            Syz += (y1 * z2);\n            Szx += (z1 * x2);\n            Szy += (z1 * y2);\n            Szz += (z1 * z2);\n        }\n    } else {\n        for (int i = 0; i < coords1.length; i++) {\n            g1 += coords1[i].x * coords1[i].x + coords1[i].y * coords1[i].y + coords1[i].z * coords1[i].z;\n            g2 += coords2[i].x * coords2[i].x + coords2[i].y * coords2[i].y + coords2[i].z * coords2[i].z;\n            Sxx += coords1[i].x * coords2[i].x;\n            Sxy += coords1[i].x * coords2[i].y;\n            Sxz += coords1[i].x * coords2[i].z;\n            Syx += coords1[i].y * coords2[i].x;\n            Syy += coords1[i].y * coords2[i].y;\n            Syz += coords1[i].y * coords2[i].z;\n            Szx += coords1[i].z * coords2[i].x;\n            Szy += coords1[i].z * coords2[i].y;\n            Szz += coords1[i].z * coords2[i].z;\n        }\n        wsum = coords1.length;\n    }\n    e0 = (g1 + g2) * 0.5;\n}","repo_id":"9","comment":"/**\n * Calculates the inner product between two coordinate sets x and y\n * (optionally weighted, if weights set through\n * {@link #set(Point3d[], Point3d[], double[])}). It also calculates an\n * upper bound of the most positive root of the key matrix.\n * http://theobald.brandeis.edu/qcp/qcprot.c\n *\n * @param coords1\n * @param coords2\n * @return\n */\n","repo_name":"biojava-master/","id":1508,"method_signature":"void innerProduct(Point3d[], Point3d[])"}