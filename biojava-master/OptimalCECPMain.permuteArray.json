{"callee_method_names":["List<T>.add","List<T>.get"],"method_name":"OptimalCECPMain.permuteArray","method_implementation":"{\n    // Allow negative cp points for convenience.\n    if (cp == 0) {\n        return;\n    }\n    if (cp < 0) {\n        cp = arr.length + cp;\n    }\n    if (cp < 0 || cp >= arr.length) {\n        throw new ArrayIndexOutOfBoundsException(\"Permutation point (\" + cp + \") must be between -ca2.length and ca2.length-1\");\n    }\n    List<T> temp = new ArrayList<T>(cp);\n    // shift residues left\n    for (int i = 0; i < cp; i++) {\n        temp.add(arr[i]);\n    }\n    for (int j = cp; j < arr.length; j++) {\n        arr[j - cp] = arr[j];\n    }\n    for (int i = 0; i < cp; i++) {\n        arr[arr.length - cp + i] = temp.get(i);\n    }\n}","repo_id":"9","comment":"/**\n * Circularly permutes arr in place.\n *\n * <p>Similar to {@link Collections#rotate(List, int)} but with reversed\n * direction. Perhaps it would be more efficient to use the Collections version?\n * @param <T>\n * @param arr The array to be permuted\n * @param cp The number of residues to shift leftward, or equivalently, the index of\n *  the first element after the permutation point.\n */\n","repo_name":"biojava-master/","id":783,"method_signature":"void permuteArray(T[], int)"}