{"callee_method_ids":[3607,3637,3655,3654,3664,3662,3666,3608,3607,3663,3661,3664,3662,3664,3662,3663,3661,3664,3662,3664,3662,3606,3628,3679],"callee_method_names":["CoxInfo.getVariance","CoxInfo.getCoefficientsList","ArrayList<CoxCoefficient>.get","SurvivalInfo.getOffset","SurvivalInfo.getVariable","SurvivalInfo.setLinearPredictor","SurvivalInfo.setScore","CoxInfo.size","CoxInfo.get","SurvivalInfo.setResidual","CoxInfo.setNaiveVariance","CoxInfo.getVariance","CoxInfo.size","CoxInfo.size","SurvivalInfo.getLinearPredictor","SurvivalInfo.getScore","SurvivalInfo.setLinearPredictor","SurvivalInfo.setScore","SurvivalInfo.setLinearPredictor","SurvivalInfo.setScore","CoxInfo.size","CoxInfo.size","SurvivalInfo.getLinearPredictor","SurvivalInfo.getScore","SurvivalInfo.setLinearPredictor","SurvivalInfo.setScore","SurvivalInfo.setLinearPredictor","SurvivalInfo.setScore","CoxInfo.setVariance","CoxInfo.setRscore","WaldTestInfo.getTest"],"method_name":"CoxR.coxphfitSCleanup","method_implementation":"{\n    //Do cleanup found after coxfit6 is called in coxph.fit.S\n    //infs <- abs(coxfit$u %*% var)\n    //[ a1 b1] * [a1 b1]\n    //           [a2 b2]\n    double[][] du = new double[1][ci.u.length];\n    du[0] = ci.u;\n    double[] infs = Matrix.abs(Matrix.multiply(ci.u, ci.getVariance()));\n    //        StdArrayIO.print(infs);\n    ArrayList<CoxCoefficient> coxCoefficients = new ArrayList<CoxCoefficient>(ci.getCoefficientsList().values());\n    for (int i = 0; i < infs.length; i++) {\n        double inf = infs[i];\n        double coe = coxCoefficients.get(i).getCoeff();\n        if (inf > ci.eps && inf > (ci.toler * Math.abs(coe))) {\n            ci.message = \"Loglik converged before variable \";\n        }\n    }\n    //sum(coef*coxfit$means)\n    double sumcoefmeans = 0;\n    for (CoxCoefficient cc : coxCoefficients) {\n        sumcoefmeans = sumcoefmeans + cc.getCoeff() * cc.getMean();\n    }\n    // coxph.fit.S line 107\n    //lp <- c(x %*% coef) + offset - sum(coef*coxfit$means)\n    for (SurvivalInfo si : ci.survivalInfoList) {\n        double offset = si.getOffset();\n        double lp = 0;\n        for (CoxCoefficient cc : coxCoefficients) {\n            String name = cc.getName();\n            double coef = cc.getCoeff();\n            double value = si.getVariable(name);\n            lp = lp + value * coef;\n        }\n        lp = lp + offset - sumcoefmeans;\n        si.setLinearPredictor(lp);\n        si.setScore(Math.exp(lp));\n        //           System.out.println(\"lp score \" + si.order + \" \" + si.time + \" \" + si.getWeight() + \" \" + si.getClusterValue() + \" \" + lp + \" \" + Math.exp(lp));\n    }\n    //       ci.dump();\n    //begin code after call to coxfit6 in coxph.fit.S\n    //Compute the martingale residual for a Cox model\n    // appears to be C syntax error for = - vs -=\n    //(if (nullmodel) in coxph.fit\n    double[] res = CoxMart.process(ci.method, ci.survivalInfoList, false);\n    for (int i = 0; i < ci.survivalInfoList.size(); i++) {\n        SurvivalInfo si = ci.survivalInfoList.get(i);\n        si.setResidual(res[i]);\n    }\n    //this represents the end of coxph.fit.S code and we pickup\n    //after call to fit <- fitter(X, Y, strats ....) in coxph.R\n    if (robust) {\n        ci.setNaiveVariance(ci.getVariance());\n        double[][] temp;\n        double[][] temp0;\n        if (cluster != null) {\n            temp = ResidualsCoxph.process(ci, ResidualsCoxph.Type.dfbeta, useWeighted, cluster);\n            //# get score for null model\n            //    if (is.null(init))\n            //          fit2$linear.predictors <- 0*fit$linear.predictors\n            //    else\n            //          fit2$linear.predictors <- c(X %*% init)\n            //Set score to 1\n            double[] templp = new double[ci.survivalInfoList.size()];\n            double[] tempscore = new double[ci.survivalInfoList.size()];\n            int i = 0;\n            for (SurvivalInfo si : ci.survivalInfoList) {\n                templp[i] = si.getLinearPredictor();\n                tempscore[i] = si.getScore();\n                si.setLinearPredictor(0);\n                //this erases stored value which isn't how the R code does it\n                si.setScore(1.0);\n                i++;\n            }\n            temp0 = ResidualsCoxph.process(ci, ResidualsCoxph.Type.score, useWeighted, cluster);\n            i = 0;\n            for (SurvivalInfo si : ci.survivalInfoList) {\n                si.setLinearPredictor(templp[i]);\n                //this erases stored value which isn't how the R code does it\n                si.setScore(tempscore[i]);\n                i++;\n            }\n        } else {\n            temp = ResidualsCoxph.process(ci, ResidualsCoxph.Type.dfbeta, useWeighted, null);\n            //     fit2$linear.predictors <- 0*fit$linear.predictors\n            double[] templp = new double[ci.survivalInfoList.size()];\n            double[] tempscore = new double[ci.survivalInfoList.size()];\n            int i = 0;\n            for (SurvivalInfo si : ci.survivalInfoList) {\n                templp[i] = si.getLinearPredictor();\n                tempscore[i] = si.getScore();\n                si.setLinearPredictor(0);\n                si.setScore(1.0);\n            }\n            temp0 = ResidualsCoxph.process(ci, ResidualsCoxph.Type.score, useWeighted, null);\n            i = 0;\n            for (SurvivalInfo si : ci.survivalInfoList) {\n                si.setLinearPredictor(templp[i]);\n                //this erases stored value which isn't how the R code does it\n                si.setScore(tempscore[i]);\n                i++;\n            }\n        }\n        //fit$var<- t(temp) % * % temp\n        double[][] ttemp = Matrix.transpose(temp);\n        double[][] var = Matrix.multiply(ttemp, temp);\n        ci.setVariance(var);\n        //u<- apply(as.matrix(temp0), 2, sum)\n        double[] u = new double[temp0[0].length];\n        for (int i = 0; i < temp0[0].length; i++) {\n            for (int j = 0; j < temp0.length; j++) {\n                u[i] = u[i] + temp0[j][i];\n            }\n        }\n        //fit$rscore <- coxph.wtest(t(temp0)%*%temp0, u, control$toler.chol)$test\n        double[][] wtemp = Matrix.multiply(Matrix.transpose(temp0), temp0);\n        double toler_chol = 1.818989e-12;\n        //  toler_chol = ci.toler;\n        WaldTestInfo wti = WaldTest.process(wtemp, u, toler_chol);\n        //not giving the correct value\n        ci.setRscore(wti.getTest());\n    }\n    calculateWaldTestInfo(ci);\n}","repo_id":"9","comment":"/**\n * @param ci\n * @param useWeighted\n * @param robust\n * @param cluster\n * @throws Exception\n */\n","repo_name":"biojava-master/","id":3564,"method_signature":"void coxphfitSCleanup(CoxInfo, boolean, boolean, ArrayList)"}