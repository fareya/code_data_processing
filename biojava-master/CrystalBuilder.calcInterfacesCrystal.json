{"callee_method_ids":[1423,1422,1422,1424,1421,1421,906],"callee_method_names":["UnitCellBoundingBox.setBbs","Logger.isDebugEnabled","Logger.debug","Logger.debug","Logger.debug","Structure.getPolyChains","UnitCellBoundingBox.getTranslatedBbs","UnitCellBoundingBox.getAuBoundingBox","UnitCellBoundingBox.getAuBoundingBox","CrystalTransform.translate","CrystalTransform.isEquivalent","Logger.debug","CrystalTransform.toString","UnitCellBoundingBox.getChainBoundingBox","UnitCellBoundingBox.getChainBoundingBox","StringBuilder.append","List<Chain>.get","List<Chain>.get","Chain.clone","StructureInterfaceList.addNcsEquivalent","StructureInterfaceList.add","StringBuilder.append","StringBuilder.append","StringBuilder.append","Logger.debug","StringBuilder.toString","Logger.debug","Logger.debug","Logger.debug","Logger.debug","Logger.debug","Logger.debug","StructureInterfaceList.size"],"method_name":"CrystalBuilder.calcInterfacesCrystal","method_implementation":"{\n    // initialising debugging vars\n    long start = -1;\n    long end = -1;\n    int trialCount = 0;\n    int skippedRedundant = 0;\n    int skippedAUsNoOverlap = 0;\n    int skippedChainsNoOverlap = 0;\n    int skippedSelfEquivalent = 0;\n    // The bounding boxes of all AUs of the unit cell\n    UnitCellBoundingBox bbGrid = new UnitCellBoundingBox(numOperatorsSg, numPolyChainsAu);\n    ;\n    // we calculate all the bounds of each of the asym units, those will then be reused and translated\n    bbGrid.setBbs(structure, ops, INCLUDE_HETATOMS);\n    // if not crystallographic there's no search to do in other cells, only chains within \"AU\" will be checked\n    if (!searchBeyondAU)\n        numCells = 0;\n    boolean verbose = logger.isDebugEnabled();\n    if (verbose) {\n        trialCount = 0;\n        start = System.currentTimeMillis();\n        int neighbors = (2 * numCells + 1) * (2 * numCells + 1) * (2 * numCells + 1) - 1;\n        int auTrials = (numPolyChainsAu * (numPolyChainsAu - 1)) / 2;\n        int trials = numPolyChainsAu * numOperatorsSg * numPolyChainsAu * neighbors;\n        logger.debug(\"Chain clash trials within original AU: {}\", auTrials);\n        logger.debug(\"Chain clash trials between the original AU and the neighbouring \" + neighbors + \" whole unit cells (\" + numCells + \" neighbours)\" + \"(2x\" + numPolyChainsAu + \"chains x \" + numOperatorsSg + \"AUs x \" + neighbors + \"cells) : \" + trials);\n        logger.debug(\"Total trials: {}\", (auTrials + trials));\n    }\n    List<Chain> polyChains = structure.getPolyChains();\n    for (int a = -numCells; a <= numCells; a++) {\n        for (int b = -numCells; b <= numCells; b++) {\n            for (int c = -numCells; c <= numCells; c++) {\n                Point3i trans = new Point3i(a, b, c);\n                Vector3d transOrth = new Vector3d(a, b, c);\n                if (a != 0 || b != 0 || c != 0) {\n                    // we avoid doing the transformation for 0,0,0 (in case it's not crystallographic)\n                    this.crystallographicInfo.getCrystalCell().transfToOrthonormal(transOrth);\n                }\n                UnitCellBoundingBox bbGridTrans = bbGrid.getTranslatedBbs(transOrth);\n                for (int n = 0; n < numOperatorsSg; n++) {\n                    // short-cut strategies\n                    // 1) we skip first of all if the bounding boxes of the AUs don't overlap\n                    if (!bbGrid.getAuBoundingBox(0).overlaps(bbGridTrans.getAuBoundingBox(n), cutoff)) {\n                        skippedAUsNoOverlap++;\n                        continue;\n                    }\n                    // 2) we check if we didn't already see its equivalent symmetry operator partner\n                    CrystalTransform tt = new CrystalTransform(this.crystallographicInfo.getSpaceGroup(), n);\n                    tt.translate(trans);\n                    if (isRedundantTransform(tt)) {\n                        skippedRedundant++;\n                        continue;\n                    }\n                    addVisitedTransform(tt);\n                    boolean selfEquivalent = false;\n                    // 3) an operator can be \"self redundant\" if it is the inverse of itself (involutory, e.g. all pure 2-folds with no translation)\n                    if (tt.isEquivalent(tt)) {\n                        logger.debug(\"Transform {} is equivalent to itself, will skip half of i-chains to j-chains comparisons\", tt.toString());\n                        // in this case we can't skip the operator, but we can skip half of the matrix comparisons e.g. j>i\n                        // we set a flag and do that within the loop below\n                        selfEquivalent = true;\n                    }\n                    StringBuilder builder = null;\n                    if (verbose)\n                        builder = new StringBuilder(String.valueOf(tt)).append(\" \");\n                    // Now that we know that boxes overlap and operator is not redundant, we have to go to the details\n                    int contactsFound = 0;\n                    for (int j = 0; j < numPolyChainsAu; j++) {\n                        for (int i = 0; i < numPolyChainsAu; i++) {\n                            // we only have to compare the original asymmetric unit to every full cell around\n                            if (selfEquivalent && (j > i)) {\n                                // in case of self equivalency of the operator we can safely skip half of the matrix\n                                skippedSelfEquivalent++;\n                                continue;\n                            }\n                            // special case of original AU, we don't compare a chain to itself\n                            if (n == 0 && a == 0 && b == 0 && c == 0 && i == j)\n                                continue;\n                            // before calculating the AtomContactSet we check for overlap, then we save putting atoms into the grid\n                            if (!bbGrid.getChainBoundingBox(0, i).overlaps(bbGridTrans.getChainBoundingBox(n, j), cutoff)) {\n                                skippedChainsNoOverlap++;\n                                if (verbose) {\n                                    builder.append(\".\");\n                                }\n                                continue;\n                            }\n                            trialCount++;\n                            // finally we've gone through all short-cuts and the 2 chains seem to be close enough:\n                            // we do the calculation of contacts\n                            Chain chaini = polyChains.get(i);\n                            Chain chainj = polyChains.get(j);\n                            if (n != 0 || a != 0 || b != 0 || c != 0) {\n                                Matrix4d mJCryst = new Matrix4d(ops[n]);\n                                translate(mJCryst, transOrth);\n                                chainj = (Chain) chainj.clone();\n                                Calc.transform(chainj, mJCryst);\n                            }\n                            StructureInterface interf = calcContacts(chaini, chainj, cutoff, tt, builder);\n                            if (interf == null) {\n                                continue;\n                            }\n                            contactsFound++;\n                            if (this.hasNcsOps()) {\n                                StructureInterface interfNcsRef = findNcsRef(interf);\n                                set.addNcsEquivalent(interf, interfNcsRef);\n                            } else {\n                                set.add(interf);\n                            }\n                        }\n                    }\n                    if (verbose) {\n                        if (a == 0 && b == 0 && c == 0 && n == 0)\n                            builder.append(\" \" + contactsFound + \"(\" + (numPolyChainsAu * (numPolyChainsAu - 1)) / 2 + \")\");\n                        else if (selfEquivalent)\n                            builder.append(\" \" + contactsFound + \"(\" + (numPolyChainsAu * (numPolyChainsAu + 1)) / 2 + \")\");\n                        else\n                            builder.append(\" \" + contactsFound + \"(\" + numPolyChainsAu * numPolyChainsAu + \")\");\n                        logger.debug(builder.toString());\n                    }\n                }\n            }\n        }\n    }\n    end = System.currentTimeMillis();\n    logger.debug(\"\\n{} chain-chain clash trials done. Time {}{}s\", trialCount, (end - start), 1000);\n    logger.debug(\"  skipped (not overlapping AUs)       : {}\", skippedAUsNoOverlap);\n    logger.debug(\"  skipped (not overlapping chains)    : {}\", skippedChainsNoOverlap);\n    logger.debug(\"  skipped (sym redundant op pairs)    : {}\", skippedRedundant);\n    logger.debug(\"  skipped (sym redundant self op)     : {}\", skippedSelfEquivalent);\n    logger.debug(\"Found {} interfaces.\", set.size());\n}","repo_id":"9","comment":"/**\n * Calculate interfaces between original asymmetric unit and neighboring\n * whole unit cells, including the original full unit cell i.e. i=0,j=0,k=0\n * @param set\n * @param cutoff\n */\n","repo_name":"biojava-master/","id":1439,"method_signature":"void calcInterfacesCrystal(StructureInterfaceList, double)"}