{"callee_method_names":["List<Chain>.size","List<Chain>.get","List<Chain>.size","List<Chain>.get","Chain.getAtomSequence","Logger.isDebugEnabled","Logger.debug","Chain.getAtomSequence","List<Chain>.get","Chain.getAtomSequence","String.length","String.indexOf","String.length","Chain.getAtomGroup","List<Chain>.get","Map<String, Integer>.get","Group.getPDBName","Map<String, Integer>.get","Group.getPDBName","String.length","String.charAt","String.length","Group.getAtom","Map<Integer, List<String>>.get","Group.getAtom","Map<Integer, List<String>>.get","Logger.info","Group.getPDBName","String.length","String.charAt","String.length","Logger.info","Group.getPDBName","String.length","String.charAt","String.length","Atom.getX","Atom.getX","Atom.getY","Atom.getY","Atom.getZ","Atom.getZ","Map<Integer, List<String>>.get","Group.getAtom","Map<Integer, List<String>>.get","Group.getAtom","List<Pair<Group>>.add","ArrayList.add","Chain.getAtomSequence","String.length","String.charAt","String.length","String.length","String.charAt","String.length","String.length","String.charAt","String.length","Logger.info"],"method_name":"BasePairParameters.findPairs","method_implementation":"{\n    List<Pair<Group>> result = new ArrayList<>();\n    for (int i = 0; i < chains.size(); i++) {\n        Chain c = chains.get(i);\n        for (int j = i + 1; j < chains.size(); j++) {\n            String complement = complement(chains.get(j).getAtomSequence(), useRNA);\n            String match = longestCommonSubstring(c.getAtomSequence(), complement);\n            if (log.isDebugEnabled()) {\n                log.debug(c.getAtomSequence() + \" \" + chains.get(j).getAtomSequence() + \" \" + match);\n            }\n            int index1 = c.getAtomSequence().indexOf(match);\n            int index2 = complement.length() - complement.indexOf(match) - 1;\n            for (int k = 0; k < match.length(); k++) {\n                Group g1 = c.getAtomGroup(index1 + k);\n                Group g2 = chains.get(j).getAtomGroup(index2 - k);\n                Integer type1 = BASE_MAP.get(g1.getPDBName());\n                Integer type2 = BASE_MAP.get(g2.getPDBName());\n                if (type1 == null || type2 == null) {\n                    if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                    continue;\n                }\n                Atom a1 = g1.getAtom(RING_MAP.get(type1).get(0));\n                Atom a2 = g2.getAtom(RING_MAP.get(type2).get(0));\n                if (a1 == null) {\n                    log.info(\"Error processing \" + g1.getPDBName());\n                    if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                    continue;\n                }\n                if (a2 == null) {\n                    log.info(\"Error processing \" + g2.getPDBName());\n                    if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                    continue;\n                }\n                double dx = a1.getX() - a2.getX();\n                double dy = a1.getY() - a2.getY();\n                double dz = a1.getZ() - a2.getZ();\n                double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n                //log.info(\"C8-C6 Distance (Ã…): \" + distance);\n                // could be a base pair\n                if (Math.abs(distance - 10.0) < 4.0) {\n                    boolean valid = true;\n                    for (String atomname : RING_MAP.get(type1)) {\n                        Atom a = g1.getAtom(atomname);\n                        if (a == null)\n                            valid = false;\n                    }\n                    if (valid)\n                        for (String atomname : RING_MAP.get(type2)) {\n                            Atom a = g2.getAtom(atomname);\n                            if (a == null)\n                                valid = false;\n                        }\n                    if (valid) {\n                        result.add(new Pair<Group>(g1, g2));\n                        pairingNames.add((useRNA ? BASE_LIST_RNA[type1] + BASE_LIST_RNA[type2] : BASE_LIST_DNA[type1] + BASE_LIST_DNA[type2]));\n                        pairSequence += c.getAtomSequence().charAt(index1 + k);\n                    } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                } else if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                    pairSequence += ' ';\n            }\n            if (pairSequence.length() != 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                pairSequence += ' ';\n        }\n        //log.info();\n    }\n    log.info(\"Matched: \" + pairSequence);\n    return result;\n}","repo_id":"9","comment":"/**\n * This method performs a search for base pairs in the structure.  The criteria is alignment of\n * sequences and the canonical base pairs of DNA or RNA. Use MismatchedBasePairParameters\n * or TertiaryBasePairParameters for finding higher-order associations.\n * @param chains The list of chains already found to be nucleic acids\n * @return The list of corresponding Watson-Crick groups as pairs, as a Pair of nucleic acid Groups\n */\n","repo_name":"biojava-master/","id":1737,"method_signature":"List<Pair<Group>> findPairs(List)"}