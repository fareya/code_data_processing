{"callee_method_names":["Chain.getId","StructureInterface.getId","Chain.getId","Map<String, Map<ResidueNumber, Integer>>.containsKey","Chain.getId","Map<String, Map<ResidueNumber, Integer>>.get","Chain.getId","Group.getResidueNumber","Chain.getSeqResGroups","Chain.getSeqResGroups","Chain.getSeqResGroups","Map<ResidueNumber, Integer>.get","Group.getResidueNumber"],"method_name":"EntityInfo.getAlignedResIndex","method_implementation":"{\n    boolean contained = false;\n    for (Chain member : getChains()) {\n        if (c.getId().equals(member.getId())) {\n            contained = true;\n            break;\n        }\n    }\n    if (!contained)\n        throw new IllegalArgumentException(\"Given chain with asym_id \" + c.getId() + \" is not a member of this entity: \" + getChainIds().toString());\n    if (!chains2pdbResNums2ResSerials.containsKey(c.getId())) {\n        // we do lazy initialisation of the map\n        initResSerialsMap(c);\n    }\n    // if no seqres groups are available at all the map will be null\n    Map<ResidueNumber, Integer> map = chains2pdbResNums2ResSerials.get(c.getId());\n    int serial;\n    if (map != null) {\n        ResidueNumber resNum = g.getResidueNumber();\n        // the resNum will be null for groups that are SEQRES only and not in ATOM,\n        // still it can happen that a group is in ATOM in one chain but not in other of the same entity.\n        // This is what we try to find out here (analogously to what we do in initResSerialsMap() ):\n        if (resNum == null && c.getSeqResGroups() != null && !c.getSeqResGroups().isEmpty()) {\n            int index = c.getSeqResGroups().indexOf(g);\n            resNum = findResNumInOtherChains(index, c);\n        }\n        if (resNum == null) {\n            // still null, we really can't map\n            serial = -1;\n        } else {\n            Integer alignedSerial = map.get(resNum);\n            if (alignedSerial == null) {\n                // the map doesn't contain this group, something's wrong: return -1\n                serial = -1;\n            } else {\n                serial = alignedSerial;\n            }\n        }\n    } else {\n        // no seqres groups available we resort to using the pdb residue numbers are given\n        serial = g.getResidueNumber().getSeqNum();\n    }\n    return serial;\n}","repo_id":"9","comment":"/**\n * Given a Group g of Chain c (member of this EntityInfo) return the corresponding position in the\n * alignment of all member sequences (1-based numbering), i.e. the index (1-based) in the SEQRES sequence.\n * This allows for comparisons of residues belonging to different chains of the same EntityInfo (entity).\n * <p>\n * Note this method should only be used for entities of type {@link EntityType#POLYMER}\n * <p>\n * If {@link FileParsingParameters#setAlignSeqRes(boolean)} is not used or SEQRES not present, a mapping\n * will not be available and this method will return {@link ResidueNumber#getSeqNum()} for all residues, which\n * in some cases will be correctly aligned indices (when no insertion codes are\n * used and when all chains within the entity are numbered in the same way), but\n * in general they will be neither unique (because of insertion codes) nor aligned.\n * <\/p>\n * @param g the group\n * @param c the chain\n * @return the aligned residue index (1 to n), if no SEQRES groups are available at all then {@link ResidueNumber#getSeqNum()}\n * is returned as a fall-back, if the group is not found in the SEQRES groups then -1 is returned\n * for the given group and chain\n * @throws IllegalArgumentException if the given Chain is not a member of this EntityInfo\n * @see Chain#getSeqResGroup(int)\n */\n","repo_name":"biojava-master/","id":1343,"method_signature":"int getAlignedResIndex(Group, Chain)"}