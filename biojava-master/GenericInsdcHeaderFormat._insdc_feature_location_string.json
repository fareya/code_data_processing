{"callee_method_names":["FeatureInterface<AbstractSequence<C>,C>.getChildrenFeatures","FeatureInterface<AbstractSequence<C>,C>.getLocations","FeatureInterface<AbstractSequence<C>,C>.getLocations","FeatureInterface<AbstractSequence<C>,C>.getLocations","Formatter.format","Formatter.toString","Formatter.close","FeatureInterface<AbstractSequence<C>,C>.getLocations","FeatureInterface<AbstractSequence<C>,C>.getLocations","long.getStrand","Formatter.format","FeatureInterface<AbstractSequence<C>,C>.getLocations","long.getStrand","Formatter.toString","Formatter.close","FeatureInterface<AbstractSequence<C>,C>.getLocations","ArrayList<String>.add","Formatter.format","Formatter.toString","Formatter.close","FeatureInterface<AbstractSequence<C>,C>.getLocations","ArrayList<String>.add","Formatter.format","Formatter.toString","Formatter.close","FeatureInterface<AbstractSequence<C>,C>.getLocations","FeatureInterface<AbstractSequence<C>,C>.getChildrenFeatures","File.getLocations","Formatter.format","FeatureInterface<AbstractSequence<C>,C>.getLocations","File.getLocations","Formatter.toString","Formatter.close","FeatureInterface<AbstractSequence<C>,C>.getChildrenFeatures","ArrayList<String>.add","File.getLocations","Formatter.format","Formatter.toString","Formatter.close","FeatureInterface<AbstractSequence<C>,C>.getChildrenFeatures","ArrayList<String>.add","File.getLocations","Formatter.format","Formatter.toString","Formatter.close"],"method_name":"GenericInsdcHeaderFormat._insdc_feature_location_string","method_implementation":"{\n    if (feature.getChildrenFeatures().isEmpty()) {\n        if (feature.getLocations().getSubLocations().isEmpty()) {\n            //Non-recursive.\n            String location = _insdc_location_string_ignoring_strand_and_subfeatures(feature.getLocations(), record_length);\n            if (feature.getLocations().getStrand() == Strand.NEGATIVE) {\n                StringBuilder sb = new StringBuilder();\n                Formatter formatter = new Formatter(sb, Locale.US);\n                formatter.format(\"complement(%s)\", location);\n                String output = formatter.toString();\n                formatter.close();\n                location = output;\n            }\n            return location;\n        } else if (feature.getLocations().getStrand() == Strand.NEGATIVE) {\n            // As noted above, treat reverse complement strand features carefully:\n            // check if any of the sublocations strand differs from the parent features strand\n            for (Location l : feature.getLocations().getSubLocations()) {\n                if (l.getStrand() != Strand.NEGATIVE) {\n                    StringBuilder sb = new StringBuilder();\n                    Formatter formatter = new Formatter(sb, Locale.US);\n                    formatter.format(\"Inconsistent strands: %s for parent, %s for child\", feature.getLocations().getStrand(), l.getStrand());\n                    String output = formatter.toString();\n                    formatter.close();\n                    throw new RuntimeException(output);\n                }\n            }\n            StringBuilder sb = new StringBuilder();\n            Formatter formatter = new Formatter(sb, Locale.US);\n            ArrayList<String> locations = new ArrayList<String>();\n            for (Location l : feature.getLocations().getSubLocations()) {\n                locations.add(_insdc_location_string_ignoring_strand_and_subfeatures((AbstractLocation) l, record_length));\n            }\n            String location = StringManipulationHelper.join(locations, \",\");\n            formatter.format(\"complement(%s(%s))\", /* feature.location_operator */\n            \"join\", location);\n            String output = formatter.toString();\n            formatter.close();\n            return output;\n        } else {\n            //Convert feature sub-locations into joins\n            //This covers typical forward strand features, and also an evil mixed strand:\n            StringBuilder sb = new StringBuilder();\n            Formatter formatter = new Formatter(sb, Locale.US);\n            ArrayList<String> locations = new ArrayList<String>();\n            for (Location l : feature.getLocations().getSubLocations()) {\n                locations.add(_insdc_location_string_ignoring_strand_and_subfeatures((AbstractLocation) l, record_length));\n            }\n            String location = StringManipulationHelper.join(locations, \",\");\n            formatter.format(\"%s(%s)\", /*feature.location_operator*/\n            \"join\", location);\n            String output = formatter.toString();\n            formatter.close();\n            return output;\n        }\n    }\n    // As noted above, treat reverse complement strand features carefully:\n    if (feature.getLocations().getStrand() == Strand.NEGATIVE) {\n        for (FeatureInterface<?, ?> f : feature.getChildrenFeatures()) {\n            if (f.getLocations().getStrand() != Strand.NEGATIVE) {\n                StringBuilder sb = new StringBuilder();\n                Formatter formatter = new Formatter(sb, Locale.US);\n                formatter.format(\"Inconsistent strands: %s for parent, %s for child\", feature.getLocations().getStrand(), f.getLocations().getStrand());\n                String output = formatter.toString();\n                formatter.close();\n                throw new RuntimeException(output);\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        Formatter formatter = new Formatter(sb, Locale.US);\n        ArrayList<String> locations = new ArrayList<String>();\n        for (FeatureInterface<AbstractSequence<C>, C> f : feature.getChildrenFeatures()) {\n            locations.add(_insdc_location_string_ignoring_strand_and_subfeatures(f.getLocations(), record_length));\n        }\n        String location = StringManipulationHelper.join(locations, \",\");\n        formatter.format(\"complement(%s(%s))\", /*feature.location_operator*/\n        \"join\", location);\n        String output = formatter.toString();\n        formatter.close();\n        return output;\n    }\n    //This covers typical forward strand features, and also an evil mixed strand:\n    StringBuilder sb = new StringBuilder();\n    Formatter formatter = new Formatter(sb, Locale.US);\n    ArrayList<String> locations = new ArrayList<String>();\n    for (FeatureInterface<AbstractSequence<C>, C> f : feature.getChildrenFeatures()) {\n        locations.add(_insdc_location_string_ignoring_strand_and_subfeatures(f.getLocations(), record_length));\n    }\n    String location = StringManipulationHelper.join(locations, \",\");\n    formatter.format(\"%s(%s)\", /*feature.location_operator*/\n    \"join\", location);\n    String output = formatter.toString();\n    formatter.close();\n    return output;\n}","repo_id":"9","comment":"/**\n *  Build a GenBank/EMBL location string from a SeqFeature (PRIVATE).\n *\n * \tThere is a choice of how to show joins on the reverse complement strand,\n * \tGenBank used \"complement(join(1,10),(20,100))\" while EMBL used to use\n * \t\"join(complement(20,100),complement(1,10))\" instead (but appears to have\n * \tnow adopted the GenBank convention). Notice that the order of the entries\n * \tis reversed! This function therefore uses the first form. In this situation\n * \twe expect the parent feature and the two children to all be marked as\n * \tstrand == -1, and in the order 0:10 then 19:100.\n *\n * \tAlso need to consider dual-strand examples like these from the Arabidopsis\n * \tthaliana chloroplast NC_000932: join(complement(69611..69724),139856..140650)\n * \tgene ArthCp047, GeneID:844801 or its CDS (protein NP_051038.1 GI:7525057)\n * \twhich is further complicated by a splice:\n * \tjoin(complement(69611..69724),139856..140087,140625..140650)\n *\n * \tFor mixed this mixed strand feature, the parent SeqFeature should have\n * \tno strand (either 0 or None) while the child features should have either\n * \tstrand +1 or -1 as appropriate, and be listed in the order given here.\n *  @param feature\n *  @param record_length\n */\n","repo_name":"biojava-master/","id":2706,"method_signature":"String _insdc_feature_location_string(FeatureInterface, int)"}