{"callee_method_names":["Logger.debug","SecStrucState.getType","SecStrucState.getTurn","SecStrucState.getTurn"],"method_name":"SecStrucCalc.checkSetHelix","method_implementation":"{\n    int idx = n - 3;\n    logger.debug(\"Set helix {} {} {}\", type, n, idx);\n    for (int i = 1; i < groups.length - n; i++) {\n        SecStrucState state = getSecStrucState(i);\n        SecStrucState previousState = getSecStrucState(i - 1);\n        //Check that no other helix was assgined to this range\n        if (state.getType().compareTo(type) < 0)\n            continue;\n        if (getSecStrucState(i + 1).getType().compareTo(type) < 0)\n            continue;\n        char turn = state.getTurn()[idx];\n        char pturn = previousState.getTurn()[idx];\n        //Two consecutive n-turns present to define a n-helix\n        if ((turn == '>' || turn == 'X') && (pturn == '>' || pturn == 'X')) {\n            //Mark following n residues as turn\n            for (int k = 0; k < n; k++) {\n                setSecStrucType(i + k, type);\n            }\n            if (!DSSP_HELICES) {\n                setSecStrucType(i - 1, type);\n                setSecStrucType(i + n, type);\n            }\n        }\n    }\n}","repo_id":"9","comment":"/**\n * A minimal helix is defined by two consecutive n-turns.\n * For example, a 4-helix, of minimal length 4 from residues\n * i to (i+3), requires turns (of type 4) at residues (i-1) and i.\n * <p>\n * Note that the orignal DSSP implementation does not assign\n * helix type to residue (i-1) and residue (i+n+1), although\n * they contain a helix turn. As they state in the original paper,\n * \"the helices are one residue shorter than they would be according\n * to rule 6.3 of IUPAC-IUB\".\n *\n * @param n\n * @param type\n */\n","repo_name":"biojava-master/","id":1604,"method_signature":"void checkSetHelix(int, SecStrucType)"}