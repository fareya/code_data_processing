{"callee_method_ids":[489,490,487,487],"callee_method_names":["AFPChain.getOptAln","AFPChain.getOptLen","AFPChain.getBlockNum","AFPChain.getBlockNum","List<Integer>.add","List<Integer>.add","List<List<Integer>>.add","List<List<Integer>>.add","List<List<List<Integer>>>.add"],"method_name":"AlignmentTools.getOptAlnAsList","method_implementation":"{\n    int[][][] optAln = afpChain.getOptAln();\n    int[] optLen = afpChain.getOptLen();\n    List<List<List<Integer>>> blocks = new ArrayList<List<List<Integer>>>(afpChain.getBlockNum());\n    for (int blockNum = 0; blockNum < afpChain.getBlockNum(); blockNum++) {\n        //TODO could improve speed an memory by wrapping the arrays with\n        // an unmodifiable list, similar to Arrays.asList(...) but with the\n        // correct size parameter.\n        List<Integer> align1 = new ArrayList<Integer>(optLen[blockNum]);\n        List<Integer> align2 = new ArrayList<Integer>(optLen[blockNum]);\n        for (int pos = 0; pos < optLen[blockNum]; pos++) {\n            align1.add(optAln[blockNum][0][pos]);\n            align2.add(optAln[blockNum][1][pos]);\n        }\n        List<List<Integer>> block = new ArrayList<List<Integer>>(2);\n        block.add(align1);\n        block.add(align2);\n        blocks.add(block);\n    }\n    return blocks;\n}","repo_id":"9","comment":"/**\n * Retrieves the optimum alignment from an AFPChain and returns it as a\n * java collection. The result is indexed in the same way as\n * {@link AFPChain#getOptAln()}, but has the correct size().\n * <pre>\n * List<List<List<Integer>>> aln = getOptAlnAsList(AFPChain afpChain);\n * aln.get(blockNum).get(structureNum={0,1}).get(pos)<\/pre>\n *\n * @param afpChain\n * @return\n */\n","repo_name":"biojava-master/","id":586,"method_signature":"List<List<List<Integer>>> getOptAlnAsList(AFPChain)"}