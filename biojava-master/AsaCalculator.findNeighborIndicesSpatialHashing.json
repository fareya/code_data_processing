{"callee_method_names":["Map<Integer, List<IndexAndDistance>>.containsKey","Map<Integer, List<IndexAndDistance>>.put","Map<Integer, List<IndexAndDistance>>.get","Map<Integer, List<IndexAndDistance>>.containsKey","Map<Integer, List<IndexAndDistance>>.put","Map<Integer, List<IndexAndDistance>>.get","List<IndexAndDistance>.add","List<IndexAndDistance>.add","Map<Integer, List<IndexAndDistance>>.entrySet","List<IndexAndDistance>.toArray"],"method_name":"AsaCalculator.findNeighborIndicesSpatialHashing","method_implementation":"{\n    // looking at a typical protein case, number of neighbours are from ~10 to ~50, with an average of ~30\n    int initialCapacity = 60;\n    List<Contact> contactList = calcContacts();\n    Map<Integer, List<IndexAndDistance>> indices = new HashMap<>(atomCoords.length);\n    for (Contact contact : contactList) {\n        // note contacts are stored 1-way only, with j>i\n        int i = contact.getI();\n        int j = contact.getJ();\n        List<IndexAndDistance> iIndices;\n        List<IndexAndDistance> jIndices;\n        if (!indices.containsKey(i)) {\n            iIndices = new ArrayList<>(initialCapacity);\n            indices.put(i, iIndices);\n        } else {\n            iIndices = indices.get(i);\n        }\n        if (!indices.containsKey(j)) {\n            jIndices = new ArrayList<>(initialCapacity);\n            indices.put(j, jIndices);\n        } else {\n            jIndices = indices.get(j);\n        }\n        double radius = radii[i] + probe + probe;\n        double dist = contact.getDistance();\n        if (dist < radius + radii[j]) {\n            iIndices.add(new IndexAndDistance(j, dist));\n            jIndices.add(new IndexAndDistance(i, dist));\n        }\n    }\n    // convert map to array for fast access\n    IndexAndDistance[][] nbsIndices = new IndexAndDistance[atomCoords.length][];\n    for (Map.Entry<Integer, List<IndexAndDistance>> entry : indices.entrySet()) {\n        List<IndexAndDistance> list = entry.getValue();\n        IndexAndDistance[] indexAndDistances = list.toArray(new IndexAndDistance[0]);\n        nbsIndices[entry.getKey()] = indexAndDistances;\n    }\n    // important: some atoms might have no neighbors at all: we need to initialise to empty arrays\n    for (int i = 0; i < nbsIndices.length; i++) {\n        if (nbsIndices[i] == null) {\n            nbsIndices[i] = new IndexAndDistance[0];\n        }\n    }\n    return nbsIndices;\n}","repo_id":"9","comment":"/**\n * Returns the 2-dimensional array with neighbor indices for every atom,\n * using spatial hashing to avoid all to all distance calculation.\n * @return 2-dimensional array of size: n_atoms x n_neighbors_per_atom\n */\n","repo_name":"biojava-master/","id":836,"method_signature":"IndexAndDistance[][] findNeighborIndicesSpatialHashing()"}