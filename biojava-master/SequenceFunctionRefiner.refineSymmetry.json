{"callee_method_names":["List<Integer>.isEmpty","Map<Integer, Double>.get","Map<Integer,Integer>.get","Map<Integer, Double>.put","Map<Integer, Double>.put","Map<Integer,Integer>.put","Map<Integer, Double>.size","Map<Integer, Double>.size","Map<Integer, Double>.keySet","Map<Integer, Double>.containsKey","Map<Integer, Double>.get","Map<Integer, Double>.get","Map<Integer, Double>.get","Map<Integer, Double>.get","Map<Integer,Integer>.keySet","Iterator<Integer>.hasNext","Iterator<Integer>.next","Map<Integer, Double>.get","Iterator<Integer>.remove"],"method_name":"SequenceFunctionRefiner.refineSymmetry","method_implementation":"{\n    // Store scores\n    Map<Integer, Double> scores = null;\n    scores = initializeScores(alignment, scores, k);\n    // Store eligible residues\n    // Eligible if:\n    //  1. score(x)>0\n    //  2. f^K-1(x) is defined\n    //\t3. score(f^K-1(x))>0\n    TreeSet<Integer> forwardLoops = new TreeSet<Integer>();\n    TreeSet<Integer> backwardLoops = new TreeSet<Integer>();\n    List<Integer> eligible = null;\n    eligible = initializeEligible(alignment, scores, eligible, k, forwardLoops, backwardLoops);\n    /* For future heap implementation\n\t\tComparator<Integer> scoreComparator = new Comparator<Integer>() {\n\t\t\t@Override public int compare(Integer o1, Integer o2) {\n\t\t\t\tif(scores.containsKey(o1)) {\n\t\t\t\t\tif(scores.containsKey(o2)) {\n\t\t\t\t\t\t// If both have defined scores, compare the scores\n\t\t\t\t\t\treturn scores.get(o1).compareTo(scores.get(o2));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// o2 has infinite score, so o1 < o2\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t//o1 has infinite score\n\t\t\t\t\tif(scores.containsKey(o2)) {\n\t\t\t\t\t\t// o1 > o2\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//both undefined\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tPriorityQueue<Integer> heap = new PriorityQueue<Integer>(alignment.size(), scoreComparator);\n\t\t */\n    //int step = 0;\n    while (!eligible.isEmpty()) {\n        //System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n        // Find eligible residue with lowest scores\n        Integer bestRes = null;\n        double bestResScore = Double.POSITIVE_INFINITY;\n        for (Integer res : eligible) {\n            Double score = scores.get(res);\n            if (score != null && score < bestResScore) {\n                bestResScore = score;\n                bestRes = res;\n            }\n        }\n        // Find f^k-1(bestRes)\n        Integer resK1 = bestRes;\n        for (int i = 0; i < k - 1; i++) {\n            assert (resK1 != null);\n            resK1 = alignment.get(resK1);\n            // Update scores\n            scores.put(resK1, 0.0);\n        }\n        scores.put(bestRes, 0.0);\n        // Modify alignment\n        alignment.put(resK1, bestRes);\n        scores = initializeScores(alignment, scores, k);\n        Map<Integer, Double> virginScores = initializeScores(alignment, null, k);\n        if (scores.size() != virginScores.size()) {\n            System.out.println(\"Size missmatch\");\n        } else {\n            for (Integer key : scores.keySet()) {\n                if (!virginScores.containsKey(key) || !scores.get(key).equals(virginScores.get(key))) {\n                    System.out.format(\"Mismatch %d -> %f/%f%n\", key, scores.get(key), virginScores.get(key));\n                }\n            }\n        }\n        // Update eligible\n        // TODO only update residues which could become ineligible\n        eligible = initializeEligible(alignment, scores, eligible, k, forwardLoops, backwardLoops);\n        // System.out.format(\"Modifying %d -> %d. %d now eligible.%n\", resK1,bestRes,eligible.size());\n    }\n    //System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n    // Remove remaining edges\n    Iterator<Integer> alignmentIt = alignment.keySet().iterator();\n    while (alignmentIt.hasNext()) {\n        Integer res = alignmentIt.next();\n        Double score = scores.get(res);\n        if (score == null || score > 0.0) {\n            alignmentIt.remove();\n        }\n    }\n    //System.out.format(\"Step %d: %s%n\", ++step, AlignmentTools.toConciseAlignmentString(alignment));\n    return alignment;\n}","repo_id":"9","comment":"/**\n * Refines a CE-Symm alignment so that it is perfectly symmetric.\n *\n * The resulting alignment will have a one-to-one correspondance between\n * aligned residues of each symmetric part.\n * @param alignment The input alignment, as a map. This will be modified.\n * @param k Symmetry order. This can be guessed by {@link CeSymm#getSymmetryOrder(AFPChain)}\n * @return A modified map with the refined alignment\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":2063,"method_signature":"Map<Integer,Integer> refineSymmetry(Map, int)"}