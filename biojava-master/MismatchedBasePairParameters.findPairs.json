{"callee_method_names":["List<Chain>.size","List<Chain>.get","Chain.getAtomSequence","String.length","List<Chain>.size","List<Chain>.get","Chain.getAtomSequence","Chain.getAtomSequence","Chain.getAtomSequence","Chain.getAtomSequence","String.charAt","String.charAt","Chain.getAtomGroup","Chain.getAtomGroup","Map<String, Integer>.get","Group.getPDBName","Map<String, Integer>.get","Group.getPDBName","Group.getAtom","Group.getAtom","Atom.getCoordsAsPoint3d","Atom.getCoordsAsPoint3d","List<Pair<Group>>.add","ArrayList.add","String.length","String.charAt","String.length","Chain.getAtomSequence"],"method_name":"MismatchedBasePairParameters.findPairs","method_implementation":"{\n    List<Pair<Group>> result = new ArrayList<>();\n    boolean lastFoundPair = false;\n    for (int i = 0; i < chains.size(); i++) {\n        Chain c = chains.get(i);\n        String sequence = c.getAtomSequence();\n        for (int m = 0; m < sequence.length(); m++) {\n            boolean foundPair = false;\n            Integer type1, type2;\n            for (int j = i + 1; j < chains.size() && !foundPair; j++) {\n                Chain c2 = chains.get(j);\n                if (j > i + 1 && c.getAtomSequence().equals(c2.getAtomSequence()) && nonredundant)\n                    continue;\n                String sequence2 = c2.getAtomSequence();\n                for (int k = c2.getAtomSequence().length() - 1; k >= 0 && !foundPair; k--) {\n                    if (canonical && !BasePairParameters.match(sequence.charAt(m), sequence2.charAt(k), useRNA))\n                        continue;\n                    Group g1 = c.getAtomGroup(m);\n                    Group g2 = c2.getAtomGroup(k);\n                    type1 = BASE_MAP.get(g1.getPDBName());\n                    type2 = BASE_MAP.get(g2.getPDBName());\n                    if (type1 == null || type2 == null)\n                        continue;\n                    Atom a1 = g1.getAtom(\"C1'\");\n                    Atom a2 = g2.getAtom(\"C1'\");\n                    if (a1 == null || a2 == null)\n                        continue;\n                    // C1'-C1' distance is one useful criteria\n                    if (Math.abs(a1.getCoordsAsPoint3d().distance(a2.getCoordsAsPoint3d()) - 10.0) > 4.0)\n                        continue;\n                    Pair<Group> ga = new Pair<>(g1, g2);\n                    // TODO is this call needed?? JD 2018-03-07\n                    @SuppressWarnings(\"unused\")\n                    Matrix4d data = basePairReferenceFrame(ga);\n                    // if the stagger is greater than 2 Ã…, it's not really paired.\n                    if (Math.abs(pairParameters[5]) > maxStagger)\n                        continue;\n                    // similarly, extreme shear and stretch is not a good base pair\n                    if (Math.abs(pairParameters[3]) > maxShear)\n                        continue;\n                    if (Math.abs(pairParameters[4]) > maxStretch)\n                        continue;\n                    // if the propeller is ridiculous it's also not that good of a pair.\n                    if (Math.abs(pairParameters[1]) > maxPropeller) {\n                        continue;\n                    }\n                    result.add(ga);\n                    pairingNames.add(useRNA ? BASE_LIST_RNA[type1] + BASE_LIST_RNA[type2] : BASE_LIST_DNA[type1] + BASE_LIST_DNA[type2]);\n                    foundPair = true;\n                }\n                if (!foundPair && lastFoundPair) {\n                    if (pairSequence.length() > 0 && pairSequence.charAt(pairSequence.length() - 1) != ' ')\n                        pairSequence += ' ';\n                }\n                if (foundPair)\n                    pairSequence += (c.getAtomSequence().charAt(i));\n                lastFoundPair = foundPair;\n            }\n        }\n    }\n    return result;\n}","repo_id":"9","comment":"/**\n * This is an implementation for finding non-canonical base pairs when there may be missing or overhanging bases.\n * @param chains The list of chains already found to be nucleic acids.\n * @return The list of the atom groups (residues) that are pairs, as a Pair of nucleic acid Groups.\n */\n","repo_name":"biojava-master/","id":1751,"method_signature":"List<Pair<Group>> findPairs(List)"}