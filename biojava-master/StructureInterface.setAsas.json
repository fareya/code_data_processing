{"callee_method_ids":[832],"callee_method_names":["AsaCalculator.calculateAsas","Atom[].getGroup","Group.getType","Map<ResidueNumber, GroupAsa>.containsKey","Group.getResidueNumber","GroupAsa.addAtomAsaU","GroupAsa.addAtomAsaC","Map<ResidueNumber, GroupAsa>.put","Group.getResidueNumber","Map<ResidueNumber, GroupAsa>.get","Group.getResidueNumber","GroupAsa.addAtomAsaU","GroupAsa.addAtomAsaC","Atom[].getGroup","Group.getType","Map<ResidueNumber, GroupAsa>.containsKey","Group.getResidueNumber","GroupAsa.addAtomAsaU","GroupAsa.addAtomAsaC","Map<ResidueNumber, GroupAsa>.put","Group.getResidueNumber","Map<ResidueNumber, GroupAsa>.get","Group.getResidueNumber","GroupAsa.addAtomAsaU","GroupAsa.addAtomAsaC"],"method_name":"StructureInterface.setAsas","method_implementation":"{\n    Atom[] atoms = getAtomsForAsa(cofactorSizeToUse);\n    AsaCalculator asaCalc = new AsaCalculator(atoms, AsaCalculator.DEFAULT_PROBE_SIZE, nSpherePoints, nThreads);\n    double[] complexAsas = asaCalc.calculateAsas();\n    if (complexAsas.length != asas1.length + asas2.length)\n        throw new IllegalArgumentException(\"The size of ASAs of complex doesn't match that of ASAs 1 + ASAs 2\");\n    groupAsas1 = new TreeMap<>();\n    groupAsas2 = new TreeMap<>();\n    this.totalArea = 0;\n    for (int i = 0; i < asas1.length; i++) {\n        Group g = atoms[i].getGroup();\n        if (!g.getType().equals(GroupType.HETATM) || isInChain(g)) {\n            // interface area should be only for protein/nucleotide but not hetatoms that are not part of the chain\n            this.totalArea += (asas1[i] - complexAsas[i]);\n        }\n        if (!groupAsas1.containsKey(g.getResidueNumber())) {\n            GroupAsa groupAsa = new GroupAsa(g);\n            groupAsa.addAtomAsaU(asas1[i]);\n            groupAsa.addAtomAsaC(complexAsas[i]);\n            groupAsas1.put(g.getResidueNumber(), groupAsa);\n        } else {\n            GroupAsa groupAsa = groupAsas1.get(g.getResidueNumber());\n            groupAsa.addAtomAsaU(asas1[i]);\n            groupAsa.addAtomAsaC(complexAsas[i]);\n        }\n    }\n    for (int i = 0; i < asas2.length; i++) {\n        Group g = atoms[i + asas1.length].getGroup();\n        if (!g.getType().equals(GroupType.HETATM) || isInChain(g)) {\n            // interface area should be only for protein/nucleotide but not hetatoms that are not part of the chain\n            this.totalArea += (asas2[i] - complexAsas[i + asas1.length]);\n        }\n        if (!groupAsas2.containsKey(g.getResidueNumber())) {\n            GroupAsa groupAsa = new GroupAsa(g);\n            groupAsa.addAtomAsaU(asas2[i]);\n            groupAsa.addAtomAsaC(complexAsas[i + asas1.length]);\n            groupAsas2.put(g.getResidueNumber(), groupAsa);\n        } else {\n            GroupAsa groupAsa = groupAsas2.get(g.getResidueNumber());\n            groupAsa.addAtomAsaU(asas2[i]);\n            groupAsa.addAtomAsaC(complexAsas[i + asas1.length]);\n        }\n    }\n    // our interface area definition: average of bsa of both molecules\n    this.totalArea = this.totalArea / 2.0;\n}","repo_id":"9","comment":"/**\n * Set ASA annotations by passing the uncomplexed ASA values of the 2 partners.\n * This will calculate complexed ASA and set the ASA values in the member variables.\n * @param asas1 ASA values for atoms of partner 1\n * @param asas2 ASA values for atoms of partner 2\n * @param nSpherePoints the number of sphere points to be used for complexed ASA calculation\n * @param nThreads the number of threads to be used for complexed ASA calculation\n * @param cofactorSizeToUse the minimum size of cofactor molecule (non-chain HET atoms) that will be used in ASA calculation\n */\n","repo_name":"biojava-master/","id":876,"method_signature":"void setAsas(double[], double[], int, int, int)"}