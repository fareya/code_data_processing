{"callee_method_names":["List<Atom[]>.size","List<Atom[]>.get","List<Atom[]>.get","List<Atom[]>.get","List<Atom[]>.get","Matrix.get","Matrix.set","Matrix.set","Matrix.get","Matrix.get","Matrix.set","Matrix.set","Matrix.get","Matrix.get","Matrix.get","Matrix.set","Matrix.get","Matrix.get","Matrix.get"],"method_name":"MultipleAlignmentScorer.getMCScore","method_implementation":"{\n    int size = trans.size();\n    int length = trans.get(0).length;\n    Matrix residueDistances = new Matrix(size, length, -1);\n    double scoreMC = 0.0;\n    int openGaps = 0;\n    int extensionGaps = 0;\n    // Calculate the average residue distances\n    for (int r1 = 0; r1 < size; r1++) {\n        boolean gapped = false;\n        for (int c = 0; c < trans.get(r1).length; c++) {\n            Atom refAtom = trans.get(r1)[c];\n            // Calculate the gap extension and opening on the fly\n            if (refAtom == null) {\n                if (gapped)\n                    extensionGaps++;\n                else {\n                    gapped = true;\n                    openGaps++;\n                }\n                continue;\n            } else\n                gapped = false;\n            for (int r2 = r1 + 1; r2 < size; r2++) {\n                Atom atom = trans.get(r2)[c];\n                if (atom != null) {\n                    double distance = Calc.getDistance(refAtom, atom);\n                    if (residueDistances.get(r1, c) == -1) {\n                        residueDistances.set(r1, c, 1 + distance);\n                    } else {\n                        residueDistances.set(r1, c, residueDistances.get(r1, c) + distance);\n                    }\n                    if (residueDistances.get(r2, c) == -1) {\n                        residueDistances.set(r2, c, 1 + distance);\n                    } else {\n                        residueDistances.set(r2, c, residueDistances.get(r2, c) + distance);\n                    }\n                }\n            }\n        }\n    }\n    for (int c = 0; c < length; c++) {\n        int nonNullRes = 0;\n        for (int r = 0; r < size; r++) {\n            if (residueDistances.get(r, c) != -1)\n                nonNullRes++;\n        }\n        for (int r = 0; r < size; r++) {\n            if (residueDistances.get(r, c) != -1) {\n                residueDistances.set(r, c, residueDistances.get(r, c) / nonNullRes);\n            }\n        }\n    }\n    // Sum all the aligned residue scores\n    for (int row = 0; row < size; row++) {\n        for (int col = 0; col < length; col++) {\n            if (residueDistances.get(row, col) == -1)\n                continue;\n            double d1 = residueDistances.get(row, col);\n            double resScore = 20.0 / (1 + (d1 * d1) / (d0 * d0));\n            scoreMC += resScore - A;\n        }\n    }\n    // Apply the Gap penalty and return\n    return scoreMC - (openGaps * gapOpen + extensionGaps * gapExtension);\n}","repo_id":"9","comment":"/**\n * Calculates the MC score, specific for the MultipleAlignment algorithm.\n * The score function is modified from the original CEMC paper, making it\n * continuous and differentiable.\n * <p>\n * The maximum score of a match is 20, and the penalties for gaps are part\n * of the input.\n * <p>\n * Complexity: T(n,l) = O(l*n^2), if n=number of structures and l=alignment\n * length.\n *\n * @param transformed\n *            List of transformed Atom arrays\n * @param d0\n *            parameter for the half-score distance\n * @param gapOpen\n *            penalty for gap opening (reasonable values are in the range\n *            (1.0-20.0)\n * @param gapExtension\n *            penalty for extending a gap (reasonable values are in the\n *            range (0.5-10.0)\n * @param A\n *            the distance cutoff penalization\n * @return the value of the score\n * @throws StructureException\n */\n","repo_name":"biojava-master/","id":687,"method_signature":"double getMCScore(List, double, double, double, double)"}