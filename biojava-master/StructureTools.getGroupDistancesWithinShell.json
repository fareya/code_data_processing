{"callee_method_names":["Structure.getChains","Chain.getAtomGroups","ResidueNumber.equals","Map<Group, Double>.containsKey","Map<Group, Double>.put","Map<Group, Double>.put","Map<Group, Double>.get","Map<Group, Integer>.containsKey","Map<Group, Integer>.put","Map<Group, Integer>.put","Map<Group, Integer>.get","Map<Group, Double>.get","Map<Group, Double>.put","Map<Group, Double>.entrySet","Map<Group, Integer>.get","Map.Entry<ResidueNumber, Integer>.getKey","Map<Group, Double>.put","Map.Entry<ResidueNumber, Integer>.getKey","Map.Entry<ResidueNumber, Integer>.getValue","Map<Group, Double>.replaceAll"],"method_name":"StructureTools.getGroupDistancesWithinShell","method_implementation":"{\n    // for speed, we avoid calculating square roots\n    radius = radius * radius;\n    Map<Group, Double> distances = new HashMap<Group, Double>();\n    // we only need this if we're averaging distances\n    // note that we can't use group.getAtoms().size() because some the\n    // group's atoms be outside the shell\n    Map<Group, Integer> atomCounts = new HashMap<Group, Integer>();\n    for (Chain chain : structure.getChains()) {\n        groupLoop: for (Group chainGroup : chain.getAtomGroups()) {\n            // exclude water\n            if (!includeWater && chainGroup.isWater())\n                continue;\n            // check blacklist of residue numbers\n            for (ResidueNumber rn : excludeResidues) {\n                if (rn.equals(chainGroup.getResidueNumber()))\n                    continue groupLoop;\n            }\n            for (Atom testAtom : chainGroup.getAtoms()) {\n                // use getDistanceFast as we are doing a lot of comparisons\n                double dist = Calc.getDistanceFast(centroid, testAtom);\n                // if we're the shell\n                if (dist <= radius) {\n                    if (!distances.containsKey(chainGroup))\n                        distances.put(chainGroup, Double.POSITIVE_INFINITY);\n                    if (useAverageDistance) {\n                        // sum the distance; we'll divide by the total\n                        // number later\n                        // here, we CANNOT use fastDistance (distance\n                        // squared) because we want the arithmetic mean\n                        distances.put(chainGroup, distances.get(chainGroup) + Math.sqrt(dist));\n                        if (!atomCounts.containsKey(chainGroup))\n                            atomCounts.put(chainGroup, 0);\n                        atomCounts.put(chainGroup, atomCounts.get(chainGroup) + 1);\n                    } else {\n                        // take the minimum distance among all atoms of\n                        // chainGroup\n                        // note that we can't break here because we might\n                        // find a smaller distance\n                        if (dist < distances.get(chainGroup)) {\n                            distances.put(chainGroup, dist);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (useAverageDistance) {\n        for (Map.Entry<Group, Double> entry : distances.entrySet()) {\n            int count = atomCounts.get(entry.getKey());\n            distances.put(entry.getKey(), entry.getValue() / count);\n        }\n    } else {\n        // in this case we used getDistanceFast\n        distances.replaceAll((k, v) -> Math.sqrt(v));\n    }\n    return distances;\n}","repo_id":"9","comment":"/**\n * Finds Groups in {@code structure} that contain at least one Atom that is\n * within {@code radius} Angstroms of {@code centroid}.\n *\n * @param structure\n *            The structure from which to find Groups\n * @param centroid\n *            The centroid of the shell\n * @param excludeResidues\n *            A list of ResidueNumbers to exclude\n * @param radius\n *            The radius from {@code centroid}, in Angstroms\n * @param includeWater\n *            Whether to include Groups whose <em>only<\/em> atoms are water\n * @param useAverageDistance\n *            When set to true, distances are the arithmetic mean (1-norm)\n *            of the distances of atoms that belong to the group and that\n *            are within the shell; otherwise, distances are the minimum of\n *            these values\n * @return A map of Groups within (or partially within) the shell, to their\n *         distances in Angstroms\n */\n","repo_name":"biojava-master/","id":1053,"method_signature":"Map<Group,Double> getGroupDistancesWithinShell(Structure, Atom, Set, double, boolean, boolean)"}