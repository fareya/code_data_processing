{"callee_method_ids":[489,490,487],"callee_method_names":["AFPChain.getOptAln","AFPChain.getOptLen","AFPChain.getBlockNum"],"method_name":"AlignmentTools.isSequentialAlignment","method_implementation":"{\n    int[][][] optAln = afpChain.getOptAln();\n    int[] alnLen = afpChain.getOptLen();\n    int blocks = afpChain.getBlockNum();\n    //trivial case\n    if (blocks < 1)\n        return true;\n    if (alnLen[0] < 1)\n        return true;\n    // Check that blocks are sequential\n    if (checkWithinBlocks) {\n        for (int block = 0; block < blocks; block++) {\n            //skip empty blocks\n            if (alnLen[block] < 1)\n                continue;\n            int prevRes1 = optAln[block][0][0];\n            int prevRes2 = optAln[block][1][0];\n            for (int pos = 1; pos < alnLen[block]; pos++) {\n                int currRes1 = optAln[block][0][pos];\n                int currRes2 = optAln[block][1][pos];\n                if (currRes1 < prevRes1) {\n                    return false;\n                }\n                if (currRes2 < prevRes2) {\n                    return false;\n                }\n                prevRes1 = currRes1;\n                prevRes2 = currRes2;\n            }\n        }\n    }\n    // Check that blocks are sequential\n    int prevRes1 = optAln[0][0][alnLen[0] - 1];\n    int prevRes2 = optAln[0][1][alnLen[0] - 1];\n    for (int block = 1; block < blocks; block++) {\n        //skip empty blocks\n        if (alnLen[block] < 1)\n            continue;\n        if (optAln[block][0][0] < prevRes1) {\n            return false;\n        }\n        if (optAln[block][1][0] < prevRes2) {\n            return false;\n        }\n        prevRes1 = optAln[block][0][alnLen[block] - 1];\n        prevRes2 = optAln[block][1][alnLen[block] - 1];\n    }\n    return true;\n}","repo_id":"9","comment":"/**\n * Checks that the alignment given by afpChain is sequential. This means\n * that the residue indices of both proteins increase monotonically as\n * a function of the alignment position (ie both proteins are sorted).\n *\n * This will return false for circularly permuted alignments or other\n * non-topological alignments. It will also return false for cases where\n * the alignment itself is sequential but it is not stored in the afpChain\n * in a sorted manner.\n *\n * Since algorithms which create non-sequential alignments split the\n * alignment into multiple blocks, some computational time can be saved\n * by only checking block boundaries for sequentiality. Setting\n * <tt>checkWithinBlocks<\/tt> to <tt>true<\/tt> makes this function slower,\n * but detects AFPChains with non-sequential blocks.\n *\n * Note that this method should give the same results as\n * {@link AFPChain#isSequentialAlignment()}. However, the AFPChain version\n * relies on the StructureAlignment algorithm correctly setting this\n * parameter, which is sadly not always the case.\n *\n * @param afpChain An alignment\n * @param checkWithinBlocks Indicates whether individual blocks should be\n * \tchecked for sequentiality\n * @return True if the alignment is sequential.\n */\n","repo_name":"biojava-master/","id":578,"method_signature":"boolean isSequentialAlignment(AFPChain, boolean)"}