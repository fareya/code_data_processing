{"callee_method_ids":[1400],"callee_method_names":["PdbId.getId","Logger.error","String.split"],"method_name":"StructureName.getBaseIdentifier","method_implementation":"{\n    if (base == null) {\n        switch(mySource) {\n            case CATH:\n                base = CathFactory.getCathDatabase().getDescriptionByCathId(getIdentifier());\n                break;\n            case ECOD:\n                try {\n                    base = EcodFactory.getEcodDatabase().getDomainsById(name);\n                } catch (IOException e) {\n                    throw new StructureException(\"Unable to get ECOD domain \" + name, e);\n                }\n                break;\n            case SCOP:\n                // Fuzzy matching of the domain name to the current default factory\n                base = guessScopDomain(getIdentifier(), ScopFactory.getSCOP());\n                if (base == null) {\n                    // Guessing didn't work, so just use the PDBID and Chain from name\n                    // Guess that '_' means 'whole structure'\n                    if (\"_\".equals(chainName)) {\n                        base = new SubstructureIdentifier(pdbId.getId());\n                    } else {\n                        base = new SubstructureIdentifier(pdbId, ResidueRange.parseMultiple(chainName));\n                    }\n                    logger.error(\"Unable to find {}, so using {}\", name, base);\n                }\n                break;\n            case FILE:\n                try {\n                    String[] prefix = name.split(\":\", 2);\n                    String filename;\n                    if (prefix.length > 1) {\n                        filename = prefix[1];\n                    } else {\n                        filename = name;\n                    }\n                    filename = FileDownloadUtils.expandUserHome(filename);\n                    base = new URLIdentifier(new File(filename).toURI().toURL());\n                } catch (MalformedURLException e) {\n                    // Should never happen\n                    throw new StructureException(\"Unable to get URL for file: \" + name, e);\n                }\n                break;\n            case URL:\n                try {\n                    base = new URLIdentifier(name);\n                } catch (MalformedURLException e) {\n                    throw new StructureException(\"Invalid URL: \" + name, e);\n                }\n                break;\n            case BIO:\n                base = new BioAssemblyIdentifier(name);\n                break;\n            case PDB:\n                base = new SubstructureIdentifier(getIdentifier());\n                break;\n            default:\n                throw new IllegalStateException(\"Unimplemented source: \" + mySource);\n        }\n    }\n    return base;\n}","repo_id":"9","comment":"/**\n * StructureName wraps another StructureIdentifier. The type of the base\n * identifier depends on the {@link #getSource() source}. Most StructureName\n * methods deligate to the base identifier.\n *\n * <p>It is possible that future versions of StructureName might change the\n * return type. Except for some specialized uses, it is probably better\n * to create the correct type of identifier directly, rather than creating\n * a StructureName and casting the result of this method.\n * @return A Str\n * @throws StructureException Wraps exceptions that may be thrown by\n *  individual implementations. For example, a SCOP identifier may require\n *  that the domain definitions be available for download.\n */\n","repo_name":"biojava-master/","id":469,"method_signature":"StructureIdentifier getBaseIdentifier()"}