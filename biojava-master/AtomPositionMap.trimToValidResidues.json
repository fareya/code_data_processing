{"callee_method_names":["ResidueRange.getStart","ResidueRange.getEnd","ResidueRange.getChainName","ResidueNumber.getChainName","ResidueNumber.getSeqNum","ResidueNumber.getInsCode","ResidueNumber.getChainName","ResidueNumber.getSeqNum","ResidueNumber.getInsCode","TreeMap<ResidueNumber, Integer>.keySet","Key.getChainName","ResidueNumber.getSeqNum","Key.getSeqNum","Logger.error","Logger.warn","ResidueRange.getStart","TreeMap<ResidueNumber, Integer>.descendingKeySet","Key.getChainName","ResidueNumber.getSeqNum","Key.getSeqNum","Logger.error","Logger.warn","ResidueRange.getEnd"],"method_name":"AtomPositionMap.trimToValidResidues","method_implementation":"{\n    ResidueNumber start = rr.getStart();\n    ResidueNumber end = rr.getEnd();\n    String chain = rr.getChainName();\n    // Add chainName\n    if (start.getChainName() == null) {\n        start = new ResidueNumber(chain, start.getSeqNum(), start.getInsCode());\n    }\n    if (end.getChainName() == null) {\n        end = new ResidueNumber(chain, end.getSeqNum(), end.getInsCode());\n    }\n    // Check that start and end are present in the map.\n    // If not, try to find the next valid residue\n    // (terminal residues sometimes lack CA atoms, so they don't appear)\n    Integer startIndex = getPosition(start);\n    if (startIndex == null) {\n        // Assume that the residue numbers are sequential\n        // Find startIndex such that the SeqNum is bigger than start's seqNum\n        for (ResidueNumber key : treeMap.keySet()) {\n            if (!key.getChainName().equals(chain))\n                continue;\n            if (start.getSeqNum() <= key.getSeqNum()) {\n                start = key;\n                startIndex = getPosition(key);\n                break;\n            }\n        }\n        if (startIndex == null) {\n            logger.error(\"Unable to find Residue {} in AtomPositionMap, and no plausible substitute.\", start);\n            return null;\n        } else {\n            logger.warn(\"Unable to find Residue {}, so substituting {}.\", rr.getStart(), start);\n        }\n    }\n    Integer endIndex = getPosition(end);\n    if (endIndex == null) {\n        // Assume that the residue numbers are sequential\n        // Find startIndex such that the SeqNum is bigger than start's seqNum\n        for (ResidueNumber key : treeMap.descendingKeySet()) {\n            if (!key.getChainName().equals(chain))\n                continue;\n            Integer value = getPosition(key);\n            if (value < startIndex) {\n                // start is before the end!\n                break;\n            }\n            if (end.getSeqNum() >= key.getSeqNum()) {\n                end = key;\n                endIndex = value;\n                break;\n            }\n        }\n        if (endIndex == null) {\n            logger.error(\"Unable to find Residue {} in AtomPositionMap, and no plausible substitute.\", end);\n            return null;\n        } else {\n            logger.warn(\"Unable to find Residue {}, so substituting {}.\", rr.getEnd(), end);\n        }\n    }\n    // now use those to calculate the length\n    // if start or end is null, will throw NPE\n    int length = getLength(startIndex, endIndex, chain);\n    return new ResidueRangeAndLength(chain, start, end, length);\n}","repo_id":"9","comment":"/**\n * Trims a residue range so that both endpoints are contained in this map.\n * @param rr residue range\n * @return residue range and length\n */\n","repo_name":"biojava-master/","id":1010,"method_signature":"ResidueRangeAndLength trimToValidResidues(ResidueRange)"}